@ROUT l3time_pt
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <assert.h>
#include "atlas_misc.h"
#include "atlas_tst.h"
#include "atlas_level3.h"
#include "atlas_threads.h"
#define ATL_GETFLAGS 1
#include "atlas_genparse.h"

#ifdef TCPLX
   #define NBLAS 2
#else
   #define NBLAS 2
#endif
enum eblas{Bgemm, Btrsm, Bsymm, Bsyrk, Bsyr2k, Btrmm, Bhemm, Bherk, Bher2k};
char *nblas[]={"gemm", "trsm"};

#ifdef TCPLX

   #define t_gemm(S_, U_, TA_, TB_, M_, N_, K_, al_, A_, LDA_, B_, LDB_, be_, C_, LDC_) \
      Mjoin(PATL,gemm)(TA_, TB_, M_, N_, K_, al_, A_, LDA_, B_, LDB_, be_, C_, LDC_);
   #define t_trsm(S_, U_, TA_, D_, M_, N_, al_, A_, LDA_, B_, LDB_, be_) \
      Mjoin(PATL,trsm)(S_, U_, TA_, D_, M_, N_, al_, A_, LDA_, B_, LDB_);

#else

   #define t_gemm(S_, U_, TA_, TB_, M_, N_, K_, al_, A_, LDA_, B_, LDB_, be_, C_, LDC_) \
      Mjoin(PATL,gemm)(TA_, TB_, M_, N_, K_, *al_, A_, LDA_, B_, LDB_, *be_, C_, LDC_);
   #define t_trsm(S_, U_, TA_, D_, M_, N_, al_, A_, LDA_, B_, LDB_, be_) \
      Mjoin(PATL,trsm)(S_, U_, TA_, D_, M_, N_, *al_, A_, LDA_, B_, LDB_);

#endif

void PrintUsage(char *name, int ierr, char *flag);

int *RoutNames2IntList(int nargs, char **args, int i)
{
   int n, *iarr, k;

   if (++i >= nargs)
      PrintUsage(args[0], i, NULL);
   n = atoi(args[i]);
   ATL_assert(n > 0);
   iarr = malloc(sizeof(int)*(n+1));
   ATL_assert(iarr);

   iarr[0] = n;
   for (k=0; k < n; k++)
   {
      int b;
      if (++i >= nargs)
         PrintUsage(args[0], i, NULL);
      for (b=0; b < NBLAS; b++)
      {
         if (!strcmp(args[i], nblas[b]))
         {
            iarr[k+1] = b;
            break;
         }
      }
      if (b == NBLAS)
         PrintUsage(args[0], i, args[i]);
   }
   return(iarr);
}
void PrintUsage(char *name, int ierr, char *flag)
{
   if (ierr > 0)
      fprintf(stderr, "Bad argument #%d: '%s'\n",
              ierr, flag ? flag : "Not enough arguments");
   else if (ierr < 0)
      fprintf(stderr, "ERROR: %s\n", flag);

   fprintf(stderr, "USAGE: %s [flags]:\n", name);
   fprintf(stderr, "   -R <#> <rout1> ... <rout#>\n");
   fprintf(stderr, "   -R <rout1/all>\n");
   fprintf(stderr, "      routs: ger, gerc, ger2, gemv, trmv, trsv\n");
   fprintf(stderr, "             syr, syr2 \n");
   fprintf(stderr, "   -A <#> <ta1> ... <ta#> : Vals: [n,t,c]\n");
   fprintf(stderr, "   -B <#> <tb1> ... <tb#> : Vals: [n,t,c]\n");
   fprintf(stderr, "   -U <#> <up1> ... <up#> : Vals: [u,l]\n");
   fprintf(stderr, "   -D <#> <dia1> ... <dia#> : Vals: [u,n]\n");
   fprintf(stderr, "   -S <#> <sd1> ... <sd#> : Vals: [l,r]\n");
   fprintf(stderr, "   -# <#> : repeat each timing # times\n");
   fprintf(stderr, "   -t <#> : use # of threads (with affinity)\n");
   fprintf(stderr, "   -tl <#> id1 ... id#: use # threads on given IDs\n");
   fprintf(stderr, "   -n <#> <N1> ... <N#>\n");
   fprintf(stderr, "   -N <Nstart> <Nend> <Ninc>\n");
   fprintf(stderr, "   -m <#> <M1> ... <M#>\n");
   fprintf(stderr, "   -M <Mstart> <Mend> <Minc>\n");
   fprintf(stderr, "   -k <#> <K1> ... <K#>\n");
   fprintf(stderr, "   -K <Kstart> <Kend> <Kinc>\n");
   fprintf(stderr, "   -a <#> <alpha1> ... <alphaN> : real/complex floats\n");
   fprintf(stderr, "   -b <#> <beta1> ... <betaN> : real/complex floats\n");
   fprintf(stderr, "   -G[a,b,c] <#> : ld[a,b,c]gap, i.e.lda = M + <gap>\n");
   fprintf(stderr, "   -F <mflop> : force <mflops> of timed computation\n");
   fprintf(stderr, "   -f <flushKB> : flush at least this mem in LRU timers\n");
   exit(ierr ? ierr : -1);
}

unsigned long GetFlags
   (int nargs, char **args, int *nreps, int *frcMF, int *ldaG, int *ldbG, 
   int *ldcG, int **Ms, int **Ns, int **Ks, int **ROUTs, int **TAs, int **TBs, 
   double **ALPs, double **BETs, int **UPLOs, int **DIs, int **SDs, 
   int *p, int **pids)
{
   int i, j, n, *ip;
   unsigned long flushKB;

   *nreps = 1;
   *frcMF = *ldaG = *ldbG = *ldcG = 0;
   *ALPs = *BETs = NULL;
   *UPLOs = *DIs = *SDs = *TAs = *TBs = NULL;
   *ROUTs = *Ms = *Ns = *Ks = NULL;
   *p = 1;
   *pids = NULL;
   #ifdef L2SIZE
      flushKB = L2SIZE / 1024;
   #else
      flushKB = 32*1024;
   #endif
   for (i=1; i < nargs; i++)
   {
      if (args[i][0] != '-')
         PrintUsage(args[0], i, args[i]);
      switch(args[i][1])
      {
      case 't':
         switch(args[i][2])
         {
         case '\0':                      /* -t <#> */
            if (++i >= nargs)
               PrintUsage(args[0], i, NULL);
            *p = atoi(args[i]);
            break;
         case 'l':                       /* -tl # id1 ... id# */
            if (++i >= nargs)
               PrintUsage(args[0], i, NULL);
            *p = atoi(args[i]);
            *pids = malloc(sizeof(int)*(*p));
            assert(*pids);
            for (j=0; j < (*p); j++)
            {
               if (++i >= nargs)
                  PrintUsage(args[0], i, "out of arguments");
               (*pids)[j] = atoi(args[i]);
            }
            break;
         default:
            PrintUsage(args[0], i, args[i]);
         }
         break;
      @multidef VR UPLO SD   DI   TB     TA
      @multidef cm up   sd   dia  tb     ta
      @multidef CM u,l  r,l  u,n  n,t,c  n,t,c
      @whiledef vr U S D B A
      case '@(vr)':              /* -@(vr) <#> <@(cm)1 ... <@(cm)#>; [@(CM)] */
         if (++i >= nargs)
            PrintUsage(args[0], i, NULL);
         n = atoi(args[i]);
         ATL_assert(n > 0);
         ip = malloc(sizeof(int)*(n+1));
         assert(ip);
         ip[0] = n;
         for (j=0; j<n; j++)
         {
            if (++i >= nargs)
               PrintUsage(args[0], i, NULL);
            switch(args[i][0])
            {
            @mif vr = "U
               @multidef iVAL U L
               @multidef VL AtlasUpper AtlasLower
            @endmif
            @mif vr = "S
               @multidef iVAL R L
               @multidef VL AtlasRight AtlasLeft
            @endmif
            @mif vr = "D
               @multidef iVAL U N
               @multidef VL AtlasUnit AtlasNonUnit
            @endmif
            @mif vr = "B
               @multidef iVAL N T C
               @multidef VL AtlasNoTrans AtlasTrans AtlasConjTrans
            @endmif
            @mif vr = "A
               @multidef iVAL N T C
               @multidef VL AtlasNoTrans AtlasTrans AtlasConjTrans
            @endmif
            @whiledef iVAL
            case '@low@(iVAL)':
            case '@(iVAL)':
               ip[j+1] = @(VL);
               break;
               @undef VL
            @endwhile
            }
         }
         *@(VR)s = ip;
         break;
         @undef cm
         @undef VR
      @endwhile
      case 'G':                          /* -G[a,b,c] <ld[a,b,c]gap> */
         if (++i >= nargs)
            PrintUsage(args[0], i, NULL);
         if (args[i-1][2] == 'b')
            *ldbG = atoi(args[i]);
         else if (args[i-1][2] == 'c')
            *ldcG = atoi(args[i]);
         else
            *ldaG = atoi(args[i]);
         break;
      case 'F':                          /* -F <mflop> */
         if (++i >= nargs)
            PrintUsage(args[0], i, NULL);
         *frcMF = atoi(args[i]);
         break;
      case 'f':                          /* -f <flushKB> */
         if (++i >= nargs)
            PrintUsage(args[0], i, NULL);
         flushKB = atol(args[i]);
         break;
      case '#':                          /* -# <reps> */
         if (++i >= nargs)
            PrintUsage(args[0], i, NULL);
         *nreps = atoi(args[i]);
         break;
   @multidef fl a   b
   @whiledef vr ALP BET
      case '@(fl)':   /* -@(fl) # @(vr)0 ... @(vr)# */
         *@(vr)s = GF_GetDoubleList(nargs, args, i, 1 SHIFT);
         break;
         @undef fl
   @endwhile
   @multidef fl M N K
   @whiledef vr M N K
      case '@low@(fl)':   /* -@low@(fl) # @(vr)0 ... @(vr)# */
         *@(vr)s = GF_GetIntList(nargs, args, i, 1);
         i += (*@(vr)s)[0] + 1;
         break;
      case '@(fl)':   /* -@(fl) @(vr)0 @(vr)N @(vr)inc */
         if (i+3 >= nargs)
            PrintUsage(args[0], i, NULL);
         *@(vr)s = GF_IntRange2IntList(atoi(args[i+1]), atoi(args[i+2]),
                   atoi(args[i+3]));
         break;
         @undef fl
   @endwhile
      case 'R':        /* -R # <rout1> ... <routN#>  */
         if (i+1 >= nargs)
            PrintUsage(args[0], i, "out of args to -R");
         if (isdigit(args[i+1][0]))
         {
            *ROUTs = RoutNames2IntList(nargs, args, i);
            i += (*ROUTs)[0] + 1;
         }
         else if (!strcmp(args[++i], "all"))  /* want them all */
            *ROUTs = GF_IntRange2IntList(Bgemm, NBLAS-1, 1);
         else  /* only giving one name */
         {
            int k;
            for (k=0; k < NBLAS; k++)
               if (!strcmp(args[i], nblas[k]))
                  break;
            if (k == NBLAS)
              PrintUsage(args[0], i,
                         "Unknown blas name to -R: is it lower case?");
            *ROUTs = GF_GetIntList1(k);
         }
         break;
      default:
         PrintUsage(args[0], i, args[i]);
      }
   }
   @multidef v Bgemm AtlasNoTrans AtlasNoTrans AtlasLower AtlasLeft AtlasNonUnit
   @whiledef vr ROUT TA TB UPLO SD DI
   if (*@(vr)s == NULL)
      *@(vr)s = GF_GetIntList1(@(v));
      @undef v
   @endwhile
   if (*Ms == NULL && *Ns == NULL && *Ks == NULL)
   {
      *Ms = GF_GetIntList1(0);
      *Ns = GF_GetIntList1(1000);
      *Ks = GF_GetIntList1(0);
   }
   if (*Ns == NULL)
   {
      if (*Ms)
      {
         *Ns = GF_DupIntList(*Ms);
         free(*Ms);
         *Ms = GF_GetIntList1(0);
      }
      else if (*Ks)
      {
         *Ns = GF_DupIntList(*Ks);
         free(*Ks);
         *Ks = GF_GetIntList1(0);
      }
   }
   if (*Ms == NULL)
      *Ms = GF_GetIntList1(0);
   if (*Ks == NULL)
      *Ks = GF_GetIntList1(0);
   #ifdef TCPLX
   @whiledef vr ALP BET
      if (*@(vr)s == NULL)
      {
         *@(vr)s = malloc(3*sizeof(double));
         assert(*@(vr)s);
         (*@(vr)s)[0] = 1;
         (*@(vr)s)[1] = 2.0;
         (*@(vr)s)[2] = 0.5;
      }
   @endwhile
   #else
   @whiledef vr ALP BET
      if (*@(vr)s == NULL)
      {
         *@(vr)s = malloc(2*sizeof(double));
         assert(*@(vr)s);
         (*@(vr)s)[0] = 1;
         (*@(vr)s)[1] = 0.75;
      }
   @endwhile
   #endif
   if (*pids == NULL)
   {
      *pids = malloc(sizeof(int)*(*p));
      assert(*pids);
      for (j=0; j < (*p); j++)
      {
         (*pids)[j] = j;
      }
   }
   return(flushKB);
}


double opbl3
(
   enum eblas  rt,
   const int   M,
   const int   N,
   const int   K
)
{
   double                     adds = 0.0, muls = 0.0, em, en, ek;

   if( M <= 0 || N <= 0 ) return( 0.0 );

   em = (double)(M);
   en = (double)(N);
   ek = (double)(K);

   if ( rt == Bgemm ) { muls = em * en * ek; adds = em * en * ek; }
   else if ( rt == Btrsm )
   {
      if ( K <= 0 ) { muls = em*en*(em+1.0)/2.0; adds = em*en*(em-1.0)/2.0; }
      else { muls = em*en*(en+1.0)/2.0; adds = em*en*(en-1.0)/2.0; }

   }

#ifdef TREAL
   return(       muls +       adds );
#else
   return( 6.0 * muls + 2.0 * adds );
#endif
}

double DoTime2(int frcMF, size_t flsh, int rt, int M, int N, int K, int ldaG, 
               int ldbG, int ldcG, int TA, int TB, int UL, int DI, int SD, 
               double *alp, double *bet)
{
   size_t i, sz, nsets, setsz, szA, szB, setSH, reps=1;
   int lda = M+ldaG;
   int ldb = M+ldbG;
   double t0, t1;
   void *vp;
   TYPE *A, *B;

   flsh *= 1024;
   szA = (lda SHIFT) * M * sizeof(TYPE);
   szB = (ldb SHIFT) * N * sizeof(TYPE);
   setsz  = (M SHIFT) * (M + N)  * sizeof(TYPE);
   setSH = szA + szB + 2*ATL_Cachelen;
   nsets = (flsh+setsz-1)/setsz;
   if (nsets < 1)
      nsets = 1;
   
   sz = nsets * setSH;
   setSH = setSH / sizeof(TYPE);
   vp = malloc(ATL_Cachelen + sz);
   assert(vp);
   A = ATL_AlignPtr(vp);
   B = ATL_AlignPtr((void*) (((size_t)A)+szA));
   sz /= sizeof(TYPE);
   Mjoin(PATL,gegen)(szA/sizeof(TYPE), 1, A, 1, N*77+M*39+471);
   if (reps > nsets)
      Mjoin(PATL, gezero)(szB/sizeof(TYPE), 1, B, 1);
   else
      Mjoin(PATL, gegen)(szB/sizeof(TYPE), 1, B, 1, M*14+350);

   if (frcMF)
   {
      double d;
      d = opbl3(rt, M, N, 0);
      reps = ((frcMF * 1e6) / d) + 0.9;
   }
   switch(rt)
   {
   @whiledef bn trsm
   case B@(bn):
      if (reps > 1)
      {
         unsigned int r, s;
         TYPE *a = A, *b = B;
         t0 = ATL_walltime();
         for (s=r=0; r < reps; r++)
         {
            t_@(bn)(SD, UL, TA, DI, M, N, alp, a, lda, b, ldb, bet);
            if (++s != nsets)
            {
               a += setSH; b += setSH;
            }
            else { a = A; b = B; s=0; }
         }
         t1 = ATL_walltime() - t0;
         t1 /= reps;
      }
      else
      {
         t0 = ATL_walltime();
         t_@(bn)(SD, UL, TA, DI, M, N, alp, A, lda, B, ldb, bet);
         t1 = ATL_walltime() - t0;
      }
      break;
   @endwhile
   }
   free(vp);
   return(t1);
}

double DoTime3(int frcMF, size_t flsh, int rt, int M, int N, int K, int ldaG, 
               int ldbG, int ldcG, int TA, int TB, int UL, int DI, int SD, 
               double *alp, double *bet)
{
   size_t i, sz, nsets, setsz, szA, szB, szC, setSH, reps=1;
   int lda = M+ldaG;
   int ldb = K+ldbG;
   int ldc = M+ldbG;
   double t0, t1;
   void *vp;
   TYPE *A, *B, *C;

   flsh *= 1024;
   szA = (lda SHIFT) * M * sizeof(TYPE);
   szB = (ldb SHIFT) * N * sizeof(TYPE);
   szC = (ldc SHIFT) * N * sizeof(TYPE);
   setsz  = ((M*K + K*N + M*N)SHIFT)  * sizeof(TYPE);
   setSH = szA + szB + szC + 3*ATL_Cachelen;
   nsets = (flsh+setsz-1)/setsz;
   if (nsets < 1)
      nsets = 1;
   
   sz = nsets * setSH;
   setSH = setSH / sizeof(TYPE);
   vp = malloc(ATL_Cachelen + sz);
   assert(vp);
   A = ATL_AlignPtr(vp);
   B = ATL_AlignPtr((void*) (((size_t)A)+szA));
   C = ATL_AlignPtr((void*) (((size_t)B)+szB));
   sz /= sizeof(TYPE);
   if (reps > nsets)
      Mjoin(PATL,gezero)(sz, 1, A, 1);
   else
      Mjoin(PATL,gegen)(sz, 1, A, 1, N*77+M*39+K*13+471);

   if (frcMF)
   {
      double d;
      d = opbl3(rt, M, N, K);
      reps = ((frcMF * 1e6) / d) + 0.9;
   }
   switch(rt)
   {
   @whiledef bn gemm
   case B@(bn):
      if (reps > 1)
      {
         unsigned int r, s;
         TYPE *a = A, *b = B, *c = C;
         t0 = ATL_walltime();
         for (s=r=0; r < reps; r++)
         {
            t_@(bn)(SD, UL, TA, TB, M, N, K, alp, a, lda, b, ldb, bet, c, ldc);
            if (++s != nsets) { a += setSH; b += setSH; c += setSH; }
            else { a = A; b = B; c = C; s=0; }
         }
         t1 = ATL_walltime() - t0;
         t1 /= reps;
      }
      else
      {
         t0 = ATL_walltime();
         t_@(bn)(SD, UL, TA, TB, M, N, K, alp, A, lda, B, ldb, bet, C, ldc);
         t1 = ATL_walltime() - t0;
      }
      break;
   @endwhile
   }
   free(vp);
   return(t1);
}

typedef struct
{
   int frcMF, rt, M, N, K, ldaG, ldbG, ldcG, TA, TB, UL, DI, SD;
   size_t flshKB;
   double *alp, *bet;
   int id, p, pid;
   unsigned char *chkin;
   double *times;
} l3_struct;

int RoutHas2Mat(int rt)
{
   return(rt == Btrsm);
}

void *TimeOnCore(void *vp)
{
   l3_struct *dp = vp;
   const int P = dp->p;
   int i;
   volatile unsigned char *chkin = dp->chkin;
   #ifdef ATL_NCPU
      chkin[dp->id] = 1;
      for (i=0; i < P; i++)
         while(!chkin[i]);       /* barrier */
   #endif
   if (RoutHas2Mat(dp->rt)) // rout has two mat
      dp->times[dp->id] = DoTime2(dp->frcMF, dp->flshKB, dp->rt, dp->M, 
                                  dp->N, dp->K, dp->ldaG, dp->ldbG, dp->ldcG, 
                                  dp->TA, dp->TB, dp->UL, dp->DI, dp->SD, 
                                  dp->alp, dp->bet);
   else
      dp->times[dp->id] = DoTime3(dp->frcMF, dp->flshKB, dp->rt, dp->M, 
                                  dp->N, dp->K, dp->ldaG, dp->ldbG, dp->ldcG, 
                                  dp->TA, dp->TB, dp->UL, dp->DI, dp->SD, 
                                  dp->alp, dp->bet);
}

#ifndef ATL_NCPU
double TimeOnCores(int frcMF, size_t flshKB, int rt, int M, int N, int K, 
                   int ldaG, int ldbG, int ldcG, int TA, int TB, int UL, 
                   int DI, int SD, double *alp, double *bet, int p, int *pids)
{
   l3_struct dp;
   double tm;
   dp.frcMF = frcMF; dp.flshKB = flshKB; dp.rt = rt; dp.M = M; dp.N = N; 
   dp.K = K; dp.ldaG = ldaG; dp.ldbG = ldbG; dp.ldcG = ldcG; dp.alp = alp; 
   dp.bet = bet; dp.TA = TA; dp.TB = TB; dp.UL = UL; dp.DI = DI; dp.SD = SD; 
   dp.id = 0; dp.p = 1; dp.pid = 0; dp.chkin = NULL;
   dp.times = &tm;
   TimeOnCore(&dp);
   return(tm);
}
#else
double TimeOnCores(int frcMF, size_t flshKB, int rt, int M, int N, int K, 
                   int ldaG, int ldbG, int ldcG, int TA, int TB, int UL, 
                   int DI, int SD, double *alp, double *bet, int p, int *pids)
{
   l3_struct *dp;
   double *times, sumtm;
   ATL_thread_t tp[ATL_NTHREADS];
   int i;
   unsigned char *chkin;
   dp = malloc(sizeof(l3_struct)*p);
   times = malloc(sizeof(double)*p);
   chkin = malloc(sizeof(char)*p);
   for (i=0; i<p; i++) chkin[i] = 0;
   for (i=0; i<p; i++)
   {
      dp[i].frcMF = frcMF; dp[i].rt = rt; dp[i].flshKB = flshKB;
      dp[i].M = M; dp[i].N = N; dp[i].K = K; dp[i].TA = TA; dp[i].TB = TB; 
      dp[i].ldaG = ldaG; dp[i].ldbG = ldbG; dp[i].ldcG = ldcG;
      dp[i].DI = DI; dp[i].UL = UL; dp[i].SD = SD;
      dp[i].alp = alp; dp[i].bet = bet;
      dp[i].id = i; dp[i].p = p; dp[i].pid = pids[i];
      dp[i].chkin = chkin;
      dp[i].times = times;
      assert(!ATL_thread_start(tp+i, pids[i], 1, TimeOnCore, dp+i));
   }
   for (i=0; i<p; i++)
      assert(!ATL_thread_join(tp+i));
   sumtm = 0;
   for (i=0; i<p; i++)
      sumtm += times[i];
   free(dp);
   free(times);
   free(chkin);
   return(sumtm/p);
}
#endif

void TimeAllL3
   (int nrep, int frcMF, int ldaG, int ldbG, int ldcG, size_t flshKB, 
    int *RTs, int *Ms, int *Ns, int *Ks, int *TAs, int *TBs, double *ALPs, 
    double *BETs, int *ULs, int *DIs, int *SDs, int p, int *pids)
{
   const int nbe=BETs[0], nal=ALPs[0];
   const int nrt=RTs[0];
   const char *frm="%6s  %c  %c  %c  %c  %c  %c  %c %7d %7d %7d  %12e %12.1f\n";
   int irt, icnt=0, ierr=0;
   printf("  ROUT SD UP DI TA TB AL BE  " 
          "     M       N       K          Time        MFLOP\n");
   printf("====== == == == == == == ==  " 
          "======  ======  ======  ============  ===========\n");

   for (irt=1; irt <= nrt; irt++)
   {
      const int rt = RTs[irt];
      const int HAS_SD = (rt==Bsymm || rt==Bhemm || rt==Btrmm || rt==Btrsm);
      const int HAS_UP = (rt==Bsyr2k || rt==Bher2k || rt==Bsyrk || rt==Bherk ||
                          rt==Btrmm || rt==Btrsm);
      const int HAS_DI = (rt==Btrmm || rt==Btrsm);
      const int HAS_TA = (rt != Bsymm && rt != Bhemm);
      const int HAS_TB = (rt == Bgemm);
      char cTA='-', cTB='-', cSD='-', cUP='-', cDI='-', cALP, cBET;
      const int nm = Ms[0];
      int in, im;
      for (im=1; im <= nm; im++)
      {
         const int nn = Ns[0];
         for (in=1; in <= nn; in++)
         {
            const int N = Ns[in], M = Ms[im] ? Ms[im] : N, nk = Ks[0];
            int ik;
            for (ik=1; ik <= nk; ik++)
            {
               const int K = Ks[ik] ? Ks[ik] : N, nta = TAs[0];
               int ita;
               for (ita=1; ita <= nta; ita++)
               {
                  const int TA=TAs[ita], ntb = TBs[0];
                  int itb;
                  for (itb=1; itb <= ntb; itb++)
                  {
                     const int TB=TBs[itb], nd = DIs[0];
                     int id;
                     for (id=1; id <= nd; id++)
                     {
                        const int DI=DIs[id], nu = ULs[0];
                        int iu;
                        for (iu=1; iu <= nu; iu++)
                        {
                           const int UL=ULs[iu], ns = SDs[0];
                           int is;
                           for (is=1; is <= ns; is++)
                           {
                              const int SD = SDs[is];
                              int ib;
                              for (ib=0; ib < nbe; ib++)
                              {
                                 double *bet = BETs+1+(ib SHIFT);
                                 int ia;
                                 for (ia=0; ia < nal; ia++)
                                 {
                                    double *alp = ALPs+1+(ia SHIFT);
                                    int ir;
                                    icnt++;
                                    if (HAS_SD)
                                       cSD = (SD == AtlasRight) ? 'R' : 'L';
                                    if (HAS_UP)
                                       cUP = (UL == AtlasLower) ? 'L' : 'U';
                                    if (HAS_DI)
                                       cDI = (DI == AtlasUnit) ? 'U' : 'N';
                                    if (HAS_TA)
				    {
				       if (TA == AtlasConjTrans)
					  cTA = 'C';
				       else
					  cTA = (TA == AtlasTrans) ? 'T' : 'N';
				    }
                                    if (HAS_TB)
				    {
				       if (TB == AtlasConjTrans)
					  cTB = 'C';
				       else
					  cTB = (TB == AtlasTrans) ? 'T' : 'N';
				    }
                                    #ifdef TREAL
				       if (*alp == 0.0)
					  cALP = '0';
				       else if (*alp == 1.0)
					  cALP = '1';
				       else if (*alp == -1.0)
					  cALP = 'N';
				       else
					  cALP = 'X';
				    #else
				       if (alp[1] == 0.0)
				       {
					  if (*alp == 0.0)
					     cALP = '0';
					  else if (*alp == 1.0)
					     cALP = '1';
					  else if (*alp == -1.0)
					     cALP = 'N';
					  else
					     cALP = 'R';
				       }
                                       else
                                          cALP = 'X';
                                    #endif
                                    #ifdef TREAL
                                       if (*bet == 0.0)
                                          cBET = '0';
                                       else if (*bet == 1.0)
                                          cBET = '1';
                                       else if (*bet == -1.0)
                                          cBET = 'N';
                                       else
                                          cBET = 'X';
                                    #else
                                       if (bet[1] == 0.0)
                                       {
                                          if (*bet == 0.0)
                                             cBET = '0';
                                          else if (*bet == 1.0)
                                             cBET = '1';
                                          else if (*bet == -1.0)
                                             cBET = 'N';
                                          else
                                             cBET = 'R';
                                       }
                                       else
                                          cBET = 'X';
                                    #endif
                                    for (ir=0; ir < nrep; ir++)
                                    {
                                       double tm, mf;
                                       tm = TimeOnCores(frcMF, flshKB, rt, M, 
                                                        N, K, ldaG, ldbG,ldcG, 
                                                        TA, TB, UL, DI, SD, 
                                                        alp, bet, p, pids);
                                       mf = opbl3(rt, M, N, K) / (tm*1e6);
                                       printf(frm, nblas[rt], cSD, cUP, cDI, 
                                       cTA, cTB, cALP, cBET, M, N, K, tm, mf);
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
   }
}

int main(int nargs, char **args)
{
   int *Ms, *Ns, *Ks, *TAs, *TBs, *ROUTs, *UPLOs, *DIs, *SDs, *pids;
   double *ALPs, *BETs;
   int nreps, frcMF, ldaG, ldbG, ldcG, p;
   size_t flushKB;

   flushKB = GetFlags(nargs, args, &nreps, &frcMF, &ldaG, &ldbG, &ldcG, 
                      &Ms, &Ns, &Ks, &ROUTs, &TAs, &TBs, &ALPs, &BETs, 
                      &UPLOs, &DIs, &SDs, &p, &pids);
   TimeAllL3(nreps, frcMF, ldaG, ldbG, ldcG, flushKB, ROUTs, Ms, Ns, Ks, 
             TAs, TBs, ALPs, BETs, UPLOs, DIs, SDs, p, pids);
   free(Ms);
   free(Ns);
   free(Ks);
   free(ROUTs);
   free(TAs);
   free(TBs);
   free(ALPs);
   free(BETs);
   free(UPLOs);
   free(DIs);
   free(SDs);
   free(pids);
   return(0);
}
