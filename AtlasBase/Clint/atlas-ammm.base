@ROUT damcases.idx samcases.idx
#
# In this file, any line beginning with a '#' is ignored, but the # must be in
# column 0.  All multiple whitespace is reduced to one space (i.e. used only
# to distinguish where words begin/end).  Lines may be extended by putting '\'
# as the *last* character of line.
#
# The file has the following format:
# ROUT='routine name' AUTH='author names' COMP='compiler name' CFLAGS='flags'
# ID=<id> NU=<nu> MU=<mu> KU=<ku> KBMAX=<kbmax> KBMIN=<kbmin>
# SSE=[0,1,2,3] X87=[0,1] BMABC=<0/1> BMAB=<0/1> JKMAB=<0/1> JKMABC=<0/1>
# AOUTER=<0/1> BETAN1=<0/1> KRUNTIME=<0/1> LDCTOP=<0/1> X87=<0/1>
# ASM=[asmlist], eg., asmlist is "GAS_x8664,GAS_x8632" or "GAS_SPARC"
# ASM defaults to no assembly dialect required.
# If NU/MU is negative, then the routine can only handle multiples of NU/MU.
#
@ROUT damcases.idx
ID=1 MU=4 NU=4 KU=1 AUTH="R. Clint Whaley" ROUT='ATL_dammm2x4x1_sse2.S' \
     SSE=3 KRUNTIME=1 ASM=GAS_x8664 \
     COMP='gcc' CFLAGS='-x assembler-with-cpp -msse3'
ID=2 MU=4 NU=4 KU=1 AUTH="R. Clint Whaley" ROUT='ATL_dammm2x4x256_sse2.S' \
     SSE=3 KBMAX=256 ASM=GAS_x8664 \
     COMP='gcc' CFLAGS='-x assembler-with-cpp -msse3'
ID=3 MU=6 NU=3 KU=1 AUTH="R. Clint Whaley" ROUT='ATL_dammm3x3x256_sse2.S' \
     SSE=3 KBMAX=256 ASM=GAS_x8664 \
     COMP='gcc' CFLAGS='-x assembler-with-cpp -msse3'
#ID=4 MU=4 NU=1 KU=4 AUTH="R. Clint Whaley" ROUT='ATL_dammm_nb4_sse2.S' \
#     SSE=3 KBMIN=4 KBMAX=4 ASM=GAS_x8664 KUISKB=1 \
#     COMP='gcc' CFLAGS='-x assembler-with-cpp -msse2'
ID=5 MU=2 NU=12 KU=2 AUTH="R. Clint Whaley" ROUT='ATL_damm2x12x2_sse2.S' \
     SSE=3 ASM=GAS_x8664 \
     COMP='gcc' CFLAGS='-x assembler-with-cpp -msse3'
ID=6 MU=2 NU=12 KU=1 AUTH="R. Clint Whaley" ROUT='ATL_damm2x12x256_sse2.S' \
     SSE=3 KBMAX=256 ASM=GAS_x8664 \
     COMP='gcc' CFLAGS='-x assembler-with-cpp -msse3'
ID=7 MU=12 NU=3 KU=1 AUTH="R. Clint Whaley" ROUT='ATL_damm12x3x256_avx.S' \
     SSE=3 KBMAX=256 ASM=GAS_x8664 \
     COMP='gcc' CFLAGS='-x assembler-with-cpp -mavx'
ID=8 MU=6 NU=3 KU=1 AUTH="R. Clint Whaley" ROUT='ATL_damm6x3x256_sse3.S' \
     SSE=3 KBMAX=256 ASM=GAS_x8664 \
     COMP='gcc' CFLAGS='-x assembler-with-cpp -msse3'
ID=9 MU=6 NU=3 KU=4 AUTH="R. Clint Whaley" ROUT='ATL_damm6x3x4_sse3.S' \
     SSE=3 KBMIN=4 ASM=GAS_x8664 \
     COMP='gcc' CFLAGS='-x assembler-with-cpp -msse3'
ID=10 MU=2 NU=12 KU=2 AUTH="R. Clint Whaley" ROUT='ATL_damm2x12x2_sse2.S' \
     SSE=3 KRUNTIME=1 ASM=GAS_x8664 \
     COMP='gcc' CFLAGS='-x assembler-with-cpp -msse2'
ID=11 MU=12 NU=3 KU=1 AUTH="R. Clint Whaley" ROUT='ATL_damm12x3x1_avx.S' \
     SSE=3 ASM=GAS_x8664 KRUNTIME=1 \
     COMP='gcc' CFLAGS='-x assembler-with-cpp -mavx'
ID=12 MU=4 NU=4 KU=1 AUTH="R. Clint Whaley" ROUT='ATL_damm4x4x2rp_arm.S' \
     ASM=GAS_ARM KRUNTIME=1 \
     COMP='gcc' CFLAGS='-x assembler-with-cpp -mfpu=vfpv3'
ID=13 MU=12 NU=3 KU=2 AUTH="R. Clint Whaley" ROUT='ATL_damm12x3x2_avx.S' \
     SSE=3 ASM=GAS_x8664 KRUNTIME=1 KBMIN=6 \
     COMP='gcc' CFLAGS='-x assembler-with-cpp -mavx'
ID=14 MU=16 NU=2 KU=4 AUTH="R. Clint Whaley" ROUT='ATL_damm16x2_kb4_avx.S' \
     SSE=3 ASM=GAS_x8664 KRUNTIME=0 KBMIN=4 KBMAX=4 \
     COMP='gcc' CFLAGS='-x assembler-with-cpp -mavx'
ID=15 MU=5 NU=5 KU=2 AUTH="R. Clint Whaley" ROUT='ATL_damm5x5x2_arm.S' \
     KBMIN=2 ASM=GAS_ARM KRUNTIME=1 \
     COMP='gcc' CFLAGS='-x assembler-with-cpp -mfpu=vfpv3'
ID=16 MU=6 NU=1 KU=1 AUTH="R. Clint Whaley" ROUT='ATL_amm6x1x1_x87.S' \
     ASM=GAS_x8664,GAS_x8632 KRUNTIME=1 x87=1 \
     COMP='gcc' CFLAGS='-x assembler-with-cpp'
ID=17 MU=24 NU=1 KU=8 AUTH="R. Clint Whaley" ROUT='ATL_damm24x1x8_sse2.S' \
     SSE=3 KRUNTIME=1 ASM=GAS_x8664 \
     COMP='gcc' CFLAGS='-x assembler-with-cpp -msse3'
ID=18 MU=24 NU=1 KU=1 AUTH="R. Clint Whaley" ROUT='ATL_damm24x1x1_sse2.S' \
     SSE=3 KRUNTIME=1 ASM=GAS_x8664 \
     COMP='gcc' CFLAGS='-x assembler-with-cpp -msse3'
ID=19 MU=5 NU=5 KU=2 AUTH="R. Clint Whaley" ROUT='ATL_damm5x5x2_armpf.S' \
     KBMIN=2 ASM=GAS_ARM KRUNTIME=1 \
     COMP='gcc' CFLAGS='-x assembler-with-cpp -mfpu=vfpv3'
ID=20 MU=5 NU=5 KU=1 AUTH="R. Clint Whaley" ROUT='ATL_damm5x5x1_armpf.S' \
     KBMIN=2 ASM=GAS_ARM KRUNTIME=1 \
     COMP='gcc' CFLAGS='-x assembler-with-cpp -mfpu=vfpv3'
ID=21 MU=12 NU=4 KU=1 AUTH="R. Clint Whaley" ROUT='ATL_damm12x4x1_fma3.S' \
     SSE=3 ASM=GAS_x8664 KRUNTIME=1 \
     COMP='gcc' CFLAGS='-x assembler-with-cpp -mavx -mfma'
ID=22 MU=3 NU=4 KU=1 AUTH="R. Clint Whaley" ROUT='ATL_damm3x4x1_armpf.S' \
     KBMIN=2 ASM=GAS_ARM KRUNTIME=1 \
     COMP='gcc' CFLAGS='-x assembler-with-cpp -mfpu=vfpv3-fp16'
ID=23 MU=4 NU=2 KU=4 AUTH="R. Clint Whaley" ROUT='ATL_amm4x2x4_kb4.c' \
     KRUNTIME=0 KBMIN=4 KBMAX=4 
ID=24 MU=6 NU=4 KU=1 AUTH="R. Clint Whaley" ROUT='ATL_damm6x4x1_fma3.S' \
     SSE=3 ASM=GAS_x8664 KRUNTIME=1 \
     COMP='gcc' CFLAGS='-x assembler-with-cpp -mavx -mfma'
ID=25 MU=6 NU=3 KU=2 AUTH="R. Clint Whaley" ROUT='ATL_damm6x3x2_sse3.S' \
     SSE=3 KBMIN=4 ASM=GAS_x8664 \
     COMP='gcc' CFLAGS='-x assembler-with-cpp -msse3'
ID=26 MU=4 NU=4 KU=1 AUTH="R. Clint Whaley" ROUT='ATL_dammm4x4x256_sse3.S' \
     SSE=3 KBMAX=256 ASM=GAS_x8664 \
     COMP='gcc' CFLAGS='-x assembler-with-cpp -msse3'
ID=27 MU=24 NU=1 KU=1 AUTH="R. Clint Whaley" ROUT='ATL_dammm24x1x256_sse3.S' \
     SSE=3 KBMAX=256 ASM=GAS_x8664 \
     COMP='gcc' CFLAGS='-x assembler-with-cpp -msse3'
ID=28 MU=6 NU=4 KU=1 AUTH="R. Clint Whaley" ROUT='ATL_dammm6x4x256_fma3.S' \
     SSE=5 KBMAX=256 ASM=GAS_x8664 \
     COMP='gcc' CFLAGS='-x assembler-with-cpp -msse3 -mfma'
ID=29 MU=12 NU=4 KU=1 AUTH="R. Clint Whaley" ROUT='ATL_dammm12x4x256_fma3.S' \
     SSE=5 KBMAX=256 ASM=GAS_x8664 \
     COMP='gcc' CFLAGS='-x assembler-with-cpp -msse3 -mfma'
ID=30 MU=12 NU=4 KU=2 AUTH="R. Clint Whaley" ROUT='ATL_damm12x4x2_fma3.S' \
     SSE=3 ASM=GAS_x8664 KRUNTIME=1 \
     COMP='gcc' CFLAGS='-x assembler-with-cpp -mavx -mfma'
ID=31 MU=6 NU=3 KU=1 AUTH="R. Clint Whaley" ROUT='ATL_dammm6x3r2x256_sse3.S' \
     SSE=3 KBMAX=256 ASM=GAS_x8664 \
     COMP='gcc' CFLAGS='-x assembler-with-cpp -msse3'
ID=32 MU=14 NU=1 KU=2 AUTH="R. Clint Whaley" ROUT='ATL_dkmmm14x1x256_sse3.S' \
     SSE=3 KMAJ=2 ASM=GAS_x8664 KBMIN=2 KBMAX=256 \
     COMP='gcc' CFLAGS='-x assembler-with-cpp -msse3'
ID=33 MU=14 NU=1 KU=2 AUTH="R. Clint Whaley" ROUT='ATL_dkmmm14x1x2_sse3.S' \
     SSE=3 KMAJ=2 ASM=GAS_x8664 KRUNTIME=1 \
     COMP='gcc' CFLAGS='-x assembler-with-cpp -msse3'
ID=34 MU=24 NU=8 KU=1 AUTH="R. Clint Whaley" ROUT='ATL_damm24x8x1_avxz.S' \
      ASM=GAS_x8664 KRUNTIME=1 COMP='icc' CFLAGS='-x assembler-with-cpp -mmic'
ID=35 MU=32 NU=4 KU=2 AUTH="R. Clint Whaley" ROUT='ATL_damm32x4x2rp_avxz.S' \
      ASM=GAS_x8664 KRUNTIME=1 COMP='icc' CFLAGS='-x assembler-with-cpp -mmic'
#ID=36 MU=32 NU=4 KU=1 AUTH="R. Clint Whaley" ROUT='ATL_damm32x4x256_avxz.S' \
#      ASM=GAS_x8664 KBMAX=320 COMP='icc' CFLAGS='-x assembler-with-cpp -mmic'
ID=37 MU=32 NU=6 KU=1 AUTH="R. Clint Whaley" ROUT='ATL_damm32x6x1_avxz.S' \
      ASM=GAS_x8664 KRUNTIME=1 COMP='icc' CFLAGS='-x assembler-with-cpp -mmic'
ID=38 MU=16 NU=8 KU=4 AUTH="R. Clint Whaley" ROUT='ATL_damm16x8x4_avxz.S' \
      ASM=GAS_x8664 KRUNTIME=1 COMP='icc' CFLAGS='-x assembler-with-cpp -mmic'
ID=40 MU=24 NU=8 KU=2 AUTH="R. Clint Whaley" ROUT='ATL_damm24x8x2_avxz.S' \
      ASM=GAS_x8664 KRUNTIME=1 COMP='icc' CFLAGS='-x assembler-with-cpp -mmic'
ID=41 MU=8 NU=8 KU=8 AUTH="R. Clint Whaley" ROUT='ATL_amm8x8x8_avxz.S' \
      KRUNTIME=0 KBMAX=8 KBMIN=8 ASM=GAS_x8664 \
      COMP='icc' CFLAGS='-x assembler-with-cpp -mmic'
ID=42 MU=5 NU=5 KU=2 AUTH="Whaley & Nuechterlein" \
      ROUT='ATL_damm5x5x2_aarch64.S' \
      KBMIN=2 ASM=GAS_ARM64 KRUNTIME=1 \
      COMP='gcc' CFLAGS='-x assembler-with-cpp'
ID=43 MU=4 NU=3 KU=6 AUTH="R. Clint Whaley" ROUT='ATL_dammm4x3x6_arm64.S' \
      KRUNTIME=1 KBMIN=12 ASM=GAS_ARM64 \
      COMP='gcc' CFLAGS='-x assembler-with-cpp'
ID=44 MU=4 NU=2 KU=2 AUTH="Whaley & Voronenko" ROUT='ATL_kmmm4x2x256_sse3.S' \
     KMAJ=2 SSE=3 KBMAX=256 ASM=GAS_x8664 \
     COMP='gcc' CFLAGS='-x assembler-with-cpp -msse3'
ID=45 MU=8 NU=1 KU=2 AUTH="R. Clint Whaley" ROUT='ATL_kmmm8x1x256_L1pf.S' \
     KMAJ=2 SSE=3 KBMAX=256 ASM=GAS_x8664 \
     COMP='gcc' CFLAGS='-x assembler-with-cpp -msse3'
ID=46 MU=8 NU=6 KU=2 AUTH="R. Clint Whaley" ROUT='ATL_damm8x6x2_fma3.S' \
     SSE=3 ASM=GAS_x8664 KRUNTIME=1 LDCTOP=1 \
     COMP='gcc' CFLAGS='-x assembler-with-cpp -mavx -mfma'
ID=48 MU=12 NU=4 KU=6 AUTH="Rakib Hasan" ROUT='ATL_damm12x4x6_aarch64-A57.S' \
     KBMIN=6 ASM=GAS_ARM64 KRUNTIME=1 \
     COMP='gcc' CFLAGS='-x assembler-with-cpp'
ID=49 MU=12 NU=4 KU=1 AUTH="Rakib Hasan" ROUT='ATL_damm12x4x1_aarch64-A53.S' \
     KBMIN=1 ASM=GAS_ARM64 KRUNTIME=1 \
     COMP='gcc' CFLAGS='-x assembler-with-cpp'
ID=50 MU=12 NU=4 KU=1 AUTH="Rakib Hasan" ROUT='ATL_damm12x4x1_aarch64-A57.S' \
     KBMIN=1 ASM=GAS_ARM64 KRUNTIME=1 \
     COMP='gcc' CFLAGS='-x assembler-with-cpp'
@ROUT samcases.idx
@ROUT samcases.idx
ID=1 MU=16 NU=4 KU=1 AUTH="R. Clint Whaley" ROUT='ATL_samm16x4x1_av.c' \
     KRUNTIME=1 COMP='gcc' CFLAGS='-Os -maltivec -mabi=altivec -mcpu=970 -mtune=970 -mvrsave -fschedule-insns2 -fno-schedule-insns'
ID=2 MU=4 NU=6 KU=2 AUTH="R. Clint Whaley" ROUT='ATL_samm4x6x2_arm.S' \
     ASM=GAS_ARM KRUNTIME=1 KBMIN=4 \
     COMP='gcc' CFLAGS='-x assembler-with-cpp -mfpu=vfpv3'
ID=3 MU=4 NU=6 KU=1 AUTH="R. Clint Whaley" ROUT='ATL_samm4x6x1_arm.S' \
     ASM=GAS_ARM KRUNTIME=1 \
     COMP='gcc' CFLAGS='-x assembler-with-cpp -mfpu=vfpv3'
ID=7 MU=24 NU=3 KU=1 AUTH="R. Clint Whaley" ROUT='ATL_samm24x3x256_avx.S' \
     SSE=3 KBMAX=256 ASM=GAS_x8664 \
     COMP='gcc' CFLAGS='-x assembler-with-cpp -mavx'
ID=8 MU=8 NU=4 KU=1 AUTH="R. Clint Whaley" ROUT='ATL_sammm8x4x256_sse2.S' \
     SSE=2 KBMAX=256 ASM=GAS_x8664 \
     COMP='gcc' CFLAGS='-x assembler-with-cpp -msse2'
ID=11 MU=24 NU=3 KU=1 AUTH="R. Clint Whaley" ROUT='ATL_damm12x3x1_avx.S' \
     SSE=3 ASM=GAS_x8664 KRUNTIME=1 \
     COMP='gcc' CFLAGS='-x assembler-with-cpp -mavx'
ID=13 MU=24 NU=3 KU=2 AUTH="R. Clint Whaley" ROUT='ATL_damm12x3x2_avx.S' \
     SSE=3 ASM=GAS_x8664 KRUNTIME=1 KBMIN=6 \
     COMP='gcc' CFLAGS='-x assembler-with-cpp -mavx'
ID=16 MU=6 NU=1 KU=1 AUTH="R. Clint Whaley" ROUT='ATL_amm6x1x1_x87.S' \
     ASM=GAS_x8664,GAS_x8632 KRUNTIME=1 x87=1 \
     COMP='gcc' CFLAGS='-x assembler-with-cpp'
ID=23 MU=4 NU=2 KU=4 AUTH="R. Clint Whaley" ROUT='ATL_amm4x2x4_kb4.c' \
     KRUNTIME=0 KBMIN=4 KBMAX=4 
ID=24 MU=24 NU=4 KU=1 AUTH="R. Clint Whaley" ROUT='ATL_sammm24x4x256_fma3.S' \
     SSE=5 KBMAX=256 ASM=GAS_x8664 \
     COMP='gcc' CFLAGS='-x assembler-with-cpp -msse3 -mfma'
ID=25 MU=24 NU=4 KU=2 AUTH="R. Clint Whaley" ROUT='ATL_samm24x4x2_fma3.S' \
     SSE=5 ASM=GAS_x8664 KRUNTIME=1 \
     COMP='gcc' CFLAGS='-x assembler-with-cpp -mavx -mfma'
ID=26 MU=12 NU=1 KU=4 AUTH="R. Clint Whaley" ROUT='ATL_skmmm12x1x4_sse3.S' \
     SSE=3 KMAJ=4 ASM=GAS_x8664 KRUNTIME=1 \
     COMP='gcc' CFLAGS='-x assembler-with-cpp -msse2'
ID=27 MU=12 NU=1 KU=4 AUTH="R. Clint Whaley" ROUT='ATL_skmmm12x1x256_sse3.S' \
     SSE=3 KMAJ=4 ASM=GAS_x8664 KRUNTIME=0 KBMIN=4 KBMAX=256 \
     COMP='gcc' CFLAGS='-x assembler-with-cpp -msse2'
#ID=26 MU=12 NU=3 KU=1 AUTH="R. Clint Whaley" ROUT='ATL_sammm12x3d2x256_sse3.S' \
#     SSE=3 DUPB=2 KBMAX=256 ASM=GAS_x8664 \
#     COMP='gcc' CFLAGS='-x assembler-with-cpp -msse2'
ID=34 MU=48 NU=8 KU=1 AUTH="R. Clint Whaley" ROUT='ATL_damm24x8x1_avxz.S' \
      ASM=GAS_x8664 KRUNTIME=1 COMP='icc' CFLAGS='-x assembler-with-cpp -mmic'
ID=35 MU=64 NU=4 KU=2 AUTH="R. Clint Whaley" ROUT='ATL_damm32x4x2rp_avxz.S' \
      ASM=GAS_x8664 KRUNTIME=1 COMP='icc' CFLAGS='-x assembler-with-cpp -mmic'
#ID=36 MU=64 NU=4 KU=1 AUTH="R. Clint Whaley" ROUT='ATL_damm32x4x256_avxz.S' \
#      ASM=GAS_x8664 KBMAX=320 COMP='icc' CFLAGS='-x assembler-with-cpp -mmic'
ID=37 MU=64 NU=6 KU=1 AUTH="R. Clint Whaley" ROUT='ATL_damm32x6x1_avxz.S' \
      ASM=GAS_x8664 KRUNTIME=1 COMP='icc' CFLAGS='-x assembler-with-cpp -mmic'
ID=38 MU=32 NU=8 KU=4 AUTH="R. Clint Whaley" ROUT='ATL_damm16x8x4_avxz.S' \
      ASM=GAS_x8664 KRUNTIME=1 COMP='icc' CFLAGS='-x assembler-with-cpp -mmic'
ID=40 MU=48 NU=8 KU=2 AUTH="R. Clint Whaley" ROUT='ATL_damm24x8x2_avxz.S' \
      ASM=GAS_x8664 KRUNTIME=1 COMP='icc' CFLAGS='-x assembler-with-cpp -mmic'
ID=42 MU=4 NU=6 KU=2 AUTH="Nuechterlein & Whaley" \
      ROUT='ATL_samm4x6x2b_aarch64.S' \
      ASM=GAS_ARM64 KRUNTIME=1 KBMIN=4 \
      COMP='gcc' CFLAGS='-x assembler-with-cpp'
ID=43 MU=8 NU=4 KU=1 AUTH="R. Clint Whaley" ROUT='ATL_sammm8x4x256_sdup.S' \
      SSE=3 KBMAX=256 ASM=GAS_x8664 \
      COMP='gcc' CFLAGS='-x assembler-with-cpp -msse3'
ID=44 MU=4 NU=2 KU=4 AUTH="Whaley & Voronenko" ROUT='ATL_kmmm4x2x256_sse3.S' \
      KMAJ=4 SSE=3 KBMAX=256 ASM=GAS_x8664 \
      COMP='gcc' CFLAGS='-x assembler-with-cpp -msse3'
ID=45 MU=8 NU=1 KU=4 AUTH="R. Clint Whaley" ROUT='ATL_kmmm8x1x256_L1pf.S' \
     KMAJ=4 SSE=3 KBMAX=256 ASM=GAS_x8664 \
     COMP='gcc' CFLAGS='-x assembler-with-cpp -msse3'
ID=48 MU=24 NU=4 KU=6 AUTH="Rakib Hasan" ROUT='ATL_damm12x4x6_aarch64-A57.S' \
     KBMIN=6 ASM=GAS_ARM64 KRUNTIME=1 \
     COMP='gcc' CFLAGS='-x assembler-with-cpp'
ID=49 MU=24 NU=4 KU=1 AUTH="Rakib Hasan" ROUT='ATL_damm12x4x1_aarch64-A53.S' \
     KBMIN=1 ASM=GAS_ARM64 KRUNTIME=1 \
     COMP='gcc' CFLAGS='-x assembler-with-cpp'
ID=50 MU=24 NU=4 KU=1 AUTH="Rakib Hasan" ROUT='ATL_damm12x4x1_aarch64-A57.S' \
     KBMIN=1 ASM=GAS_ARM64 KRUNTIME=1 \
     COMP='gcc' CFLAGS='-x assembler-with-cpp'
@ROUT samcases.idx
@ROUT atlas_gnuvec.h
#ifndef ATLAS_GNUVEC
   #define ATLAS_GNUVEC 1
   #ifndef TYPE
      #if defined(SREAL) || defined(SCPLX)
         #define TYPE float
      #else
         #define TYPE double
      #endif
   #endif
   #ifdef ATL_VSX
      #define ATL_NVREG 64
      #ifndef ATL_VLEN
         #define ATL_VLENb 16
         #if defined(SREAL) || defined (SCPLX)
            #define ATL_VLEN 4
         #else
            #define ATL_VLEN 2
         #endif
      #endif
   #elif defined(ATL_AltiVec)
      #define ATL_NVREG 32
      #ifndef ATL_VLEN
         #define ATL_VLENb 16
         #if defined(SREAL) || defined (SCPLX)
            #define ATL_VLEN 4
         #else
            #define ATL_VLEN 2
         #endif
      #endif
   #elif defined(ATL_AVXZ)
      #include "immintrin.h"
      #define ATL_NVREG 32
      #define ATL_VLENb 64
      #if defined(SREAL) || defined (SCPLX)
          #define ATL_VLEN 16
      #else
          #define ATL_VLEN 8
      #endif
      #if defined(SREAL) || defined (SCPLX)
         #define ATL_gvbcast(ptr_, v_) \
            v_ = _mm512_extload_ps((void*)(ptr_), _MM_UPCONV_PS_NONE, \
                                   _MM_BROADCAST_1X16, 0)
      #else
         #define ATL_gvbcast(ptr_, v_) \
            v_ = _mm512_extload_pd((void*)(ptr_), _MM_UPCONV_PD_NONE, \
                                   _MM_BROADCAST_1X8, 0)
      #endif
   #elif defined(ATL_AVXMAC) || defined(ATL_AVXFMA4) || defined(ATL_AVX)
      #ifdef ATL_GAS_x8664
         #define ATL_NVREG 16
      #else
         #define ATL_NVREG 8
      #endif
      #ifndef ATL_VLEN
         #define ATL_VLENb 32
         #if defined(SREAL) || defined (SCPLX)
            #define ATL_VLEN 8
         #else
            #define ATL_VLEN 4
         #endif
      #endif
      #if ATL_VLENb == 32
         #define ATL_gvbcast(ptr_, v_) \
            (v_) = __builtin_ia32_vbroadcastsd256((void*)(ptr_));
      #elif ATL_VLENb == 16 && defined(ATL_SSE3)
         #include "immintrin.h"
         #define ATL_gvbcast(ptr_, v_) \
            (v_) = _mm_loaddup_pd(ptr_);
@skip            (v_) = __builtin_ia32_movddup(ptr_);
      #endif
   #elif defined(ATL_SSE3) || defined(ATL_SSE2)
      #ifdef ATL_GAS_x8664
         #define ATL_NVREG 16
      #else
         #define ATL_NVREG 8
      #endif
      #ifndef ATL_VLEN
         #define ATL_VLENb 16
         #if defined(SREAL) || defined (SCPLX)
            #define ATL_VLEN 4
         #else
            #define ATL_VLEN 2
         #endif
      #endif
      #if defined(DREAL) || defined(DCPLX)
         #if defined(ATL_SSE3) && ATL_VLEN == 2
         #include "immintrin.h"
            #define ATL_gvbcast(ptr_, v_) \
            (v_) = _mm_loaddup_pd(ptr_);
@skip               (v_) = __builtin_ia32_movddup(ptr_);
         #endif
      #endif
   #elif defined(SREAL) || defined(SCPLX)   /* single-only stuff */
      #ifdef ATL_AltiVec
         #define ATL_NVREG 32
         #ifndef ATL_VLEN
            #define ATL_VLENb 16
            #define ATL_VLEN 4
         #endif
      #elif defined(ATL_SSE1)
         #ifdef ATL_GAS_x8664
            #define ATL_NVREG 16
         #else
            #define ATL_NVREG 8
         #endif
         #ifndef ATL_VLEN
            #define ATL_VLENb 16
            #define ATL_VLEN 4
         #endif
      #elif defined(ATL_NONIEEE) && ATL_NONIEEE != 0
         #ifdef ATL_NEON
            #define ATL_NVREG 16
            #ifndef ATL_VLEN
               #define ATL_VLENb 8
               #define ATL_VLEN 2
            #endif
         #elif defined(ATL_3DNow)
            #define ATL_NVREG 8
            #ifndef ATL_VLEN
               #define ATL_VLENb 16
               #define ATL_VLEN 4
            #endif
         #endif
      #endif
   #endif
   #if defined(ATL_VLEN) && !defined(ATL_VLENb)
      #if defined(SREAL) || defined (SCPLX)
         @iexp i 0 2 +
         @iwhile i < 32
            @iexp j @(i) 4 *
         #if ATL_VLEN == @(i)
            #define ATL_VLENb @(j)
         #endif
            @iexp i @(i) 2 *
         @endiwhile
      #else
         @iexp i 0 2 +
         @iwhile i < 64
            @iexp j @(i) 8 *
         #if ATL_VLEN == @(i)
            #define ATL_VLENb @(j)
         #endif
            @iexp i @(i) 2 *
         @endiwhile
      #endif
   #endif
   #ifndef ATL_VLENb
      #define ATL_VLEN 1
      #if defined(SREAL) || defined (SCPLX)
         #define ATL_VLENb 4
      #else
         #define ATL_VLENb 8
      #endif
      #if defined(ATL_GAS_x8664) || defined(ATL_GAS_x8632)
         #define ATL_NVREG 8
      #else
         #define ATL_NVREG 32
      #endif
   #endif
   #ifndef ATL_vec_t
      #if ATL_VLEN > 1
         typedef TYPE ATL_vec_t  __attribute__ ((vector_size (ATL_VLENb)));
      #else
         #define ATL_vec_t TYPE
      #endif
   #endif
/*
 * Setup macros to multiply and divide by VLEN using shifts
 */
   #if ATL_VLEN == 1
      #define ATL_DivByVLEN(i_) (i_)
      #define ATL_MulByVLEN(i_) (i_)
@iexp s 1 0 +
@iexp i 2 0 +
@iwhile i < 64
   #elif ATL_VLEN == @(i)
      #define ATL_DivByVLEN(i_) ((i_)>>@(s))
      #define ATL_MulByVLEN(i_) ((i_)<<@(s))
   @iexp s @(s) 1 +
   @iexp i @(i) 2 *
@endiwhile
   #else
      #define ATL_DivByVLEN(i_) ((i_)/ATL_VLEN)
      #define ATL_MulByVLEN(i_) ((i_)*ATL_VLEN)
   #endif
   #ifndef ATL_gvbcast
      #if ATL_VLEN == 1
         #define ATL_gvbcast(ptr_, v_) \
            { ATL_vec_t z={*(ptr_)}; v_ = z; }
      #elif ATL_VLEN == 2
         #define ATL_gvbcast(ptr_, v_) \
            { ATL_vec_t z={*(ptr_),*(ptr_)}; v_ = z; }
      #elif ATL_VLEN == 4
         #define ATL_gvbcast(ptr_, v_) \
            { ATL_vec_t z={*(ptr_),*(ptr_),*(ptr_),*(ptr_)}; v_ = z; }
      #elif ATL_VLEN == 8
         #define ATL_gvbcast(ptr_, v_) \
            v_ = {*(ptr_), *(ptr_), *(ptr_), *(ptr_), \
                  *(ptr_), *(ptr_), *(ptr_), *(ptr_)}
      #elif ATL_VLEN == 16
         #define ATL_gvbcast(ptr_, v_) \
         { \
            ATL_vec_t z_ = {*(ptr_), *(ptr_), *(ptr_), *(ptr_), \
                  *(ptr_), *(ptr_), *(ptr_), *(ptr_), \
                  *(ptr_), *(ptr_), *(ptr_), *(ptr_), \
                  *(ptr_), *(ptr_), *(ptr_), *(ptr_), \
                 }; \
            v_ = z_; \
         }
      #else
         #error "Cannot create gvbcast"
      #endif
   #endif
   
#endif
@ROUT atlas_amm.h
#ifndef ATLAS_AMM_H
   #define ATLAS_AMM_H

#ifndef ATL_MaxMalloc_MB
   #define ATL_MaxMalloc_MB 2048UL
#endif
#ifndef ATL_MaxMalloc
   #ifdef ATL_MaxMalloc_MB
      #define ATL_MaxMalloc (ATL_MaxMalloc_MB<<20)
   #else
      #define ATL_MaxMalloc (1<<27)   /* 128 MB */
   #endif
#endif
#include "atlas_misc.h"

#ifdef TREAL
   typedef void (*cm2am_t)(const size_t, const size_t, const SCALAR,
                           const TYPE*, const size_t, TYPE*);
   typedef void (*am2cm_t)(const size_t, const size_t, const SCALAR,
                           TYPE*, const size_t, const TYPE*);
   typedef void (*ablk2cmat_t)(const size_t, const size_t, const SCALAR,
                               const TYPE*, const SCALAR, TYPE *, const size_t);
   typedef void (*cmat2ablk_t)(const size_t, const size_t, const SCALAR,
                               const TYPE*, const size_t, const SCALAR,TYPE*);
   typedef void (*ammswp_t)(ATL_CINT, TYPE*,ATL_CSZT,TYPE*);
#else
   typedef void (*cm2am_t)(const size_t, const size_t, const SCALAR,
                           const TYPE*, const size_t, TYPE*, TYPE*);
   typedef void (*am2cm_t)(const size_t, const size_t, const SCALAR,
                           TYPE*, const size_t, const TYPE*, const TYPE*);
   typedef void (*ablk2cmat_t)(const size_t, const size_t, const SCALAR,
                               const TYPE*, const TYPE*, const SCALAR, 
                               TYPE *, const size_t);
   typedef void (*cmat2ablk_t)(const size_t, const size_t, const SCALAR,
                               const TYPE*, const size_t, const SCALAR,
                               TYPE*,TYPE*);
   typedef void (*ammswp_t)(ATL_CINT, TYPE*,ATL_CSZT,TYPE*,TYPE*);
#endif
typedef void (*ammkern_t)(ATL_CSZT,ATL_CSZT,ATL_CSZT,const TYPE*,const TYPE*,
                          TYPE*, const TYPE*, const TYPE*, const TYPE*);
typedef struct amminfo amminfo_t;
struct amminfo
{
   cm2am_t a2blk, b2blk;
   ablk2cmat_t Cblk2cm, Cblk2cm_b1;
   cmat2ablk_t cm2Cblk;
   ammkern_t amm_b0, amm_b1, amm_bn, amm_k1_b0, amm_k1_b1, amm_k1_bn;
   unsigned short IDX, mb, nb, kb, kbmin;
   unsigned char flag, mu, nu, ku;
};

typedef struct rkinfo rkinfo_t;
struct rkinfo
{
   size_t incAm, incAk;
   size_t incBn, incBk;
   size_t lda, ldb, ldc;
   ammkern_t amm_b0, amm_b1;      /* beta=0 ammm kern */
   cm2am_t a2blk, b2blk;          /* full-KB A/B copy routs */
   ablk2cmat_t blk2c;
   ATL_INT nfmb, nfnb, nfkb;      /* FLOOR(D/db) */
   short idx;
   unsigned short mbL, nbL, kbL;  /* D-nfdb*db */
   unsigned short MBL, NBL, KBL;  /* nmu*mu, nnu*nu, nku*ku */
   unsigned short mb, nb, kb;     /* blk fact, always mul of unrolling */
   unsigned short nmu, nnu, nmuL, nnuL; /* # U for normal & last blks */
   unsigned char flag, mu, nu, ku;
};

enum ATL_AMMALG {ATL_amm1b, ATL_ammrkK, ATL_NMK};

@whiledef info GetAmmmInfo GetRankKInfo
int Mjoin(PATL,@(info))
   (amminfo_t *out, enum ATLAS_TRANS TA, enum ATLAS_TRANS TB, ATL_CSZT M, 
    ATL_CSZT N, ATL_CSZT K, const SCALAR alpha, const SCALAR beta);
@endwhile
#ifdef TREAL
int Mjoin(PATL,GetTrsmInfo)
   (amminfo_t *out, int ialp, enum ATLAS_TRANS TA, ATL_CSZT M, ATL_CSZT N, 
    const SCALAR beta);
#endif
int Mjoin(PATL,tGetAmmmInfo)
   (amminfo_t *out, const unsigned int P, enum ATLAS_TRANS TA, 
    enum ATLAS_TRANS TB, ATL_CSZT M, ATL_CSZT N, ATL_CSZT K, 
    const SCALAR alpha, const SCALAR beta);
ablk2cmat_t Mjoin(PATL,tGetSyammInfo)
   (amminfo_t *out, const int P, enum ATLAS_TRANS TA, ATL_CSZT N, ATL_CSZT K,
    const SCALAR alpha, const SCALAR beta);
ablk2cmat_t Mjoin(PATL,tGetSyammInfo_K)
   (amminfo_t *out, const int P, enum ATLAS_TRANS TA, ATL_CSZT N, ATL_CSZT K);


void Mjoin(PATL,ammmK)
   (amminfo_t*, const int mb, const int nmu, const int nb, const int nnu, 
    ATL_CINT nfkblks, const int kb, const int kb0, const int KB0, const TYPE *A,
    const size_t lda, const size_t incAk, const TYPE*B, const size_t ldb, 
    const size_t incBk, const ablk2cmat_t blkc2c, TYPE*, const size_t ldc, 
    TYPE *a, ATL_CINT inca, TYPE *b, ATL_CINT incb, TYPE *rC, TYPE *iC, 
    const SCALAR alpA, const SCALAR alpB, const SCALAR alpC, const SCALAR beta);

void Mjoin(PATL,ammm)
   (enum ATLAS_TRANS,enum ATLAS_TRANS,ATL_CSZT,ATL_CSZT,ATL_CSZT, const SCALAR,
    const TYPE*,ATL_CSZT,const TYPE*,ATL_CSZT,const SCALAR,TYPE*,ATL_CSZT);
int Mjoin(PATL,ammm_rk2)
   (enum ATLAS_TRANS,enum ATLAS_TRANS,ATL_CSZT,ATL_CSZT, const SCALAR,
    const TYPE*,ATL_CSZT,const TYPE*,ATL_CSZT,const SCALAR,TYPE*,ATL_CSZT);
@multidef rt ammmNKM
@whiledef rt ammm_1b ammm_rkK ammm_IP ammm_tN ammm_aliased_rkK ammmMNK ammmREC
int Mjoin(PATL,@(rt))
   (enum ATLAS_TRANS,enum ATLAS_TRANS,ATL_CSZT,ATL_CSZT,ATL_CSZT, const SCALAR,
    const TYPE*,ATL_CSZT,const TYPE*,ATL_CSZT,const SCALAR,TYPE*,ATL_CSZT);
@endwhile
int Mjoin(PATL,ammmNMK)
   (enum ATLAS_TRANS,enum ATLAS_TRANS,ATL_CSZT,ATL_CSZT,ATL_CSZT, 
    const SCALAR,const TYPE*,ATL_CSZT,const TYPE*,ATL_CSZT,const SCALAR,
    TYPE*,ATL_CSZT);
#endif  /* end include file guard */
@ROUT emit_uamm
@extract -b @(topd)/cw.inc lang=C -def cwdate 2012 -def cwdate 2013  -def cwdate 2014 
#include "atlas_misc.h"
#define ATL_JKMDEF 1
#include "atlas_mmparse.h"
#include "atlas_sys.h"
   static int UID=0, UIL=1;
void PrintUsage(char *name, int ierr, char *flag)
{
   if (ierr > 0)
      fprintf(stderr, "Bad argument #%d: '%s'\n", ierr,
              flag?flag:"OUT-OF_ARGUMENTS");
   else if (ierr < 0)
      fprintf(stderr, "ERROR: %s\n", flag);
   fprintf(stderr, "USAGE: %s [flags]:\n", name);
   fprintf(stderr, "   -p [s,d,c,z]: set type/precision prefix (d) \n");
   fprintf(stderr, "   -d <outdir>: directory to dump files to\n");
   fprintf(stderr, "   -i <infile> : can be repeated for multiple files\n");
   fprintf(stderr, "   -k <unique K cleanup index file> : \n");
   fprintf(stderr, "   -K <K cleanup by NB file> \n");
   fprintf(stderr, "   -r <rank-K kernel file> \n");
   fprintf(stderr, "   -s <square-case kernel file>\n");

   fprintf(stderr,
      "   -I <ID> : unique non-negative ID for header/kern files\n");
   exit(ierr ? ierr : -1);
}

ATL_mmnode_t *GetFlags(int nargs, char **args, char *PRE, char **DOUT,
                       char **UKIN, char **KCIN, char **RKIN, char **SQIN)
{
   int i, j=0, n, k;
   char pre='d';
   *SQIN = *RKIN = *UKIN = *KCIN = *DOUT = NULL;
   ATL_mmnode_t *mmb=NULL, *mmp, *mp;

   for (i=1; i < nargs; i++)
   {
      if (args[i][0] != '-')
         PrintUsage(args[0], i, args[i]);

      switch(args[i][1])
      {
      case 'p':
        if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
        pre = tolower(args[i][0]);
        assert(pre == 's' || pre == 'd' || pre == 'z' || pre == 'c');
        break;
      case 's':
        if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
        *SQIN = DupString(args[i]);
        break;
      case 'k':
        if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
        *UKIN = DupString(args[i]);
        break;
      case 'K':
        if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
        *KCIN = DupString(args[i]);
        break;
      case 'I':
        if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
        UID = atol(args[i]);
        for (k=10; k <= UID; k *= 10)
           UIL++;
        break;
      case 'd':
        if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
        *DOUT = DupString(args[i]);
        break;
      case 'i':
        if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
        mmp = ReadMMFile(args[i]);
        if (mmb)
        {
           ATL_mmnode_t *mp;
           for (mp=mmb; mp->next; mp = mp->next);
           mp->next = mmp;
        }
        else
           mmb = mmp;
        break;
      default:
         PrintUsage(args[0], i, args[i]);
      }
   }
   *PRE = pre;
   if (!(*DOUT))
   {
      *DOUT = DupString("dMake_amm");
      (*DOUT)[0] = pre;
   }
   return(mmb);
}

char *GetVecStr(char pre, int vlen)
{
   if (vlen == 1)
      return("scalar");
   #ifdef ATL_AVX
      if (pre == 'd' || pre == 'z')
      {
         if (vlen == 4)
            return("avx");
         else if (vlen == 2)
            return("sse");
      }
      else if (pre == 's' || pre == 'c')
      {
         if (vlen == 8)
            return("avx");
         else if (vlen == 4)
            return("sse");
      }
   #elif defined(ATL_SSE1)
      #ifdef ATL_SSE2
         if ((pre == 'd' || pre == 'z') && vlen == 2)
               return("sse");
      #endif
      if ((pre == 's' || pre == 'c') && vlen == 4)
         return("sse");
   #endif
/*
 * Any vector length > 1 that isn't one of our known cases uses gnuvec
 */
   return("gvec");
}

void FillInGenStrings
(
   char pre,
   ATL_mmnode_t *mmb,  /* queue to look through */
   char *dir           /* output directory to generate into */
)
/*
 * Creates GenString for any ID=0 in mmb
 */
{
   ATL_mmnode_t *mp;
   char *frm="make gen_amm_%s lat=%d mu=%d nu=%d ku=%d kb=%d vlen=%d rt=%s/%s kmaj=%d";
   int frml;

   frml = strlen(frm);
   for (mp=mmb; mp; mp = mp->next)
   {
      if (mp->ID == 0)  /* is generated file */
      {
         int ll;
         char *sp, *vec;
         int vlen = mp->vlen;

         assert(mp->rout);  /* should have been filled in by search */
         ll = frml + strlen(dir) + strlen(mp->rout) + 8;
         sp = malloc(ll*sizeof(char));
         assert(sp);

         vec = GetVecStr(pre, mp->vlen);

         sprintf(sp, frm, vec, mp->lat, mp->mu, mp->nu,
                 mp->ku, FLAG_IS_SET(mp->flag, MMF_KRUNTIME) ? 0 : mp->kbB,
                 vlen, dir, mp->rout, mp->kmaj);
         mp->genstr = sp;
      }
   }
}

void PrintBegBlock(char pre, ATL_mmnode_t *mmb, char *nam, FILE *fp)
{
   ATL_mmnode_t *mp;
   char PRE = toupper(pre);
   int i;

   if (nam)
   {
      fprintf(fp, "#ifndef ATLAS_%cUAMM_%s_H\n   #define ATLAS_%cUAMM_%s_H\n\n",
              PRE, nam, PRE, nam);
      fprintf(fp, "#include \"atlas_amm.h\"\n");
   }
   else
      fprintf(fp, "#ifndef ATLAS_%cUAMM_H\n   #define ATLAS_%cUAMM_H\n\n",
              PRE, PRE);
/*
 * Count mmb, and print def of NCASES
 */
   if (!nam || strstr(nam, "RANKK") == NULL)
   {
      for (mp=mmb,i=0; mp; i++, mp = mp->next);

      fprintf(fp, "#ifdef ATL_UAMM_NCASES\n");
      fprintf(fp, "   #if ATL_UAMM_NCASES != %d\n", i);
      fprintf(fp, "      #error \"NCASES MISMATCH!\"\n");
      fprintf(fp, "   #endif\n");
      fprintf(fp, "#else\n");
      fprintf(fp, "   #define ATL_UAMM_NCASES %d\n", i);
      fprintf(fp, "#endif\n");
   }
}

char *GetHName(char pre, char *outd, char *bnam)
{
   int i, NOBASE=0;
   char *fnam;
   if (!bnam)
   {
      NOBASE = 1;
      bnam = "";
   }
   i = strlen(outd) + strlen(bnam) + 16+UIL;

   fnam = malloc(i*sizeof(char));
   assert(fnam);
   if (NOBASE)
      sprintf(fnam, "%s/atlas_%cu%damm.h", outd, pre, UID);
   else
      sprintf(fnam, "%s/atlas_%cu%damm_%s.h", outd, pre, UID, bnam);
   return(fnam);
}

FILE *StandHStart(char pre, ATL_mmnode_t *mmb, char *outd, char *bnam)
{
   char *fnam;
   FILE *fp;
   int i;

   assert(outd);
   fnam = GetHName(pre, outd, bnam);
   fp = fopen(fnam, "w");
   assert(fp);
   if (bnam)
   {
      for (i=0; bnam[i]; i++)
         fnam[i] = toupper(bnam[i]);
      fnam[i] = '\0';
      PrintBegBlock(pre, mmb, fnam, fp);
   }
   else
      PrintBegBlock(pre, mmb, NULL, fp);
   free(fnam);
   return(fp);
}

static int Mylcm(const int M, const int N)
/*
 * Returns least common multiple (LCM) of two positive integers M & N by
 * computing greatest common divisor (GCD) and using the property that
 * M*N = GCD*LCM.
 */
{
   register int tmp, max, min, gcd=0;

   if (M != N)
   {
      if (M > N) { max = M; min = N; }
      else { max = N; min = M; }
      if (min > 0)  /* undefined for negative numbers */
      {
         do  /* while (min) */
         {
            if ( !(min & 1) ) /* min is even */
            {
               if ( !(max & 1) ) /* max is also even */
               {
                  do
                  {
                     min >>= 1;
                     max >>= 1;
                     gcd++;
                     if (min & 1) goto MinIsOdd;
                  }
                  while ( !(max & 1) );
               }
               do min >>=1 ; while ( !(min & 1) );
            }
/*
 *          Once min is odd, halve max until it too is odd.  Then, use
 *          property that gcd(max, min) = gcd(max, (max-min)/2)
 *          for odd max & min
 */
MinIsOdd:
            if (min != 1)
            {
               do  /* while (max >= min */
               {
                  max -= (max & 1) ? min : 0;
                  max >>= 1;
               }
               while (max >= min);
            }
            else return( (M*N) / (1<<gcd) );
            tmp = max;
            max = min;
            min = tmp;
         }
         while(tmp);
      }
      return( (M*N) / (max<<gcd) );
   }
   else return(M);
}

void GenAmmSum(char pre, ATL_mmnode_t *mmb, ATL_mmnode_t *rkb, char *outd)
{
   ATL_mmnode_t *mp, *p66;
   char *fnam;
   FILE *fp;
   char *type = "unsigned short";
   int i, n, maxb, maxNB, maxMB, maxKB, maxkmaj;
   char PRE = toupper(pre), bc[3] = {'M', 'N', 'K'};
   double mfB;

   fp = StandHStart(pre, mmb, outd, "sum");
   maxkmaj = maxNB = maxKB = maxMB = 0;
   mfB = 0.0;
   for (n=0,mp=mmb; mp; n++, mp = mp->next)
   {
      maxkmaj = Mmax(maxkmaj, mp->kmaj);
      maxMB = Mmax(maxMB, mp->mbB);
      maxNB = Mmax(maxNB, mp->nbB);
      maxKB = Mmax(maxKB, mp->kbB);
      mfB = Mmax(mfB, mp->mflop[0]);
   }
   if (maxkmaj == 1)
      maxkmaj = 0;
   maxb = Mmax(maxMB, maxNB);
   maxb = Mmax(maxb, maxKB);
   fprintf(fp, "\n#define ATL_UAMM_MAXMB %d\n", maxMB);
   fprintf(fp, "#define ATL_UAMM_MAXNB %d\n", maxNB);
   fprintf(fp, "#define ATL_UAMM_MAXKB %d\n", maxKB);
   fprintf(fp, "#define ATL_UAMM_MAXKMAJ %d\n\n", maxkmaj);

   for (mp=mmb; mp && mp->next; mp = mp->next);
   assert(mp);
   fprintf(fp, "#define ATL_UAMM_LMU %d\n", mp->mu);
   fprintf(fp, "#define ATL_UAMM_LNU %d\n", mp->nu);
   fprintf(fp, "#define ATL_UAMM_LKU %d\n", mp->ku);
   fprintf(fp, "#define ATL_UAMM_LLCMMN %d\n\n", Mylcm(mp->mu, mp->nu));
   fprintf(fp, "#define ATL_UAMM_LLCMU %d\n\n",
           Mylcm(Mylcm(mp->mu, mp->nu),mp->ku));
/*
 * Find smallest case achieving 2/3 of maximal performance
 */
   for (i=0,mp=mmb; mp && mp->mflop[0]*1.5 < mfB; i++, mp = mp->next);
   assert(mp);
   fprintf(fp, "#define ATL_UAMM_66IDX %d\n", i);
   fprintf(fp, "#define ATL_UAMM_66MB %d\n", mp->mbB);
   fprintf(fp, "#define ATL_UAMM_66NB %d\n", mp->nbB);
   fprintf(fp, "#define ATL_UAMM_66KB %d\n", mp->kbB);
   fprintf(fp, "#define ATL_UAMM_66LCMMN %d\n\n", Mylcm(mp->mu, mp->nu));
   fprintf(fp, "#define ATL_UAMM_66LCMU %d\n\n",
           Mylcm(Mylcm(mp->mu, mp->nu),mp->ku));
   fprintf(fp, "#define ATL_UAMM_66RATIO %1.4lf\n\n", mp->mflop[0]/mfB);
/*
 * Find smallest case achieving 98% of maximal performance
 */
   for (i=0,mp=mmb; mp && mp->mflop[0] < 0.98*mfB; i++, mp = mp->next);
   assert(mp);
   fprintf(fp, "#define ATL_UAMM_98IDX %d\n", i);
   fprintf(fp, "#define ATL_UAMM_98MB %d\n", mp->mbB);
   fprintf(fp, "#define ATL_UAMM_98NB %d\n", mp->nbB);
   fprintf(fp, "#define ATL_UAMM_98KB %d\n", mp->kbB);
   fprintf(fp, "#define ATL_UAMM_98LCMMN %d\n\n", Mylcm(mp->mu, mp->nu));
   fprintf(fp, "#define ATL_UAMM_98LCMU %d\n\n",
           Mylcm(Mylcm(mp->mu, mp->nu),mp->ku));
   fprintf(fp, "#define ATL_UAMM_98RATIO %1.4lf\n\n", mp->mflop[0]/mfB);
   assert(rkb == NULL);

   fprintf(fp, "#define ATL_UAMMFLG_KRUNTIME(flg_) ((flg_) & 1)\n");
   fprintf(fp, "#define ATL_UAMMFLG_KMAJOR(flg_) ((flg_) & 2)\n");

   fprintf(fp, "\n#endif  /* end include file guard */\n");
   fclose(fp);
}

void GenPerfFile(char pre, ATL_mmnode_t *mmb, char *outd, char *nm)
{
   ATL_mmnode_t *mp;
   #define NTHRSH 11
   int THRSH[NTHRSH] = {25, 33, 50, 66, 75, 80, 85, 90, 95, 98, 99};
   int idxT[NTHRSH];
   ATL_mmnode_t *mpT[NTHRSH];
   char *fnam;
   FILE *fp;
   char *type = "float";
   double mfMax=0.0;
   int i, j, n, maxb, maxNB, maxMB, maxKB, maxkmaj, idxMax=0;
   char PRE = toupper(pre), bc[3] = {'M', 'N', 'K'};

   for (i=0; i < NTHRSH; i++)
      mpT[i] = NULL;
   fp = StandHStart(pre, mmb, outd, nm);
   for (n=0,mp=mmb; mp; n++, mp = mp->next)
   {
      if (mp->mflop[0] > mfMax)
      {
         mfMax = mp->mflop[0];
         idxMax = n;
      }
   }
   fprintf(fp, "#define ATL_UAMM_MAXMFLOP %le /* (%.2f)*/ \n",
           mfMax, mfMax);
   fprintf(fp, "#define ATL_UAMM_MAXMFLOPIDX %d\n\n", idxMax);
   for (n=0,mp=mmb; mp; mp = mp->next, n++)
   {
      double mf = mp->mflop[0] / mfMax;
      for (i=0; i < NTHRSH; i++)
      {
         if (!mpT[i] && THRSH[i]*0.01*mfMax < mp->mflop[0])
         {
            mpT[i] = mp;
            idxT[i] = n;
         }
      }
   }
   for (i=0; i < NTHRSH; i++)
   {
      mp = mpT[i];
      fprintf(fp, "#define ATL_UAMM_%dLCMU %d\n", THRSH[i],
              Mylcm(Mylcm(mp->mu,mp->nu),mp->ku));
      fprintf(fp, "#define ATL_UAMM_%dLCMMN %d\n", THRSH[i],
              Mylcm(mp->mu,mp->nu));
      fprintf(fp, "#define ATL_UAMM_%dKB %d\n", THRSH[i],
              mp->kbB);
      fprintf(fp, "#define ATL_UAMM_%dNB %d\n", THRSH[i],
              mp->nbB);
      fprintf(fp, "#define ATL_UAMM_%dMB %d\n", THRSH[i],
              mp->mbB);
      fprintf(fp, "#define ATL_UAMM_%dIDX %d\n", THRSH[i],
              idxT[i]);
   }
   fprintf(fp, "\n");

   fprintf(fp, "static const float ATL_UAMM_PERF[%d] =", n);
   fprintf(fp, "   /* %% of performance of best kernel */\n{\n");
   for (j=0,mp=mmb; mp; j++,mp = mp->next)
      fprintf(fp, "   %f%c  /* IDX=%d, KB=%d */\n", mp->mflop[0]/mfMax,
              (mp->next)?',':' ', j, mp->kbB);
   fprintf(fp, "};\n\n");

   fprintf(fp, "static const float ATL_UAMM_SPDUPNXT[%d] =", n);
   fprintf(fp, "   /* speedup of next higher NB */\n{\n");
   for (j=0,mp=mmb; mp; j++,mp = mp->next)
   {
      double mf = (mp->next) ? mp->next->mflop[0] : mp->mflop[0];
      fprintf(fp, "   %f%c  /* IDX=%d, KB=%d vs. %d */\n", mf/mp->mflop[0],
              (mp->next)?',':' ', j, mp->kbB, mp->next?mp->next->kbB:mp->kbB);
   }
   fprintf(fp, "};\n\n");

   fprintf(fp, "#endif  /* end include file guard */\n");
   fclose(fp);
}

void GenBlockingFile(char pre, ATL_mmnode_t *mmb, char *outd, char *nm)
{
   ATL_mmnode_t *mp;
   char *fnam;
   FILE *fp;
   char *type = "unsigned short";
   int i, n, maxb, maxNB, maxMB, maxKB, maxkmaj;
   char PRE = toupper(pre), bc[3] = {'M', 'N', 'K'};

   fp = StandHStart(pre, mmb, outd, nm);
   maxkmaj = maxNB = maxKB = maxMB = 0;
   for (n=0,mp=mmb; mp; n++, mp = mp->next)
   {
      maxkmaj = Mmax(maxkmaj, mp->kmaj);
      maxMB = Mmax(maxMB, mp->mbB);
      maxNB = Mmax(maxNB, mp->nbB);
      maxKB = Mmax(maxKB, mp->kbB);
   }
   if (maxkmaj == 1)
      maxkmaj = 0;
   maxb = Mmax(maxMB, maxNB);
   maxb = Mmax(maxb, maxKB);
   fprintf(fp, "#define ATL_UAMM_MAXMB %d\n", maxMB);
   fprintf(fp, "#define ATL_UAMM_MAXNB %d\n", maxNB);
   fprintf(fp, "#define ATL_UAMM_MAXKB %d\n", maxKB);
   fprintf(fp, "#define ATL_UAMM_MAXKMAJ %d\n", maxkmaj);
   fprintf(fp, "\n");

   if (maxb <= 255)
      type = "unsigned char";
   for (i=0; i < 3; i++)
   {
      int j;
      fprintf(fp, "static const %s ATL_UAMM_%cBs[%d] =\n{\n",
              type, bc[i], n);
      for (j=0,mp=mmb; mp; j++,mp = mp->next)
      {
         int b;
         if (bc[i] == 'M')
            b = mp->mbB;
         else if (bc[i] == 'N')
            b = mp->nbB;
         else if (bc[i] == 'K')
            b = mp->kbB;
         if (mp->next)
            fprintf(fp, "%8d,  /* index %d */\n", b, j);
         else
            fprintf(fp, "%8d   /* index %d */\n", b, j);
      }
      fprintf(fp, "};\n\n");
   }
   for (i=0; i < 3; i++)
   {
      int j;
      fprintf(fp, "static const %s ATL_UAMM_%cUs[%d] =\n{\n",
              type, bc[i], n);
      for (j=0,mp=mmb; mp; j++,mp = mp->next)
      {
         int b;
         if (bc[i] == 'M')
            b = mp->mu;
         else if (bc[i] == 'N')
            b = mp->nu;
         else if (bc[i] == 'K')
         {
            if (FLAG_IS_SET(mp->flag, MMF_KRUNTIME))
               b = mp->ku;
            else
               b = (mp->kmaj > 1) ? mp->ku : mp->kbB;
         }
         if (mp->next)
            fprintf(fp, "%8d,  /* index %d */\n", b, j);
         else
            fprintf(fp, "%8d   /* index %d */\n", b, j);
      }
      fprintf(fp, "};\n\n");
   }
   fprintf(fp, "static const %s ATL_UAMM_KBMINs[%d] =\n{\n", type, n);
   for (i=0,mp=mmb; mp; i++,mp = mp->next)
   {
      if (mp->next)
         fprintf(fp, "%8d,  /* index %d */\n", mp->kbmin, i);
      else
         fprintf(fp, "%8d   /* index %d */\n", mp->kbmin, i);
   }
   fprintf(fp, "};\n\n");
   fprintf(fp, "\n#endif  /* end include file guard */\n");
   fclose(fp);
}

void GenFlagH(char pre, ATL_mmnode_t *mmb, char *outd, char *nm)
{
   FILE *fp;
   int j, n;
   ATL_mmnode_t *mp;

   fp = StandHStart(pre, mmb, outd, nm);

   for (n=0,mp=mmb; mp; n++,mp = mp->next);

   fprintf(fp, "static const unsigned char ATL_UAMM_KFLAG[%d] =\n{\n", n);
   for (j=0,mp=mmb; mp; j++,mp = mp->next)
   {
      unsigned char flag=FLAG_IS_SET(mp->flag, MMF_KRUNTIME) ? 1 : 0;
      if (mp->kmaj)
         flag |= 2;
      if (mp->next)
         fprintf(fp, "%6d,  /* index %d */\n", flag, j);
      else
         fprintf(fp, "%6d   /* index %d */\n", flag, j);
   }
   fprintf(fp, "};\n\n");
   fprintf(fp, "#define ATL_AMM_KRUNTIME(idx_) (ATL_AMM_KFLAG[idx_] & 1)\n");
   fprintf(fp, "#define ATL_AMM_KMAJOR(idx_) (ATL_AMM_KFLAG[idx_] & 2)\n");
   fprintf(fp, "\n#endif  /* end include file guard */\n");
   fclose(fp);
}

void SpewForthC2MProto(char pre, FILE *fp0, FILE *fp1, int mu, int nu)
{
   char ac[3] = {'1', 'n', 'X'};
   char bc[4] = {'0', '1', 'n', 'X'};
   int ia, ib;
   for (ia=0; ia < 3; ia ++)
   {
      for (ib=0; ib < 4; ib++)
      {
         fprintf(fp0, "void ATL_%cu%dablk2cmat_%dx%d_a%c_b%c\n",
                 pre, UID, mu, nu, ac[ia], bc[ib]);
         if (pre == 'z' || pre == 'c')
            fprintf(fp0, "   (ATL_CSZT,ATL_CSZT,const SCALAR,const TYPE*,const TYPE*,const SCALAR,TYPE *,ATL_CSZT);\n");
         else
            fprintf(fp0, "   (ATL_CSZT,ATL_CSZT,const SCALAR,const TYPE*,const SCALAR,TYPE *,ATL_CSZT);\n");
         fprintf(fp1, "void ATL_%cu%dcmat2ablk_%dx%d_a%c_b%c\n",
                 pre, UID, mu, nu, ac[ia], bc[ib]);
         if (pre == 'z' || pre == 'c')
            fprintf(fp1, "   (ATL_CSZT,ATL_CSZT,const SCALAR,const TYPE*,ATL_CSZT,const SCALAR,TYPE*,TYPE*);\n");
         else
            fprintf(fp1, "   (ATL_CSZT,ATL_CSZT,const SCALAR,const TYPE*,ATL_CSZT,const SCALAR,TYPE*);\n");
      }
   }
}

void SpewForthC2BDecl(char pre, ATL_mmnode_t *mmb, FILE *fp, char *rt,
                      char alp, char bet)
{
   ATL_mmnode_t *mp;
   int j;

   for (j=0,mp=mmb; mp; j++,mp = mp->next)
   {
      fprintf(fp, "   ATL_%cu%d%s_%dx%d_a%c_b%c",
              pre, UID, rt, mp->mu,mp->nu, alp, bet);
      if (mp->next)
         fprintf(fp, ",  /* index %d */\n", j);
      else
         fprintf(fp, "   /* index %d */\n", j);
      }
      fprintf(fp, "};\n\n");
}

void GenC2BLK(char pre, ATL_mmnode_t *mmb, char *outd, char *suff)
{
   FILE *fp0, *fp1;
   ATL_mmnode_t *mp;
   int ia, ib;
   char ac[3] = {'1', 'n', 'X'};
   char bc[4] = {'0', '1', 'n', 'X'};
   char *fnam;

   if (!suff)
   {
      fp0 = StandHStart(pre, mmb, outd, "ablk2cmat");
      fp1 = StandHStart(pre, mmb, outd, "cmat2ablk");
   }
   else
   {
      fnam = malloc(sizeof(char)*(strlen(suff) + 10));
      assert(fnam);
      strncpy(fnam, "ablk2cmat", 9);
      strcpy(fnam+9, suff);
      fp0 = StandHStart(pre, mmb, outd, fnam);
      strncpy(fnam, "cmat2ablk", 9);
      fp1 = StandHStart(pre, mmb, outd, fnam);
   }
   fprintf(fp0, "\n");
   fprintf(fp1, "\n");
/*
 * Crank out prototypes
 */
   SpewForthC2MProto(pre, fp0, fp1, mmb->mu, mmb->nu);
   for (mp=mmb->next; mp; mp = mp->next)
   {
      ATL_mmnode_t *p;
      const int mu=mp->mu, nu=mp->nu;
      for (p=mmb; p->mu != mu || p->nu != nu; p = p->next);
      if (p == mp)  /* first occurance of this mu,nu pair */
         SpewForthC2MProto(pre, fp0, fp1, mp->mu, mp->nu);
   }
   fprintf(fp0, "\n");
   fprintf(fp1, "\n");
/*
 * Now, crank out funcptr arrays
 */
   for (ia=0; ia < 3; ia ++)
   {
      for (ib=0; ib < 4; ib++)
      {
         fprintf(fp0,
            "static const ablk2cmat_t ATL_UAMM_BLK2C_a%c_b%c[ATL_UAMM_NCASES] =\n{\n",
                 ac[ia], bc[ib]);
         SpewForthC2BDecl(pre, mmb, fp0, "ablk2cmat", ac[ia], bc[ib]);
         fprintf(fp1,
            "static const cmat2ablk_t ATL_UAMM_C2BLK_a%c_b%c[ATL_UAMM_NCASES] =\n{\n",
                 ac[ia], bc[ib]);
         SpewForthC2BDecl(pre, mmb, fp1, "cmat2ablk", ac[ia], bc[ib]);
      }
   }
   fprintf(fp0, "\n#endif  /* end include file guard */\n");
   fclose(fp0);
   fprintf(fp1, "\n#endif  /* end include file guard */\n");
   fclose(fp1);
}

void SpewForthRevCpProto(char pre, FILE *fp, char alp, int u, int kmaj)
{
   const int G = (pre == 'c' || pre == 'z') ? 2 : 1;
   const char *cst[2] = {"", "C"};
   int g;

   for (g=0; g < G; g++)
   {
      if (kmaj > 1)
         fprintf(fp, "void ATL_%cu%dam2cm_a%c_%dx%d%s\n",
                 pre, UID, alp, kmaj, u, cst[g]);
      else
         fprintf(fp, "void ATL_%cu%dam2cm_a%c_%d%s\n",pre, UID, alp, u, cst[g]);
      if (pre == 'z' || pre == 'c')
         fprintf(fp, "   (ATL_CSZT,ATL_CSZT,const SCALAR,TYPE*,ATL_CSZT,const TYPE*,const TYPE*);\n");
      else
         fprintf(fp,
         "   (ATL_CSZT,ATL_CSZT,const SCALAR,TYPE*,ATL_CSZT,const TYPE*);\n");
      if (kmaj > 1)
         fprintf(fp, "void ATL_%cu%dam2rm_a%c_%dx%d%s\n",
                 pre, UID, alp, kmaj, u, cst[g]);
      else
         fprintf(fp, "void ATL_%cu%dam2rm_a%c_%d%s\n",pre, UID, alp, u, cst[g]);
      if (pre == 'z' || pre == 'c')
         fprintf(fp, "   (ATL_CSZT,ATL_CSZT,const SCALAR,TYPE*,ATL_CSZT,const TYPE*,const TYPE*);\n");
      else
         fprintf(fp,
         "   (ATL_CSZT,ATL_CSZT,const SCALAR,TYPE*,ATL_CSZT,const TYPE*);\n");
   }
}

void SpewForthCpProto(char pre, FILE *fp, char alp, int u, int kmaj)
{
   const int G = (pre == 'c' || pre == 'z') ? 2 : 1;
   const char *cst[2] = {"", "C"};
   int g;

   for (g=0; g < G; g++)
   {
      if (kmaj > 1)
         fprintf(fp, "void ATL_%cu%dcm2am_a%c_%dx%d%s\n",
                 pre, UID, alp, kmaj, u, cst[g]);
      else
         fprintf(fp, "void ATL_%cu%dcm2am_a%c_%d%s\n",pre, UID, alp, u, cst[g]);
      if (pre == 'z' || pre == 'c')
         fprintf(fp,
    "   (ATL_CSZT,ATL_CSZT,const SCALAR,const TYPE*,ATL_CSZT,TYPE*,TYPE*);\n");
      else
         fprintf(fp,
         "   (ATL_CSZT,ATL_CSZT,const SCALAR,const TYPE*,ATL_CSZT,TYPE*);\n");
      if (kmaj > 1)
         fprintf(fp, "void ATL_%cu%drm2am_a%c_%dx%d%s\n",
                 pre, UID, alp, kmaj, u, cst[g]);
      else
         fprintf(fp, "void ATL_%cu%drm2am_a%c_%d%s\n",pre, UID, alp, u, cst[g]);
      if (pre == 'z' || pre == 'c')
         fprintf(fp,
     "   (ATL_CSZT,ATL_CSZT,const SCALAR,const TYPE*,ATL_CSZT,TYPE*,TYPE*);\n");
      else
         fprintf(fp,
         "   (ATL_CSZT,ATL_CSZT,const SCALAR,const TYPE*,ATL_CSZT,TYPE*);\n");
   }
}

void SpewForthCpConjDecl(char pre, int REVERSE, ATL_mmnode_t *mmb, FILE *fp,
                         char *arr, char *rt, char alp, int u)
{
   ATL_mmnode_t *mp;
   int j;

   fprintf(fp, "static const %s_t %s_a%c[%d] =\n{\n",
           REVERSE?"am2cm":"cm2am", arr, alp,  ATL_CountNumberOfMMNodes(mmb));
   for (j=0,mp=mmb; mp; j++,mp = mp->next)
   {
      const int kmaj = mp->kmaj;
      if (kmaj > 1)
         fprintf(fp, "   ATL_%cu%d%s_a%c_%dx%dC", pre, UID, rt, alp, kmaj,
                 u?mp->mu:mp->nu);
      else
         fprintf(fp, "   ATL_%cu%d%s_a%c_%dC", pre, UID, rt, alp,
                 u?mp->mu:mp->nu);
      if (mp->next)
         fprintf(fp, ",");
      else
         fprintf(fp, " ");
      fprintf(fp, "  /* index %d */\n", j);
   }
   fprintf(fp, "};\n\n");
}

void SpewForthCpDecl(char pre, int REVERSE, ATL_mmnode_t *mmb, FILE *fp,
                     char *arr, char *rt, char alp, int u)
{
   ATL_mmnode_t *mp;
   int j;

   fprintf(fp, "static const %s_t %s_a%c[%d] =\n{\n",
           REVERSE?"am2cm":"cm2am", arr, alp, ATL_CountNumberOfMMNodes(mmb));
   for (j=0,mp=mmb; mp; j++,mp = mp->next)
   {
      const int kmaj = mp->kmaj;
      if (kmaj > 1)
         fprintf(fp, "   ATL_%cu%d%s_a%c_%dx%d", pre, UID, rt, alp, kmaj,
                 u?mp->mu:mp->nu);
      else
         fprintf(fp, "   ATL_%cu%d%s_a%c_%d", pre, UID, rt, alp,
                 u?mp->mu:mp->nu);
      if (mp->next)
         fprintf(fp, ",");
      else
         fprintf(fp, " ");
      fprintf(fp, "  /* index %d */\n", j);
   }
   fprintf(fp, "};\n\n");
}


void GenAMAJ2CMAJ(char pre, ATL_mmnode_t *mmb, char *outd, char *suff)
/*
 * 3. atlas_<pre>amm_am2cm_a[1,X,n]:
 *    defines: ATL_AMM_NCASES
 *    prototypes all am2rm & am2cm routines
 *    1 indexible array giving which to use for each block factor
 */
{
   char ac[3] = {'1', 'n', 'X'};
   int ia, j;
   char *fnam, *sp, *np;
   ATL_mmnode_t *mp;

   if (!suff)
      suff = "";
   ia = strlen(outd) + strlen(suff) + 24+UIL;
   fnam = malloc(ia*sizeof(char));
   assert(fnam);
   sprintf(fnam, "%s/atlas_%cu%damm%s_am2cm_a1.h", outd, pre, UID, suff);
   np = fnam+ia-23+12;
   assert(*np == 'a' && np[1] == 'm');
   sp = fnam+ia-4;
   assert(*sp == '1');

   for (ia=0; ia < 3; ia++)
   {
      char *rt[2] = {"am2cm", "am2rm"};
      FILE *fp;
      int kmaj = mmb->kmaj;

      if (kmaj == 1)
         kmaj = 0;
      *sp = ac[ia];
      fp = fopen(fnam, "w");
      assert(fp);
      sp[1] = '\0';
      PrintBegBlock(pre, mmb, np, fp);
      sp[1] = '.';
      fprintf(fp, "/*\n * mat2blk prototypes\n */\n");
      SpewForthRevCpProto(pre, fp, ac[ia], mmb->mu, kmaj);
      if (mmb->nu != mmb->mu || kmaj > 1)
         SpewForthRevCpProto(pre, fp, ac[ia], mmb->nu, kmaj);
      for (mp=mmb->next; mp; mp = mp->next)
      {
         ATL_mmnode_t *p;
         int mu = mp->mu, nu = mp->nu, kmaj=mp->kmaj;
         for (p=mmb; p != mp; p = p->next)
            if (mu == p->mu && p->kmaj == kmaj)
               break;
         if (p == mp) /* haven't seen before */
            SpewForthRevCpProto(pre, fp, ac[ia], mu, kmaj);
         for (p=mmb; p != mp; p = p->next)
            if ((p->nu == nu && p->kmaj == kmaj) ||
                (p->kmaj == kmaj && p->mu == nu))
               break;
         if (p == mp) /* haven't seen before */
            SpewForthRevCpProto(pre, fp, ac[ia], nu, kmaj);
      }
      fprintf(fp, "\n");
      SpewForthCpDecl(pre,1,mmb, fp, "ATL_UAMM_BLK2A", "am2cm", ac[ia], 1);
      SpewForthCpDecl(pre,1,mmb, fp, "ATL_UAMM_BLK2AT", "am2rm", ac[ia], 1);
      SpewForthCpDecl(pre,1,mmb, fp, "ATL_UAMM_BLK2B", "am2cm", ac[ia], 0);
      SpewForthCpDecl(pre,1,mmb, fp, "ATL_UAMM_BLK2BT", "am2rm", ac[ia], 0);
      if (pre == 'c' || pre == 'z')
      {
         SpewForthCpConjDecl(pre, 1, mmb, fp, "ATL_UAMM_BLKC2A",
                             "am2cm", ac[ia], 1);
         SpewForthCpConjDecl(pre, 1, mmb, fp, "ATL_UAMM_BLKH2A",
                             "am2rm", ac[ia], 1);
         SpewForthCpConjDecl(pre, 1, mmb, fp, "ATL_UAMM_BLKC2B",
                             "am2cm", ac[ia], 0);
         SpewForthCpConjDecl(pre, 1, mmb, fp, "ATL_UAMM_BLKH2B",
                             "am2rm", ac[ia], 0);
      }
      fprintf(fp, "\n#endif  /* end include file guard */\n");
      fclose(fp);
   }
   free(fnam);
}
void GenCMAJ2AMAJ(char pre, ATL_mmnode_t *mmb, char *outd, char *suff)
/*
 * 3. atlas_<pre>amm_cm2am_a[1,X,n]:
 *    defines: ATL_AMM_NCASES
 *    prototypes all rm2am & cm2am routines
 *    1 indexible array giving which to use for each block factor
 */
{
   char ac[3] = {'1', 'n', 'X'};
   int ia, j;
   char *fnam, *sp, *np;
   ATL_mmnode_t *mp;

GenAMAJ2CMAJ(pre, mmb, outd, suff);
   if (!suff)
      suff = "";
   ia = strlen(outd) + strlen(suff) + 24+UIL;
   fnam = malloc(ia*sizeof(char));
   assert(fnam);
   sprintf(fnam, "%s/atlas_%cu%damm%s_cm2am_a1.h", outd, pre, UID, suff);
   np = fnam+ia-23+12;
   assert(*np == 'c' && np[1] == 'm');
   sp = fnam+ia-4;
   assert(*sp == '1');

   for (ia=0; ia < 3; ia++)
   {
      char *rt[2] = {"cm2am", "rm2am"};
      FILE *fp;
      int kmaj = mmb->kmaj;

      if (kmaj == 1)
         kmaj = 0;
      *sp = ac[ia];
      fp = fopen(fnam, "w");
      assert(fp);
      sp[1] = '\0';
      PrintBegBlock(pre, mmb, np, fp);
      sp[1] = '.';
      fprintf(fp, "/*\n * mat2blk prototypes\n */\n");
      SpewForthCpProto(pre, fp, ac[ia], mmb->mu, kmaj);
      if (mmb->nu != mmb->mu || kmaj > 1)
         SpewForthCpProto(pre, fp, ac[ia], mmb->nu, kmaj);
      for (mp=mmb->next; mp; mp = mp->next)
      {
         ATL_mmnode_t *p;
         int mu = mp->mu, nu = mp->nu, kmaj=mp->kmaj;
         for (p=mmb; p != mp; p = p->next)
            if (mu == p->mu && p->kmaj == kmaj)
               break;
         if (p == mp) /* haven't seen before */
            SpewForthCpProto(pre, fp, ac[ia], mu, kmaj);
         for (p=mmb; p != mp; p = p->next)
            if ((p->nu == nu && p->kmaj == kmaj) ||
                (p->kmaj == kmaj && p->mu == nu))
               break;
         if (p == mp) /* haven't seen before */
            SpewForthCpProto(pre, fp, ac[ia], nu, kmaj);
      }
      fprintf(fp, "\n");
      SpewForthCpDecl(pre,0,mmb, fp, "ATL_UAMM_A2BLK", "cm2am", ac[ia], 1);
      SpewForthCpDecl(pre,0,mmb, fp, "ATL_UAMM_AT2BLK", "rm2am", ac[ia], 1);
      SpewForthCpDecl(pre,0,mmb, fp, "ATL_UAMM_B2BLK", "cm2am", ac[ia], 0);
      SpewForthCpDecl(pre,0,mmb, fp, "ATL_UAMM_BT2BLK", "rm2am", ac[ia], 0);
      if (pre == 'c' || pre == 'z')
      {
         SpewForthCpConjDecl(pre, 0, mmb, fp, "ATL_UAMM_AC2BLK",
                             "cm2am", ac[ia], 1);
         SpewForthCpConjDecl(pre, 0, mmb, fp, "ATL_UAMM_AH2BLK",
                             "rm2am", ac[ia], 1);
         SpewForthCpConjDecl(pre, 0, mmb, fp, "ATL_UAMM_BC2BLK",
                             "cm2am", ac[ia], 0);
         SpewForthCpConjDecl(pre, 0, mmb, fp, "ATL_UAMM_BH2BLK",
                             "rm2am", ac[ia], 0);
      }
      fprintf(fp, "\n#endif  /* end include file guard */\n");
      fclose(fp);
   }
   free(fnam);
}

int KernelIsExactSame(ATL_mmnode_t *p0, ATL_mmnode_t *p1)
/*
 * RETURNS: 1 if kernels are the same including KB, 0 otherwise
 */
{
/*
 * Kernels aren't the same if one is being compiled with specific KB,
 * and the other has runtime
 */
   if (FLAG_IS_SET(p0->flag, MMF_KRUNTIME) !=
       FLAG_IS_SET(p1->flag, MMF_KRUNTIME))
      return(0);
   if (!FLAG_IS_SET(p0->flag, MMF_KRUNTIME) && (p0->kbB != p1->kbB))
      return(0);
/*
 * Kernels aren't same if one is K-veclen-major and one is not
 */
   if (p0->kmaj != p1->kmaj)
      return(0);
/*
 * Kernels aren't same if the -DATL_MOVE bits don't match
 */
   if (ATL_MMF_MVGET(p0->flag) != ATL_MMF_MVGET(p1->flag))
      return(0);
/*
 * Two generated kernels are the same if mu,nu,kmaj,ku,VLEN,flag are the same.
 * NOTE: if we make generator handle muladd, etc, MUST UPDATE HERE!!!
 */
   if (p0->ID == 0 && p1->ID == 0)
      return(p0->mu == p1->mu && p0->nu == p1->nu && p0->kmaj == p1->kmaj &&
             p0->ku == p1->ku && p0->vlen == p1->vlen && p0->flag == p1->flag);
/*
 * If both are user kernels, then they may be repeats.  For user kernels,
 * they are the same if both ID and flag match, else they are not.
 */
   else if (p0->ID > 0 && p1->ID > 0)
      return(p0->ID == p1->ID && p0->flag == p1->flag);
   return(0);  /* Can't be the same if above criteria fails */
}

/*
 * RETURNS: flags that necessitate recompilation, not including KRUNTIME,
 * which is encoded in kb
 */
int GetCompTimeFlags(ATL_mmnode_t *mp)
{
   int iflg;
   iflg = ATL_MMF_MVGET(mp->flag);  /* MVbits change kern at comp time */
   iflg |=  (((mp->flag) & 1)<<3);  /* LDTOP/BOT could be compile-time dec */
   if (mp->kmaj > 1)
      iflg |= 1<<4;
   return(iflg);
}
int ExactKernelInList(ATL_mmnode_t *mmb, ATL_mmnode_t *p)
/*
 * RETURNS: 1 if p is duplicated in mmb, else 0
 */
{
   ATL_mmnode_t *mp;
   if (!p || !mmb)
      return(0);
   for (mp=mmb; mp; mp = mp->next)
      if (KernelIsExactSame(mp, p))
         return(1);
    return(0);
}

void SpewForthKernProto(FILE *fp, char pre, ATL_mmnode_t *p, char bc)
{
   fprintf(fp, "void ATL_%cu%dAMMM_%d_%d_%x_%dx%dx%d_b%c\n", pre, UID, p->ID,
           FLAG_IS_SET(p->flag, MMF_KRUNTIME)?0:p->kbB, GetCompTimeFlags(p),
           p->mu, p->nu, p->ku,bc);
   fprintf(fp,
      "   (ATL_CSZT,ATL_CSZT,ATL_CSZT,const TYPE*,const TYPE*,TYPE*,\n");
   fprintf(fp,
      "    const TYPE*,const TYPE*,const TYPE*);\n");
}

void SpewForthKernProtos(FILE *fp, char pre, ATL_mmnode_t *mmb, int nbet)
{
   ATL_mmnode_t *mp;
   for (mp=mmb; mp; mp = mp->next)
   {
      if (!ExactKernelInList(mp->next, mp))
      {
         char bc[3] = {'0', '1', 'n'};  /* 0 must come first */
         int ib;
         for (ib=0; ib < nbet; ib++)
            SpewForthKernProto(fp, pre, mp, bc[ib]);
      }
   }
}

void SpewForthKernArray(FILE *fp, char pre, ATL_mmnode_t *mmb,
                        char *vnam, char cbet)
{
   ATL_mmnode_t *mp;
   int n;

   for (n=0,mp=mmb; mp; n++, mp = mp->next);
   fprintf(fp, "static const ammkern_t ATL_UAMM_%s[%d] =\n", vnam, n);
   fprintf(fp, "{\n");
   for (mp=mmb; mp; mp = mp->next)
   {
      fprintf(fp, "   ATL_%cu%dAMMM_%d_%d_%x_%dx%dx%d_b%c", pre, UID, mp->ID,
              FLAG_IS_SET(mp->flag, MMF_KRUNTIME)?0:mp->kbB,
              GetCompTimeFlags(mp), mp->mu, mp->nu, mp->ku, cbet);
      if (mp->next)
         fprintf(fp, ",\n");
   }
   fprintf(fp, "\n};\n\n");
}

/*
 * RETURNS: possibly updated list of all unique mu/nu comboes
 */
typedef struct mnur mnur_t;
struct mnur {int mu; int nu; int kmaj; mnur_t *next;};
mnur_t *GetUniqueMNUnrolls(ATL_mmnode_t *mmb, mnur_t *urb)
{
   ATL_mmnode_t *mp;
   mnur_t *up;
/*
 * For each node in mmb, add to urb if mu/nu combo not already there
 * kmaj only affects A/B copy, and this is for C put, so ignore kmaj
 */
   for (mp = mmb; mp; mp = mp->next)
   {
      for (up=urb; up; up = up->next)
         if (mp->mu == up->mu && mp->nu == up->nu)
            break;
      if (!up)
      {
         up = malloc(sizeof(mnur_t));
         assert(up);
         up->mu = mp->mu;
         up->nu = mp->nu;
         up->kmaj = 0;
         up->next = urb;
         urb = up;
      }
   }
   return(urb);
}

/*
 * RETURNS: list of just unique MUs from mnb not already in mub
 */
mnur_t *GetUniqueMUnrolls(ATL_mmnode_t *mnb, mnur_t *mub)
{
   mnur_t *mup;
   ATL_mmnode_t *mnp;
   if (!mnb)
      return(mub);
   for (mnp=mnb; mnp; mnp = mnp->next)
   {
      const int kmaj = mnp->kmaj;
      for (mup=mub; mup; mup = mup->next)
         if (mup->mu == mnp->mu && mup->kmaj == kmaj)
            break;
      if (!mup)  /* a new mu */
      {
         mup = malloc(sizeof(mnur_t));
         assert(mup);
         mup->nu = mup->mu = mnp->mu;
         mup->next = mub;
         mup->kmaj = kmaj;
         mub = mup;
      }
   }
   return(mub);
}
/*
 * RETURNS: list of just unique NUs from mnb not already in mub
 */
mnur_t *GetUniqueNUnrolls(ATL_mmnode_t *mnb, mnur_t *mub)
{
   mnur_t *mup;
   ATL_mmnode_t *mnp;
   if (!mnb)
      return(mub);
   for (mnp=mnb; mnp; mnp = mnp->next)
   {
      const int kmaj = mnp->kmaj;
      for (mup=mub; mup; mup = mup->next)
         if (mup->mu == mnp->nu && kmaj == mup->kmaj)
            break;
      if (!mup)  /* a new nu */
      {
         mup = malloc(sizeof(mnur_t));
         assert(mup);
         mup->nu = mup->mu = mnp->nu;
         mup->next = mub;
         mup->kmaj = kmaj;
         mub = mup;
      }
   }
   return(mub);
}

void KillUnrollList(mnur_t *b)
{
   mnur_t *p;
   while (b)
   {
      p = b->next;
      free(b);
      b = p;
   }
}
void PrintSwapProto(FILE *fp, char pre, int mu, int nu)
{
   fprintf(fp, "void Mjoin(PATL,ammswp%dx%d)", mu, nu);
   if (pre == 'd' || pre == 's')
      fprintf(fp, "(ATL_CINT nnu, TYPE *A, ATL_CSZT lda, TYPE *b);\n");
   else
      fprintf(fp, "(ATL_CINT nnu, TYPE *A, ATL_CSZT lda, TYPE *r, TYPE *i);\n");
}


void zGenAmmSwp(char pre, FILE *fp, int mu, int nu)
{
}

void GenAmmSwp(char pre, FILE *fp, int mu, int nu)
{
   const int munu=mu*nu;
   int i, j, ib;

   if (pre == 'z' || pre == 'c')
   {
      zGenAmmSwp(pre, fp, mu, nu);
      return;
   }

   fprintf(fp, "#include \"atlas_misc.h\"\n");
   fprintf(fp, "void Mjoin(PATL,ammswp%dx%d)\n", mu, nu);
   fprintf(fp, "(\n");
   fprintf(fp, "   ATL_CINT nnu,   /* CEIL(rowlen / nu) */\n");
   fprintf(fp, "   TYPE *A,        /* col-maj matrix to swap wt b */\n");
   fprintf(fp, "   ATL_CSZT lda1,  /* stride between row elts in A */\n");
   fprintf(fp,
           "   TYPE *b         /* %dx%d C-format row ptr to be swapped */\n",
           mu, nu);
   fprintf(fp, ")\n{\n");

   fprintf(fp, "   register unsigned int j;\n");
   if (nu > 1)
   {
      fprintf(fp, "   const size_t lda2=lda1+lda1");
      for (i=3; i <= nu; i++)
         fprintf(fp, ", lda%d=lda1+lda%d", i, i-1);
      fprintf(fp, ";\n");
   }

   fprintf(fp, "   for (j=nnu; j; j--)\n   {\n");

   fprintf(fp, "      register TYPE a0");
   for (i=1; i < nu; i++)
      fprintf(fp, ", a%d", i);
   fprintf(fp, ";\n");

   fprintf(fp, "      a0 = *A;\n");
   for (i=1; i < nu; i++)
      fprintf(fp, "      a%d = A[lda%d];\n", i, i);
   fprintf(fp, "      *A = *b;\n");
   for (i=1; i < nu; i++)
      fprintf(fp, "      A[lda%d] = b[%d];\n", i, i*mu);
   fprintf(fp, "      *b = a0;\n");
   for (i=1; i < nu; i++)
      fprintf(fp, "      b[%d] = a%d;\n", i*mu, i);
   fprintf(fp, "      b += %d;\n", mu*nu);
   fprintf(fp, "      A += lda%d;\n", nu);

   fprintf(fp, "   }\n");

   fprintf(fp, "}\n");
}

void GenAmmSwapFiles(char pre, ATL_mmnode_t *mmb, char *outd)
{
   mnur_t *ub, *up;
   char *fnam;
   int ia;

   if (pre == 's')
      GenAmmSwapFiles('c', mmb, outd);
   else if (pre == 'd')
      GenAmmSwapFiles('z', mmb, outd);
   ia = strlen(outd) + 24+UIL;
   fnam = malloc(ia);
   assert(fnam);
   ub = GetUniqueMNUnrolls(mmb, NULL);
   for (up=ub; up; up = up->next)
   {
      FILE *fp;
      assert(up->mu < 100 && up->nu < 100);
      sprintf(fnam, "%s/ATL_%cammswp%dx%d.c", outd, pre, up->mu, up->nu);
      fp = fopen(fnam, "w");
      assert(fp);
      GenAmmSwp(pre, fp, up->mu, up->nu);
      fclose(fp);
   }
   KillUnrollList(ub);
   free(fnam);
}
void GenAmmSwapH(char pre, ATL_mmnode_t *mmb, char *outd)
{
   mnur_t *ub, *up;
   ATL_mmnode_t *mp;
   FILE *fp;
   int i;

   fp = StandHStart(pre, mmb, outd, "swp");

   fprintf(fp, "\n");
   ub = GetUniqueMNUnrolls(mmb, NULL);
   for (up=ub; up; up = up->next)
      PrintSwapProto(fp, pre, up->mu, up->nu);
   KillUnrollList(ub);
   fprintf(fp, "\n");

   fprintf(fp, "static const ammswp_t ATL_UAMM_SWP[ATL_UAMM_NCASES] =\n{\n");
   for (i=0, mp=mmb; mp; mp = mp->next, i++)
      if (mp->next)
         fprintf(fp, "   ATL_%cammswp%dx%d,  /* index %d */\n",
                 pre, mp->mu, mp->nu, i);
     else
         fprintf(fp, "   ATL_%cammswp%dx%d   /* index %d */\n",
                 pre, mp->mu, mp->nu, i);

   fprintf(fp, "};\n\n");
   fprintf(fp, "\n#endif  /* end include file guard */\n");
   fclose(fp);
}

int KernelIsSame(ATL_mmnode_t *p0, ATL_mmnode_t *p1)
/*
 * RETURNS: 1 if kernels are the same except for blocking, 0 otherwise
 */
{
/*
 * Kernels aren't the same if one is being compiled with specific KB,
 * and the other has runtime
 */
   if (FLAG_IS_SET(p0->flag, MMF_KRUNTIME) !=
       FLAG_IS_SET(p1->flag, MMF_KRUNTIME))
      return(0);
/*
 * Two generated kernels are the same if mu,nu,ku,VLEN,flag are the same.
 * NOTE: if we make generator handle muladd, etc, MUST UPDATE HERE!!!
 */
   if (p0->ID == 0 && p1->ID == 0)
      return(p0->mu == p1->mu && p0->nu == p1->nu && p0->ku == p1->ku &&
             p0->vlen == p1->vlen && p0->flag == p1->flag);
/*
 * If both are user kernels, then they may be repeats.  For user kernels,
 * they are the same if both ID and flag match, else they are not.
 */
   else if (p0->ID > 0 && p1->ID > 0)
      return(p0->ID == p1->ID && p0->flag == p1->flag);
   return(0);  /* Can't be the same if above criteria fails */
}


void GenRankKH
(
   char pre,
   ATL_mmnode_t *sqb,  /* baseptr  of square-case AMMM kernels */
   ATL_mmnode_t *rkb,  /* rank-K kernels, one for each supported K */
   char *outd
)
{
   FILE *fp;
   mnur_t *putb, *cpyb, *up;
   ATL_mmnode_t *mp;
   int m, n, k;
   int ia, ib;
   char PRE = pre;
   char ac[3] =  {'1', 'n', 'X'};
   char bc[4] = {'1', 'n', '0', 'X'};
   if (pre == 'c')
      pre = 's';
   else  if (pre == 'z')
      pre = 'd';

   assert(sqb && rkb);
   fp = StandHStart(PRE, rkb, outd, "rankK");
   fprintf(fp, "\n");

   for (mp=sqb; mp->next; mp = mp->next);
   fprintf(fp, "#define ATL_MAXM_RKK %d\n", mp->mbB);
   fprintf(fp, "#define ATL_MAXN_RKK %d\n", mp->nbB);
   fprintf(fp, "#define ATL_MAXK_RKK %d\n\n", mp->kbB);
/*
 * Prototype needed copy routines
 */
   putb = GetUniqueMNUnrolls(rkb, NULL);
   fprintf(fp, "/*\n * cblk2mat put function prototypes\n */\n");
   for (up=putb; up; up = up->next)
   {
      for (ib=0; ib < 4; ib++)
      {
         fprintf(fp, "void ATL_%cablk2cmat_%dx%d_a1_b%c\n",
                 PRE, up->mu, up->nu, bc[ib]);
         if (PRE == 'c' || PRE == 'z')
            fprintf(fp, "   (ATL_CSZT,ATL_CSZT,const SCALAR,const TYPE*,const TYPE*,const SCALAR,TYPE *,ATL_CSZT);\n");
         else
            fprintf(fp, "   (ATL_CSZT,ATL_CSZT,const SCALAR,const TYPE*,const SCALAR,TYPE *,ATL_CSZT);\n");
      }
   }
   KillUnrollList(putb);
   fprintf(fp,
      "/*\n * Column-major to access-major copy function prototypes\n */\n");
   cpyb = GetUniqueMUnrolls(rkb, NULL);
   cpyb = GetUniqueNUnrolls(rkb, cpyb);
   for (up=cpyb; up; up = up->next)
   {
      for (ia=0; ia < 3; ia++)
         SpewForthCpProto(PRE, fp, ac[ia], up->mu, up->kmaj);
   }
   KillUnrollList(cpyb);
/*
 * Prototype the rank-K functions
 */
   fprintf(fp, "/*\n * rank-K AMMM kernel prototypes\n */\n");
   for (mp=rkb; mp; mp = mp->next)
   {
/*
 *    For runtime kernels, only prototype 1st time they are seen in list
 */
      if (FLAG_IS_SET(mp->flag, MMF_KRUNTIME))
      {
         ATL_mmnode_t *p;
         if (mp->ID > 0)
         {
            for (p=rkb; p != mp; p = p->next)
               if (p->ID == mp->ID)
                  break;
         }
         else
         {
            for (p=rkb; p != mp; p = p->next)
               if (KernelIsSame(mp, p))
                  break;
         }
         if (mp == p)
         {
            SpewForthKernProto(fp, pre, mp, '0');
            SpewForthKernProto(fp, pre, mp, '1');
            SpewForthKernProto(fp, pre, mp, 'n');
         }
      }
/*
 *    compile-time-K kernels get prototyped for each invocation
 */
      else
      {
         SpewForthKernProto(fp, pre, mp, '0');
         SpewForthKernProto(fp, pre, mp, '1');
         SpewForthKernProto(fp, pre, mp, 'n');
      }
   }
/*
 * Now, crank out funcptr arrays
 */
   for (ib=0; ib < 4; ib++)
   {
      fprintf(fp,
         "\nstatic const ablk2cmat_t ATL_RKK_BLK2C_a1_b%c[%d] =\n{\n",
              bc[ib], ATL_CountNumberOfMMNodes(rkb));
      SpewForthC2BDecl(PRE, rkb, fp, "ablk2cmat", '1', bc[ib]);
   }
   for (ia=0; ia < 3; ia++)
   {
      fprintf(fp, "\n");
      SpewForthCpDecl(PRE, 0, rkb, fp, "ATL_RKK_A2BLK", "cm2am", ac[ia], 1);
      SpewForthCpDecl(PRE, 0, rkb, fp, "ATL_RKK_AT2BLK", "rm2am", ac[ia], 1);
      SpewForthCpDecl(PRE, 0, rkb, fp, "ATL_RKK_B2BLK", "cm2am", ac[ia], 0);
      SpewForthCpDecl(PRE, 0, rkb, fp, "ATL_RKK_BT2BLK", "rm2am", ac[ia], 0);
      if (PRE == 'z' || PRE == 'c')
      {
         SpewForthCpConjDecl(PRE,0,rkb, fp, "ATL_RKK_AC2BLK", "cm2am",ac[ia],1);
         SpewForthCpConjDecl(PRE,0,rkb, fp, "ATL_RKK_AH2BLK", "rm2am",ac[ia],1);
         SpewForthCpConjDecl(PRE,0,rkb, fp, "ATL_RKK_BC2BLK", "cm2am",ac[ia],0);
         SpewForthCpConjDecl(PRE,0,rkb, fp, "ATL_RKK_BH2BLK", "rm2am",ac[ia],0);
      }
   }
   SpewForthKernArray(fp, pre, rkb, "KERN_RKK", '0');
   SpewForthKernArray(fp, pre, rkb, "KERN_RKK_b1", '1');
   SpewForthKernArray(fp, pre, rkb, "KERN_RKK_bn", 'n');
   fprintf(fp, "\n#endif  /* end include file guard */\n");
   fclose(fp);
}

void GenSquareKH(char pre, ATL_mmnode_t *mmb, char *outd)
/*
 * 5. atlas_<pre>amm_kerns.h
 *    defines: ATL_AMM_NCASES
 *    prototypes all kernels, including K-cleanup
 *    1 indexible array gives kernel to use for each case as func ptr
 *    1 indexible array gives K-clean kernel
 */
{
   FILE *fp;
/*
 * Dump out standard header start and kernel prototypes
 */
   fp = StandHStart(pre, mmb, outd, "sqkern");
   fprintf(fp, "\n");
   SpewForthKernProtos(fp, pre, mmb, 3);
   fprintf(fp, "\n");
/*
 * Dump out kernel ptr arrays
 */
   SpewForthKernArray(fp, pre, mmb, "SQKERN_b0", '0');
   SpewForthKernArray(fp, pre, mmb, "SQKERN_b1", '1');
   SpewForthKernArray(fp, pre, mmb, "SQKERN_bn", 'n');

   fprintf(fp, "\n#endif  /* end include file guard */\n");
   fclose(fp);
}

void GenKernH(char pre, ATL_mmnode_t *mmb, ATL_mmnode_t *ukb,
              ATL_mmnode_t *kcb, char *outd)
/*
 * 5. atlas_<pre>amm_kerns.h
 *    defines: ATL_AMM_NCASES
 *    prototypes all kernels, including K-cleanup
 *    1 indexible array gives kernel to use for each case as func ptr
 *    1 indexible array gives K-clean kernel
 */
{
   FILE *fp;
/*
 * Dump out standard header start and kernel prototypes
 */
   fp = StandHStart(pre, mmb, outd, "kern");
   fprintf(fp, "\n");
   SpewForthKernProtos(fp, pre, mmb, 3);
   if (ukb)
      SpewForthKernProtos(fp, pre, ukb, 3);
   fprintf(fp, "\n");
/*
 * Dump out kernel ptr arrays
 */
   SpewForthKernArray(fp, pre, mmb, "KERN_b0", '0');
   SpewForthKernArray(fp, pre, mmb, "KERN_b1", '1');
   SpewForthKernArray(fp, pre, mmb, "KERN_bn", 'n');
   if (kcb)
   {
      SpewForthKernArray(fp, pre, kcb, "KERN_K1", '0');
      SpewForthKernArray(fp, pre, kcb, "KERN_K1_b1", '1');
      SpewForthKernArray(fp, pre, kcb, "KERN_K1_bn", 'n');
   }

   fprintf(fp, "\n#endif  /* end include file guard */\n");
   fclose(fp);
}

void GenCmplxHeaders(char pre, ATL_mmnode_t *mmb, ATL_mmnode_t *rkb, char *outd)
{
   GenCMAJ2AMAJ(pre, mmb, outd, NULL);
   GenC2BLK(pre, mmb, outd, NULL);
   if (rkb)
   {
      GenCMAJ2AMAJ(pre, rkb, outd, "rkk");
      GenC2BLK(pre, rkb, outd, "_rkk");
      GenRankKH(pre, mmb, rkb, outd);
   }
}

void GenHeaderFiles(char pre, ATL_mmnode_t *mmb, ATL_mmnode_t *ukb,
                    ATL_mmnode_t *kcb, ATL_mmnode_t *rkb, ATL_mmnode_t *urb,
                    ATL_mmnode_t *sqb, ATL_mmnode_t *usb, char *outd)
/*
 * Header files required to build full gemm (no timing):
 *X1. atlas_<pre>amm_blk.h :
 *X   defines: ATL_AMM_NCASES, ATL_AMM_MAX[M,N,K]B
 *X   3 arrays indexed by case give blocking
 *X2  atlas_<pre>amm_flag.h
 *X   defines: ATL_AMM_NCASES
 *X   1 indexible array giving KRUNTIME for now
 *X3. atlas_<pre>amm_cm2am_a[1,X,n]:
 *X   defines: ATL_AMM_NCASES
 *X   prototypes all rm2am & cm2am routines
 *X   1 indexible array giving which to use for each block factor
 *X4. atlas_<pre>amm_ablk2cmat.h
 *X   defines: ATL_AMM_NCASES
 *X   prototypes all ablk2cmat routines
 *X   1 indexible array for each alpha,beta combination
 *X   -> 3*4 = 12 indexible arrays total
 *X5. atlas_<pre>amm_kerns.h
 *X   defines: ATL_AMM_NCASES
 *X   prototypes all kernels, including K-cleanup
 *X   1 indexible array gives kernel to use for each case as func ptr
 *X   1 indexible array gives K-clean kernel
 *X6. atlas_<pre>amm_cmat2ablk.h (I don't need, Rakib does)
 *X   defines: ATL_AMM_NCASES
 *X   prototypes all cmat2ablk routines
 *X   1 indexible array for each alpha,beta combination
 *X   -> 3*4 = 12 indexible arrays total
 */
{
   /* if (rkb) */ /* rkb is not used inside GenAmmSum anyway */
      GenAmmSum(pre, mmb, rkb, outd);
   GenAmmSwapH(pre, mmb, outd);
   GenBlockingFile(pre, mmb, outd, "blk");
   GenPerfFile(pre, mmb, outd, "perf");
   GenFlagH(pre, mmb, outd, "flag");
   GenCMAJ2AMAJ(pre, mmb, outd, NULL);
   GenC2BLK(pre, mmb, outd, NULL);
   GenKernH(pre, mmb, ukb, kcb, outd);
   if (rkb)
   {
      GenBlockingFile(pre, rkb, outd, "rkkblk");
      GenFlagH(pre, rkb, outd, "rkkflag");
      GenCMAJ2AMAJ(pre, rkb, outd, "rkk");
      GenC2BLK(pre, rkb, outd, "_rkk");
      GenRankKH(pre, mmb, rkb, outd);
   }
   if (sqb)
   {
      GenBlockingFile(pre, rkb, outd, "sqblk");
      GenFlagH(pre, rkb, outd, "sqflag");
      GenCMAJ2AMAJ(pre, rkb, outd, "sq");
      GenC2BLK(pre, rkb, outd, "_sq");
      GenSquareKH(pre, sqb, outd);
   }
}

/*
 * Splits rkb into two lists: (1) Routines with runtime K (RUNB),
 * (2) Routines with fixed-KB (returned)
 * NOTE: original list rkb is unchanged
 */
ATL_mmnode_t *SplitRankK(ATL_mmnode_t *rkb, ATL_mmnode_t **RUNB)
{
   ATL_mmnode_t *runb=NULL, *fixb=NULL, *p, *np;
   for (p=rkb; p; p = p->next)
   {
      np = CloneMMNode(p);
      if (FLAG_IS_SET(np->flag, MMF_KRUNTIME))
      {
         np->next = runb;
         runb = np;
      }
      else
      {
         np->next = fixb;
         fixb = np;
      }
   }
   *RUNB = runb;
   return(fixb);
}

char *GetKernComp(ATL_mmnode_t *mmp, char *dcomp, char *dflags, char **flgs)
{
   char *comp = dcomp;
   if (mmp->comp)
   {
      comp = (mmp->comp[0] == 'g' && mmp->comp[1] == 'c' &&
              mmp->comp[2] == 'c' &&
             (mmp->comp[3] == '\0' || mmp->comp[3] == ' '))
             ? "$(GOODGCC)" : mmp->comp;
      *flgs = mmp->cflags;
   }
   else
      *flgs = dflags;
   return(comp);
}
void PrintKernComp
(
   FILE *fp,            /* file to print to */
   char pre,
   ATL_mmnode_t *mmp,   /* kernel compile rule is for */
   int UID,             /* user-ID for user-determined kerns */
   char *comp,          /* compiler to use */
   char *cflags,        /* compiler flags to use */
   char *styp,          /* string defining type (eg. "-DSREAL") */
   char cbet,           /* character with beta name ('1', '0', 'n') */
   char *sbet           /* string wt full beta name ("1", "N1", "0") */
)
{
   const int kb = FLAG_IS_SET(mmp->flag, MMF_KRUNTIME)?0:mmp->kbB;
   const int flg = GetCompTimeFlags(mmp);
   if (pre == 'z')
      styp = "-DDREAL=1";
   else if (pre == 'c')
      styp = "-DSREAL=1";
   fprintf(fp, "ATL_%cu%dAMMM_%d_%d_%x_%dx%dx%d_b%c.o : %s\n", pre,
           UID, mmp->ID, kb, flg, mmp->mu, mmp->nu, mmp->ku, cbet, mmp->rout);
   fprintf(fp, "\t%s $(CDEFS2) %s -DBETA%s=1", comp, styp, sbet);
   if (!FLAG_IS_SET(mmp->flag, MMF_KRUNTIME))
      fprintf(fp, " -DMB=%d -DNB=%d, -DKB=%d", mmp->mbB, mmp->nbB, mmp->kbB);
   if (FLAG_IS_SET(mmp->flag, MMF_MVA))
      fprintf(fp, " -DATL_MOVEA");
   if (FLAG_IS_SET(mmp->flag, MMF_MVB))
      fprintf(fp, " -DATL_MOVEB");
   if (FLAG_IS_SET(mmp->flag, MMF_MVC))
      fprintf(fp, " -DATL_MOVEC");
         fprintf(fp,
         " -DATL_USERMM=ATL_%cu%dAMMM_%d_%d_%x_%dx%dx%d_b%c -DATL_UAMMID=%d",
                 pre, UID, mmp->ID, kb, flg, mmp->mu, mmp->nu, mmp->ku, cbet,
                 UID);
         fprintf(fp, " %s -o ATL_%cu%dAMMM_%d_%d_%x_%dx%dx%d_b%c.o -c %s\n",
                 cflags, pre, UID, mmp->ID, kb, flg, mmp->mu, mmp->nu,
                 mmp->ku, cbet, mmp->rout);
}
void GenMakefile
(
   char pre,            /* type/precision prefix : s,d,c,z */
   ATL_mmnode_t *mmb,   /* main kernels for GEMM */
   ATL_mmnode_t *ukb,   /* unique kernels for doing K cleanup of kerns in mmb */
   ATL_mmnode_t *rkb,   /* list of kernels to doing rank-K update */
   ATL_mmnode_t *urb,   /* rank-K update kerns not existing in other lists */
   ATL_mmnode_t *usb,   /* square kernels not existing in other lists */
   char *outd
)
{
   ATL_mmnode_t *mmp, *p, *fixb, *runb;
   mnur_t *mnurb=NULL, *allub, *up;
   FILE *fp;
   char *comp, *cflags;
   char *ln;
   int i;
   char pres[2];
   char be[3] = {'1', 'n', '0'};
   char *bes[3] = {"1", "N1", "0"};
   char al[3] = {'1', 'n', 'X'};
   char dcomp[8] = {'$', '(', 'D', 'M', 'C', ')', '\0'};
   char dflags[12] = {'$', '(', 'D', 'M', 'C', 'F', 'L', 'A', 'G', 'S',
                     ')', '\0'};
   char *styps[2] = {"-DDREAL", "-DDCPLX"};
   char *styp = (pre == 'd' || pre == 'z') ? "-DDREAL" : "-DSREAL";

   pres[0] = pre;
   if (pre == 's' || pre == 'c')
   {
      styps[0] = "-DSREAL";
      styps[1] = "-DSCPLX";
      pres[1] = 'c';
   }
   else
      pres[1] = 'z';

   ln = malloc((strlen(outd)+11)*sizeof(char));
   assert(ln);
   sprintf(ln, "%s/%cMake_amm", outd, pre);
   fp = fopen(ln, "w");
   assert(fp);
   free(ln);
   fprintf(fp, "include ../Make.inc\n");
   fprintf(fp, "CDEFS2=$(CDEFS)\n\n");
   if (pre == 'c')
   {
      fprintf(fp, "CMC=$(SMC)\n");
      fprintf(fp, "CKCFLAGS=$(SKCFLAGS)\n");
      fprintf(fp, "CMCFLAGS=$(SMCFLAGS)\n");
   }
   else if (pre == 'z')
   {
      fprintf(fp, "ZMC=$(DMC)\n");
      fprintf(fp, "ZKCFLAGS=$(DKCFLAGS)\n");
      fprintf(fp, "ZMCFLAGS=$(DMCFLAGS)\n");
   }
/*
 * Build list of all unique MU/NU combos for copy routines
 * Square cases built from mmb, so they are all represented in mmb
 */
   mnurb = GetUniqueMNUnrolls(mmb, NULL);
   mnurb = GetUniqueMNUnrolls(urb, mnurb);
   allub = GetUniqueMUnrolls(mmb, NULL);
   allub = GetUniqueMUnrolls(urb, allub);
   allub = GetUniqueNUnrolls(mmb, allub);
   allub = GetUniqueNUnrolls(urb, allub);
/*
 * Spew out all filenames that must be compiled
 */
   fprintf(fp, "objs =");
/*
 * Routines to copy from MU/NU-major to column major output array
 */
   for (up=mnurb; up; up = up->next)
   {
      int j;
      const int mu=up->mu, nu=up->nu;

      for (j=0; j < 3; j++)
      {
         int k;
         char *rtn[2] = {"ablk2cmat", "cmat2ablk"};
         for (k=0; k < 2; k++)
         {
            int h;
            for (h=0; h < 2; h++)
            {
               if (pre != pres[h])
                  continue;
               if (j == 0)
                  fprintf(fp, " \\\n       ATL_%cammswp%dx%d.o", pre, mu, nu);
               fprintf(fp, " \\\n       ATL_%cu%d%s_%dx%d_a%c_b1.o",
                       pre, UID, rtn[k], mu, nu, al[j]);
               fprintf(fp, " ATL_%cu%d%s_%dx%d_a%c_bX.o",
                       pre, UID, rtn[k], mu, nu, al[j]);
               fprintf(fp, " \\\n       ATL_%cu%d%s_%dx%d_a%c_b0.o",
                       pre, UID, rtn[k], mu, nu, al[j]);
               fprintf(fp, " ATL_%cu%d%s_%dx%d_a%c_bn.o",
                       pre, UID, rtn[k], mu, nu, al[j]);
            }
         }
      }
   }
/*
 * Routines to copy back and forth from A and B
 */
   for (up=allub; up; up = up->next)
   {
      int h;
      for (h=0; h < 2; h++)
      {
        if (pre != pres[h]) continue;
         int j;
         const int u = up->mu;
         for (j=0; j < 3; j++)
         {
            if (up->kmaj > 1)
            {
               fprintf(fp,
 " \\\n       ATL_%cu%drm2am_a%c_%dx%d.o ATL_%cu%dcm2am_a%c_%dx%d.o",
              pre, UID, al[j], up->kmaj, u, pre, UID, al[j], up->kmaj, u);
               fprintf(fp,
 " \\\n       ATL_%cu%dam2rm_a%c_%dx%d.o ATL_%cu%dam2cm_a%c_%dx%d.o",
              pre, UID, al[j], up->kmaj, u, pre, UID, al[j], up->kmaj, u);
            }
            else
            {
               fprintf(fp,
                  " \\\n       ATL_%cu%drm2am_a%c_%d.o ATL_%cu%dcm2am_a%c_%d.o",
                       pre, UID, al[j], u, pre, UID, al[j], u);
               fprintf(fp,
                  " \\\n       ATL_%cu%dam2rm_a%c_%d.o ATL_%cu%dam2cm_a%c_%d.o",
                       pre, UID, al[j], u, pre, UID, al[j], u);
            }
            if (pre == 'c' || pre == 'z')
            {
               if (up->kmaj > 1)
               {
                  fprintf(fp,
 " \\\n       ATL_%cu%drm2am_a%c_%dx%dC.o ATL_%cu%dcm2am_a%c_%dx%dC.o",
                  pre, UID, al[j], up->kmaj, u, pre, UID, al[j], up->kmaj, u);
                  fprintf(fp,
 " \\\n       ATL_%cu%dam2rm_a%c_%dx%dC.o ATL_%cu%dam2cm_a%c_%dx%dC.o",
                  pre, UID, al[j], up->kmaj, u, pre, UID, al[j], up->kmaj, u);
               }
               else
               {
                  fprintf(fp,
               " \\\n       ATL_%cu%drm2am_a%c_%dC.o ATL_%cu%dcm2am_a%c_%dC.o",
                          pre, UID, al[j], u, pre, UID, al[j], u);
                  fprintf(fp,
               " \\\n       ATL_%cu%dam2rm_a%c_%dC.o ATL_%cu%dam2cm_a%c_%dC.o",
                          pre, UID, al[j], u, pre, UID, al[j], u);
               }
            }
         }
      }
   }
/*
 * AMM kernel routines
 */
   for (mmp=mmb; mmp; mmp = mmp->next)
   {
      int kb = mmp->kbB;
/*
 *    Kernels that take runtime K are only compiled once, so don't repeat them
 *    for every KB.  Only generate a statement if this is the first one.
 */
      if (FLAG_IS_SET(mmp->flag, MMF_KRUNTIME))
      {
         const int id = mmp->ID;
         for (p=mmb; p != mmp; p = p->next)
            if (p->ID == id && FLAG_IS_SET(p->flag, MMF_KRUNTIME))
               break;
         if (p != mmp)
            continue;
         kb = 0;
      }
/*
 *    ATL_<pre>UAMMM_<ID>_<kb>_<flg>_<mu>x<nu>x<ku>_b<X>
 */
      for (i=0; i < 3; i++)
         fprintf(fp, " \\\n       ATL_%cu%dAMMM_%d_%d_%x_%dx%dx%d_b%c.o",
                 pre, UID, mmp->ID, kb, GetCompTimeFlags(mmp),
                 mmp->mu, mmp->nu, mmp->ku, be[i]);
   }
/*
 * AMM K-cleanup kernel routines are all unique, so no checking for repeats
 *    ATL_<pre>UAMMM_<ID>_<kb>_<flg>_<mu>x<nu>x<ku>_b0
 */
   for (mmp=ukb; mmp; mmp = mmp->next)
      for (i=0; i < 3; i++)
         fprintf(fp, " \\\n       ATL_%cu%dAMMM_%d_0_%x_%dx%dx%d_b%c.o", pre,
                 UID, mmp->ID, GetCompTimeFlags(mmp), mmp->mu, mmp->nu,
                 mmp->ku, be[i]);
/*
 * library make targets
 */
   fprintf(fp, "\n\nlib : %clib.grd\nall : %clib.grd\n%clib : %clib.grd\n",
           pre, pre, pre, pre);
   fprintf(fp, "%clib.grd : $(objs)\n", pre);
   fprintf(fp, "\t$(ARCHIVER) $(ARFLAGS) $(UAMMlib) $(objs)\n");
   fprintf(fp, "\t $(RANLIB) $(UAMMlib)\n");
   fprintf(fp, "\t touch %clib.grd\n", pre);
   fprintf(fp, "clean : %cclean\n", pre);
   fprintf(fp, "%cclean:\n\t- rm -f $(objs)\n", pre);
   fprintf(fp, "killall : %ckillall\n", pre);
   fprintf(fp, "%ckillall : %cclean\n", pre, pre);
   fprintf(fp, "\t- $(ARCHIVER) d $(UAMMlib) $(objs)\n");
   fprintf(fp, "\t $(RANLIB) $(UAMMlib)\n");
   fprintf(fp, "\t- rm -f ATL_%c*.[S,c]\n", pre);

/*
 * Print out the individual rules for each needed copy function
 */
   dcomp[2] = dflags[2] = toupper(pre);
   dflags[3] = dcomp[3] = 'K';
   fprintf(fp, "\ntsth.o : tsth.c\n");
   fprintf(fp, "\t%s %s $(CDEFS) %s -c tsth.c\n\n", dcomp, dflags, styp);
   fprintf(fp, "#\n# Data copy rules\n#\n");
/*
 * Print out 2-D ablk2Cmat, cmat2ablk and ammswp targets
 */
   for (up=mnurb; up; up = up->next)
   {
      const int mu=up->mu, nu = up->nu;
      char cbe[4] = {'0', '1', 'n', 'X'};
      int ibe[4] =  {0,    1,  -1,  2};
      int i, j;

      for (i=0; i < 4; i++)
      {
         int h;
         for (h=0; h < 2; h++)
         {
            if (pre != pres[h])
               continue;
            if (i == 0)
            {
               fprintf(fp, "ATL_%cammswp%dx%d.o : ATL_%cammswp%dx%d.c\n",
                       pre, mu, nu, pre, mu, nu);
               fprintf(fp, "\t%s %s %s $(CDEFS) -c ATL_%cammswp%dx%d.c\n",
                       dcomp, dflags, styp, pre, mu, nu);
            }
            char pre=pres[h];
            char *styp=styps[h];
            for (j=0; j < 3; j++)
            {
               int k;
               char *rtn[2] = {"ablk2cmat", "cmat2ablk"};
               for (k=0; k < 2; k++)
               {
                  char rn[64];
                  sprintf(rn, "ATL_%cu%d%s_%dx%d_a%c_b%c",
                          pre, UID, rtn[k], mu, nu, al[j], cbe[i]);
                  fprintf(fp, "%s.o : %s.c\n", rn, rn);
                  fprintf(fp, "\t%s %s $(CDEFS) %s -c -DATL_%c%s=%s \\\n",
                          dcomp, dflags, styp, rn[4], rn+6+UIL, rn);
                  fprintf(fp, "          -c %s.c\n", rn);
               }
            }
         }
      }
   }
   KillUnrollList(mnurb);
/*
 * Print out 1-D copy-in routine rules
 */
   for (up=allub; up; up = up->next)
   {
      const int u = up->mu, kmaj=up->kmaj;
      int j;
      for (j=0; j < 3; j++)
      {
         int h;
         for (h=0; h < 2; h++)
         {
            if (pre != pres[h]) continue;
            char *styp=styps[h];
            char *cst[2] = {"", "C"};
            char *cdef[2] = {"", "-DConj_=1 "};
            int g;
            const int G = (pre == 'c' || pre == 'z') ? 2:1;
            for (g=0; g < G; g++)
            {
               int kk;
               int nmI, nmI0=5;
               char *sp;
               char rout[32], rt0[32];
               if (kmaj > 1)
               {
                  sprintf(rout, "ATL_%cu%drm2am_a%c_%dx%d",
                          pre, UID, al[j], kmaj, u);
                  sprintf(rt0, "ATL_%crm2am_a%c_%dx%d", pre, al[j], kmaj, u);
               }
               else
               {
                  sprintf(rout, "ATL_%cu%drm2am_a%c_%d", pre, UID, al[j], u);
                  sprintf(rt0, "ATL_%crm2am_a%c_%d", pre, al[j], u);
               }
               sp = strstr(rout, "rm2am");
               nmI = sp - rout;
               for (kk=0; kk < 4; kk++)
               {
                  if (kk == 1)
                     rt0[5] = rout[6+UIL] = 'c';
                  else if (kk == 2)
                  {
                     rt0[5] = rout[6+UIL] = 'a';
                     rt0[8] = rout[9+UIL] = 'r';
                  }
                  else if (kk == 3)
                      rt0[8] = rout[9+UIL] = 'c';

                  fprintf(fp, "%s%s.o : %s.c\n", rout, cst[g], rout);
               fprintf(fp,
                       "\t%s %s $(CDEFS) %s%s -D%s%s=%s%s -o %s%s.o -c %s.c\n",
                       dcomp, dflags, cdef[g], styp, rt0, cst[g], rout, cst[g],
                       rout, cst[g], rout);
               }
            }
         }
      }
   }
   KillUnrollList(allub);
/*
 * Print out the individual rules for each kernel compile
 */
   dflags[3] = dcomp[3] = 'M';
   fprintf(fp, "#\n#  AMM kernel rules\n#\n");
   for (mmp=mmb; mmp; mmp = mmp->next)
   {
/*
 *    Kernels that take runtime K are only compiled once, so print rules on
 *    only the first encounter of that ID
 */
      if (FLAG_IS_SET(mmp->flag, MMF_KRUNTIME))
      {
         const int id = mmp->ID;
         for (p=mmb; p != mmp; p = p->next)
            if (p->ID == id && FLAG_IS_SET(p->flag, MMF_KRUNTIME))
               break;
         if (p != mmp)
            continue;
      }
      comp = GetKernComp(mmp, dcomp, dflags, &cflags);
/*
 *    ATL_<pre>UAMMM_<ID>_<kb>_<flg>_<mu>x<nu>x<ku>_b<X>,
 *    kerns in all 3 beta cases
 */
      for (i=0; i < 3; i++)
         PrintKernComp(fp, pre, mmp, UID, comp, cflags, styp, be[i], bes[i]);
   }
/*
 * K-cleanup needs only the kernel compile rule
 */
   fprintf(fp, "#\n#  K-cleanup rules\n#\n");
   for (mmp=ukb; mmp; mmp = mmp->next)
   {
      comp = GetKernComp(mmp, dcomp, dflags, &cflags);
      for (i=0; i < 3; i++)
         PrintKernComp(fp, pre, mmp, UID, comp, cflags, styp, be[i], bes[i]);
   }
   fclose(fp);
}

void GenKerns(char pre, ATL_mmnode_t *mmb, ATL_mmnode_t *ukb, ATL_mmnode_t *urb,
              char *outd)
/*
 * Creates/copies all required matmul kernels into outd using specified names
 */
{
   ATL_mmnode_t *mmp, *p;
   mnur_t *mnurb=NULL, *allub, *up;
   char *ln=NULL;
   int lnlen=0, dlen;
   char al[3] = {'1', 'n', 'X'};
   int ial[3] = {1,   -1,   2};
   char pres[2];
   pres[0] = pre;
   pres[1] = (pre == 's') ? 'c' : 'z';

    GenAmmSwapFiles(pre, mmb, outd);
/*
 * Build list of all unique MU/NU combos for copy routines
 */
   mnurb = GetUniqueMNUnrolls(mmb, NULL);
   mnurb = GetUniqueMNUnrolls(urb, mnurb);
   allub = GetUniqueMUnrolls(mmb, NULL);
   allub = GetUniqueMUnrolls(urb, allub);
   allub = GetUniqueNUnrolls(mmb, allub);
   allub = GetUniqueNUnrolls(urb, allub);
   dlen = strlen(outd);
/*
 * Extract every unique block-copy routine
 */
   for (up=mnurb; up; up = up->next)
   {
      const int mu=up->mu, nu=up->nu;
      char cbe[4] = {'0', '1', 'n', 'X'};
      int ibe[4] =  {0,    1,  -1,  2};
      int i, j;
      j = 64+8 + strlen(outd);
      j = (j > 128) ? j : 128;
      if (lnlen < j)
      {
         free(ln);
         lnlen = j;
         ln = malloc(j*sizeof(char));
         assert(ln);
      }
      for (i=0; i < 4; i++)
      {
         for (j=0; j < 3; j++)
         {
            char rn[64];
            int ierr;
            int k;
            for (k=0; k < 2; k++)
            {
               int h=0;
                  if (!k)
                     sprintf(rn, "ATL_%cablk2cmat_%dx%d_a%c_b%c.c",
                             pre, mu, nu, al[j], cbe[i]);
                  else
                     sprintf(rn, "ATL_%ccmat2ablk_%dx%d_a%c_b%c.c",
                             pre, mu, nu, al[j], cbe[i]);
                  sprintf(ln,
                     "make %s pre=%c mu=%d nu=%d al=%c be=%c alpha=%d beta=%d",
                          rn, pre, mu, nu, al[j], cbe[i], ial[j], ibe[i]);
                  ierr = system(ln);
                  if (ierr)
                  {
                     fprintf(stderr, "FAILED CMND='%s'\n", ln);
                     exit(ierr);
                  }
                  sprintf(ln, "mv %s %s/ATL_%cu%d%s", rn, outd, pre, UID, rn+5);
                  ierr = system(ln);
                  if (ierr)
                  {
                     fprintf(stderr, "FAILED CMND='%s'\n", ln);
                     exit(ierr);
                  }
            }
         }
      }
   }
   KillUnrollList(mnurb);

/*
 * Routines to copy back and forth from A and B
 */
   for (up=allub; up; up = up->next)
   {
      const int u = up->mu, kmaj=up->kmaj;
      int j;
      j = 16 * 40 + (strlen(outd)<<1);
      j = (j > 90) ? j : 90;
      if (lnlen < j)
      {
         free(ln);
         lnlen = j;
         ln = malloc(j*sizeof(char));
         assert(ln);
      }
      for (j=0; j < 3; j++)
      {
         int h;
         for (h=0; h < 2; h++)
         {
            int ierr;
            if (h)
               continue;
            sprintf(ln,
                    "make ATL_%crm2am_a%c_%d.c ATL_%ccm2am_a%c_%d.c "
                    "ATL_%cam2rm_a%c_%d.c ATL_%cam2cm_a%c_%d.c "
                    "pre=%c UR=%d alpha=%d al=%c kmaj=%d",
                    pre, al[j], u, pre, al[j], u,
                    pre, al[j], u, pre, al[j], u,
                    pre, u, ial[j], al[j], kmaj);
            ierr = system(ln);
            if (ierr)
            {
               fprintf(stderr, "FAILED CMND='%s'\n", ln);
               exit(ierr);
            }
            if (kmaj > 1)
               sprintf(ln,
                       "mv ATL_%crm2am_a%c_%d.c %s/ATL_%cu%drm2am_a%c_%dx%d.c",
                       pre, al[j], u, outd, pre, UID, al[j], kmaj, u);
            else
               sprintf(ln,
                       "mv ATL_%crm2am_a%c_%d.c %s/ATL_%cu%drm2am_a%c_%d.c",
                       pre, al[j], u, outd, pre, UID, al[j], u);
            ierr = system(ln);
            if (ierr)
            {
               fprintf(stderr, "FAILED CMND='%s'\n", ln);
               exit(ierr);
            }
            if (kmaj > 1)
               sprintf(ln,
                       "mv ATL_%ccm2am_a%c_%d.c %s/ATL_%cu%dcm2am_a%c_%dx%d.c",
                       pre, al[j], u, outd, pre, UID, al[j], kmaj, u);
            else
               sprintf(ln,
                       "mv ATL_%ccm2am_a%c_%d.c %s/ATL_%cu%dcm2am_a%c_%d.c",
                       pre, al[j], u, outd, pre, UID, al[j], u);
            ierr = system(ln);
            if (ierr)
            {
               fprintf(stderr, "FAILED CMND='%s'\n", ln);
               exit(ierr);
            }
            if (kmaj > 1)
               sprintf(ln,
                       "mv ATL_%cam2rm_a%c_%d.c %s/ATL_%cu%dam2rm_a%c_%dx%d.c",
                       pre, al[j], u, outd, pre, UID, al[j], kmaj, u);
            else
               sprintf(ln,
                       "mv ATL_%cam2rm_a%c_%d.c %s/ATL_%cu%dam2rm_a%c_%d.c",
                       pre, al[j], u, outd, pre, UID, al[j], u);
            ierr = system(ln);
            if (ierr)
            {
               fprintf(stderr, "FAILED CMND='%s'\n", ln);
               exit(ierr);
            }
            if (kmaj > 1)
               sprintf(ln,
                       "mv ATL_%cam2cm_a%c_%d.c %s/ATL_%cu%dam2cm_a%c_%dx%d.c",
                       pre, al[j], u, outd, pre, UID, al[j], kmaj, u);
            else
               sprintf(ln,
                       "mv ATL_%cam2cm_a%c_%d.c %s/ATL_%cu%dam2cm_a%c_%d.c",
                       pre, al[j], u, outd, pre, UID, al[j], u);
            ierr = system(ln);
            if (ierr)
            {
               fprintf(stderr, "FAILED CMND='%s'\n", ln);
               exit(ierr);
            }
         }
      }
   }
   KillUnrollList(allub);
/*
 * Copy/generate every unique file, but only once
 */
   for (mmp=mmb; mmp; mmp = mmp->next)
   {
      const int id=mmp->ID;
/*
 *    For generated files, just overwrite dups with same file, won't hurt
 */
      if (id == 0)
      {
         assert(mmp->genstr);
         assert(!system(mmp->genstr));
      }
      else  /* user-supplied files copied from AMMCASES directory */
      {
/*
 *       If this is the first time we've seen this ID, it must be copied
 */
         for (p=mmb; p != mmp && p->ID != id; p = p->next);
         if (p == mmp)
         {
            int i, ierr;
            i = strlen(mmp->rout) + dlen + 16;
            if (i > lnlen)
            {
               if (ln)
                  free(ln);
               ln = malloc(i*sizeof(char));
               assert(ln);
               lnlen = i;
            }
            sprintf(ln, "cp AMMCASES/%s %s/.", mmp->rout, outd);
            ierr = system(ln);
            if (ierr)
            {
               fprintf(stderr, "FAILED CMND='%s'\n", ln);
               exit(ierr);
            }
         }
      }
   }
/*
 * Copy/generate k-cleanup which is known to be unique
 */
   for (mmp=ukb; mmp; mmp = mmp->next)
   {
      const int id=mmp->ID;
/*
 *    For generated files, just generate it using genstr
 */
      if (id == 0)
      {
         assert(mmp->genstr);
         assert(!system(mmp->genstr));
      }
      else  /* user-supplied files copied from AMMCASES directory */
      {
         int i, ierr;
         i = strlen(mmp->rout) + dlen + 16;
         if (i > lnlen)
         {
            if (ln)
               free(ln);
            ln = malloc(i*sizeof(char));
            assert(ln);
            lnlen = i;
         }
         sprintf(ln, "cp AMMCASES/%s %s/.", mmp->rout, outd);
         ierr = system(ln);
         if (ierr)
         {
            fprintf(stderr, "FAILED CMND='%s'\n", ln);
            exit(ierr);
         }
      }
   }
   if (ln)
      free(ln);
}
void GenAllFiles(char pre, ATL_mmnode_t *mmb, ATL_mmnode_t *ukb,
                 ATL_mmnode_t *kcb, ATL_mmnode_t *rkb, ATL_mmnode_t *urb,
                 ATL_mmnode_t *sqb, ATL_mmnode_t *usb,
                 char *outd)
{
   GenHeaderFiles(pre, mmb, ukb, kcb, rkb, urb, sqb, usb, outd);
   GenMakefile(pre, mmb, ukb, rkb, urb, usb, outd);
   GenKerns(pre, mmb, ukb, urb, outd);
}


int KernelInList(ATL_mmnode_t *mmb, ATL_mmnode_t *p)
/*
 * RETURNS: 1 if p is duplicated in mmb, else 0
 */
{
   ATL_mmnode_t *mp;
   if (!p || !mmb)
      return(0);
   for (mp=mmb; mp; mp = mp->next)
      if (KernelIsSame(mp, p))
         return(1);
    return(0);
}

ATL_mmnode_t *StripNonUniqueKs(ATL_mmnode_t *ukb, ATL_mmnode_t *mmb)
/*
 * Deletes any ukb node that also appears in mmb,
 * RETURNS: possibly shortened ukb
 */
{
   ATL_mmnode_t *mp, *prev;
/*
 * Delete any repetitive nodes starting unique queue
 */
   while(ukb && KernelInList(mmb, ukb))
      ukb = KillMMNode(ukb);
   if (!ukb)
      return(ukb);
/*
 * Now, delete any internal non-unique K-cleanup
 */
   prev = ukb;
   mp = ukb->next;
   while (mp)
   {
      if (KernelInList(mmb, mp))
         mp = prev->next = KillMMNode(mp);
      else
      {
         prev = mp;
         mp = mp->next;
      }
   }
   return(ukb);
}
ATL_mmnode_t *StripExactMatchKs(ATL_mmnode_t *ukb, ATL_mmnode_t *mmb)
/*
 * Deletes any ukb node that also appears in mmb with same K-value,
 * RETURNS: possibly shortened ukb
 */
{
   ATL_mmnode_t *mp, *prev;
/*
 * Delete any repetitive nodes starting unique queue
 */
   while(ukb && ExactKernelInList(mmb, ukb))
      ukb = KillMMNode(ukb);
   if (!ukb)
      return(ukb);
/*
 * Now, delete any internal non-unique K-cleanup
 */
   prev = ukb;
   mp = ukb->next;
   while (mp)
   {
      if (ExactKernelInList(mmb, mp))
         mp = prev->next = KillMMNode(mp);
      else
      {
         prev = mp;
         mp = mp->next;
      }
   }
   return(ukb);
}
/*
 * RETURNS: mmb, with all repeated kernels removed
 */
ATL_mmnode_t *RemoveNonUniqueKernels(ATL_mmnode_t *mmb)
{
   ATL_mmnode_t *mp;
   if (!mmb || !mmb->next)
      return(mmb);
   for (mp=mmb; mp; mp = mp->next)
   {
      ATL_mmnode_t *p=mp->next, *prev=mp;
      while (p)
      {
         if (KernelIsSame(mp, p))
            prev->next = p = KillMMNode(p);
         else
         {
            prev = p;
            p = p->next;
         }
      }
   }
   return(mmb);
}

int main(int nargs, char **args)
{
   char pre='d';
   int verb=1;
   int *nbs;
   char *outd, *ukin, *kcin, *rkin, *sqin;
   ATL_mmnode_t *mmb, *mmp, *ukb=NULL, *kcb=NULL, *rkb=NULL, *urb=NULL,
                *sqb=NULL, *usb=NULL;

   mmb = GetFlags(nargs, args, &pre, &outd, &ukin, &kcin, &rkin, &sqin);
   assert(mmb);
   if (ukin)
   {
      ukb = ReadMMFile(ukin);
      free(ukin);
/*
 *    Now, strip off any ukb node that also appears in mmb, in order to
 *    make sure we don't repeat prototypes, generation, etc
 */
      ukb = StripNonUniqueKs(ukb, mmb);
   }
   if (kcin)
   {
      kcb = ReadMMFile(kcin);
      free(kcin);
   }
   if (rkin)
   {
      rkb = ReadMMFile(rkin);
      urb = CloneMMQueue(rkb);
      urb = RemoveNonUniqueKernels(urb);
      urb = StripExactMatchKs(urb, kcb);
      urb = StripExactMatchKs(urb, mmb);
      free(rkin);
   }
   if (sqin)
   {
      sqb = ReadMMFile(sqin);
      usb = CloneMMQueue(sqb);
      usb = RemoveNonUniqueKernels(usb);
      usb = StripExactMatchKs(usb, mmb);
      usb = StripExactMatchKs(usb, kcb);
      usb = StripExactMatchKs(usb, urb);
      free(sqin);
   }
   FillInGenStrings(pre, mmb, outd);
   FillInGenStrings(pre, ukb, outd);
   FillInGenStrings(pre, kcb, outd);
   FillInGenStrings(pre, rkb, outd);
   FillInGenStrings(pre, urb, outd);
   FillInGenStrings(pre, usb, outd);
   GenAllFiles(pre, mmb, ukb, kcb, rkb, urb, sqb, usb, outd);
   KillAllMMNodes(mmb);
   KillAllMMNodes(ukb);
   KillAllMMNodes(kcb);
   KillAllMMNodes(rkb);
   exit(0);
}
@ROUT emit_amm
@extract -b @(topd)/cw.inc lang=C -def cwdate 2012 -def cwdate 2013 -def cwdate 2015
#include "atlas_misc.h"
#define ATL_JKMDEF 1
#include "atlas_mmparse.h"
#include "atlas_sys.h"

ATL_mmnode_t *RemoveNonUniqueKernels(ATL_mmnode_t *mmb);

void PrintUsage(char *name, int ierr, char *flag)
{
   if (ierr > 0)
      fprintf(stderr, "Bad argument #%d: '%s'\n", ierr, 
              flag?flag:"OUT-OF_ARGUMENTS");
   else if (ierr < 0)
      fprintf(stderr, "ERROR: %s\n", flag);
   fprintf(stderr, "USAGE: %s [flags]:\n", name);
   fprintf(stderr, "   -p [s,d,c,z]: set type/precision prefix (d) \n");
   fprintf(stderr, "   -d <outdir>: directory to dump files to\n");
   fprintf(stderr, "   -g <rect kern file> <geKCleanFile>\n");
   fprintf(stderr, "   -r <rank-K kernel file> \n");
   fprintf(stderr, "   -s <square-case kernel file> <sqKCleanFile>\n");
   fprintf(stderr, "   -t <trsm file> : should match -s\n");
   exit(ierr ? ierr : -1);
}

/*
 * RETURNS: precision prefix [s,d,c,z]
 */
char GetFlags(int nargs, char **args, char **DOUT, 
              ATL_mmnode_t **GEMM, ATL_mmnode_t **GEK1,
              ATL_mmnode_t **SQMM, ATL_mmnode_t **SQK1,
              ATL_mmnode_t **RKMM, ATL_mmnode_t **TRSM,
              ATL_mmnode_t **cGEMM, ATL_mmnode_t **cGEK1,
              ATL_mmnode_t **cSQMM, ATL_mmnode_t **cSQK1,
              ATL_mmnode_t **cRKMM, ATL_mmnode_t **cTRSM)
{
   int i, j=0, n, k;
   char pre='d', cpre;
   ATL_mmnode_t *gemm=NULL, *gek1=NULL, *sqmm=NULL, *sqk1=NULL, *rkmm=NULL;
   ATL_mmnode_t *trsm=NULL, *mmb=NULL, *mmp, *mp;

   *DOUT = NULL;
   for (i=1; i < nargs; i++)
   {
      if (args[i][0] != '-')
         PrintUsage(args[0], i, args[i]);
      
      switch(args[i][1])
      {
      case 'p':
        if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
        pre = tolower(args[i][0]);
        assert(pre == 's' || pre == 'd' || pre == 'z' || pre == 'c');
        break;
      case 'g':
        if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
        gemm = ReadMMFile(args[i]);
        assert(gemm);
        if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
        gek1 = ReadMMFile(args[i]);
        assert(gek1);
        break;
      case 't':
        if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
        trsm = ReadMMFile(args[i]);
        assert(trsm);
      case 's':
        if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
        sqmm = ReadMMFile(args[i]);
        assert(sqmm);
        if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
        sqk1 = ReadMMFile(args[i]);
        assert(sqk1);
        break;
      case 'r':
        if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
        rkmm = ReadMMFile(args[i]);
        break;
      case 'd':
        if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
        *DOUT = DupString(args[i]);
        break;
      case 'i':
        if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
        mmp = ReadMMFile(args[i]);
        if (mmb)
        {
           ATL_mmnode_t *mp;
           for (mp=mmb; mp->next; mp = mp->next);
           mp->next = mmp;
        }
        else
           mmb = mmp;
        break;
      default:
         PrintUsage(args[0], i, args[i]);
      }
   }
   if (!gemm)
   {
      assert(!gek1);
      gemm = ReadMMFileWithPath(pre, "res", "geAMMRES.sum");
      assert(gemm);
      gek1 = ReadMMFileWithPath(pre, "res", "geAMMKCLEAN.sum");
      assert(gek1);
   }
   if (!sqmm)
   {
      assert(!sqk1);
      sqmm = ReadMMFileWithPath(pre, "res", "sqAMMRES.sum");
      assert(sqmm);
      sqk1 = ReadMMFileWithPath(pre, "res", "sqAMMKCLEAN.sum");
      assert(sqk1);
   }
   if (!trsm)
   {
      trsm = ReadMMFileWithPath(pre, "res", "tsAMMRES.sum");
      assert(trsm);
   }
   if (!rkmm)
   {
      rkmm = ReadMMFileWithPath(pre, "res", "rkAMMRES.sum");
      assert(rkmm);
   }
   if (!(*DOUT))
      *DOUT = DupString("KERNEL");
   cpre = (pre == 'd') ? 'z' : 'c';
   *cGEMM = ReadMMFileWithPath(cpre, "res", "geAMMRES.sum");
   *cGEK1 = ReadMMFileWithPath(cpre, "res", "geAMMKCLEAN.sum");
   *cSQMM = ReadMMFileWithPath(cpre, "res", "sqAMMRES.sum");
   *cSQK1 = ReadMMFileWithPath(cpre, "res", "sqAMMKCLEAN.sum");
   *cRKMM = ReadMMFileWithPath(cpre, "res", "rkAMMRES.sum");
   *cTRSM = ReadMMFileWithPath(cpre, "res", "tsAMMRES.sum");
   *GEMM = gemm;
   *GEK1 = gek1;
   *SQMM = sqmm;
   *SQK1 = sqk1;
   *RKMM = rkmm;
   *TRSM = trsm;
   return(pre);
}

char *GetVecStr(char pre, int vlen)
{
   if (vlen == 1)
      return("scalar");
   #ifdef ATL_AVX
      if (pre == 'd' || pre == 'z')
      {
         if (vlen == 4)
            return("avx");
         else if (vlen == 2)
            return("sse");
      }
      else if (pre == 's' || pre == 'c')
      {
         if (vlen == 8)
            return("avx");
         else if (vlen == 4)
            return("sse");
      }
   #elif defined(ATL_SSE1)
      #ifdef ATL_SSE2
         if ((pre == 'd' || pre == 'z') && vlen == 2)
               return("sse");
      #endif
      if ((pre == 's' || pre == 'c') && vlen == 4)
         return("sse");
   #endif
/*
 * Any vector length > 1 that isn't one of our known cases uses gnuvec
 */
   return("gvec");
}

void FillInGenStrings
(
   char pre,
   ATL_mmnode_t *mmb,  /* queue to look through */
   char *dir           /* output directory to generate into */
)
/*
 * Creates GenString for any ID=0 in mmb
 */
{
   ATL_mmnode_t *mp;
   char *frm="make gen_amm_%s lat=%d mu=%d nu=%d ku=%d kb=%d vlen=%d rt=%s/%s kmaj=%d";
   int frml;

   if (pre == 'z')
      pre = 'd';
   else if (pre == 'c')
      pre = 's';

   frml = strlen(frm);
   for (mp=mmb; mp; mp = mp->next)
   {
      if (mp->ID == 0)  /* is generated file */
      {
         int ll;
         char *sp, *vec;
         int vlen = mp->vlen;

         assert(mp->rout);  /* should have been filled in by search */
         ll = frml + strlen(dir) + strlen(mp->rout) + 8;
         sp = malloc(ll*sizeof(char));
         assert(sp);

         vec = GetVecStr(pre, mp->vlen);
@skip         if (vec[0] == 'g' && vec[1] == 'v' && vec[2] == 'e' && vlen != 1)
@skip            vlen *= (pre == 'd') ? 8:4;

         sprintf(sp, frm, vec, mp->lat, mp->mu, mp->nu,
                 mp->ku, FLAG_IS_SET(mp->flag, MMF_KRUNTIME) ? 0 : mp->kbB,
                 vlen, dir, mp->rout, mp->kmaj);
         mp->genstr = sp;
      }
   }
}

void PrintBegBlock(char pre, ATL_mmnode_t *mmb, char *pfx, char *nam, FILE *fp)
{
   ATL_mmnode_t *mp;
   char PRE = toupper(pre);
   int i;

   if (nam)
   {
      if (pfx)
         fprintf(fp,
         "#ifndef ATLAS_%c%sAMM_%s_H\n   #define ATLAS_%c%sAMM_%s_H\n\n",
                 PRE, pfx, nam, PRE, pfx, nam);
      else
         fprintf(fp,"#ifndef ATLAS_%cAMM_%s_H\n   #define ATLAS_%cAMM_%s_H\n\n",
                 PRE, nam, PRE, nam);
      fprintf(fp, "#include \"atlas_amm.h\"\n");
   }
   else
      fprintf(fp, "#ifndef ATLAS_%cAMM_H\n   #define ATLAS_%cAMM_H\n\n",
              PRE, PRE);
/*
 * Count mmb, and print def of NCASES
 */
   for (mp=mmb,i=0; mp; i++, mp = mp->next);
   if (pfx)
      fprintf(fp, "#define ATL_%c%sAMM_NCASES %d\n", pre, pfx, i);
   else if (!nam || strstr(nam, "RANKK") == NULL)
   {
      fprintf(fp, "#ifdef ATL_AMM_NCASES\n");
      fprintf(fp, "   #if ATL_AMM_NCASES != %d\n", i);
      fprintf(fp, "      #error \"NCASES MISMATCH!\"\n");
      fprintf(fp, "   #endif\n");
      fprintf(fp, "#else\n");
      fprintf(fp, "   #define ATL_AMM_NCASES %d\n", i);
      fprintf(fp, "#endif\n");
   }
}

char *GetHName(char pre, char *outd, char *pfx, char *bnam)
{
   int i, NOBASE=0;
   char *fnam;
   if (!bnam)
   {
      NOBASE = 1;
      bnam = "";
   }
   i = strlen(outd) + strlen(bnam) + strlen(pfx) + 16;

   fnam = malloc(i*sizeof(char));
   assert(fnam);
   if (NOBASE)
      sprintf(fnam, "%s/atlas_%c%samm.h", outd, pre, pfx);
   else
      sprintf(fnam, "%s/atlas_%c%samm_%s.h", outd, pre, pfx, bnam);
   return(fnam);
}

FILE *StandHStart(char pre, ATL_mmnode_t *mmb, char *pfx, 
                  char *outd,  char *bnam)
{
   char *fnam;
   FILE *fp;
   int i;

   assert(outd);
   fnam = GetHName(pre, outd, pfx, bnam);
   fp = fopen(fnam, "w");
   assert(fp);
   if (bnam)
   {
      for (i=0; bnam[i]; i++)
         fnam[i] = toupper(bnam[i]);
      fnam[i] = '\0';
      if (strstr(bnam, "perf"))
         PrintBegBlock(pre, mmb, pfx, fnam, fp);
      else
         PrintBegBlock(pre, mmb, NULL, fnam, fp);
   }
   else
      PrintBegBlock(pre, mmb, NULL, NULL, fp);
   free(fnam);
   return(fp);
}

@extract -b @(basd)/atlas.base rout=Mylcm

void GenAmmSum(char pre, ATL_mmnode_t *mmb, ATL_mmnode_t *rkb, 
               char *pfx, char *outd)
{
   ATL_mmnode_t *mp, *p66;
   char *fnam;
   FILE *fp;
   char *type = "unsigned short";
   int i, n, maxb, maxNB, maxMB, maxKB, maxkmaj;
   char PRE = toupper(pre), bc[3] = {'M', 'N', 'K'};
   double mfB;

   fp = StandHStart(pre, mmb, pfx, outd, "sum");
   maxkmaj = maxNB = maxKB = maxMB = 0;
   mfB = 0.0;
   for (n=0,mp=mmb; mp; n++, mp = mp->next)
   {
      maxkmaj = Mmax(maxkmaj, mp->kmaj);
      maxMB = Mmax(maxMB, mp->mbB);
      maxNB = Mmax(maxNB, mp->nbB);
      maxKB = Mmax(maxKB, mp->kbB);
      mfB = Mmax(mfB, mp->mflop[0]);
   }
   if (maxkmaj == 1)
      maxkmaj = 0;
   maxb = Mmax(maxMB, maxNB);
   maxb = Mmax(maxb, maxKB);
   fprintf(fp, "\n#define ATL_AMM_MAXMB %d\n", maxMB);
   fprintf(fp, "#define ATL_AMM_MAXNB %d\n", maxNB);
   fprintf(fp, "#define ATL_AMM_MAXKB %d\n", maxKB);
   fprintf(fp, "#define ATL_AMM_MAXKMAJ %d\n\n", maxkmaj);

   for (mp=mmb; mp && mp->next; mp = mp->next);
   assert(mp);
   fprintf(fp, "#define ATL_AMM_LMU %d\n", mp->mu);
   fprintf(fp, "#define ATL_AMM_LNU %d\n", mp->nu);
   fprintf(fp, "#define ATL_AMM_LKU %d\n", mp->ku);
   fprintf(fp, "#define ATL_AMM_LLCMMN %d\n\n", Mylcm(mp->mu, mp->nu));
   fprintf(fp, "#define ATL_AMM_LLCMU %d\n\n", 
           Mylcm(Mylcm(mp->mu, mp->nu),mp->ku));
/*
 * Find smallest case achieving 2/3 of maximal performance
 */
   for (i=0,mp=mmb; mp && mp->mflop[0]*1.5 < mfB; i++, mp = mp->next);
   assert(mp);
   fprintf(fp, "#define ATL_AMM_66IDX %d\n", i);
   fprintf(fp, "#define ATL_AMM_66MB %d\n", mp->mbB);
   fprintf(fp, "#define ATL_AMM_66NB %d\n", mp->nbB);
   fprintf(fp, "#define ATL_AMM_66KB %d\n", mp->kbB);
   fprintf(fp, "#define ATL_AMM_66LCMMN %d\n\n", Mylcm(mp->mu, mp->nu));
   fprintf(fp, "#define ATL_AMM_66LCMU %d\n\n", 
           Mylcm(Mylcm(mp->mu, mp->nu),mp->ku));
   fprintf(fp, "#define ATL_AMM_66RATIO %1.4lf\n\n", mp->mflop[0]/mfB);
/*
 * Find smallest case achieving 98% of maximal performance
 */
   for (i=0,mp=mmb; mp && mp->mflop[0] < 0.98*mfB; i++, mp = mp->next);
   assert(mp);
   fprintf(fp, "#define ATL_AMM_98IDX %d\n", i);
   fprintf(fp, "#define ATL_AMM_98MB %d\n", mp->mbB);
   fprintf(fp, "#define ATL_AMM_98NB %d\n", mp->nbB);
   fprintf(fp, "#define ATL_AMM_98KB %d\n", mp->kbB);
   fprintf(fp, "#define ATL_AMM_98LCMMN %d\n\n", Mylcm(mp->mu, mp->nu));
   fprintf(fp, "#define ATL_AMM_98LCMU %d\n\n", 
           Mylcm(Mylcm(mp->mu, mp->nu),mp->ku));
   fprintf(fp, "#define ATL_AMM_98RATIO %1.4lf\n\n", mp->mflop[0]/mfB);
   if (rkb)
   {
      maxkmaj = maxNB = maxKB = maxMB = 0;
      mfB = 0.0;
      for (n=0,mp=rkb; mp; n++, mp = mp->next)
      {
         maxkmaj = Mmax(maxkmaj, mp->kmaj);
         maxMB = Mmax(maxMB, mp->mbB);
         maxNB = Mmax(maxNB, mp->nbB);
         maxKB = Mmax(maxKB, mp->kbB);
         mfB = Mmax(mfB, mp->mflop[0]);
      }
      if (maxkmaj == 1)
         maxkmaj = 0;
      fprintf(fp, "#define ATL_MAXM_RKK %d\n", maxMB);
      fprintf(fp, "#define ATL_MAXN_RKK %d\n", maxNB);
      fprintf(fp, "#define ATL_MAXK_RKK %d\n", maxKB);
      fprintf(fp, "#define ATL_MAXKMAJ_RKK %d\n\n", maxkmaj);
/*
 *    Find smallest case achieving 2/3 of maximal performance
 */
      for (i=0,mp=rkb; mp && mp->mflop[0]*1.5 < mfB; i++, mp = mp->next);
      assert(mp);
      fprintf(fp, "#define ATL_66IDX_RKK %d\n", i);
      fprintf(fp, "#define ATL_66NB_RKK %d\n", mp->mbB);
      fprintf(fp, "#define ATL_66MB_RKK %d\n", mp->nbB);
      fprintf(fp, "#define ATL_66KB_RKK %d\n", mp->kbB);
      fprintf(fp, "#define ATL_66RATIO_RKK %1.4lf\n\n", mp->mflop[0]/mfB);
   }
   fprintf(fp, "#define ATL_AMMFLG_KRUNTIME(flg_) ((flg_) & 1)\n");
   fprintf(fp, "#define ATL_AMMFLG_KMAJOR(flg_) ((flg_) & 2)\n");

   fprintf(fp, "\n#endif  /* end include file guard */\n");
   fclose(fp);
}

void GenPerfFile(char pre, ATL_mmnode_t *mmb, char *pfx, char *outd, 
                 double mfMax)
{
   ATL_mmnode_t *mp;
   #define NTHRSH 11
   int THRSH[NTHRSH] = {25, 33, 50, 66, 75, 80, 85, 90, 95, 98, 99};
   int idxT[NTHRSH];
   ATL_mmnode_t *mpT[NTHRSH];
   char *fnam;
   FILE *fp;
   char *type = "float";
   int i, j, n, maxb, maxNB, maxMB, maxKB, maxkmaj, idxMax=0;
   const int FNDMAX = (mfMax == 0.0);
   char PRE = toupper(pre), bc[3] = {'M', 'N', 'K'};

   fp = StandHStart(pre, mmb, pfx, outd, "perf");

   if (FNDMAX)
   {
      for (i=0; i < NTHRSH; i++)
         mpT[i] = NULL;
      for (n=0,mp=mmb; mp; n++, mp = mp->next)
      {
         if (mp->mflop[0] > mfMax)
         {
            mfMax = mp->mflop[0];
            idxMax = n;
         }
      }
   }
   else
   {
      for (n=0,mp=mmb; mp; n++, mp = mp->next);
      idxMax = -1;
   }
   fprintf(fp, "#define ATL_%sAMM_DENOM %le /* (%.2f)*/ \n", pfx,
           mfMax, mfMax);
   fprintf(fp, "#define ATL_%sAMM_MAXMFLOPIDX %d\n\n", pfx, idxMax);
   if (FNDMAX)
   {
      for (n=0,mp=mmb; mp; mp = mp->next, n++)
      {
         double mf = mp->mflop[0] / mfMax;
         for (i=0; i < NTHRSH; i++)
         {
            if (!mpT[i] && THRSH[i]*0.01*mfMax < mp->mflop[0])
            {
               mpT[i] = mp;
               idxT[i] = n;
            }
         }
      }
      for (i=0; i < NTHRSH; i++)
      {
         mp = mpT[i];
      @multidef fd
         idxT[i] mp->mbB mp->nbB mp->kbB Mylcm(mp->mu,mp->nu) 
         Mylcm(Mylcm(mp->mu,mp->nu),mp->ku)
      @endmultidef
      @whiledef nm IDX MB NB KB LCMMN LCMU
         fprintf(fp, "#define ATL_AMM_%d@(nm) %d\n", THRSH[i],
                 @(fd));
         @undef fd
      @endwhile
      }
      fprintf(fp, "\n");
   }

   fprintf(fp, "static const float ATL_%sAMM_PERF[%d] =", pfx, n);
   fprintf(fp, "   /* %% of performance of best kernel */\n{\n");
   for (j=0,mp=mmb; mp; j++,mp = mp->next)
      fprintf(fp, "   %f%c  /* IDX=%d, KB=%d */\n", mp->mflop[0]/mfMax,
              (mp->next)?',':' ', j, mp->kbB);
   fprintf(fp, "};\n\n");

   fprintf(fp, "static const float ATL_%sAMM_TIME[%d] =", pfx, n);
   fprintf(fp, "   /* %% of performance of best kernel */\n{\n");
   for (j=0,mp=mmb; mp; j++,mp = mp->next)
      fprintf(fp, "   %e%c  /* IDX=%d, KB=%d */\n", 
              2.0*mp->mbB*mp->nbB*mp->kbB / (mp->mflop[0]*1.0e6),
              (mp->next)?',':' ', j, mp->kbB);
   fprintf(fp, "};\n\n");

   #if 0   /* found no use for this yet, so don't waste mem wt it */
   fprintf(fp, "static const float ATL_AMM_SPDUPNXT[%d] =", n);
   fprintf(fp, "   /* speedup of next higher NB */\n{\n");
   for (j=0,mp=mmb; mp; j++,mp = mp->next)
   {
      double mf = (mp->next) ? mp->next->mflop[0] : mp->mflop[0];
      fprintf(fp, "   %f%c  /* IDX=%d, KB=%d vs. %d */\n", mf/mp->mflop[0],
              (mp->next)?',':' ', j, mp->kbB, mp->next?mp->next->kbB:mp->kbB);
   }
   fprintf(fp, "};\n\n");
   #endif

   fprintf(fp, "#endif  /* end include file guard */\n");
   fclose(fp);
}

void GenBlockingFile(char pre, ATL_mmnode_t *mmb, char *pfx, char *outd)
{
   ATL_mmnode_t *mp;
   char *fnam;
   FILE *fp;
   char *type = "unsigned short";
   int i, n, maxb, maxNB, maxMB, maxKB, maxkmaj;
   char PRE = toupper(pre), bc[3] = {'M', 'N', 'K'};

   fp = StandHStart(pre, mmb, pfx, outd, "blk");
   maxkmaj = maxNB = maxKB = maxMB = 0;
   for (n=0,mp=mmb; mp; n++, mp = mp->next)
   {
      maxkmaj = Mmax(maxkmaj, mp->kmaj);
      maxMB = Mmax(maxMB, mp->mbB);
      maxNB = Mmax(maxNB, mp->nbB);
      maxKB = Mmax(maxKB, mp->kbB);
   }
   if (maxkmaj == 1)
      maxkmaj = 0;
   maxb = Mmax(maxMB, maxNB);
   maxb = Mmax(maxb, maxKB);
   fprintf(fp, "#define ATL_AMM_MAXMB %d\n", maxMB);
   fprintf(fp, "#define ATL_AMM_MAXNB %d\n", maxNB);
   fprintf(fp, "#define ATL_AMM_MAXKB %d\n", maxKB);
   fprintf(fp, "#define ATL_AMM_MAXKMAJ %d\n", maxkmaj);
   fprintf(fp, "\n");

   if (maxb <= 255)
      type = "unsigned char";
   for (i=0; i < 3; i++)
   {
      int j;
      fprintf(fp, "static const %s ATL_AMM_%cBs[%d] =\n{\n", 
              type, bc[i], n);
      for (j=0,mp=mmb; mp; j++,mp = mp->next)
      {
         int b;
         if (bc[i] == 'M')
            b = mp->mbB;
         else if (bc[i] == 'N')
            b = mp->nbB;
         else if (bc[i] == 'K')
            b = mp->kbB;
         if (mp->next)
            fprintf(fp, "%8d,  /* index %d */\n", b, j);
         else
            fprintf(fp, "%8d   /* index %d */\n", b, j);
      }
      fprintf(fp, "};\n\n");
   }
   for (i=0; i < 3; i++)
   {
      int j;
      fprintf(fp, "static const %s ATL_AMM_%cUs[%d] =\n{\n", 
              type, bc[i], n);
      for (j=0,mp=mmb; mp; j++,mp = mp->next)
      {
         int b;
         if (bc[i] == 'M')
            b = mp->mu;
         else if (bc[i] == 'N')
            b = mp->nu;
         else if (bc[i] == 'K')
         {
            if (FLAG_IS_SET(mp->flag, MMF_KRUNTIME))
               b = mp->ku;
            else
               b = (mp->kmaj > 1) ? mp->ku : mp->kbB;
         }
         if (mp->next)
            fprintf(fp, "%8d,  /* index %d */\n", b, j);
         else
            fprintf(fp, "%8d   /* index %d */\n", b, j);
      }
      fprintf(fp, "};\n\n");
   }
   fprintf(fp, "static const %s ATL_AMM_KBMINs[%d] =\n{\n", type, n);
   for (i=0,mp=mmb; mp; i++,mp = mp->next)
   {
      if (mp->next)
         fprintf(fp, "%8d,  /* index %d */\n", mp->kbmin, i);
      else
         fprintf(fp, "%8d   /* index %d */\n", mp->kbmin, i);
   }
   fprintf(fp, "};\n\n");
   fprintf(fp, "\n#endif  /* end include file guard */\n");
   fclose(fp);
}

void GenFlagH(char pre, ATL_mmnode_t *mmb, char *pfx, char *outd)
{
   FILE *fp;
   int j, n;
   ATL_mmnode_t *mp;

   fp = StandHStart(pre, mmb, pfx, outd, "flag");

   for (n=0,mp=mmb; mp; n++,mp = mp->next);

   fprintf(fp, "static const unsigned char ATL_AMM_KFLAG[%d] =\n{\n", n);
   for (j=0,mp=mmb; mp; j++,mp = mp->next)
   {
      unsigned char flag=FLAG_IS_SET(mp->flag, MMF_KRUNTIME) ? 1 : 0;
      if (mp->kmaj)
         flag |= 2;
      if (mp->next)
         fprintf(fp, "%6d,  /* index %d */\n", flag, j);
      else
         fprintf(fp, "%6d   /* index %d */\n", flag, j);
   }
   fprintf(fp, "};\n\n");
   fprintf(fp, "#define ATL_AMM_KRUNTIME(idx_) (ATL_AMM_KFLAG[idx_] & 1)\n");
   fprintf(fp, "#define ATL_AMM_KMAJOR(idx_) (ATL_AMM_KFLAG[idx_] & 2)\n");
   fprintf(fp, "\n#endif  /* end include file guard */\n");
   fclose(fp);
}

void SpewForthC2MProto(char pre, FILE *fp0, FILE *fp1, int mu, int nu)
{
   char ac[3] = {'1', 'n', 'X'};
   char bc[4] = {'0', '1', 'n', 'X'};
   int ia, ib;
   for (ia=0; ia < 3; ia ++)
   {
      for (ib=0; ib < 4; ib++)
      {
         fprintf(fp0, "void ATL_%cablk2cmat_%dx%d_a%c_b%c\n", 
                 pre, mu, nu, ac[ia], bc[ib]);
         if (pre == 'z' || pre == 'c')
            fprintf(fp0, "   (ATL_CSZT,ATL_CSZT,const SCALAR,const TYPE*,const TYPE*,const SCALAR,TYPE *,ATL_CSZT);\n");
         else
            fprintf(fp0, "   (ATL_CSZT,ATL_CSZT,const SCALAR,const TYPE*,const SCALAR,TYPE *,ATL_CSZT);\n");
         fprintf(fp1, "void ATL_%ccmat2ablk_%dx%d_a%c_b%c\n", 
                 pre, mu, nu, ac[ia], bc[ib]);
         if (pre == 'z' || pre == 'c')
            fprintf(fp1, "   (ATL_CSZT,ATL_CSZT,const SCALAR,const TYPE*,ATL_CSZT,const SCALAR,TYPE*,TYPE*);\n");
         else
            fprintf(fp1, "   (ATL_CSZT,ATL_CSZT,const SCALAR,const TYPE*,ATL_CSZT,const SCALAR,TYPE*);\n");
      }
   }
}

void SpewForthC2BDecl(char pre, ATL_mmnode_t *mmb, FILE *fp, char *rt, 
                      char alp, char bet)
{
   ATL_mmnode_t *mp;
   int j;

   for (j=0,mp=mmb; mp; j++,mp = mp->next)
   {
      fprintf(fp, "   ATL_%c%s_%dx%d_a%c_b%c", 
              pre, rt, mp->mu,mp->nu, alp, bet);
      if (mp->next)
         fprintf(fp, ",  /* index %d */\n", j);
      else
         fprintf(fp, "   /* index %d */\n", j);
      }
      fprintf(fp, "};\n\n");
}

void GenC2BLK(char pre, ATL_mmnode_t *mmb, char *pfx, char *outd)
{
   FILE *fp0, *fp1;
   ATL_mmnode_t *mp;
   int ia, ib;
   char ac[3] = {'1', 'n', 'X'};
   char bc[4] = {'0', '1', 'n', 'X'};
   char *fnam;

   fp0 = StandHStart(pre, mmb, pfx, outd, "ablk2cmat");
   fp1 = StandHStart(pre, mmb, pfx, outd, "cmat2ablk");
   fprintf(fp0, "\n");
   fprintf(fp1, "\n");
/*
 * Crank out prototypes
 */
   SpewForthC2MProto(pre, fp0, fp1, mmb->mu, mmb->nu);
   for (mp=mmb->next; mp; mp = mp->next)
   {
      ATL_mmnode_t *p;
      const int mu=mp->mu, nu=mp->nu;
      for (p=mmb; p->mu != mu || p->nu != nu; p = p->next);
      if (p == mp)  /* first occurance of this mu,nu pair */
         SpewForthC2MProto(pre, fp0, fp1, mp->mu, mp->nu);
   }
   fprintf(fp0, "\n");
   fprintf(fp1, "\n");
/*
 * Now, crank out funcptr arrays
 */
   for (ia=0; ia < 3; ia ++)
   {
      for (ib=0; ib < 4; ib++)
      {
         fprintf(fp0, 
            "static const ablk2cmat_t ATL_AMM_BLK2C_a%c_b%c[ATL_AMM_NCASES] =\n{\n",
                 ac[ia], bc[ib]);
         SpewForthC2BDecl(pre, mmb, fp0, "ablk2cmat", ac[ia], bc[ib]);
         fprintf(fp1, 
            "static const cmat2ablk_t ATL_AMM_C2BLK_a%c_b%c[ATL_AMM_NCASES] =\n{\n",
                 ac[ia], bc[ib]);
         SpewForthC2BDecl(pre, mmb, fp1, "cmat2ablk", ac[ia], bc[ib]);
      }
   }
   fprintf(fp0, "\n#endif  /* end include file guard */\n");
   fclose(fp0);
   fprintf(fp1, "\n#endif  /* end include file guard */\n");
   fclose(fp1);
}

void SpewForthRevCpProto(char pre, FILE *fp, char alp, int u, int kmaj)
{
   assert(0);
}

void SpewForthCpProto(char pre, FILE *fp, char alp, int u, int kmaj)
{
   const int G = (pre == 'c' || pre == 'z') ? 2 : 1;
   const char *cst[2] = {"", "C"};
   int g;

   for (g=0; g < G; g++)
   {
      if (kmaj > 1)
         fprintf(fp, "void ATL_%ccm2am_a%c_%dx%d%s\n", 
                 pre, alp, kmaj, u, cst[g]);
      else
         fprintf(fp, "void ATL_%ccm2am_a%c_%d%s\n", pre, alp, u, cst[g]);
      if (pre == 'z' || pre == 'c')
         fprintf(fp,
    "   (ATL_CSZT,ATL_CSZT,const SCALAR,const TYPE*,ATL_CSZT,TYPE*,TYPE*);\n");
      else
         fprintf(fp,
         "   (ATL_CSZT,ATL_CSZT,const SCALAR,const TYPE*,ATL_CSZT,TYPE*);\n");
      if (kmaj > 1)
         fprintf(fp, "void ATL_%crm2am_a%c_%dx%d%s\n", 
                 pre, alp, kmaj, u, cst[g]);
      else
         fprintf(fp, "void ATL_%crm2am_a%c_%d%s\n", pre, alp, u, cst[g]);
      if (pre == 'z' || pre == 'c')
         fprintf(fp,
     "   (ATL_CSZT,ATL_CSZT,const SCALAR,const TYPE*,ATL_CSZT,TYPE*,TYPE*);\n");
      else
         fprintf(fp,
         "   (ATL_CSZT,ATL_CSZT,const SCALAR,const TYPE*,ATL_CSZT,TYPE*);\n");
   }
}

void SpewForthCpConjDecl(char pre, int REVERSE, ATL_mmnode_t *mmb, FILE *fp, 
                         char *arr, char *rt, char alp, int u)
{
   ATL_mmnode_t *mp;
   int j;

   fprintf(fp, "static const %s_t %s_a%c[%d] =\n{\n",
           REVERSE?"am2cm":"cm2am", arr, alp,  ATL_CountNumberOfMMNodes(mmb));
   for (j=0,mp=mmb; mp; j++,mp = mp->next)
   {
      const int kmaj = mp->kmaj;
      if (kmaj > 1)
         fprintf(fp, "   ATL_%c%s_a%c_%dx%dC", pre, rt, alp, kmaj, 
                 u?mp->mu:mp->nu);
      else
         fprintf(fp, "   ATL_%c%s_a%c_%dC", pre, rt, alp, u?mp->mu:mp->nu);
      if (mp->next)
         fprintf(fp, ",");
      else
         fprintf(fp, " ");
      fprintf(fp, "  /* index %d */\n", j);
   }
   fprintf(fp, "};\n\n");
}

void SpewForthCpDecl(char pre, int REVERSE, ATL_mmnode_t *mmb, FILE *fp, 
                     char *arr, char *rt, char alp, int u)
{
   ATL_mmnode_t *mp;
   int j;

   fprintf(fp, "static const %s_t %s_a%c[%d] =\n{\n", 
           REVERSE?"am2cm":"cm2am", arr, alp, ATL_CountNumberOfMMNodes(mmb));
   for (j=0,mp=mmb; mp; j++,mp = mp->next)
   {
      const int kmaj = mp->kmaj;
      if (kmaj > 1)
         fprintf(fp, "   ATL_%c%s_a%c_%dx%d", pre, rt, alp, kmaj, 
                 u?mp->mu:mp->nu);
      else
         fprintf(fp, "   ATL_%c%s_a%c_%d", pre, rt, alp, u?mp->mu:mp->nu);
      if (mp->next)
         fprintf(fp, ",");
      else
         fprintf(fp, " ");
      fprintf(fp, "  /* index %d */\n", j);
   }
   fprintf(fp, "};\n\n");
}


@define len @23@
void GenAMAJ2CMAJ(char pre, ATL_mmnode_t *mmb, char *outd, char *suff)
/*
 * 3. atlas_<pre>amm_am2cm_a[1,X,n]: 
 *    defines: ATL_AMM_NCASES
 *    prototypes all am2rm & am2cm routines
 *    1 indexible array giving which to use for each block factor
 */
{
   char ac[3] = {'1', 'n', 'X'};
   int ia, j;
   char *fnam, *sp, *np;
   ATL_mmnode_t *mp;

   if (!suff)
      suff = "";
   ia = strlen(outd) + strlen(suff) + @(len);
   fnam = malloc(ia*sizeof(char));
   assert(fnam);
   sprintf(fnam, "%s/atlas_%camm%s_am2cm_a1.h", outd, pre, suff);
   np = fnam+ia-23+12;
   assert(*np == 'a' && np[1] == 'm');
   sp = fnam+ia-4;
   assert(*sp == '1');

   for (ia=0; ia < 3; ia++)
   {
      char *rt[2] = {"am2cm", "am2rm"};
      FILE *fp;
      int kmaj = mmb->kmaj;

      if (kmaj == 1)
         kmaj = 0;
      *sp = ac[ia];
      fp = fopen(fnam, "w");
      assert(fp);
      sp[1] = '\0';
      PrintBegBlock(pre, mmb, NULL, np, fp);
      sp[1] = '.';
      fprintf(fp, "/*\n * mat2blk prototypes\n */\n");
      SpewForthRevCpProto(pre, fp, ac[ia], mmb->mu, kmaj);
      if (mmb->nu != mmb->mu || kmaj > 1)
         SpewForthRevCpProto(pre, fp, ac[ia], mmb->nu, kmaj);
      for (mp=mmb->next; mp; mp = mp->next)
      {
         ATL_mmnode_t *p;
         int mu = mp->mu, nu = mp->nu, kmaj=mp->kmaj;
         for (p=mmb; p != mp; p = p->next)
            if (mu == p->mu && p->kmaj == kmaj)
               break;
         if (p == mp) /* haven't seen before */
            SpewForthRevCpProto(pre, fp, ac[ia], mu, kmaj);
         for (p=mmb; p != mp; p = p->next)
            if ((p->nu == nu && p->kmaj == kmaj) || 
                (p->kmaj == kmaj && p->mu == nu))
               break;
         if (p == mp) /* haven't seen before */
            SpewForthRevCpProto(pre, fp, ac[ia], nu, kmaj);
      }
      fprintf(fp, "\n");
      SpewForthCpDecl(pre,1,mmb, fp, "ATL_AMM_BLK2A", "am2cm", ac[ia], 1);
      SpewForthCpDecl(pre,1,mmb, fp, "ATL_AMM_BLK2AT", "am2rm", ac[ia], 1);
      SpewForthCpDecl(pre,1,mmb, fp, "ATL_AMM_BLK2B", "am2cm", ac[ia], 0);
      SpewForthCpDecl(pre,1,mmb, fp, "ATL_AMM_BLK2BT", "am2rm", ac[ia], 0);
      if (pre == 'c' || pre == 'z')
      {
         SpewForthCpConjDecl(pre, 1, mmb, fp, "ATL_AMM_BLKC2A", 
                             "am2cm", ac[ia], 1);
         SpewForthCpConjDecl(pre, 1, mmb, fp, "ATL_AMM_BLKH2A", 
                             "am2rm", ac[ia], 1);
         SpewForthCpConjDecl(pre, 1, mmb, fp, "ATL_AMM_BLKC2B", 
                             "am2cm", ac[ia], 0);
         SpewForthCpConjDecl(pre, 1, mmb, fp, "ATL_AMM_BLKH2B", 
                             "am2rm", ac[ia], 0);
      }
      fprintf(fp, "\n#endif  /* end include file guard */\n");
      fclose(fp);
   }
   free(fnam);
}
void GenCMAJ2AMAJ(char pre, ATL_mmnode_t *mmb, char *pfx, char *outd)
/*
 * 3. atlas_<pre>amm_cm2am_a[1,X,n]: 
 *    defines: ATL_AMM_NCASES
 *    prototypes all rm2am & cm2am routines
 *    1 indexible array giving which to use for each block factor
 */
{
   char ac[3] = {'1', 'n', 'X'};
   int ia, j;
   char *fnam, *sp, *np;
   ATL_mmnode_t *mp;

   ia = strlen(outd) + strlen(pfx) + @(len);
   fnam = malloc(ia*sizeof(char));
   assert(fnam);
   sprintf(fnam, "%s/atlas_%c%samm_cm2am_a1.h", outd, pre, pfx);
   np = fnam+ia-23+12;
   assert(*np == 'c' && np[1] == 'm');
   sp = fnam+ia-4;
   assert(*sp == '1');

   for (ia=0; ia < 3; ia++)
   {
      char *rt[2] = {"cm2am", "rm2am"};
      FILE *fp;
      int kmaj = mmb->kmaj;

      if (kmaj == 1)
         kmaj = 0;
      *sp = ac[ia];
      fp = fopen(fnam, "w");
      assert(fp);
      sp[1] = '\0';
      PrintBegBlock(pre, mmb, NULL, np, fp);
      sp[1] = '.';
      fprintf(fp, "/*\n * mat2blk prototypes\n */\n");
      SpewForthCpProto(pre, fp, ac[ia], mmb->mu, kmaj);
      if (mmb->nu != mmb->mu || kmaj > 1)
         SpewForthCpProto(pre, fp, ac[ia], mmb->nu, kmaj);
      for (mp=mmb->next; mp; mp = mp->next)
      {
         ATL_mmnode_t *p;
         int mu = mp->mu, nu = mp->nu, kmaj=mp->kmaj;
         for (p=mmb; p != mp; p = p->next)
            if (mu == p->mu && p->kmaj == kmaj)
               break;
         if (p == mp) /* haven't seen before */
            SpewForthCpProto(pre, fp, ac[ia], mu, kmaj);
         for (p=mmb; p != mp; p = p->next)
            if ((p->nu == nu && p->kmaj == kmaj) || 
                (p->kmaj == kmaj && p->mu == nu))
               break;
         if (p == mp) /* haven't seen before */
            SpewForthCpProto(pre, fp, ac[ia], nu, kmaj);
      }
      fprintf(fp, "\n");
      SpewForthCpDecl(pre,0,mmb, fp, "ATL_AMM_A2BLK", "cm2am", ac[ia], 1);
      SpewForthCpDecl(pre,0,mmb, fp, "ATL_AMM_AT2BLK", "rm2am", ac[ia], 1);
      SpewForthCpDecl(pre,0,mmb, fp, "ATL_AMM_B2BLK", "cm2am", ac[ia], 0);
      SpewForthCpDecl(pre,0,mmb, fp, "ATL_AMM_BT2BLK", "rm2am", ac[ia], 0);
      if (pre == 'c' || pre == 'z')
      {
         SpewForthCpConjDecl(pre, 0, mmb, fp, "ATL_AMM_AC2BLK", 
                             "cm2am", ac[ia], 1);
         SpewForthCpConjDecl(pre, 0, mmb, fp, "ATL_AMM_AH2BLK", 
                             "rm2am", ac[ia], 1);
         SpewForthCpConjDecl(pre, 0, mmb, fp, "ATL_AMM_BC2BLK", 
                             "cm2am", ac[ia], 0);
         SpewForthCpConjDecl(pre, 0, mmb, fp, "ATL_AMM_BH2BLK", 
                             "rm2am", ac[ia], 0);
      }
      fprintf(fp, "\n#endif  /* end include file guard */\n");
      fclose(fp);
   }
   free(fnam);
}

int KernelIsExactSame(ATL_mmnode_t *p0, ATL_mmnode_t *p1)
/*
 * RETURNS: 1 if kernels are the same including KB, 0 otherwise
 */
{
/*
 * Kernels aren't the same if one is being compiled with specific KB,
 * and the other has runtime
 */
   if (FLAG_IS_SET(p0->flag, MMF_KRUNTIME) != 
       FLAG_IS_SET(p1->flag, MMF_KRUNTIME))
      return(0);
   if (!FLAG_IS_SET(p0->flag, MMF_KRUNTIME) && (p0->kbB != p1->kbB))
      return(0);
/*
 * Kernels aren't same if one is K-veclen-major and one is not
 */
   if (p0->kmaj != p1->kmaj)
      return(0);
/*
 * Kernels aren't same if the -DATL_MOVE bits don't match
 */
   if (ATL_MMF_MVGET(p0->flag) != ATL_MMF_MVGET(p1->flag))
      return(0);
/*
 * Two generated kernels are the same if mu,nu,kmaj,ku,VLEN,flag are the same.
 * NOTE: if we make generator handle muladd, etc, MUST UPDATE HERE!!!
 */
   if (p0->ID == 0 && p1->ID == 0)
      return(p0->mu == p1->mu && p0->nu == p1->nu && p0->kmaj == p1->kmaj &&
             p0->ku == p1->ku && p0->vlen == p1->vlen && p0->flag == p1->flag);
/*
 * If both are user kernels, then they may be repeats.  For user kernels,
 * they are the same if both ID and flag match, else they are not.
 */
   else if (p0->ID > 0 && p1->ID > 0)
      return(p0->ID == p1->ID && p0->flag == p1->flag);
   return(0);  /* Can't be the same if above criteria fails */
}

/*
 * RETURNS: flags that necessitate recompilation, not including KRUNTIME,
 * which is encoded in kb
 */
int GetCompTimeFlags(ATL_mmnode_t *mp)
{
   int iflg;
   iflg = ATL_MMF_MVGET(mp->flag);  /* MVbits change kern at comp time */
   iflg |=  (((mp->flag) & 1)<<3);  /* LDTOP/BOT could be compile-time dec */
   if (mp->kmaj > 1)
      iflg |= 1<<4;
   return(iflg);
}
int ExactKernelInList(ATL_mmnode_t *mmb, ATL_mmnode_t *p)
/*
 * RETURNS: 1 if p is duplicated in mmb, else 0
 */
{
   ATL_mmnode_t *mp;
   if (!p || !mmb)
      return(0);
   for (mp=mmb; mp; mp = mp->next)
      if (KernelIsExactSame(mp, p))
         return(1);
    return(0);
}

void SpewForthKernProto(FILE *fp, char pre, char *nm, ATL_mmnode_t *p, char bc)
{
   fprintf(fp, "void ATL_%c%s_%d_%d_%x_%dx%dx%d_b%c\n", pre, nm, p->ID, 
           FLAG_IS_SET(p->flag, MMF_KRUNTIME)?0:p->kbB, GetCompTimeFlags(p),
           p->mu, p->nu, p->ku,bc);
   fprintf(fp, 
      "   (ATL_CSZT,ATL_CSZT,ATL_CSZT,const TYPE*,const TYPE*,TYPE*,\n");
   fprintf(fp, 
      "    const TYPE*,const TYPE*,const TYPE*);\n");
}

void SpewForthKernProtos(FILE *fp, char pre, char *nm, ATL_mmnode_t *mmb, 
                         int nbet)
{
   ATL_mmnode_t *mp;
   for (mp=mmb; mp; mp = mp->next)
   {
      char bc[3] = {'0', '1', 'n'};  /* 0 must come first */
      int ib;
      for (ib=0; ib < nbet; ib++)
         SpewForthKernProto(fp, pre, nm, mp, bc[ib]);
   }
}

void SpewForthKernArray(FILE *fp, char pre, ATL_mmnode_t *mmb, 
                        char *vnam, char cbet)
{
   ATL_mmnode_t *mp;
   int n;
   char *nm = (vnam[5] == 'R' && vnam[6] == 'K') ? "AMRK":"AMMM";

   for (n=0,mp=mmb; mp; n++, mp = mp->next);
   fprintf(fp, "static const ammkern_t ATL_AMM_%s[%d] =\n", vnam, n);
   fprintf(fp, "{\n");
   for (mp=mmb; mp; mp = mp->next)
   {
      fprintf(fp, "   ATL_%c%s_%d_%d_%x_%dx%dx%d_b%c", pre, nm, mp->ID, 
              FLAG_IS_SET(mp->flag, MMF_KRUNTIME)?0:mp->kbB, 
              GetCompTimeFlags(mp), mp->mu, mp->nu, mp->ku, cbet);
      if (mp->next)
         fprintf(fp, ",\n");
   }
   fprintf(fp, "\n};\n\n");
}

/*
 * RETURNS: new list of K-cleanup kernels for mmb taken from mmk; 
 * mmb & mmk not changed
 */
ATL_mmnode_t *GetUniqueK1Kerns
(
   char pre,            /* z,c,d,s */
   ATL_mmnode_t *mmb,   /* list of kernels requiring K-cleanup */
   ATL_mmnode_t *mmk,   /* list of K-cleanup kernels */
   char *outd
)
{
   ATL_mmnode_t *kcb=NULL, *prev, *mp;
   for (mp=mmb; mp; mp = mp->next)
   {
      ATL_mmnode_t *kc;
      for (kc=mmk; kc; kc = kc->next) /* search for matching cleanup routine */
         if (kc->mu == mp->mu && kc->nu == mp->nu && kc->kmaj == mp->kmaj)
            break;
      if (!kc)  /* cleanup routine must be in original list! */
      {
         if (mp->ku == 1 && FLAG_IS_SET(mp->flag, MMF_KRUNTIME) &&
             (!mp->kbmin || mp->kbmin == 1))
            kc = mp;
         else
         {
            for (kc=mmb; kc; kc = kc->next)
               if (kc->mu == mp->mu && kc->nu == mp->nu && kc->kmaj == mp->kmaj
                   && kc->ku == 1 && FLAG_IS_SET(kc->flag, MMF_KRUNTIME) &&
                   (!kc->kbmin || kc->kbmin == 1) && 
                   (!kc->kbmax || kc->kbmax >= mp->kbB))
                  break;
            assert(kc);
         }
      }
      assert(kc);
      kc = CloneMMNode(kc);
      kc->mbB = mp->mbB;
      kc->nbB = mp->nbB;
      kc->kbB = mp->kbB;
      if (kcb)
      {
         prev->next = kc;
         prev = prev->next;
      }
      else
         prev = kcb = kc;
      
   }
   FillInGenStrings(pre, kcb, outd);
   return(kcb);
}

/*
 * RETURNS: possibly updated list of all unique mu/nu comboes
 */
typedef struct mnur mnur_t;
struct mnur {int mu; int nu; int kmaj; mnur_t *next;};
mnur_t *GetUniqueMNUnrolls(ATL_mmnode_t *mmb, mnur_t *urb)
{
   ATL_mmnode_t *mp;
   mnur_t *up;
/*
 * For each node in mmb, add to urb if mu/nu combo not already there
 * kmaj only affects A/B copy, and this is for C put, so ignore kmaj
 */
   for (mp = mmb; mp; mp = mp->next)
   {
      for (up=urb; up; up = up->next)
         if (mp->mu == up->mu && mp->nu == up->nu)
            break;
      if (!up)
      {
         up = malloc(sizeof(mnur_t));
         assert(up);
         up->mu = mp->mu;
         up->nu = mp->nu;
         up->kmaj = 0;
         up->next = urb;
         urb = up;
      }
   }
   return(urb);
}

/*
 * RETURNS: list of just unique MUs from mnb not already in mub
 */
mnur_t *GetUniqueMUnrolls(ATL_mmnode_t *mnb, mnur_t *mub)
{
   mnur_t *mup;
   ATL_mmnode_t *mnp;
   if (!mnb)
      return(mub);
   for (mnp=mnb; mnp; mnp = mnp->next)
   {
      const int kmaj = mnp->kmaj;
      for (mup=mub; mup; mup = mup->next)
         if (mup->mu == mnp->mu && mup->kmaj == kmaj)
            break;
      if (!mup)  /* a new mu */
      {
         mup = malloc(sizeof(mnur_t));
         assert(mup);
         mup->nu = mup->mu = mnp->mu;
         mup->next = mub;
         mup->kmaj = kmaj;
         mub = mup;
      }
   }
   return(mub);
}
/*
 * RETURNS: list of just unique NUs from mnb not already in mub
 */
mnur_t *GetUniqueNUnrolls(ATL_mmnode_t *mnb, mnur_t *mub)
{
   mnur_t *mup;
   ATL_mmnode_t *mnp;
   if (!mnb)
      return(mub);
   for (mnp=mnb; mnp; mnp = mnp->next)
   {
      const int kmaj = mnp->kmaj;
      for (mup=mub; mup; mup = mup->next)
         if (mup->mu == mnp->nu && kmaj == mup->kmaj)
            break;
      if (!mup)  /* a new nu */
      {
         mup = malloc(sizeof(mnur_t));
         assert(mup);
         mup->nu = mup->mu = mnp->nu;
         mup->next = mub;
         mup->kmaj = kmaj;
         mub = mup;
      }
   }
   return(mub);
}

void KillUnrollList(mnur_t *b)
{
   mnur_t *p;
   while (b)
   {
      p = b->next;
      free(b);
      b = p;
   }
}

int MMKernsSame1(ATL_mmnode_t *p0, ATL_mmnode_t *p1)
/*
 * RETURNS: 1 if kernels are the same except for blocking, 0 otherwise
 */
{
/*
 * Kernels aren't the same if one is being compiled with specific KB,
 * and the other has runtime
 */
   if (FLAG_IS_SET(p0->flag, MMF_KRUNTIME) != 
       FLAG_IS_SET(p1->flag, MMF_KRUNTIME))
      return(0);
/*
 * Two generated kernels are the same if mu,nu,ku,VLEN,flag are the same.
 * NOTE: if we make generator handle muladd, etc, MUST UPDATE HERE!!!
 */
   if (p0->ID == 0 && p1->ID == 0)
      return(p0->mu == p1->mu && p0->nu == p1->nu && p0->ku == p1->ku &&
             p0->vlen == p1->vlen && p0->flag == p1->flag);
/*
 * If both are user kernels, then they may be repeats.  For user kernels,
 * they are the same if both ID and flag match, else they are not.
 */
   else if (p0->ID > 0 && p1->ID > 0)
      return(p0->ID == p1->ID && p0->flag == p1->flag);
   return(0);  /* Can't be the same if above criteria fails */
}

@beginskip
/*
 * This routine spits out the timing estimate for doing a muXnuXku portion
 * of the computation.  It is a wild estimate, in that assumes you are
 * using mbBxnbBxkbB blocking used during timings, but it's better than nothing.
 * Note we have a MFLOP measure, and mf = 2*M*N*K / (1e6*time)
 * so time = 2*M*N*K / (1e6*mf), which is time for full GEMM, so
 * time / M*N*K is time for 1 K iteration, or t1 = 2 / (1.e6*mf), which we
 * then multiply by mu*nu*ku to get t2 = 2*mu*nu*ku /1.e6*mf, which is the
 * time to do one unrolled iteration of the ku loop (the building block of
 * all usage of this kernel).  For k-major storage, total time can be
 * estimated at:
 *   T = CEIL(M/mu)*CEIL(N/nu)*CEIL(K/ku)*t3
 * For M-major storage it would instead be:
 *   T = CEIL(M/mu) * CEIL(N/nu) * (FLOOR(K/ku)*t3 + K%ku*t3_K1)
 * where t3_K1 is the t3 mentioned above for the KU=1 K-cleanup kernel.
 */
void SpewTimeEst
(
   ATL_mmnode_t *mmb,  /* baseptr  of AMMM kernel queue */
   char *arrnam,       /* name of array to create */
   FILE *fpout,        /* open file stream to print array to */
   int imf             /* which mflop elt to use for timing */
)
{
}
@endskip

void GenRankKH
(
   char pre, 
   ATL_mmnode_t *geb,  /* baseptr  of gemm kernels */
   ATL_mmnode_t *rkb,  /* rank-K kernels, one for each supported K */
   char *outd
)
{
   FILE *fp;
   mnur_t *putb, *cpyb, *up;
   ATL_mmnode_t *mp;
   int m, n, k;
   int ia, ib;
   char PRE = pre;
   char ac[3] =  {'1', 'n', 'X'};
   char bc[4] = {'1', 'n', '0', 'X'};
   if (pre == 'c')
      pre = 's';
   else  if (pre == 'z')
      pre = 'd';

   assert(geb && rkb);
   fp = StandHStart(PRE, rkb, "rk", outd, "kern");
   fprintf(fp, "\n");

   for (mp=geb; mp->next; mp = mp->next);
   fprintf(fp, "#define ATL_MAXM_RKK %d\n", mp->mbB);
   fprintf(fp, "#define ATL_MAXN_RKK %d\n", mp->nbB);
   fprintf(fp, "#define ATL_MAXK_RKK %d\n\n", mp->kbB);
/*
 * Prototype needed copy routines
 */
   putb = GetUniqueMNUnrolls(rkb, NULL);
   fprintf(fp, "/*\n * cblk2mat put function prototypes\n */\n");
   for (up=putb; up; up = up->next)
   {
      for (ib=0; ib < 4; ib++)
      {
         fprintf(fp, "void ATL_%cablk2cmat_%dx%d_a1_b%c\n", 
                 PRE, up->mu, up->nu, bc[ib]);
         if (PRE == 'c' || PRE == 'z')
            fprintf(fp, "   (ATL_CSZT,ATL_CSZT,const SCALAR,const TYPE*,const TYPE*,const SCALAR,TYPE *,ATL_CSZT);\n");
         else
            fprintf(fp, "   (ATL_CSZT,ATL_CSZT,const SCALAR,const TYPE*,const SCALAR,TYPE *,ATL_CSZT);\n");
      }
   }
   KillUnrollList(putb);
   fprintf(fp, 
      "/*\n * Column-major to access-major copy function prototypes\n */\n");
   cpyb = GetUniqueMUnrolls(rkb, NULL);
   cpyb = GetUniqueNUnrolls(rkb, cpyb);
   for (up=cpyb; up; up = up->next)
   {
      for (ia=0; ia < 3; ia++)
         SpewForthCpProto(PRE, fp, ac[ia], up->mu, up->kmaj);
   }
   KillUnrollList(cpyb);
/*
 * Prototype the rank-K functions
 */
   fprintf(fp, "/*\n * rank-K AMMM kernel prototypes\n */\n");
   for (mp=rkb; mp; mp = mp->next)
   {
/*
 *    For runtime-K kernels, only prototype 1st time they are seen in list
 */
      if (FLAG_IS_SET(mp->flag, MMF_KRUNTIME))
      {
         ATL_mmnode_t *p;
         if (mp->ID > 0)
         {
            for (p=rkb; p != mp; p = p->next)
               if (p->ID == mp->ID)
                  break;
         }
         else
         {
            for (p=rkb; p != mp; p = p->next)
               if (MMKernsSame(mp, p))
                  break;
         }
         if (mp == p)
         {
            SpewForthKernProto(fp, pre, "AMRK", mp, '0');
            SpewForthKernProto(fp, pre, "AMRK", mp, '1');
            SpewForthKernProto(fp, pre, "AMRK", mp, 'n');
         }
      }
/*
 *    compile-time-K kernels get prototyped for each invocation
 */
      else
      {
         SpewForthKernProto(fp, pre, "AMRK", mp, '0');
         SpewForthKernProto(fp, pre, "AMRK", mp, '1');
         SpewForthKernProto(fp, pre, "AMRK", mp, 'n');
      }
   }
/*
 * Now, crank out funcptr arrays
 */
   for (ib=0; ib < 4; ib++)
   {
      fprintf(fp,
         "\nstatic const ablk2cmat_t ATL_RKK_BLK2C_a1_b%c[%d] =\n{\n",
              bc[ib], ATL_CountNumberOfMMNodes(rkb));
      SpewForthC2BDecl(PRE, rkb, fp, "ablk2cmat", '1', bc[ib]);
   }
   for (ia=0; ia < 3; ia++)
   {
      fprintf(fp, "\n");
      SpewForthCpDecl(PRE, 0, rkb, fp, "ATL_RKK_A2BLK", "cm2am", ac[ia], 1);
      SpewForthCpDecl(PRE, 0, rkb, fp, "ATL_RKK_AT2BLK", "rm2am", ac[ia], 1);
      SpewForthCpDecl(PRE, 0, rkb, fp, "ATL_RKK_B2BLK", "cm2am", ac[ia], 0);
      SpewForthCpDecl(PRE, 0, rkb, fp, "ATL_RKK_BT2BLK", "rm2am", ac[ia], 0);
      if (PRE == 'z' || PRE == 'c')
      {
         SpewForthCpConjDecl(PRE,0,rkb, fp, "ATL_RKK_AC2BLK", "cm2am",ac[ia],1);
         SpewForthCpConjDecl(PRE,0,rkb, fp, "ATL_RKK_AH2BLK", "rm2am",ac[ia],1);
         SpewForthCpConjDecl(PRE,0,rkb, fp, "ATL_RKK_BC2BLK", "cm2am",ac[ia],0);
         SpewForthCpConjDecl(PRE,0,rkb, fp, "ATL_RKK_BH2BLK", "rm2am",ac[ia],0);
      }
   }
   SpewForthKernArray(fp, pre, rkb, "KERN_RKK", '0');
   SpewForthKernArray(fp, pre, rkb, "KERN_RKK_b1", '1');
   SpewForthKernArray(fp, pre, rkb, "KERN_RKK_bn", 'n');
   fprintf(fp, "\n#endif  /* end include file guard */\n");
   fclose(fp);
}

void GenKernH
(
   char pre, 
   char *outd, 
   char *pfx, 
   ATL_mmnode_t *mmb,  /* full kerns */
   ATL_mmnode_t *k1b   /* K cleanup kerns */
)
/*
 * 5. atlas_<pre>_<pfx>kern.h
 *    defines: ATL_AMM_NCASES
 *    prototypes all kernels, including K-cleanup
 *    1 indexible array gives kernel to use for each case as func ptr
 *    1 indexible array gives K-clean kernel
 */
{
   FILE *fp;
   ATL_mmnode_t *ukb;
   const char upr = (pre == 'z' || pre == 'd') ? 'd' : 's';

   fp = StandHStart(pre, mmb, pfx, outd, "kern");
   fprintf(fp, "\n");
/*
 * For prototyping, create a list of all full and cleanup kerns, and get
 * rid of duplicates
 */
   ukb = AddUniqueMMKernCompList(NULL, mmb);
   ukb = AddUniqueMMKernCompList(ukb, k1b);
   SpewForthKernProtos(fp, upr, "AMMM", ukb, 3);
   fprintf(fp, "\n");
   KillAllMMNodes(ukb);
/*
 * Dump out kernel ptr arrays
 */
   SpewForthKernArray(fp, upr, mmb, "KERN_b0", '0');
   SpewForthKernArray(fp, upr, mmb, "KERN_b1", '1');
   SpewForthKernArray(fp, upr, mmb, "KERN_bn", 'n');
   if (k1b)
   {
      SpewForthKernArray(fp, upr, k1b, "KERN_K1", '0');
      SpewForthKernArray(fp, upr, k1b, "KERN_K1_b1", '1');
      SpewForthKernArray(fp, upr, k1b, "KERN_K1_bn", 'n');
   }

   fprintf(fp, "\n#endif  /* end include file guard */\n");
   fclose(fp);
}

void GenCmplxHeaders(char pre, ATL_mmnode_t *mmb, ATL_mmnode_t *rkb, 
                     char *pfx, char *outd)
{
   GenCMAJ2AMAJ(pre, mmb, pfx, outd);
   GenC2BLK(pre, mmb, pfx, outd);
   if (rkb)
   {
      GenCMAJ2AMAJ(pre, rkb, "rk", outd);
      GenC2BLK(pre, rkb, "rk", outd);
      GenRankKH(pre, mmb, rkb, outd);
   }
}

void GenHeaderFiles(char pre, char *outd, 
                    ATL_mmnode_t *geb, ATL_mmnode_t *gek1b,
                    ATL_mmnode_t *sqb, ATL_mmnode_t *sqk1b,
                    ATL_mmnode_t *rkb, ATL_mmnode_t *trsmb)
/*
 * Header files required to build full gemm (no timing):
 *X1. atlas_<pre>amm_blk.h : 
 *X   defines: ATL_AMM_NCASES, ATL_AMM_MAX[M,N,K]B
 *X   3 arrays indexed by case give blocking
 *X2  atlas_<pre>amm_flag.h
 *X   defines: ATL_AMM_NCASES
 *X   1 indexible array giving KRUNTIME for now
 *X3. atlas_<pre>amm_cm2am_a[1,X,n]: 
 *X   defines: ATL_AMM_NCASES
 *X   prototypes all rm2am & cm2am routines
 *X   1 indexible array giving which to use for each block factor
 *X4. atlas_<pre>amm_ablk2cmat.h
 *X   defines: ATL_AMM_NCASES
 *X   prototypes all ablk2cmat routines
 *X   1 indexible array for each alpha,beta combination
 *X   -> 3*4 = 12 indexible arrays total
 *X5. atlas_<pre>amm_kerns.h
 *X   defines: ATL_AMM_NCASES
 *X   prototypes all kernels, including K-cleanup
 *X   1 indexible array gives kernel to use for each case as func ptr
 *X   1 indexible array gives K-clean kernel
 *X6. atlas_<pre>amm_cmat2ablk.h (I don't need, Rakib does)
 *X   defines: ATL_AMM_NCASES 
 *X   prototypes all cmat2ablk routines
 *X   1 indexible array for each alpha,beta combination
 *X   -> 3*4 = 12 indexible arrays total
 */
{
   ATL_mmnode_t *mp;
   char *pfx;

   pfx = "ge";
   GenAmmSum(pre, geb, rkb, pfx, outd);
   GenBlockingFile(pre, geb, pfx, outd);
   GenPerfFile(pre, geb, pfx, outd, 0.0);
   GenFlagH(pre, geb, pfx, outd);
   GenCMAJ2AMAJ(pre, geb, pfx, outd);
   GenC2BLK(pre, geb, pfx, outd);
   GenKernH(pre, outd, pfx, geb, gek1b);
@skip   GenCmplxHeaders(pre=='s'?'c':'z', geb, rkb, pfx, outd);

   pfx = "sq";
   GenAmmSum(pre, sqb, rkb, pfx, outd);
   GenBlockingFile(pre, sqb, pfx, outd);
   GenPerfFile(pre, sqb, pfx, outd, 0.0);
   GenFlagH(pre, sqb, pfx, outd);
   GenCMAJ2AMAJ(pre, sqb, pfx, outd);
   GenC2BLK(pre, sqb, pfx, outd);
   GenKernH(pre, outd, pfx, sqb, sqk1b);
@skip   GenCmplxHeaders(pre=='s'?'c':'z', sqb, rkb, pfx, outd);

   if (trsmb)
   {
      double maxMF=0.0;
      for (mp=sqb; mp; mp = mp->next)
         if (mp->mflop[0] > maxMF)
             maxMF = mp->mflop[0];
      GenPerfFile(pre, trsmb, "ts", outd, maxMF);
   }
   if (rkb)
   {
      pfx = "rk";
      GenBlockingFile(pre, rkb, pfx, outd);
      GenPerfFile(pre, rkb, pfx, outd, 0.0);
      GenFlagH(pre, rkb, pfx, outd);
      GenCMAJ2AMAJ(pre, rkb, pfx, outd);
      GenC2BLK(pre, rkb, pfx, outd);
      GenRankKH(pre, geb, rkb, outd);
   }
}

/*
 * Splits rkb into two lists: (1) Routines with runtime K (RUNB),
 * (2) Routines with fixed-KB (returned)
 * NOTE: original list rkb is unchanged
 */
ATL_mmnode_t *SplitRankK(ATL_mmnode_t *rkb, ATL_mmnode_t **RUNB)
{
   ATL_mmnode_t *runb=NULL, *fixb=NULL, *p, *np;
   for (p=rkb; p; p = p->next)
   {
      np = CloneMMNode(p);
      if (FLAG_IS_SET(np->flag, MMF_KRUNTIME))
      {
         np->next = runb;
         runb = np;
      }
      else
      {
         np->next = fixb;
         fixb = np;
      }
   }
   *RUNB = runb;
   return(fixb);
}

char *GetKernComp(ATL_mmnode_t *mmp, char *dcomp, char *dflags, char **flgs)
{
   char *comp = dcomp;
   if (mmp->comp)
   {
      comp = (mmp->comp[0] == 'g' && mmp->comp[1] == 'c' &&
              mmp->comp[2] == 'c' && 
             (mmp->comp[3] == '\0' || mmp->comp[3] == ' '))
             ? "$(GOODGCC)" : mmp->comp;
      *flgs = mmp->cflags;
   }
   else
      *flgs = dflags;
   return(comp);
}
void PrintKernComp
(
   FILE *fp,            /* file to print to */
   char pre, 
   ATL_mmnode_t *mmp,   /* kernel compile rule is for */
   int UID,             /* user-ID for user-determined kerns */
   char *nam,           /* base name ("AMMM" or "AMRK") */
   char *comp,          /* compiler to use */
   char *cflags,        /* compiler flags to use */
   char *styp,          /* string defining type (eg. "-DSREAL") */
   char cbet,           /* character with beta name ('1', '0', 'n') */
   char *sbet           /* string wt full beta name ("1", "N1", "0") */
)
{
   const int kb = FLAG_IS_SET(mmp->flag, MMF_KRUNTIME)?0:mmp->kbB;
   const int flg = GetCompTimeFlags(mmp);
   fprintf(fp, "ATL_%c%s_%d_%d_%x_%dx%dx%d_b%c.o : %s\n", pre, nam,
           mmp->ID, kb, flg, mmp->mu, mmp->nu, mmp->ku, cbet, mmp->rout);
   fprintf(fp, "\t%s $(CDEFS2) %s -DBETA%s=1", comp, styp, sbet);
   if (!FLAG_IS_SET(mmp->flag, MMF_KRUNTIME))
      fprintf(fp, " -DMB=%d -DNB=%d, -DKB=%d", mmp->mbB, mmp->nbB, mmp->kbB);
   if (FLAG_IS_SET(mmp->flag, MMF_MVA))
      fprintf(fp, " -DATL_MOVEA");
   if (FLAG_IS_SET(mmp->flag, MMF_MVB))
      fprintf(fp, " -DATL_MOVEB");
   if (FLAG_IS_SET(mmp->flag, MMF_MVC))
      fprintf(fp, " -DATL_MOVEC");
         fprintf(fp, " -DATL_USERMM=ATL_%c%s_%d_%d_%x_%dx%dx%d_b%c", pre, nam,
                 mmp->ID, kb, flg, mmp->mu, mmp->nu, mmp->ku, cbet);
         fprintf(fp, " %s -o ATL_%c%s_%d_%d_%x_%dx%dx%d_b%c.o -c %s\n", 
                 cflags, pre, nam, mmp->ID, kb, flg, mmp->mu, mmp->nu, mmp->ku, 
                 cbet, mmp->rout);
}
@define uid @-1@
@define lib @ATLAS@
void GenMakefile
(
   char pre,            /* type/precision prefix : s,d,c,z */
   char *outd,          /* directory to generate Makefile in */
   ATL_mmnode_t *geb,   /* main kernels for GEMM */
   ATL_mmnode_t *gek1b, /* K-cleanup for gemm kerns */
   ATL_mmnode_t *sqb,   /* kernels where MB=NB=KB */
   ATL_mmnode_t *sqk1b, /* K-cleanup for square kerns */
   ATL_mmnode_t *rkb    /* list of kernels to doing rank-K update */
)
{
   ATL_mmnode_t *mmb, *mmp, *p, *fixb, *runb;
   mnur_t *mnurb=NULL, *allub, *up;
   FILE *fp;
   char *comp, *cflags;
   char *ln;
   int i;
   char pres[2];
   char be[3] = {'1', 'n', '0'};
   char *bes[3] = {"1", "N1", "0"};
   char al[3] = {'1', 'n', 'X'};
   char dcomp[8] = {'$', '(', 'D', 'M', 'C', ')', '\0'};
   char dflags[12] = {'$', '(', 'D', 'M', 'C', 'F', 'L', 'A', 'G', 'S', 
                     ')', '\0'};
   char *styps[2] = {"-DDREAL", "-DDCPLX"};
   char *styp = (pre == 'd' || pre == 'z') ? "-DDREAL" : "-DSREAL";
/*
 * Square & rect kernels handled same way: going to be compiled once for
 * each compile-time K, and once if runtime, so combine them into one big
 * queue for Make generation, w/o repeating same compile-time kernel
 */
   mmb = AddUniqueMMKernCompList(NULL, geb);
   mmb = AddUniqueMMKernCompList(mmb, gek1b);
   mmb = AddUniqueMMKernCompList(mmb, sqk1b);
   mmb = AddUniqueMMKernCompList(mmb, sqb);

   pres[0] = pre;
   if (pre == 's' || pre == 'c')
   {
      styps[0] = "-DSREAL";
      styps[1] = "-DSCPLX";
      pres[1] = 'c';
   }
   else
      pres[1] = 'z';

   ln = malloc((strlen(outd)+11)*sizeof(char));
   assert(ln);
   sprintf(ln, "%s/%cMake_amm", outd, pre);
   fp = fopen(ln, "w");
   assert(fp);
   free(ln);
   fprintf(fp, "include ../Make.inc\n");
   fprintf(fp, "CDEFS2=$(CDEFS)\n\n");
   if (pre == 'c')
   {
      fprintf(fp, "CMC=$(SMC)\n");
      fprintf(fp, "CKCFLAGS=$(SKCFLAGS)\n");
      fprintf(fp, "CMCFLAGS=$(SMCFLAGS)\n");
   }
   else if (pre == 'z')
   {
      fprintf(fp, "ZMC=$(DMC)\n");
      fprintf(fp, "ZKCFLAGS=$(DKCFLAGS)\n");
      fprintf(fp, "ZMCFLAGS=$(DMCFLAGS)\n");
   }
/*
 * Build list of all unique MU/NU combos for copy routines
 */
   mnurb = GetUniqueMNUnrolls(mmb, NULL);
   mnurb = GetUniqueMNUnrolls(rkb, mnurb);
   allub = GetUniqueMUnrolls(mmb, NULL);
   allub = GetUniqueMUnrolls(rkb, allub);
   allub = GetUniqueNUnrolls(mmb, allub);
   allub = GetUniqueNUnrolls(rkb, allub);
/*
 * Spew out all filenames that must be compiled
 */
   fprintf(fp, "objs =");
/*
 * Routines to copy from MU/NU-major to column major output array
 */
   for (up=mnurb; up; up = up->next)
   {
      int j;
      const int mu=up->mu, nu=up->nu;

      for (j=0; j < 3; j++)
      {
         int k;
         char *rtn[2] = {"ablk2cmat", "cmat2ablk"};
         for (k=0; k < 2; k++)
         {
            int h;
            for (h=0; h < 2; h++)
            {
               char pre = pres[h];
               fprintf(fp, " \\\n       ATL_%c%s_%dx%d_a%c_b1.o",
                       pre, rtn[k], mu, nu, al[j]);
               fprintf(fp, " ATL_%c%s_%dx%d_a%c_bX.o",
                       pre, rtn[k], mu, nu, al[j]);
               fprintf(fp, " \\\n       ATL_%c%s_%dx%d_a%c_b0.o",
                       pre, rtn[k], mu, nu, al[j]);
               fprintf(fp, " ATL_%c%s_%dx%d_a%c_bn.o",
                       pre, rtn[k], mu, nu, al[j]);
            }
         }
      }
   }
/*
 * Routines to copy back and forth from A and B
 */
   for (up=allub; up; up = up->next)
   {
      int h;
      for (h=0; h < 2; h++)
      {
         char pre=pres[h];
         int j;
         const int u = up->mu;
         for (j=0; j < 3; j++)
         {
            if (up->kmaj > 1)
               fprintf(fp, 
 " \\\n       ATL_%crm2am_a%c_%dx%d.o ATL_%ccm2am_a%c_%dx%d.o",
                       pre, al[j], up->kmaj, u, pre, al[j], up->kmaj, u);
            else
               fprintf(fp, " \\\n       ATL_%crm2am_a%c_%d.o ATL_%ccm2am_a%c_%d.o",
                       pre, al[j], u, pre, al[j], u);
            if (pre == 'c' || pre == 'z')
            {
               if (up->kmaj > 1)
                  fprintf(fp, 
 " \\\n       ATL_%crm2am_a%c_%dx%dC.o ATL_%ccm2am_a%c_%dx%dC.o",
                          pre, al[j], up->kmaj, u, pre, al[j], up->kmaj, u);
               else
                  fprintf(fp, " \\\n       ATL_%crm2am_a%c_%dC.o ATL_%ccm2am_a%c_%dC.o",
                          pre, al[j], u, pre, al[j], u);
            }
         }
      }
   }
/*
 * AMM kernel routines
 */
   for (mmp=mmb; mmp; mmp = mmp->next)
   {
      int kb = mmp->kbB;
/*
 *    Kernels that take runtime K are only compiled once, so don't repeat them
 *    for every KB.  Only generate a statement if this is the first one.
 */
      if (FLAG_IS_SET(mmp->flag, MMF_KRUNTIME))
      {
         const int id = mmp->ID;
         for (p=mmb; p != mmp; p = p->next)
            if (MMKernsSame(mmp, p))
               break;
         if (p != mmp)
            continue;
         kb = 0;
      }
/* 
 *    ATL_<pre>AMMM_<ID>_<kb>_<flg>_<mu>x<nu>x<ku>_b<X>
 */
      for (i=0; i < 3; i++)
         fprintf(fp, " \\\n       ATL_%cAMMM_%d_%d_%x_%dx%dx%d_b%c.o", 
                 pre, mmp->ID, kb, GetCompTimeFlags(mmp), mmp->mu, mmp->nu, 
                 mmp->ku, be[i]);
   }
/*
 * rank-K AMM routines where KB is runtime variable
 */
   fixb = SplitRankK(rkb, &runb);
   runb = RemoveNonUniqueKernels(runb);
   for (mmp=runb; mmp; mmp = mmp->next)
      for (i=0; i < 3; i++)
         fprintf(fp, " \\\n       ATL_%cAMRK_%d_0_%x_%dx%dx%d_b%c.o", pre, 
                 mmp->ID, GetCompTimeFlags(mmp),mmp->mu,mmp->nu,mmp->ku,be[i]);
/*
 * rank-K AMM routines where KB is compile-time, need obj for each unique kbB
 */
   for (mmp=fixb; mmp; mmp = mmp->next)
   {
      for (i=0; i < 3; i++)
         fprintf(fp, " \\\n       ATL_%cAMRK_%d_%d_%x_%dx%dx%d_b%c.o", 
                 pre, mmp->ID, mmp->kbB, GetCompTimeFlags(mmp), 
                 mmp->mu, mmp->nu, mmp->ku, be[i]);
   }
/*
 * library make targets
 */
   fprintf(fp, "\n\nlib : %clib.grd\nall : %clib.grd\n%clib : %clib.grd\n", 
           pre, pre, pre, pre);
   fprintf(fp, "%clib.grd : $(objs)\n", pre);
   fprintf(fp, "\t$(ARCHIVER) $(ARFLAGS) $(@(lib)lib) $(objs)\n");
   fprintf(fp, "\t $(RANLIB) $(@(lib)lib)\n");
   fprintf(fp, "\t touch %clib.grd\n", pre);
   fprintf(fp, "clean : %cclean\n", pre);
   fprintf(fp, "%cclean:\n\t- rm -f $(objs)\n", pre);
   fprintf(fp, "killall : %ckillall\n", pre);
   fprintf(fp, "%ckillall : %cclean\n", pre, pre);
   fprintf(fp, "\t- $(ARCHIVER) d $(@(lib)lib) $(objs)\n");
   fprintf(fp, "\t $(RANLIB) $(@(lib)lib)\n");
   fprintf(fp, "\t- rm -f ATL_%c*.[S,c]\n", pre);

/*
 * Print out the individual rules for each needed copy function
 */
   dcomp[2] = dflags[2] = toupper(pre);
   dflags[3] = dcomp[3] = 'K';
   fprintf(fp, "\ntsth.o : tsth.c\n");
   fprintf(fp, "\t%s %s $(CDEFS) %s -c tsth.c\n\n", dcomp, dflags, styp);
   fprintf(fp, "#\n# Data copy rules\n#\n");
/*
 * Print out 2-D ablk2Cmat, cmat2ablk and ammswp targets
 */
   for (up=mnurb; up; up = up->next)
   {
      const int mu=up->mu, nu = up->nu;
      char cbe[4] = {'0', '1', 'n', 'X'};
      int ibe[4] =  {0,    1,  -1,  2};
      int i, j;

      for (i=0; i < 4; i++)
      {
         int h;
         for (h=0; h < 2; h++)
         {
            char pre=pres[h];
            char *styp=styps[h];
            for (j=0; j < 3; j++)
            {
               int k;
               char *rtn[2] = {"ablk2cmat", "cmat2ablk"};
               for (k=0; k < 2; k++)
               {
                  char rn[64];
                  sprintf(rn, "ATL_%c%s_%dx%d_a%c_b%c",
                          pre, rtn[k], mu, nu, al[j], cbe[i]);
                  fprintf(fp, "%s.o : %s.c\n", rn, rn);
                  fprintf(fp, "\t%s %s $(CDEFS) %s -c %s.c\n", 
                          dcomp, dflags, styp, rn);
               }
            }
         }
      }
   }
   KillUnrollList(mnurb);
/*
 * Print out 1-D copy-in routine rules
 */
   for (up=allub; up; up = up->next)
   {
      const int u = up->mu, kmaj=up->kmaj;
      int j;
      for (j=0; j < 3; j++)
      {
         int h;
         for (h=0; h < 2; h++)
         {
            char pre=pres[h];
            char *styp=styps[h];
            char *cst[2] = {"", "C"};
            char *cdef[2] = {"", "-DConj_=1 "};
            int g;
            const int G = (pre == 'c' || pre == 'z') ? 2:1;
            for (g=0; g < G; g++)
            {
               int kk;
               const int nmI = 5;
               char rout[32];
               if (kmaj > 1)
                  sprintf(rout, "ATL_%crm2am_a%c_%dx%d", pre, al[j], kmaj, u);
               else
                  sprintf(rout, "ATL_%crm2am_a%c_%d", pre, al[j], u);
               for (kk=0; kk < 2; kk++)
               {
                  if (kk == 1)
                     rout[5] = 'c';
                  fprintf(fp, "%s%s.o : %s.c\n", rout, cst[g], rout);
                  fprintf(fp, "\t%s %s $(CDEFS) %s%s -o %s%s.o -c %s.c\n", 
                          dcomp, dflags, cdef[g], styp, rout, cst[g], rout);
               }
            }
         }
      }
   }
   KillUnrollList(allub);
/*
 * Print out the individual rules for each kernel compile
 */
   dflags[3] = dcomp[3] = 'M';
   fprintf(fp, "#\n#  AMM kernel rules\n#\n");
   for (mmp=mmb; mmp; mmp = mmp->next)
   {
/*
 *    Kernels that take runtime K are only compiled once, so print rules on
 *    only the first encounter of that ID
 */
      if (FLAG_IS_SET(mmp->flag, MMF_KRUNTIME))
      {
         const int id = mmp->ID;
         for (p=mmb; p != mmp; p = p->next)
            if (MMKernsSame(mmp, p))
               break;
         if (p != mmp)
            continue;
      }
      comp = GetKernComp(mmp, dcomp, dflags, &cflags);
/* 
 *    ATL_<pre>AMMM_<ID>_<kb>_<flg>_<mu>x<nu>x<ku>_b<X>, 
 *    kerns in all 3 beta cases
 */
      for (i=0; i < 3; i++)
         PrintKernComp(fp, pre, mmp, @(uid), "AMMM", comp, cflags, styp, 
                       be[i], bes[i]);
   }
/*
 * runtime-KB rank-K needs only one kernel compile rule
 */
   if (runb)
      fprintf(fp, "#\n#  rank-K kernels with run-time K\n#\n");
   for (mmp=runb; mmp; mmp = mmp->next)
   {
      comp = GetKernComp(mmp, dcomp, dflags, &cflags);
      for (i=0; i < 3; i++)
         PrintKernComp(fp, pre, mmp, @(uid), "AMRK", comp, cflags, styp, 
                       be[i], bes[i]);
   }
   
/*
 * Compile-time rank-K must be recompiled for each kbB
 */
   if (fixb)
      fprintf(fp, "#\n#  rank-K kernels with compile-time KB\n#\n");
   for (mmp=fixb; mmp; mmp = mmp->next)
   {
      const int kmaj = mmp->kmaj;
      comp = GetKernComp(mmp, dcomp, dflags, &cflags);
      for (i=0; i < 3; i++)
      {
         int kbG = mmp->kbB;
         if (kmaj)
            kbG = ((mmp->kbB + kmaj-1)/kmaj)*kmaj;
         fprintf(fp, "ATL_%cAMRK_%d_%d_%x_%dx%dx%d_b%c.o : %s\n", pre, mmp->ID, 
                 mmp->kbB, GetCompTimeFlags(mmp), mmp->mu, mmp->nu, mmp->ku,
                 be[i], mmp->rout);
         fprintf(fp, "\t%s $(CDEFS2) %s -DBETA%s=1", comp, styp, bes[i]);
         fprintf(fp, " -DKB=%d -DATL_USERMM=ATL_%cAMRK_%d_%d_%x_%dx%dx%d_b%c", 
                 kbG, pre, mmp->ID, mmp->kbB, GetCompTimeFlags(mmp), mmp->mu,
                 mmp->nu, mmp->ku, be[i]);
         fprintf(fp, " -DATL_MOVEA -DATL_MOVEC");
         fprintf(fp, " %s -o ATL_%cAMRK_%d_%d_%x_%dx%dx%d_b%c.o -c %s\n", 
                 cflags, pre, mmp->ID, mmp->kbB, GetCompTimeFlags(mmp), 
                 mmp->mu, mmp->nu, mmp->ku, be[i], mmp->rout);
      }
   }
   KillAllMMNodes(fixb);
   KillAllMMNodes(runb);
   KillAllMMNodes(mmb);
   fclose(fp);
}

void GenKerns(char pre, char *outd, ATL_mmnode_t *geb, ATL_mmnode_t *gek1b, 
              ATL_mmnode_t *sqb, ATL_mmnode_t *sqk1b, ATL_mmnode_t *rkb)
/*
 * Creates/copies all required matmul kernels into outd using specified names
 */
{
   ATL_mmnode_t *mmb, *mmp, *p;
   mnur_t *mnurb=NULL, *allub, *up;
   char *ln=NULL;
   int lnlen=0, dlen;
   char al[3] = {'1', 'n', 'X'};
   int ial[3] = {1,   -1,   2};
   char pres[2];
   pres[0] = pre;
   pres[1] = (pre == 's') ? 'c' : 'z';
/*
 * All non-rkK kerns are generated the same way, so combine them all into one
 * gigantic queue.  We then eliminate all the guys who aren't different
 * once we have compiled them, which still leaves duplicates that differ
 * only in their compilation options.  We'll go ahead and just generate
 * them multiple times (overwriting the file with the same file), so that
 * we don't have to write & support a stricter RemoveNonUnique
 */
   mmb = CloneMMQueue(geb);
   ATL_LastMMNode(mmb)->next = CloneMMQueue(sqb);
   ATL_LastMMNode(mmb)->next = CloneMMQueue(gek1b);
   ATL_LastMMNode(mmb)->next = CloneMMQueue(sqk1b);
   ATL_LastMMNode(mmb)->next = CloneMMQueue(rkb);
   mmb = RemoveNonUniqueKernels(mmb);
/*
 * Build list of all unique MU/NU combos for copy routines
 */
   mnurb = GetUniqueMNUnrolls(mmb, NULL);
   allub = GetUniqueMUnrolls(mmb, NULL);
   allub = GetUniqueNUnrolls(mmb, allub);
   dlen = strlen(outd);
/*
 * Extract every unique block-copy routine
 */
   for (up=mnurb; up; up = up->next)
   {
      const int mu=up->mu, nu=up->nu;
      char cbe[4] = {'0', '1', 'n', 'X'};
      int ibe[4] =  {0,    1,  -1,  2};
      int i, j;
      j = 64+8 + strlen(outd);
      j = (j > 128) ? j : 128;
      if (lnlen < j)
      {
         free(ln);
         lnlen = j;
         ln = malloc(j*sizeof(char));
         assert(ln);
      }
      for (i=0; i < 4; i++)
      {
         for (j=0; j < 3; j++)
         {
            char rn[64];
            int ierr;
            int k;
            for (k=0; k < 2; k++)
            {
               int h;
               for (h=0; h < 2; h++)
               {
                  char pre = pres[h];
                  if (!k)
                     sprintf(rn, "ATL_%cablk2cmat_%dx%d_a%c_b%c.c",
                             pre, mu, nu, al[j], cbe[i]);
                  else
                     sprintf(rn, "ATL_%ccmat2ablk_%dx%d_a%c_b%c.c",
                             pre, mu, nu, al[j], cbe[i]);
                  sprintf(ln, 
                     "make %s pre=%c mu=%d nu=%d al=%c be=%c alpha=%d beta=%d", 
                          rn, pre, mu, nu, al[j], cbe[i], ial[j], ibe[i]);
                  ierr = system(ln);
                  if (ierr)
                  {
                     fprintf(stderr, "FAILED CMND='%s'\n", ln);
                     exit(ierr);
                  }
                  sprintf(ln, "mv %s %s/.", rn, outd);
                  ierr = system(ln);
                  if (ierr)
                  {
                     fprintf(stderr, "FAILED CMND='%s'\n", ln);
                     exit(ierr);
                  }
               }
            }
         }
      }
   }
   KillUnrollList(mnurb);

/*
 * Routines to copy back and forth from A and B
 */
   for (up=allub; up; up = up->next)
   {
      const int u = up->mu, kmaj=up->kmaj;
      int j;
      j = 16 * 40 + (strlen(outd)<<1);
      j = (j > 90) ? j : 90;
      if (lnlen < j)
      {
         free(ln);
         lnlen = j;
         ln = malloc(j*sizeof(char));
         assert(ln);
      }
      for (j=0; j < 3; j++)
      {
         int h;
         for (h=0; h < 2; h++)
         {
            int ierr;
            char pre = pres[h];
            sprintf(ln, "make ATL_%crm2am_a%c_%d.c ATL_%ccm2am_a%c_%d.c "
                    "pre=%c UR=%d alpha=%d al=%c kmaj=%d",
                    pre, al[j], u, pre, al[j], u, pre, u, ial[j], al[j], kmaj);
            ierr = system(ln);
            if (ierr)
            {
               fprintf(stderr, "FAILED CMND='%s'\n", ln);
               exit(ierr);
            }
   @whiledef rt cm2am rm2am
            if (kmaj > 1)
               sprintf(ln, 
                       "mv ATL_%c@(rt)_a%c_%d.c %s/ATL_%c@(rt)_a%c_%dx%d.c",
                       pre, al[j], u, outd, pre, al[j], kmaj, u);
            else
               sprintf(ln, 
                       "mv ATL_%c@(rt)_a%c_%d.c %s/ATL_%c@(rt)_a%c_%d.c",
                       pre, al[j], u, outd, pre, al[j], u);
            ierr = system(ln);
            if (ierr)
            {
               fprintf(stderr, "FAILED CMND='%s'\n", ln);
               exit(ierr);
            }
   @endwhile
         }
      }
   }
   KillUnrollList(allub);
/*
 * Copy/generate every unique file, but only once
 */
   for (mmp=mmb; mmp; mmp = mmp->next)
   {
      const int id=mmp->ID;
/*
 *    For generated files, just overwrite dups with same file, won't hurt
 */
      if (id == 0)
      {
         assert(mmp->genstr);
         assert(!system(mmp->genstr));
      }
      else  /* user-supplied files copied from AMMCASES directory */
      {
/*
 *       If this is the first time we've seen this ID, it must be copied
 */
         for (p=mmb; p != mmp && p->ID != id; p = p->next);
         if (p == mmp)
         {
            int i, ierr;
            i = strlen(mmp->rout) + dlen + 16;
            if (i > lnlen)
            {
               if (ln)
                  free(ln);
               ln = malloc(i*sizeof(char));
               assert(ln);
               lnlen = i;
            }
            sprintf(ln, "cp AMMCASES/%s %s/.", mmp->rout, outd);
            ierr = system(ln);
            if (ierr)
            {
               fprintf(stderr, "FAILED CMND='%s'\n", ln);
               exit(ierr);
            }
         }
      }
   }
/*
 * Copy/generate rank-K kerns
 */
   for (mmp=rkb; mmp; mmp = mmp->next)
   {
      const int id=mmp->ID;
/*
 *    For generated files, just generate it using genstr
 */
      if (id == 0)
      {
         assert(mmp->genstr);
         assert(!system(mmp->genstr));
      }
      else  /* user-supplied files copied from AMMCASES directory */
      {
         int i, ierr;
         i = strlen(mmp->rout) + dlen + 16;
         if (i > lnlen)
         {
            if (ln)
               free(ln);
            ln = malloc(i*sizeof(char));
            assert(ln);
            lnlen = i;
         }
         sprintf(ln, "cp AMMCASES/%s %s/.", mmp->rout, outd);
         ierr = system(ln);
         if (ierr)
         {
            fprintf(stderr, "FAILED CMND='%s'\n", ln);
            exit(ierr);
         }
      }
   }
   KillAllMMNodes(mmb);
   if (ln)
      free(ln);
}

int KernelInList(ATL_mmnode_t *mmb, ATL_mmnode_t *p)
/*
 * RETURNS: 1 if p is duplicated in mmb, else 0
 */
{
   ATL_mmnode_t *mp;
   if (!p || !mmb)
      return(0);
   for (mp=mmb; mp; mp = mp->next)
      if (MMKernsSame1(mp, p))
         return(1);
    return(0);
}

ATL_mmnode_t *StripNonUniqueKs(ATL_mmnode_t *ukb, ATL_mmnode_t *mmb) 
/*
 * Deletes any ukb node that also appears in mmb,
 * RETURNS: possibly shortened ukb
 */
{
   ATL_mmnode_t *mp, *prev;
/*
 * Delete any repetitive nodes starting unique queue
 */
   while(ukb && KernelInList(mmb, ukb))
      ukb = KillMMNode(ukb);
   if (!ukb)
      return(ukb);
/*
 * Now, delete any internal non-unique K-cleanup
 */
   prev = ukb;
   mp = ukb->next;
   while (mp)
   {
      if (KernelInList(mmb, mp))
         mp = prev->next = KillMMNode(mp);
      else
      {
         prev = mp;
         mp = mp->next;
      }
   }
   return(ukb);
}
ATL_mmnode_t *StripExactMatchKs(ATL_mmnode_t *ukb, ATL_mmnode_t *mmb) 
/*
 * Deletes any ukb node that also appears in mmb with same K-value,
 * RETURNS: possibly shortened ukb
 */
{
   ATL_mmnode_t *mp, *prev;
/*
 * Delete any repetitive nodes starting unique queue
 */
   while(ukb && ExactKernelInList(mmb, ukb))
      ukb = KillMMNode(ukb);
   if (!ukb)
      return(ukb);
/*
 * Now, delete any internal non-unique K-cleanup
 */
   prev = ukb;
   mp = ukb->next;
   while (mp)
   {
      if (ExactKernelInList(mmb, mp))
         mp = prev->next = KillMMNode(mp);
      else
      {
         prev = mp;
         mp = mp->next;
      }
   }
   return(ukb);
}
/*
 * RETURNS: mmb, with all repeated kernels removed
 */
ATL_mmnode_t *RemoveNonUniqueKernels(ATL_mmnode_t *mmb)
{
   ATL_mmnode_t *mp;
   if (!mmb || !mmb->next)
      return(mmb);
   for (mp=mmb; mp; mp = mp->next)
   {
      ATL_mmnode_t *p=mp->next, *prev=mp;
      while (p)
      {
@skip    if (MMKernsSame(mp, p) && (FLAG_IS_SET(p->flag, MMF_KRUNTIME) ||
@skip        p->kbB == mp->kbB))
         if (MMKernsSame1(mp, p))
            prev->next = p = KillMMNode(p);
         else
         {
            prev = p;
            p = p->next;
         }
      }
   }
   return(mmb);
}

void GenAllFiles(char pre, char *outd, ATL_mmnode_t *geb, ATL_mmnode_t *gek1b, 
                 ATL_mmnode_t *sqb, ATL_mmnode_t *sqk1b, ATL_mmnode_t *rkb,
                 ATL_mmnode_t *trsmb, ATL_mmnode_t *cgeb, ATL_mmnode_t *cgek1b,
                 ATL_mmnode_t *csqb, ATL_mmnode_t *csqk1b, ATL_mmnode_t *crkb,
                 ATL_mmnode_t *ctrsmb)
{
   ATL_mmnode_t *uge, *usq, *urk;  /* lists w/o object repeats */
   ATL_mmnode_t *mp;
   const char cpr = (pre == 'd') ? 'z' : 'c';

   if (!ctrsmb)
      ctrsmb = trsmb;
   GenHeaderFiles(pre, outd, geb, gek1b, sqb, sqk1b, rkb, trsmb);
   GenHeaderFiles(cpr, outd, cgeb, cgek1b, csqb, csqk1b, crkb, ctrsmb);
/*
 * Link complex and real together: real/cplx don't matter for generation
 * or compiling
 */
   ATL_LastMMNode(geb)->next = cgeb;
   ATL_LastMMNode(gek1b)->next = cgek1b;
   ATL_LastMMNode(sqb)->next = csqb;
   ATL_LastMMNode(sqk1b)->next = csqk1b;
   mp = AddUniqueMMKernCompList(NULL, rkb);
   KillAllMMNodes(rkb);
   rkb = AddUniqueMMKernCompList(mp, crkb);
   KillAllMMNodes(crkb);

   GenMakefile(pre, outd, geb, gek1b, sqb, sqk1b, rkb);
   GenKerns(pre, outd, geb, gek1b, sqb, sqk1b, rkb);
   KillAllMMNodes(geb);
   KillAllMMNodes(gek1b);
   KillAllMMNodes(sqb);
   KillAllMMNodes(sqk1b);
   KillAllMMNodes(rkb);
   KillAllMMNodes(trsmb);
}

void Cplx2RealMM(char pre, ATL_mmnode_t *mmb, char *outd)
{
   ATL_mmnode_t *mp;
   const int mask = ~(1<<MMF_COMPLEX);
   char pfx[8];
   const char cpr = (pre == 'd') ? 'z' : 'c';
   pfx[0] = 'A'; pfx[1] = 'T'; pfx[2] = 'L'; pfx[3] = '_';
   pfx[4] = cpr; pfx[5] = 0;
   for (mp=mmb; mp; mp = mp->next)
   {
      char *sp;
      mp->flag &= mask;
      if (mp->rout)
      {
         sp = strstr(mp->rout, pfx);
         if (sp)
            sp[4] = pre;
      }
   }
   FillInGenStrings(pre, mmb, outd);
}

int main(int nargs, char **args)
{
   char pre='d';
   int verb=1;
   int *nbs;
   char *outd, *ukin, *kcin, *rkin, *sqin;
   ATL_mmnode_t *geb, *gek1b, *sqb, *sqk1b, *rkb, *trsm;
   ATL_mmnode_t *cgeb, *cgek1b, *csqb, *csqk1b, *crkb, *ctrsm;
/*
 * We expect to get a list of rectangular blocking factor kernels for gemm,
 * K-cleanup kernels for gemm, and square kernels for building amm-based L3BLAS,
 * and their K-cleanup kernels, and finally a list of kernels for rank-K
 */
   pre = GetFlags(nargs, args, &outd, &geb, &gek1b, &sqb, &sqk1b, &rkb, &trsm,
                  &cgeb, &cgek1b, &csqb, &csqk1b, &crkb, &ctrsm);
   assert(geb && gek1b);
   assert(sqb && sqk1b);
   assert(rkb);
/*
 * Complex actually handled by real
 */
   if (pre == 'c')
      pre = 's';
   else if (pre == 'z')
      pre = 'd';
/*
 * Fill in correct generator strings for all lists
 */
   FillInGenStrings(pre, geb, outd);
   FillInGenStrings(pre, gek1b, outd);
   FillInGenStrings(pre, sqb, outd);
   FillInGenStrings(pre, sqk1b, outd);
   FillInGenStrings(pre, rkb, outd);
   Cplx2RealMM(pre, cgeb, outd);
   Cplx2RealMM(pre, cgek1b, outd);
   Cplx2RealMM(pre, csqb, outd);
   Cplx2RealMM(pre, csqk1b, outd);
   Cplx2RealMM(pre, crkb, outd);

   GenAllFiles(pre, outd, geb, gek1b, sqb, sqk1b, rkb, trsm, 
               cgeb, cgek1b, csqb, csqk1b, crkb, ctrsm);

   return(0);
}
@ROUT ammsearch uammsearch
@extract -b @(topd)/cw.inc lang=C -def cwdate 2012 -def cwdate 2013 -def cwdate 2015
#include "atlas_misc.h"
#include "atlas_gnuvec.h"
#define ATL_JKMDEF 1
#include "atlas_mmtesttime.h"

#define NVECS 4
static enum VECTYPE {VTAVXZ=0, VTAVX=1, VTSSE=2, VTGV=3, VTSC=4} VECi=VTSC;
static int VLEN[5] = {8, 4, 2, 2, 1};  /* assume double, fix later if nec */
static char *VECs[5] = {"avxz", "avx", "sse", "gvec", "scalar"};
static int TSIZE=8;
@skip static char *MOVES=NULL;
static int IMVS=3;     /* move ptrs in timing encoded in last 3 bits: CBA */
#define KRUNMUL 1.02   /* KRUNTIME speedup increase over K-compile time */

@extract -b @(basd)/atlas.base rout=Mylcm

double TimeMMKernel_KB
(
   int verb,                    /* 0: no output, 1 min output, 2: full output */
   int FORCETIME,               /* 1: ignore any prior output file */
   ATL_mmnode_t *mmp,           /* ptr to mmkern struct */
   char pre,                    /* type/prec prefix: z,c,d,s */
   int mb, int nb, int kb,      /* dimensions to time */
   int beta,                    /* beta to time */
   int mflop,                   /* >0: force mflop MFLOPs in each time interv */
   int cflush                   /* >=0: size of cache flush, else ignored */
)
/*
 * If kernel has property KRUNTIME, try timing it with compile- and run-time K,
 * and if compile-time is more than 2% faster, turn off KRUNTIME
 */
{
   double mf;
   if (mmp->kbmax && kb > mmp->kbmax)
      return(0.0);
   if (mmp->kbmin && kb < mmp->kbmin)
      return(0.0);
   mf = TimeMMKernel(verb, FORCETIME, mmp, pre, mb, nb, kb, 0, 0, 0, 
                     beta, mflop, cflush);
   if (FLAG_IS_SET(mmp->flag, MMF_KRUNTIME))
   {
      double mfC;
      mmp->flag &= ~(1<<MMF_KRUNTIME);
      mfC = TimeMMKernel(verb, FORCETIME, mmp, pre, mb, nb, kb, kb, kb, mb, 
                         beta, mflop, cflush);
      if (mfC <= 1.02*mf)
         mmp->flag |= (1<<MMF_KRUNTIME);
      else
      {
         if (verb)
            printf("      Forcing K compile-time, mfC=%.2f, mfR=%.2f\n", 
                   mfC, mf);
         mf = mfC;
      }
   }
   return(mf);
}
/*
 * Finds best blocking factors for kernel mmp trying all legal values
 * between [b0, bN]
 */
ATL_mmnode_t *BestBlocking_BFI
(
   int verb, 
   char pre, 
   ATL_mmnode_t *mmp, 
   int b0,
   int bN,
   int minInc,  /* minimum increment to use */
   int FORCE
)
/*
 * Times all legal block factors in all dims between [b0,bN].
 * RETURNS: ptr to best performing kernel, NULL if no legal block factors
 */
{
   ATL_mmnode_t *mp;
   int mbB=0, nbB=0, kbB=0;
   int mbS=0, nbS=0, kbS=0;
   int mu = mmp->mu, nu = mmp->nu, ku = mmp->ku;
   int k0, kn, m0, mn, n0, nn, m, n, k;
   double mfB=0.0, mfS=0.0;

   if (!mmp)
      return(NULL);
   if (minInc > mu)
      mu = ((minInc+mu-1)/mu)*mu;
   if (minInc > nu)
      nu = ((minInc+nu-1)/nu)*nu;
   if (minInc > ku)
      ku = ((minInc+ku-1)/ku)*ku;
   m0 = ((b0+mu-1)/mu)*mu;
   n0 = ((b0+nu-1)/nu)*nu;
   k0 = ((b0+ku-1)/ku)*ku;
   mn = ((bN+mu-1)/mu)*mu;
   nn = ((bN+nu-1)/nu)*nu;
   kn = ((bN+ku-1)/ku)*ku;
   mp = CloneMMNode(mmp);
   if (mp->kbmax && mp->kbmax < kn)
      kn = mp->kbmax;
   if (mp->kbmin && mp->kbmin > k0)
      k0 = mp->kbmin;


   printf("SEARCH BLKING [%d - %d] for %d.%s:\n\n", b0, bN, mp->ID, mp->rout);
   printf("  MB    NB    KB        MFLOP    mbB  nbB  kbB      mflopB\n");
   printf("====  ====  ====  ===========   ==== ==== ==== ===========\n");
   for (m=m0; m <= mn; m += mu)
   {
      for (n=m0; n <= nn; n += nu)
      {
         for (k=k0; k <= kn; k += ku)
         {
            double mf;
            mf = TimeMMKernel(verb, FORCE, mp, pre, m, n, k, k, k, m, 1, 0, -1);
            printf("%4d %5d %5d %11.1f %4d %4d %4d %11.1f\n", 
                   m, n, k, mf, mbB, nbB, kbB, mfB);
            if (mf > mfB)
            {
               mfB = mf;
               mbB = m;
               nbB = n;
               kbB = k;
            }
            if (m == n && m == k)
            {
               if (mf > mfS)
               {
                  mfS = mf;
                  mbS = m;
                  nbS = n;
                  kbS = k;
               }
            }
         }
      }
   }
   if (mfB == 0)
   {
      printf("NO KERNEL POSSIBLE FOR RANGE=[%d,%d]\n", b0, bN);
      KillMMNode(mp);
      return(NULL);
   }
   mp->mbB = mbB;
   mp->nbB = nbB;
   mp->kbB = kbB;
   mp->mflop[0] = mfB;
   printf("FOR %d.'%s': MB=%d, NB=%d, KB=%d, MFLOPS=%.1f\n",
          mp->ID, mp->rout, mbB, nbB, kbB, mfB);
   k = MMKernelFailsTest(pre, mbB, nbB, kbB, 0, mp);
   if (!k)
      k = MMKernelFailsTest(pre, mbB, nbB, kbB, 1, mp);
   if (!k)
      k = MMKernelFailsTest(pre, mbB, nbB, kbB, -1, mp);
   if (k)
   {
      printf("KERNEL FAILS TESTER FOR [M,N,K]B=%d,%d,%d\n", mbB, nbB, kbB);
      exit(k);
   }
   if (mbS == 0)
      mp->next = NULL;
   else
   {
      k = MMKernelFailsTest(pre, mbS, nbS, kbS, 0, mp);
      if (!k)
         k = MMKernelFailsTest(pre, mbS, nbS, kbS, 1, mp);
      if (!k)
         k = MMKernelFailsTest(pre, mbS, nbS, kbS, -1, mp);
      if (k)
         mp->next = NULL;
      else
      {
         mp->next = CloneMMNode(mp);
         mp->next->mbB = mbS;
         mp->next->nbB = nbS;
         mp->next->kbB = kbS;
         mp->next->mflop[0] = mfS;
      }
   }
   WriteMMFileWithPath(pre, "res", "AMMEXBLKS.sum", mp);
   return(mp);
}

ATL_mmnode_t *TimeExtraBlockings(char pre, int verb)
{
   ATL_mmnode_t *eb;
   eb = ReadMMFileWithPath(pre, "res", "AMMEXBLKS.sum");
   if (!eb)
      return(eb);
   if (eb->mflop[0] < 0)
   {
      ATL_mmnode_t *mp;
      printf("EXTRA BLOCKING FACTOR TIMINGS:\n\n");
      if (verb)
      {
         printf("  MB    NB    KB        MFLOP\n");
         printf("====  ====  ====  ===========\n");
      }
      for (mp=eb; mp; mp = mp->next)
      {
         mp->mflop[0] = TimeMMKernel(verb, 0, mp, pre, mp->mbB, mp->nbB,
                                     mp->kbB, 0, 0, mp->mbB, 1, 0, -1);
         if (verb)
            printf("%4d %5d %5d %11.1f\n", 
                   mp->mbB, mp->nbB, mp->kbB, mp->mflop[0]);
      }
      WriteMMFileWithPath(pre, "res", "AMMEXBLKS.sum", eb);
   }
   return(eb);
}

ATL_mmnode_t *BestForThisNB
(
   int verb, 
   char pre, 
   ATL_mmnode_t *mmb, 
   int nb, 
   int pnb,  /* previous nb */
   int nnb,  /* next nb */
   int FORCE
)
/*
 * Times all kernels in mmb
 * RETURNS: ptr to best performing kernel, empty gen node if no user case wrks
 */
{
   ATL_mmnode_t *mmp, *mmB=NULL;
   double mf, mf0, mfB=0.0;

   printf("SCOPING FOR BEST PERFORMING KERNEL FOR NB=%d\n", nb);
   for (mmp=mmb; mmp; mmp = mmp->next)
   {
      int kb;
/*
 *    Choose kb, if forced only kb will do, so skip if kernel can't do it
 */
      if (FORCE || nb <= 16)
         kb = nb;
/*
 *    If this kernel can't do the exact block factor, allow leeway
 */
      else
      {
         int u;
         u = Mylcm(mmp->mu, mmp->nu);
         u = Mylcm(u, mmp->ku);
         kb = (nb/u)*u;
         if (kb != nb)
         {
            int kbB;
            kbB = ((nb+u-1)/u)*u;
            if (!kb || kbB-nb < nb-kb && kbB <= 4)
               kb = kbB;
         }
      }
      if ((mmp->kbmin && kb < mmp->kbmin) ||
          (mmp->kbmax && kb > mmp->kbmax) ||
          ((kb/mmp->mu)*mmp->mu != kb) || ((kb/mmp->nu)*mmp->nu != kb) ||
          ((kb/mmp->ku)*mmp->ku != kb) || (kb == pnb) || (kb == nnb))
      {
         
         printf("   %d. %s: SKIPPED, bad NB\n", mmp->ID, mmp->rout);
         continue;
      }
      mf0 = TimeMMKernel(verb, 0, mmp, pre, kb, kb, kb, kb, kb, kb, 1, 0, -1);
/*
 *    Give bonus to K-runtime variable over K-compile time; K-runtime kernels
 *    can be used for some K-cleanup, and they can be used for any required KB
 *    as well as being typically much smaller instruction load, so they are
 *    strongly preferred
 */
      mf = FLAG_IS_SET(mmp->flag, MMF_KRUNTIME) ? mf0*KRUNMUL : mf0;
      if (mf > mfB)
      {
         mfB = mf;
         mmB = mmp;
         mmB->mbB = mmB->nbB = mmB->kbB = kb;
      }
      printf("   %d. %s: kb=%d, MFLOP=%.2f\n", mmp->ID, mmp->rout, kb, mf0);
   }
   if (!mmB)
   {
      printf("NO KERNEL POSSIBLE FOR NB=%d\n", nb);
      mmB = GetMMNode();
      mmB->mbB = mmB->nbB = mmB->kbB = nb;
   }
   else
   {
      int i, kb = mmB->kbB;
      i = MMKernelFailsTest(pre, kb, kb, kb, 0, mmB);
      if (!i)
         i = MMKernelFailsTest(pre, kb, kb, kb, 1, mmB);
      if (!i)
         i = MMKernelFailsTest(pre, kb, kb, kb, -1, mmB);
      if (i)
      {
         printf("BEST KERNEL FAILS TESTER FOR NB=%d\n", kb);
         exit(i);
      }
      if (FLAG_IS_SET(mmB->flag, MMF_KRUNTIME))
         mfB /= KRUNMUL;
      printf("BEST KERNEL FOUND FOR NB=%d: ID#%d '%s' %.2f MFLOPS\n\n", 
             nb, mmB->ID, mmB->rout, mfB);
      mmB = CloneMMNode(mmB);
      mmB->mflop[0] = mfB;
      mmB->next = NULL;
   }
   return(mmB);
}

int DeleteBadBigNBs(ATL_mmnode_t *mmb, int *nbs)
{
   ATL_mmnode_t *best=NULL, *mmp;
   double mfB=0.0;
   int n=0;
/*
 * Find the best-performing kernel
 */
   for (mmp=mmb; mmp; mmp = mmp->next)
   {
      double mf;
      mf = mmp->mflop[0];
      if (mf > mfB)
      {
         mfB = mf;
         best = mmp;
      }
   }
/*
 * Delete all NBs larger than best
 */
   while (best->next)
   {
      best->next = KillMMNode(best->next);
      n++;
   }
   if (n)
   {
      int N = *nbs;
      N = (N >= 0) ? N : -N;
      printf("Deleted %d large, slow kernels starting at NB=%d\n", 
             n, nbs[N-n+1]);
   }
   return(n);
}

ATL_mmnode_t *FindBestForEachNB(int verb, char pre, ATL_mmnode_t *mmb, int *nbs)
{
   int i, n, FORCE=0;
   ATL_mmnode_t *best, *bp;
/*
 * If # of nbs is negative, then each nb is required and that exact size
 * will be used, or no NB of that size if no kernel works.  The normal behavior
 * is the exact size of forced for all nb <= 16, and inexact for larger
 */
   n = nbs[0];
   if (n < 0)  /* negative # of nbs says force exact NB or nothing */
   {
      n = -n;
      FORCE = 1;
   }
   bp = best = BestForThisNB(verb, pre, mmb, nbs[1], 0, (n == 1)?nbs[1]:0,
                             FORCE);
   for (i=2; i <= n; i++)
   {
      int pnb = nbs[i-1], nnb = (i < n) ? nbs[i+1]:0;
      bp->next = BestForThisNB(verb, pre, mmb, nbs[i], pnb, nnb, FORCE);
      bp = bp->next;
   }
   if (!FORCE)
      i = DeleteBadBigNBs(best, nbs);
   return(best);
}

@ROUT ammsearch
void PrintUsage(char *name, int ierr, char *flag)
{
   if (ierr > 0)
      fprintf(stderr, "Bad argument #%d: '%s'\n", ierr, 
              flag?flag:"OUT-OF_ARGUMENTS");
   else if (ierr < 0)
      fprintf(stderr, "ERROR: %s\n", flag);
   fprintf(stderr, "USAGE: %s [flags:\n", name);
   fprintf(stderr, "   -p [s,d,c,z]: set type/precision prefix (d) \n");
@skip    fprintf(stderr, "   -o <outfile>: output file (res/<pre>uAMMRES.sum)\n");
   fprintf(stderr, "   -n # nb1 ... nb# : NBs to try for\n");
   fprintf(stderr, "   -N # nb1 ... nb# : force exact NBs in search\n");
   fprintf(stderr, "   -r <nreg> : set max # of registers to try\n");
   fprintf(stderr, "   -b <nb>   : set initial block factor to try\n");
   fprintf(stderr, 
      "   -B <b0> <bN> <idx> <rfn>: brute-force blocking search:\n");
   fprintf(stderr, "       b0: smallest value to try for all dims\n");
   fprintf(stderr, "       b1: largest value to try for all dims\n");
   fprintf(stderr, "      idx: index in rfn to use; -1 means last\n");
   fprintf(stderr, "      rfn: search result file name to read kern from\n");
   fprintf(stderr, "   -v <verb> : set verbosity (1)\n");
   exit(ierr ? ierr : -1);
}

int *GetFlags(int nargs, char **args, char *PRE, 
              int *verb, int *NREG, int *NB, int *CS)
{
   ATL_mmnode_t *mmb=NULL;
   int B0, BN;
   int i, j=0, n, k;
   char pre='d';
   int *nbs=NULL;
   *NREG = *NB = 0;
   *verb = 1;
   *CS = 0;
   for (i=1; i < nargs; i++)
   {
      if (args[i][0] != '-')
         PrintUsage(args[0], i, args[i]);
      
      switch(args[i][1])
      {
      case 'B':  /* <b0> <bN> <idx> <rfn> */
         if (i+4 >= nargs)
            PrintUsage(args[0], i-1, NULL);
         else
         {
            int I, k;
            ATL_mmnode_t *mp;

            B0 = atoi(args[i+1]);
            BN = atoi(args[i+2]);
            I = atoi(args[i+3]);
            mmb = ReadMMFile(args[i+4]);
            assert(mmb);
            if (I < 0)
               for (mp=mmb; mp->next; mp = mp->next);
            else
               for (k=0, mp=mmb; k < I && mp; k++, mp = mp->next);
            assert(mp);
            mp = CloneMMNode(mp);
            KillAllMMNodes(mmb);
            mmb = mp;
         }
         i += 4;
         break;
      case 'p':
        if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
        pre = tolower(args[i][0]);
        assert(pre == 's' || pre == 'd' || pre == 'z' || pre == 'c');
        break;
@beginskip
      case 'o':
        if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
        *FNOUT = DupString(args[i]);
        break;
@endskip
      case 'n':
         j = 1;
      case 'N':
        if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
         n = atoi(args[i]);
         nbs = malloc((n+1)*sizeof(int));
         assert(nbs);
         nbs[0] = (j) ? n : -n;
         for (k=1; k <= n; k++)
         {
           if (++i >= nargs)
               PrintUsage(args[0], i-1, NULL);
            nbs[k] = atoi(args[i]);
         }
         break;
      case 'r':
        if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
         *NREG = atoi(args[i]);
         break;
      case 'v':
        if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
         *verb = atoi(args[i]);
         break;
      case 'b':
        if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
         *NB = atoi(args[i]);
         break;
   fprintf(stderr, "   -b <nb>   : set initial block factor to try\n");
      default:
         PrintUsage(args[0], i, args[i]);
      }
   }
   *PRE = pre;
   if (pre == 's' || pre == 'c')
   {
      VLEN[VTAVXZ] = 16;
      VLEN[VTAVX] = 8;
      VLEN[VTSSE] = 4;
      VLEN[VTGV] = 4;
      TSIZE = 4;
   }
   #ifdef ATL_AVXZ
      if (*NREG == 0)
         *NREG = ATL_NVREG;
      VECi = VTAVXZ;
      VECi = VTSC;  /* turn off due to errors */
   #elif defined(ATL_AVX)
      if (*NREG == 0)
         *NREG = ATL_NVREG;
      VECi = VTAVX;
   #elif defined(ATL_SSE1)
      if (*NREG == 0)
         *NREG = ATL_NVREG;
      if (pre == 's')
         VECi = VTSSE;
      #ifdef ATL_SSE2
      else
         VECi = VTSSE;
      #endif
   #elif (defined(ATL_AltiVec) && !defined(ATL_VSX)) || \
         (defined(ATL_NEON) && defined(ATL_NONIEEE) && ATL_NONIEEE != 0) || \
         (defined(ATL_3DNow) && defined(ATL_NONIEEE) && ATL_NONIEEE != 0)
      if (*NREG == 0)
         *NREG = ATL_NVREG;
      if (pre == 's')
         VECi = VTGV;
   #elif defined(ATL_VSX)
      if (*NREG == 0)
         *NREG = ATL_NVREG;
      VECi = VTGV;
   #endif
      if (*NREG == 0)
      #ifdef ATL_GAS_x8664
         *NREG = 16;
      #elif defined(ATL_GAS_x8632)
         *NREG = 8;
      #elif defined(ATL_ARCH_IA64Itan) || defined(ATL_ARCH_IA64Itan)
         *NREG = 128;
      #else
         *NREG = 32;
      #endif
   if (!nbs)
   {
      nbs = malloc(24*sizeof(int));
      assert(nbs);
@beginskip
      nbs[0] = 11;
      nbs[1] = 4; nbs[2] = 6; nbs[3] = 8; nbs[4] = 10;
      nbs[5] = 12; nbs[6] = 14; nbs[7] = 16; nbs[8] = 18;
      nbs[9] = 24; nbs[10] = 32; nbs[11] = 64;
@endskip
      nbs[0] = 19; nbs[1] = 4; nbs[2] = 6; nbs[3] = 8; 
      nbs[4] = 12; nbs[5] = 16; nbs[6] = 18; nbs[7] = 24;
      nbs[8] = 32; nbs[9] = 36; nbs[10] = 48; nbs[11] = 56; 
      nbs[12] = 60; nbs[13] = 64; nbs[14] = 72; nbs[15] = 80; nbs[16] = 84;
      nbs[17] = 96; nbs[18] = 120; nbs[19] = 144; nbs[20] = 180; 
      nbs[21] = 228; nbs[22] = 240; nbs[23] = 480;
   }
   if (*CS == 0)
      *CS = GetL1CacheElts(pre);
   if (mmb)
   {
      ATL_mmnode_t *mp;
      mp = BestBlocking_BFI(1, pre, mmb, B0, BN, 4, 0);
      KillMMNode(mmb);
      KillMMNode(mp);
      exit(0);
   }
   return(nbs);
}
@ROUT ammsearch uammsearch
static INLINE void ApplyMoves2Flag
(
   ATL_mmnode_t *mmp,  /* kernel to set MMF_MV[A,B,C] flag bits */
   int mvBits          /* last 3 bits: MOVE_[CBA] */
)
{
   int flag = mmp->flag & (~MMF_MVSET);         /* zero existing move bits */
   mmp->flag = flag | ((mvBits & 7)<<MMF_MVA); /* put new move bits in */
}
static void ApplyMoves2Flags
(
   ATL_mmnode_t *mmb,  /* kernel to set MMF_MV[A,B,C] flag bits */
   int mvBits          /* last 3 bits: MOVE_[CBA] */
)
{
   const unsigned int mvMSK = ~MMF_MVSET, mvSET = (mvBits&7)<<MMF_MVA;
   ATL_mmnode_t *mmp;
   for (mmp=mmb; mmp; mmp = mmp->next)
      mmp->flag = ((mmp->flag) & mvMSK) | mvSET;
}

char *GenString(char pre, int lat, int nb, int mu, int nu, int ku, 
                int kmaj, char *rt)
{
   char *frm=
      "make gen_amm_%s lat=%d mu=%d nu=%d ku=%d kb=%d vlen=%d rt=%s kmaj=%d"; 
   char *ln;
   int l;

   if (pre == 'z')
      pre = 'd';
   else if (pre == 'c')
      pre = 's';

   l = strlen(frm) + Mmax(6,strlen(VECs[VECi])) + strlen(rt) + 8;
   ln = malloc(l*sizeof(char));
   assert(ln);
   if (kmaj > 1 || mu > VLEN[VECi])
      sprintf(ln, frm, "scalar", lat, mu, nu, ku, nb, 1, rt, kmaj);
#if 1
   else
      sprintf(ln, frm, VECs[VECi], lat, mu*VLEN[VECi], nu, ku, nb, 
              VLEN[VECi], rt, 0);
/*
 * Don't know why gnuvec split out this way, but it doesn't seem to work!
 * Going to try handling it same way as other vec methods, but this is untested.
 */
#else
   else if (VECi != VTGV)
      sprintf(ln, frm, VECs[VECi], lat, mu*VLEN[VECi], nu, ku, nb, 
              VLEN[VECi], rt, 0);
   else
   {
      int sz = (pre == 's') ? 4 : 8;
      sprintf(ln, frm, VECs[VECi], lat, mu, nu, ku, nb, VLEN[VECi]*sz, rt, 0);
   }
#endif
   return(ln);
}

void FillInGenStrings(char pre, ATL_mmnode_t *mmb)
{
   ATL_mmnode_t *mp;

   if (pre == 'z')
      pre = 'd';
   else if (pre == 'c')
      pre = 's';

   for (mp=mmb; mp; mp = mp->next)
   {
      if (mp->ID == 0 && !mp->genstr)
      {
         const int vlen=mp->vlen, mu = (vlen) ? mp->mu/vlen : mp->mu, vl0=VECi;
         if (!vlen || vlen == 1)
            VECi = VTSC;
         else if (vlen != VLEN[VECi])
         {
            if (pre == 's' || pre == 'c')
            {
               if (vlen == 16)
                  VECi = VTAVXZ;
               else if (vlen == 8)
                  VECi = VTAVX;
               else if (vlen == 4 && VECi == VTAVX)
                  VECi = VTSSE;
               else if (vlen == 4)
                  VECi = VTGV;
               else 
                  VECi = VTSC;
            }
            else
            {
               if (vlen == 8)
                  VECi = VTAVXZ;
               else if (vlen == 4)
                  VECi = VTAVX;
               else if (vlen == 2 && VECi == VTAVX)
                  VECi = VTSSE;
               else if (vlen == 2)
                  VECi = VTGV;
               else 
                  VECi = VTSC;
            }
         }
         mp->genstr = GenString(pre, mp->lat, mp->kbB, mu, mp->nu, mp->ku, 
                                mp->kmaj, mp->rout);
         VECi = vl0;
      }
   }
}

ATL_mmnode_t *GetNewGenNode(char pre, int nb, int lat, int mu, int nu, int ku,
                            int kmaj)
{
   ATL_mmnode_t *np;
   char *ln;
   const char upr = (pre == 'z' || pre == 'd') ? 'd' : 's';
   if (kmaj < 2)
      kmaj = 0;
   np = GetMMNode();
   np->rout = malloc(sizeof(char)*27);
   np->vlen = VLEN[VECi];
   assert(np->rout);
   sprintf(np->rout, "ATL_%cgamm%dx%d_%dx%d_nb%d.c", upr, kmaj, np->vlen, 
           mu, nu, nb);
   np->nbB = np->mbB = np->kbB = nb;
   if (kmaj)
      np->mu = mu;
   else
      np->mu = mu*VLEN[VECi];
   np->nu = nu;
   np->ku = ku;
   np->muladd = VECi;  /* stores what vector ISA to use */
   np->lat = lat;
   np->kmaj = kmaj;
   np->genstr = GenString(upr, lat, nb, mu, nu, ku, kmaj, np->rout);
   ApplyMoves2Flag(np, IMVS);
@skip   if (MOVES)
@skip      np->moves = DupString(MOVES);
   return(np);
}

ATL_mmnode_t *GetNewKCleanGenNode
(
   char pre, 
   ATL_mmnode_t *kp,  /* kernel we are generating K-cleanup for */
   int mb, 
   int nb, 
   int kb
)
{
   ATL_mmnode_t *p;
   const int mu=kp->mu, nu=kp->nu, kmaj=(kp->kmaj < 2) ? 0 : kp->kmaj;
   int vl=VECi, vmu;
/*
 * Right now, we don't have a generator for K-vectorized kernels, must fix
 * this when we add that
 */
   if (kmaj)
   {
      vmu = mu;
      VECi = VTSC;
   }
   else
   {
      if (mu % VLEN[VECi])
      {
         if (VECi = VTAVX && !(mu%VLEN[VTSSE]))
            VECi = VTSSE;
         else
            VECi = VTSC;
      }
      vmu = mu / VLEN[VECi];
   }
   p = GetNewGenNode(pre, 0, 0, vmu, nu, 1, kmaj);
   p->flag |= (1<<MMF_KRUNTIME);
   VECi = vl;
   p->mbB = mb;
   p->nbB = nb;
   p->kbB = kb;
   return(p);
}

ATL_mmnode_t *FindDefMUNU(int verb, char pre, int nreg, int lat, int nb, int ku,
                          int *MU, int *NU)
{
   ATL_mmnode_t *mmp;
   double mf, mfB=0.0;
   int n, i, j, kb, muB=1, nuB=1;

   mmp = ReadMMFileWithPath(pre, "res", "gAMMMUNU.sum");
   if (mmp)
   {
      FillInGenStrings(pre, mmp);
      nb = mmp->kbB;
      if (mmp->mflop[0] < 0.0)
         mmp->mflop[0] = TimeMMKernel(verb, 1, mmp, pre, nb, nb, nb, 
                                      nb, nb, nb, 1, 0, -1);
      printf("READ IN BEST GENNED MU=%d, NU=%d, MFLOP=%.2f\n\n", 
             mmp->mu, mmp->nu, mmp->mflop[0]);
/*
 *    See if there is a mismatch between vector settings
 */
      if (mmp->vlen != VLEN[VECi])
      {
         printf("\n\n!!! WARNING: TURNING OFF VECTORIZATION DUE TO MISMATCHED VLEN IN 'res/%cAMMMUNU.sum!!!!\n\n", pre);
         VECi = VTSC;
      }
      *MU = mmp->mu / VLEN[VECi];
      assert(*MU);
      *NU = mmp->nu;
@skip      KillMMNode(mmp);
      return (mmp);
   }
   mmp = GetMMNode();
   mmp->ku = ku;
   mmp->muladd = (lat != 0);
   mmp->lat = lat;
   mmp->rout = DupString("ATL_Xamm_munu.c");
   if (pre == 'z')
      mmp->rout[4] = 'd';
   else if (pre == 'c')
      mmp->rout[4] = 's';
   else
      mmp->rout[4] = pre;
   mmp->mbB = mmp->nbB = mmp->kbB = nb;
   mmp->vlen = VLEN[VECi];
/*
 * Try all near-square register blocking cases
 */
   printf("Finding best MUxNU case for nb=%d\n", nb);
   for (n=4; n < nreg; n++)
   {
      int mbu, nbu, mu, nu;
      for (j=1; j*j < n; j++);
      i = n / j;
      if (nb%i || nb%j)
         continue;
      mu = mmp->mu = i * VLEN[VECi];
      nu = mmp->nu = j;
      if (mmp->genstr)
        free(mmp->genstr);
      mbu = (nb >= mu) ? (nb/mu)*mu : mu;
      nbu = (nb >= nu) ? (nb/nu)*nu : nu;
      mmp->genstr = GenString(pre, lat, nb, i, j, ku, mmp->kmaj, mmp->rout);
      mf = TimeMMKernel(verb, 1, mmp, pre, mbu, nbu, nb, nb, nb, nb, 1, 0, -1);
      printf("   MU=%2d, NU=%2d, MFLOP=%.2f\n", i, j, mf);
      if (mf > mfB)
      {
         muB = i;
         nuB = j;
         mfB = mf;
      }
   }
/*
 * For x86, try 1-D cases since older machines are 2-operand assemblies
 */
   #if defined(ATL_GAS_x8664) || defined(ATL_GAS_x8632) 
   if (VECi != VTAVX && VECi != VTAVXZ)  /* AVX is 3-operand */
   {
      printf("BEST NEAR-SQUARE CASE IS MU=%d, NU=%d, MFLOP=%.2f\n\n", 
             muB, nuB, mfB);
      printf("Finding best 1-D outer loop unrolling for nb=%d\n", nb);
      for (n=2; n < nreg; n++)
      {
         int mbu, nbu, mu, nu;
         i = 1; j = n;
         if (nb % n)
            continue;
         mu = mmp->mu = i*VLEN[VECi];
         nu = mmp->nu = j;
         if (mmp->genstr)
           free(mmp->genstr);
         mmp->genstr = GenString(pre, lat, nb, i, j, ku, mmp->kmaj, mmp->rout);
         mbu = (nb >= mu) ? (nb/mu)*mu : mu;
         nbu = (nb >= nu) ? (nb/nu)*nu : nu;
         mf = TimeMMKernel(verb, 1, mmp, pre, mbu, nbu, nb, nb, nb, nb, 
                           1, 0, -1);
         printf("   MU=%2d, NU=%2d, MFLOP=%.2f\n", i, j, mf);
         if (mf > mfB)
         {
            muB = i;
            nuB = j;
            mfB = mf;
         }
         i = n; j = 1;
         mu = mmp->mu = i * VLEN[VECi];
         nu = mmp->nu = j;
         mbu = (nb >= mu) ? (nb/mu)*mu : mu;
         nbu = (nb >= nu) ? (nb/nu)*nu : nu;
         if (mmp->genstr)
           free(mmp->genstr);
         mmp->genstr = GenString(pre, lat, nb, i, j, ku, mmp->kmaj, mmp->rout);
         mf = TimeMMKernel(verb, 1, mmp, pre, mbu, nbu, nb, nb, nb, nb, 
                           1, 0, -1);
         printf("   MU=%2d, NU=%2d, MFLOP=%.2f\n", i, j, mf);
         if (mf > mfB)
         {
            muB = i;
            nuB = j;
            mfB = mf;
         }
      }
   }
   #endif

   i = mmp->kmaj;
   KillMMNode(mmp);
   mmp = GetNewGenNode(pre, nb, lat, muB, nuB, ku, i);
@beginskip
   mmp->mu = muB * VLEN[VECi];
   mmp->nu = nuB;
   mmp->mbB = (nb >= muB) ? (nb/muB)*muB : muB;
   mmp->nbB = (nb >= nuB) ? (nb/nuB)*nuB : nuB;
   mmp->kbB = nb;
   if (mmp->genstr)
     free(mmp->genstr);
   mmp->genstr = GenString(pre, lat, nb, muB, nuB, ku, mmp->kmaj, mmp->rout);
@endskip
   WriteMMFileWithPath(pre, "res", "gAMMMUNU.sum", mmp);
@skip   KillMMNode(mmp);
   printf("BEST CASE IS MU=%d, NU=%d, MFLOP=%.2f (%.2f)\n\n", 
          muB, nuB, mf, mfB);
   *MU = muB;
   *NU = nuB;
   return(mmp);
}

void GetMUNUbyNB(int nb, int nreg, int *MU, int *NU)
{
   int mu=(*MU), nu=(*NU), vmu=mu*VLEN[VECi];

   assert(mu && nu && !(nb%VLEN[VECi]));
   if (!(nb%vmu) && !(nb%nu))
      return;
   if (nu == 1) /* handle MUx1 by decreasing by VLEN */
   {
      int u = vmu, vlen = VLEN[VECi];
      while (u+u+1 <= nreg && nb%u)
         u += vlen;
      if (u+u+1 > nreg)
         u -= vlen;
      while (nb%u)
         u -= vlen;
      assert(u);
      *MU = u / vlen;
      return;
   }
   if (mu == 1 || nu == 1) /* handle 1-D cases by just inc/dec U */
   {
      int u = (mu == 1) ? nu : mu;
      while (u+u+1 <= nreg && nb%u)
         u++;
      if (u+u+1 > nreg)
         u--;
      while (nb%u)
         u--;
      if (mu == 1)
         *NU = u;
      else
         *MU = u;
      return;
   }
   if (nb%vmu)  /* mu can't handle NB */
   {
      int i;
/* 
 *    try increasing mu until we run out of registers
 */
      for (i=mu+1; i*nu+i+nu <= nreg; i++)
         if (!(nb%(i*VLEN[VECi])))
            break;
/*
 *    Try decreasing mu until it divides
 */
      if (nb%(i*VLEN[VECi]) || i*nu+i+nu > nreg)
      {
         for (mu--; mu; mu--)
            if (!(nb%(mu*VLEN[VECi])))
               break;
      }
      else
         mu = i;
   }
   if (nb%nu)  /* nu can't handle NB */
   {
      int i;
/* 
 *    try increasing nu until we run out of registers
 */
      for (i=nu+1; i*mu+i+mu <= nreg; i++)
         if (!(nb%i))
            break;
/*
 *    Try decreasing nu until it divides
 */
      if (nb%i || i*mu+i+mu > nreg)
      {
         for (nu--; nu; nu--)
            if (!(nb%nu))
               break;
      }
      else
         nu = i;
   }
   *MU = mu;
   *NU = nu;
}

int FindNBInArray(int nb, int *nbs)
/*
 * RETURNS: location+1, or 0 if not found
 */
{
   int i, n = (nbs[0] > 0) ? nbs[0] : -nbs[0];
   for (i=1; i <= n; i++)
       if (nbs[i] == nb)
          return(i);
   return(0);
}
ATL_mmnode_t *CreateGenCasesFromNBs
(
   ATL_mmnode_t *mmb,   /* best user-contributed kernels */
   char pre,            /* precision: s/d */
   int *nbs,            /* list of desired NBs */
   int nreg,            /* upper bound on register use */
   int MU, int NU,      /* default M/N unrolling */
   int KU               /* -1 for fully unrolled, else unrolling factor */
)
/*
 * Generate a list of generated kernels, with the union of nb's in nbs
 * and mmb, and return the generated nodes for timing.
 * HERE HERE HERE: this code is crap, needs to merge both lists, not user
 * list twice.
 */
{
   ATL_mmnode_t *mp, *umb=NULL, *ap;
   int i, n = (nbs[0] > 0) ? nbs[0] : -nbs[0], ne=0, *enbs;

/*
 * Create new queue with an entry for all NBs; both lists (mmb & nbs) are
 * sorted in increasing size
 */
   if (!n && !mmb)
      return(NULL);
   n++;
   ap = mmb;  /* add ptr */
   i = 1;     /* ptr to normal block under consideration */
   do
   {
      int nb, mu=MU, nu=NU, ku;
      ATL_mmnode_t *p=NULL;
      if (ap && i < n)  /* must choose amongst blocks */
      {
         nb = ap->kbB;
         nb = Mmin(nb, nbs[i]);
         if (nb == ap->kbB)
            ap = ap->next;
         if (nb == nbs[i])
            i++;
      }
      else if (ap)
      {
         nb = ap->kbB;
         ap = ap->next;
      }
      else
         nb = nbs[i++];
      ku = (KU == -1) ? nb : KU;
   
/*
 *    If NB is not a multiple of VLEN, drop down to shorter ops
 */
      if (nb%VLEN[VECi])
      {
         int vl=VECi;
/*
 *       For AVX, see if dropping to SSE will fix problem
 */
         if (VECi == VTAVX && !(nb%VLEN[VTSSE]))  /* AVX can drop to SSE */
         {
            VECi = VTSSE;
            GetMUNUbyNB(nb, nreg, &mu, &nu);
            p = GetNewGenNode(pre, nb, 0, mu, nu, ku, 0);
         }
         if (!p)
         {
            VECi = VTSC;
            GetMUNUbyNB(nb, nreg, &mu, &nu);
            p = GetNewGenNode(pre, nb, 0, mu, nu, ku, 0);
         }
         VECi = vl;
      }
      else
      {
         GetMUNUbyNB(nb, nreg, &mu, &nu);
         p = GetNewGenNode(pre, nb, 0, mu, nu, ku, 0);
      }
      if (umb)
      {
         mp->next = p;
         mp = p;
      }
      else
         umb = mp = p;
   }
   while (i < n || ap);
   return(umb);
}
void SetGenVec(int verb, char pre)
/*
 * This routine uses a simple timing to be sure if vectorization helps or not
 */
{
   ATL_mmnode_t *mp;
/*
 * If vector operations are being used, make sure they work; compiler and
 * flag changes can mess them up, and in this case we'll fall back to
 * scalar generation.  Try to see if we can successfully test simplist
 * possible vector kernel, and fall back to scalar kernel if we can't
 */
   if (VLEN[VECi] < 2)
      return;
   mp = GetNewGenNode(pre, 32, 0, 1, 1, 1, 0);
   if (MMKernelFailsTest(pre, 32, 32, 32, 1, mp))
   {
      printf("ERROR: VEC='%s' FAILED, genstr='%s'!\n",VECs[VECi],mp->genstr);
      KillMMNode(mp);
/*
 *    For AVX, try falling back to SSE
 */
      if (VECi == VTAVX)
      {
         VECi = VTSSE;
         KillMMNode(mp);
         mp = GetNewGenNode(pre, 32, 0, 1, 1, 1, 0);
         if (MMKernelFailsTest(pre, 32, 32, 32, 1, mp))
            VECi = VTSC;
      }
      else
         VECi = VTSC;
   }
   KillMMNode(mp);
/*
 * For AVX, switch to SSE if AVX doesn't offer a performance advantage
 * (as on AMD Dozer), since SSE smaller code size and requires less cleanup 
 */
   if (VECi == VTAVX)
   {
      double mfA, mfS, mf;
      char *sp; 
      int vl;
      mp = GetNewGenNode(pre, 128, 0, 1, 4, 1, 0);
      mfA = TimeMMKernel(verb, 1, mp, pre, 128, 128, 128, 128, 128, 128,
                         1, 0, -1);
      KillMMNode(mp);
      mp = GetNewGenNode(pre, 128, 0, 2, 2, 1, 0);
      mf = TimeMMKernel(verb, 1, mp, pre, 128, 128, 128, 128, 128, 128,
                        1, 0, -1);
      KillMMNode(mp);
      if (mf > mfA)
         mfA = mf;
      vl = VECi;
      VECi = VTSSE;
      mp = GetNewGenNode(pre, 128, 0, 1, 4, 1, 0);
      mfS = TimeMMKernel(verb, 1, mp, pre, 128, 128, 128, 128, 128, 128,
                         1, 0, -1);
      KillMMNode(mp);
      mp = GetNewGenNode(pre, 128, 0, 2, 2, 1, 0);
      mf = TimeMMKernel(verb, 1, mp, pre, 128, 128, 128, 128, 128, 128,
                        1, 0, -1);
      if (mf > mfA)
         mfA = mf;
      KillMMNode(mp);
      if (mfA < 1.03*mfS)
         printf("USING SSE INSTEAD OF AVX, AVX=%.2f, SSE=%.2f\n", mfA, mfS);
      else
      {
         printf("AVX GOOD, AVX=%.2f, SSE=%.2f\n", mfA, mfS);
         VECi = vl;
      }
   }
/*
 * For any system, don't use vector instructions if they aren't faster than
 * scalar. 
 */
   if (VLEN[VECi] > 1)
   {
      double mfV, mfS;
      char *sp; 
      int vl;
      mp = GetNewGenNode(pre, 128, 0, 1, 4, 1, 0);
      mfV = TimeMMKernel(verb, 1, mp, pre, 128, 128, 128, 128, 128, 128,
                         1, 0, -1);
      KillMMNode(mp);
      vl = VECi;
      VECi = VTSC;
      mp = GetNewGenNode(pre, 128, 0, 1, 4, 1, 0);
      mfS = TimeMMKernel(verb, 1, mp, pre, 128, 128, 128, 128, 128, 128,
                         1, 0, -1);
      KillMMNode(mp);
      if (mfV < 1.05*mfS)
         printf("USING SCALAR INSTEAD OF VECTOR, VEC=%.2f, SCALAR=%.2f\n", 
                mfV, mfS);
      else
      {
         printf("VEC GOOD, VEC=%.2f, SCALAR=%.2f\n", mfV, mfS);
         VECi = vl;
      }
   }
   printf("GENERATING WITH VEC='%s', VLEN=%d\n\n", VECs[VECi], VLEN[VECi]);
}

ATL_mmnode_t *FindBestGenCases(int verb, char pre, int nreg, 
                               int *nbs, ATL_mmnode_t *ummb)
{
   ATL_mmnode_t *mp, *gmmU, *gmmb;
   int MU, NU;

   gmmb = ReadMMFileWithPath(pre, "res", "gAMMRES.sum");
   if (gmmb)
   {
      printf("Reading in generated cases for all NBs:\n");
      FillInGenStrings(pre, gmmb);
      for (mp=gmmb; mp; mp = mp->next)
      {
         const int mu = (mp->vlen) ? mp->mu / mp->vlen : mp->mu;
         int kb = mp->kbB, mb = Mmax(mp->mu,kb), nb=Mmax(mp->nu,kb);
         if (mp->mflop[0] < 0.0)
            mp->mflop[0] = TimeMMKernel(verb, 1, mp, pre, mb, nb, kb,
                                         kb, kb, mb, 1, 0, -1);
         printf("  NB=%d, MU=%d, NU=%d, vlen=%d, MFLOP=%.2f\n", 
                nb, mu, mp->nu, mp->vlen, mp->mflop[0]);
      }
      WriteMMFileWithPath(pre, "res", "gAMMRES.sum", gmmb);
      printf("Done.\n\n");
      return(gmmb);
   }
   SetGenVec(verb, pre);
/*
 * Find the best mu/nu for NB=120; we don't care if we overflow cache for
 * this timing, and 120 = LCM(2,3,4,5,6,8,12).  Use ku=1 so that large
 * problems don't have large K-driven advantage.
 */
   KillMMNode(FindDefMUNU(verb, pre, nreg, 0, 120, 1, &MU, &NU));
   gmmb = CreateGenCasesFromNBs(ummb, pre, nbs, nreg, MU, NU, 1);
   if (verb > 1)
   {
      printf("\n");
      PrintMMNodes(stdout, gmmb);
      printf("\n");
   }
   printf("Finding generated cases for all NBs:\n");
   for (mp=gmmb; mp; mp = mp->next)
   {
      int mu;
      mp->mflop[0] = TimeMMKernel(verb, 0, mp, pre, mp->mbB, mp->nbB, mp->kbB, 
                                  mp->kbB, mp->kbB, mp->mbB, 1, 0, -1);
      mu = (mp->vlen) ? mp->mu / mp->vlen : mp->mu;
      printf("   NB=%d, mu=%d, nu=%d, vlen=%d, MFLOPS=%.2f\n", 
             mp->kbB, mu, mp->nu, mp->vlen, mp->mflop[0]);
   }
   printf("Done.\n\n");
   WriteMMFileWithPath(pre, "res", "gAMMRES.sum", gmmb);
   return(gmmb);
}


ATL_mmnode_t *GetWorkingUserCases(int verb, char pre)
{
   ATL_mmnode_t *mmb, *mmp;
@ROUT ammsearch00
   mmb = ReadMMFileWithPath(pre, "res", "AMMFRCLST.sum");
   if (mmb)
      return(mmb);
@ROUT ammsearch uammsearch
   mmb = ReadMMFileWithPath(pre, "res", "WORKING.sum");
   if (mmb)
      return(mmb);
   mmb = ReadMMFileWithPath(pre, "AMMCASES", "amcases.idx");
   if (!mmb)
      return(mmb);
/*
 * Eliminate those kernels that can't work for any block size
 */
   for (mmp=mmb; mmp; mmp = mmp->next)
   {
      if (FLAG_IS_SET(mmp->flag, MMF_KUISKB))
         mmp->mbB = mmp->nbB = mmp->kbB = mmp->ku;
      else
      {
         int m = Mylcm(mmp->mu, mmp->nu);
         m = ((60+m-1)/m)*m;
         mmp->mbB = mmp->nbB = mmp->kbB = m;
         if (mmp->kbmin)
            mmp->kbB = Mmax(mmp->kbB, mmp->kbmin);
         if (mmp->kbmax)
            mmp->kbB = Mmin(mmp->kbB, mmp->kbmax);
      }
   }
   mmb = DelBadMMKernels(pre, verb, mmb);
   WriteMMFileWithPath(pre, "res", "WORKING.sum", mmb);
   return(mmb);
}

ATL_mmnode_t *FindBestUserCases(int verb, char pre, int *nbs, ATL_mmnode_t *mmb)
/*
 * NOTE: frees mmb after search!!
 * RETURNS: list of the best user case for each supplied NB; if no user case
 *          works, special "generated" node is returned for later filling out.
 */
{
   ATL_mmnode_t *mmp, *mp;
   mp = ReadMMFileWithPath(pre, "res", "uAMMRES.sum");
/*
 * If final output file exists, then we need to rerun timings at worst
 */
   if (mp)
   {
      KillAllMMNodes(mmb);
      for (mmp=mp; mmp; mmp = mmp->next)
      {
         if (mmp->ID > 0 && mmp->mflop[0] < 0.0)
            mmp->mflop[0] = TimeMMKernel(verb, 0, mmp, pre, mmp->mbB, mmp->nbB,
                                         mmp->kbB, mmp->kbB, mmp->kbB, mmp->mbB,
                                         1, 0, -1);
         if (mmp->ID > 0)
            printf("USER KERNEL AT NB=%d gets MFLOP=%.2f\n",
                   mmp->kbB, mmp->mflop[0]);
         else
            printf("NO USER KERNEL FOR NB=%d\n", mmp->kbB);
      }
      printf("\n");
      return(mp);
   }
   mmp = FindBestForEachNB(verb, pre, mmb, nbs);
   KillAllMMNodes(mmb);
   WriteMMFileWithPath(pre, "res", "uAMMRES.sum", mmp);
   return(mmp);
}

ATL_mmnode_t *MergeCases
(
   int imf,
   ATL_mmnode_t *bs0, /* queue of cases */
   ATL_mmnode_t *bs1  /* queue of cases */
)
/*
 * Merges two queues of matmul kern cases.  Cases are not winnowed, but
 * duplicates are not allowed, so if two entries have the same kbB, then
 * we take the one with best mflop[imf].  If imf < 0, then we do indeed
 * allow duplicates of kbB.
 * NOTE: does not change bs0 or bs1.
 * ASSUMES: both bs0 & bs1 are in kb-increasing order.
 * RETURNS: base ptr to merged queue
 */
{
   ATL_mmnode_t *mb=NULL, *mp;
   while (bs0 || bs1)
   {
      ATL_mmnode_t *p;
      if (bs0 && bs1)
      {
         if (bs0->kbB < bs1->kbB)
         {
            p = CloneMMNode(bs0);
            bs0 = bs0->next;
         }
         else if (bs0->kbB > bs1->kbB)
         {
            p = CloneMMNode(bs1);
            bs1 = bs1->next;
         }
         else /* they are equal, must take best performer, or both */
         {
/*
 *          If we are taking both, special case can't use general completion
 */
            if (imf < 0)
            {
               p = CloneMMNode(bs0);
               bs0 = bs0->next;
               p->next = CloneMMNode(bs1);
               bs1 = bs1->next;
               if (mb)
                  mp->next = p;
               else
                  mb = p;
               mp = p->next;
               continue;
            }
/*
 *          Taking only the best performer, but moving both base ptrs
 */
            else
            {
/*
 *             If they are equal, take the KRUN=1 case if it exists, else
 *             take the most flexible one or one requiring the least cleanup
 */
               if (bs0->mflop[imf] == bs1->mflop[imf])
               {
                  if (FLAG_IS_SET(bs0->flag, MMF_KRUNTIME))
                     p = bs0;
                  else if (FLAG_IS_SET(bs1->flag, MMF_KRUNTIME))
                     p = bs1;
                  else if (bs0->ku < bs1->ku)
                     p = bs0;
                  else if (bs1->ku < bs0->ku)
                     p = bs1;
                  else
                  {
                     const int u0=Mmax(bs0->mu, bs0->nu), 
                               u1=Mmax(bs1->mu, bs1->nu);
                     p = (u0 <= u1) ? bs0 : bs1;
                  }
               }
               else
                  p = (bs0->mflop[imf] > bs1->mflop[imf]) ? bs0 : bs1;
               p = CloneMMNode(p);
               bs0 = bs0->next;
               bs1 = bs1->next;
            }
         }
      }
      else if (bs0)
      {
         p = CloneMMNode(bs0);
         bs0 = bs0->next;
      }
      else /* if (bs1) */
      {
         p = CloneMMNode(bs1);
         bs1 = bs1->next;
      }
      if (mb)
      {
         mp->next = p;
         mp = p;
      }
      else
        mp = mb = p;
   }
   return(mb);
}

#define HUGE_NB 180
ATL_mmnode_t *WinnowHugeNB
(
   int imf,
   ATL_mmnode_t *mb  /* queue of cases */
)
/*
 * Removes any NB >= HUGE_NB that aren't at least 2% faster than smaller cases
 */
{
   ATL_mmnode_t *mp, *p, *prev=mb;
   double mfB;

   if (!mb || !mb->next)
      return(mb);
   mp = mb->next;
/*
 * Find best-performing kernel below HUGE_NB
 */
   mfB = mp->mflop[imf];
   for (mp=mb->next; mp; mp = mp->next)
   {
      if (mp->mbB < HUGE_NB && mp->nbB < HUGE_NB && mp->kbB < HUGE_NB)
         mfB = Mmax(mfB, mp->mflop[imf]);
      else
         break;
      prev = mp;
   }
/*
 * If no kernels above threshold, return original queue
 */
   if (!mp)
      return(mb);
/* 
 * mp points to first NB above threshold, but there is no point in deleting
 * small NB if we leave large NB, so delete only from the end of queue
 */
  do
  {
     for (p=mp; p->next; p = p->next);
     if (p->mflop[imf] <= 1.02*mfB)
        mp = RemoveMMNodeFromQ(mp, p);
     else  /* stop removing stuff */
        break;
  }
  while (mp);
  prev->next = mp;
  return(mb);
}

ATL_mmnode_t *WinnowCases
(
   int imf,
   ATL_mmnode_t *mb  /* queue of cases */
)
/*
 * Removes any case that runs slower than a smaller case
 * RETURNS: mb with queue bad kernels deleted
 * NOTE: mb can never change, since by def nothing smaller than 1st case
 */
{
   ATL_mmnode_t *prev = mb, *mp;

   if (!mb)
      return(NULL);
@skip   mb = WinnowHugeNB(imf, mb);
   mp = mb->next;
   while (mp)
   {
      if (mp->mflop[imf] <= prev->mflop[imf])  /* kill slow KB */
         mp = prev->next = KillMMNode(mp);
      else
      {
         prev = mp;
         mp = mp->next;
      }
   }
   return(mb);
}

ATL_mmnode_t *MergeAndWinnowCases
(
   int verb, 
   char pre, 
   ATL_mmnode_t *umb, /* queue of user cases */
   ATL_mmnode_t *gmb  /* genned cases, always include NBs of umb */
)
/*
 * Merges user and gmp cases, while getting rid of cases that get worse
 * performance than their smaller blocks; FREES umb and gmb
 * RETURNS: new merged and winnowed queue
 */
{
   ATL_mmnode_t *mmb=NULL, *mmp, *gmp, *ump=umb;
   for (gmp=gmb; gmp; gmp = gmp->next)
   {
      ATL_mmnode_t *p;
      if (ump)
      {
         if (ump->kbB == gmp->kbB)
         {
            if (gmp->mflop[0] >= ump->mflop[0])
               p = CloneMMNode(gmp);
            else
               p = CloneMMNode(ump);
            ump = ump->next;
         }
         else
            p = CloneMMNode(gmp);
      }
      else
         p = CloneMMNode(gmp);
      p->next = NULL;
      if (mmb)
      {
/*
 *       If larger NB isn't faster than smaller one, kill it for nb >= 16
 */
         if (p->kbB >= 16 && mmp->mflop[0] > p->mflop[0])
            KillMMNode(p);
         else
         {
            mmp->next = p;
            mmp = p;
         }
      }
      else
         mmp = mmb = p;
   }
   KillAllMMNodes(umb);
   KillAllMMNodes(gmb);
   mmb = WinnowCases(0, mmb);
@skip   mmb = WinnowHugeNB(0, mmb);
   return(mmb);
}


@beginskip
void ApplyMoves2Flags  /* overwrites MV bits according to string */
(
   ATL_mmnode_t *mmb,  /* queue of kernels to set MMF_MV[A,B,C] flag bits */
   char *mvs           /* string passed to timer wt moves */
)
{
   ATL_mmnode_t *mmp;
   const unsigned int NOMV = ~MMF_MVSET;
   unsigned int DOMV;
   if (!mvs)
      DOMV = ((1<<MMF_MVA) | (1<<MMF_MVB));
   else
   {
      DOMV = 0;
      if (strstr(mvs, "MoveA"))
         DOMV |= (1<<MMF_MVA);
      if (strstr(mvs, "MoveB"))
         DOMV |= (1<<MMF_MVB);
      if (strstr(mvs, "MoveC"))
         DOMV |= (1<<MMF_MVC);
   }
   for (mmp=mmb; mmp; mmp = mmp->next)
      mmp->flag = (((mmp->flag) & NOMV) | DOMV);
}
@endskip

int FailKCleanTests(char pre, int nb, ATL_mmnode_t *kp)
/*
 *  This routine tests if a kernel is suitable for use in K-cleanup by
 *  doing testing with ku=1, kb=0, and tries all K values between 1 and nb
 *  RETURNS: 0 if kernel passes all tests, else non-zero
 */
{
   int i, beg, end, inc;

   if (!FLAG_IS_SET(kp->flag, MMF_KRUNTIME) || 
       (kp->ku != 1 && kp->ku != kp->kmaj))
      return(-1);
   printf("TESTING ID=%d, rout='%s', nb=%d, mu=%d, nu=%d for K-cleanup:\n",
          kp->ID, kp->rout, nb, kp->mu, kp->nu);

   if (kp->kmaj > 1)
   {
      inc = beg = kp->kmaj;
      end = ((nb+inc-1)/inc)*inc;
   }
   else
   {
      beg = inc = 1;
      end = nb;
   }
   for (i=beg; i <= end; i += inc)
   {
      int ierr;
      ierr = MMKernelFailsTest(pre, nb, nb, i, 0, kp);
      if (ierr)
      {
         printf("  K=%d: FAILED!\n", i);
         return(ierr);
      }
      else
         printf("  K=%d: PASSED!\n", i);
   }
   printf("PASSED ALL K-tests!\n\n");
   return(0);
}
@ROUT ammsearch  `@define kpr @AMM@`
@ROUT uammsearch `@define kpr @UMM@`
ATL_mmnode_t *GetUniqueKClean(int verb, char pre, ATL_mmnode_t *mmb)
/*
 * OUTPUT: <pre>@(kpr)KCLEAN.sum: all unique kerns to be compiled
 */
{
   ATL_mmnode_t *mp, *gmmb, *ummb, *ub, *np, **dlmm;
   int nn=0, nd=0, n=0;  /* #needed & done, total, copy of done */
   int *dl, *nl;         /* done and needed lists */
   int i;
@ROUT ammsearch
   gmmb = ReadMMFileWithPath(pre, "res", "@(kpr)KCLEAN.sum");
   if (gmmb)
   {
      printf("READING IN UNIQUE K-CLEANUP:\n");
      FillInGenStrings(pre, gmmb);
      for (mp=gmmb; mp; mp = mp->next)
      {
         int mb = (mp->nbB > mp->mu) ? (mp->nbB/mp->mu)*mp->mu : mp->mu;
         int nb = (mp->nbB > mp->nu) ? (mp->nbB/mp->nu)*mp->nu : mp->nu;
         int kb = (nb > 8) ? (nb>>2) : nb, KB = kb;
         int ku = mp->ku;
         if (mp->kmaj > 1)
            KB = ((kb+ku-1)/ku)*ku;
         if (mp->mflop[0] < 0.0)
         {
            mp->mflop[0] = TimeMMKernel(verb, 0, mp, pre, mb, nb, KB, 0, 0, mb,
                                        0, 0, -1);
            mp->mflop[0] *= (double)kb / (double)KB;
         }
         printf("   nb=%d,  kb=%d, mu=%d, nu=%d, MFLOP=%.2f\n", 
                nb, kb, mp->mu, mp->nu, mp->mflop[0]);
      }
      printf("Done.\n");
      return(gmmb);
   }
@ROUT ammsearch uammsearch
/*
 * Find out how many total kernels, and how many already have their own
 * cleanup (nd, number done).  This nd may be bigger than it should, because
 * we can't guarantee they are unique
 */
   for (mp=mmb; mp; mp = mp->next, n++)
      if ((mp->ku == 1 || (mp->kmaj == mp->ku)) && 
          FLAG_IS_SET(mp->flag, MMF_KRUNTIME))
        nd++;
   dl = malloc(8*n*sizeof(int));
   assert(dl);
   if (nd)
   {
      dlmm = malloc(nd*sizeof(ATL_mmnode_t*));
      assert(dlmm);
   }
   else
      dlmm = NULL;

   nl = dl + (n<<2);
   nd = 0;
/*
 * First, go back through kernels, and add kernels that can serve as K-cleaners
 * to the done list
 */
   for (mp=mmb; mp; mp = mp->next, n++)
   {
      if (FLAG_IS_SET(mp->flag, MMF_KRUNTIME) && 
          (mp->ku == 1 || mp->kmaj == mp->ku))
      {
         const int nd4 = (nd<<2), mu=mp->mu, nu=mp->nu, kmaj=mp->kmaj;
/*
 *       See if trip is already in done list if so, no new entry, just update kb
 *       and cleanup kernel entry
 */
         for (i=0; i < nd4; i += 4)
            if (mu == dl[i] && nu == dl[i+1] && kmaj == dl[i+2])
               break;
         if (i < nd4)
         {                      /* (larger NB always later) */
            dl[i+3] = mp->kbB;  /* take largest kbB that matches mu/nu */
            dlmm[i>>2] = mp;
            continue;           
         }
         else
         {
            dl[nd4] = mu;
            dl[nd4+1] = nu;
            dl[nd4+2] = kmaj;
            dl[nd4+3] = mp->kbB;
            dlmm[nd++] = mp;
         }
      }
   }
/*
 * Delete any kernels from dl that fail to actually work for K cleaning
 */
   for (i=0; i < nd; i++)
   {
      if (FailKCleanTests(pre, dlmm[i]->kbB, dlmm[i]))
      {
         const int i4=(i<<2), nc=nd-i-1;
         if (nc > 0)
         {
            memcpy(dl+i4, dl+i4+4, (nc<<2)*sizeof(int));
            memcpy(dlmm[i], dlmm[i+1], nc*sizeof(ATL_mmnode_t*));
         }
         nd--;
      }
   }

/*
 * Find all unique (mu,nu,kmaj) combos that still need to to be cleaned; 
 * there will be nn (# needed) of these, and we'll save (mu,nu,MAXNB) in
 * needed list (nl).
 * We use MAXNB for testing (large NB tests mosts cases of K).
 * Combos that are handled by the done list (dl) aren't added to needed list.
 */
   for (mp=mmb; mp; mp = mp->next, n++)
   {
      int mu=mp->mu, nu=mp->nu, kmaj=mp->kmaj, nn4=(nn<<2), nd4=(nd<<2);
/*
 *    See if pair is already in done list or needed list, if so, no change
 */
      for (i=0; i < nd4; i += 4)
         if (mu == dl[i] && nu == dl[i+1] && kmaj == dl[i+2])
            break;
      if (i < nd4)    /* if it was found in the done list */
         continue;    /* this combo is already handled */
/*
 *    If we reach here, combo is not handled, must add to needed list 
 */
      for (i=0; i < nn4; i += 4)
         if (mu == nl[i] && nu == nl[i+1] && kmaj == nl[i+2])
            break;
      if (i < nn4)            /* If already in needed list */
      {
         nl[i+3] = mp->kbB;   /* just update kb so we get largest for testing */
         continue;
      }
/*
 *    If we haven't seen this pair before, add to needed list
 */
      else
      {
         nl[nn4] = mu;
         nl[nn4+1] = nu;
         nl[nn4+2] = kmaj;
         nl[nn4+3] = mp->kbB;
         nn++;
      }
   }
/*
 * Now, create a queue of generated kernels for each needed pair, and time
 * it's maxNB performance.
 */
   gmmb = NULL;
   printf("Timing Generated K-cleanup:\n");
   for (i=0; i < nn; i++)
   {
      ATL_mmnode_t *p;
      const int i4 = (i<<2), mu=nl[i4], nu=nl[i4+1], kmaj=nl[i4+2];
      int nb = Mmax(nl[i4+3],nu), mb = (nb > mu) ? (nb/mu)*mu : mu;
      const int kb = (nb > 8) ? (nb>>2) : nb;
      int vl=VECi, vmu, KK;
      double mf;
/*
 *    HERE HERE: Improve KMAJ when generator is extended!
 */
      if (kmaj > 1)
      {
        vmu = mu;
        VECi = VTSC;
      }
      else
      {
         if (mu % VLEN[VECi])
         {
            if (VECi == VTAVX && !(mu%VLEN[VTSSE]))
               VECi = VTSSE;
            else
               VECi = VTSC;
         }
         vmu = mu / VLEN[VECi];
      }
/* HERE HERE */
      p = GetNewGenNode(pre, nb, 0, vmu, nu, 1, kmaj);
      p->mbB = mb;
      p->nbB = nb;
      p->kbB = kb;
      p->flag |= (1<<MMF_KRUNTIME);
      VECi = vl;
      #if 0  /* by default don't waste time testing generated code */
         assert(!FailKCleanTests(pre, nb, p));
      #endif
      KK = (kmaj < 2) ? kb : ((kb+kmaj-1)/kmaj)*kmaj;
      p->mflop[0] = TimeMMKernel(verb, 0, p, pre, mb, nb, kb, 0, 0, nb, 
                                 0, 0, -1);
      if (KK != kb)
         p->mflop[0] *= (double)kb / (double)KK;
      printf("   nb=%d, kb=%d,  mu=%d, nu=%d, MFLOP=%.2f\n", 
             nb, kb, mu, nu, p->mflop[0]);
      if (gmmb)
      {
         mp->next = p;
         mp = p;
      }
      else
         gmmb = mp = p;
   }
   printf("Done.\n");
/*
 * Now, add the done-list items to generated list
 */
   for (i=0; i < nd; i++)
   {
      const int i4=4*i, mu=dl[i4], nu=dl[i4+1], kmaj=dl[i4+2], nb=dl[i4+3];
      ATL_mmnode_t *prev=NULL;
/*
 *    Get a copy of done-list kern that can be added to genlist
 */
      np = CloneMMNode(dlmm[i]);
      np->next = gmmb;
      gmmb = np;
   }
   if (dlmm)
      free(dlmm);
/*
 * Now, search index file for suitable user-submitted kernels to compete
 * with existing solutions
 */
   ub = ReadMMFileWithPath(pre, "AMMCASES", "amcases.idx");
   ummb = NULL;  /* no suitable user cases to begin */
/*
 * Look through user-list for any routine with ku=1 and K-Runtime
 */
   for (mp=ub; mp; mp = mp->next)
   {
      if (FLAG_IS_SET(mp->flag, MMF_KRUNTIME) && 
          (mp->ku == 1 || mp->kmaj == mp->ku))
      {
/*
 *       It matched our gross criteria, see if it is a required mu/nu
 */
         for (i=0; i < nn; i++)
         {
            const int i4=(i<<2), mu=nl[i4], nu=nl[i4+1], kmaj=nl[i4+2], 
                      nb=nl[i4+3];
            if (mp->mu == mu && mp->nu == nu && mp->kmaj == kmaj)
            {
               if (!FailKCleanTests(pre, nb, mp))
               {
                  ATL_mmnode_t *p;
                  p = CloneMMNode(mp);
                  p->next = NULL;
                  p->nbB = ((nb+nu-1)/nu)*nu;
                  p->mbB = ((nb+mu-1)/mu)*mu;
                  p->kbB = nb;
                  if (ummb)
                  {
                     np->next = p;
                     np = p;
                  }
                  else
                     np = ummb = p;
                  break;
               }
            }
         }
      }
   }
   KillAllMMNodes(ub);
/*
 * If we have both user and genned code, must compare timing to select best
 */
   if (ummb)
   {
/*
 *    Now, loop over user cases and time them for comparison with genned
 */
      printf("Timing User K-cleanup:\n");
      for (mp=ummb; mp; mp = mp->next)
      {
         const int nb = mp->nbB, kb = (nb > 8) ? (nb>>2) : nb;
         const int KK = (mp->kmaj < 2) ? kb:((kb+mp->kmaj-1)/mp->kmaj)*mp->kmaj;
         mp->mflop[0] = TimeMMKernel(verb, 0, mp, pre, mp->mbB, nb, KK, 0, 0, 
                                     KK, 0, 0, -1);
         if (KK != kb)
            mp->mflop[0] *= (double)kb / (double)KK;
         printf("   ID=%d, nb=%d, kb=%d, mu=%d, nu=%d, MFLOP=%.2f\n", 
                mp->ID, nb, kb, mp->mu, mp->nu, mp->mflop[0]);
      }
      printf("Done timing, merging lists:\n");
/*
 *    Merge generated (gmmb) and user (ummb) kerns by selecting best performing.
 *    gmmb is a superset of ummb, so what we will do is look through gmmb
 *    for matching (mu,nu,dup), time them, and if ummb is faster, replace
 *    that entry in gmmb with ummb.
 */
      while (ummb)
      {
         ATL_mmnode_t *prev=NULL;
         int mu=ummb->mu, nu=ummb->nu, kmaj = ummb->kmaj;
         for (mp=gmmb; mp && (mp->mu != mu || mp->nu != nu || mp->kmaj != kmaj);
              mp = mp->next)
            prev = mp;
         assert(mp);  /* logic error if we haven't found it */
/*
 *       If user case gets better performance, replace genned case in queue
 */
         if (ummb->mflop[0] > gmmb->mflop[0])
         {
            printf("   Replacing genned case (%.2f) with user ID %d (%.2f)\n",
                   gmmb->mflop[0], ummb->ID, ummb->mflop[0]);
            if (prev)
            {
               prev->next = ummb;
               ummb = ummb->next;
               prev->next->next = KillMMNode(mp);
            }
            else /* replace gmmb, mp pts at gmmb */
            {
               ATL_mmnode_t *up=ummb;
               ummb = ummb->next;
               up->next = KillMMNode(gmmb);
               gmmb = up;
            }
         }
         else /* user case loser, just delete it */
         {
            printf("   Preferring genned case (%.2f) over user ID %d (%.2f)\n",
                   gmmb->mflop[0], ummb->ID, ummb->mflop[0]);
            ummb = KillMMNode(ummb);
         }
      }
      printf("DONE.\n\n");
   }
   else
      printf("NO VALID USER-SUBMITTED K-CLEANUP KERNELS\n\n");
   free(dl);
@skip   ApplyMoves2Flags(gmmb, MOVES);  /* gen must know operand movement pattern */
   WriteMMFileWithPath(pre, "res", "@(kpr)KCLEAN.sum", gmmb);
   return(gmmb);
}

@beginskip
int MMKernsSame(ATL_mmnode_t *p0, ATL_mmnode_t *p1)
/*
 * RETURNS: 1 if kernels are the same except for blocking, 0 otherwise
 */
{
/*
 * Two generated kernels are the same if mu,nu,ku,VLEN,flag are the same.
 * NOTE: if we make generator handle muladd, etc, MUST UPDATE HERE!!!
 */
   if (p0->ID == 0 && p1->ID == 0)
      return(p0->mu == p1->mu && p0->nu == p1->nu && p0->ku == p1->ku &&
             p0->vlen == p1->vlen && p0->flag == p1->flag &&
             p0->kmaj == p1->kmaj);
/*
 * If both are user kernels, then they may be repeats.  For user kernels,
 * they are the same if both ID and flag match, else they are not.
 */
   else if (p0->ID > 0 && p1->ID > 0)
      return(p0->ID == p1->ID && p0->flag == p1->flag);
   return(0);  /* Can't be the same if above criteria fails */
}

int MMKernCompsSame(ATL_mmnode_t *p0, ATL_mmnode_t *p1)
/*
 * RETURNS: 1 if kernels are the same except for blocking, 0 otherwise
 */
{
/*
 * Kernels are not the same if one has compile-time K and other runtime
 */
   if (FLAG_IS_SET(p0->flag, MMF_KRUNTIME) != 
       FLAG_IS_SET(p1->flag, MMF_KRUNTIME))
      return(0);
/*
 * Kernels not same if both compilet-time K with differing KB
 */
   if (!FLAG_IS_SET(p0->flag, MMF_KRUNTIME) && p0->kbB != p1->kbB)
      return(0);
   return(MMKernsSame(p0, p1));
}
@endskip

int KernelIsUnique(ATL_mmnode_t *mmb, ATL_mmnode_t *mmp)
/*
 * Determines if mmp is the first mention of a unique kernel in mmb, or not.
 * For user cases (ID > 0), (ID,flag) together make a unique kernel.
 * For user generated cases, if they match on : mu,nu,ku,VLEN,flag
 *
 * RETURNS: 0 if mmp appears in mmb before mmp, else 1
 */
{
   ATL_mmnode_t *mp;
   if (mmp == mmb)
      return(1);
   for (mp=mmb; mp && mp != mmp; mp = mp->next)
      if (MMKernsSame(mmp, mp))
         return(0);
   return(1);  /* didn't find it, must be first time in list */
}

@beginskip
int MMKernCompIsPresent(ATL_mmnode_t *mmb, ATL_mmnode_t *mmp)
/*
 * RETURNS: 1 if kernel compilation matching mmp is in list mmb, 0 otherwise
 */
{
   ATL_mmnode_t *mp;
   for (mp=mmb; mp; mp = mp->next)
      if (mp != mmp && MMKernCompsSame(mmp, mp))
         return(1);
   return(0);
}
@endskip

/*
 * Returns a non-repetitive list of user kernels (ID>0) found in rb.  Note that
 * differing compilations of the same kernel are reduced to one entry.
 * rb is left unchanged.
 */
ATL_mmnode_t *GetUniqueUserKerns(ATL_mmnode_t *rb)
{
   ATL_mmnode_t *ub=NULL, *p;

   if (!rb)
      return(NULL);
   for (p=rb; p; p = p->next)
      if (p->ID > 0) 
         break;
   if (!p)
      return(NULL);
   ub = CloneMMNode(p);
   for (p=p->next; p; p = p->next)
   {
       if (p->ID > 0)
       {
          ATL_mmnode_t *np;
          int ID = p->ID;

          for (np=ub; np; np = np->next)
             if (np->ID == ID)
                break;
          if (!np)
          {
             np = CloneMMNode(p);
             np->next = ub;
             ub = np;
          }
       }
   }
   return(ub);
}

static int SelfKClean(ATL_mmnode_t *mp)
{
   if (FLAG_IS_SET(mp->flag, MMF_KRUNTIME))
   {
      if (mp->kmaj > 1)
      {
         if (mp->ku == mp->kmaj && mp->kbmin == mp->kmaj)
            return(1);
      }
      else if (mp->ku == 1 && mp->kbmin < 2)
         return(1);
   }
   return(0);
}

ATL_mmnode_t *CanKClean(ATL_mmnode_t *krn, ATL_mmnode_t *cln)
/*
 * RETURNS: NULL if cln/krn cannot provide K-cleanup for krn, else ptr
 *          to krn if it can do its own K-cleanup, else ptr to cln
 */
{
/*
 * First, determine if kernel can perform its own cleaning
 */
   if (SelfKClean(krn))
      return(krn);
/*
 * Cleaner must share same mu/nu, have runtime K, and handle long enough K
 */
   if (krn->mu == cln->mu && krn->nu == cln->nu && 
       FLAG_IS_SET(cln->flag, MMF_KRUNTIME) &&
      (!cln->kbmax || cln->kbmax >= krn->kbB))
   {
      if (krn->kmaj > 1)
      {
         if (cln->kmaj == krn->kmaj && cln->kbmin <= krn->kmaj)
            return(cln);
      }
      else if (cln->ku == 1 && cln->kbmin < 2 && cln->kmaj < 2)
         return(cln);
   }
   return(NULL);
}

ATL_mmnode_t *FindKCleaner(ATL_mmnode_t *clnb, ATL_mmnode_t *kp)
/*
 * RETURNS: kp if kp provides its own K cleanup, 
 *          else NULL if no K-cleaner for kp is found in clnb, 
 *          else a ptr to the first such valid K-cleaner found in clnb
 */
{
   ATL_mmnode_t *mp, *cln;
   for (mp=clnb; mp; mp = mp->next)
   {
      ATL_mmnode_t *cln;
      cln = CanKClean(kp, mp);
      if (cln)
         return(cln);
   }
   return(NULL);
}

ATL_mmnode_t *FindAllKCleaners(ATL_mmnode_t *clnb, ATL_mmnode_t *kp)
/*
 * RETURNS: if kp provides its own K-cleaning, then kp is returned.
 *          otherwise a queue cloned nodes of all kernels in clnb that 
 *          could be used to clean kp is return.
 * Cloned nodes have their blocking values set to match kp
 */
{
   ATL_mmnode_t *gdb=NULL, *mp, *mpc;

   gdb = FindKCleaner(clnb, kp);
   if (gdb == kp)
      return(kp);
   else if (gdb)
   {
      mp = gdb;
      gdb = CloneMMNode(gdb);
      gdb->mbB = kp->mbB;
      gdb->nbB = kp->nbB;
      gdb->kbB = kp->kbB;
      while ((mp = FindKCleaner(mp->next, kp)))
      {
         mpc = CloneMMNode(mp);
         mpc->mbB = kp->mbB;
         mpc->nbB = kp->nbB;
         mpc->kbB = kp->kbB;
         mpc->next = gdb;
         gdb = mpc;
      }
      return(gdb);
   }
   return(NULL);
}

ATL_mmnode_t *FindAllUniqueKClean(int verb, char pre, ATL_mmnode_t *mmb)
/*
 * Finds a way to clean up all kernels in mmb
 * RETURNS: list of all unique kernels required to do K-cleanup
 */
{
   ATL_mmnode_t *clnb=NULL, *mkb, *kp;
   if (verb)
      printf("FINDING K CLEANERS FOR ALL KERNELS:\n");
/*
 * mkb is the list of all candidate cleanup codes
 */
   mkb = GetWorkingUserCases(verb, pre);
   for (kp=mmb; kp; kp = kp->next)
   {
      ATL_mmnode_t *cp;
      if (FindKCleaner(clnb, kp))  /* if we've already got a K-cleaner */
         continue;                 /* for this case, skip! */
      cp = FindAllKCleaners(mkb, kp);
      if (cp)
         printf("   %s --> %s!\n", kp->rout, cp->rout);
      else
         printf("   %s --> no Kclean!\n", kp->rout);
/*
 *    For kernels that serve as their own K-cleanup, just use them wt no need
 *    to time anything else
 */
      if (cp == kp)
      {
         cp = CloneMMNode(kp);
         cp->next = clnb;
         clnb = cp;
      }
/*
 *    For kernels that must be cleaned by other kernels, we must time all
 *    candidate kernels and use the best!
 */
      else
      {
         ATL_mmnode_t *mp;
         const int mb=kp->mbB, nb=kp->nbB, kb=kp->kbB;
         int ntim;
/*
 *       Add generated case to any user cases that work
 */
         mp = GetNewKCleanGenNode(pre, kp, mb, nb, kb);
         if (!CanKClean(kp, mp))
         {
            fprintf(stderr, "KU=(%d,%d,%d), KV=%d, MU=(%d,%d,%d), MV=%d\n",
                    kp->mu, kp->nu, kp->ku, kp->kmaj,
                    mp->mu, mp->nu, mp->ku, mp->kmaj);
            assert(CanKClean(kp,mp));
         }
         mp->next = cp;
         cp = mp;
         ntim = ATL_CountNumberOfMMNodes(cp);
         if (ntim > 1)
         {
/*
 *          Now time all kernels, and choose the fastest for cleanup.
 *          We'll use kbB as kb, even though this is larger than the code
 *          will ever be used for.  However, it will allow us to directly
 *          compare kernel and cleanup performance.
 *          A better strategy would be to time many different K cases, but
 *          I don't want to spend that amount of install time tuning and timing
 *          low-order cleanup!
 */
            printf("   CHOOSING BETWEEN %d KB=%d K-CLEANERS WITH TIMINGS:\n", 
                   ntim, kb);
            for (mp=cp; mp; mp = mp->next)
            {
               double mf;
               if (mp->mbB != mb || mp->nbB != nb || mp->kbB != kb || 
                   mp->mflop[0] <= 0.0)
               {
                  mp->mbB = mb;
                  mp->nbB = nb;
                  mp->kbB = kb;
                  mf = TimeMMKernel(0, 1, mp, pre, mb, nb, kb, 0, 0, mb, 
                                    0, 0, -1);
                  mp->mflop[0] = mf;
               }
               else
                  mf = mp->mflop[0];
               printf("      %d-%s: %.2f\n", mp->ID, mp->rout?mp->rout:"", mf);
            }
            mp = FindMaxMflopMMQ(cp, 0);
            printf("   USING %d-%s\n", mp->ID, mp->rout? mp->rout:"");
            cp = RemoveMMNodeFromQ(cp, mp);
            KillAllMMNodes(cp);
         }
         else
         {
            mp = cp;
            mp->mbB = mb;
            mp->nbB = nb;
            mp->kbB = kb;
         }
         mp->next = clnb;
         clnb = mp;
      }
   }
   KillAllMMNodes(mkb);
   if (verb)
      printf("DONE FINDING FULL LIST OF K-CLEANERS\n");
   return(clnb);
}

ATL_mmnode_t *FindMUNU(ATL_mmnode_t *mb, int mu, int nu)
{
   ATL_mmnode_t *mp;
   for (mp=mb; mp; mp = mp->next)
      if (mp->mu == mu && mp->nu == nu)
         return(mp);
   return(NULL);
}

ATL_mmnode_t *KCleanByNB
(
   int verb, 
   char pre, 
   ATL_mmnode_t *mmb, /* final kernels giving final supported NBs */
   ATL_mmnode_t *mkb  /* All necessary routs ku=1 to clean all kerns in mmb */
)
/*
 * Replicates mkb so that it includes all NBs in mmb, times K-clean,
 * **FREES** mkb, and returns by-NB list
 *
 * OUTPUT:
 *   <pre>@(kpr)KCLEANBYNB.sum: non-unique K-clean for each NB in mmb
 *      mflop[1] contains estimated time for 1 K-it using K=MAX(kb/4,4)
 */
{
   ATL_mmnode_t *nkb=NULL, *mp, *np;
   int kb;
   double mf;

@ROUT ammsearch
   nkb = ReadMMFileWithPath(pre, "res", "@(kpr)KCLEANBYNB.sum");
   if (nkb)
   {
      KillAllMMNodes(mkb);
      printf("READING IN BY-NB K-CLEANUP:\n");
      FillInGenStrings(pre, nkb);
      for (mp=nkb; mp; mp = mp->next)
      {
         int mb=mp->mbB, nb=mp->nbB;
         kb = mp->kbB >> 2;
         kb = (kb >= 4) ? kb : 4;
         if (mp->mflop[0] < 0.0)
            mp->mflop[0] = TimeMMKernel(verb, 0, mp, pre, mb, nb, kb, 0, 0, mb,
                                        0, 0, -1);
         mf = (2.0*nb)*nb;  /* flop count of gemm/kits (kb) */
         mp->mflop[1] = mf / mp->mflop[0]; /* time in microsecs for 1 k-it */
         printf("   nb=%d, kb=%d, mu=%d, nu=%d, mf=%.2f (%e Usec/Kit)\n", 
                nb, kb, mp->mu, mp->nu, mp->mflop[0], mp->mflop[1]);
      }
      printf("Done.\n");
      WriteMMFileWithPath(pre, "res", "@(kpr)KCLEANBYNB.sum", nkb);
      return(nkb);
   }
@ROUT ammsearch uammsearch
   printf("TIMING K-CLEAN FOR ALL SUPPORTED NBs:\n");
   for (mp=mmb; mp; mp = mp->next)
   {
      ATL_mmnode_t *p;
      int mb = mp->mbB, nb = mp->nbB, kb;

      kb = mp->kbB >> 2;
      kb = (kb >= 4) ? kb : 4;
      if (mp->kmaj > 1)
         kb = ((kb+mp->kmaj-1)/mp->kmaj)*mp->kmaj;

      p = FindMUNU(mkb, mp->mu, mp->nu);
/*
 *    If no user cleanup exists, generate one
 */
      if (!p)
      {
         if (mp->kmaj > 1)
            p = GetNewGenNode(pre, 0, 0, mp->mu, mp->nu, mp->kmaj, mp->kmaj);
         else
            p = GetNewGenNode(pre, 0, 0, mp->mu, mp->nu, 1, 0);
      }
      else
      {
         p = CloneMMNode(p);
         p->next = NULL;
      }
      p->nbB = nb; p->mbB = mb;  p->kbB = kb;
      p->mflop[0] = TimeMMKernel(verb, 0, p, pre, mb, nb, kb, 0, 0, mb, 
                                 0, 0, -1);
      mf = mb*nb;
      p->mflop[1] = mf / p->mflop[0];   /* time in microseconds for 1 k it */
      printf("   mb=%d, nb=%d, kb=%d, mu=%d, nu=%d, mf=%.2f (%e Usec/Kit)\n", 
             mb, nb, kb, p->mu, p->nu, p->mflop[0], mf);
      if (nkb)
      {
         np->next = p;
         np = p;
      }
      else
         nkb = np = p;
   }
   printf("DONE.\n\n");
   KillAllMMNodes(mkb);
   WriteMMFileWithPath(pre, "res", "@(kpr)KCLEANBYNB.sum", nkb);
   return(nkb);
}

void TimeKClean(int verb, char pre, ATL_mmnode_t *mp)
/*
 *   mp is the ku=1, KRUNTIME K-cleanup kernel for a support NB.
 *   This routine creates an output file for supported the NB, where we
 *   document the performance for all NB different KB values.  These
 *   timings can therefore precisely document how expensive K-cleanup
 *   will be for each NB.  
 *   OUTPUT:
 *   <pre>@(kpr)KCLEAN_<nb>.TIM: timing of K-clean for nb=<nb>; there are
 *   i=nb-1 timings, mflop[0] contains time to do NB-i K its.  Will use
 *   these times to get completely accurate estimate of total time for
 *   large problems (use estimated time in CLBYNB for small probs).
 */
{
   ATL_mmnode_t *mmb, *p, *np;
   char fn[32];
   int mb = mp->mbB, nb = mp->nbB, i;

   sprintf(fn, "@(kpr)KCLEAN_%d.TIM", mp->nbB);
   mmb = ReadMMFileWithPath(pre, "res", fn);
   if (mmb)
   {
      printf("READING IN K-CLEANUP TIMINGS FOR NB=%d:\n", nb);
      FillInGenStrings(pre, mmb);
      for (p=mmb; p; p = p->next)
      {
         int kb = p->kbB;
         assert(nb == p->nbB && mb == p->mbB);
         if (p->mflop < 0)
            p->mflop[0] = TimeMMKernel(verb, 0, p, pre, mb, nb, kb, 0, 0, kb, 
                                       0, 0, -1);
         printf("   MB=%d, NB=%d, KB=%d, mu=%d, nu=%d, MFLOP=%.2f\n", 
                mb, nb, kb, p->mu, p->nu, p->mflop[0]);
      }
      printf("Done.\n\n");
      WriteMMFileWithPath(pre, "res", fn, mmb);
      KillAllMMNodes(mmb);
      return;
   }
   
   printf("TIMING K-CLEANUP FOR MB=%d, NB=%d:\n", mb, nb);
   for (i=1; i <= nb; i++)  /* create queue of ascending KB */
   {
      p = CloneMMNode(mp);
      p->next = NULL;
      p->kbB = i;
      p->mflop[0] = TimeMMKernel(verb, 0, p, pre, mb, nb, i, 0, 0, i, 0, 0, -1);
      printf("   MB=%d, NB=%d, KB=%d, mu=%d, nu=%d, MFLOP=%.2f\n", mb, nb, i, 
             p->mu, p->nu, p->mflop[0]);
      if (mmb)
      {
         np->next = p;
         np = p;
      }
      else
         mmb = np = p;
   }
   WriteMMFileWithPath(pre, "res", fn, mmb);
   KillAllMMNodes(mmb);
   printf("Done.\n");
}

/*
 * Specialize the K cleanup routs in mkb to the kernels in mmb by changing
 * their block factors, and timing them.
 */
ATL_mmnode_t *SpecializeKClean
   (int verb, char pre, ATL_mmnode_t *mmb, ATL_mmnode_t *mkb)
{
   ATL_mmnode_t *mp, *b=NULL;
   for (mp=mmb; mp; mp = mp->next)
   {
      ATL_mmnode_t *kp;
      if (SelfKClean(mp))
      {
         kp = CloneMMNode(mp);
         kp->mflop[2] = 1.0;
      }
      else
      {
         const int mb=mp->mbB, nb=mp->nbB, kb=mp->kbB;
         kp = FindKCleaner(mkb, mp);
         if (!kp)
            fprintf(stderr, "UR(%d,%d,%d), %s: NO KCLEAN", 
                    mp->mu, mp->nu, mp->ku, mp->rout);
         assert(kp);
         kp = CloneMMNode(kp);
         if (kp->mbB != mb || kp->nbB != nb || kp->kbB != kb || 
             kp->mflop[0] <= 0.0)
         {
            kp->mbB = mb;
            kp->nbB = nb;
            kp->kbB = kb;
            kp->mflop[0] = TimeMMKernel(verb, 0, kp, pre, mb, nb, kb, 0, 0, mb,
                                        0, 0, -1);
            kp->mflop[2] = kp->mflop[0] / mp->mflop[0];
         }
      }
      printf("   KB=%d KCLEAN SPEEDUP: %.4f\n", kp->kbB, kp->mflop[2]);
      kp->next = b;
      b = kp;
   }
   return(b);
}
@ROUT uammsearch
void ComputeKClean(int verb, char pre, ATL_mmnode_t *mmb)
{
   ATL_mmnode_t *mkb, *mp, *mmbk=NULL;

   assert(mmb);

   mkb = FindAllUniqueKClean(verb, pre, mmb);
   if (verb)
      printf("SPECIALIZING K-CLEANERS FOR SQUARE BLOCKINGS:\n");
   mmbk = SpecializeKClean(verb, pre, mmb, mkb);
   if (verb)
      printf("DONE SPECIALIZING K-CLEANERS FOR SQUARE BLOCKINGS.\n");
   WriteMMFileWithPath(pre, "res", "UMMKCLEAN.sum", mmbk);
   KillAllMMNodes(mmbk);
   if (verb)
      printf("\nDONE FINDING K-CLEANUP FOR EACH KB.\n");
}
@ROUT ammsearch
void ComputeKClean(int verb, char pre)
/*
 * This kernel finds K-cleanup for all routines present in <pre>geAMMRES.sum
 * and <pre>sqAMMRES.sum.
 *
 * OUTPUT: <pre>@(kpr)KCLEAN.sum: all unique kerns to be compiled
 *         <pre>geAMMKCLEAN.sum:  MFLOP[2] = cleanup slowdown
 *         <pre>sqAMMKCLEAN.sum: MFLOP[2] = cleanup slowdown
@beginskip
 *   i=nb-1 timings, mflop[0] contains time to do NB-i K its.  Will use
 *   these times to get completely accurate estimate of total time for
 *   large problems (use estimated time in CLBYNB for small probs).
@endskip
 * 
 * NOTE: we will time K-cleanup kernels only in BETA=0 case, and peel
 *    the first K-block rather than the last.  This will minimize the C cost,
 *    which is more appreciable for short-K.  We will actually generate all
 *    beta cases, since sometimes you need other betas (in complex, or if
 *    you can't peel first partial for some reason).
 */
{
   ATL_mmnode_t *mkb, *mmGE, *mmSQ, *mp, *mmGEk=NULL, *mmSQk=NULL;
   mmGEk = TimeMMFileWithPath(pre, "res", "geAMMKCLEAN.sum", 
                              0, verb, 0, 0, 0, -1);
   mmSQk = TimeMMFileWithPath(pre, "res", "sqAMMKCLEAN.sum", 
                              0, verb, 0, 0, 0, -1);
   if (mmGEk && mmSQk)
   {
      KillAllMMNodes(mmGEk);
      KillAllMMNodes(mmSQk);
      return;
   }
   if (mmGEk)
      KillAllMMNodes(mmGEk);
   if (mmSQk)
      KillAllMMNodes(mmSQk);
   mmGEk = mmSQk = NULL;
@skip   if (verb)
@skip      printf("FINDING K-CLEANUP FOR EACH KB:");
/*
 * Will use only one K-cleanup for any (mu,nu,kmaj) combo.  Will decide between
 * competing kernels based on timings, with larger KB more important, so we
 * reverse the list order so that the larger block factors choose cleanup for
 * smaller, rather than reverse.
 */
   mmGE = ReverseMMQ(ReadMMFileWithPath(pre, "res", "geAMMRES.sum"));
   mmSQ = ReverseMMQ(ReadMMFileWithPath(pre, "res", "sqAMMRES.sum"));
   assert(mmGE && mmSQ);
/*
 * Now temporarily join rect & square lists into one, and get a list of
 * all cleanup routines that are required.  Routines that provide their
 * own cleanup will always be used regardless of what is in the list,
 * and the first such kernel will appear in mkb
 */
   for (mp=mmGE; mp->next; mp = mp->next);
   mp->next = mmSQ;
   mkb = FindAllUniqueKClean(verb, pre, mmGE);
   WriteMMFileWithPath(pre, "res", "k1AMM.sum", mkb);
   mp->next = NULL;  /* go back to separate lists */
/*
 * Use reversed lists to build lists of cleanup, which will be in correct
 * order due to the way we build them
 */
   if (verb)
      printf("SPECIALIZING K-CLEANERS FOR RECTANGULAR BLOCKINGS:\n");
   mmGEk = SpecializeKClean(verb, pre, mmGE, mkb);
   if (verb)
      printf("DONE SPECIALIZING K-CLEANERS FOR RECTANGULAR BLOCKINGS.\n");
   KillAllMMNodes(mmGE);
   WriteMMFileWithPath(pre, "res", "geAMMKCLEAN.sum", mmGEk);
   KillAllMMNodes(mmGEk);
/*
 * Now do same for square kernels
 */
   if (verb)
      printf("SPECIALIZING K-CLEANERS FOR SQUARE BLOCKINGS:\n");
   mmSQk = SpecializeKClean(verb, pre, mmSQ, mkb);
   if (verb)
      printf("DONE SPECIALIZING K-CLEANERS FOR SQUARE BLOCKINGS.\n");
   KillAllMMNodes(mmSQ);
   WriteMMFileWithPath(pre, "res", "sqAMMKCLEAN.sum", mmSQk);
   KillAllMMNodes(mmSQk);
   if (verb)
      printf("\nDONE FINDING K-CLEANUP FOR EACH KB.\n");
}
@ROUT ammsearch uammsearch

void FindBestKU1
(
   int verb, 
   char pre,   
   int K       /* K dim, should be small, probably like 23 or 17 */
)
/* 
 * Find the best possible kernel for use in low-rank update;  We only consider
 * kernels with runtime-K that handle all possible K (ku=1).  We will try
 * all legal blocking factors between 16 & 480 for this kernel, and choose
 * the one that performs best.  This kernel always used for any K not covered
 * by optimized kernels given in eAMMRES kbBs.  When we match a kbB, we
 * compare the perf of this kernel at its optimal nbB/mbB wt that of the
 * specialized kernel, and choose the best.
 *
 * OUTPUT: This routine outputs two files:
 * (1) AMMRANKK: best ku=1 kern wt best MB/NB, K=K
 * (2) AMMRANKKT: timing of this kern wt M=mbB, N=nbB, all K between 1 & maxNB
 */
{
}

double CacheRatio_all3(size_t CS, size_t mb, size_t nb, size_t kb, 
                       size_t mu, size_t nu)
{ /* RETURNS: ratio of utilized cache to keep all 3 mm ops in CS */
   double dret = 1.0*kb*(mb+nb)+mb*nb;
   return(dret/CS);
}

double CacheRatio_one(size_t CS, size_t mb, size_t nb, size_t kb, 
                      size_t mu, size_t nu)
{ /* RETURNS: ratio of util cache for B + working set of A/C */
   double dret = kb*nb + 2.0*(mu*kb + mu*nu);
   return(dret/CS);
}

double CacheRatio_ws(size_t CS, size_t mb, size_t nb, size_t kb, 
                     size_t mu, size_t nu)
{ /* RETURNS: ratio of working set of all matmul ops to CS */
   double dret = 2.0*(mu*nu + nu*kb) + mu*kb;
   return(dret/CS);
}

typedef void (*BudgetFunc_t)(double, size_t, size_t, size_t, size_t, 
                             size_t*, size_t*, size_t*);

#define MAXNB 512
void GetBlkFromBudget_all3(double thresh, size_t CS, 
                           size_t mu, size_t nu, size_t ku,
                           size_t *MB, size_t *NB, size_t *KB)
{
   size_t mb=mu, nb=nu, kb=ku;
   int MGROW, NGROW, KGROW;
   do
   {
      size_t mn=mb+mu, nn=nb+nu, kn=kb+ku;
      MGROW = mn < MAXNB && (CacheRatio_all3(CS, mn, nb, kb, mu, nu) <= thresh);
      NGROW = nn < MAXNB && (CacheRatio_all3(CS, mb, nn, kb, mu, nu) <= thresh);
      KGROW = kn < MAXNB && (CacheRatio_all3(CS, mb, nb, kn, mu, nu) <= thresh);
      if (KGROW && ((!MGROW && !NGROW) || (kn <= nn && kn <= mn)))
         kb = kn;
      else if (MGROW && (!NGROW || mb < nb))
         mb = mn;
      else if (NGROW)
         nb = nn;
   }
   while (MGROW | NGROW | KGROW);
   *MB = mb;
   *NB = nb;
   *KB = kb;
}

void GetBlkFromBudget_one(double thresh, size_t CS, 
                           size_t mu, size_t nu, size_t ku,
                           size_t *MB, size_t *NB, size_t *KB)
{
   size_t mb=mu, nb=nu, kb=ku;
   int NGROW, KGROW;
   do
   {
      size_t nn=nb+nu, mn=(nn/mu)*mu, mn1 = ((nn+mu-1)/mu)*mu, kn=kb+ku;
      if (mn1 - nn <= nn - mn || !mn)
         mn = mn1;
      NGROW = nn < MAXNB && (CacheRatio_one(CS, mn, nn, kb, mu, nu) <= thresh);
      KGROW = kn < MAXNB && (CacheRatio_one(CS, mb, nb, kn, mu, nu) <= thresh);
      if (NGROW && ((nn < kn && mn < kn) || !KGROW))
      {
         nb = nn;
         mb = mn;
      }
      else if (KGROW)
         kb = kn;
   }
   while (NGROW | KGROW);
   *MB = mb;
   *NB = nb;
   *KB = kb;
}

void GetBlkFromBudget_ws(double thresh, size_t CS, 
                          size_t mu, size_t nu, size_t ku,
                          size_t *MB, size_t *NB, size_t *KB)
{
   size_t mb=mu, nb=nu, kb=ku;
   int KGROW;
   do
   {
      size_t kn=kb+ku, mn=(kn > mu)?(kn/mu)*mu:mu, nn=(kn>nu)?(kn/nu)*nu:nu;
      KGROW = kn < MAXNB && (CacheRatio_ws(CS, mn, nn, kn, mu, nu) <= thresh);
      if (KGROW)
      {
         mb = mn;
         nb = mn;
         kb = kn;
      }
   }
   while (KGROW);
   *MB = mb;
   *NB = nb;
   *KB = kb;
}

ATL_mmnode_t *FindBestCacheBudgetCase
(
   int verb,
   char pre, 
   BudgetFunc_t GetBlocking,     /* func ptr to budget function */
   double thresh,                /* max ratio of cache to fill */
   size_t CS,                    /* size of cache we are optimizing for */
   int imf,                      /* entry in mflop[] to use */
   ATL_mmnode_t *mmb             /* list of cases to try */
)
/*
 * RETURNS: clone of best-peforming kernel in mmb for kb=kb, mb & nb 
 *          near-square and within budget
 */
{
   ATL_mmnode_t *mmB=NULL, *mp, *p;
   double mf, mfB=0.0;

   printf("Finding best case for cache budget case=%d, CS=%.0f elts\n",
          imf, CS*thresh);
   for (mp=mmb; mp; mp = mp->next)
   {
      size_t mb, nb, kb;
      GetBlocking(thresh, CS, mp->mu, mp->nu, mp->ku, &mb, &nb, &kb);
      p = CloneMMNode(mp);  /* can't use mp, since may switch KRUNTIME */
      mf = TimeMMKernel_KB(verb, 0, p, pre, mb, nb, kb, 1, 0, -1);
      printf("   ID=%d, mb=%d, nb=%d, kb=%d, RTK=%d, MFLOP=%.2f\n", p->ID,
             (int)mb, (int)nb, (int)kb, FLAG_IS_SET(p->flag, MMF_KRUNTIME), mf);
      if (mf > mfB)
      {
         if (mmB)
            KillMMNode(mmB);
         p->mbB = mb;
         p->nbB = nb;
         p->kbB = kb;
         mmB = p;
         mfB = mmB->mflop[imf] = mf;
      }
      else
         KillMMNode(p);
   }
   printf("BEST CASE %s: mb=%d, nb=%d, kb=%d, RTK=%d, MFLOP=%.2f\n\n",
          mmB->rout ? mmB->rout : "GENNED",
          mmB->mbB, mmB->nbB, mmB->kbB, FLAG_IS_SET(mmB->flag, MMF_KRUNTIME), 
          mmB->mflop[imf]);
   mmB->next = NULL;
   return(mmB);
}

ATL_mmnode_t *FindBestCacheBudgetCases
(
   int verb,
   char pre, 
   size_t CS,                    /* size of cache we are optimizing for */
   ATL_mmnode_t *mmb             /* list of cases to try */
)
/*
 * This case attempts to find the best kernel for 3 cases of interest:
 * (1) All 3 matrices fit in CS -- this case is designed for when we wish
 *     to reuse at least one of the matrices *across* mmkern calls.  It is
 *     particularly good for complex arithmetic, or when CS is large enough
 *     that A&B are reused so much internally to a mmkern call that it makes
 *     sense to retain C in cache for the next mmkern call in K-loop.
 * (2) All of B fits in CS, and so does the working set of A&C.  This one
 *     reuses all internal ops from L1, but won't allow any full op reuse
 *     across multiple GEMM calls.  Usually best for small-to-medium cache
 *     sizes.
 * (3) All of working set of A/B/C fit in cache.  This case provides maximal
 *     NB, where only the mu*KB panel of A is reused from the L1 internally
 *     to the algorthm.  It is essentially an L2-blocked algorithm internally,
 *     but can be useful on those archs where the best sustained bandwidth
 *     comes from one L1 load (A) and 1 L2 load (B).
 */
{
   ATL_mmnode_t *mm3, *mm1, *mmw;
   mm3 = FindBestCacheBudgetCase(verb, pre, GetBlkFromBudget_all3, 1.0, 
                                 CS, 1, mmb);
   mm1 = FindBestCacheBudgetCase(verb, pre, GetBlkFromBudget_one, 1.0, 
                                 CS, 2, mmb);
   mmw = FindBestCacheBudgetCase(verb, pre, GetBlkFromBudget_ws, .90, 
                                 CS, 3, mmb);
   mm3->next = mm1;
   mm1->next = mmw;
   mmw->next = NULL;

   printf("3CASES: ID=%d/%d/%d, mb=%d/%d/%d, nb=%d/%d/%d, kb=%d/%d/%d\n",
          mm3->ID, mm1->ID, mmw->ID, mm3->mbB, mm1->mbB, mmw->mbB, 
          mm3->nbB, mm1->nbB, mmw->nbB, mm3->kbB, mm1->kbB, mmw->kbB);
   printf("        RTK=%d/%d/%d, MFLOP=%.2f/%2f/%2f\n\n",
          FLAG_IS_SET(mm3->flag, MMF_KRUNTIME),
          FLAG_IS_SET(mm1->flag, MMF_KRUNTIME),
          FLAG_IS_SET(mmw->flag, MMF_KRUNTIME),
          mm3->mflop[1], mm1->mflop[2], mmw->mflop[3]);

   return(mm3);
}

ATL_mmnode_t *TimeKBRegion
(
   int verb,
   char pre, 
   ATL_mmnode_t *mmk,            /* kernel to time throughout region */
   int kbmin,                    /* start of region */
   int kbend,                    /* largest kb in region */
   int kincD                     /* default stride between kernel timings */
)
/*
 * Returns list of timings of kernel mmk using near-square cases with KB
 * varying between kbmin - kbend.  All cases that are legal and incremented
 * by kinc are tried, as are all perfectly square cases
 */
{
   ATL_mmnode_t *mmb=NULL, *mp, *mpB=NULL;
   const int ku = mmk->ku, mu=mmk->mu, nu=mmk->nu;
   int kstart, kinc, kend, k, ksq, ksqinc;
   double mf, mfB=0.0;
/*
 * Get starting and ending point that is legal for this kernel.
 */
   kstart = Mmax(mmk->kbmin, kbmin);
   kstart = ((kstart+ku-1)/ku)*ku;
   kend = ((kbend+ku-1)/ku)*ku;
   if (mmk->kbmax)
      kend = Mmin(kend, mmk->kbmax);
   k = kstart;
/*
 * square inc always lcm(mu,nu,ku).  Normal increment is always at least
 * as big as the default stride, but must be a multiple of the kernel's ku
 */
   ksqinc = Mylcm(mu, nu);
   ksqinc = Mylcm(ksqinc, ku);
   for (kinc=ku; kinc < kincD; kinc += ku);
   if (kstart <= kend)
   {
      int kb = k;
      printf("TIMING %s mu=%d, mu=%d, For KB=[%d,%d]:\n", 
             mmk->rout ? mmk->rout : "Genkern", mu, nu, kstart, kend);
      ksq = ((kstart+ksqinc-1)/ksqinc)*ksqinc;
      do
      {
         ATL_mmnode_t *p;
         const int mb=((kb+mu-1)/mu)*mu, nb=((kb+nu-1)/nu)*nu;

         p = CloneMMNode(mmk);
         p->mbB = mb; p->nbB = nb; p->kbB = kb;
         mf = TimeMMKernel_KB(verb, 0, p, pre, mb, nb, kb, 1, 0, -1);
         printf("   mb=%d, nb=%d, kb=%d, KRUN=%d, MFLOP=%.2f\n",
                mb, nb, kb, FLAG_IS_SET(p->flag, MMF_KRUNTIME), mf);
         p->mflop[0] = mf;
         if (mf > mfB)
         {
            mfB = mf;
            mpB = p;
         }
         if (mmb)
         {
            mp->next = p;
            mp = p;
         }
         else
            mmb = mp = p;
         if (kb == ksq)
            ksq += ksqinc;
         if (kb == k)
            k += kinc;
         kb = Mmin(k,ksq);
      }
      while(kb <= kend);
      printf("DONE, best case %s mb=%d, nb=%d, kb=%d, MFLOP=%.2f\n\n", 
             mmk->rout ? mmk->rout : "Genkern",
             mpB->mbB, mpB->nbB, mpB->kbB, mfB);
   }
   else
   {
      printf("KERNEL %s mu=%d, mu=%d, has no legal cases in KB=[%d,%d]!\n\n", 
             mmk->rout ? mmk->rout : "Genkern", mu, nu, kstart, kend);
   }
   return(mmb);
}

ATL_mmnode_t *TimeAllKBRegions
(
   int verb,
   char pre, 
   ATL_mmnode_t *mmk,            /* kernel to time throughout regions */
   int kb1,                      /* rough kb ending region 1 */
   int kb2,                      /* rough kb ending region 2 */
   int kb3                       /* maxKB to ever try */
)
/*
 * Times mmk for KBs in the three regions, returns list
 */
{
   const int ku = mmk->ku;
   ATL_mmnode_t *mmb, *mp;

   mmb = TimeKBRegion(verb, pre, mmk, 24, kb3, 4);
   return(mmb);
}

ATL_mmnode_t *FindCacheBudgetCasesByKB
(
   int verb,
   char pre, 
   size_t CS,                    /* size of cache we are optimizing for */
   ATL_mmnode_t *mmb             /* list of cases to try */
)
/* 
 * This routine is responsible for:
 * (1) Find the best performing kernels out of mmb for our 3 cache budget
 *     cases
 * (2) Free mmb
 * (3) For each unique kernel, find perf of kernel for all supported KBs 
 *     in the budgetary regions
 * (4) Merge these lists, and winnow underperforming cases
 * (5) RETURN: queue of all supported KBs
 */
{
   ATL_mmnode_t *mm3b, *mp;
   const char upr = (pre == 'z' || pre == 'd') ? 'd' : 's';
/*
 * We want number of real elts, not # of cplx elts!
 */
   if (pre == 'c' || pre == 'z')
      CS += CS;
/*
 * See if we just need to rerun cases
 */
   mm3b = ReadMMFileWithPath(pre, "res", "bAMMRES.sum");
   if (mm3b)
   {
      int i=0;
      printf("READING IN LARGE KERNEL CASES FROM res/<pre>bAMMRES:\n");
      FillInGenStrings(pre, mm3b);
      for (mp=mm3b; mp; mp = mp->next)
      {
         if (mp->mflop[0] <= 0.0)
            mp->mflop[0] = TimeMMKernel(verb, 0, mp, pre, mp->mbB, mp->nbB, 
                                        mp->kbB, 0, 0, 0, 1, 0, -1);
         printf("   ID=%d, %s: MB=%d, NB=%d, KB=%d, KRUN=%d, MFLOP=%.2f\n",
                mp->ID, mp->rout ? mp->rout : "Gennedkern",
                mp->mbB, mp->nbB, mp->kbB, FLAG_IS_SET(mp->flag, MMF_KRUNTIME),
                mp->mflop[0]);
         i++;
      }
      printf("DONE %d CASES.\n\n", i);
      return(mm3b);
   }
/*
 * Find best performing kernels for each of our 3 cache budgets
 */
   mm3b = FindBestCacheBudgetCases(verb, pre, CS, mmb);
   KillAllMMNodes(mmb);
/*
 * Get list of performance of all-3 in-cache kernel in all 3 cache regions
 */
   mmb = TimeAllKBRegions(verb, pre, mm3b, mm3b->kbB, mm3b->next->kbB,
                          mm3b->next->next->kbB);
   for (mp=mm3b->next; mp; mp = mp->next)
   {
      if (KernelIsUnique(mm3b, mp))
      {
         ATL_mmnode_t *p, *p2;
         p = TimeAllKBRegions(verb, pre, mp, mm3b->kbB, mm3b->next->kbB,
                              mm3b->next->next->kbB);
         p2 = MergeCases(0, mmb, p);
         KillAllMMNodes(p);
         KillAllMMNodes(mmb);
         mmb = p2;
      }
   }
   KillAllMMNodes(mm3b);
/*
 * Now, get rid of any blocking factor that is slower than the preceeding one
 */
   mmb = WinnowCases(0, mmb);
   WriteMMFileWithPath(pre, "res", "bAMMRES.sum", mmb);
   return(mmb);
}

ATL_mmnode_t *DecentGenCase(int verb, char pre, int nreg)
{
/*
 * Find out what vectorization, if any, to use in generating kernels
 */
   int mu, nu;
   SetGenVec(verb, pre);
/* 
 * 120 = LCM(2,3,4,5,6,8), and large enough to stress mu/nu
 */
   return(FindDefMUNU(verb, pre, nreg, 0, 120, 1, &mu, &nu));
@skip   return(ReadMMFileWithPath(pre, "res", "gAMMMUNU.sum"));
@skip   return(GetNewGenNode(pre, 0, 0, mu, nu, 1, 0));
}

/*
 * This routine finds kernels to use in low-rank-K update. For 3 <= K <= 15,
 * it tries all kernels and chooses the best performing; In this search
 * we consider only compile-time K kernels, since runtime kernels will be
 * selected by general (K>15) search.
 * (K=1 and K=2 are handled by GER and GER2).
 * We consider only user-generated kernels; for any problem sizes that are
 * not supported, we will use the normal K or K-clean routines.  This list
 * is just to allow for hand-tuning small-K special cases.
 * This routine produces output file <pre>AMMLOWK.sum
 */
ATL_mmnode_t *GetLowRankKKernels
(
   int verb,            /* verbosity */
   char pre,            /* s,d */
   int MB,              /* default mb to time with */
   int NB,              /* default nb to time with */
   ATL_mmnode_t *inb    /* all working ukerns */
)
{
   int k, ik;
   ATL_mmnode_t *rkKb=NULL, *mp;
/*
 * Get rid of all K-runtime kernels from consideration
 */
   while (inb && FLAG_IS_SET(inb->flag, MMF_KRUNTIME))
      inb = KillMMNode(inb);
   if (inb)
   {
      ATL_mmnode_t *prev=inb;
      mp = inb->next;
      while (mp)
      {
         if (FLAG_IS_SET(mp->flag, MMF_KRUNTIME))
         {
            mp = KillMMNode(mp);
            prev->next = mp;
         }
         else
         {
            prev = mp;
            mp = mp->next;
         }
      }
   }
   else
      return(NULL);
   for (ik=0; ik < 2; ik++)
   {
      int kbeg, kend, kinc;
      if (!ik)
      {
         kbeg = 96;
         kend = 16;
         kinc = 16;
      }
      else
      {
         kbeg = 15;
         kend = 3;
         kinc = 1;
      }
      for (k=kbeg; k >= kend; k -= kinc)
      {
         printf("FINDING BEST USER-PROVIDED KERNEL FOR K=%d:\n", k);
         ATL_mmnode_t *best=NULL;
         for (mp=inb; mp; mp = mp->next)
         {
            const int mu = mp->mu, nu = mp->nu, ku = mp->ku;
            const int mb = (MB/mu)*mu, nb = (NB/nu)*nu;
            const int KK = (mp->kmaj < 2) ? k : ((k+ku-1)/ku)*ku;
            double mf;
   
            assert(mb && nb);
            if (FLAG_IS_SET(mp->flag, MMF_KRUNTIME) || KK%ku)
            {
               printf("   skipping %d. %s, KRUN=%d, ku=%d\n", mp->ID, mp->rout,
                      FLAG_IS_SET(mp->flag, MMF_KRUNTIME), ku);
               continue;
            }
            if ((mp->kbmin && k < mp->kbmin) || (mp->kbmax && KK > mp->kbmax))
            {
               printf("   skipping %d. %s, kbmin,max=%d,%d, K=%d\n", 
                      mp->ID, mp->rout, mp->kbmin, mp->kbmax, KK);
               continue;
            }
            mf = TimeMMKernel(verb, 0, mp, pre, mb, nb, KK, 0, 0, 0, 0, 0, -1);
            if (KK != k)
               mf = (mf*k) / (double)KK;
            printf("   %d. %s: mb=%d, nb=%d, MFLOP=%.2f\n", mp->ID, mp->rout,
                   mb, nb, mf);
            if (!best)
            {
               best = mp;
               mp->mflop[0] = mf;
               mp->mbB = mb;
               mp->nbB = nb;
               mp->kbB = k;
            }
            else if (best->mflop[0] < mf)
            {
               best = mp;
               mp->mflop[0] = mf;
               mp->mbB = mb;
               mp->nbB = nb;
               mp->kbB = k;
            }
         }
         if (best)
         {
            best = CloneMMNode(best);
            best->next = rkKb;
            rkKb = best;
            printf("BEST FIXED-%d KERNEL: %d. %s MFLOP=%.2f\n\n", 
                   k, best->ID, best->rout, best->mflop[0]);
         }
         else
            printf("NO SPECIAL CASE for K=%d\n\n", k);
      }
   }
   KillAllMMNodes(inb);
   return(rkKb);
}

/*
 * Finds list of best run-time kernel, ranked by KU.  Higher KUs are not
 * retained unless they beat any lower-KU kernel that divides that KU evenly
 */
ATL_mmnode_t *GetRuntimeKKernels
(
   int verb,            /* verbosity */
   char pre,            /* s,d */
   int MB,              /* default mb to time with */
   int NB,              /* default nb to time with */
   ATL_mmnode_t *inb    /* all working ukerns */
)
{
   ATL_mmnode_t *mp;
   int KU;
/*
 * Get rid of all non-K-runtime kernels from consideration
 */
   while (inb && !FLAG_IS_SET(inb->flag, MMF_KRUNTIME))
      inb = KillMMNode(inb);
/* 
 * Got rid of any at base, now get rid of non-K-runtime from internal nodes
 */
   if (inb)
   {
      ATL_mmnode_t *prev=inb;
      mp = inb->next;
      while (mp)
      {
         if (!FLAG_IS_SET(mp->flag, MMF_KRUNTIME))
         {
            mp = KillMMNode(mp);
            prev->next = mp;
         }
         else
         {
            prev = mp;
            mp = mp->next;
         }
      }
   }
   else
      return(NULL);
   KU = inb->ku;
   for (mp=inb->next; mp; mp = mp->next)
      KU = Mylcm(KU, mp->ku);
   if (KU > 32)
      KU = 32;
   else
      KU = ((16+KU-1)/KU)*KU;
   printf("TRYING ALL RUNTIMEK KERNS WITH MB=%d, NB=%d, KB=%d:\n", MB, NB, KU);
   for (mp=inb; mp; mp = mp->next)
   {
      int mu=mp->mu, nu=mp->nu, ku=mp->ku;
      int mb = (MB/mu)*mu, nb = (NB/nu)*nu, kb = (KU/ku)*ku;
      double mf;
      assert(mb && nb && kb);
      mf = TimeMMKernel(verb, 0, mp, pre, mb, nb, kb, 0, 0, 0, 0, 0, -1);
      printf("   %d. %s: mb=%d, nb=%d, MFLOP=%.2f\n", mp->ID, mp->rout,
             mb, nb, mf);
      mp->mflop[0] = mf;
      mp->mbB = mb;
      mp->nbB = nb;
      mp->kbB = kb;
   }
   printf("\n");
   inb = ATL_SortMMNodesByMflop(0, inb);
   if (inb->ku == 1)
   {
      KillAllMMNodes(inb->next);
      inb->next = NULL;
   }   
   else
   {
      ATL_mmnode_t *p;
/*
 *    Go thru sorted list, and kill all slower nodes that don't add new K
 */
      for (p=inb; p; p = p->next)
      {
         ATL_mmnode_t *prev=p;
         mp = p->next;
         while (mp)
         {
            if (mp->ku % p->ku == 0)
            {
               mp = KillMMNode(mp);
               prev->next = mp;
            }
            else
            {
               prev = mp;
               mp = mp->next;
            }
         }
      }
   }
   if (!inb)
      printf("NO RETAINED RUNTIME KERNELS.\n\n");
   else
   {
      printf("RETAINED RUNTIME KERNELS:\n");
      for (mp=inb; mp; mp = mp->next)
         printf("   %d. %s: ku=%d, MFLOP=%.2f\n", mp->ID, mp->rout, mp->ku,
                mp->mflop[0]);
      printf("DONE.\n");
   }
   return(inb);
}
/*
 * RETURNS: 1 if mmc is slower than any kernel in mmb
 */
int IsSlowerThanList
(
   int verb,            /* verbosity */
   char pre,            /* s,d */
   int MB,
   int NB,              /* default mb/nb to time with */
   ATL_mmnode_t *mmc,  /* candidate mmkern */
   ATL_mmnode_t *mmb   /* kernels to time candidate against */
)
{
   ATL_mmnode_t *mp;
   double mfc, mf;
   int mu, nu, ku;
   int mb, nb, kb, KB;

   if (!mmb)
      return(0);
   kb = mmc->kbB;
   mu = mmc->mu;
   nu = mmc->nu;
   mb = (MB/mu)*mu;
   nb = (NB/nu)*nu;
   assert(mb && nb && kb);
   KB = (mmc->kmaj < 2) ? kb : ((kb+mmc->ku-1)/mmc->ku)*mmc->ku;
   mfc = TimeMMKernel(verb, 0, mmc, pre, mb, nb, KB, 0, 0, 0, 0, 0, -1);
   mfc = (kb*mfc)/(double)KB;
   mmc->mflop[1] = mfc;
   kb = mmc->kbB;
   for (mp=mmb; mp; mp = mp->next)
   {
      ku = mp->ku;
      if (mp->kbmin && kb < mp->kbmin)
         continue;
      if (mp->kbmax && kb > mp->kbmax)
         continue;
      if (kb%ku == 0 || mp->kmaj > 1)
      {
         int KK = (mp->kmaj > 1) ? ((kb+ku-1)/ku)*ku : kb;
         mu = mp->mu;
         nu = mp->nu;
         mb = (MB/mu)*mu;
         nb = (NB/nu)*nu;
         assert(mb && nb);
         mf = TimeMMKernel(verb, 0, mp, pre, mb, nb, KK, 0, 0, 0, 0, 0, -1);
         mp->mflop[1] = (kb*mfc)/(double)KK;
         if (mf > mfc)
         {
@skip            printf("      %d. %s (%.2f) outcompeted by %d. %s (%.2f)\n",
@skip                   mmc->ID, mmc->rout, mfc, mp->ID, mp->rout, mf);
            return(1);
         }
      }
   }
   return(0);
}

/*
 * Finds best-performing square cases in list of pre-existing kernels, mmb.
 * Does not modify original mmb list, and will return only kernels that are
 * faster than smaller square cases.
 * RETURNS: new list of all square cases that got best performance from
 *          original mmb.
 */
@ROUT uammsearch
ATL_mmnode_t *FindBestSquareCases(char pre, int verb, ATL_mmnode_t *mmb)
{
   ATL_mmnode_t *mmp, *mmSQ=NULL, *prev=NULL;
   int maxNB=0, maxU=0, i;

   for (mmp=mmb; mmp; mmp = mmp->next)
   {
      if (mmp->mu > maxU)
         maxU = mmp->mu;
      if (mmp->nu > maxU)
         maxU = mmp->nu;
      if (mmp->nbB > maxNB)
         maxNB = mmp->nbB;
      if (mmp->mbB > maxNB)
         maxNB = mmp->mbB;
      if (mmp->kbB > maxNB)
         maxNB = mmp->kbB;
   }
   maxNB = ((maxNB+maxU-1) / maxU)*maxU;

   for (i=4; i <= maxNB; i++)
   {
      mmp = BestForThisNB(verb, pre, mmb, i, i-1, i+1, 1);
      if (mmSQ)
      {
         if (prev->mflop[0] >= mmp->mflop[0])
            KillMMNode(mmp);
         else
         {
            prev->next = mmp;
            prev = mmp;
         }
      }
      else
         mmSQ = prev = mmp;
   }
   return(mmSQ);
}
@ROUT ammsearch
ATL_mmnode_t *FindBestSquareCases(char pre, int verb, int nregs, int maxNB, 
                                  ATL_mmnode_t *mmb)
{
   ATL_mmnode_t *mmp, *mmSQ=NULL, *prev=NULL, *gmm;
   int maxU=0, i;

   for (mmp=mmb; mmp; mmp = mmp->next)
   {
      if (mmp->mu > maxU)
         maxU = mmp->mu;
      if (mmp->nu > maxU)
         maxU = mmp->nu;
@beginskip
      if (mmp->nbB > maxNB)
         maxNB = mmp->nbB;
      if (mmp->mbB > maxNB)
         maxNB = mmp->mbB;
      if (mmp->kbB > maxNB)
         maxNB = mmp->kbB;
@endskip
   }
   maxNB = ((maxNB+maxU-1) / maxU)*maxU;
   gmm = DecentGenCase(verb, pre, nregs);
   gmm->next = mmb;

   for (i=4; i <= maxNB; i++)
   {
      mmp = BestForThisNB(verb, pre, gmm, i, i-1, i+1, 1);
      if (mmSQ)
      {
         if (prev->mflop[0] >= mmp->mflop[0])
            KillMMNode(mmp);
         else
         {
            prev->next = mmp;
            prev = mmp;
         }
      }
      else
         mmSQ = prev = mmp;
   }
   return(mmSQ);
}
@ROUT ammsearch uammsearch
@ROUT ammsearch
/*
 * Sets all MV[A,B,C] bits in mmb to those provided in low 3 bits of bits
 */
void ResetMoveBitsInQ(ATL_mmnode_t *mmb, int bits)
{
   while (mmb)
   {
      ATL_MMF_MVPUT(mmb->flag, bits);
      mmb = mmb->next;
   }
}

ATL_mmnode_t *MergeRankKKernels
(
   int verb,            /* verbosity */
   char pre,            /* s,d */
   int MB,              /* default mb to time with */
   int NB,              /* default nb to time with */
   int maxKB,           /* largest KB to produce */
   ATL_mmnode_t *fixb,  /* rank-K fixed-K kerenls */
   ATL_mmnode_t *runb,  /* rank-K, runtime-K kernels */
   ATL_mmnode_t *sqrb   /* optimized near-square kernels */
)
{
   ATL_mmnode_t *rkb, *rkp;
   int k;
   rkp = rkb = GetMMNode();
   printf("CHOOSING BEST KERNEL FOR EACH RANK-K (3 <= K <= %d):\n", maxKB);
   for (k=3; k <= maxKB; k++)
   {
      ATL_mmnode_t *best=NULL, *p;
      double mfB=0.0, mf;
/*
 *    fixb & sqrb are in K-order, so we pop them off stack until we get to
 *    one big enough to solve the problem.  We also ignore all KRUNTIME kernels
 *    in sqrb, since they should appear in runb if they are competitive
 */
      while (fixb)
      {
         if (fixb->kbB < k || (fixb->kbmin && fixb->kbmin > k) ||
             (fixb->kbmax && fixb->kbmax < k))
            fixb = KillMMNode(fixb);
         else
            break;
      }
      while (sqrb)
      {
         if (sqrb->kbB < k || FLAG_IS_SET(sqrb->flag, MMF_KRUNTIME)
             || (sqrb->kbmin && sqrb->kbmin > k) || 
                (sqrb->kbmax && sqrb->kbmax < k))
            sqrb = KillMMNode(sqrb);
         else break;
      }
      if (fixb)
      {
         if (fixb->kbB == k)
         {
            int mu = fixb->mu, nu = fixb->nu, ku = fixb->ku;
            int mb = (NB/mu)*mu, nb = (NB/nu)*nu;
            int kb = (fixb->kmaj < 2) ? k : ((k+ku-1)/ku)*ku;
            best = fixb;
            fixb = fixb->next;
            mfB = TimeMMKernel(verb, 0, best, pre, mb, nb, kb, 0, 0, 0, 0,0,-1);
            mfB = (mfB*k)/(double)kb;
         }
      }
      if (sqrb)
      {
         if (sqrb->kbB == k)
         {
            int mu = sqrb->mu, nu = sqrb->nu, ku = sqrb->ku;
            int mb = (MB/mu)*mu, nb = (NB/nu)*nu;
            int kb = (sqrb->kmaj < 2) ? k : ((k+ku-1)/ku)*ku;
            mf = TimeMMKernel(verb, 0, sqrb, pre, mb, nb, kb, 0, 0, 0, 0, 0,-1);
            mf = (mf*k)/(double)kb;
            if (mf > mfB)
            {
               mfB = mf;
               if (best)
                  KillMMNode(best);
               best = sqrb;
               sqrb = sqrb->next;
            }
            else
               sqrb = KillMMNode(sqrb);
         }
      }
      for (p=runb; p; p = p->next)
         if ((k % p->ku == 0 || p->kmaj > 1) && 
             k > p->kbmax && (!p->kbmin || p->kbmin <= k))
            break;
      if (p)
      {
         int mu = p->mu, nu = p->nu, ku = p->ku;
         int mb = (NB/mu)*mu, nb = (NB/nu)*nu;
         int kb = (p->kmaj < 2) ? k : ((k+ku-1)/ku)*ku;
         if (p->kbmax && p->kbmax < kb)
            mf = -1.0;
         else
            mf = TimeMMKernel(verb, 0, p, pre, mb, nb, kb, 0, 0, 0, 0, 0, -1);
         mf = (mf*k)/(double)kb;
         if (mf > mfB)
         {
            mfB = mf;
            if (best)
               KillMMNode(best);
            best = CloneMMNode(p);
         }
      }
      assert(best);
      printf("   Best kernel K=%d: %d. %s (%.2f)\n",k,best->ID,best->rout,mfB);
      best->kbB = k;
      rkp->next = best;
      rkp = best;
   }
   if (sqrb)
      KillAllMMNodes(sqrb);
   if (fixb)
      KillAllMMNodes(fixb);
   rkp->next = NULL;
   printf("DONE.\n\n");
   return(KillMMNode(rkb));
}

/*
 * low, mmb & gmm are freed.
 */
ATL_mmnode_t *GetRankKKernels
(
   int verb,            /* verbosity */
   char pre,            /* s,d */
   int NB,              /* default mb/nb to time with */
   ATL_mmnode_t *gmm,   /* generated matmul kernel */
   ATL_mmnode_t *low,   /* all working ukerns */
   ATL_mmnode_t *mmb    /* cases already chosen for square GEMM */
)
{
   ATL_mmnode_t *run, *rkb;
   int maxKB=128;
   int mb, nb;
   rkb = ReadMMFileWithPath(pre, "res", "rkAMMRES.sum");
   if (rkb)
   {
      ATL_mmnode_t *mp;
      printf("Reading in RANK-K cases:\n");
      FillInGenStrings(pre, rkb);
      for (mp=rkb; mp; mp = mp->next)
      {
         const int mu = (mp->vlen) ? mp->mu / mp->vlen : mp->mu;
         int kb = mp->kbB, mb = mp->mbB, nb=mp->nbB;
         if (mp->mflop[0] < 0.0)
            mp->mflop[0] = TimeMMKernel(verb, 1, mp, pre, mb, nb, kb,
                                         kb, kb, mb, 1, 0, -1);
         printf("  ID=%d, %s: (M,N,K)=(%d,%d,%d) mf=%.2f\n", mp->ID, 
                mp->rout ? mp->rout:"Gennedkern", mb, nb, kb, mp->mflop[0]);
      }
      WriteMMFileWithPath(pre, "res", "rkAMMRES.sum", rkb);
      KillAllMMNodes(low);
      KillAllMMNodes(gmm);
      KillAllMMNodes(mmb);
      return(rkb);
   }
   ResetMoveBitsInQ(mmb, 5);
   ResetMoveBitsInQ(gmm, 5);
   ResetMoveBitsInQ(low, 5);
@beginskip
   if (mmb)
   {
      mb = mmb->mbB;
      nb = mmb->nbB;
      maxKB = mmb->kbB;
      for (run=mmb; run; run = run->next)
      {
         if (maxKB < run->kbB)
         {
            maxKB = run->kbB;
            mb = run->mbB;
            nb = run->nbB;
         }
      }
   }
   else
      mb = nb = NB;
@endskip
   if (mmb)
   {
      maxKB = mmb->kbB;
      for (run=mmb->next; run; run = run->next)
         if (maxKB < run->kbB)
            maxKB = run->kbB;
   }
   mb = nb = NB;
   run = CloneMMQueue(low);
   if (FLAG_IS_SET(gmm->flag, MMF_KRUNTIME))
   {
      if (gmm->ku != 1)
      {
         ATL_mmnode_t *p;
         int gmu = (gmm->kmaj > 1) ? gmm->mu : gmm->mu / VLEN[VECi];
         assert(gmu);
         p = GetNewGenNode(pre, NB, gmm->lat, gmu, gmm->nu, 1, 0);
         p->next = run;
         run = p;
      }
      gmm->next = run;
      run = gmm;
   }
   else
   {
      ATL_mmnode_t *p;
      int gmu = (gmm->kmaj > 1) ? gmm->mu : gmm->mu / VLEN[VECi];
      assert(gmu);
      p = GetNewGenNode(pre, NB, gmm->lat, gmu, gmm->nu, 1, 0);
      p->flag |= (1<<MMF_KRUNTIME);
      p->next = run;
      run = p;
      gmm->next = low;
      low = gmm;
   }
   low = GetLowRankKKernels(verb, pre, mb, nb, low);
   run = GetRuntimeKKernels(verb, pre, mb, nb, run);
/*
 * Delete any fixed kernels that are slower than the runtime-K kernels
 */
   printf("DELETING FIXED KERNELS OUTCOMPETED BY RUNTIME KERNELS:\n");
   while (low)
   {
      if (!IsSlowerThanList(verb, pre, mb, nb, low, run));
         break;
      printf("   Deleting: %d. %s for K=%d\n", low->ID, low->rout, low->kbB);
      low = KillMMNode(low);
   }
   if (low)
   {
      ATL_mmnode_t *mp=low->next, *prev=low;
      while (mp)
      {
         if (IsSlowerThanList(verb, pre, mb, nb, mp, run))
         {
            printf("   Deleting: %d. %s for K=%d\n", mp->ID, mp->rout, mp->kbB);
            mp = KillMMNode(mp);
            prev->next = mp;
         }
         else
         {
            prev = mp;
            mp = mp->next;
         }
      }
   }
   printf("DONE.\n\n");

   rkb = MergeRankKKernels(verb, pre, mb, nb, maxKB, low, run, mmb);
   printf("RANK-K KERNELS:\n");
   PrintMMNodes(stdout, rkb);
   printf("\n");
   KillAllMMNodes(run);
   WriteMMFileWithPath(pre, "res", "rkAMMRES.sum", rkb);
   return(rkb);
}

/*
 * Complex types use the previously selected real kernels in order to
 * reduce library size (means we only have 2 precision GEMMS for 4
 * types/precisions).  The only thing that is different is we may
 * reduce max NB in order to keep complex ops in cache.
 * May want to write this as part of real tuning!
 */
int DoComplex(char pre, int verb)
{
   ATL_mmnode_t *mmb;
   char upr = (pre == 'z') ? 'd' : 's';
   exit(-1);
   mmb = ReadMMFileWithPath(pre, "res", "geAMMRES.sum");
   if (!mmb)
   {
      mmb = ReadMMFileWithPath(upr, "res", "geAMMRES.sum");
      assert(mmb);
      WriteMMFileWithPath(pre, "res", "geAMMRES.sum", mmb);
   }

}

/*
 * Creates two lists from original, which is left unchanged.
 * A list of all unique runtime kernels is RETURNED, 
 * while a list of all unique KB compile kernels is provided by CBAS
 */
ATL_mmnode_t *SplitRunCompKB(ATL_mmnode_t *orig, ATL_mmnode_t **CBAS)
{
   ATL_mmnode_t *comp=NULL, *run, *bp;
   for (bp=orig; bp; bp = bp->next)
   {
      if (FLAG_IS_SET(bp->flag, MMF_KRUNTIME))
      {
         if (!MMKernCompIsPresent(run, bp))
         {
            ATL_mmnode_t *tp;
            tp = CloneMMQueue(bp);
            tp->next = run;
            run = tp;
         }
      }
      else  /* candidate for compile-time K list */
      {
         if (!MMKernCompIsPresent(comp, bp))
         {
            ATL_mmnode_t *tp;
            tp = CloneMMQueue(bp);
            tp->next = comp;
            comp = tp;
         }
      }
   }
/*
 * Put them back in original order, they were produced backwards from orig
 */
   if (comp)
      comp = ReverseMMQ(comp);
   if (run)
      run = ReverseMMQ(run);

   *CBAS = comp;
   return(run);
}
/*
 * Deletes all kernels in mmb with kbB that are not a multiple of mu
 */
ATL_mmnode_t *KillIncompatible_MK(ATL_mmnode_t *mmb)
{
   while (mmb && (mmb->kbB/mmb->mu)*mmb->mu != mmb->kbB)
      mmb = KillMMNode(mmb);
   if (mmb)
   {
      ATL_mmnode_t *mp=mmb->next, *prev=mmb;

      while (mp)
      {
         if ((mp->kbB/mp->mu)*mp->mu != mp->kbB)
             mp = prev->next = KillMMNode(mp);
         else
         {
            prev = mp;
            mp = mp->next;
         }
      }
   }
   return(mmb);
}
/*
 * Given a list of kernels being already being used by GEMM, find best
 * performing cases with MB=KB, and NB allowed to vary.  These blockings
 * of already-existing kernels will be used to build triangular & symmetric
 * amm-based routines 
 */
ATL_mmnode_t *DoMKB_findNB(char pre, int verb, ATL_mmnode_t *mmb)
{
   ATL_mmnode_t *mmSQ, *run, *comp, *mp;
   mmSQ = ReadMMFileWithPath(pre, "res", "mkbAMMRES.sum");
   if (mmSQ)
   {
      FillInGenStrings(pre, mmSQ);
      if (mmSQ->mflop[0] < 0.0)
      {
         for (mp=mmSQ; mp; mp = mp->next)
         {
            int nb=mp->kbB;
            if (mp->mflop[0] < 0.0)
               mp->mflop[0] = TimeMMKernel(verb, 0, mp, pre, nb, nb, nb, 
                                           nb, nb, nb, 1, 0, -1);
         }
         WriteMMFileWithPath(pre, "res", "mkbAMMRES.sum", mmSQ);
      }
      return(mmSQ);
   }
   run = SplitRunCompKB(mmb, &comp);
   comp = KillIncompatible_MK(comp);
/*
 * Add all K-cleanup kernels to list of candidates
 */
   mp = ReadMMFileWithPath(pre, "res", "AMMKCLEAN.sum");
   if (mp)
   {
      ATL_mmnode_t *r, *c;
      r = SplitRunCompKB(mp, &c);
      KillAllMMNodes(mp);
      c = KillIncompatible_MK(c);
      mp = MergeCases(-1, run, r);
      KillAllMMNodes(run);
      KillAllMMNodes(r);
      run = mp;
      mp = MergeCases(-1, comp, c);
      KillAllMMNodes(comp);
      KillAllMMNodes(c);
      comp = mp;
   }
/*
 * HERE HERE HERE
 */
}
ATL_mmnode_t *DoSquare(char pre, int verb, int nregs, ATL_mmnode_t *mmb)
{
   ATL_mmnode_t *mmSQ;
   const char upr = (pre == 'z' || pre == 'd') ? 'd' : 's';

   mmSQ = TimeMMFileWithPath(pre, "res", "sqAMMRES.sum", 0, verb, 0, 1, 0, -1);
   if (mmSQ)
      return(mmSQ);
@beginskip
   mmSQ = ReadMMFileWithPath(pre, "res", "sqAMMRES.sum");
   if (mmSQ)
   {
      FillInGenStrings(pre, mmSQ);
      if (mmSQ->mflop[0] < 0.0)
      {
         ATL_mmnode_t *mp;
         for (mp=mmSQ; mp; mp = mp->next)
         {
            int nb=mp->kbB;
            if (mp->mflop[0] < 0.0)
               mp->mflop[0] = TimeMMKernel(verb, 0, mp, pre, nb, nb, nb, 
                                           nb, nb, nb, 1, 0, -1);
         }
         WriteMMFileWithPath(pre, "res", "sqAMMRES.sum", mmSQ);
      }
   }
@endskip
   else
   {
      int maxNB=0;
      ATL_mmnode_t *mp;
      for (mp=mmb; mp; mp = mp->next)
      {
          if (mp->kbB > maxNB)
             maxNB = mp->kbB;
          if (mp->mbB > maxNB)
             maxNB = mp->mbB;
          if (mp->nbB > maxNB)
             maxNB = mp->nbB;
      }
      mmb = GetWorkingUserCases(verb, upr);
@skip      mmb = GetUniqueUserKerns(mmb);
      mmSQ = FindBestSquareCases(pre, verb, nregs, maxNB, mmb);
      KillAllMMNodes(mmb);
      WriteMMFileWithPath(pre, "res", "sqAMMRES.sum", mmSQ);
   }
   return(mmSQ);
}

void DoTRSM(char pre, int verb)
/*
 * Later, may need to put trsm 'Right' timings in mflop[1]
 */
{
   ATL_mmnode_t *tb, *tp, *sb;
   if (pre == 'z' || pre == 'c')
      return;
   tb = ReadMMFileWithPath(pre, "res", "tsAMMRES.sum");
   if (tb)  /* already ran! */
   {
      for (tp=tb; tp; tp = tp->next)
      {
         if (tp->mflop[0] <= 0.0)
         {
            tp->mflop[0] = TimeTSKernel(verb, 0, pre, tp->mbB, tp->nbB, 0);
            if (verb)
               printf("   trsmKL %dx%d: %.2f\n", tp->mbB,tp->nbB, tp->mflop[0]);
         }
      }
      KillAllMMNodes(tb);
      return;
   }

   tb = ReadMMFileWithPath(pre, "res", "sqAMMRES.sum");
   printf("\nFINDING PERFORMANCE OF TRSM KERNELS FOR SQUARE AMM:\n");
   for (tp=tb; tp; tp = tp->next)
   {
      tp->mflop[0] = TimeTSKernel(verb, 0, pre, tp->mbB, tp->nbB, 0);
      if (verb)
         printf("   trsmKL %dx%d: %.2f\n", tp->mbB, tp->nbB, tp->mflop[0]);
   }
   WriteMMFileWithPath(pre, "res", "tsAMMRES.sum", tb);
   printf("DONE TRSM TIMING.\n");
   KillAllMMNodes(tb);
}

/*
 * Finds main amm kernels
 */
ATL_mmnode_t *DoMainMM(char pre, int verb, int nregs, int CS)
{
   ATL_mmnode_t *mmb, *sqmmb, *mp;
   const char upr = (pre == 'z' || pre == 'd') ? 'd' : 's';
   mmb = TimeMMFileWithPath(pre, "res", "geAMMRES.sum", 0, verb, 0, 1, 0, -1);
   if (mmb)
      return(mmb);
@beginskip
   mmb = ReadMMFileWithPath(pre, "res", "geAMMRES.sum");
   if (mmb)
   {
      FillInGenStrings(pre, mmb);
      if (mmb->mflop[0] < 0.0)
      {
         ATL_mmnode_t *mp;
         for (mp=mmb; mp; mp = mp->next)
            mp->mflop[0] = TimeMMKernel(verb, 0, mp, pre, mp->mbB, mp->nbB,
                                        mp->kbB, 0, 0, mp->mbB, 1, 0, -1);
         WriteMMFileWithPath(pre, "res", "geAMMRES.sum", mmb);
      }
      return(mmb);
   }
@endskip
/*
 * Find which kernels can compile on this platform
 */
   mmb = GetWorkingUserCases(verb, upr);
/*
 * Find decent generator case and find correct vectorization settings, add
 * this case to default list to be searched.
 */
   mp = DecentGenCase(verb, pre, nregs);
   mp->next = mmb;
   mmb = mp;
/*
 * Find the best user-supplied cases for the three common cache blking cases
 */
   mmb = FindCacheBudgetCasesByKB(verb, pre, CS, mmb);
/*
 * Now find best square cases
 */
   sqmmb = DoSquare(pre, verb, nregs, mmb);
/*
 * Now add small-case kernels back in, and write it out
 */
   mp = MergeCases(0, mmb, sqmmb);
   KillAllMMNodes(sqmmb);
   KillAllMMNodes(mmb);
   mmb = WinnowCases(0, mp);
   WriteMMFileWithPath(pre, "res", "geAMMRES.sum", mmb);
   return(mmb);
}
@beginskip
/*
 * Finds main amm kernels
 */
ATL_mmnode_t *DoMainMM(char pre, int verb, int nregs, int CS, int *nbs)
{
   ATL_mmnode_t *mmb, *smmb;
   mmb = ReadMMFileWithPath(pre, "res", "geAMMRES.sum");
   if (mmb)
   {
      FillInGenStrings(pre, mmb);
      if (mmb->mflop[0] < 0.0)
      {
         ATL_mmnode_t *mp;
         for (mp=mmb; mp; mp = mp->next)
            mp->mflop[0] = TimeMMKernel(verb, 0, mp, pre, mp->mbB, mp->nbB,
                                        mp->kbB, 0, 0, mp->mbB, 1, 0, -1);
         WriteMMFileWithPath(pre, "res", "geAMMRES.sum", mmb);
      }
      return(mmb);
   }
   if (verb)
   {
      int i;
      const int n = (nbs[0] >= 0) ? nbs[0]+1 : 1-nbs[0];
      printf("NBs = %3d", nbs[1]);
      for (i=2; i < n; i++)
         printf(", %3d", nbs[i]);
      printf("\n");
   }
/*
 * Find which kernels can compile on this platform
 */
   mmb = GetWorkingUserCases(verb, pre);
/*
 * For small cases (or user specified), try all kernels with all KB for
 * user generated.  Smmb now points to these KB values that are always
 * retained, and will simply be added to eventual list of large KB kernels
 * that we generate in the next step.
 */
   if (mmb)
   {
      ATL_mmnode_t *mmp;
      mmp = CloneMMQueue(mmb);
      smmb = FindBestUserCases(verb, pre, nbs, mmp);
      mmp = FindBestGenCases(verb, pre, nregs, nbs, smmb);
      if (nbs[0] >= 0)
         smmb = MergeAndWinnowCases(verb, pre, smmb, mmp);
      else  /* forced nbs are all kept, so just merge */
         smmb = MergeCases(0, smmb, mmp);
@skip         WriteMMFileWithPath(pre, "./", "win0.sum", smmb);
   }
   else
     smmb = FindBestGenCases(verb, pre, nregs, nbs, NULL);
/*
 * If nbs aren't being forced, then try larger ranges using cache budgets
 */
   if (nbs[0] >= 0)
   {
      ATL_mmnode_t *mp;
/*
 *    Find decent generator case and find correct vectorization settings, add
 *    this case to default list to be searched.
 */
      mp = DecentGenCase(verb, pre, nregs);
      mp->next = mmb;
      mmb = mp;
/*
 *    Find the best user-supplied cases for the three common cache blking cases
 */
      mmb = FindCacheBudgetCasesByKB(verb, pre, CS, mmb);
/*
 *    Now add small-case kernels back in, and write it out
 */
      mp = MergeCases(0, mmb, smmb);
      KillAllMMNodes(smmb);
      KillAllMMNodes(mmb);
      mmb = WinnowCases(0, mp);
   }
   else /* when we force nbs, we just blindly use the provided list */
      mmb = smmb;
   WriteMMFileWithPath(pre, "res", "geAMMRES.sum", mmb);
   return(mmb);
}
@endskip

int KernHandlesThisKB(ATL_mmnode_t *mp, int kb)
{
   int ku;
   if (kb < mp->kbmin)
      return(0);
   if (mp->kbmax && kb > mp->kbmax)
      return(0);
   ku = mp->ku;
   if ((kb/ku)*ku != kb)
      return(0);
   return(1);
}

/*
 * This routine tries all kernels in mmb, with K=KB, M=CEIL(KB/MU)*MU,
 * N=CEIL(KB/NU)*NU.  Kernels that can't handle KB are rejected
 * RETURNS: new mmnode ptr for best case for this KB; cannot be NULL, because
 *          1st param of mmb must be a generated kernel that works for any KB
 */
ATL_mmnode_t *BestKernForKB(int verb, char pre, ATL_mmnode_t *mmb, int KB)
{
   ATL_mmnode_t *mp, *mpB=NULL;
   double mfB=0.0;
   assert(mmb);
/*
 * Make sure first entry of mmb is a generated kernel wt runtime K & KU==1
 */
   assert(mmb->ID == 0);
   assert(mmb->genstr);
   assert(mmb->rout);
   assert(mmb->ku == 1);
   mmb->flag |=  (1 << MMF_KRUNTIME);  /* force genned case to runtime K */
   printf("   FINDING BEST NEAR-SQUARE KERNEL WT KB=%d:\n", KB);
   for (mp=mmb; mp; mp = mp->next)
   {
      const int mu=mp->mu, nu=mp->nu, ku=mp->ku, ID=mp->ID;
      const int mb=((KB+mu-1)/mu)*mu, nb=((KB+nu-1)/nu)*nu;
      const char *rt=mp->rout;
      double mf;

      if (!KernHandlesThisKB(mp, KB))
      {
         printf("      %d-%s: skipped, cannot handle KB=%d\n", ID, rt, KB);
         continue;
      }
      mf = TimeMMKernel(verb, 0, mp, pre, mb, nb, KB, 0, 0, mb, 0,  0, -1);
      if (mf > mfB)
      {
         mfB = mf;
         mpB = mp;
      }
      printf("      %d-%s, M=%d, N=%d, K=%d: %.1f\n", ID, rt, mb, nb, KB, mf);
   }
   assert(mpB);
   printf("   BEST FOR KB=%d: %d-%s (%.1f MFLOPS)\n", 
          KB, mpB->ID, mpB->rout, mfB);
   mpB = CloneMMNode(mpB);
   mpB->mflop[0] = mfB;
   mpB->kbB = KB;
   mpB->mbB = ((KB+mpB->mu-1)/mpB->mu)*mpB->mu;
   mpB->nbB = ((KB+mpB->nu-1)/mpB->nu)*mpB->nu;
   return(mpB);
}

ATL_mmnode_t *DoRankK(char pre, int verb, int nregs, const ATL_mmnode_t *mainb)
{
   ATL_mmnode_t *rkb=NULL, *mp, *mmb;
   const ATL_mmnode_t *cmp;
   int maxB=0, b;
   const char upr = (pre == 'z' || pre == 'd') ? 'd' : 's';
   rkb = TimeMMFileWithPath(pre, "res", "rkAMMRES.sum", 0, verb, 0, 1, 0, -1);
   if (rkb)
      return(rkb);
/*
 * Find largest KB used by main kernels; we will time all near-square kernels
 * of this size and below
 */
   for (cmp=mainb; cmp; cmp = cmp->next)
      if (cmp->kbB > maxB)
         maxB = cmp->kbB;
   if (!maxB)
      maxB = 256;
/*
 * All we need main kerns for is to find maxB, so now reuse the ptr to hold
 * all user cases that work on this platform
 */
   mmb = GetWorkingUserCases(verb, upr);
   mp = DecentGenCase(verb, pre, nregs);
   assert(mp);
   mp->next = mmb;
   mmb = mp;
   ResetMoveBitsInQ(rkb, 5);
   printf("TUNING RANK-K, 3 <= K <= %d:\n", maxB);
   for (b = maxB; b > 2; b--)
   {
      mp = BestKernForKB(verb, pre, mmb, b);
      mp->next = rkb;
      rkb = mp;
   }
   WriteMMFileWithPath(pre, "res", "rkAMMRES.sum", rkb);
   return(rkb);
}

int main(int nargs, char **args)
{
   char pre='d';
   int verb, nregs, nb, CS, gmu, gnu;
   int *nbs;
   char *fnout;
   ATL_mmnode_t *mmb, *rnkK, *grnkK, *emb, *mp, *mmSQ;

   nbs = GetFlags(nargs, args, &pre, &verb, &nregs, &nb, &CS);
#if 0
   if (pre == 'c' || pre == 'z')
      return(DoComplex(pre, verb));
#endif
   mmb = DoMainMM(pre, verb, nregs, CS);
   emb = TimeExtraBlockings(pre, verb);
   if (emb)
   {
      emb = SortMMQByIntVal(emb, &(emb->kbB));
      mp = MergeCases(0, mmb, emb);
      KillAllMMNodes(mmb);
      KillAllMMNodes(emb);
      mmb = WinnowCases(0, mp);
      WriteMMFileWithPath(pre, "res", "geAMMRES.sum", mmb);
   }
   rnkK = DoRankK(pre, verb, nregs, mmb);
/*
 * Handle K-cleanup
 */
   ComputeKClean(verb, pre);
/*
 * Time TRSM kernels with matching block factors as square cases
 */
   DoTRSM(pre, verb);
/*
 * Join mmb & rnkK to make master list of all kernels required in this search
 */
   if (rnkK)
   {
      for (mp=mmb; mp->next; mp = mp->next);
      mp->next = rnkK;
   }
   mp = GetUniqueUserKerns(mmb);
   KillAllMMNodes(mmb);
   WriteMMFileWithPath(pre, "res", "AMMFRCLST.sum", mp);
   KillAllMMNodes(mp);
   free(nbs);
   exit(0);
}
@ROUT uammsearch
/*
 * ASSUMES: mmb comes in ordered from smallest blocking to largest.  
 * Kills any kernel that is not faster than a smaller-NB kernel.
 */
ATL_mmnode_t *HarshPrune(ATL_mmnode_t *mmb)
{
   ATL_mmnode_t *mmp=mmb;
   while (mmp)
   {
      if (!mmp->next)
         return(mmb);
      do
      {
         if (!mmp->next)
            return(mmb);
         if (mmp->mflop[0] > mmp->next->mflop[0])
            mmp->next = KillMMNode(mmp->next);
         else
            mmp = mmp->next;
      }
      while (mmp);
   }
}
/*
 * ASSUMES: mmb comes in ordered from smallest blocking to largest.  
 * Kills any kernel that is not faster than a smaller-NB kernel.
 */
ATL_mmnode_t *TolerantPrune
(
   ATL_mmnode_t *mmb,   /* list of kernels to prune */
   double tol           /* set > 1 to allow slow kernels to stay */
)                       /* < 1 to make pruning harsher */
{
   ATL_mmnode_t *mmp=mmb;
   double mfB = 0.0;
   while (mmp)
   {
      if (!mmp->next)
         return(mmb);
      do
      {
         if (!mmp->next)
            return(mmb);
         if (mmp->mflop[0] > mfB)
            mfB = mmp->mflop[0];
         if (mfB > tol*mmp->next->mflop[0])
            mmp->next = KillMMNode(mmp->next);
         else
            mmp = mmp->next;
      }
      while (mmp);
   }
}
#define CON_NOKVEC 0
#define CON_NOMVEC 1
#define CON_NOCOMPK 2
/*
 * RETURNS: N-length queue wt best-performing kernel for specified dims
 */
ATL_mmnode_t *FindBestKerns
(
   char pre, 
   int verb, 
   ATL_mmnode_t *mmb,            /* candidate user-supplied kerns */
   int N,                        /* number of forced block factors */
   int *mbs, int *nbs, int *kbs, /* forced block factors */
   int *tids,                    /* affinity IDs to run on */
   int C,                        /* constraints */
   float tol                     /* tolerance in getting rid of slow kerns */
)
{
   ATL_mmnode_t *nmmb=NULL, *mp, *mpB, *mpG, *mpg;
   const int TRYKVEC=!(C & (1<<CON_NOKVEC));
   const int TRYMVEC=!(C & (1<<CON_NOMVEC));
   int i, mbB=0;
   double mfB, mf;
/*
 * Find basic register blocking for generated case
 */
   mpG = DecentGenCase(verb, pre, 32);
   if (mpG->vlen != VLEN[VECi])
      VECi = VTSC;
   assert (mpG->kmaj < 2);
/*
 * Loop over all required blocking factors
 */
   printf("SEARCHING %d USER BLOCKINGS:\n", N);
   for (i=N-1; i >= 0; i--)
   {
      int mb=mbs[i], nb=nbs[i], kb=kbs[i], MB=mbs[i];
      int kuG, KK=kb, veci0=VECi;
      double mfK=0.0, mfM=0.0;
      int iveci = VECi, VL=VLEN[VECi];
/*
 *    If mb not specified, choose one near specified KB
 */
      printf("\n   FINDING KERNEL FOR MB=%d, NB=%d, KB=%d:\n", mb, nb, kb);
/*
 *    Find best of M- or K-vectorized generated code for this problem size
 */
      mpg = mpB = NULL;
      if (TRYMVEC)
      {
         int muG=mpG->mu, nuG=mpG->nu, ut=muG*nuG; 
/*
 *       If mb is not specified, make it a multiple of mu & vlen
 */
         if (!MB)
         {
            int mb0;
            mb = Mylcm(muG, VL);
            mb0 = (kb/mb)*mb;
            mb = ((kb+mb-1)/mb)*mb;
            if (mb0 && mb-kb > kb-mb0)
               mb = mb0;
         }
/*
 *       If specified mb not a multiple of vlen, reduce vlen until it is
 */
         else if (mb%VL)
         {
            if (VECi == VTAVX && !(mb%VLEN[VTSSE]))
               VECi = VTSSE;
            else
               VECi = VTSC;
         }
/*
 *       Make register block a multiple of mandated block
 */
         muG = (muG / VL)*VLEN[VECi];
         ut = muG * nuG;
         while (muG > 1 && mb%muG)
            muG -= VLEN[VECi];
         if (muG < 1)
            muG = 1;
         while(muG*(nuG+1) <= ut)
            nuG++;
         while (nb%nuG)
            nuG--;
         kuG = 1;
         mpg = GetNewGenNode(pre, kb, 0, muG/VLEN[VECi], nuG, 1, 0);
         mpg->mbB = mb;
         mpg->tids = tids;
         mfM = TimeMMKernel(verb, 0, mpg, pre, mb, nb, KK, KK, KK, mb, 1, 0,-1);
         printf("      Gen mu=%d, nu=%d, kmaj=%d, mf=%.2f\n", muG, nuG, 0, mfM);
      }
      VECi = iveci;
/*
 *    Generator currently does not support k-vectorized kernels
 */
      if (0 && TRYKVEC)
      {
         int muG, nuG=mpG->nu, ut;

         if (VLEN[VECi] > 1)
            muG = mpG->mu / VLEN[VECi];
         else
            muG = mpG->mu;
         ut = muG * nuG;
/*
 *       If kb not a multiple of vlen, reduce it until it is
 */
         if (kb%VLEN[VECi])
         {
            if (VECi == VTAVX && !(kb%VLEN[VTSSE]))
               VECi = VTSSE;
            else
               VECi = VTSC;
         }
         kuG = VLEN[VECi];
/*
 *       Make register block a multiple of mandated block
 */
         while (mb%muG)
            muG--;
         while(muG*(nuG+1) <= ut)
            nuG++;
         while (nb%nuG)
            nuG--;
         if (kuG > 1)
         {
            mpB =  GetNewGenNode(pre, kb, 0, muG, nuG, kuG, kuG);
            mpg->mbB = mb;
            mpB->tids = tids;
            mfK = TimeMMKernel(verb, 0, mpB, pre, mb, nb, KK, KK, KK, mb,
                               1, 0,-1);
            printf("      Gen mu=%d, nu=%d, kmaj=%d, mf=%.2f\n", muG, nuG, kuG,
                   mfK);
         }
      }
      if (mfM >= mfK)  /* use M-vectorized gen kernel */
      {
         if (mpB)
            KillMMNode(mpB);
         mpB = mpg;
         mfB = mfM;
      }
      else
      {
         if (mpg)
            KillMMNode(mpg);
         mpg = mpB;
         mfB = mfK;
      }
      VECi = iveci;
      if (KK != kb)
         mfB *= (double)kb / (double)KK;
      mpg->mflop[0] = mfB;
/*
 *    Search through all user kernels, and take best performing
 */
      mpB = mpg;
      mbB = mpg->mbB;
      for (mp=mmb; mp; mp = mp->next)
      {
         const int mu=mp->mu, nu=mp->nu, ku=mp->ku, kmaj=mp->kmaj;
         const int KB = (kmaj < 2) ? kb : ((kb+ku-1)/ku)*ku;
         int SKIP=0;
         if (!MB)
         {
            if (nb%nu || KB%ku)
               SKIP=1;
            else
            {
               int mb0;
               mb0 = (kb/mu)*mu;
               mb = ((kb+mu-1)/mu)*mu;
               if (mb0 && (mb-kb > kb-mb0))
                  mb = mb0;
            }
         }
         else if (mb%mu || nb%nu || KB%ku)
            SKIP=1;
         if (mp->kbmin && mp->kbmin > kb)
            SKIP=1;
         else if (mp->kbmax && mp->kbmax < kb)
            SKIP=1;
         if (SKIP)
         {
            printf("      %d-%s: SKIPPED\n", mp->ID, mp->rout);
            continue;
         }
         mp->tids = tids;
         mf = TimeMMKernel(verb, 0, mp, pre, mb, nb, KB, KB, KB, mb, 1, 0, -1);
         if (KB != kb)
            mf *= (double)kb / (double)KB;
         printf("      %d-%s: %.2f\n", mp->ID, mp->rout, mf);
         if (mf > mfB)
         {
            mfB = mf;
            mpB = mp;
            mbB = mb;
         }
      }
      printf("    [M,N,K]B=%d,%d,%d BEST: %d-%s %.2f\n", mbB, nb, kb,
             mpB->ID, mpB->rout, mfB);
      if (mpB == mpg)
      {
         mpg->next = nmmb;
         nmmb = mpg;
      }
      else
      {
         KillMMNode(mpg);
         mp = CloneMMNode(mpB);
         mp->next = nmmb;
         nmmb = mp;
      }
      nmmb->mflop[0] = mfB;
      nmmb->mbB = mbB;
      nmmb->nbB = nb;
      nmmb->kbB = kb;
      VECi = veci0;
   }
   KillAllMMNodes(mmb);
   KillMMNode(mpG);
@skip   PrintMMNodes(stderr, nmmb);
   if (tol > 0.0)
      nmmb = TolerantPrune(nmmb, tol);
@skip   ApplyMoves2Flags(nmmb, MOVES);  /* gen must know operand movement pattern */
   WriteMMFileWithPath(pre, "res", "uAMMFRC.sum", nmmb);
   printf("DONE.\n");
   return(nmmb);
}

/*
 * This routine applies the contraints C to mmb, and returns winnowed queue
 * RETURNS: Q wt all kernels failing constraints stropped out
 */
ATL_mmnode_t *ApplyConstraints(ATL_mmnode_t *mmb, int C)
{
    if (C)
    {
       ATL_mmnode_t *mp = mmb, *next;
       while (mp)
       {
          next = mp->next;
          if ((C & (1<<CON_NOKVEC)) && mp->kmaj > 1)
             mmb = KillMMNodeFromQ(mmb, mp);
          else if ((C & (1<<CON_NOMVEC)) && mp->kmaj < 2)
             mmb = KillMMNodeFromQ(mmb, mp);
          else if ((C & (1<<CON_NOCOMPK)) && 
                   !FLAG_IS_SET(mp->flag, MMF_KRUNTIME))
             mmb = KillMMNodeFromQ(mmb, mp);
          mp = next;
       }
    }
    return(mmb);
}
void PrintUsage(char *name, int ierr, char *flag)
{
   if (ierr > 0)
      fprintf(stderr, "Bad argument #%d: '%s'\n", ierr, 
              flag?flag:"OUT-OF_ARGUMENTS");
   else if (ierr < 0)
      fprintf(stderr, "ERROR: %s\n", flag);
   fprintf(stderr, "USAGE: %s [flags]:\n", name);
   fprintf(stderr, 
   "   -S <file> : take kerns from sum file, force square sizes\n");
   fprintf(stderr, "   -T #  : set pruning tolerance for slower kernels:\n");
   fprintf(stderr, 
   "      # <= 0.0 : keep all legal kernel sizes regardless of performance\n");
   fprintf(stderr, 
   "      # >=0.0 : delete all kerns wt perf*# < maxSmallerPerf\n");
   fprintf(stderr, 
   "                maxSmallerPerf= max perf found in smaller-sized kern\n");
   fprintf(stderr, "   -p [s,d]: set precision prefix (d) \n");
   fprintf(stderr, "   -b # nb1 ... nb# : square NBs to force\n");
   fprintf(stderr, "   -B # mb1 nb1 kb1 ... mb# nb# kb#: dims to force\n");
   fprintf(stderr, "   -tl # t1 t2 ... t#: affinity IDs to use\n");
   fprintf(stderr, 
           "   -M # abc1 ... abc#: which matblks should be cache flushed\n");
   fprintf(stderr, "   -v <verb> : set verbosity (1)\n");
   fprintf(stderr, "   -C [kmc] : Constrain kernel choice:\n");
   fprintf(stderr, "      k : don't allow K-vectorized storage\n");
   fprintf(stderr, "      m : don't allow M-vectorized storage\n");
   fprintf(stderr, "      c : don't allow compile-time K kernels\n");
   fprintf(stderr, "   -K <1/0> : do/don't generate K cleanup\n");

   fprintf(stderr,
      "   -F <b0> <bN> <KI> <idx> <rfn>: brute-force blocking search:\n");
   fprintf(stderr, "       b0: smallest value to try for all dims\n");
   fprintf(stderr, "       b1: largest value to try for all dims\n");
   fprintf(stderr, "       KI: min K increment\n");
   fprintf(stderr, "      idx: index in rfn to use; -1 means last\n");
   fprintf(stderr, "      rfn: search result file name to read kern from\n");
   exit(ierr ? ierr : -1);
}

ATL_mmnode_t *GetFlags(int nargs, char **args, char *PRE, int *VERB, int *NN,
                       int *C, int **MBS, int **NBS, int **KBS, float *TOL,
                       int *KCLEAN, int **TIDS)
{
   ATL_mmnode_t *mmb=NULL;
   int B0=0, BN, KI;
   int *mbs=NULL, *nbs=NULL, *kbs=NULL, *tids=NULL;
   int i, k, j, N=0, ALL=0, MV, tl=0;
   char *cs;

@skip   MOVES = NULL;
   *TOL = 0.0;
   *VERB = 1;
   *PRE = 'd';
   *C = 0;
   *KCLEAN = 1;
   for (i=1; i < nargs; i++)
   {
      int n;
      if (args[i][0] != '-')
         PrintUsage(args[0], i, args[i]);

      switch(args[i][1])
      {
      case 'T':
         if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
         *TOL = atof(args[i]);
         if (*TOL < 0.0)
            *TOL = 0.0;
         break;
      case 'F':  /* <b0> <bN> <KI> <idx> <rfn> */
         if (i+5 >= nargs)
            PrintUsage(args[0], i-1, NULL);
         else
         {
            int I, k;
            ATL_mmnode_t *mp;

            B0 = atoi(args[i+1]);
            BN = atoi(args[i+2]);
            KI = atoi(args[i+3]);
            I = atoi(args[i+4]);
            mmb = ReadMMFile(args[i+5]);
            assert(mmb);
            if (I < 0)
               for (mp=mmb; mp->next; mp = mp->next);
            else
               for (k=0, mp=mmb; k < I && mp; k++, mp = mp->next);
            assert(mp);
            mp = CloneMMNode(mp);
            KillAllMMNodes(mmb);
            mmb = mp;
         }
         i += 5;
         break;
      case 'M':
         if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
         n = atoi(args[i]);
         for (MV=k=0; k < n; k++)
         {
           if (++i >= nargs)
               PrintUsage(args[0], i-1, NULL);
            if (args[i][0] == 'a' || args[i][0] == 'A')
               MV |= 1;
            else if (args[i][0] == 'b' || args[i][0] == 'B')
               MV |= 2;
            else if (args[i][0] == 'c' || args[i][0] == 'C')
               MV |= 4;
            else
               PrintUsage(args[0], -i, "UNKNOWN MATRIX FOR -M");
         }
         IMVS = MV;
@beginskip
         n=0;
         if (MV&1) n++;
         if (MV&2) n++;
         if (MV&4) n++;
         if (n == 1)
         {
            MOVES = DupString("-DMoveA");
            if (MV == 2)
               (MOVES)[6] = 'B';
            else if (MV == 4)
               (MOVES)[6] = 'C';
         }
         else if (n == 2)
         {
            MOVES = DupString("-DMoveA -DMoveB");
            if ((MV&1) == 0)
               MOVES[6] = 'C';
            else if ((MV&2) == 0)
               MOVES[14] = 'C';
         }
         else
            MOVES = DupString("-DMoveA -DMoveB -DMoveC");
@endskip
         break;
      case 'S':
         if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
         mmb = ReadMMFile(args[i]);
         break;
      case 'K':
         if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
         *KCLEAN = atoi(args[i]);
         break;
      case 'v':
         if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
         *VERB = atoi(args[i]);
         break;
      case 'p':
        if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
        *PRE = tolower(args[i][0]);
        assert(*PRE == 's' || *PRE == 'd' || *PRE == 'z' || *PRE == 'c');
        break;
      case 'C':  /* -C <constraint string */
        if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
         cs = args[i];
         n = strlen(cs);
         for (k=0; k < n; k++)
         {
            switch(cs[k])
            {
            case 'm':
               *C |= 1<<CON_NOMVEC;
               break;
            case 'k':
               *C |= 1<<CON_NOKVEC;
               break;
            case 'c':
               *C |= 1<<CON_NOCOMPK;
               break;
            default:
               PrintUsage(args[0], -i, "UNKNOWN CONSTRAINT");
            }
         }
      case 'B':
         if (nbs)
         {
            free(mbs);
            free(nbs);
            free(kbs);
         }
         if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
         N = atoi(args[i]);
         assert(N > 0);
         nbs = malloc(N*sizeof(int));
         assert(nbs);
         mbs = malloc(N*sizeof(int));
         assert(mbs);
         kbs = malloc(N*sizeof(int));
         assert(kbs);
         for (k=0; k < N; k++)
         {
           if (++i >= nargs)
               PrintUsage(args[0], i-1, NULL);
           mbs[k] = atoi(args[i]);
           if (++i >= nargs)
               PrintUsage(args[0], i-1, NULL);
           nbs[k] = atoi(args[i]);
           if (++i >= nargs)
               PrintUsage(args[0], i-1, NULL);
           kbs[k] = atoi(args[i]);
         }
         break;
      case 't':
         assert(args[i][2] == 'l'); /* making sure -tl flag was used */
         if (tids) free(tids);
         if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
         tl = atoi(args[i]);
         assert(tl > 0);
         tids = malloc((tl+1)*sizeof(int));
         assert(tids);
         tids[0] = tl;
         for (k=1; k <= tl ; k++)
         {
           if (++i >= nargs)
               PrintUsage(args[0], i-1, NULL);
            tids[k] = atoi(args[i]);
         }
         *TIDS = tids;
         break;
      case 'b':
         if (nbs)
         {
            free(mbs);
            free(nbs);
            free(kbs);
         }
         if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
         N = atoi(args[i]);
         if (N < 0)
         {
            ALL = (N == -2) ? 32 : -1;  /* -2: don't force MB */
            N = 36;
         }
         assert(N > 0);
         nbs = malloc(N*sizeof(int));
         assert(nbs);
         mbs = malloc(N*sizeof(int));
         assert(nbs);
         kbs = malloc(N*sizeof(int));
         assert(nbs);
         if (ALL)  /* special case to just try most possible NBs */
         {
            mbs[ 0]=nbs[ 0]=kbs[ 0]=4;
            mbs[ 1]=nbs[ 1]=kbs[ 1]=6;
            mbs[ 2]=nbs[ 2]=kbs[ 2]=8;
            mbs[ 3]=nbs[ 3]=kbs[ 3]=12;
            mbs[ 4]=nbs[ 4]=kbs[ 4]=14;
            mbs[ 5]=nbs[ 5]=kbs[ 5]=16;
            mbs[ 6]=nbs[ 6]=kbs[ 6]=20;
            mbs[ 7]=nbs[ 7]=kbs[ 7]=22;
            mbs[ 8]=nbs[ 8]=kbs[ 8]=24;
            mbs[ 9]=nbs[ 9]=kbs[ 9]=26;
            mbs[10]=nbs[10]=kbs[10]=28;
            mbs[11]=nbs[11]=kbs[11]=32;
            mbs[12]=nbs[12]=kbs[12]=36;
            mbs[13]=nbs[13]=kbs[13]=40;
            mbs[14]=nbs[14]=kbs[14]=44;
            mbs[15]=nbs[15]=kbs[15]=48;
            mbs[16]=nbs[16]=kbs[16]=52;
            mbs[17]=nbs[17]=kbs[17]=56;
            mbs[18]=nbs[18]=kbs[18]=60;
            mbs[19]=nbs[19]=kbs[19]=64;
            mbs[20]=nbs[20]=kbs[20]=72;
            mbs[21]=nbs[21]=kbs[21]=80;
            mbs[22]=nbs[22]=kbs[22]=84;
            mbs[23]=nbs[23]=kbs[23]=88;
            mbs[24]=nbs[24]=kbs[24]=96;
            mbs[25]=nbs[25]=kbs[25]=104;
            mbs[26]=nbs[26]=kbs[26]=112;
            mbs[27]=nbs[27]=kbs[27]=120;
            mbs[28]=nbs[28]=kbs[28]=128;
            mbs[29]=nbs[29]=kbs[29]=132;
            mbs[30]=nbs[30]=kbs[30]=144;
            mbs[31]=nbs[31]=kbs[31]=156;
            mbs[32]=nbs[32]=kbs[32]=168;
            mbs[33]=nbs[33]=kbs[33]=192;
            mbs[34]=nbs[34]=kbs[34]=216;
            mbs[35]=nbs[35]=kbs[35]=240;
            for (k=0; k < ALL; k++)     /* don't force any particular */
               mbs[k] = 0;              /* MB during search */
         }
         else
         {
            for (k=0; k < N; k++)
            {
              if (++i >= nargs)
                  PrintUsage(args[0], i-1, NULL);
               mbs[k] = kbs[k] = nbs[k] = atoi(args[i]);
            }
         }
         break;
      default:
         PrintUsage(args[0], i, args[i]);
      }
   }
   if (B0 && mmb)
   {
      ATL_mmnode_t *mp;
      mp = BestBlocking_BFI(1, *PRE, mmb, B0, BN, KI, 0);
      KillMMNode(mmb);
      KillMMNode(mp);
      exit(0);
   }
   if (!nbs && !mmb)
      PrintUsage(args[0], -1, "Dimensional flag (-b or -B) or -S required!");
   *MBS = mbs;
   *NBS = nbs;
   *KBS = kbs;
   if (*PRE == 's' || *PRE == 'c')
   {
      VLEN[VTAVXZ] = 16;
      VLEN[VTAVX] = 8;
      VLEN[VTSSE] = 4;
      VLEN[VTGV] = 4;
      TSIZE = 4;
   }
   #ifdef ATL_AVXZ
      VECi = VTAVXZ;
   #elif defined(ATL_AVX)
      VECi = VTAVX;
   #elif defined(ATL_SSE1)
      if (*PRE == 's')
         VECi = VTSSE;
      #ifdef ATL_SSE2
      else
         VECi = VTSSE;
      #endif
   #elif (defined(ATL_AltiVec) && !defined(ATL_VSX)) || \
         (defined(ATL_NEON) && defined(ATL_NONIEEE) && ATL_NONIEEE != 0) || \
         (defined(ATL_3DNow) && defined(ATL_NONIEEE) && ATL_NONIEEE != 0)
      if (pre == 's')
         VECi = VTGV;
   #elif defined(ATL_VSX)
      VECi = VTGV;
   #endif
   *NN = N;
   return(mmb);
}

/*
 * Finds best-performing square cases from input list of good kernels, which
 * are first pruned of any losers (any kernel that is not faster than a
 * kernel with a smaller NB).
 */
ATL_mmnode_t *FindBestSquareKern(char pre, int verb, ATL_mmnode_t *mmb)
{
   ATL_mmnode_t *mmp, *mmSQ=NULL, *prev=NULL;
   int maxNB=0;

   mmb = HarshPrune(mmb);  /* kill uncompetitive kernels */
   assert(mmb);

   mmSQ = FindBestSquareCases(pre, verb, mmb);
   assert(mmSQ);
   KillAllMMNodes(mmb);
@skip   ApplyMoves2Flags(mmSQ, MOVES);  /* gen must know operand movement pattern */
   WriteMMFileWithPath(pre, "res", "uAMMFRC.sum", mmSQ);
   printf("DONE.\n");
   return(mmSQ);
}

int main(int nargs, char **args)
{
   int *nbs, *mbs, *kbs, verb, N, C=0, KCLEAN, *tids=NULL;
   float tol;
   char pre;
   ATL_mmnode_t *mmb, *mp, *mmB;
   double mfB;

   mmb = GetFlags(nargs, args, &pre, &verb, &N, &C, &mbs, &nbs, &kbs, &tol,
                  &KCLEAN, &tids);
/*
 * If -S is thrown, we take kernels from prior search, and just retune with
 * requirement that the kernels be square
 */
   if (mmb)
   {
      mmb = ApplyConstraints(mmb, C);
      assert(mmb);
      ApplyMoves2Flags(mmb, IMVS);
@beginskip
      if (MOVES)
      {
         for (mp=mmb; mp; mp = mp->next)
            mp->moves = DupString(MOVES);
      }
@endskip
      mmb = FindBestSquareKern(pre, verb, mmb);
   }
   else
   {
      char upr=pre;
      if (pre == 'z')
         upr = 'd';
      else if (pre == 'c')
         upr = 's';
      mmb = GetWorkingUserCases(verb, upr);  /* get all working kernels */
      mmb = ApplyConstraints(mmb, C);        /* reject disallowed kerns */
      ApplyMoves2Flags(mmb, IMVS);           /* indicate A/B/C movememnt */
      mmb = FindBestKerns(pre, verb, mmb, N, mbs, nbs, kbs, tids, C, tol);
   }
   if (KCLEAN)
      ComputeKClean(verb, pre, mmb);
   mmb = ATL_SortMMNodesByMflop(0, mmb);
   mmB = ReadMMFileWithPath(pre, "res", "geAMMRES.sum");
   mmB = ATL_SortMMNodesByMflop(0, mmB);
   printf("\n");
   if (mmb)
      printf("YOUR BEST CASE: %d-%s, BLK=%d,%d,%d  %.2f\n", 
             mmb->ID, mmb->rout, mmb->mbB, mmb->nbB, mmb->kbB, mmb->mflop[0]);
   if (mmB)
   {
      printf("ATLAS BEST CASE: %d-%s, BLK=%d,%d,%d  %.2f\n", mmB->ID, 
             mmB->rout, mmB->mbB, mmB->nbB, mmB->kbB, mmB->mflop[0]);
      if (mmb)
         printf("   RATIO=%0.4f\n", mmb->mflop[0] / mmB->mflop[0]);
   }

   KillAllMMNodes(mmb);
   KillAllMMNodes(mmB);
   free(mbs);
   free(nbs);
   free(kbs);
   if (tids) free(tids);
@skip   if (MOVES)
@skip      free(MOVES);
   return(0);
}
@ROUT ATL_ammmABC
#include "atlas_misc.h"
/*
 * This routine loops over calls to the access-major matmul kernel given
 * in the arguments, using the NMK loop pattern, using the given blocking
 * parameters.  
 * alpha & beta are both applied by ablk2cmat.
 * It allocates an K*NB workspace for B, and an Mc*K workspace for A,
 * and a NB*NB workspace for C.
 */

typedef void (*mat2am_t)
   (ATL_CINT, ATL_CINT, const SCALAR, const TYPE*, ATL_CINT, TYPE*);
typedef void (*ablk2cmat_t)
   (ATL_CINT M, ATL_CINT N, const SCALAR al, const TYPE*A, 
    const SCALAR beta, TYPE*C, ATL_CINT ldc);
typedef void (*ammm_t)
   (ATL_CINT M, ATL_CINT N, ATL_CINT K, TYPE *A, TYPE *B, TYPE *C);
int Mjoin(PATL,ammmABC)
(
   enum ATLAS_TRANS TA,
   enum ATLAS_TRANS TB,
   ATL_CINT M,
   ATL_CINT N,
   ATL_CINT K,
   const SCALAR alpha,
   const TYPE *A,
   ATL_CINT lda,
   const TYPE *B,
   ATL_CINT ldb,
   const SCALAR beta,
   const TYPE *C,
   ATL_CINT ldc,
   ATL_CINT MB,                 /* chosen M blocking for this problem */
   ATL_CINT NB,                 /* chosen N blocking for this problem */
   ATL_CINT KB,                 /* chosen K blocking for this problem */
   ATL_CINT mu,                 /* M unrolling used by kernels */
   ATL_CINT nu,                 /* N unrolling used by kernels */
   ATL_CINT ku,                 /* K unrolling used by non-cleanup kernels */
   ammm_t ammmk_b0,             /* amm beta=0 kernel to use */
   ammm_t ammmk_b1,             /* amm beta=1 kernel to use */
   ammm_t ammmk_ku1,            /* amm beta=1 for K-cleanup */
   mat2am_t A2am,               /* routine to translate A into access-major */
   mat2am_t B2am,               /* routine to translate B into access-major */
   ablk2cmat_t ablk2cmat,       /* put ammmk's C back to user's C */
)
{
   ATL_CINT Mf = (M/mu)*mu, mr = M-Mf, Nf = (N/nu)*nu, nr = N-Nf;
   ATL_CINT Kf = (K/ku)*ku, kr = K-Kf;
   ATL_CINT Mc = (mr) ? Mf + mr : Mf;  /* compute CEIL from FLOOR */
   ATL_CINT Nc = (nr) ? Nf + nr : Nf;
   ATL_CINT Kc = (kr) ? Kf + kr : Kf;
   ATL_CINT incBn = (TB == AtlasNoTrans) ldb*NB-Kf : NB-Kf*ldb;
   ATL_CINT incAm = (TA == AtlasNoTrans) ? MB - Kf*ldb : MB*ldb - Kf;
   ATL_INT i, j, k;
   void *vp;
   TYPE *pA, *pB, *c;
   int COPYA=1;

   if (K <= KB) 
      return(1);   /* don't handle rank-K update with this routine */
   vp = malloc(3*ATL_Cacchelen + sizeof(TYPE)*(Mc*K+K*NB+NB*NB));
   if (!vp)
      return(2);
   pB = ATL_AlignPtr(vp);
   pA = pB + K*NB;
   pA = ATL_AlignPtr(pA);
   c = pA + Mc*K;
   c = ATL_AlignPtr(c);

   for (j=0; j != Nc; j += NB)
   {
      ATL_CINT n = Mmin(NB, Nc-j), incb = n*nu*KB, n0 = Mmin(NB, N-j);
      int COPYB=1;
      TYPE *b = pB, *a = pA;

      for (i=0; i != Mc; i += MB)
      {
         ATL_CINT m = Mmin(MB, Mc-i), inca = m*mu*KB, m0 = Mmin(NB,M-j);

/* 
 *       Handle first block, known to always have a full KB, using _b0
 *       case to initialize workspace c
 */
         if (COPYA)
            A2am(m, KB, ATL_rone, A, lda, a);
         if (COPYB)
            B2am(KB, n, ATL_rone, B, ldb, b);
         ammmk_b0(m, n, KB, a, b, c);
         a += inca; b += incb;
/*
 *       Loop over all remaining blocks that can use ammmk_b1
 */
         for (k=KB; k < Kf; k += KB, a += inca, b += incb)
         {
            ATL_CINT kk = Mmin(KB, Kf-i);
/*
 *          If necessary, copy both A & B blocks to access-major format
 */
            if (COPYA)
            {
               A2am(m, kk, ATL_rone, A, lda, a);
               A += (TA == AtlasNoTrans) ? kk*lda : kk;
            }
            if (COPYB)
            {
               B2am(kk, n, ATL_rone, B, ldb, b);
               B += (TB == AtlasNoTrans) ? kk : kk*ldb;
            }
            ammmk_b1(m, n, kk, a, b, c);
         }
/*
 *       Handle K cleanup using the provided kernel
 */
         if (kr)
         {
            if (COPYA)
               A2am(m, kr, ATL_rone, A, lda, a);
            if (COPYB)
               B2am(kr, n, ATL_rone, B, ldb, b);
            ammmk_ku1(m, n, kr, a, b, c);
            a += kr*m;
         }
         A += incAm;
/*
 *       Write answer back out to user's C 
 */
         ablk2cmat(m0, n0, alpha, c, beta, C, ldc);
         C += m0;
         COPYB = 0;
         b = pB;
      }
      B += incBn;
      COPYA = 0;
   }
   free(vp);
   return(0);
}
@ROUT ATL_ammm_IP ATL_cammm_IP ATL_ammm_tN ATL_cammm_tN ATL_ammmMNK ATL_cammmMNK
   @define rt @Mjoin(PATL,ammm_IP)@
#include "atlas_misc.h"
#include "atlas_amm.h"
#include Mstr(Mjoin(AMM_PRE,_sum.h))
@ROUT ATL_ammm_IP ATL_cammm_IP
/*
 * This routine handles M <= MAXM && N <= MAXN && very long K, or
 * the inner-product GEMM form.  It appears in the GEMM-based SYRK, which
 * is important for Cholesky.  It is typically the worst-case for ATLAS,
 * since the copy of A and B are of the same order as the computation.
 * It is a minimal workspace routine.
 */
@ROUT ATL_ammm_rkK0
#include "atlas_misc.h"
#include Mstr((Mjoin(ATLAS_PRE,rkamm_kern.h)
#include Mstr(Mjoin(ATLAS_PRE,rkamm_blk.h))
#include Mstr(Mjoin(ATLAS_PRE,rkamm_flag.h))
@ROUT ATL_cammm_1b ATL_ammm_rkK ATL_cammm_rkK
#include "atlas_misc.h"
#include "atlas_amm.h"
#include "atlas_level1.h"
#include "atlas_lvl2.h"
#include Mstr(Mjoin(AMM_PRE,_sum.h))
@ROUT ATL_ammm_1b ATL_ammmKNM
#include "atlas_misc.h"
#include "atlas_amm.h"
#include Mstr(Mjoin(AMM_PRE,_sum.h))
@ROUT ATL_ammm ATL_cammm
#include "atlas_misc.h"
#include "atlas_lvl2.h"
#include "atlas_level1.h"
#include Mstr(Mjoin(AMM_PRE,_sum.h))
   @define rt @Mjoin(PATL,ammm)@
@ROUT ATL_cammm_rkK ATL_cammm_tN ATL_cammmMNK
#include Mstr(Mjoin(AMM_PRE,_sum.h))
#ifdef ATL_CAMM_MAXMB
   #define MY_MAXMB ATL_CAMM_MAXMB
   #define MY_MAXNB ATL_CAMM_MAXNB
#else
   #define MY_MAXMB ATL_MAXM_RKK
   #define MY_MAXNB ATL_MAXM_RKK
#endif
@ROUT ATL_ammm_rkK ATL_cammm_rkK ATL_ammm_tN ATL_cammm_tN ATL_ammmMNK @\
      ATL_ammmKNM ATL_cammmMNK

#ifdef __GNUC__
static inline int ATL_ComputeB   /* RETURNS: selected blocking */
#else
static int ATL_ComputeB           /* RETURNS: selected blocking */
#endif
(
   size_t N,   /* problem dimension */
   int nu,     /* unrolling by kernel on this dim */
   int nb,     /* IN: large-case blocking */
   size_t *NS, /* OUT: # of blks of size NB-nu to perform */
   size_t *NT  /* OUT: # of blks to perform */
)
{
   size_t ns, nt, nblks, NN;
/*
 * If the entire problem is less than or equal to the unrolling, choose a block
 * of the ceiling of the unrolling and only do one
 */
   NN=((N+nu-1)/nu)*nu;  /* ceiling of number of unrollings in N */
   if (NN <= nu)
   {
      *NS = 0;
      *NT = 1;
      return(NN);
   }
/*
 * If suggested block size is smaller or same as unrolling, then the blocking
 * size is the unrolling, and we don't have an NB-nu sized-blocks, since that
 * would be zero sized
 */
   if (nb <= nu)
   {
      *NS = 0;
      *NT = NN/nu;
      return(nu);
   }

   nb = (nb/nu)*nu;      /* floor of number of unrollings in a block*/
/*
 * If 1 block is within NU of covering the entire dim, just make the
 * block size the entire dim
 */
   if (nb+nu >= NN)
   {
      *NS = 0;
      *NT = 1;
      return(NN);
   }
/*
 * Otherwise, compute how many blocks we need  of each type
 */
   while(1)
   {
      nblks = (N+nb-1)/nb;
      ns = (nblks*nb - NN)/nu;
      if (ns < nblks)
         break;
      nb -= nu;
   }

   *NS = ns;
   *NT = nblks;
   return(nb);
}
@ROUT ATL_ammmKNM

static int ATL_ammm_rkK
(
   const size_t M,
   const size_t nmblks,
   const size_t nsmblks,
   const int MB,
   const int NMU,
   const int mu,
   const size_t N,
   const size_t nnblks,
   const size_t nsnblks,
   const int NB,
   const int NNU,
   const int nu,
   const int K,
   const int KK,
   const int ku,
   const TYPE *A,      /* pts to beginning of matrix */
   const size_t lda,
   const size_t incAm0,
   const size_t incAm,
   const TYPE *B,      /* pts to 1 past END of matrix */
   const size_t ldb,
   const size_t incBn0,
   const size_t incBn,
   TYPE *C,            /* pts to 1 past END of matrix */
   const size_t ldc,
   const SCALAR alpA, 
   const SCALAR alpB,
   const SCALAR beta,
   TYPE *pA,
   const size_t incAw0,
   const size_t incAw,
   TYPE *pB,
   TYPE *pC,
   const ammkern_t amm,
   const cm2am_t a2blk,
   const cm2am_t b2blk,
   const ablk2cmat_t blk2c
)
{
   size_t n, j;
   int mb, nb;
   TYPE *pA0=pA;

   n = N;
   for (n=N, j=0; j < nnblks; j++)
   {
      int nmu, mb, nnu, nb, nn;
      size_t i, m;
      TYPE *c;
      if (j < nsnblks)
      {
         nb = NB-nu;
         nnu = NNU-1;
         B -= incBn0;
      }
      else
      {
         nb = NB;
         nnu = NNU;
         B -= incBn;
      }
      nn = Mmin(n, nb);
      C -= nn*ldc;
      c=C;

      b2blk(K, nn, alpB, B, ldb, pB);

      mb = MB-mu;
      nmu = NMU-1;
      pA = pA0;
      for (m=M,i=0; i < nsmblks; i++, m -= mb, c += mb)
      {
         const int mm = Mmin(m, mb);
         TYPE *pAn = pA + incAw0;
         if (!j)
         {
            a2blk(K, mm, alpA, A, lda, pA);
            A += incAm0;
         }
         amm(nmu, nnu, KK, pA, pB, pC, pAn, pB, pC);
         blk2c(mm, nn, ATL_rone, pC, beta, c, ldc);
         pA = pAn;
      }

      for (mb=MB, nmu=NMU; i < nmblks; i++, m -= mb, c += mb)
      {
         const int mm = Mmin(m, mb);
         TYPE *pAn = pA + incAw;
         if (!j)
         {
            a2blk(K, mm, alpA, A, lda, pA);
            A += incAm;
         }
         amm(nmu, nnu, KK, pA, pB, pC, pAn, pB, pC);
         blk2c(mm, nn, ATL_rone, pC, beta, c, ldc);
         pA = pAn;
      }
      n -= nb;
   }
   return(0);
}

@ROUT ATL_ammmKNM
   @define rt @Mjoin(PATL,ammmKNM)@
/*
 * This routine called for very large matrices; requires workspace of
 * one panel and 2 blocks at most
 */
@ROUT ATL_ammmMNK ATL_cammmMNK
   @define rt @Mjoin(PATL,ammmMNK)@
/*
 * This routine called when N < M and K is large
 */
@ROUT ATL_ammm_rkK
 #include Mstr(Mjoin(Mjoin(atlas_,PRE),sysinfo.h))
@ROUT ATL_ammm_rkK ATL_cammm_rkK

   @define rt @Mjoin(PATL,ammm_rkK)@
/*
 * This routine called when 2 < K <= MAXK
 */
@ROUT ATL_ammm_1b ATL_cammm_1b
   @define rt @Mjoin(PATL,ammm_1b)@
/* 
 * This routine called in degenerate case where all dims less than max block,
 * so we can do entire operation with one kernel call
 */
@ROUT ATL_ammm ATL_cammm
static int ATL_ammm
@ROUT ATL_ammm_tN ATL_cammm_tN
/* 
 * This routine handles N <= MAXN, K & M large (left-looking shape)
 */
int Mjoin(PATL,ammm_tN)
@ROUT ATL_ammm_1b  ATL_ammm_rkK ATL_cammm_1b ATL_ammmMNK ATL_cammmMNK @\
      ATL_cammm_rkK ATL_cammm_IP ATL_ammmKNM
int @(rt)
@ROUT ATL_ammm ATL_ammm_1b  ATL_ammm_rkK ATL_cammm ATL_cammm_1b ATL_ammmMNK @\
      ATL_cammm_rkK  ATL_cammm_IP ATL_ammm_tN ATL_cammm_tN @\
      ATL_ammmKNM ATL_cammmMNK
(
   enum ATLAS_TRANS TA,
   enum ATLAS_TRANS TB,
   ATL_CSZT M,
   ATL_CSZT N,
   ATL_CSZT K,
   const SCALAR alpha,
   const TYPE *A,
   ATL_CSZT lda,
   const TYPE *B,
   ATL_CSZT ldb,
   const SCALAR beta,
   TYPE *C,
   ATL_CSZT ldc
)
@ROUT ATL_ammmMNK ATL_cammmMNK
{
   ablk2cmat_t blk2c;
   cm2am_t a2blk, b2blk;
   size_t m, nsmblks, nmblks, nsnblks, nnblks, i, incAm0, incAm, incAw0;
   size_t nkb, incAk, incAk0, mulAm, incBk, incBk0, mulBn;
   int mu, nu, ku, MB, NB, KB, KB0, kb0, NMU, NNU, A_1TRIP;
   void *vp;
@ROUT ATL_ammmMNK
   TYPE *pC, *pB, *pB0, *pA, *pA0;
   ammkern_t ammK0, amm;
   const int B_BYCOLS = (TB == AtlasNoTrans);
   const int A_BYROWS = (TA == AtlasNoTrans);
   TYPE alpA=ATL_rone, alpB=ATL_rone, alpC=ATL_rone;
@ROUT ATL_cammmMNK
   TYPE *rC, *iC, *iB, *pB0, *iA, *pA0;
   ammkern_t ammK0, ammK0_bn, ammK0_b1, amm_b1, amm_bn;
   const int B_BYCOLS = (TB == AtlasNoTrans || TB == AtlasConj);
   const int A_BYROWS = (TA == AtlasNoTrans || TA == AtlasConj);
   const TYPE ONE[2] = {ATL_rone, ATL_rzero};
   const TYPE *alpA=ONE, *alpB=ONE, *alpC=ONE;
@ROUT ATL_ammmMNK ATL_cammmMNK
   amminfo_t mminfo;

   mu = Mjoin(PATL,GetAmmmInfo)(&mminfo, TA, TB, M, N, K, alpha, beta);
   if (!mu)
      alpA = alpha;
   else if (mu == 1)
      alpB = alpha;
   else 
      alpC = alpha;
   mu = mminfo.mu;
   nu = mminfo.nu;
   ku = mminfo.ku;
@ROUT ATL_cammmMNK
   MB = ATL_ComputeB(M, mu, MY_MAXMB, &nsmblks, &nmblks);
   NMU = MB / mu;
   NB = ATL_ComputeB(N, nu, MY_MAXNB, &nsnblks, &nnblks);
@ROUT ATL_ammmMNK
   MB = ATL_ComputeB(M, mu, ATL_AMM_MAXMB, &nsmblks, &nmblks);
   NMU = MB / mu;
   NB = ATL_ComputeB(N, nu, ATL_AMM_MAXNB, &nsnblks, &nnblks);
@ROUT ATL_ammmMNK ATL_cammmMNK
   NNU = NB / nu;
   KB = mminfo.kb;
   nkb = K/KB;
/*
 * kb0: K remainder, KB0 is CEIL(kb0/ku)*ku for k-vector kerns, and
 * same as kb0 for M-vector kerns
 */
   KB0 = kb0 = K - nkb*KB;
   if (!kb0)
   {
      KB0 = kb0 = KB;
      nkb--;
   }
   #if ATL_AMM_MAXKMAJ > 1
      if (ATL_AMMFLG_KMAJOR(mminfo.flag))
      {
         KB0 = ((kb0+ku-1)/ku)*ku;
         if (ATL_AMMFLG_KRUNTIME(mminfo.flag))
            ammK0 = mminfo.amm_b0;
         else
            ammK0 = (mminfo.kb==KB0) ? mminfo.amm_b0 : mminfo.amm_k1_b0;
      }
      else
   #endif
   {
      ammK0 = (kb0 == KB) ? mminfo.amm_b0 : mminfo.amm_k1_b0;
      if (ATL_AMMFLG_KRUNTIME(mminfo.flag) && kb0 == (kb0/ku)*ku &&
          kb0 > mminfo.kbmin)
         ammK0 = mminfo.amm_b0;
   }
@ROUT ATL_ammmMNK
   amm = mminfo.amm_b1;
@ROUT ATL_cammmMNK
   if (ammK0 == mminfo.amm_b0)
   {
      amm_b1 = ammK0_b1 = mminfo.amm_b1;
      amm_bn = ammK0_bn = mminfo.amm_bn;
   }
   else
   {
      ammK0_b1 = mminfo.amm_k1_b1;
      ammK0_bn = mminfo.amm_k1_bn;
      amm_b1 = mminfo.amm_b1;
      amm_bn = mminfo.amm_bn;
   }
@ROUT ATL_ammmMNK ATL_cammmMNK
   a2blk = mminfo.a2blk;
   b2blk = mminfo.b2blk;
   blk2c = mminfo.Cblk2cm;
   i = nkb*KB+KB0;
/*
 * Determine worspace requirements and allocate
 */
   {
      size_t tsz;
      const size_t szA=MB*i;
      const size_t szB=i*(nsnblks*(NB-nu)+(nnblks-nsnblks)*NB);
      const int szC = MB*NB;

      tsz = ATL_MulBySize(szA + szB + szC + mu*nu*ku) + 3*ATL_Cachelen;
      if (tsz > ATL_MaxMalloc)
         return(2);
      vp = malloc(tsz);
      if (!vp)
         return(1);
@ROUT ATL_ammmMNK
      pC = ATL_AlignPtr(vp);
      pA = pC + szC;
      pA0 = pA = ATL_AlignPtr(pA);
      pB = pA + szA;
      pB0 = pB = ATL_AlignPtr(pB);
@ROUT ATL_cammmMNK
      iC = ATL_AlignPtr(vp);
      rC = iC + szC;
      iA = rC + szC;
      pA0 = iA = ATL_AlignPtr(iA);
      iB = iA + szA + szA;
      pB0 = iB = ATL_AlignPtr(iB);
@ROUT ATL_ammmMNK ATL_cammmMNK
   }
   if (A_BYROWS)
   {
      incAk = KB*(lda SHIFT);
      incAk0 = kb0*(lda SHIFT);
      mulAm = 1 SHIFT;
   }
   else
   {
      incAk = KB SHIFT;
      incAk0 = kb0 SHIFT;
      mulAm = lda SHIFT;
   }
   if (B_BYCOLS)
   {
      incBk = KB SHIFT;
      incBk0 = kb0 SHIFT;
      mulBn = ldb SHIFT;
   }
   else
   {
      incBk = (KB SHIFT)*ldb;
      incBk0 = kb0*(ldb SHIFT);
      mulBn = 1 SHIFT;
   }

   for (m=M, i=0; i < nmblks; i++)
   {
      size_t j, n;
      int mb, mm, nmu, incAw, incAw0;
      TYPE *c=C;
      if (i < nsmblks)
      {
         mb = MB-mu;
         nmu = NMU-1;
      }
      else
      {
         mb = MB;
         nmu = NMU;
      }
      mm = Mmin(m, mb);  /* number of A/C rows left */
      m -= mm;
      incAw = mb*KB;
      incAw0 = mb*KB0;
      for (n=N, j=0; j < nnblks; j++)
      {
         size_t k;
@ROUT ATL_ammmMNK
         int nb, nn, nnu, incBw;
         const TYPE *b=B, *a=A; 
         TYPE *pAn, *pBn;
@ROUT ATL_cammmMNK
         int nb, nn, nnu, incBw, incBw0;
         const TYPE *b=B, *a=A; 
         TYPE *pAn, *pBn, *rA, *rB;
@ROUT ATL_ammmMNK ATL_cammmMNK

         if (j < nsnblks)
         {
            nb = NB-nu;
            nnu = NNU-1;
         }
         else
         {
            nb = NB;
            nnu = NNU;
         }
         incBw = KB*nb;
         nn = Mmin(n, nb);  /* number of B/C cols left */
         n -= nn;
@ROUT ATL_ammmMNK
         if (!j)
         {
            a2blk(kb0, mm, alpA, a, lda, pA);
            a += incAk0;
         }
         if (!i)
         {
             b2blk(kb0, nn, alpB, b, ldb, pB);
             b += incBk0;
         }
         pAn = pA + incAw0;
         pAn = (nkb) ? pAn : pA0;
         pBn = pB + KB0*nb;
         ammK0(nmu, nnu, KB0, pA, pB, pC, pAn, pBn, pC);
         pA = pAn;
         pB = pBn;
         for (k=0; k < nkb; k++)
         {
            if (!j)
            {
               a2blk(KB, mm, alpA, a, lda, pA);
               a += incAk;
            }
            if (!i)
            {
                b2blk(KB, nn, alpB, b, ldb, pB);
                b += incBk;
            }
            pAn = pA + incAw;
            pAn = (k != nkb-1) ? pAn : pA0;
            pBn = pB + incBw;
            pBn = (k != nkb-1 || j != nnblks-1) ? pBn : pB0;
            amm(nmu, nnu, KB, pA, pB, pC, pAn, pBn, pC);
            pA = pAn;
            pB = pBn;
         }
         blk2c(mm, nn, alpC, pC, beta, c, ldc);
         c += nn*(ldc SHIFT);
         B += nn*mulBn;
      }
      pB = pB0;
      A += mm*mulAm;
      C += mm;
   }
@ROUT ATL_cammmMNK
         incBw0 = KB0*nb;

         rA = iA + incAw0;
         pAn = rA + incAw0;
         pAn = (nkb) ? pAn : pA0;
         rB = iB + incBw0;
         pBn = rB + incBw0;
         if (!j)
         {
            a2blk(kb0, mm, alpA, a, lda, rA, iA);
            a += incAk0;
         }
         if (!i)
         {
             b2blk(kb0, nn, alpB, b, ldb, rB, iB);
             b += incBk0;
         }
         ammK0(nmu, nnu, KB0, iA, iB, rC, rA, iB, iC);
         ammK0(nmu, nnu, KB0, rA, iB, iC, rA, rB, rC);
         ammK0_bn(nmu, nnu, KB0, rA, rB, rC, iA, rB, iC);
         ammK0_b1(nmu, nnu, KB0, iA, rB, iC, pAn, pBn, rC);
         iA = pAn;
         iB = pBn;
         for (k=0; k < nkb; k++)
         {
            rA = iA + incAw;
            rB = iB + incBw;
            if (!j)
            {
               a2blk(KB, mm, alpA, a, lda, rA, iA);
               a += incAk;
            }
            if (!i)
            {
                b2blk(KB, nn, alpB, b, ldb, rB, iB);
                b += incBk;
            }
            pAn = rA + incAw;
            pAn = (k != nkb-1) ? pAn : pA0;
            pBn = rB + incBw;
            pBn = (k != nkb-1 || j != nnblks-1) ? pBn : pB0;
            amm_bn(nmu, nnu, KB, iA, iB, rC, rA, iB, iC);
            amm_b1(nmu, nnu, KB, rA, iB, iC, rA, rB, rC);
            amm_bn(nmu, nnu, KB, rA, rB, rC, iA, rB, iC);
            amm_b1(nmu, nnu, KB, iA, rB, iC, pAn, pBn, rC);
            iA = pAn;
            iB = pBn;
         }
         blk2c(mm, nn, alpC, rC, iC, beta, c, ldc);
         c += nn*(ldc SHIFT);
         B += nn*mulBn;
      }
      iB = pB0;
      A += mm*mulAm;
      C += mm SHIFT;
   }
@ROUT ATL_ammmMNK ATL_cammmMNK

   free(vp);
   return(0);
}
@ROUT ATL_ammmKNM
{
   ablk2cmat_t blk2c;
   cm2am_t a2blk, b2blk;
   size_t n, nsmblks, nmblks, nsnblks, nnblks, j, incAm0, incAm, incAw0, incAw;
   size_t KK, incAk, incBk, incBn0, incBn, k;
   int mu, nu, ku, MB, NB, KB, mb, nb, NMU, NNU, A_1TRIP, nkb, kb0, KB0;
   void *vp;
   TYPE *pC, *pB, *pA, *pA0;
   ammkern_t ammK0, amm;
   const int B_BYCOLS = (TB == AtlasNoTrans);
   const int A_BYROWS = (TA == AtlasNoTrans);
   TYPE alpA=ATL_rone, alpB=ATL_rone;
   amminfo_t mminfo;

@skip   ATL_assert(N > ATL_AMM_MAXNB & M > ATL_AMM_MAXMB & K > ATL_AMM_MAXKB);
   mu = Mjoin(PATL,GetAmmmInfo)(&mminfo, TA, TB, M, N, K, alpha, beta);
   if (!mu)
      alpA = alpha;
   else
      alpB = alpha;
   mu = mminfo.mu;
   nu = mminfo.nu;
   ku = mminfo.ku;
   MB = ATL_ComputeB(M, mu, ATL_AMM_MAXMB, &nsmblks, &nmblks);
   NMU = MB / mu;
   NB = ATL_ComputeB(N, nu, ATL_AMM_MAXMB, &nsnblks, &nnblks);
   NNU = NB / nu;
   A_1TRIP = (nnblks < 2);
   KB = mminfo.kb;
   nkb = K/KB;
/*
 * kb0: K remainder, KB0 is CEIL(kb0/ku)*ku for k-vector kerns, and
 * same as kb0 for M-vector kerns
 */
   KB0 = kb0 = K - nkb*KB;
   if (!kb0)
   {
      KB0 = kb0 = KB;
      nkb--;
   }
   #if ATL_AMM_MAXKMAJ > 1
      if (ATL_AMMFLG_KMAJOR(mminfo.flag))
      {
         KB0 = ((kb0+ku-1)/ku)*ku;
         if (ATL_AMMFLG_KRUNTIME(mminfo.flag))
            ammK0 = mminfo.amm_b0;
         else
            ammK0 = (mminfo.kb==KB0) ? mminfo.amm_b0 : mminfo.amm_k1_b0;
      }
      else
   #endif
   {
      ammK0 = (kb0 == KB) ? mminfo.amm_b0 : mminfo.amm_k1_b0;
      if (ATL_AMMFLG_KRUNTIME(mminfo.flag) && kb0 == (kb0/ku)*ku &&
          kb0 > mminfo.kbmin)
         ammK0 = mminfo.amm_b0;
   }
   a2blk = mminfo.a2blk;
   b2blk = mminfo.b2blk;
   blk2c = mminfo.Cblk2cm;
   KK = nkb*KB + KB0;
/*
 * Do memory allocation, setup pointers
 */
   {
      size_t tsz, szA;
      const int szB = NB*KB, szC = MB*NB;

      if (A_1TRIP)
         szA = KB*MB;
      else
         szA = (nsmblks*(MB-mu)+(nmblks-nsmblks)*MB)*KB;
      tsz = ATL_MulBySize(szA + szB + szC + mu*nu*ku) + 3*ATL_Cachelen;
      if (tsz > ATL_MaxMalloc)
         return(2);
      vp = malloc(tsz);
      if (!vp)
         return(1);
      pC = ATL_AlignPtr(vp);
      pB = pC + szC;
      pB = ATL_AlignPtr(pB);
      pA = pB + szB;
      pA = ATL_AlignPtr(pA);
   }

   if (A_BYROWS)
   {
      incAm0 = (MB-mu);
      incAm = MB;
      incAk = KB*lda;
   }
   else
   {
      incAm0 = (MB-mu)*lda;
      incAm = MB*lda;
      incAk = KB;
   }
   if (B_BYCOLS)
   {
      incBn0 = (NB-nu)*ldb;
      incBn = NB*ldb;
   }
   else
   {
      incBn0 = (NB-nu);
      incBn = NB;
   }
   if (A_1TRIP)
      incAw0 = incAw = 0;
   else
   {
      incAw0 = (MB-mu)*KB0;
      incAw = MB*KB0;
   }

   C += N*ldc;
   j = (nnblks-nsnblks)*NB + nsnblks*(NB-nu);
   if (B_BYCOLS)
   {
      B += j*ldb;
      incBk = KB;
   }
   else
   {
      B += j;
      incBk = KB*ldb;
   }
/*
 * Handle remainder/full block using the actual beta; all remaining K blks
 * will be of size KB after this
 */
   ATL_ammm_rkK(M, nmblks, nsmblks, MB, NMU, mu, N, nnblks, nsnblks, NB,
                NNU, nu, kb0, KB0, ku, A, lda, incAm0, incAm, B, ldb, 
                incBn0, incBn, C, ldc, alpA, alpB, beta, pA, incAw0, incAw, 
                pB, pC, ammK0, a2blk, b2blk, blk2c);
   B += (B_BYCOLS) ? kb0 : kb0*ldb;
   A += (A_BYROWS) ? kb0*lda : kb0;
/* 
 * If A workspace is entire panel, must now base increment on full KB
 */
   if (!A_1TRIP && KB0 != KB)
   {
      incAw0 = (MB-mu)*KB;
      incAw = MB*KB;
   }
/*
 * Loop over all remaining blocks using beta=1 and full KB
 * ALSO: need to change blk2c if it is bn!
 */
   amm = mminfo.amm_b0;
   for (k=0; k < nkb; k++, B += incBk, A += incAk)
      ATL_ammm_rkK(M, nmblks, nsmblks, MB, NMU, mu, N, nnblks, nsnblks, NB,
                   NNU, nu, KB, KB, ku, A, lda, incAm0, incAm, B, ldb, 
                   incBn0, incBn, C, ldc, alpA, alpB, ATL_rone, 
                   pA, incAw0, incAw, pB, pC, amm, a2blk, b2blk, blk2c);
   free(vp);
   return(0);
}
@ROUT ATL_ammm_rkK
{
   ablk2cmat_t blk2c;
   cm2am_t a2blk, b2blk;
   size_t n, nsmblks, nmblks, nsnblks, nnblks, j, incAm0, incAm, incAw0, incAw;
   int mu, nu, ku, MB, NB, mb, nb, NMU, NNU, A_1TRIP;
   void *vp;
   TYPE *pC, *pB, *pA, *pA0;
   ammkern_t amm;
   const int B_BYCOLS = (TB == AtlasNoTrans);
   const int A_BYROWS = (TA == AtlasNoTrans);
   TYPE alpA=ATL_rone, alpB=ATL_rone;
   #if ATL_MAXKMAJ_RKK > 1
      int KK=K;
   #else
      #define KK K
   #endif
   amminfo_t mminfo;

   mu = Mjoin(PATL,GetRankKInfo)(&mminfo, TA, TB, M, N, K, alpha, beta);
   if (!mu)
      alpA = alpha;
   else
      alpB = alpha;
   mu = mminfo.mu;
   nu = mminfo.nu;
   ku = mminfo.ku;
/*
 * If 4 operands (C, wC, A, B) all fit in L1, use small, near-square shapes.
 * otherwise, use MB/NB from largest KB, which we know fits in some level
 * of cache.  Using larger M/N will tend to minimize function call overhead,
 * and shouldn't have much negative effect when in-cache.
 */
   MB = mminfo.mb+mu;
   NB = mminfo.nb+nu;
   if ((((MB*NB)<<1) + (MB+NB)*K) >= ATL_L1elts)
   {
      MB = ATL_MAXM_RKK;
      NB = ATL_MAXN_RKK;
   }
   MB = ATL_ComputeB(M, mu, MB, &nsmblks, &nmblks);
   NMU = MB / mu;
   NB = ATL_ComputeB(N, nu, NB, &nsnblks, &nnblks);
   NNU = NB / nu;
   A_1TRIP = (nnblks < 2);
   #if ATL_MAXKMAJ_RKK > 1
      if (ATL_AMMFLG_KMAJOR(mminfo.flag))
         KK = ((K+ku-1)/ku)*ku;
   #endif

   {
      size_t tsz, szA;
      int szB = KK*NB, szC = MB*NB;

      if (A_1TRIP)
         szA = MB*KK;
      else
         szA = (nsmblks*(MB-mu)+(nmblks-nsmblks)*MB)*KK;
      tsz = ATL_MulBySize(szA + szB + szC + mu*nu*ku) + 3*ATL_Cachelen;
      if (tsz > ATL_MaxMalloc)
         return(2);
      vp = malloc(tsz);
      if (!vp)
         return(1);
      pC = ATL_AlignPtr(vp);
      pB = pC + szC;
      pB = ATL_AlignPtr(pB);
      pA = pB + szB;
      pA0 = pA = ATL_AlignPtr(pA);
   }
   amm = mminfo.amm_b0;
   a2blk = mminfo.a2blk;
   b2blk = mminfo.b2blk;
   blk2c = mminfo.Cblk2cm;

   if (A_BYROWS)
   {
      incAm0 = (MB-mu);
      incAm = MB;
   }
   else
   {
      incAm0 = (MB-mu)*lda;
      incAm = MB*lda;
   }
   if (A_1TRIP)
      incAw0 = incAw = 0;
   else
   {
      incAw0 = (MB-mu)*KK;
      incAw = MB*KK;
   }

   C += N*ldc;
   B += (B_BYCOLS) ? N*ldb : N;
   n = N;
   for (n=N, j=0; j < nnblks; j++)
   {
      int nmu, mb, nnu, nb, nn;
      size_t incBn, i, m;
      TYPE *c;
      if (j < nsnblks)
      {
         nb = NB-nu;
         nnu = NNU-1;
      }
      else
      {
         nb = NB;
         nnu = NNU;
      }
      nn = Mmin(n, nb);
      B -= (B_BYCOLS) ? nn*ldb : nn;
      C -= nn*ldc;
      c=C;

      b2blk(K, nn, alpB, B, ldb, pB);

      mb = MB-mu;
      nmu = NMU-1;
      pA = pA0;
      for (m=M,i=0; i < nsmblks; i++, m -= mb, c += mb)
      {
         const int mm = Mmin(m, mb);
         TYPE *pAn = pA + incAw0;
         if (!j)
         {
            a2blk(K, mm, alpA, A, lda, pA);
            A += incAm0;
         }
         amm(nmu, nnu, KK, pA, pB, pC, pAn, pB, pC);
         blk2c(mm, nn, ATL_rone, pC, beta, c, ldc);
         pA = pAn;
      }

      for (mb=MB, nmu=NMU; i < nmblks; i++, m -= mb, c += mb)
      {
         const int mm = Mmin(m, mb);
         TYPE *pAn = pA + incAw;
         if (!j)
         {
            a2blk(K, mm, alpA, A, lda, pA);
            A += incAm;
         }
         amm(nmu, nnu, KK, pA, pB, pC, pAn, pB, pC);
         blk2c(mm, nn, ATL_rone, pC, beta, c, ldc);
         pA = pAn;
      }

      n -= nb;
   }
   free(vp);
   return(0);
}
@ROUT ATL_cammm_rkK
{
   ablk2cmat_t blk2c;
   cm2am_t a2blk, b2blk;
   size_t n, nsmblks, nmblks, nsnblks, nnblks, j, incAm0, incAm, incAw0, incAw;
   int mu, nu, ku, MB, NB, mb, nb, NMU, NNU, A_1TRIP;
   void *vp;
   TYPE *rC, *iC, *rB, *iB, *pA0;
   ammkern_t amm_b0, amm_b1, amm_bn;
   const size_t lda2=lda+lda, ldb2=ldb+ldb, ldc2=ldc+ldc;
   const int B_BYCOLS = (TB == AtlasNoTrans || TB == AtlasConj);
   const int A_BYROWS = (TA == AtlasNoTrans || TA == AtlasConj);
   const TYPE ONE[2] = {ATL_rone, ATL_rzero};
   const TYPE *alpA=ONE, *alpB=ONE;
   #if ATL_MAXKMAJ_RKK > 1
      int KK=K;
   #else
      #define KK K
   #endif
   amminfo_t mminfo;

   mu = Mjoin(PATL,GetRankKInfo)(&mminfo, TA, TB, M, N, K, alpha, beta);
   if (!mu)
      alpA = alpha;
   else
      alpB = alpha;
   mu = mminfo.mu;
   nu = mminfo.nu;
   ku = mminfo.ku;
   MB = ATL_ComputeB(M, mu, MY_MAXMB, &nsmblks, &nmblks);
   NMU = MB / mu;
   NB = ATL_ComputeB(N, nu, MY_MAXNB, &nsnblks, &nnblks);
   NNU = NB / nu;
   A_1TRIP = (nnblks < 2);
   #if ATL_MAXKMAJ_RKK > 1
      if (ATL_AMMFLG_KMAJOR(mminfo.flag))
         KK = ((K+ku-1)/ku)*ku;
   #endif

   {
      size_t szA, tsz;
      int szB = KK*NB, szC = MB*NB;
      if (A_1TRIP)
         szA = MB*KK;
      else
         szA = ((nmblks-nsmblks)*MB+nsmblks*(MB-mu))*KK;
      tsz = ATL_MulBySize(szA + szB + szC + mu*nu*ku) + 3*ATL_Cachelen;
      if (tsz > ATL_MaxMalloc)
         return(2);
      vp = malloc(tsz);
      if (!vp)
         return(1);
      iC = ATL_AlignPtr(vp);
      rC = iC + szC;
      iB = rC + szC;
      iB = ATL_AlignPtr(iB);
      rB = iB + szB;
      pA0 = rB + szB;
      pA0 = ATL_AlignPtr(pA0);
   }
   amm_b0 = mminfo.amm_b0;
   amm_b1 = mminfo.amm_b1;
   amm_bn = mminfo.amm_bn;
   a2blk = mminfo.a2blk;
   b2blk = mminfo.b2blk;
   blk2c = mminfo.Cblk2cm;

   if (A_BYROWS)
   {
      incAm0 = (MB-mu)SHIFT;
      incAm = MB SHIFT;
   }
   else
   {
      incAm0 = (MB-mu)*lda2;
      incAm = MB*lda2;
   }
   incAw0 = (MB-mu)*KK;
   incAw = MB*KK;

   C += N*ldc2;
   B += (B_BYCOLS) ? N*ldb2 : N+N;
   n = N;
   for (n=N, j=0; j < nnblks; j++)
   {
      int nmu, mb, nnu, nb, nn;
      size_t incBn, i, m;
      TYPE *iA=pA0;
      TYPE *c;
      if (j < nsnblks)
      {
         nb = NB-nu;
         nnu = NNU-1;
      }
      else
      {
         nb = NB;
         nnu = NNU;
      }
      nn = Mmin(n, nb);
      B -= (B_BYCOLS) ? nn*ldb2 : nn+nn;
      C -= nn*ldc2;
      c=C;

      b2blk(K, nn, alpB, B, ldb, rB, iB);

      mb = MB-mu;
      nmu = NMU-1;
      for (m=M,i=0; i < nsmblks; i++, m -= mb, c += mb+mb)
      {
         const int mm = Mmin(m, mb);
         TYPE *rA = iA + incAw0, *pAn = (A_1TRIP) ? iA : rA + incAw0;

         if (!j)
         {
            a2blk(K, mm, alpA, A, lda, rA, iA);
            A += incAm0;
         }
         amm_b0(nmu, nnu, KK, iA, iB, rC, iA, rB, iC);
         amm_b0(nmu, nnu, KK, iA, rB, iC, rA, rB, rC);
         amm_bn(nmu, nnu, KK, rA, rB, rC, rA, iB, iC);
         amm_b1(nmu, nnu, KK, rA, iB, iC, pAn, rB, rC);
         blk2c(mm, nn, ONE, rC, iC, beta, c, ldc);
         iA = pAn;
      }

      for (mb=MB, nmu=NMU; i < nmblks; i++, m -= mb, c += mb+mb)
      {
         const int mm = Mmin(m, mb);
         TYPE *rA = iA + incAw, *pAn = (A_1TRIP) ? iA : rA + incAw;
         if (!j)
         {
            a2blk(K, mm, alpA, A, lda, rA, iA);
            A += incAm;
         }
         amm_b0(nmu, nnu, KK, iA, iB, rC, iA, rB, iC);
         amm_b0(nmu, nnu, KK, iA, rB, iC, rA, rB, rC);
         amm_bn(nmu, nnu, KK, rA, rB, rC, rA, iB, iC);
         amm_b1(nmu, nnu, KK, rA, iB, iC, pAn, rB, rC);
         blk2c(mm, nn, ONE, rC, iC, beta, c, ldc);
         iA = pAn;
      }

      n -= nb;
   }
   free(vp);
   return(0);
}
@ROUT ATL_ammm_rkK ATL_cammm_rkK
static void *FixVector(enum ATLAS_TRANS TX, ATL_CSZT N, const SCALAR alpha,
                       const TYPE *X, ATL_CSZT incX)
{
   void *vx;
   TYPE *x;
   vx = malloc(ATL_MulBySize(N)+ATL_Cachelen);
   ATL_assert(vx);
   x = ATL_AlignPtr(vx);
@ROUT ATL_ammm_rkK
   if (SCALAR_IS_ONE(alpha))
      Mjoin(PATL,copy)(N, X, incX, x, 1);
   else
      Mjoin(PATL,cpsc)(N, alpha, X, incX, x, 1);
@ROUT ATL_cammm_rkK
   if (SCALAR_IS_ONE(alpha))
   {
      if (TX == AtlasTrans || TX == AtlasNoTrans)
         Mjoin(PATL,copy)(N, X, incX, x, 1);
      else
         Mjoin(PATL,copyConj)(N, X, incX, x, 1);
   }
   else
   {
      if (TX == AtlasTrans || TX == AtlasNoTrans)
         Mjoin(PATL,cpsc)(N, alpha, X, incX, x, 1);
      else
         Mjoin(PATL,moveConj)(N, alpha, X, incX, x, 1);
   }
@ROUT ATL_ammm_rkK ATL_cammm_rkK
   return(vx);
}

/*
 * This entry makes rkK safe for L3kernel aliased calls.  It handles
 * only the aliasing required by the L3kernels, namely square blocks
 * less than ATLAS's largest blocking factor for the square dimensions,
 * with one of A/B aliased with C, and aliased by having
 * either A == C or B == C (i.e., not a partial overlap).  When A==C, 
 * M=K < ATL_MAXK_RKK; when B==C, N=K < ATL_MAXK_RKK.
 */
@ROUT ATL_ammm_rkK 
   @define one @ATL_rone@
@ROUT ATL_cammm_rkK
   @define one @ONE@
@ROUT ATL_ammm_rkK ATL_cammm_rkK
int Mjoin(PATL,ammm_aliased_rkK)
(
   enum ATLAS_TRANS TA,
   enum ATLAS_TRANS TB,
   ATL_CSZT M,
   ATL_CSZT N,
   ATL_CSZT K,
   const SCALAR alp,
   const TYPE *A,
   ATL_CSZT lda,
   const TYPE *B,
   ATL_CSZT ldb,
   const SCALAR beta,
   TYPE *C,
   ATL_CSZT ldc
)
{
@skip   TYPE *a = (TYPE*)A, *b = (TYPE*)B;
@skip   size_t lda=ldA, ldb=ldB;
@ROUT ATL_cammm_rkK `   const TYPE ONE[2] = {ATL_rone, ATL_rzero};`
   void *vp=NULL;

   if (K == 0 || SCALAR_IS_ZERO(alp))
   {
      if (SCALAR_IS_ZERO(beta))
         Mjoin(PATL,gezero)(M, N, C, ldc);
      else if (!SCALAR_IS_ZERO(beta))
         Mjoin(PATL,gescal)(M, N, beta, C, ldc);
      return(0);
   }
   if (K == 1)
   {
@ROUT ATL_ammm_rkK  `      TYPE alpha = alp;`
@ROUT ATL_cammm_rkK `      const SCALAR alpha = alp;`
      void *xp=NULL, *yp=NULL;
      TYPE *a = (TYPE*)A, *b = (TYPE*)B;
      size_t ldA=lda, ldB=ldb;

@ROUT ATL_cammm_rkK `      TYPE ONE[2] = {ATL_rone, ATL_rzero};`

      if (A == C)
      {
         xp = FixVector(TA, M, alpha, A, 
                        (TA == AtlasTrans || TA == AtlasConjTrans) ? lda:1);
         a = ATL_AlignPtr(xp);
         alpha = @(one);
         if (TA == AtlasConjTrans || TA == AtlasTrans)
         {
            TA = AtlasTrans;
            ldA = 1;
         }
         else if (TA == AtlasConj)
            TA = AtlasNoTrans;
      }
      if (B == C)
      {
         yp = FixVector(TB, N, alpha, B, 
                        (TB == AtlasTrans || TB == AtlasConjTrans) ? 1:ldb);
         b = ATL_AlignPtr(yp);
         alpha = @(one);
         if (TB == AtlasConjTrans)
            TB = AtlasTrans;
         else if (TB == AtlasConj || TB == AtlasNoTrans)
         {
            TA = AtlasNoTrans;
            ldB = 1;
         }
      }
      Mjoin(PATL,ammm)(TA, TB, M, N, K, alpha, a, ldA, b, ldB, beta, C, ldc);
      if (xp)
         free(xp);
      if (yp)
         free(yp);
      return(0);
   }

   if (K == 2)
   {
@ROUT ATL_ammm_rkK  `      TYPE alpha = alp;`
@ROUT ATL_cammm_rkK `      const SCALAR alpha = alp;`
@ROUT ATL_cammm_rkK `      TYPE ONE[2] = {ATL_rone, ATL_rzero};`
/*
 *    If BETA != 1, ammm_rk2 will copy all inputs and thus aliasing safe
 */
      if (!SCALAR_IS_ONE(beta))
         Mjoin(PATL,ammm_rk2)(TA, TB, M, N, alpha, A, lda, B, ldb, beta, 
                              C, ldc);
/*
 *    For beta = 1, copy aliased input array(s) and then call GER2
 */
      else
      {
         void *wp=NULL, *xp=NULL, *yp=NULL, *zp=NULL;
         TYPE *w, *x, *y, *z;
         ATL_SZT incX, incY;
@ROUT ATL_ammm_rkK
         if (A == C)
         {
            ATL_CSZT incx = (TA == AtlasTrans) ? lda:1;
@ROUT ATL_cammm_rkK
         if (A == C || TA == AtlasConjTrans || TA == AtlasConj)
         {
            ATL_CSZT incx = (TA == AtlasTrans || TA == AtlasConjTrans) ? lda:1;
@ROUT ATL_ammm_rkK ATL_cammm_rkK
            wp = FixVector(TA, M, alpha, A, incx);
            xp = FixVector(TA, M, alpha, A+((incx==1 ? lda:1)SHIFT), incx);
            alpha = @(one);
            w = ATL_AlignPtr(wp);
            incX = 1;
         }
         else  /* don't need to copy A */
         {
            w = (TYPE*)A;
            if (TA == AtlasNoTrans)
            {
               x = (TYPE*)(A + (lda SHIFT));
               incX = 1;
            }
            else /* if (TA == AtlasTrans) */
            {
               x = (TYPE*)(A + (1 SHIFT));
               incX = lda;
            }
         }
         if (B == C)
         {
            ATL_CSZT incy = (TB == AtlasTrans || TB == AtlasConjTrans) ? 1:ldb;
            yp = FixVector(TB, N, alpha, A, incy);
            zp = FixVector(TB, N, alpha, A+(((incy==1)?ldb:1)SHIFT), incy);
            y = ATL_AlignPtr(yp);
            z = ATL_AlignPtr(zp);
@ROUT ATL_cammm_rkK
            if (TB == AtlasConj)
               TB = AtlasNoTrans;
            else if (TB == AtlasConjTrans)
               TB = AtlasTrans;
@ROUT ATL_ammm_rkK ATL_cammm_rkK
            incY = 1;
            alpha = @(one);
         
         }
         else  /* no need to copy B */
         {
            y = (TYPE*)B;
@ROUT ATL_cammm_rkK `            if (TB == AtlasNoTrans || TB == AtlasConj)`
@ROUT ATL_ammm_rkK `            if (TB == AtlasNoTrans)`
            {
               incY = ldb;
               z = (TYPE*)(B + (1 SHIFT));
            }
            else
            {
               incY = 1;
               z = (TYPE*)(B + (ldb SHIFT));
            }
         }
@ROUT ATL_ammm_rkK
         Mjoin(PATL,ger2)(M, N, alpha, w, incX, y, incY, @(one), 
                          x, incX, z, incY, C, ldc);
@ROUT ATL_cammm_rkK
         if (TB == AtlasNoTrans || TB == AtlasTrans)
            Mjoin(PATL,ger2u)(M, N, alpha, w, incX, y, incY, @(one), 
                              x, incX, z, incY, C, ldc);
         else
            Mjoin(PATL,ger2c)(M, N, alpha, w, incX, y, incY, @(one), 
                              x, incX, z, incY, C, ldc);
@ROUT ATL_ammm_rkK ATL_cammm_rkK
         if (wp)
            free(wp);
         if (xp)
            free(xp);
         if (yp)
            free(yp);
         if (zp)
            free(zp);
         return(0);
      }
      return(0);
   }
/*
 * For K > 3, ATL_ammm_rkK is safe for these precise aliasing conditions
 */
   ATL_assert(!Mjoin(PATL,ammm_rkK)(TA, TB, M, N, K, alp, A, lda, B, ldb, 
                                    beta, C, ldc));
   return(0);
@beginskip
   if (K < 3)
   {
      lda = (TA == AtlasNoTrans || TA == AtlasConj) ? M:K;
      ldb = (TB == AtlasNoTrans || TB == AtlasConj) ? K:N;
      a = malloc(ATL_MulBySize((M+N)*K));
      ATL_assert(a);
      b = a + ((M*K)SHIFT);
      if (lda == M)
         Mjoin(PATL,gecopy)(M, K, A, ldA, a, lda);
      else
         Mjoin(PATL,gecopy)(K, M, A, ldA, a, lda);
      if (ldb == K)
         Mjoin(PATL,gecopy)(K, N, B, ldB, b, ldb);
      else
         Mjoin(PATL,gecopy)(N, K, B, ldB, b, ldb);
   }
   ATL_assert(!Mjoin(PATL,ammm)(TA, TB, M, N, K, alpha, a, lda, b, ldb, 
              beta, C, ldc));
   if (a != A)
      free(a);
@endskip
}
@ROUT ATL_ammm_tN
{
   ablk2cmat_t blk2c;
   cm2am_t a2blk, b2blk;
   ammkern_t ammK0, amm;
   amminfo_t mminfo;
   TYPE alpA=ATL_rone, alpB=ATL_rone, alpC=ATL_rone;
   TYPE *pA, *pB0, *pB, *pC;
   int mu, nu, ku, nnu, NN, MB, NMU, KB, KB0, kb0, incBw, incBw0;
   size_t incAk0, incAk, mulAm, incBk0, incBk, nkb, k, nmblks, nsmblks, i, m;
   void *vp;

   ATL_assert(N <= ATL_AMM_MAXNB);
   mu = Mjoin(PATL,GetAmmmInfo)(&mminfo, TA, TB, M, N, K, alpha, beta);
   if (!mu)
      alpA = alpha;
   else if (mu == 1)
      alpB = alpha;
   else
      alpC = alpha;

   mu = mminfo.mu;
   nu = mminfo.nu;
   ku = mminfo.ku;
   MB = ATL_ComputeB(M, mu, ATL_AMM_MAXMB, &nsmblks, &nmblks);
   NMU = MB / mu;
   nnu = (N+nu-1)/nu;
   KB = mminfo.kb;
   NN = nnu * nu;
   nkb = K/KB;
/*
 * kb0: K remainder, KB0 is CEIL(kb0/ku)*ku for k-vector kerns, and
 * same as kb0 for M-vector kerns
 */
   KB0 = kb0 = K - nkb*KB;
   if (!kb0)
   {
      KB0 = kb0 = KB;
      nkb--;
   }
   #if ATL_AMM_MAXKMAJ > 1
      if (ATL_AMMFLG_KMAJOR(mminfo.flag))
      {
         KB0 = ((kb0+ku-1)/ku)*ku;
         if (ATL_AMMFLG_KRUNTIME(mminfo.flag))
            ammK0 = mminfo.amm_b0;
         else
            ammK0 = (mminfo.kb==KB0) ? mminfo.amm_b0 : mminfo.amm_k1_b0;
      }
      else
   #endif
   {
      ammK0 = (kb0 == KB) ? mminfo.amm_b0 : mminfo.amm_k1_b0;
      if (ATL_AMMFLG_KRUNTIME(mminfo.flag) && kb0 == (kb0/ku)*ku &&
          kb0 > mminfo.kbmin)
         ammK0 = mminfo.amm_b0;
   }
   amm = mminfo.amm_b1;
   a2blk = mminfo.a2blk;
   b2blk = mminfo.b2blk;
   blk2c = mminfo.Cblk2cm;

/*
 * Do memory allocation, setup pointers
 */
   {
      const int szA = MB*KB, szC=MB*NN; 
      size_t szB = (nkb*KB+KB0)*NN;
      const size_t tsz = ATL_MulBySize(szA+szB+szC+mu*nu*ku) + 3*ATL_Cachelen;
      if (tsz > ATL_MaxMalloc)
         return(2);
      vp = malloc(tsz);
      if (!vp)
         return(1);
      pA = ATL_AlignPtr(vp);
      pB = pA + szA;
      pB0 = pB = ATL_AlignPtr(pB);
      pC = pB + szB;
      pC = ATL_AlignPtr(pC);
   }
   if (TA == AtlasNoTrans)
   {
      incAk = lda*KB;
      incAk0 = lda*kb0;
      mulAm = 1;
   }
   else
   {
      incAk = KB;
      incAk0 = kb0;
      mulAm = lda;
   }
   if (TB == AtlasNoTrans)
   {
      incBk = KB;
      incBk0 = kb0;
   }
   else
   {
      incBk = KB*ldb;
      incBk0 = kb0*ldb;
   }
   if (nkb)
   {
      incBw0 = KB0*NN;
      if (nkb > 1)
         incBw = KB*NN;
      else incBw = 0;
   }
   else 
      incBw = incBw0 = 0;
   for (m=M,i=0; i < nmblks; i++)
   {
      const TYPE *An;
      TYPE *pBn;
      int mb, nmu, mm;

      if (i < nsmblks)
      {
         mb = MB-mu;
         nmu = NMU-1;
      }
      else
      {
         mb = MB;
         nmu = NMU;
      }
      mm = Mmin(m, mb);
      m -= mm;
      An = A + mm*mulAm;
/*
 *    Do first (possibly partial) K-block
 */
      a2blk(kb0, mm, alpA, A, lda, pA);
      A += incAk0;
      if (!i)
      {
         b2blk(kb0, N, alpB, B, ldb, pB);
         B += incBk0;
      }
      pBn = pB + incBw0;
      ammK0(nmu, nnu, KB0, pA, pB, pC, pA, pBn, pC);
      pB = pBn;
/*
 *    Loop over all full-sized blocks
 */
      for (k=0; k < nkb; k++)
      {
         a2blk(KB, mm, alpA, A, lda, pA);
         A += incAk;
         if (!i)
         {
            b2blk(KB, N, alpB, B, ldb, pB);
            B += incBk;
         }
         pBn = (k < nkb-1) ? pB+incBw : pB0;
         amm(nmu, nnu, KB, pA, pB, pC, pA, pBn, pC);
         pB = pBn;
      }
      blk2c(mm, N, alpC, pC, beta, C, ldc);
      C += mm;
      A = An;
   }

   free(vp);
   return(0);
}
@ROUT ATL_cammm_tN
{
   ablk2cmat_t blk2c;
   cm2am_t a2blk, b2blk;
   ammkern_t ammK0_b0, ammK0_b1, ammK0_bn, amm_b1, amm_bn;
   amminfo_t mminfo;
   const TYPE ONE[2] = {ATL_rone, ATL_rzero};
   const TYPE *alpA=ONE, *alpB=ONE, *alpC=ONE;
   TYPE *rA, *iA, *pB0, *rC, *iC;
   int mu, nu, ku, nnu, NN, MB, NMU, KB, KB0, kb0, incBw, incBw0;
   size_t incAk0, incAk, mulAm, incBk0, incBk, nkb, k, nmblks, nsmblks, i, m;
   void *vp;

   ATL_assert(N <= ATL_AMM_MAXNB);
   mu = Mjoin(PATL,GetAmmmInfo)(&mminfo, TA, TB, M, N, K, alpha, beta);
   if (!mu)
      alpA = alpha;
   else if (mu == 1)
      alpB = alpha;
   else
      alpC = alpha;

   mu = mminfo.mu;
   nu = mminfo.nu;
   ku = mminfo.ku;
   MB = ATL_ComputeB(M, mu, MY_MAXMB, &nsmblks, &nmblks);
   NMU = MB / mu;
   nnu = (N+nu-1)/nu;
   KB = mminfo.kb;
   NN = nnu * nu;
   nkb = K/KB;
/*
 * kb0: K remainder, KB0 is CEIL(kb0/ku)*ku for k-vector kerns, and
 * same as kb0 for M-vector kerns
 */
   KB0 = kb0 = K - nkb*KB;
   if (!kb0)
   {
      KB0 = kb0 = KB;
      nkb--;
   }
   #if ATL_AMM_MAXKMAJ > 1
      if (ATL_AMMFLG_KMAJOR(mminfo.flag))
      {
         KB0 = ((kb0+ku-1)/ku)*ku;
         if (ATL_AMMFLG_KRUNTIME(mminfo.flag))
            ammK0_b0 = mminfo.amm_b0;
         else
            ammK0_b0 = (mminfo.kb==KB0) ? mminfo.amm_b0 : mminfo.amm_k1_b0;
      }
      else
   #endif
   {
      ammK0_b0 = (kb0 == KB) ? mminfo.amm_b0 : mminfo.amm_k1_b0;
      if (ATL_AMMFLG_KRUNTIME(mminfo.flag) && (kb0/ku)*ku == kb0 &&
          kb0 > mminfo.kbmin)
         ammK0_b0 = mminfo.amm_b0;
   }
   amm_b1 = mminfo.amm_b1;
   amm_bn = mminfo.amm_bn;
   if (ammK0_b0 == mminfo.amm_b0)
   {
      ammK0_b1 = mminfo.amm_b1;
      ammK0_bn = mminfo.amm_bn;
   }
   else
   {
      ammK0_b1 = mminfo.amm_k1_b1;
      ammK0_bn = mminfo.amm_k1_bn;
   }
   a2blk = mminfo.a2blk;
   b2blk = mminfo.b2blk;
   blk2c = mminfo.Cblk2cm;

/*
 * Do memory allocation, setup pointers
 */
   {
      const int szA = MB*KB, szC=MB*NN; 
      size_t szB = (nkb*KB+KB0)*NN;
      const size_t tsz = ATL_MulBySize(szA+szB+szC+mu*nu*ku) + 3*ATL_Cachelen;
      if (tsz > ATL_MaxMalloc)
         return(2);
      vp = malloc(tsz);
      if (!vp)
         return(1);
      iA = ATL_AlignPtr(vp);
      rA = iA + szA;
      iC = rA + szA;
      iC = ATL_AlignPtr(iC);
      rC = iC + szC;
      pB0 = rC + szC;
      pB0 = ATL_AlignPtr(pB0);
   }
   if (TA == AtlasNoTrans)
   {
      incAk = (lda*KB)SHIFT;
      incAk0 = (lda*kb0)SHIFT;
      mulAm = 2;
   }
   else
   {
      incAk = KB SHIFT;
      incAk0 = kb0 SHIFT;
      mulAm = lda SHIFT;
   }
   if (TB == AtlasNoTrans)
   {
      incBk = KB SHIFT;
      incBk0 = kb0 SHIFT;
   }
   else
   {
      incBk = (KB*ldb)SHIFT;
      incBk0 = (kb0*ldb)SHIFT;
   }
   incBw0 = KB0*NN;
   incBw = KB*NN;
   for (m=M,i=0; i < nmblks; i++)
   {
      const TYPE *An;
      TYPE *iB=pB0, *rB=pB0+incBw0, *pBn=rB+incBw0;
      int mb, nmu, mm;

      if (i < nsmblks)
      {
         mb = MB-mu;
         nmu = NMU-1;
      }
      else
      {
         mb = MB;
         nmu = NMU;
      }
      mm = Mmin(m, mb);
      m -= mm;
      An = A + mm*mulAm;
/*
 *    Do first (possibly partial) K-block
 */
      a2blk(kb0, mm, alpA, A, lda, rA, iA);
      A += incAk0;
      if (!i)
      {
         b2blk(kb0, N, alpB, B, ldb, rB, iB);
         B += incBk0;
      }
      rB = iB + incBw0;
      pBn = rB + incBw0;
      ammK0_b0(nmu, nnu, KB0, iA, iB, rC, rA, iB, iC);
      ammK0_b0(nmu, nnu, KB0, rA, iB, iC, rA, rB, rC);
      ammK0_bn(nmu, nnu, KB0, rA, rB, rC, iA, rB, iC);
      ammK0_b1(nmu, nnu, KB0, iA, rB, iC, rA, pBn, iC);
      iB = pBn;
/*
 *    Loop over all full-sized blocks
 */
      for (k=0; k < nkb; k++)
      {
         a2blk(KB, mm, alpA, A, lda, rA, iA);
         A += incAk;
         rB = iB + incBw;
         if (!i)
         {
            b2blk(KB, N, alpB, B, ldb, rB, iB);
            B += incBk;
         }
         pBn = (k < nkb-1) ? rB+incBw : pB0;
         amm_bn(nmu, nnu, KB, iA, iB, rC, rA, iB, iC);
         amm_b1(nmu, nnu, KB, rA, iB, iC, rA, rB, rC);
         amm_bn(nmu, nnu, KB, rA, rB, rC, iA, rB, iC);
         amm_b1(nmu, nnu, KB, iA, rB, iC, rA, pBn, iC);
         iB = pBn;
      }
      blk2c(mm, N, alpC, rC, iC, beta, C, ldc);
      C += mm+mm;
      A = An;
   }

   free(vp);
   return(0);
}
@ROUT ATL_cammm_IP
{
   ablk2cmat_t blk2c;
   cm2am_t a2blk, b2blk;
   ammkern_t ammK0_b0, ammK0_b1, ammK0_bn, amm_b1, amm_bn;
   amminfo_t mminfo;
   const TYPE ONE[2] = {ATL_rone, ATL_rzero};
   const TYPE *alpA=ONE, *alpB=ONE, *alpC=ONE;
   TYPE *rA, *iA, *rB, *iB, *rC, *iC;
   int mu, nu, ku, nmu, nnu, MM, NN, KB, KB0, kb0;
   size_t incA, incB, nkb, k;
   void *vp;

   mu = Mjoin(PATL,GetAmmmInfo)(&mminfo, TA, TB, M, N, K, alpha, beta);
   if (!mu)
      alpA = alpha;
   else if (mu == 1)
      alpB = alpha;
   else
      alpC = alpha;

   mu = mminfo.mu;
   nu = mminfo.nu;
   ku = mminfo.ku;
   nmu = (M+mu-1)/mu;
   nnu = (N+nu-1)/nu;
   KB = mminfo.kb;
   MM = nmu * mu;
   NN = nnu * nu;
   nkb = K/KB;
/*
 * kb0: K remainder, KB0 is CEIL(kb0/ku)*ku for k-vector kerns, and
 * same as kb0 for M-vector kerns
 */
   KB0 = kb0 = K - nkb*KB;
   if (!kb0)
   {
      KB0 = kb0 = KB;
      nkb--;
   }
   #if ATL_AMM_MAXKMAJ > 1
      if (ATL_AMMFLG_KMAJOR(mminfo.flag))
      {
         KB0 = ((kb0+ku-1)/ku)*ku;
         if (ATL_AMMFLG_KRUNTIME(mminfo.flag))
            ammK0_b0 = mminfo.amm_b0;
         else
            ammK0_b0 = (mminfo.kb==KB0) ? mminfo.amm_b0 : mminfo.amm_k1_b0;
      }
      else
   #endif
   {
      ammK0_b0 = (kb0 == KB) ? mminfo.amm_b0 : mminfo.amm_k1_b0;
      if (ATL_AMMFLG_KRUNTIME(mminfo.flag) && (kb0/ku)*ku == kb0 && 
          kb0 > mminfo.kbmin)
         ammK0_b0 = mminfo.amm_b0;
   }
   amm_b1 = mminfo.amm_b1;
   amm_bn = mminfo.amm_bn;
   if (ammK0_b0 == mminfo.amm_b0)
   {
      ammK0_b1 = amm_b1;
      ammK0_bn = amm_bn;
   }
   else
   {
      ammK0_b1 = mminfo.amm_k1_b1;
      ammK0_bn = mminfo.amm_k1_bn;
   }
   a2blk = mminfo.a2blk;
   b2blk = mminfo.b2blk;
   blk2c = mminfo.Cblk2cm;

/*
 * Do memory allocation, setup pointers
 */
   {
      const int szA=MM*KB, szB=KB*NN, szC=MM*NN;
      vp = malloc(ATL_MulBySize(szA + szB + szC + mu*nu*ku) + 3*ATL_Cachelen);
      ATL_assert(vp);
      iA = ATL_AlignPtr(vp);
      rA = iA + szA;
      iB = rA + szA;
      iB = ATL_AlignPtr(iB);
      rB = iB + szB;
      iC = rB + szB;
      iC = ATL_AlignPtr(iC);
      rC = iC + szC;
   }
   incA = ((TA == AtlasNoTrans) ? lda*KB : KB)SHIFT;
   incB = ((TB == AtlasNoTrans) ? KB : KB*ldb)SHIFT;
/*
 * Do first (possibly partial) K-block
 */
   a2blk(kb0, M, alpA, A, lda, rA, iA);
   b2blk(kb0, N, alpB, B, ldb, rB, iB);
   ammK0_b0(nmu, nnu, KB0, iA, iB, rC, rA, iB, iC);
   ammK0_b0(nmu, nnu, KB0, rA, iB, iC, rA, rB, rC);
   ammK0_bn(nmu, nnu, KB0, rA, rB, rC, iA, rB, iC);
   ammK0_b1(nmu, nnu, KB0, iA, rB, iC, iA, iB, rC);
   A += ((TA == AtlasNoTrans) ? lda*kb0 : kb0)SHIFT;
   B += ((TB == AtlasNoTrans) ? kb0 : kb0*ldb)SHIFT;
/*
 * Loop over all full-sized blocks
 */
   for (k=0; k < nkb; k++)
   {
      a2blk(KB, M, alpA, A, lda, rA, iA);
      b2blk(KB, N, alpB, B, ldb, rB, iB);
      ammK0_bn(nmu, nnu, KB, iA, iB, rC, rA, iB, iC);
      ammK0_b1(nmu, nnu, KB, rA, iB, iC, rA, rB, rC);
      ammK0_bn(nmu, nnu, KB, rA, rB, rC, iA, rB, iC);
      ammK0_b1(nmu, nnu, KB, iA, rB, iC, iA, iB, rC);
      A += incA;
      B += incB;
   }
   blk2c(M, N, alpC, rC, iC, beta, C, ldc);

   free(vp);
   return(0);
}
@ROUT ATL_ammm_IP_0
{
   ablk2cmat_t blk2c;
   cm2am_t a2blk, b2blk;
   ammkern_t ammK0, amm;
   amminfo_t mminfo;
   TYPE alpA=ATL_rone, alpB=ATL_rone, alpC=ATL_rone;
   TYPE *pA, *pB, *pC;
   int mu, nu, ku, nmu, nnu, MM, NN, KB, KB0, kb0;
   size_t incA, incB, nkb, k;
   void *vp;

   mu = Mjoin(PATL,GetAmmmInfo)(&mminfo, TA, TB, M, N, K, alpha, beta);
   if (!mu)
      alpA = alpha;
   else if (mu == 1)
      alpB = alpha;
   else
      alpC = alpha;

   mu = mminfo.mu;
   nu = mminfo.nu;
   ku = mminfo.ku;
   nmu = (M+mu-1)/mu;
   nnu = (N+nu-1)/nu;
   KB = mminfo.kb;
   MM = nmu * mu;
   NN = nnu * nu;
   nkb = K/KB;
/*
 * kb0: K remainder, KB0 is CEIL(kb0/ku)*ku for k-vector kerns, and
 * same as kb0 for M-vector kerns
 */
   KB0 = kb0 = K - nkb*KB;
   if (!kb0)
   {
      KB0 = kb0 = KB;
      nkb--;
   }
   #if ATL_AMM_MAXKMAJ > 1
      if (ATL_AMMFLG_KMAJOR(mminfo.flag))
      {
         KB0 = ((kb0+ku-1)/ku)*ku;
         if (ATL_AMMFLG_KRUNTIME(mminfo.flag))
            ammK0 = mminfo.amm_b0;
         else
            ammK0 = (mminfo.kb==KB0) ? mminfo.amm_b0 : mminfo.amm_k1_b0;
      }
      else
   #endif
   {
      ammK0 = (kb0 == KB) ? mminfo.amm_b0 : mminfo.amm_k1_b0;
      if (ATL_AMMFLG_KRUNTIME(mminfo.flag) && kb0 == (kb0/ku)*ku && 
          kb0 > mminfo.kbmin)
         ammK0 = mminfo.amm_b0;
   }
   amm = mminfo.amm_b1;
   a2blk = mminfo.a2blk;
   b2blk = mminfo.b2blk;
   blk2c = mminfo.Cblk2cm;

/*
 * Do memory allocation, setup pointers
 */
   {
      const int szA=MM*KB, szB=KB*NN, szC=MM*NN;
      vp = malloc(ATL_MulBySize(szA + szB + szC + mu*nu*ku) + 3*ATL_Cachelen);
      ATL_assert(vp);
      pA = ATL_AlignPtr(vp);
      pB = pA + szA;
      pB = ATL_AlignPtr(pB);
      pC = pB + szB;
      pC = ATL_AlignPtr(pC);
   }
   incA = (TA == AtlasNoTrans) ? lda*KB : KB;
   incB = (TB == AtlasNoTrans) ? KB : KB*ldb;
/*
 * Do first (possibly partial) K-block
 */
   a2blk(kb0, M, alpA, A, lda, pA);
   b2blk(kb0, N, alpB, B, ldb, pB);
   ammK0(nmu, nnu, KB0, pA, pB, pC, pA, pB, pC);
   A += (TA == AtlasNoTrans) ? lda*kb0 : kb0;
   B += (TB == AtlasNoTrans) ? kb0 : kb0*ldb;
/*
 * Loop over all full-sized blocks
 */
   for (k=0; k < nkb; k++)
   {
      a2blk(KB, M, alpA, A, lda, pA);
      b2blk(KB, N, alpB, B, ldb, pB);
      amm(nmu, nnu, KB, pA, pB, pC, pA, pB, pC);
      A += incA;
      B += incB;
   }
   blk2c(M, N, alpC, pC, beta, C, ldc);

   free(vp);
   return(0);
}
@ROUT ATL_ammm_IP
int Mjoin(PATL,ammm_IP)
(
   enum ATLAS_TRANS TA,
   enum ATLAS_TRANS TB,
   ATL_CSZT M,
   ATL_CSZT N,
   ATL_CSZT K,
   const SCALAR alpha,
   const TYPE *A,
   ATL_CSZT lda,
   const TYPE *B,
   ATL_CSZT ldb,
   const SCALAR beta,
   TYPE *C,
   ATL_CSZT ldc
)
{
   #ifdef TCPLX
      const TYPE ONE[2]={ATL_rone,ATL_rzero}, ZERO[2]={ATL_rzero,ATL_rzero};
      const TYPE *alpA=ONE, *alpB=ONE, *alpC=ONE;
   #else
      #define ONE ATL_rone
      TYPE alpA=ATL_rone, alpB=ATL_rone, alpC=ATL_rone;
   #endif
   TYPE *a, *b, *rC, *iC;
   void *vp;
   size_t sz, incAk, incBk;
   ATL_INT lenA, lenB, lenC;
   int mu, nu, ku, nmu, nnu, kb, MB, NB, KB, kb0, KB0;
   ATL_INT nfkblks;
   amminfo_t mminf;


   mu = Mjoin(PATL,GetAmmmInfo)(&mminf, TA, TB, M, N, K, alpha, beta);
   if (!mu)
      alpA = alpha;
   else if (mu == 1)
      alpB = alpha;
   else
      alpC = alpha;

   mu = mminf.mu;
   nu = mminf.nu;
   ku = mminf.ku;
   nmu = (M+mu-1)/mu;
   nnu = (N+nu-1)/nu;
   KB = kb = mminf.kb;
   nfkblks = K / kb;
   MB = nmu * mu;
   NB = nnu * nu;
   kb0 = K - nfkblks*kb;
   if (!kb0)
   {
      kb0 = KB0 = kb;
      nfkblks--;
   }
   else
   {
      #if ATL_AMM_MAXKMAJ > 1
         if (ATL_AMMFLG_KMAJOR(mminf.flag))
         {
            KB0 = ((kb0+ku-1)/ku)*ku;
            KB = Mmax(KB, KB0);
         }
         else
      #endif
      KB0 = kb0;
   }
   lenA = MB*KB;
   lenB = KB*NB;
   lenC = MB*NB;
   sz = lenA + lenB + lenC + 2*mu*nu;
   sz = ATL_MulBySize(sz) + 4*ATL_Cachelen;
   vp = malloc(sz);
   ATL_assert(vp);
   a = ATL_AlignPtr(vp);
   b = a + (lenA SHIFT);
   b = ATL_AlignPtr(b);
   iC = b + (lenB SHIFT);
   iC = ATL_AlignPtr(iC);
   #ifdef TCPLX
      rC = iC + lenC;
      rC = ATL_AlignPtr(rC);
   #else
      rC = iC;
   #endif
   incAk = (IS_COLMAJ(TA)) ? lda*kb : kb;
   incBk = (IS_COLMAJ(TB)) ? kb : kb*ldb;
   #ifdef TCPLX
      incAk += incAk;
      incBk += incBk;
   #endif
   Mjoin(PATL,ammmK)(&mminf, M, nmu, N, nnu, nfkblks, kb, kb0, KB0, A, lda,
                     incAk, B, ldb, incBk, mminf.Cblk2cm, C, ldc, a, 0, b, 0,
                     rC, iC, alpA, alpB, alpC, beta);
   free(vp);
   return(0);
}
@ROUT ATL_ammm_1b
{
   int i;
   int nmu, nnu, nku, bM, bN, bK, szB;
   #if ATL_AMM_MAXKMAJ > 1
      int KK;
   #else
      #define KK K
   #endif
   int mu, nu, ku, appAl;
   void *vp;
   TYPE *pA, *pB, *pC, *p;
   TYPE alpA=ATL_rone, alpB=ATL_rone, alpC=ATL_rone;
   ammkern_t amm;
   ablk2cmat_t blk2c;
   cm2am_t a2blk, b2blk;
   amminfo_t mminfo;
   appAl = Mjoin(PATL,GetAmmmInfo)(&mminfo, TA, TB, M, N, K, alpha, beta);
   if (!appAl)
      alpA = alpha;
   else if (appAl == 1)
      alpB = alpha;
   else
      alpC = alpha;
/*
 * These kernels all take runtime M/N, and do well with near-square, so
 * blindly use this kernel with nM = CEIL(M/mu)*mu, nN = CEIL(N/nu)*nu
 */
   mu = mminfo.mu;
   nu = mminfo.nu;
   ku = mminfo.ku;
   nmu = (M+mu-1)/mu;
   nnu = (N+nu-1)/nu;
   nku = (K+ku-1)/ku;
   bM = nmu * mu;
   bN = nnu * nu;
   bK = nku * ku;
   a2blk = mminfo.a2blk;
   b2blk = mminfo.b2blk;
   blk2c = mminfo.Cblk2cm;
   #if ATL_AMM_MAXKMAJ > 1
      KK = K;
      if (ATL_AMMFLG_KMAJOR(mminfo.flag))
      {
         KK = bK;
         if (ATL_AMMFLG_KRUNTIME(mminfo.flag))
            amm = mminfo.amm_b0;
         else 
            amm = (mminfo.kb==KK) ? mminfo.amm_b0 : mminfo.amm_k1_b0;
      }
      else
   #endif
         amm = (bK == K) ? mminfo.amm_b0 : mminfo.amm_k1_b0;
/*
 * Force rank-K code to handle this case if we would have to use K-cleanup
 * code with unknown performance
 */
   if (amm != mminfo.amm_b0 && K > 2 && K <= ATL_MAXK_RKK)
      return(-1);
   szB = KK*bN;
   vp = malloc((bM*bN + bM*KK + szB + mu*nu*ku)*sizeof(TYPE) + 3*ATL_Cachelen);
   if (!vp)
      return(1);
   pB = ATL_AlignPtr(vp);
   pA = pB + szB;
   pA = ATL_AlignPtr(pA);
   pC = pA + bM*KK;
   pC = ATL_AlignPtr(pC);
/*
 * Copy A & B into workspace, and pad K its if necessary
 */
   a2blk(K, M, alpA, A, lda, pA);
   b2blk(K, N, alpB, B, ldb, pB);
   amm(nmu, nnu, KK, pA, pB, pC, pA, pB, pC);
   blk2c(M, N, alpC, pC, beta, C, ldc);

   free(vp);
   return(0);
}
@ROUT ATL_cammm_1b
{
   int i;
   int nmu, nnu, nku, bM, bN, bK;
   int szA, szB, szC;
   #if ATL_AMM_MAXKMAJ > 1
      int KK;
   #else
      #define KK K
   #endif
   int mu, nu, ku, appAl;
   void *vp;
   TYPE *rA, *iA, *rB, *iB, *rC, *iC, *p, *w;
   const TYPE one[2] = {ATL_rone, ATL_rzero};
   const TYPE *alpA=one, *alpB=one, *alpC=one;
   ammkern_t amm;
   ablk2cmat_t blk2c;
   cm2am_t a2blk, b2blk;
   amminfo_t mminfo;
   appAl = Mjoin(PATL,GetAmmmInfo)(&mminfo, TA, TB, M, N, K, alpha, beta);
   if (!appAl)
      alpA = alpha;
   else if (appAl == 1)
      alpB = alpha;
   else
      alpC = alpha;
/*
 * These kernels all take runtime M/N, and do well with near-square, so
 * blindly use this kernel with nM = CEIL(M/mu)*mu, nN = CEIL(N/nu)*nu
 */
   mu = mminfo.mu;
   nu = mminfo.nu;
   ku = mminfo.ku;
   nmu = (M+mu-1)/mu;
   nnu = (N+nu-1)/nu;
   nku = (K+ku-1)/ku;
   bM = nmu * mu;
   bN = nnu * nu;
   bK = nku * ku;
   a2blk = mminfo.a2blk;
   b2blk = mminfo.b2blk;
   blk2c = mminfo.Cblk2cm;
   #if ATL_AMM_MAXKMAJ > 1
      KK = K;
      if (ATL_AMMFLG_KMAJOR(mminfo.flag))
      {
         KK = bK;
         if (ATL_AMMFLG_KRUNTIME(mminfo.flag))
            amm = mminfo.amm_b0;
         else 
            amm = (mminfo.kb==KK) ? mminfo.amm_b0 : mminfo.amm_k1_b0;
      }
      else
   #endif
         amm = (bK == K) ? mminfo.amm_b0 : mminfo.amm_k1_b0;
/*
 * Force rank-K code to handle this case if we would have to use K-cleanup
 * code with unknown performance
 */
   if (amm != mminfo.amm_b0 && K > 2 && K <= ATL_MAXK_RKK)
      return(-1);
   szB = KK*bN;
   szA = bM*KK;
   szC = bM*bN;
   vp = malloc((szC+mu*nu*ku + szA + szB)*2*ATL_sizeof + 3*ATL_Cachelen);
   ATL_assert(vp);
   iB = ATL_AlignPtr(vp);
   rB = iB + szB;
   rB = ATL_AlignPtr(rB);
   iA = rB + szB;
   iA = ATL_AlignPtr(iA);
   rA = iA + szA;
   iC = rA + szA;
   rC = iC + szC;
   w = rC + szC;
/*
 * Copy A & B into workspace, and pad K its if necessary
 */
   a2blk(K, M, alpA, A, lda, rA, iA);
   b2blk(K, N, alpB, B, ldb, rB, iB);
   amm(nmu, nnu, KK, iA, iB, rC, rA, iB, iC);
   amm(nmu, nnu, KK, rA, iB, iC, rA, rB, rC);
   if (amm == mminfo.amm_b0)
   {
      mminfo.amm_bn(nmu, nnu, KK, rA, rB, rC, iA, rB, iC);
      mminfo.amm_b1(nmu, nnu, KK, iA, rB, iC, iA, rB, iC);
   }
   else
   {
      mminfo.amm_k1_bn(nmu, nnu, KK, rA, rB, rC, iA, rB, iC);
      mminfo.amm_k1_b1(nmu, nnu, KK, iA, rB, iC, iA, rB, iC);
   }
   blk2c(M, N, alpC, rC, iC, beta, C, ldc);

   free(vp);
   return(0);
}
@ROUT ATL_ammm
{
/*
 * Just do a scale and return
 */
   if (SCALAR_IS_ZERO(alpha) || !K)
   {
      if (SCALAR_IS_ZERO(beta))
         Mjoin(PATL,gezero)(M, N, C, ldc);
      else if (!SCALAR_IS_ZERO(beta))
         Mjoin(PATL,gescal)(M, N, beta, C, ldc);
      return(0);
   }
/*
 * Scope for degenerate cases that should call Level-2 BLAS; these
 * routines assert they work, since their workspace is O(N) and so are
 * not allowed to fail.
 */
   if (K == 1)  /* really a GER */
   {
      if (!SCALAR_IS_ONE(beta))
      {
         int i;
         ATL_CSZT incA = ((TA == AtlasNoTrans) ? 1 : lda);
         ATL_CSZT incB = ((TB == AtlasNoTrans) ? ldb : 1);
         for (i=0; i < N; i++, B += incB, C += ldc)
            Mjoin(PATL,axpby)(M, alpha * *B,  A, incA, beta, C, 1);
      }
      else
         Mjoin(PATL,ger)(M, N, alpha, A, (TA == AtlasNoTrans) ? 1 : lda,
                         B, (TB == AtlasNoTrans) ? ldb : 1, C, ldc);
      return(0);
   }
   if (K == 2)
      return(Mjoin(PATL,ammm_rk2)(TA, TB, M, N, alpha, A, lda, B, ldb,
                                  beta, C, ldc));
   if (N == 1)  /* Really GEMV with A as matrix, A & C as vectors */
   {
      if (TA == AtlasNoTrans)
         Mjoin(PATL,gemv)(AtlasNoTrans, M, K, alpha, A, lda, B,
                          (TB == AtlasNoTrans) ? 1:ldb, beta, C, 1);
      else
         Mjoin(PATL,gemv)(AtlasTrans, K, M, alpha, A, lda, B,
                          (TB == AtlasNoTrans) ? 1:ldb, beta, C, 1);
      return(0);
   }
   if (M == 1)  /* Really GEMV with B as matrix, A & C as vectors */
   {
      if (TB == AtlasNoTrans)
         Mjoin(PATL,gemv)(AtlasTrans, K, N, alpha, B, ldb, A,
                          (TA == AtlasNoTrans) ? lda:1, beta, C, ldc);
      else
         Mjoin(PATL,gemv)(AtlasNoTrans, N, K, alpha, B, ldb, A,
                          (TA == AtlasNoTrans) ? lda:1, beta, C, ldc);
      return(0);
   }
/*
 * Special case mainly for LU, where K==4, N==4 beta=1.0, TA==AtlasNoTrans;
 * Can do a no-copy update with only one loop.
 */
   if (K == 4 && N == 4 && TA==AtlasNoTrans && SCALAR_IS_ONE(beta))
   {
      int Mjoin(PATL,rk4n4)(enum ATLAS_TRANS,ATL_CSZT,const SCALAR,
          const TYPE*,ATL_CSZT,const TYPE*,ATL_CSZT,TYPE*,ATL_CSZT);
      if (!Mjoin(PATL,rk4n4)(TB, M, alpha, A, lda, B, ldb, C, ldc))
         return(0);
   }
/*
 * 1-block special case code can return w/o doing op if it thinks
 * rank-K would be faster
 */
   if (M <= ATL_AMM_MAXMB && N <= ATL_AMM_MAXNB && K <= ATL_AMM_MAXKB)
      if (!Mjoin(PATL,ammm_1b)(TA, TB, M, N, K, alpha, A, lda, B, ldb,
                               beta, C, ldc))
         return(0);
/*
 * Rank-K can fail to allocate space, so return success/failure
 */
   if (K > 2 && K <= ATL_MAXK_RKK)
      return(Mjoin(PATL,ammm_rkK)(TA, TB, M, N, K, alpha, A, lda, B, ldb,
                                  beta, C, ldc));
/*
 * Handle case that is really an inner product shape (M<=MB, N<=NB, large K)
 * This case not allowed to fail since it requires only 3*NB^2 workspace.
 */
   if (M <= ATL_AMM_MAXMB && N <= ATL_AMM_MAXNB)
      return(Mjoin(PATL,ammm_IP)(TA, TB, M, N, K, alpha, A, lda, B, ldb,
                                 beta, C, ldc));
/*
 * If B/C have only one column panel, call special low-workspace (3NB^3)
 * code for additional performance.  This shape occurs in left-looking LU.
 */
   if (N <= ATL_AMM_MAXNB)
      return(Mjoin(PATL,ammm_tN)(TA, TB, M, N, K, alpha, A, lda, B, ldb,
                                 beta, C, ldc));
/*
 * Next two loop orderings are general case, so use whichever uses least
 * workspace
 */
#if 0
   if (M >= N)
      return(Mjoin(PATL,ammmMNK)(TA, TB, M, N, K, alpha, A, lda, B, ldb,
                                 beta, C, ldc));
/*
 * This guy tries to allocate (M+NB)*K + NB^2 worskpace, so recursion
 * may be needed to keep it within allotted memory.
 */
   return(Mjoin(PATL,ammmNMK)(TA, TB, M, N, K, alpha, A, lda, B, ldb,
                              beta, C, ldc));
#else
   if (M > N)
      return(Mjoin(PATL,ammmKMNK)(TA, TB, M, N, K, alpha, A, lda, B, ldb,
                                  beta, C, ldc));
   return(Mjoin(PATL,ammmKNMK)(TA, TB, M, N, K, alpha, A, lda, B, ldb, 
                               beta, C, ldc));
#endif
}
@ROUT ATL_cammm
{
/*
 * Just do a scale and return
 */
   if (SCALAR_IS_ZERO(alpha) || !K)
   {
      if (SCALAR_IS_ZERO(beta))
         Mjoin(PATL,gezero)(M, N, C, ldc);
      else if (!SCALAR_IS_ZERO(beta))
         Mjoin(PATL,gescal)(M, N, beta, C, ldc);
      return(0);
   }
/*
 * Scope for degenerate cases that should call Level-2 BLAS; these
 * routines assert they work, since their workspace is O(N) and so they
 * are not allowed to fail.
 */
   if (K == 1)  /* really a GER */
   {
      if (!SCALAR_IS_ONE(beta))  /* can't use GER for beta != 1 */
      {
         int i;
         const register TYPE ral=alpha[0], ial=alpha[1];
         const size_t ldc2 = ldc+ldc;
         ATL_CSZT incB = ((TB == AtlasNoTrans) ? ldb : 1)SHIFT;
         const register TYPE 
            cjm = (TB==AtlasConj || TB==AtlasConjTrans) ? ATL_rnone:ATL_rone;
         TYPE *X=(TYPE*)A;
         void *vp=NULL;
/*
 *       Copy A if it's a row or if it must be conjugated
 */
         if (TA == AtlasTrans || TA == AtlasConjTrans || TA == AtlasConj)
         {
            vp = malloc(ATL_MulBySize(M)+ATL_Cachelen);
            ATL_assert(vp);
            X = ATL_AlignPtr(vp);
            if (TA == AtlasTrans)
               Mjoin(PATL,copy)(M, A, lda, X, 1);
            else if (TA == AtlasConjTrans)
               Mjoin(PATL,copyConj)(M, A, lda, X, 1);
            else
               Mjoin(PATL,copyConj)(M, A, 1, X, 1);
         }
         for (i=0; i < N; i++, B += incB, C += ldc2)
         {
            TYPE scal[2];
            register TYPE rb=(*B), ib=cjm*B[1];
            scal[0] = rb*ral - ib*ial;
            scal[1] = rb*ial + ib*ral;
            Mjoin(PATL,axpby)(M, scal,  X, 1, beta, C, 1);
         }
         if (vp) 
            free(vp);
      }
      else  /* BETA=1, can use GERU/GERC */
      {
         if (TA == AtlasConjTrans || TA == AtlasConj)  /* must copyConj A */
         {
            void *vp;
            TYPE *X;
            const TYPE ONE[2] = {ATL_rone, ATL_rzero};
            vp = malloc(ATL_MulBySize(M)+ATL_Cachelen);
            ATL_assert(vp);
            X = ATL_AlignPtr(vp);
            Mjoin(PATL,moveConj)(M, alpha, A, (TA == AtlasConj) ? 1:lda, X, 1);
            if (TB == AtlasConjTrans || TB == AtlasConj)  /* use gerc */
               Mjoin(PATL,gerc)(M, N, ONE, X, 1, B, 
                                (TB == AtlasConj) ? ldb : 1, C, ldc);
            else
               Mjoin(PATL,geru)(M, N, ONE, X, 1, B, 
                                (TB == AtlasNoTrans) ? ldb : 1, C, ldc);
            free(vp);
         }
         else if (TB == AtlasConjTrans || TB == AtlasConj)  /* use gerc */
            Mjoin(PATL,gerc)(M, N, alpha, A, (TA == AtlasNoTrans) ? 1 : lda, 
                             B, (TB == AtlasConj) ? ldb : 1, C, ldc);
         else /* use geru */
            Mjoin(PATL,geru)(M, N, alpha, A, (TA == AtlasNoTrans) ? 1 : lda, 
                            B, (TB == AtlasNoTrans) ? ldb : 1, C, ldc);
      }
      return(0);
   }
   if (K == 2)
      return(Mjoin(PATL,ammm_rk2)(TA, TB, M, N, alpha, A, lda, B, ldb,
                                  beta, C, ldc));
   if (N == 1)  /* GEMV wt A as matrix, B&C vecs */
   {                     
      TYPE *X = (TYPE*)B;
      void *vp = NULL;
      int incX = 1;
/*
 *    Copy B if it we need to conjugate it
 */
      if (TB == AtlasConj || TB == AtlasConjTrans)
      {
         vp = malloc(ATL_MulBySize(K)+ATL_Cachelen);
         ATL_assert(vp);
         X = ATL_AlignPtr(vp);
         Mjoin(PATL,copyConj)(K, B, (TB == AtlasConj) ? 1:ldb, X, 1);
      }
      else
         incX = (TB == AtlasNoTrans) ? 1:ldb;
      if (TA == AtlasNoTrans || TA == AtlasConj)
         Mjoin(PATL,gemv)(TA, M, K, alpha, A, lda, X, incX, beta, C, 1);
      else /* if (TA == AtlasTrans || TA == AtlasConjTrans) */
         Mjoin(PATL,gemv)(TA, K, M, alpha, A, lda, X, incX, beta, C, 1);
      if (vp)
         free(vp);
      return(0);
   }
   if (M == 1)  /* Really GEMV with B as matrix, A & C as vectors */
   {
      TYPE *X = (TYPE*)A;
      void *vp = NULL;
      int incX = 1;
/*
 *    Copy A if it we need to conjugate it
 */
      if (TA == AtlasConj || TA == AtlasConjTrans)
      {
         vp = malloc(ATL_MulBySize(K)+ATL_Cachelen);
         ATL_assert(vp);
         X = ATL_AlignPtr(vp);
         Mjoin(PATL,copyConj)(K, A, (TA == AtlasConj) ? lda:1, X, 1);
      }
      else
         incX = (TA == AtlasNoTrans) ? lda:1;
      if (TB == AtlasNoTrans)
         Mjoin(PATL,gemv)(AtlasTrans, K, N, alpha, B, ldb, X, incX,
                          beta, C, ldc);
      else if (TB == AtlasConj)
         Mjoin(PATL,gemv)(AtlasConjTrans, K, N, alpha, B, ldb, X, incX,
                          beta, C, ldc);
      else if (TB == AtlasTrans)
         Mjoin(PATL,gemv)(AtlasNoTrans, N, K, alpha, B, ldb, X, incX,
                          beta, C, ldc);
      else if (TB == AtlasConjTrans)
         Mjoin(PATL,gemv)(AtlasConj, N, K, alpha, B, ldb, X, incX,
                          beta, C, ldc);
      if (vp)
         free(vp);
      return(0);
   }
/*
 * 1-block special case code can return w/o doing op if it thinks
 * rank-K would be faster
 */
   if (M <= ATL_AMM_MAXMB && N <= ATL_AMM_MAXNB && K <= ATL_AMM_MAXKB)
   {
      if (!Mjoin(PATL,ammm_1b)(TA, TB, M, N, K, alpha, A, lda, B, ldb,
                               beta, C, ldc))
         return(0);
   }
/*
 * Rank-K could fail to allocate M*KB+KB*N+MB*KB workspace
 */
   if (K > 2 && K <= ATL_MAXK_RKK)
      return(Mjoin(PATL,ammm_rkK)(TA, TB, M, N, K, alpha, A, lda, B, ldb,
                                  beta, C, ldc));
/*
 * If B/C have only one column panel, call special low-workspace (3NB^3)
 * code for additional performance.  This shape occurs in left-looking algs.
 */
   if (N <= ATL_AMM_MAXNB)
      return(Mjoin(PATL,ammm_tN)(TA, TB, M, N, K, alpha, A, lda, B, ldb,
                                 beta, C, ldc));
/*
 * Handle case that is really an inner product shape (M<=MB, N<=NB, large K)
 */
   if (M <= ATL_AMM_MAXMB && N <= ATL_AMM_MAXNB)
      return(Mjoin(PATL,ammm_IP)(TA, TB, M, N, K, alpha, A, lda, B, ldb,
                                 beta, C, ldc));
/*
 * Next two loop orderings are general case, so use whichever uses least
 * workspace
 */
#if 0
   if (M > N)
      return(Mjoin(PATL,ammmMNK)(TA, TB, M, N, K, alpha, A, lda, B, ldb,
                                 beta, C, ldc));
/*
 * This guy tries to allocate (M+NB)*K + NB^2 worskpace, so recursion
 * may be needed to keep it within allotted memory.
 */
   return(Mjoin(PATL,ammmNMK)(TA, TB, M, N, K, alpha, A, lda, B, ldb, 
                              beta, C, ldc));
#else
   if (M > N)
      return(Mjoin(PATL,ammmKMNK)(TA, TB, M, N, K, alpha, A, lda, B, ldb,
                                  beta, C, ldc));
   return(Mjoin(PATL,ammmKNMK)(TA, TB, M, N, K, alpha, A, lda, B, ldb, 
                               beta, C, ldc));
#endif
}
@ROUT ATL_ammm ATL_cammm
/*
 * Recur to get K below this value; this puts a ceiling on workspace and
 * usually improves performance (in huge problems, reduces TLB pressure)
 */
#define ATL_MAX_RK 3000


/*
 * This routine uses recursion to cut the dimensions of the matrices until
 * workspace requirements are low enough that a call to ATL_ammm succeeds
 */
void Mjoin(PATL,ammm)
(
   enum ATLAS_TRANS TA,
   enum ATLAS_TRANS TB,
   ATL_CSZT M,
   ATL_CSZT N,
   ATL_CSZT K,
   const SCALAR alpha,
   const TYPE *A,
   ATL_CSZT lda,
   const TYPE *B,
   ATL_CSZT ldb,
   const SCALAR beta,
   TYPE *C,
   ATL_CSZT ldc
)
{
   if (!M || !N)
      return;
/*
 * Cases where all we must do is possibly scale and return
 */
   if (SCALAR_IS_ZERO(alpha) || !K)
   {
      if (SCALAR_IS_ZERO(beta))
         Mjoin(PATL,gezero)(M, N, C, ldc);
      else if (!SCALAR_IS_ONE(beta))
         Mjoin(PATL,gescal)(M, N, beta, C, ldc);
      return;
   }
/*
 * Our stopping criteria is if ATL_ammm signals success in mallocing mem
 */
   if (K <= ATL_MAX_RK)
   {
      if(!ATL_ammm(TA, TB, M, N, K, alpha, A, lda, B, ldb, beta, C, ldc))
         return;
   }
/*
 * =========================================================================
 * Otherwise, problem too large, so we'll recursively divide its largest dim
 * =========================================================================
 */
/*
 * if K is tied for largest, cut it, since it reduces size of A & B
 * NOTE: C always uses only NB^2 workspace, so only A/B matters.
 */
   if (K > ATL_MAX_RK || (K >= N && K >= M))
   {
      const size_t kL=(K>>4)<<3, kR=K-kL;
@ROUT ATL_cammm `   const TYPE ONE[2] = {ATL_rone, ATL_rzero};`

      Mjoin(PATL,ammm)(TA, TB, M, N, kL, alpha, A, lda, B, ldb, beta, C, ldc);
      if (TA == AtlasNoTrans || TA == AtlasConj)
         A += (lda*kL)SHIFT;
      else
         A += kL SHIFT;
      if (TB == AtlasNoTrans)
         B += kL SHIFT;
      else
         B += (ldb*kL) SHIFT;
      Mjoin(PATL,ammm)(TA, TB, M, N, kR, alpha, A, lda, B, ldb, 
@ROUT ATL_ammm `                       ATL_rone, C, ldc);`
@ROUT ATL_cammm `                       ONE, C, ldc);`
   }
   else if (N >= M)  /* cutting N */
   {
      const size_t nL = (N>>1), nR = N-nL;
      Mjoin(PATL,ammm)(TA, TB, M, nL, K, alpha, A, lda, B, ldb, beta, C, ldc);
      if (TB == AtlasNoTrans || TB == AtlasConj)
         B += (ldb*nL)SHIFT;
      else 
         B += nL SHIFT;
      C += (ldc*nL)SHIFT;
      Mjoin(PATL,ammm)(TA, TB, M, nR, K, alpha, A, lda, B, ldb, beta, C, ldc);
   }
   else  /* cutting M */
   {
      const size_t mL = (M>>1), mR = M-mL;
      Mjoin(PATL,ammm)(TA, TB, mL, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
      if (TA == AtlasNoTrans || TA == AtlasConj)
         A += mL SHIFT;
      else
         A += (mL*lda)SHIFT;
      C += mL SHIFT;
      Mjoin(PATL,ammm)(TA, TB, mR, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
   }
}

void Mjoin(PATL,gemm)(const enum ATLAS_TRANS TA, const enum ATLAS_TRANS TB,
                      const int M, const int N, const int K, const SCALAR alpha,
                      const TYPE *A, const int lda, const TYPE *B, 
                      const int ldb, const SCALAR beta, TYPE *C, const int ldc)
{
   Mjoin(PATL,ammm)(TA, TB, M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
}
@ROUT atlas_simd.h
#ifndef ATLAS_SIMD_H
   #define  ATLAS_SIMD_H 1
/*
 * This header files contains wrappers to allow you to use SIMD vector
 * extensions in a very simplified way in a type-independent manner.
 * First argument is always destination.
 */
#if defined(ATL_AVXMAC) || defined(ATL_AVX)
   #include <immintrin.h>
   #if defined(SREAL) || defined(SCPLX)
      #if defined(ATL_VLEN) && ATL_VLEN != 8  /* VLEN OVERRIDE! */
         #if ATL_VLEN == 4
            #define ATL_VTYPE __m128
         #else
            #error "Only VLEN==4 or 8 supported for single precision AVX!"
         #endif
      #else
         #define ATL_VTYPE __m256
         #define ATL_VLEN 8
      #endif
      #define ATL_vzero(v_) v_ = _mm256_setzero_ps()
      #define ATL_vbcast(v_, p_) \
         v_ =  _mm256_broadcast_ss(p_);
      #define ATL_vuld(v_, p_) v_ = _mm256_loadu_ps(p_)
      #define ATL_vld(v_, p_) v_ = _mm256_load_ps(p_)
      #define ATL_vust(p_, v_) _mm256_storeu_ps(p_, v_)
      #define ATL_vst(p_, v_) _mm256_store_ps(p_, v_)
      #define ATL_vadd(d_, s1_, s2_) d_ =  _mm256_add_ps(s1_, s2_)
      #define ATL_vmul(d_, s1_, s2_) d_ =  _mm256_mul_ps(s1_, s2_)
      #ifdef ATL_AVXMAC
         #define ATL_vmac(d_, s1_, s2_) \
            d_ = _mm256_fmadd_ps(s1_, s2_, d_)
      #else
         #define ATL_vmac(d_, s1_, s2_) \
         { ATL_VTYPE t_; \
            t_ = _mm256_mul_ps(s1_, s2_); \
            d_ = _mm256_add_ps(t_, d_); \
         }
      #endif
   #else        /* double precision */
      #if defined(ATL_VLEN) && ATL_VLEN != 4  /* VLEN OVERRIDE! */
         #if (ATL_VLEN == 2)
            #define ATL_VTYPE __m128d
         #else
            #error "Only VLEN==2 or 4 supported for double precision AVX!"
         #endif
      #else
         #define ATL_VTYPE __m256d
         #define ATL_VLEN 4
      #endif
      #define ATL_vzero(v_) v_ = _mm256_setzero_pd()
      #define ATL_vbcast(v_, p_) v_ =  _mm256_broadcast_sd(p_)
      #define ATL_vuld(v_, p_) v_ = _mm256_loadu_pd(p_)
      #define ATL_vld(v_, p_) v_ = _mm256_load_pd(p_)
      #define ATL_vust(p_, v_) _mm256_storeu_pd(p_, v_)
      #define ATL_vst(p_, v_) _mm256_store_pd(p_, v_)
      #define ATL_vadd(d_, s1_, s2_) d_ =  _mm256_add_pd(s1_, s2_)
      #define ATL_vmul(d_, s1_, s2_) d_ =  _mm256_mul_pd(s1_, s2_)
      #ifdef ATL_AVXMAC
         #define ATL_vmac(d_, s1_, s2_) \
            d_ = _mm256_fmadd_pd(s1_, s2_, d_)
      #else
         #define ATL_vmac(d_, s1_, s2_) \
         { ATL_VTYPE t_; \
            t_ = _mm256_mul_pd(s1_, s2_); \
            d_ = _mm256_add_pd(t_, d_); \
         }
      #endif
   #endif
#elif defined(ATL_SSE2) && (defined(DREAL) || defined(DCPLX))
   #include <xmmintrin.h>
   #define ATL_VTYPE __m128d
   #if defined(ATL_VLEN) && ATL_VLEN != 2
      #error "VLEN == 2 only supported size for double precision SSE!"
   #elif !defined(ATL_VLEN)
      #define ATL_VLEN 2
   #endif
   #define ATL_vzero(v_) v_ = _mm_setzero_pd()
   #define ATL_vbcast(v_, p_) v_ =  _mm_load1_pd(p_)
   #define ATL_vuld(v_, p_) v_ = _mm_loadu_pd(p_)
   #define ATL_vld(v_, p_) v_ = _mm_load_pd(p_)
   #define ATL_vust(p_, v_) _mm_storeu_pd(p_, v_)
   #define ATL_vst(p_, v_) _mm_store_pd(p_, v_)
   #define ATL_vadd(d_, s1_, s2_) d_ =  _mm_add_pd(s1_, s2_)
   #define ATL_vmul(d_, s1_, s2_) d_ =  _mm_mul_pd(s1_, s2_)
   #define ATL_vmac(d_, s1_, s2_) \
   { ATL_VTYPE t_; \
      t_ = _mm_mul_pd(s1_, s2_); \
      d_ = _mm_add_pd(t_, d_); \
   }
#elif defined(ATL_SSE1)
   #include <xmmintrin.h>
   #define ATL_VTYPE __m128
   #if defined(ATL_VLEN) && ATL_VLEN != 4
      #error "VLEN == 4 only supported size for single precision SSE!"
   #elif !defined(ATL_VLEN)
      #define ATL_VLEN 4
   #endif
   #define ATL_vzero(v_) v_ = _mm_setzero_pd()
   #define ATL_vbcast(v_, p_) v_ =  _mm_load1_ps(p_)
   #define ATL_vuld(v_, p_) v_ = _mm_loadu_ps(p_)
   #define ATL_vld(v_, p_) v_ = _mm_load_ps(p_)
   #define ATL_vust(p_, v_) _mm_storeu_ps(p_, v_)
   #define ATL_vst(p_, v_) _mm_store_ps(p_, v_)
   #define ATL_vadd(d_, s1_, s2_) d_ =  _mm_add_ps(s1_, s2_)
   #define ATL_vmul(d_, s1_, s2_) d_ =  _mm_mul_ps(s1_, s2_)
   #define ATL_vmac(d_, s1_, s2_) \
   { ATL_VTYPE t_; \
      t_ = _mm_mul_ps(s1_, s2_); \
      d_ = _mm_add_ps(t_, d_); \
   }
#else
   #if defined(ATL_VLEN) && ATL_VLEN != 1
      #error "For systems without vector support, only ATL_VLEN=1 supported!"
   #elif !defined(ATL_VLEN)
      #define ATL_VLEN 1
   #endif
   #define ATL_VTYPE TYPE
   #define ATL_vbcast(v_, p_) v_ =  *(p_)
   #define ATL_vuld(v_, p_) v_ = *(p_)
   #define ATL_vld(v_, p_) v_ = *(p_)
   #define ATL_vust(p_, v_) *(p_) =  v_
   #define ATL_vst(p_, v_) *(p_) =  v_
   #define ATL_vadd(d_, s1_, s2_) d_ =  s1_ + s2_
   #define ATL_vmul(d_, s1_, s2_) d_ =  s1_ * s2_
   #define ATL_vmac(d_, s1_, s2_) d_ += s1_ * s2_
#endif
@iexp p 1 0 +
@iexp j 0 0 +
@iwhile p < 64
   #if ATL_VLEN == @(p)
      #define ATL_VLSH @(j)
      #if defined(SREAL) || defined(SCPLX)
         @iexp i @(p) 4 *
         #define ATL_VLENb @(i)
      #else
         @iexp i @(p) 8 *
         #define ATL_VLENb @(i)
      #endif
   #endif
   @iexp j @(j) 1 +
   @iexp p @(p) 2 *
@endiwhile

#endif  /* end multiple-inclusion guard */
@ROUT ATL_rk4n4
#include "atlas_misc.h"
#include "atlas_simd.h"
#if defined(__GNUC__) || \
    (defined(__STDC_VERSION__) && (__STDC_VERSION__/100 >= 1999))
   #define ATL_SINLINE static inline
#else
   #define ATL_SINLINE static
#endif
#if ATL_VLEN > 1
@define up @@
@whiledef up u
   @define ld @ATL_v@(up)ld@
   @define st @ATL_v@(up)st@
ATL_SINLINE void ATL_rk4n4_@(up)vec
(
   enum ATLAS_TRANS TB,
   ATL_CSZT M,
   const SCALAR alpha,
   const TYPE *A0,
   ATL_CSZT lda,
   const TYPE *B0,
   ATL_CSZT ldb,
   TYPE *C0,
   ATL_CSZT ldc
)
{
   ATL_VTYPE b00, b10, b20, b30, b01, b11, b21, b31;
   ATL_VTYPE b02, b12, b22, b32, b03, b13, b23, b33;
   const TYPE *A1=A0+lda, *A2=A1+lda, *A3=A2+lda;
   TYPE *C1=C0+ldc, *C2=C1+ldc, *C3=C2+ldc;
   register int i;
   if (TB == AtlasNoTrans)
   {
      const TYPE *B1=B0+ldb, *B2=B1+ldb, *B3=B2+ldb;
      ATL_vbcast(b00, B0);
      ATL_vbcast(b01, B1);
      ATL_vbcast(b02, B2);
      ATL_vbcast(b03, B3);
      ATL_vbcast(b10, B0+1);
      ATL_vbcast(b11, B1+1);
      ATL_vbcast(b12, B2+1);
      ATL_vbcast(b13, B3+1);
      ATL_vbcast(b20, B0+2);
      ATL_vbcast(b21, B1+2);
      ATL_vbcast(b22, B2+2);
      ATL_vbcast(b23, B3+2);
      ATL_vbcast(b30, B0+3);
      ATL_vbcast(b31, B1+3);
      ATL_vbcast(b32, B2+3);
      ATL_vbcast(b33, B3+3);
   }
   else /* TB == AtlasTrans, B NxK */
   {
      const TYPE *B1=B0+ldb, *B2=B1+ldb, *B3=B2+ldb;
      ATL_vbcast(b00, B0);
      ATL_vbcast(b10, B1);
      ATL_vbcast(b20, B2);
      ATL_vbcast(b30, B3);
      ATL_vbcast(b01, B0+1);
      ATL_vbcast(b11, B1+1);
      ATL_vbcast(b21, B2+1);
      ATL_vbcast(b31, B3+1);
      ATL_vbcast(b02, B0+2);
      ATL_vbcast(b12, B1+2);
      ATL_vbcast(b22, B2+2);
      ATL_vbcast(b32, B3+2);
      ATL_vbcast(b03, B0+3);
      ATL_vbcast(b13, B1+3);
      ATL_vbcast(b23, B2+3);
      ATL_vbcast(b33, B3+3);
   }
   if (alpha != 1.0)
   {
      ATL_VTYPE al;
      ATL_vbcast(al, &alpha);
      ATL_vmul(b00, b00, al);
      ATL_vmul(b10, b10, al);
      ATL_vmul(b20, b20, al);
      ATL_vmul(b30, b30, al);
      ATL_vmul(b01, b01, al);
      ATL_vmul(b11, b11, al);
      ATL_vmul(b21, b21, al);
      ATL_vmul(b31, b31, al);
      ATL_vmul(b02, b02, al);
      ATL_vmul(b12, b12, al);
      ATL_vmul(b22, b22, al);
      ATL_vmul(b32, b32, al);
      ATL_vmul(b03, b03, al);
      ATL_vmul(b13, b13, al);
      ATL_vmul(b23, b23, al);
      ATL_vmul(b33, b33, al);
   }
   for (i=0; i < M; i += ATL_VLEN)
   {
      ATL_VTYPE c0, c1, c2, c3, a0;
      @(ld)(c0, C0+i);
      @(ld)(c1, C1+i);
      @(ld)(c2, C2+i);
      @(ld)(c3, C3+i);

      @(ld)(a0, A0+i);
      ATL_vmac(c0, b00, a0);
      ATL_vmac(c1, b01, a0);
      ATL_vmac(c2, b02, a0);
      ATL_vmac(c3, b03, a0);
      @(ld)(a0, A1+i);
      ATL_vmac(c0, b10, a0);
      ATL_vmac(c1, b11, a0);
      ATL_vmac(c2, b12, a0);
      ATL_vmac(c3, b13, a0);
      @(ld)(a0, A2+i);
      ATL_vmac(c0, b20, a0);
      ATL_vmac(c1, b21, a0);
      ATL_vmac(c2, b22, a0);
      ATL_vmac(c3, b23, a0);
      @(ld)(a0, A3+i);
      ATL_vmac(c0, b30, a0);
      ATL_vmac(c1, b31, a0);
      ATL_vmac(c2, b32, a0);
      ATL_vmac(c3, b33, a0);

      @(st)(C0+i, c0);
      @(st)(C1+i, c1);
      @(st)(C2+i, c2);
      @(st)(C3+i, c3);
   }
}
   @undef ld
   @undef st
@endwhile
#endif

ATL_SINLINE void ATL_rk4n4
(
   enum ATLAS_TRANS TB,
   ATL_CSZT M,
   const SCALAR alpha,
   const TYPE *A0,
   ATL_CSZT lda,
   const TYPE *B0,
   ATL_CSZT ldb,
   TYPE *C0,
   ATL_CSZT ldc
)

/*
 * This special-case code used for LU, only called when:
 *   TA=AtlasNoTrans, N == K == 4, beta == 1.0
 */
{
   TYPE b00, b10, b20, b30, b01, b11, b21, b31;
   TYPE b02, b12, b22, b32, b03, b13, b23, b33;
   const TYPE *A1=A0+lda, *A2=A1+lda, *A3=A2+lda;
   TYPE *C1=C0+ldc, *C2=C1+ldc, *C3=C2+ldc;
   register int i;

   if (TB == AtlasNoTrans)
   {
      const TYPE *B1=B0+ldb, *B2=B1+ldb, *B3=B2+ldb;
      b00 = alpha * *B0;
      b01 = alpha * *B1;
      b02 = alpha * *B2;
      b03 = alpha * *B3;
      b10 = alpha * B0[1];
      b11 = alpha * B1[1];
      b12 = alpha * B2[1];
      b13 = alpha * B3[1];
      b20 = alpha * B0[2];
      b21 = alpha * B1[2];
      b22 = alpha * B2[2];
      b23 = alpha * B3[2];
      b30 = alpha * B0[3];
      b31 = alpha * B1[3];
      b32 = alpha * B2[3];
      b33 = alpha * B3[3];
   }
   else  /* B == AtlasTrans; B is NxK */
   {
      const TYPE *B1=B0+ldb, *B2=B1+ldb, *B3=B2+ldb;
      b00 = alpha * *B0;
      b10 = alpha * *B1;
      b20 = alpha * *B2;
      b30 = alpha * *B3;
      b01 = alpha * B0[1];
      b11 = alpha * B1[1];
      b21 = alpha * B2[1];
      b31 = alpha * B3[1];
      b02 = alpha * B0[2];
      b12 = alpha * B1[2];
      b22 = alpha * B2[2];
      b32 = alpha * B3[2];
      b03 = alpha * B0[3];
      b13 = alpha * B1[3];
      b23 = alpha * B2[3];
      b33 = alpha * B3[3];
   }
   for (i=0; i < M; i++)
   {
      const register TYPE a0=A0[i], a1=A1[i], a2=A2[i], a3=A3[i];
      TYPE register c0=C0[i], c1=C1[i], c2=C2[i], c3=C3[i];
      c0 += b00*a0;
      c1 += b01*a0;
      c2 += b02*a0;
      c3 += b03*a0;
      c0 += b10*a1;
      c1 += b11*a1;
      c2 += b12*a1;
      c3 += b13*a1;
      c0 += b20*a2;
      c1 += b21*a2;
      c2 += b22*a2;
      c3 += b23*a2;
      c0 += b30*a3;
      c1 += b31*a3;
      c2 += b32*a3;
      c3 += b33*a3;
      C0[i] = c0;
      C1[i] = c1;
      C2[i] = c2;
      C3[i] = c3;
   }
}

int Mjoin(PATL,rk4n4)
(
   enum ATLAS_TRANS TB,
   ATL_CSZT M,
   const SCALAR alpha,
   const TYPE *A0,
   ATL_CSZT lda,
   const TYPE *B0,
   ATL_CSZT ldb,
   TYPE *C0,
   ATL_CSZT ldc
)
{
   #if ATL_VLEN < 2
      ATL_rk4n4(TB, M, alpha, A0, lda, B0, ldb, C0, ldc);
   #else
      const int vmod = (ATL_VLEN-1);
      int Mp=0, Mv, Mr;  /* peel, vector, remainder */
      int ALLALIGN=0;
      if (!((ldc&vmod) | (lda&vmod)))
      {
         const size_t VMOD = ((size_t)(ATL_VLEN-1));
         size_t a0, a1;
         int gap0, gap;
         a0 = (size_t) C0;
         a1 = (size_t) A0;
         a0 = ATL_DivBySize(a0);
         a1 = ATL_DivBySize(a1);
         gap0 = a0 & VMOD;
         gap  = a1 & VMOD;
         if (gap0 == gap)
         {
            ALLALIGN=1;
            if (gap)
            {
               Mp = ATL_VLEN - gap;
               Mp = Mmin(Mp, M);
            }
         }
      }
      Mr = M - Mp;
      Mv = Mr & ~vmod;
      Mr -= Mv;

      if (ALLALIGN)
      {
         if (Mp)
         {
            ATL_rk4n4(TB, Mp, alpha, A0, lda, B0, ldb, C0, ldc);
            A0 += Mp; C0 += Mp;
         }
         if (Mv)
         {
            ATL_rk4n4_vec(TB, Mv, alpha, A0, lda, B0, ldb, C0, ldc);
            A0 += Mv; C0 += Mv;
         }
      }
      else if (Mv)
      {
         ATL_rk4n4_uvec(TB, Mv, alpha, A0, lda, B0, ldb, C0, ldc);
         A0 += Mv; C0 += Mv;
      }
      if (Mr)
         ATL_rk4n4(TB, Mr, alpha, A0, lda, B0, ldb, C0, ldc);
   #endif
   return(0);
}
@ROUT ATL_ammm_rk2
#include "atlas_misc.h"
#include "atlas_lvl2.h"
#include "atlas_level1.h"
/*
 * This is special-case code that handles rank-2 update by calling GER2
 */
int Mjoin(PATL,ammm_rk2)
(
   enum ATLAS_TRANS TA,
   enum ATLAS_TRANS TB,
   ATL_CSZT M,
   ATL_CSZT N,
   const SCALAR alpha,
   const TYPE *A,
   ATL_CSZT lda,
   const TYPE *B,
   ATL_CSZT ldb,
   const SCALAR beta,
   TYPE *C,
   ATL_CSZT ldc
)
{
   #ifdef DREAL
      const int MB=512, NB=32;
   #else /* SREAL */
      const int MB=512, NB=64;
   #endif
   void *vp;
   TYPE *x, *y, *w, *z;
   size_t j;
   ATL_CSZT incC = NB*ldc;

/*
 * If beta is one, can handle by one call to ger2
 */
   if (SCALAR_IS_ONE(beta))
   {
      if (TA == AtlasNoTrans)
      {
         if (TB == AtlasNoTrans)
            Mjoin(PATL,ger2)(M, N, alpha, A, 1, B, ldb, alpha, A+lda, 1,
                             B+1, ldb, C, ldc);
         else
            Mjoin(PATL,ger2)(M, N, alpha, A, 1, B, 1, alpha, A+lda, 1,
                             B+ldb, 1, C, ldc);
      }
      else if (TB == AtlasNoTrans)
         Mjoin(PATL,ger2)(M, N, alpha, A, lda, B, ldb, alpha, A+1, lda,
                          B+1, ldb, C, ldc);
      else
         Mjoin(PATL,ger2)(M, N, alpha, A, lda, B, 1, alpha, A+1, lda,
                          B+ldb, 1, C, ldc);
      return(0);
   }
/*
 * Later on, do smart think like copy only MB/NB at a time, and don't copy
 * at all if vectors are contiguous, but right now, always do copy up-front
 * so loop does not have to worry about TA/TB; this is a O(N) cost in N^2 alg
 */
   vp = malloc(2*ATL_MulBySize(M+N)+4*ATL_Cachelen);
   if (!vp)
      return(1);
   x = ATL_AlignPtr(vp);
   y = x + M;
   y = ATL_AlignPtr(y);
   w = y + N;
   w = ATL_AlignPtr(w);
   z = w + M;
   z = ATL_AlignPtr(z);
   if (TA == AtlasNoTrans)
   {
      Mjoin(PATL,copy)(M, A, 1, x, 1);
      Mjoin(PATL,copy)(M, A+lda, 1, w, 1);
   }
   else
   {
      Mjoin(PATL,copy)(M, A, lda, x, 1);
      Mjoin(PATL,copy)(M, A+1, lda, w, 1);
   }
   if (SCALAR_IS_ONE(alpha))
   {
      if (TB == AtlasNoTrans)
      {
         Mjoin(PATL,copy)(N, B, ldb, y, 1);
         Mjoin(PATL,copy)(N, B+1, ldb, z, 1);
      }
      else
      {
         Mjoin(PATL,copy)(N, B, 1, y, 1);
         Mjoin(PATL,copy)(N, B+ldb, 1, z, 1);
      }
   }
   else
   {
      if (TB == AtlasNoTrans)
      {
         Mjoin(PATL,cpsc)(N, alpha, B, ldb, y, 1);
         Mjoin(PATL,cpsc)(N, alpha, B+1, ldb, z, 1);
      }
      else
      {
         Mjoin(PATL,cpsc)(N, alpha, B, 1, y, 1);
         Mjoin(PATL,cpsc)(N, alpha, B+ldb, 1, z, 1);
      }
   }
   for (j=0; j < N; j += NB, C += incC)
   {
      size_t i, nb = N-j;
      nb = (nb >= NB) ? NB : nb;
      for (i=0; i < M; i += MB)
      {
         size_t mb = M-i;
         mb = (mb >= MB) ? MB : mb;
         Mjoin(PATL,gescal)(mb, nb, beta, C+i, ldc);
         Mjoin(PATL,ger2)(mb, nb, ATL_rone, x+i, 1, y+j, 1, ATL_rone, 
                          w+i, 1, z+j, 1, C+i, ldc);
      }
   }
   free(vp);
   return(0);
}
@ROUT ATL_cammm_rk2
#include "atlas_misc.h"
#include "atlas_lvl2.h"
#include "atlas_level1.h"
/*
 * This is special-case code that handles rank-2 update by calling GER2
 */
int Mjoin(PATL,ammm_rk2)
(
   enum ATLAS_TRANS TA,
   enum ATLAS_TRANS TB,
   ATL_CSZT M,
   ATL_CSZT N,
   const SCALAR alpha,
   const TYPE *A,
   ATL_CSZT lda,
   const TYPE *B,
   ATL_CSZT ldb,
   const SCALAR beta,
   TYPE *C,
   ATL_CSZT ldc
)
{
   #ifdef DCPLX
      const int MB=512, NB=16;
   #else /* SCPLX */
      const int MB=512, NB=32;
   #endif
   void *vp;
   TYPE *x, *y, *w, *z;
   size_t j;
   const TYPE ONE[2] = {ATL_rone, ATL_rzero};
   ATL_CSZT lda2=lda+lda, ldb2=ldb+ldb, ldc2=ldc+ldc, incC = NB*ldc2;

/*
 * If beta is one, can handle by one call to ger2
 */
   if (SCALAR_IS_ONE(beta) && 0)
   {
      if (TA == AtlasNoTrans)
      {
         if (TB == AtlasNoTrans)
            Mjoin(PATL,ger2u)(M, N, alpha, A, 1, B, ldb, alpha, A+lda2, 1,
                              B+2, ldb, C, ldc);
         else if (TB == AtlasConj)
            Mjoin(PATL,ger2c)(M, N, alpha, A, 1, B, ldb, alpha, A+lda2, 1,
                              B+2, ldb, C, ldc);
         else if (TB == AtlasTrans)
            Mjoin(PATL,ger2u)(M, N, alpha, A, 1, B, 1, alpha, A+lda2, 1,
                              B+ldb2, 1, C, ldc);
         else /* if (TB == AtlasConjTrans) */
            Mjoin(PATL,ger2c)(M, N, alpha, A, 1, B, 1, alpha, A+lda2, 1,
                              B+ldb2, 1, C, ldc);
      }
      else if (TA == AtlasTrans)
      {
         if (TB == AtlasNoTrans)
            Mjoin(PATL,ger2u)(M, N, alpha, A, lda, B, ldb, alpha, A+2, lda,
                              B+2, ldb, C, ldc);
         else if (TB == AtlasConj)
            Mjoin(PATL,ger2c)(M, N, alpha, A, lda, B, ldb, alpha, A+2, lda,
                              B+2, ldb, C, ldc);
         else if (TB == AtlasTrans)
            Mjoin(PATL,ger2u)(M, N, alpha, A, lda, B, 1, alpha, A+2, lda,
                              B+ldb2, 1, C, ldc);
         else if (TB == AtlasConjTrans)
            Mjoin(PATL,ger2c)(M, N, alpha, A, lda, B, 1, alpha, A+2, lda,
                              B+ldb2, 1, C, ldc);
      }
/*
 *    If A must be conjugated, copy it
 */
      else  /* TA == AtlasConj || TA == AtlasConjTrans */
      {
         vp = malloc((ATL_MulBySize(M)+ATL_Cachelen)<<1);
         if (!vp)
           return(2);
         x = ATL_AlignPtr(vp);
         w = x + M + M;
         w = ATL_AlignPtr(w);
         if (SCALAR_IS_ONE(alpha))
         {
            if (TA == AtlasConj)
            {
               Mjoin(PATL,copyConj)(M, A, 1, x, 1);
               Mjoin(PATL,copyConj)(M, A+lda2, 1, w, 1);
            }
            else /* if (TA == AtlasConjTrans) */
            {
               Mjoin(PATL,copyConj)(M, A, lda, x, 1);
               Mjoin(PATL,copyConj)(M, A+2, lda, w, 1);
            }
         }
         else
         {
            if (TA == AtlasConj)
            {
               Mjoin(PATL,moveConj)(M, alpha, A, 1, x, 1);
               Mjoin(PATL,moveConj)(M, alpha, A+lda2, 1, w, 1);
            }
            else /* if (TA == AtlasConjTrans) */
            {
               Mjoin(PATL,moveConj)(M, alpha, A, lda, x, 1);
               Mjoin(PATL,moveConj)(M, alpha, A+2, lda, w, 1);
            }
         }
         if (TB == AtlasNoTrans)
            Mjoin(PATL,ger2u)(M, N, ONE, x, 1, B, ldb, ONE, w, 1,
                              B+2, ldb, C, ldc);
         else if (TB == AtlasConj)
            Mjoin(PATL,ger2c)(M, N, ONE, x, 1, B, ldb, ONE, w, 1,
                              B+2, ldb, C, ldc);
         else if (TB == AtlasTrans)
            Mjoin(PATL,ger2u)(M, N, ONE, x, 1, B, 1, ONE, w, 1,
                              B+ldb2, 1, C, ldc);
         else /* if (TB == AtlasConjTrans) */
            Mjoin(PATL,ger2c)(M, N, ONE, x, 1, B, 1, ONE, w, 1,
                              B+ldb2, 1, C, ldc);
         free(vp);
      }
      return(0);
   }
/*
 * Later on, do smart think like copy only MB/NB at a time, and don't copy
 * at all if vectors are contiguous, but right now, always do copy up-front
 * so loop does not have to worry about TA/TB; this is a O(N) cost in N^2 alg
 */
   vp = malloc(2*ATL_MulBySize(M+N)+4*ATL_Cachelen);
   if (!vp)
      return(1);
   x = ATL_AlignPtr(vp);
   y = x + M + M;
   y = ATL_AlignPtr(y);
   w = y + N + N;
   w = ATL_AlignPtr(w);
   z = w + M + M;
   z = ATL_AlignPtr(z);
   if (TA == AtlasNoTrans)
   {
      Mjoin(PATL,copy)(M, A, 1, x, 1);
      Mjoin(PATL,copy)(M, A+lda2, 1, w, 1);
   }
   else if (TA == AtlasConj)
   {
      Mjoin(PATL,copyConj)(M, A, 1, x, 1);
      Mjoin(PATL,copyConj)(M, A+lda2, 1, w, 1);
   }
   else if (TA == AtlasTrans)
   {
      Mjoin(PATL,copy)(M, A, lda, x, 1);
      Mjoin(PATL,copy)(M, A+2, lda, w, 1);
   }
   else if (TA == AtlasConjTrans)
   {
      Mjoin(PATL,copyConj)(M, A, lda, x, 1);
      Mjoin(PATL,copyConj)(M, A+2, lda, w, 1);
   }
   if (SCALAR_IS_ONE(alpha))
   {
      if (TB == AtlasNoTrans)
      {
         Mjoin(PATL,copy)(N, B, ldb, y, 1);
         Mjoin(PATL,copy)(N, B+2, ldb, z, 1);
      }
      else if (TB == AtlasConj)
      {
         Mjoin(PATL,copyConj)(N, B, ldb, y, 1);
         Mjoin(PATL,copyConj)(N, B+2, ldb, z, 1);
      }
      else if (TB == AtlasTrans)
      {
         Mjoin(PATL,copy)(N, B, 1, y, 1);
         Mjoin(PATL,copy)(N, B+ldb2, 1, z, 1);
      }
      else if (TB == AtlasConjTrans)
      {
         Mjoin(PATL,copyConj)(N, B, 1, y, 1);
         Mjoin(PATL,copyConj)(N, B+ldb2, 1, z, 1);
      }
   }
   else  /* alpha non-one; must apply */
   {
      if (TB == AtlasNoTrans)
      {
         Mjoin(PATL,cpsc)(N, alpha, B, ldb, y, 1);
         Mjoin(PATL,cpsc)(N, alpha, B+2, ldb, z, 1);
      }
      else if (TB == AtlasConj)
      {
         Mjoin(PATL,moveConj)(N, alpha, B, ldb, y, 1);
         Mjoin(PATL,moveConj)(N, alpha, B+2, ldb, z, 1);
      }
      else if (TB == AtlasTrans)
      {
         Mjoin(PATL,cpsc)(N, alpha, B, 1, y, 1);
         Mjoin(PATL,cpsc)(N, alpha, B+ldb2, 1, z, 1);
      }
      else /* if (TB == AtlasConjTrans) */
      {
         Mjoin(PATL,moveConj)(N, alpha, B, 1, y, 1);
         Mjoin(PATL,moveConj)(N, alpha, B+ldb2, 1, z, 1);
      }
   }
   for (j=0; j < N; j += NB, C += incC)
   {
      size_t i, nb = N-j;
      nb = (nb >= NB) ? NB : nb;
      for (i=0; i < M; i += MB)
      {
         size_t mb = M-i;
         mb = (mb >= MB) ? MB : mb;
         Mjoin(PATL,gescal)(mb, nb, beta, C+i+i, ldc);
         Mjoin(PATL,ger2u)(mb, nb, ONE, x+i+i, 1, y+j+j, 1, ONE,
                           w+i+i, 1, z+j+j, 1, C+i+i, ldc);
      }
   }
   free(vp);
   return(0);
}
@ROUT ATL_ammmREC
#include "atlas_misc.h"
#include Mstr(Mjoin(AMM_PRE,_sum.h))

typedef struct ammrec ammrec_t;
struct ammrec
{
   cm2am_t a2blk, b2blk;
   ablk2cmat_t blk2c;
   ammkern_t amm_b0, amm_b1, amm_k1_b0, amm_k1_b1;
   size_t lda, ldb, ldc, incAm, incAk, incBk, incBn, incCn, incCm;
   TYPE alpA, alpB, alpC, beta;
   int mbkb, kbnb, mbnb, nmu, nnu, nmuF, nnuF;
   int mb, nb, kb, KB0, mr, nr, kr;
};


#define v_kp 1
#define v_np 2
#define v_mp 4
#define v_cpA 8
#define v_cpB 16
#define v_cpC 32
#define v_lwC 64  /* last guy to update C must write it out */
#define v_nmA 128 /* don't move A ptr */
#define v_nmB 256 /* don't move B ptr */
#define v_nmC 512 /* don't move C ptr */

#define b_kp 0
#define b_np 1
#define b_mp 2
#define b_cpA 3
#define b_cpB 4
#define b_cpC 5
#define b_lwC 6 
#define b_nmA 7
#define b_nmB 8
#define b_nmC 9 

@beginskip
static void ammmRECf  /* no partial blocks */
(
   const ammrec_t *pd,
   int nmblks,
   int nnblks,
   int nkblks,
   int flag, /* bits: 0:kp, 1:np, 2:mp, 3:cpA, 4:cpyB, 5:cpyC */
   const TYPE *A,
   const TYPE *B, 
   TYPE *C,
   TYPE *a,
   TYPE *b,
   TYPE *c
)
{
/*
 * If only one block remains, stop and do multiply
 */
   ATL_assert((flag & (v_mp|v_np|v_kp)) == 0)
//   if ((nmblks|nnblks|nkblks) == 1)
   if (nmblks == 1 && nnblks == 1 && nkblks == 1)
   {
      TYPE *an = (flag & v_nmA) ? a : a+pd->mbkb;
      TYPE *bn = (flag & v_nmB) ? b : b+pd->kbnb;
      TYPE *cn = (flag & v_nmC) ? c : c+pd->mbnb;
      const ammkern_t amm = (flag & v_cpC) ? pd->amm_b0 : pd->amm_b1;
      if (flag & v_cpA)
         pd->a2blk(pd->kb, pd->mb, pd->alpA, A, pd->lda, a);
      if (flag & v_cpB)
         pd->b2blk(pd->kb, pd->nb, pd->alpB, B, pd->ldb, b);
      amm(pd->nmu, pd->nnu, pd->kb, a, b, c, an, bn, cn);
      if (flag & v_lwC) 
         pd->blk2c(pd->mb, pd->nb, pd->alpC, c, pd->beta, C, pd->ldc);
   }
   else if (nkblks > nmblks && nkblks > nnblks)  /* split K */
   {
      const int nR=(nkblks>>1), nL = nkblks-nR;
      int flg = flag & ~(v_nmA|v_nmB|v_nmC);  /* only one guy doesn't move */
      ammmRECf(pd, nmblks, nnblks, nL, (flag & ~(v_nmA+v_nmB+v_lwC))|v_nmC,
               A, B, C, a, b, c);
      flg = flag & ~v_cpC;
      if (nR == 1)
      {
         if (flag&v_lwC)
            flg |= v_lwC;
         else
            flg &= ~v_lwC;
      }
      ammmRECf(pd, nmblks, nnblks, nR, flg, A+nL*pd->incAk, B+nL*pd->incBk, C,
               a+nL*nmblks*pd->mbkb, b+nL*nnblks*pd->kbnb, c);
   }
   else if (nnblks > nmblks) /* split N */
   {
      const int nR=(nnblks>>1), nL = nnblks-nR;
      ammmRECf(pd, nmblks, nL, nkblks, (flag & ~(v_nmB+v_nmC))|v_nmA, 
               A, B, C, a, b, c);
      ammmRECf(pd, nmblks, nR, nkblks, flag & ~v_cpA,
               A, B+nL*pd->incBn, C+pd->incCn*nL, 
               a, b+nL*nkblks*pd->kbnb, c+nL*nmblks*pd->mbnb);
   }
   else                      /* split M */
   {
      const int nR=(nmblks>>1), nL = nmblks-nR;
      ammmRECf(pd, nL, nnblks, nkblks, (flag & ~(v_nmA+v_nmC))|v_nmB, 
               A, B, C, a, b, c);
      ammmRECf(pd, nR, nnblks, nkblks, flag & ~v_cpB,
               A+nL*pd->incAm, B, C+pd->mb*nL, 
               a+nL*nkblks*pd->mbkb, b, c+nL*nnblks*pd->mbnb);
   }
}
@endskip

static void ammmRECf /* no partial blocks */
(
   const ammrec_t *pd,
   int nmblks,
   int nnblks,
   int nkblks,
   int flag, /* bits: 0:kp, 1:np, 2:mp, 3:cpA, 4:cpyB, 5:cpyC */
   const TYPE *A,
   const TYPE *B,
   TYPE *C,
   TYPE *a,
   TYPE *b,
   TYPE *c
)
{
@skip   ATL_assert((flag & (v_mp|v_np|v_kp)) == 0)
/*
 * Stop recursion and do multiply when only 1 block is left
 */
   if (nmblks == 1 && nnblks == 1 && nkblks == 1)
   {
      TYPE *an = (flag & v_nmA) ? a : a+pd->mbkb;
      TYPE *bn = (flag & v_nmB) ? b : b+pd->kbnb;
      TYPE *cn = (flag & v_nmC) ? c : c+pd->mbnb;
      const ammkern_t amm = (flag & v_cpC) ? pd->amm_b0 : pd->amm_b1;
      if (flag & v_cpA)
         pd->a2blk(pd->kb, pd->mb, pd->alpA, A, pd->lda, a);
      if (flag & v_cpB)
         pd->b2blk(pd->kb, pd->nb, pd->alpB, B, pd->ldb, b);
      amm(pd->nmu, pd->nnu, pd->kb, a, b, c, an, bn, cn);
      if (flag & v_lwC)
         pd->blk2c(pd->mb, pd->nb, pd->alpC, c, pd->beta, C, pd->ldc);
   }
   else if (nnblks >= nkblks && nnblks >= nmblks)   /* recursively divide N */
   {
      const int nR=(nnblks>>1), nL = nnblks-nR;
      ammmRECf(pd, nmblks, nL, nkblks, (flag|v_nmA) & ~(v_nmB+v_nmC), 
               A, B, C, a, b, c);
      ammmRECf(pd, nmblks, nR, nkblks, flag & ~v_cpA,
              A, B+nL*pd->incBn, C+pd->incCn*nL,
              a, b+nL*nkblks*pd->kbnb, c+nL*nmblks*pd->mbnb);
   }
   else if (nmblks >= nkblks)                       /* recursively divide M */
   {
      const int nR=(nmblks>>1), nL = nmblks-nR;
      ammmRECf(pd, nL, nnblks, nkblks, (flag|v_nmB) & ~(v_nmA+v_nmC), 
               A, B, C, a, b, c);
      ammmRECf(pd, nR, nnblks, nkblks, flag & ~v_cpB,
              A+nL*pd->incAm, B, C+pd->mb*nL,
              a+nL*nkblks*pd->mbkb, b, c+nL*nnblks*pd->mbnb);
   }
   else                                             /* recursively divide K */
   {
      const int nR=(nkblks>>1), nL = nkblks-nR;
      ammmRECf(pd, nmblks, nnblks, nL, (flag|v_nmC) & ~(v_nmA+v_nmB+v_lwC), 
               A, B, C, a, b, c);
      ammmRECf(pd, nmblks, nnblks, nR, flag & ~v_cpC, 
               A+nL*pd->incAk, B+nL*pd->incBk, C,
               a+nL*nmblks*pd->mbkb, b+nL*nnblks*pd->kbnb, c);
   }
}

static void ammmREC  /* partial blocks are possible */
(
   const ammrec_t *pd,
   int nmblks,
   int nnblks,
   int nkblks,
   int flag, /* bits: 0:kp, 1:np, 2:mp, 3:cpA, 4:cpyB, 5:cpyC */
   const TYPE *A,
   const TYPE *B,
   TYPE *C,
   TYPE *a,
   TYPE *b,
   TYPE *c
)
{
/*
 * If I only have one possibly partial block left.  Equivalent to:
 * if ( ((nmblks == 1 && !(flag&v_mp)) || nmblks == 0) &&
 *      ((nnblks == 1 && !(flag&v_np)) || nnblks == 0) &&
 *      ((nkblks == 1 && !(flag&v_kp)) || nkblks == 0) )
 */
   if (nmblks < 2 && nnblks < 2 && nkblks < 2 &&
       nmblks != ((flag>>b_mp)&1) &&
       nnblks != ((flag>>b_np)&1) &&
       nkblks != ((flag>>b_kp)&1))
   {
      TYPE *an = (flag & v_nmA) ? a : a+pd->mbkb;
      TYPE *bn = (flag & v_nmB) ? b : b+pd->kbnb;
      TYPE *cn = (flag & v_nmC) ? c : c+pd->mbnb;
/*
 *    If we aren't doing K-cleanup, can always use fastest kernels
 */
      if (!(flag & v_kp))
      {
         const ammkern_t amm = (flag & v_cpC) ? pd->amm_b0 : pd->amm_b1;
         if (!(flag & (v_mp+v_np)))   /* one full block to multiply */
         {
            if (flag & v_cpA)
               pd->a2blk(pd->kb, pd->mb, pd->alpA, A, pd->lda, a);
            if (flag & v_cpB)
               pd->b2blk(pd->kb, pd->nb, pd->alpB, B, pd->ldb, b);
            amm(pd->nmu, pd->nnu, pd->kb, a, b, c, an, bn, cn);
            if (flag & v_lwC)
               pd->blk2c(pd->mb, pd->nb, pd->alpC, c, pd->beta, C, pd->ldc);
         }
         else
         {
            int nmu=pd->nmu, nnu=pd->nnu, m=pd->mb, n=pd->nb, kb=pd->kb;
            if (flag & v_mp)
            {
               nmu = pd->nmuF;
               m = pd->mr;
            }
            if (flag & v_np)
            {
               nnu = pd->nnuF;
               n = pd->nr;
            }
            if (flag & v_cpA)
               pd->a2blk(kb, m, pd->alpA, A, pd->lda, a);
            if (flag & v_cpB)
               pd->b2blk(kb, n, pd->alpB, B, pd->ldb, b);
            amm(nmu, nnu, kb, a, b, c, an, bn, cn);
            if (flag & v_lwC)
               pd->blk2c(m, n, pd->alpC, c, pd->beta, C, pd->ldc);
         }
      }
      else /* if (flag & (v_mp|v_np|v_kp))   partial block to multiply */
      {
         const ammkern_t amm = (flag & v_cpC) ? pd->amm_k1_b0 : pd->amm_k1_b1;
         const int nmu = (nmblks) ? pd->nmu : pd->nmuF;
         const int m = (nmblks) ? pd->mb : pd->mr;
         const int nnu = (nnblks) ? pd->nnu : pd->nnuF;
         const int n = (nnblks) ? pd->nb : pd->nr;
         const int k = (nkblks) ? pd->kb : pd->kr;
         const int KBF = (nkblks) ? k : pd->KB0;

         if (flag & v_cpA)
            pd->a2blk(k, m, pd->alpA, A, pd->lda, a);
         if (flag & v_cpB)
            pd->b2blk(k, n, pd->alpB, B, pd->ldb, b);
         amm(nmu, nnu, KBF, a, b, c, an, bn, cn);
         if (flag & v_lwC)
            pd->blk2c(m, n, pd->alpC, c, pd->beta, C, pd->ldc);
      }
   }
   else if (nnblks >= nkblks && nnblks >= nmblks &&           /* recursively */
            (nnblks > 1 || (flag&v_np)))                      /* divide N    */
   {
      const int nR=(nnblks>>1), nL = nnblks-nR;
      const size_t mblks=(flag&v_mp) ? nmblks+1 : nmblks;
      const size_t kblks=(flag&v_kp) ? nkblks+1 : nkblks;
      const int flg = (flag|v_nmA) & ~(v_np+v_nmB+v_nmC);
      if (flag & (v_mp+v_kp))
         ammmREC(pd, nmblks, nL, nkblks, flg, A, B, C, a, b, c);
      else
         ammmRECf(pd, nmblks, nL, nkblks, flg, A, B, C, a, b, c);
      ammmREC(pd, nmblks, nR, nkblks, flag & ~v_cpA,
              A, B+nL*pd->incBn, C+pd->incCn*nL,
              a, b+nL*kblks*pd->kbnb, c+nL*mblks*pd->mbnb);
   }
   else if (nmblks >= nkblks && (nmblks > 1 || (flag&v_mp)))  /* recursively */
   {                                                          /* divide M    */
      const int nR=(nmblks>>1), nL = nmblks-nR;
      const size_t nblks=(flag&v_np) ? nnblks+1 : nnblks;
      const size_t kblks=(flag&v_kp) ? nkblks+1 : nkblks;
      const int flg = (flag|v_nmB) & ~(v_mp+v_nmA+v_nmC);
      if (flag&(v_np+v_kp))
         ammmREC(pd, nL, nnblks, nkblks, flg, A, B, C, a, b, c);
      else
         ammmRECf(pd, nL, nnblks, nkblks, flg, A, B, C, a, b, c);
      ammmREC(pd, nR, nnblks, nkblks, flag & ~v_cpB,
              A+nL*pd->incAm, B, C+pd->mb*nL,
              a+nL*kblks*pd->mbkb, b, c+nL*nblks*pd->mbnb);
   }
   else                                                       /* recursively */
   {                                                          /* divide K    */
      const int nR=(nkblks>>1), nL = nkblks-nR;
      const size_t mblks=(flag&v_mp) ? nmblks+1 : nmblks;
      const size_t nblks=(flag&v_np) ? nnblks+1 : nnblks;
      const int flg = (flag|v_nmC) & ~(v_kp+v_lwC+v_nmA+v_nmB);
      if (flag & (v_mp+v_np))
         ammmREC(pd, nmblks, nnblks, nL, flg, A, B, C, a, b, c);
      else
         ammmRECf(pd, nmblks, nnblks, nL, flg, A, B, C, a, b, c);
      ammmREC(pd, nmblks, nnblks, nR, flag & ~v_cpC, 
              A+nL*pd->incAk, B+nL*pd->incBk, C,
              a+nL*mblks*pd->mbkb, b+nL*nblks*pd->kbnb, c);
   }
}

int Mjoin(PATL,ammmREC)
(
   enum ATLAS_TRANS TA,
   enum ATLAS_TRANS TB,
   ATL_CSZT M,
   ATL_CSZT N,
   ATL_CSZT K,
   const SCALAR alpha,
   const TYPE *A,
   ATL_CSZT lda,
   const TYPE *B,
   ATL_CSZT ldb,
   const SCALAR beta,
   TYPE *C,
   ATL_CSZT ldc
)
{
   void *vp;
   TYPE *a, *b, *c;
   amminfo_t mminfo;
   ammrec_t pd;
   #if ATL_AMM_MAXKMAJ > 1
      size_t kb0U, KK;
   #else
      #define kb0U kb0
      #define KK K
   #endif
   size_t nmblks, nnblks, nkblks, szA, szB, szC, i, j, k;
   int mb, nb, kb, mu, nu, ku, mr, nr, kr, KB0, flag, appAl;

   pd.alpA = pd.alpB = pd.alpC = ATL_rone;
   appAl = Mjoin(PATL,GetAmmmInfo)(&mminfo, TA, TB, M, N, K, alpha, beta);
   pd.mb = mb = mminfo.mb;
   pd.nb = nb = mminfo.nb;
   pd.kb = kb = mminfo.kb;
   mu = mminfo.mu;
   nu = mminfo.nu;
   ku = mminfo.ku;
   nmblks = M / mb;
   nnblks = N / nb;
   nkblks = K / kb;
   pd.nmu = mb / mu;
   pd.nnu = mb / nu;
   pd.mr = mr = M - nmblks*mb;
   if (mr)
      pd.nmuF = (mr+mu-1)/mu;
   else
      pd.nmuF = pd.nmu;
   pd.nr = nr = N - nnblks*nb;
   if (nr)
      pd.nnuF = (nr+nu-1)/nu;
   else
      pd.nnuF = pd.nnu;
   pd.kr = kr = K - nkblks*kb;
   if (!appAl)
      pd.alpA = alpha;
   else if (appAl == 1)
      pd.alpB = alpha;
   else
      pd.alpC = alpha;
   pd.a2blk = mminfo.a2blk;
   pd.b2blk = mminfo.b2blk;
   pd.blk2c = mminfo.Cblk2cm;
   pd.amm_b0 = mminfo.amm_b0;
   pd.amm_b1 = mminfo.amm_b1;
   if (!kr)
   {
      pd.amm_k1_b0 = mminfo.amm_b0;
      pd.amm_k1_b1 = mminfo.amm_b1;
      KB0 = kb;
   }
/*
 * If last K-block is partial, compute K of gemm (KB0) and K of copy (kr)
 */
   else
   {
/*
 *    K-major require GEMM's K (KB0) to be a mult of ku
 */
      #if ATL_AMM_MAXKMAJ > 1
      if (ATL_AMMFLG_KMAJOR(mminfo.flag))
      {
         KB0 = ((kr+ku-1)/ku)*ku;
         if (ATL_AMMFLG_KRUNTIME(mminfo.flag))
         {
            pd.amm_k1_b0 = mminfo.amm_b0;
            pd.amm_k1_b1 = mminfo.amm_b1;
         }
         else
         {
            pd.amm_k1_b0 = mminfo.amm_k1_b0;
            pd.amm_k1_b1 = mminfo.amm_k1_b1;
         }
            
      }
      else
      {
      #endif
         KB0 = kr;
         if (ATL_AMMFLG_KRUNTIME(mminfo.flag) && kr == (kr/ku)*ku &&
             kr > mminfo.kbmin)
         {
            pd.amm_k1_b0 = mminfo.amm_b0;
            pd.amm_k1_b1 = mminfo.amm_b1;
         }
         else
         {
            pd.amm_k1_b0 = mminfo.amm_k1_b0;
            pd.amm_k1_b1 = mminfo.amm_k1_b1;
         }
      #if ATL_AMM_MAXKMAJ > 1
      }
      #endif
   }
   pd.mb = mminfo.mb;
   pd.nb = mminfo.nb;
   pd.kb = mminfo.kb;
   pd.mbkb = mminfo.mb * mminfo.kb;
   pd.kbnb = mminfo.kb * mminfo.nb;
   pd.mbnb = mminfo.mb * mminfo.nb;
   pd.lda = lda;
   pd.ldb = ldb;
   pd.ldc = ldc;
   pd.nmu = mminfo.mb / mminfo.mu;
   pd.nnu = mminfo.nb / mminfo.nu;
   pd.beta = beta;
   if (TA == AtlasNoTrans)
   {
      pd.incAm = pd.mb;
      pd.incAk = pd.kb * lda;
   }
   else
   {
      pd.incAm = pd.mb * lda;
      pd.incAk = pd.kb;
   }
   if (TB == AtlasNoTrans)
   {
      pd.incBk = pd.kb;
      pd.incBn = pd.nb * ldb;
   }
   else
   {
      pd.incBk = pd.kb * ldb;
      pd.incBn = pd.nb;
   }
   pd.incCn = nb*ldc;
   pd.incCm = mb;
   pd.KB0 = KB0;
/*
 * Allocate workspace, for now get double amount space required for first
 * recursively divided dimension!
 */
   i = (mr) ? nmblks+1 : nmblks;
   j = (nr) ? nnblks+1 : nnblks;
   k = (kr) ? nkblks+1 : nkblks;
   szA = i*k*pd.mbkb;
   szB = k*j*pd.kbnb;
   szC = i*j*pd.mbnb;
   vp = malloc(ATL_MulBySize(szA+mu + szB+nu + szC+mu*nu) + 3*ATL_Cachelen);
   ATL_assert(vp);
   a = ATL_AlignPtr(vp);
   b = a + szA;
   b = ATL_AlignPtr(b);
   c = b + szB;
   c = ATL_AlignPtr(c);
   flag = (v_cpA | v_cpB | v_cpC | v_nmA | v_nmB | v_nmC | v_lwC);
   if (!(mr|nr|kr))
      ammmRECf(&pd, nmblks, nnblks, nkblks, flag, A, B, C, a, b, c);
   else
   {
      flag |= (mr) ? v_mp : 0;
      flag |= (nr) ? v_np : 0;
      flag |= (kr) ? v_kp : 0;
      ammmREC(&pd, nmblks, nnblks, nkblks, flag, A, B, C, a, b, c);
   }
   free(vp);
}
@ROUT ATL_ammmNMK
#include "atlas_misc.h"
#include Mstr(Mjoin(AMM_PRE,_sum.h))

int Mjoin(PATL,ammmNMK)
(
   enum ATLAS_TRANS TA,
   enum ATLAS_TRANS TB,
   ATL_CSZT M,
   ATL_CSZT N,
   ATL_CSZT K,
   const SCALAR alpha,
   const TYPE *A,
   ATL_CSZT lda,
   const TYPE *B,
   ATL_CSZT ldb,
   const SCALAR beta,
   TYPE *C,
   ATL_CSZT ldc
)
{
   amminfo_t mminfo;
   ATL_INT mb, NB, kb, mu, nu, ku, KRUN;
   #if ATL_AMM_MAXKMAJ > 1
      size_t kb0U, KK;
   #else
      #define kb0U kb0
      #define KK K
   #endif
   size_t nmblks, nnblks, nkblks, mbF, nbF, kb0, nmu, nmuF, MBF, NBF;
   size_t incwA, incAk, incBk, incAk0, incBk0, incAm, incBn, incCn;
   size_t i, j, k, szA, szB, szC, nnu0, nnuF;
   const TYPE *B0 = B;
   TYPE alpA=ATL_rone, alpB=ATL_rone, alpC=ATL_rone;
   TYPE *wA, *wB, *wC, *wA0, *wB0;
   void *vp;
   cm2am_t a2blk, b2blk;
   ablk2cmat_t blk2c;
   ammkern_t amm_b1, amm_b0;
   int appAl;

   appAl = Mjoin(PATL,GetAmmmInfo)(&mminfo, TA, TB, M, N, K, alpha, beta);
   if (!appAl)
      alpA = alpha;
   else if (appAl == 1)
      alpB = alpha;
   else
      alpC = alpha;
   mb = mminfo.mb;
   NB = mminfo.nb;
   kb = mminfo.kb;
   KRUN = ATL_AMMFLG_KRUNTIME(mminfo.flag);
   mu = mminfo.mu;
   nu = mminfo.nu;
   ku = mminfo.ku;
   incwA = mb*kb; 
   nmu = mb / mu;
   amm_b1 = mminfo.amm_b1;
   blk2c = mminfo.Cblk2cm;
   a2blk = mminfo.a2blk;
   b2blk = mminfo.b2blk;
/*
 * Handle N differently than other dims: since it is outer loop, don't want
 * to peel, so just vary nb inside the main loop.  nnblks therefore includes
 * final block, unlike for M or K.
 */
   if (N >= NB+nu+nu)
   {
      nnblks = N/NB;
      nbF = N - nnblks * NB;
      if (nbF < nu+nu)
         nbF += NB;
      else
         nnblks++;
   }
   else
   {
      nnblks = 1;
      nbF = N;
   }
   nnu0 = NB / nu;
   nnuF = (nbF+nu-1)/nu;
   NBF = nnuF * nu;
/*
 * For M, we must peel the final block to handle any cleanup (can't peel 1st
 * block or we mess up alignment!), so this block is not included in the
 * block count
 */
   if (M >= mb+mu+mu)  /* more than just last block */
   {
      nmblks = M/mb;
      mbF = M - nmblks * mb;
      if (mbF < mu+mu)  /* steal block from main iteration, not enough here! */
      {
         nmblks--;
         mbF += mb;
      }
   }
   else /* put everything in final block */
   {
      mbF = M;
      nmblks = 0;
   }
   nmuF = (mbF+mu-1) / mu;
   MBF = nmuF * mu;
/*
 * For K, we peel the first iteration to set BETA=0, so the nkblks does not
 * include the peeled block
 */
   if (K >= kb)
   {
      nkblks = K/kb;
      kb0 = K - nkblks * kb;
      if (!kb0)
      {
         kb0 = kb;
         nkblks--;
      }
      else
      {
         if (kb0 < 4)
         {
            kb0 += kb;
            nkblks--;
         }
      }
   }
   else /* K < nb */
   {
      kb0 = K;
      nkblks = 0;
   }
   #if ATL_AMM_MAXKMAJ > 1
      if (ATL_AMMFLG_KMAJOR(mminfo.flag))
      {
         KK = ((K+ku-1)/ku)*ku;
         kb0U = ((kb0+ku-1)/ku)*ku;
         if (ATL_AMMFLG_KRUNTIME(mminfo.flag))
            amm_b0 = mminfo.amm_b0;
         else
            amm_b0 = (mminfo.kb == kb0U) ?  mminfo.amm_b0 : mminfo.amm_k1_b0;
      }
      else
      {
         KK = K;
         kb0U = kb0;
         amm_b0 = (kb0 == mminfo.kb || 
                   (KRUN && kb0 >= mminfo.kbmin && (kb0/ku)*ku == kb0)) ?  
                  mminfo.amm_b0 : mminfo.amm_k1_b0;
      }
   #else
      amm_b0 = (kb0 == mminfo.kb || 
                (KRUN && kb0 >= mminfo.kbmin && (kb0/ku)*ku == kb0)) ?  
               mminfo.amm_b0 : mminfo.amm_k1_b0;
   #endif
   szA = (nmblks*mb+MBF)*KK; /* wrkspc for all of A wt M rounded up to MU*/
   j = Mmax(NB, NBF);
   i = Mmax(MBF, mb);
   szC = i*j;
   szB = KK*j;                     /* workspace for panel of B */

   k = ATL_MulBySize(szA+szB+szC+mu*nu*ku) + 3*ATL_Cachelen;
   if (k > ATL_MaxMalloc)
      return(2);
   vp = malloc(k);
   if (!vp)
      return(1);
   wB0 = wB = ATL_AlignPtr(vp);
   wA = wB + szB;
   wA0 = wA = ATL_AlignPtr(wA);
   wC = wA + szA;
   wC = ATL_AlignPtr(wC);

   if (TA == AtlasNoTrans)
   {
      incAm = mb;
      incAk0 = kb0*lda;
      incAk = kb*lda;
   }
   else
   {
      incAm = mb*lda;
      incAk0 = kb0;
      incAk = kb;
   }
   if (TB == AtlasNoTrans)
   {
      incBk0 = kb0;
      incBk = kb;
      incBn = NB*ldb;
   }
   else
   {
      incBk0 = kb0*ldb;
      incBk = kb*ldb;
      incBn = NB;
   }
   incCn = ldc*NB;

   for (j=0; j < nnblks; j++)
   {
      size_t nb, nbsz, incwB, incwB0, nnu;
      const TYPE *Bn = B+incBn;
      TYPE *Cn = C + incCn;
      if (j != nnblks-1)
      {
         nbsz = nb = NB;
         nnu = nnu0;
      }
      else
      {
         nb = nbF;
         nbsz = NBF;
         nnu = nnuF;
      }
      incwB = nbsz*kb;
      incwB0 = nbsz*kb0U;
/*
 *    Do all M-blocks except final one, which may be of differing size & partial
 */
      for (i=0; i < nmblks; i++)
      {
         TYPE *wAn, *wBn;
         const TYPE *An = A+incAm;
/*
 *       Peel first K it to handle K-cleanup and set BETA=0
 */
         if (!j)
            a2blk(kb0, mb, alpA, A, lda, wA);
         if (!i)
            b2blk(kb0, nb, alpB, B, ldb, wB);
         wAn = wA+mb*kb0U;
         wBn = (nkblks) ? wB+incwB0 : wB;
         amm_b0(nmu, nnu, kb0U, wA, wB, wC, nkblks?wAn:wA, wBn, wC);
         wA = wAn;
         wB = wBn;
         A += incAk0;
         B += incBk0;
/*
 *       If first K-block not the only K-block
 */
         if (nkblks)
         {
            for (k=nkblks-1; k; k--)
            {
               wAn = wA+incwA;
               wBn = wB+incwB;
               if (!j)
                  a2blk(kb, mb, alpA, A, lda, wA);
               if (!i)
                  b2blk(kb, nb, alpB, B, ldb, wB);
               amm_b1(nmu, nnu, kb, wA, wB, wC, wAn, wBn, wC);
               wA = wAn;
               wB = wBn;
               A += incAk;
               B += incBk;
            }
/*
 *          Last K-block peeled to change prefetch pattern
 */
            wAn = wA+incwA;
            if (!j)
               a2blk(kb, mb, alpA, A, lda, wA);
            if (!i)
               b2blk(kb, nb, alpB, B, ldb, wB);
            amm_b1(nmu, nnu, kb, wA, wB, wC, wAn, wB0, wC);
            wA = wAn;
            wB = wB0;
         }
         blk2c(mb, nb, alpC, wC, beta, C, ldc);
         A = An;
         B = B0;
         C += mb;
      }
/*
 *    Do the final peeled M-block, which is of non-constant size mbF
 */
      {
         TYPE *wAn, *wBn;
/*
 *       Peel first K it to handle K-cleanup and set BETA=0
 */
         if (!j)
            a2blk(kb0, mbF, alpA, A, lda, wA);
         if (!i)
            b2blk(kb0, nb, alpB, B, ldb, wB);
         wAn = wA+MBF*kb0U;
         wBn = (nkblks) ? wB+incwB0 : wB;
         amm_b0(nmuF, nnu, kb0U, wA, wB, wC, nkblks?wAn:wA, wBn, wC);
         wA = wAn;
         wB = wBn;
         A += incAk0;
         B += incBk0;
/*
 *       If first K-block not the only K-block
 */
         if (nkblks)
         {
            for (k=nkblks-1; k; k--)
            {
               wAn = wA+MBF*kb;
               wBn = wB+incwB;
               if (!j)
                  a2blk(kb, mbF, alpA, A, lda, wA);
               if (!i)
                  b2blk(kb, nb, alpB, B, ldb, wB);
               amm_b1(nmuF, nnu, kb, wA, wB, wC, wAn, wBn, wC);
               wA += MBF*kb;
               wB = wBn;
               A += incAk;
               B += incBk;
            }
/*
 *          Last K-block peeled to change prefetch pattern
 */
            if (!j)
               a2blk(kb, mbF, alpA, A, lda, wA);
            if (!i)
               b2blk(kb, nb, alpB, B, ldb, wB);
            amm_b1(nmuF, nnu, kb, wA, wB, wC, wA0, wB0, wC);
            wA = wA0;
            wB = wB0;
         }
         blk2c(mbF, nb, alpC, wC, beta, C, ldc);
      }  /* end M-peel */
      wA = wA0;
      B = B0 = Bn;
      C = Cn;
   }
   free(vp);
   return(0);
}
@ROUT ATL_cammmNMK
#include "atlas_misc.h"
#include Mstr(Mjoin(AMM_PRE,_sum.h))

int Mjoin(PATL,ammmNMK)
(
   enum ATLAS_TRANS TA,
   enum ATLAS_TRANS TB,
   ATL_CSZT M,
   ATL_CSZT N,
   ATL_CSZT K,
   const SCALAR alpha,
   const TYPE *A,
   ATL_CSZT lda,
   const TYPE *B,
   ATL_CSZT ldb,
   const SCALAR beta,
   TYPE *C,
   ATL_CSZT ldc
)
{
   amminfo_t mminfo;
   ATL_INT mb, NB, kb, mu, nu, ku, KRUN;
   #if ATL_AMM_MAXKMAJ > 1
      size_t kb0U, KK;
   #else
      #define kb0U kb0
      #define KK K
   #endif
   size_t nmblks, nnblks, nkblks, mbF, nbF, kb0, nmu, nmuF, MBF, NBF;
   size_t incwA, incAk, incBk, incAk0, incBk0, incAm, incBn, incCn;
   size_t i, j, k, szA, szB, szC, nnu0, nnuF;
   const TYPE *B0 = B;
   const TYPE one[2] = {ATL_rone, ATL_rzero};
   const TYPE *alpA=one, *alpB=one, *alpC=one;
   TYPE *wA, *wB, *wC, *rC, *wA0, *wB0;
   void *vp;
   cm2am_t a2blk, b2blk;
   ablk2cmat_t blk2c;
   ammkern_t amm_b1, amm_b0, amm_bn, amm_b1K, amm_bnK;
   int appAl;

   appAl = Mjoin(PATL,GetAmmmInfo)(&mminfo, TA, TB, M, N, K, alpha, beta);
   if (!appAl)
      alpA = alpha;
   else if (appAl == 1)
      alpB = alpha;
   else
      alpC = alpha;
   mb = mminfo.mb;
   NB = mminfo.nb;
   kb = mminfo.kb;
   KRUN = ATL_AMMFLG_KRUNTIME(mminfo.flag);
   mu = mminfo.mu;
   nu = mminfo.nu;
   ku = mminfo.ku;
   incwA = mb*kb; 
   nmu = mb / mu;
   amm_b1 = mminfo.amm_b1;
   amm_bn = mminfo.amm_bn;
   blk2c = mminfo.Cblk2cm;
   a2blk = mminfo.a2blk;
   b2blk = mminfo.b2blk;
/*
 * Handle N differently than other dims: since it is outer loop, don't want
 * to peel, so just vary nb inside the main loop.  nnblks therefore includes
 * final block, unlike for M or K.
 */
   if (N >= NB+nu+nu)
   {
      nnblks = N/NB;
      nbF = N - nnblks * NB;
      if (nbF < nu+nu)
         nbF += NB;
      else
         nnblks++;
   }
   else
   {
      nnblks = 1;
      nbF = N;
   }
   nnu0 = NB / nu;
   nnuF = (nbF+nu-1)/nu;
   NBF = nnuF * nu;
/*
 * For M, we must peel the final block to handle any cleanup (can't peel 1st
 * block or we mess up alignment!), so this block is not included in the
 * block count
 */
   if (M >= mb+mu+mu)  /* more than just last block */
   {
      nmblks = M/mb;
      mbF = M - nmblks * mb;
      if (mbF < mu+mu)  /* steal block from main iteration, not enough here! */
      {
         nmblks--;
         mbF += mb;
      }
   }
   else /* put everything in final block */
   {
      mbF = M;
      nmblks = 0;
   }
   nmuF = (mbF+mu-1) / mu;
   MBF = nmuF * mu;
/*
 * For K, we peel the first iteration to set BETA=0, so the nkblks does not
 * include the peeled block
 */
   if (K >= kb)
   {
      nkblks = K/kb;
      kb0 = K - nkblks * kb;
      if (!kb0)
      {
         kb0 = kb;
         nkblks--;
      }
      else
      {
         if (kb0 < 4)
         {
            kb0 += kb;
            nkblks--;
         }
      }
   }
   else /* K < nb */
   {
      kb0 = K;
      nkblks = 0;
   }
   #if ATL_AMM_MAXKMAJ > 1
      if (ATL_AMMFLG_KMAJOR(mminfo.flag))
      {
         KK = ((K+ku-1)/ku)*ku;
         kb0U = ((kb0+ku-1)/ku)*ku;
         if (ATL_AMMFLG_KRUNTIME(mminfo.flag))
            amm_b0 = mminfo.amm_b0;
         else
            amm_b0 = (mminfo.kb == kb0U) ?  mminfo.amm_b0 : mminfo.amm_k1_b0;
      }
      else
      {
         KK = K;
         kb0U = kb0;
         amm_b0 = (kb0 == mminfo.kb || 
                   (KRUN && kb0 >= mminfo.kbmin && (kb0/ku)*ku == kb0)) ?  
                  mminfo.amm_b0 : mminfo.amm_k1_b0;
      }
   #else
      amm_b0 = (kb0 == mminfo.kb || 
                (KRUN && kb0 >= mminfo.kbmin && (kb0/ku)*ku == kb0)) ?  
               mminfo.amm_b0 : mminfo.amm_k1_b0;
   #endif
   if (amm_b0 == mminfo.amm_b0)
   {
      amm_b1K = amm_b1;
      amm_bnK = amm_bn;
   }
   else
   {
      amm_b1K = mminfo.amm_k1_b1;
      amm_bnK = mminfo.amm_k1_bn;
   }
   szA = (nmblks*mb+MBF)*KK; /* wrkspc for all of A wt M rounded up to MU*/
   j = Mmax(NB, NBF);
   i = Mmax(MBF, mb);
   szC = i*j;
   szB = KK*j;                     /* workspace for panel of B */

   k = ATL_MulBySize(szA+szB+szC+mu*nu*ku) + 3*ATL_Cachelen;
   if (k > ATL_MaxMalloc)
      return(2);
   vp = malloc(k);
   if (!vp)
      return(1);
   wB0 = wB = ATL_AlignPtr(vp);
   wA = wB + szB + szB;
   wA0 = wA = ATL_AlignPtr(wA);
   wC = wA + szA + szA;
   wC = ATL_AlignPtr(wC);
   rC = wC + szC;

   if (TA == AtlasNoTrans)
   {
      incAm = mb SHIFT;
      incAk0 = kb0*lda SHIFT;
      incAk = kb*lda SHIFT;
   }
   else
   {
      incAm = mb*lda SHIFT;
      incAk0 = kb0 SHIFT;
      incAk = kb SHIFT;
   }
   if (TB == AtlasNoTrans)
   {
      incBk0 = kb0 SHIFT;
      incBk = kb SHIFT;
      incBn = NB*ldb SHIFT;
   }
   else
   {
      incBk0 = kb0*ldb SHIFT;
      incBk = kb*ldb SHIFT;
      incBn = NB SHIFT;
   }
   incCn = ldc*NB SHIFT;

   for (j=0; j < nnblks; j++)
   {
      size_t nb, nbsz, incwB, incwB0, nnu;
      const TYPE *Bn = B+incBn;
      TYPE *Cn = C + incCn;
      if (j != nnblks-1)
      {
         nbsz = nb = NB;
         nnu = nnu0;
      }
      else
      {
         nb = nbF;
         nbsz = NBF;
         nnu = nnuF;
      }
      incwB = nbsz*kb;
      incwB0 = nbsz*kb0U;
/*
 *    Do all M-blocks except final one, which may be of differing size & partial
 */
      for (i=0; i < nmblks; i++)
      {
         TYPE *wAn, *wBn;
         const TYPE *An = A+incAm;
/*
 *       Peel first K it to handle K-cleanup and set BETA=0
 */
         wAn = wA+mb*kb0U;
         wBn = wB+incwB0;
         if (!j)
            a2blk(kb0, mb, alpA, A, lda, wAn, wA);
         if (!i)
            b2blk(kb0, nb, alpB, B, ldb, wBn, wB);
         amm_b0(nmu, nnu, kb0U, wA, wB, rC, wAn, wB, wC);
         amm_b0(nmu, nnu, kb0U, wAn, wB, wC, wAn, wBn, rC);
         amm_bnK(nmu, nnu, kb0U, wAn, wBn, rC, wA, wBn, wC);
         wB = wBn+incwB0;
         wAn += mb*kb0U;
         amm_b1K(nmu, nnu, kb0U, wA, wBn, wC, wAn, wB, rC);
         wA = wAn;
         A += incAk0;
         B += incBk0;
/*
 *       If first K-block not the only K-block
 */
         if (nkblks)
         {
            for (k=nkblks-1; k; k--)
            {
               wAn = wA+incwA;
               wBn = wB+incwB;
               if (!j)
                  a2blk(kb, mb, alpA, A, lda, wAn, wA);
               if (!i)
                  b2blk(kb, nb, alpB, B, ldb, wBn, wB);
               amm_bn(nmu, nnu, kb, wA, wB, rC, wAn, wB, wC);
               amm_b1(nmu, nnu, kb, wAn, wB, wC, wAn, wBn, rC);
               amm_bn(nmu, nnu, kb, wAn, wBn, rC, wAn, wB, wC);
               wAn += incwA;
               wB = wBn + incwB;
               amm_b1(nmu, nnu, kb, wA, wBn, wC, wAn, wB, rC);
               wA = wAn;
               A += incAk;
               B += incBk;
            }
/*
 *          Last K-block peeled to change prefetch pattern
 */
            wAn = wA+incwA;
            wBn = wB+incwB;
            if (!j)
               a2blk(kb, mb, alpA, A, lda, wAn, wA);
            if (!i)
               b2blk(kb, nb, alpB, B, ldb, wBn, wB);
            amm_bn(nmu, nnu, kb, wA, wB, rC, wAn, wB, wC);
            amm_b1(nmu, nnu, kb, wAn, wB, wC, wAn, wBn, rC);
            amm_bn(nmu, nnu, kb, wAn, wBn, rC, wAn, wB, wC);
            wAn += incwA;
            amm_b1(nmu, nnu, kb, wA, wBn, wC, wAn, wB0, rC);
            wA = wAn;
            wB = wB0;
         }
         blk2c(mb, nb, alpC, rC, wC, beta, C, ldc);
         A = An;
         B = B0;
         wB = wB0;
         C += mb+mb;
      }
/*
 *    Do the final peeled M-block, which is of non-constant size mbF
 */
      {
         TYPE *wAn, *wBn;
/*
 *       Peel first K it to handle K-cleanup and set BETA=0
 */
         wAn = wA+MBF*kb0U;
         wBn = wB+incwB0;
         if (!j)
            a2blk(kb0, mbF, alpA, A, lda, wAn, wA);
         if (!i)
            b2blk(kb0, nb, alpB, B, ldb, wBn, wB);
         amm_b0(nmuF, nnu, kb0U, wA, wB, rC, wAn, wB, wC);
         amm_b0(nmuF, nnu, kb0U, wAn, wB, wC, wAn, wBn, rC);
         amm_bnK(nmuF, nnu, kb0U, wAn, wBn, rC, wAn, wB, wC);
         wAn += MBF*kb0U;
         wB = wBn + incwB0;
         amm_b1K(nmuF, nnu, kb0U, wA, wBn, wC, nkblks?wAn:wA, wB, rC);
         wA = wAn;
         A += incAk0;
         B += incBk0;
/*
 *       If first K-block not the only K-block
 */
         if (nkblks)
         {
            for (k=nkblks-1; k; k--)
            {
               wAn = wA+MBF*kb;
               wBn = wB+incwB;
               if (!j)
                  a2blk(kb, mbF, alpA, A, lda, wAn, wA);
               if (!i)
                  b2blk(kb, nb, alpB, B, ldb, wBn, wB);
               amm_bn(nmuF, nnu, kb, wA, wB, rC, wAn, wB, wC);
               amm_b1(nmuF, nnu, kb, wAn, wB, wC, wAn, wBn, rC);
               amm_bn(nmuF, nnu, kb, wAn, wBn, rC, wAn, wB, wC);
               wAn += MBF*kb;
               wB = wBn + incwB;
               amm_b1(nmuF, nnu, kb, wA, wBn, wC, wAn, wB, rC);
               wA = wAn;
               A += incAk;
               B += incBk;
            }
/*
 *          Last K-block peeled to change prefetch pattern
 */
            wAn = wA+MBF*kb;
            wBn = wB+incwB;
            if (!j)
               a2blk(kb, mbF, alpA, A, lda, wAn, wA);
            if (!i)
               b2blk(kb, nb, alpB, B, ldb, wBn, wB);
            amm_bn(nmuF, nnu, kb, wA, wB, rC, wAn, wB, wC);
            amm_b1(nmuF, nnu, kb, wAn, wB, wC, wAn, wBn, rC);
            amm_bn(nmuF, nnu, kb, wAn, wBn, rC, wAn, wB, wC);
            amm_b1(nmuF, nnu, kb, wA, wBn, wC, wA0, wB0, rC);
            wA = wA0;
            wB = wB0;
         }
         blk2c(mbF, nb, alpC, rC, wC, beta, C, ldc);
      }  /* end M-peel */
      wA = wA0;
      wB = wB0;
      B = B0 = Bn;
      C = Cn;
   }
   free(vp);
   return(0);
}
@ROUT tune_cluster
#include "atlas_misc.h"
#ifdef ATL_NCLUSTER
   #include "atlas_cluster.h"
#endif
#include "atlas_sys.h"

void PrintUsage(char *name, int ierr, char *flag)
{
   if (ierr > 0)
      fprintf(stderr, "Bad argument #%d: '%s'\n", ierr,
              flag?flag:"OUT-OF_ARGUMENTS");
   else if (ierr < 0)
      fprintf(stderr, "ERROR: %s\n", flag);
   fprintf(stderr, "USAGE: %s [flags:\n", name);
   fprintf(stderr, "   -p <precision>: precision to tune\n");
   exit(ierr ? ierr : -1);
}
char GetFlags(int nargs, char **args, char **incd)
{
   int i;
   char pre = 'd';
   *incd = "../../../include"; /* for now assume we are in tune/blas/gemm */

   for (i=1; i < nargs; i++)
   {
      if (args[i][0] != '-')
         PrintUsage(args[0], i, args[i]);
      switch(args[i][1])
      {
      case 'p':
         pre = args[++i][0];
         break;
      case 'i':
         *incd = args[++i];
         break;
      default:
         PrintUsage(args[0], i, args[i]);
      }
   }
   return(pre);
}

#ifdef ATL_NCLUSTER
      
#define CL_AMM_ID_START ATL_CL_AMM_START

void GenHeader(char pre, char *incd, int *mbs, int *nbs, int *kbs, 
               double *perf, double total_perf)
{
   FILE *fpout;
   char ln[2048];
   int lni, j;
   sprintf(ln, "%s/atlas_%cuamm_cluster.h", incd, pre);
   fpout = fopen(ln, "w");
   assert(fpout);
   fprintf(fpout, "/* Generated by %s */\n", __FILE__);
   fprintf(fpout, "#ifndef ATLAS_%cUAMM_CLUSTER_H\n", pre-0x20);
   fprintf(fpout, "   #define ATLAS_%cUAMM_CLUSTER_H\n\n", pre-0x20);

   fprintf(fpout, "   #include \"atlas_amm.h\"\n\n");

   fprintf(fpout, "   #define ATLAS_TOTAL_PERF %e /* (%.2lf) */\n\n", 
                                       total_perf, total_perf);

   fprintf(fpout, "   /* Performance per core for each cluster */\n");
   fprintf(fpout, "   static double ATL_CL_PERF[%d] = \n", ATL_NCLUSTER);
   fprintf(fpout, "   {\n");
   fprintf(fpout, "      %12e", perf[0]);
   for (j=1; j<ATL_NCLUSTER; j++)
   {
      fprintf(fpout, ",   /* cluster %d (%9.2lf) */\n      %12e", 
                                    j-1, perf[j-1], perf[j]);
   }
   fprintf(fpout, "    /* cluster %d (%9.2lf) */\n   };\n\n", 
                              j-1, perf[j-1]);

   fprintf(fpout, "   /* Performance ratio = PERF_PER_CORE * " 
                  "CORE_PER_CLUSTER / TOTAL_PERF */\n");
   fprintf(fpout, "   static double ATL_CL_LD_RATIO[%d] = \n", ATL_NCLUSTER);
   fprintf(fpout, "   {\n");
   fprintf(fpout, "      %lf", perf[0]*ATL_CL_ncpus[0]/total_perf);
   for (j=1; j<ATL_NCLUSTER; j++)
   {
      fprintf(fpout, ",   /* cluster %d */\n      %lf", 
                           j-1, perf[j]*ATL_CL_ncpus[j]/total_perf);
   }
   fprintf(fpout, "    /* cluster %d */\n   };\n\n", j-1);

   fprintf(fpout, "   /* Save all MAX MB/NB/KBs for GEMM. */\n\n");

   fprintf(fpout, "   static int ATL_CL_MAXMBs[%d] = \n", ATL_NCLUSTER);
   fprintf(fpout, "   {\n");
   fprintf(fpout, "      %3d", mbs[0]);
   for (j=1; j<ATL_NCLUSTER; j++)
   {
      fprintf(fpout, ",   /* cluster %d */\n      %3d", 
                           j-1, mbs[j]);
   }
   fprintf(fpout, "    /* cluster %d */\n   };\n\n", j-1);

   fprintf(fpout, "   static int ATL_CL_MAXNBs[%d] = \n", ATL_NCLUSTER);
   fprintf(fpout, "   {\n");
   fprintf(fpout, "      %3d", nbs[0]);
   for (j=1; j<ATL_NCLUSTER; j++)
   {
      fprintf(fpout, ",   /* cluster %d */\n      %3d", 
                           j-1, nbs[j]);
   }
   fprintf(fpout, "    /* cluster %d */\n   };\n\n", j-1);

   fprintf(fpout, "   static int ATL_CL_MAXKBs[%d] = \n", ATL_NCLUSTER);
   fprintf(fpout, "   {\n");
   fprintf(fpout, "      %3d", kbs[0]);
   for (j=1; j<ATL_NCLUSTER; j++)
   {
      fprintf(fpout, ",   /* cluster %d */\n      %3d", 
                           j-1, kbs[j]);
   }
   fprintf(fpout, "    /* cluster %d */\n   };\n\n", j-1);

   lni = sprintf(ln, 
      "      (enum ATLAS_TRANS, enum ATLAS_TRANS, ATL_CINT, ATL_CINT, \n");
   lni += sprintf(ln+lni, 
      "      ATL_CINT, const SCALAR, const TYPE*, ATL_CINT, \n");
   lni += sprintf(ln+lni, 
      "      const TYPE*, ATL_CINT, const SCALAR, TYPE*, ATL_CINT); \n");

   fprintf(fpout, "   typedef int (*tammm_CL_t)\n");
   fprintf(fpout, "%s", ln);

   for (j=0; j<ATL_NCLUSTER; j++)
   {
      fprintf(fpout, "   int ATL_%ctammm_GC%d\n", pre, j);
      fprintf(fpout, "%s", ln);
   }

   fprintf(fpout, "   static const tammm_CL_t ATL_CL_tammm_G[%d] = \n", 
                  ATL_NCLUSTER);
   fprintf(fpout, "   {\n");
   fprintf(fpout, "      ATL_%ctammm_GC%d", pre, 0);
   for (j=1; j<ATL_NCLUSTER; j++)
   {
      fprintf(fpout, ",   /* cluster %d */\n      ATL_%ctammm_GC%d", 
                           j-1, pre, j);
   }
   fprintf(fpout, "    /* cluster %d */\n   };\n\n", j-1);

   lni = sprintf(ln, 
      "      (amminfo_t*, const unsigned int, "
      "enum ATLAS_TRANS, enum ATLAS_TRANS, \n");
   lni += sprintf(ln+lni, 
      "      ATL_CSZT, ATL_CSZT, ATL_CSZT, const SCALAR, const SCALAR); \n");

   fprintf(fpout, "   typedef int (*GetAmmmInfo_CL_t)\n");
   fprintf(fpout, "%s", ln);

   for (j=0; j<ATL_NCLUSTER; j++)
   {
      fprintf(fpout, "   int ATL_%ctGetAmmmInfoC%d\n", pre, j);
      fprintf(fpout, "%s", ln);
   }

   fprintf(fpout, 
      "   static const GetAmmmInfo_CL_t ATL_CL_tGetAmmmInfo[%d] = \n", 
                  ATL_NCLUSTER);
   fprintf(fpout, "   {\n");
   fprintf(fpout, "      ATL_%ctGetAmmmInfoC%d", pre, 0);
   for (j=1; j<ATL_NCLUSTER; j++)
   {
      fprintf(fpout, ",   /* cluster %d */\n      ATL_%ctGetAmmmInfoC%d", 
                           j-1, pre, j);
   }
   fprintf(fpout, "    /* cluster %d */\n   };\n\n", j-1);

   fprintf(fpout, "\n#endif /* end multiple inclusion guard */");
   fclose(fpout);
}

void GetMaxBList(char pre, char *incd, int *mbs, int *nbs, int *kbs)
{
   int j;
   char ln[2048];
   for (j=0; j<ATL_NCLUSTER; j++)
   {
      char *res;
      sprintf(ln, "cat %s/atlas_%cu%damm_sum.h | "
                  "grep -m 1 ATL_UAMM_MAXMB | cut -d' ' -s -f 3", 
                  incd, pre, CL_AMM_ID_START+j);
      res = atlsys_1L(NULL, ln, 0, 0);
      if (res)
      {
         mbs[j] = atoi(res);
         free(res);
      }
      sprintf(ln, "cat %s/atlas_%cu%damm_sum.h | "
                  "grep -m 1 ATL_UAMM_MAXNB | cut -d' ' -s -f 3", 
                  incd, pre, CL_AMM_ID_START+j);
      res = atlsys_1L(NULL, ln, 0, 0);
      if (res)
      {
         nbs[j] = atoi(res);
         free(res);
      }
      sprintf(ln, "cat %s/atlas_%cu%damm_sum.h | "
                  "grep -m 1 ATL_UAMM_MAXKB | cut -d' ' -s -f 3", 
                  incd, pre, CL_AMM_ID_START+j);
      res = atlsys_1L(NULL, ln, 0, 0);
      if (res)
      {
         kbs[j] = atoi(res);
         free(res);
      }
   }
}

#endif

int main(int nargs, char **args)
{
   int ierr = 0;
   char pre;
   char *incd;
   int mbs[ATL_NCLUSTER], nbs[ATL_NCLUSTER], kbs[ATL_NCLUSTER];
   double total_perf, perf[ATL_NCLUSTER];
   pre = GetFlags(nargs, args, &incd);
   #ifdef ATL_NCLUSTER
   {
      FILE *fpout;
      char tids[2048];
      char ln[2048];
      int ti, tj, lni;

      /* first install amm for individual cluster */
      for (tj=0; tj<ATL_NCLUSTER; tj++)
      {
         lni = sprintf(tids, " -tl %d", ATL_CL_ncpus[tj]);
         for (ti=0; ti<ATL_CL_ncpus[tj]; ti++) 
            lni += sprintf(tids+lni, " %d", ATL_CL_affIds[tj][ti]);
         sprintf(ln, "make %cinstall_amm_cluster pre=%c CLID=%d ID=%d "
                     "TIDLIST=\"%s\" \n", 
                     pre, pre, tj, CL_AMM_ID_START+tj, tids);
         fprintf(stdout, "%s", ln);
         if (ierr=system(ln))
         {
            fprintf(stderr, 
               "ERROR at tuning for CLUSTER %d. Aborting ...\n", tj);
            return(ierr);
         }
      }

      /* find the performance stat to determine load balance */
      total_perf = 0;
      for (tj=0; tj<ATL_NCLUSTER; tj++)
      {
         char *res;
         sprintf(ln, "cat %s/atlas_%cu%damm_perf.h | "
                     "grep -m 1 ATL_UAMM_MAXMFLOP | cut -d' ' -s -f 3", 
                     incd, pre, CL_AMM_ID_START+tj);
         res = atlsys_1L(NULL, ln, 0, 0);
         if (res)
         {
            perf[tj] = atof(res);
            total_perf += perf[tj]*ATL_CL_ncpus[tj];
            free(res);
         }
      }

      /* find the blk-sz stat for GEMM use */
      GetMaxBList(pre, incd, mbs, nbs, kbs);

      /* save the performance stat in atlas_<pre>uamm_cluster.h */
      GenHeader(pre, incd, mbs, nbs, kbs, perf, total_perf);
      fprintf(stdout, "Summary header file generated.\n");

      /* compile tammm_G and tGetAmmInfo for each cluster */
      /* define CLID=<cluster_id> and UAMM_ID=<uamm-id> when compiling */
      fprintf(stdout, "Compiling cluster-specific GEMM.\n");
      for (tj=0; tj<ATL_NCLUSTER; tj++)
      {
         sprintf(ln, "make %cinstall_l3thr_cluster pre=%c CLID=%d UAMM_ID=%d", 
                 pre, pre, tj, CL_AMM_ID_START+tj);
         fprintf(stdout, "%s\n", ln);
         if (ierr=system(ln))
         {
            fprintf(stderr, 
               "ERROR at compiling gemm for CLUSTER %d. Aborting ...\n", tj);
            return(ierr);
         }
      }
   }
   #endif
   return(ierr);
}
@ROUT peaktim
#include "atlas_misc.h"
#include <assert.h>

void PrintUsage(char *name, int ierr, char *flag)
{
   if (ierr > 0)
      fprintf(stderr, "Bad argument #%d: '%s'\n", ierr,
              flag?flag:"OUT-OF_ARGUMENTS");
   else if (ierr < 0)
      fprintf(stderr, "ERROR: %s\n", flag);
   fprintf(stderr, "USAGE: %s [flags:\n", name);
   fprintf(stderr, "   -n <spclen>: workspace to pass\n");
   fprintf(stderr, "   -I <its> : iterations to pass\n");
   fprintf(stderr, "   -# <ntimes> : set # of times to time kernel\n");
   exit(ierr ? ierr : -1);
}
size_t GetFlags(int nargs, char **args, size_t *N, int *NREP)
{
   size_t nits = 10000;
   int i;

   *N = 128;
   *NREP = 3;
   for (i=1; i < nargs; i++)
   {
      if (args[i][0] != '-')
         PrintUsage(args[0], i, args[i]);
      switch(args[i][1])
      {
      case 'I':
        if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
         nits = atoll(args[i]);
         break;
      case 'n':
        if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
         *N = atoll(args[i]);
         break;
      case '#':
        if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
         *NREP = atoi(args[i]);
         break;
      default:
         PrintUsage(args[0], i, args[i]);
      }
   }
   return(nits);
}

double ATL_walltime(void);
void RunKern(size_t nits, void *vp);

int main (int nargs, char **args)
{
   size_t n, nits, i, ifl;
   double t0, mf, mfB;
   void *vp;
   char *cp;
   size_t *lp;
   int nrep;

   nits = GetFlags(nargs, args, &n, &nrep);
   vp = malloc(n+32);
   cp = ATL_AlignPtr(vp);
   lp = (size_t*)cp;
   for (i=0; i < n; i++)
      cp[i] = 0;

   mfB=0;
   for (i=0; i < nrep; i++)
   {
      t0 = ATL_walltime();
      RunKern(nits, (void*)cp);
      t0 = ATL_walltime() - t0;
      ifl = lp[0];
      mf = (((double)ifl)*nits) / (t0 * 1.0e6);
      if (mf > mfB)
         mfB = mf;
      printf("MFLOPS=%.2f\n", mf);
   }
   printf("\nBEST = %.2f\n\n", mfB);

   free(vp);
   return(0);
}
@ROUT cm2amtst
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <string.h>
#include "atlas_misc.h"

void cm2am_tst
(
   ATL_CSZT K,          /* number of rows in A */
   ATL_CSZT N,          /* number of columns in A */
   const SCALAR alpha,  /* scalar for A */
   const TYPE *A,       /* matrix to be copied to access-major format */
   ATL_CSZT lda,        /* stride between row elements */
   TYPE *pA,            /* OUTPUT: access-major block holding real(A) */
   int nu
)
{
   ATL_CINT nfblks = (N/nu), NNU=nfblks*nu, nr = N-NNU;
   for (j=0; j < NNU; j += nu)
   {
      for (k=0; k < k++)
      {
         for (i=0; i < nu; i++)
            *pA++ = A[(j+i)*lda+k]
      }
   }
   for (; j < N; j++)
   {
      for (k=0; k < k++)
      {
         for (i=0; i < nr; i++)
            *pA++ = A[(j+i)*lda+k]
         for (; i < nu; i++)
            *pA++ = ATL_rzero;
      }
   }
}

void InitEntryArray(int M, int N, TYPE *A, int lda)
{
   int i, j;
   for (j=0; j < N; j++)
   {
      for (i=0; i < lda; i++)
         A[i] = lda*j+i;
   }
   
}

main(int nargs, char **args)
{
   int M=12, N=10, lda=14, align=16, maxalign=32, mu=5, k, ierr=0;
   TYPE *A, *pA0, *pA1;
   TYPE alpha = 1.0;
   A = malloc(((2*M+lda)*N + 2*maxalign);
   assert(A);
   pA0 = A + lda*N;
   pA1 = pA0 + M*N;
   assert(maxalign > align);
   pA1 = (TYPE*)((((size_t)pA1)+maxalign-1)/maxalign)*maxalign;
   if (align)
      pA1 = (TYPE*)((size_t)pA1 + align);
   cm2am_tst(N, M, alpha, A, lda, pA0, mu);
   ATL_UCM2AM(N, M, alpha, A, lda, pA1);
   for (k=0; k < M*N; k++)
   {
      if (pA0[i] != pA1[i])
      {
         int i, j, jmu;
         jmu = k / (M*mu);
         j = k - (jmu*M*mu);
         i = j / mu;
         j = j % mu;
         if (pA0[i] != alpha*A[j*lda+i])
         {
            printf(
               "TEST COPY OR INDEX CALC WRONG: pA0[%d] != A[%d,%d] (%g, %g)\n"
                   k, i, j, pA0[i] != A[j*lda+i]);
            return(k+1);
         }
         printf("pA[%d] ([%d,%d] of matrix): expected=%g (%g), got=%g\n",
                i, i, j, pA0[i], A[j*lda+i], pA1[i]);
         ierr++;
      }
   }
   if (!ierr)
      printf("PASSED.\n");
   else
      printf("FAILED: %d\n", ierr);
   return(ierr);
}

@ROUT ATL_GetAmmAlg.c
#include "atlas_amm.h"
#include Mstr(Mjoin(ATLAS_PRE,geamm_blk.h))
#include Mstr(Mjoin(ATLAS_PRE,geamm_ablk2cmat.h))
#include Mstr(Mjoin(ATLAS_PRE,geamm_cm2am_a1.h))
#include Mstr(Mjoin(ATLAS_PRE,geamm_cm2am_an.h))
#include Mstr(Mjoin(ATLAS_PRE,geamm_cm2am_aX.h))
#include Mstr(Mjoin(ATLAS_PRE,geamm_flag.h))
#include Mstr(Mjoin(ATLAS_PRE,geamm_kern.h))

void GetAmmNMKDetails
(
/*
 * Input parameters describing problem; for now, don't use A/B/C, but might
 * be important to find aliasing later!
 */
   const enum ATLAS_TRANS TA,
   const enum ATLAS_TRANS TB,
   ATL_CSZT M,
   ATL_CSZT N,
   ATL_CSZT K,
   const SCALAR alpha,
   const TYPE *A,
   ATL_CSZT lda,
   const TYPE *B,
   ATL_CSZT ldb,
   const SCALAR beta,
   const TYPE *C,
   ATL_CSZT ldc
/*
 * Output params
 */
   ATL_SZT *mb, ATL_SZT *nb, ATL_SZT *kb,
   int *mu, int *nu, int *ku,
   ammkern_t *amm_b0, ammkern_t *amm_b1, ammkern_t *amm_bn, 
   cm2am_t *a2blk, *b2blk, ablk2cmat_t *blk2c
)
{

   if (SCALAR_IS_ONE(alpha))
   {
      if (SCALAR_IS_ONE(beta))
         *blk2c = ATL_AMM_BLK2C_a1_b1[IK];
      else if (SCALAR_IS_NONE(beta))
         *blk2c = ATL_AMM_BLK2C_a1_bn[IK];
      else if (SCALAR_IS_ZERO(beta))
         *blk2c = ATL_AMM_BLK2C_a1_b0[IK];
      else
         *blk2c = ATL_AMM_BLK2C_a1_bX[IK];
   }
   else if (alpha == ATL_rnone)
   {
      if (SCALAR_IS_ONE(beta))
         *blk2c = ATL_AMM_BLK2C_an_b1[IK];
      else if (SCALAR_IS_NONE(beta))
         *blk2c = ATL_AMM_BLK2C_an_bn[IK];
      else if (SCALAR_IS_ZERO(beta))
         *blk2c = ATL_AMM_BLK2C_an_b0[IK];
      else
         *blk2c = ATL_AMM_BLK2C_an_bX[IK];
   }
   else
   {
      if (beta == ATL_rone)
         *blk2c = ATL_AMM_BLK2C_aX_b1[IK];
      else if (beta == ATL_rnone)
         *blk2c = ATL_AMM_BLK2C_aX_bn[IK];
      else if (beta == ATL_rzero)
         *blk2c = ATL_AMM_BLK2C_aX_b0[IK];
      else
         *blk2c = ATL_AMM_BLK2C_aX_bX[IK];
   }
}
enum ATL_AMMALG ATL_GetAmmAlg
(
   const enum ATLAS_TRANS TA,
   const enum ATLAS_TRANS TB,
   ATL_CSZT M,
   ATL_CSZT N,
   ATL_CSZT K,
   const SCALAR alpha,
   const TYPE *A,
   ATL_CSZT lda,
   const TYPE *B,
   ATL_CSZT ldb,
   const SCALAR beta,
   const TYPE *C,
   ATL_CSZT ldc
{
   enum ATL_AMMALG ret=ATL_NMK;

   if (M <= ATL_AMM_MAXMB && N <= ATL_AMM_MAXNB && K <= ATL_AMM_MAXKB)
      ret = ATL_amm1b;
   else if (K <= ATL_RKK_MAXKB)  /* must create this! */
      ret = ATL_ammrkK;
   return(ret);
}
@ROUT genMM
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
enum VECEXT {VEC_None=0, VEC_VSX, VEC_AV, VEC_AVXMAC, VEC_AVXFMA4, VEC_AVX, 
             VEC_SSE3, VEC_SSE2, VEC_SSE1}
typedef enum VECEXT vec_t;
enum STRG {bcastB=0, kmaj};
typedef enum STRG strg_t;

char *typ = "double", *vtyp, *bcast, *mul, *add, *sub, *vld, *vst;
int VLEN, CL;
strg_t STRG=bcastB;

int GetVeclen(char pre, vec_t vec)
{
   int vlen;
   switch(vec)
   {
   case VEC_AVXMAC:
   case VEC_AVXFMA4:
   case VEC_AVX:
      vlen = 8;
      break;
   case VEC_VSX:
   case VEC_AV:
   case VEC_SSE3:
   case VEC_SSE2:
   case VEC_SSE1:
      vlen = 4;
      break;
   default:
      vlen = 1;
   }
   if (pre == 'd' && vlen > 1)
      vlen >>= 1;
}
void SetVecInfo(char pre, vec_t vec)
{
   VLEN = GetVeclen(pre, vec);
   if (pre == 'd')
   {
      switch(vec)
      {
      case VEC_AVXMAC:
      case VEC_AVXFMA4:
      case VEC_AVX:
         vtyp = "__m256d";
         bcast = "_mm256_broadcast_sd";
         mul = "_mm256_mul_pd";
         add = "_mm256_add_pd";
         sub = "_mm256_sub_pd";
         vld = "_mm256_load_pd";
         vst = "_mm256_store_pd";
         vlen = 4;
         break;
      case VEC_VSX:
      case VEC_AV:
      case VEC_SSE3:
      case VEC_SSE2:
      case VEC_SSE1:
         vlen = 4;
         break;
      default:
         vlen = 1;
      }
   }
   else
   {
   }
}
void PrintDecl(FILE *fp)
{
   fprintf(fp, "void ATL_USERMM(ATL_CSZT nmus, ATL_CSZT nnus, ATL_CSZT K,\n");
   fprintf(fp, "                const %s *pA, const %s *pB, %s *pC,\n",
           typ, typ, typ);
   fprintf(fp, "                const %s *pAn, const %s *pBn, const %s *pCn)\n",
           typ, typ, typ);
}
void DoKloop(FILE *fp, char pre, vec_t vec, int kmaj, int kb, 
             int mu, int nu, int ku)
{
   if (kmaj)
   {
      assert(kmaj == VLEN)
      assert(ku%kmaj == 0);
   }
   if (kb)
   {
      assert(kb%ku == 0);
      if (kb > ku)
         fprintf(fp, "      for (k=%d; k < %d; k += %d\n", ku, kb, ku);
   }
   else
      fprintf(fp, "      for (k=%d; k < K; k += %d\n", ku, ku);
   fprintf(fp,    "      {\n");
   fprintf(fp,    "      } /* end of K-loop */ \n");
}
void genMM(FILE *fp, char pre, vec_t vec, int kmaj, int kb, 
           int mu, int nu, int ku)
{
   int i, j;
   int incb = (kmaj) ? kmaj : 1;
   int ia=0, ib=0;
   char *Bld = (kmaj) ? "vld" : "bcast";

   if (kb && ku+ku >= kb)
      ku = kb;
   else
      ku = 0;

   fprintf(fp, "#include <atlas_simd.h>\n\n");
   PrintDecl(fp);
   fprintf(fp, "/*\n");
   fprintf(fp, 
" * Access-major matmul with: pre=%c, KMAJ=%d, kb=%d, mu=%d, nu=%d\n",
           pre, kmaj, kb, mu, nu);
   fprintf(fp, " */\n");
   fprintf(fp, "{\n");
   fprintf(fp, "   size_t i, j, k, incPF\n");
   if (kb)
      fprintf(fp, "   #define incA %d\n", mu*kb);
   else
      fprintf(fp, "   const size_t incA = K*%d\n", mu);
   fprintf(fp, "   const %s *pB0=pB;\n", typ);
   fprintf(fp, "   register ATL_VTYP rA0");
   for (j=1; j < nu; j++)
      fprintf(fp, ", rA%d", j);
   fprintf(fp, ";\n");
   fprintf(fp, "   register ATL_VTYP rB0");
   for (j=1; j < mu; j++)
      fprintf(fp, ", rB%d", j);
   fprintf(fp, ";\n");
   fprintf(fp, "   register ATL_VTYP rC0_0");
   for (j=0; j < nu; j++)
      for (i=0; i < mu; i++)
         if (i | j)
            fprintf(fp, ", rC%d_%d", i, j);
   fprintf(fp, ";\n");
   fprintf(fp, "\n");
   fprintf(fp, "   for (i=0; i < nmus; i++, pA += incA)\n   {\n");
   fprintf(fp, "      const %s *a=pA;\n");
   fprintf(fp, "      for (j=0; j < nnus; j++)\n      {\n");
/*
 * Rewrite to peel X its in order to schedule loads & prefetches, then
 * start loop; will have specialized routines for each case
 */
   fprintf(fp, "/*\n *         K=0 it peeled to zero rCx_x\n */\n");
   for (j=0; j < nu; j++)
      fprintf(fp, "         ATL_v%s(rB%d, pB+%d);\n", Bld, j, j*incb);
   if (!ku)
      fprintf(fp, "         pB += %d;\n", nu*incb);
   else 
      ib += nu*incb;
   for (i=0; i < mu; i++)
      fprintf(fp, "         ATL_vld(rA%d, a+%d);\n", i, i*VLEN);
   if (!ku)
      fprintf(fp, "         pA += %d;\n", VLEN*mu);
   else 
      ia += VLEN*mu;

   for (j=0; j < nu; j++)
   {
      for (i=0; i < mu; i++)
      {
         fprintf(fp, "         ATL_vmul(rC%d_%d, rA%d, rB%d);\n",
                 i, j, i, j);
         if (j==nu-1)
            fprintf(fp, "         ATL_vld(rA%d, a+%d);\n", i, ia+i*VLEN);
      }
      if (j != nu-1)
         fprintf(fp, "         ATL_v%s(rB%d, pB+%d);\n", Bld, j, ib+j*incb);
   }
   if (kb && ku+ku > kb) /* fully unrolled K loop */
   {
      fprintf(fp, "         ATL_v%s(rB0, pB+%d);\n", Bld, nu*incb);
      for (k=VLEN; k < kb; k += VLEN)
      {
         fprintf(fp, "/*\n *         K=%d iteration\n */\n");
      }
   }
   else
   {
      if (kmaj)
      {
         if (kb)
            fprintf(fp, "         for (k=%d; k < %d; k += %d)\n         {\n",
                    VLEN, kb, VLEN);
         else
            fprintf(fp, "         for (k=%d; k < K; k += %d)\n         {\n",
                    VLEN, VLEN);
      }
      else
      {
         fprintf(fp, "         for (k=1; k < K; k++)\n         {\n");
      }
      fprintf(fp, "         }  /* end K-loop */\n");
   }
   fprintf(fp, "         a += %d;\n", mu*VLEN);
   fprintf(fp, "         pB += %d;\n", nu*incb);

   fprintf(fp, "      } /* end j-loop */\n");
   fprintf(fp, "      pB = pB0;\n");
   fprintf(fp, "   } /* end i-loop */\n");

   
   fprintf(fp, "}\n");
   if (kb)
      fprintf(fp, "#undef incA\n");
}
void PrintUsage(char *name, int ierr, char *flag)
{
   if (ierr > 0)
      fprintf(stderr, "Bad argument #%d: '%s'\n", ierr, 
              flag?flag:"OUT-OF_ARGUMENTS");
   else if (ierr < 0)
      fprintf(stderr, "ERROR: %s\n", flag);
   fprintf(stderr, "USAGE: %s [flags]:\n", name);
   fprintf(stderr, "   -p [s,d,c,z]: set type/precision prefix (d) \n");
   fprintf(stderr, "   -o <outfile>: path & file to generate\n");
   fprintf(stderr, "   -U[m,n,k]: set unrolling factor\n");
   fprintf(stderr, "   -V [sse1,sse2,sse3,avx,fma3,fma4,ppcav,vsx]\n");
   fprintf(stderr, "   -K # : non-zero number is fixed K loop\n");
   fprintf(stderr, "   -S [B,K]: storage bcastB/KU-major\n");
}

FILE *GetFlags(char *PRE, vec_t *VEC, int *KMAJ, int *KB, 
               int *MU, int *NU, int *KU)
{
   FILE *fpout=stdout;
   *PRE = 'd';
   *VEC = VEC_SSE3;
   *KMAJ = *KB = 0;
   *MU = *NU = 3;
   *KU = 1;
}
int main(int nargs, char **args)
{
   char pre='d';
   int mu, nu, ku, kb;
   FILE *fpout;
   vec_t vec;
   
   fpout = GetFlags(&pre, &vec, &kb, &kmaj, &mu, &nu, &ku);
   if (pre == 's')
      typ = "float";
   genMM(pre, vec, kmaj, kb, mu, nu, ku);
}
@ROUT ATL_GetRankKInfo
#define ATL_NOAMM 1
#include "atlas_misc.h"
#undef ATL_NOAMM
#include Mstr(Mjoin(ATLAS_PRE,rkamm_kern.h))
#include Mstr(Mjoin(ATLAS_PRE,rkamm_blk.h))
#include Mstr(Mjoin(ATLAS_PRE,rkamm_flag.h))
#include Mstr(Mjoin(ATLAS_PRE,rkamm_perf.h))

int Mjoin(PATL,GetRankKInfo)
(
   amminfo_t *out,
   enum ATLAS_TRANS TA,
   enum ATLAS_TRANS TB,
   ATL_CSZT M,
   ATL_CSZT N,
   ATL_CSZT K,
   const SCALAR alpha,
   const SCALAR beta
)
{
   const int ik = K-3;
   int appAl;  /* 0:A, 1:B */
   ATL_assert(K > 2 && K <= ATL_MAXK_RKK);
@ROUT ATL_GetAmmmInfoSQ
#include "atlas_misc.h"
#include Mstr(Mjoin(ATLAS_PRE,sqamm_blk.h))
#include Mstr(Mjoin(ATLAS_PRE,sqamm_ablk2cmat.h))
#include Mstr(Mjoin(ATLAS_PRE,sqamm_cm2am_a1.h))
#include Mstr(Mjoin(ATLAS_PRE,sqamm_cm2am_an.h))
#include Mstr(Mjoin(ATLAS_PRE,sqamm_cm2am_aX.h))
#include Mstr(Mjoin(ATLAS_PRE,sqamm_flag.h))
#include Mstr(Mjoin(ATLAS_PRE,sqamm_kern.h))
#include Mstr(Mjoin(ATLAS_PRE,sqamm_perf.h))

#ifdef ATL_CAMM_MAXINDX
   #define ATL_MAXIDX ATL_CAMM_MAXINDX
#elif defined(ATL_AMM_98IDX) && !defined(ATL_AMM_66IDX)
   #define ATL_MAXIDX ATL_AMM_98IDX
#endif
#ifndef ATL_MAXIDX
   #define ATL_MAXIDX ATL_AMM_NCASES-1
#endif

static INLINE void FillInInfo(amminfo_t *out, int id)
{
   out->IDX = id;
   out->nb = out->kb = out->mb = ATL_AMM_KBs[id];
   out->mu = ATL_AMM_MUs[id];
   out->nu = ATL_AMM_NUs[id];
   out->ku = ATL_AMM_KUs[id];
   out->kbmin = ATL_AMM_KBMINs[id];
   out->flag = ATL_AMM_KFLAG[id];
   out->amm_b0 = ATL_AMM_KERN_b0[id];
   out->amm_b1 = ATL_AMM_KERN_b1[id];
   out->amm_bn = ATL_AMM_KERN_bn[id];
   out->amm_k1_b0 = ATL_AMM_KERN_K1[id];
   out->amm_k1_b1 = ATL_AMM_KERN_K1_b1[id];
   out->amm_k1_bn = ATL_AMM_KERN_K1_bn[id];
}

static INLINE ablk2cmat_t GetBlk2C(int id, int ialp, int ibet)
{
   if (ialp == 1)
   {
      if (ibet == 1)
         return(ATL_AMM_BLK2C_a1_b1[id]);
      else if (!ibet)
         return(ATL_AMM_BLK2C_a1_b0[id]);
      else if (ibet == -1)
         return(ATL_AMM_BLK2C_a1_bn[id]);
      return(ATL_AMM_BLK2C_a1_bX[id]);
   }
   else if (ialp == -1)
   {
      if (ibet == 1)
         return(ATL_AMM_BLK2C_an_b1[id]);
      else if (!ibet)
         return(ATL_AMM_BLK2C_an_b0[id]);
      else if (ibet == -1)
         return(ATL_AMM_BLK2C_an_bn[id]);
      return(ATL_AMM_BLK2C_an_bX[id]);
   }
   else
   {
      if (ibet == 1)
         return(ATL_AMM_BLK2C_aX_b1[id]);
      else if (!ibet)
         return(ATL_AMM_BLK2C_aX_b0[id]);
      else if (ibet == -1)
         return(ATL_AMM_BLK2C_aX_bn[id]);
      return(ATL_AMM_BLK2C_aX_bX[id]);
   }
}

int Mjoin(PATL,GetSyrkInfo)  /* returns nb */
(
   amminfo_t *out,
   int ialp,             /* 1:alpha=1.0, -1:-1.0, else alpha=X */
   enum ATLAS_TRANS TA,
   ATL_CSZT N,           /* size of triangular matrix */
   ATL_CSZT K,           /* K dim of A/A^T */
   int ibet              /* 0:beta=0.0 1:beta=1.0, -1:-1.0, else beta=X */
)
{
   int id=0, nb, ibest=0;
   double timB = ((double)N)*N*K*ATL_sqAMM_TIME[0];
   for (id=0; id < ATL_AMM_NCASES; id++)
   {
      double tim;
      const int nb=ATL_AMM_KBs[id];
      ATL_SZT ndiag, ncblks;
      ATL_CSZT nnblks=N/nb, nkblks=K/nb;
      const int nr=N-nnblks*nb, kr=K-nkblks*nb;
      if (nb+nb > K)
         break;
      tim = nkblks*ATL_sqAMM_TIME[id];
      if (kr)
      {
         int i;
         double d;
         for (i=id; i > 0; i--)         /* find kb closest to kr to */
            if (ATL_AMM_KBs[i] <= kr)   /* estimate K-clean speed */
               break;
         d = nb;
         d /= (double)ATL_AMM_KBs[i];
         tim += d*ATL_sqAMM_TIME[i]*d*d;
      }
      ndiag = (nr) ? nnblks+1 : nnblks;
      ncblks = ((ndiag-1)*ndiag)>>1;
      tim *= (ndiag+ncblks);
      if (tim < timB)
      {
         timB = tim;
         ibest = id;
      }
   }
   id = ibest;

   FillInInfo(out, id);
// printf("IDX=%d, B=%d, U=(%d,%d,%d)\n", id, out->nb, out->mu,out->nu,out->ku);
   nb = out->nb;
   out->Cblk2cm = GetBlk2C(id, 1, ibet);
   out->Cblk2cm_b1 = ATL_AMM_BLK2C_a1_b0[id]; /* _b1 is really _b0 for SYRK! */
   if (TA == AtlasNoTrans)
   {
      out->a2blk = ATL_AMM_AT2BLK_a1[id];
      if (ialp == 1)
         out->b2blk = ATL_AMM_BT2BLK_a1[id];
      else
         out->b2blk = (ialp == -1)?ATL_AMM_BT2BLK_an[id]:ATL_AMM_BT2BLK_aX[id];
   }
   #ifdef TCPLX
   else if (TA == AtlasConj)  /* means HERK, noTrans */
   {
      out->a2blk = ATL_AMM_AT2BLK_a1[id];
      if (ialp == 1)
         out->b2blk = ATL_AMM_BH2BLK_a1[id];
      else
         out->b2blk = (ialp == -1)?ATL_AMM_BH2BLK_an[id]:ATL_AMM_BH2BLK_aX[id];
   }
   else if (TA == AtlasConjTrans)  /* Means HERK, HermTrans */
   {
      out->a2blk = ATL_AMM_AC2BLK_a1[id];
      if (ialp == 1)
         out->b2blk = ATL_AMM_B2BLK_a1[id];
      else
         out->b2blk = (ialp == -1)?ATL_AMM_B2BLK_an[id]:ATL_AMM_B2BLK_aX[id];
   }
   #endif
   else  /* TA == AtlasTrans */
   {
      out->a2blk = ATL_AMM_A2BLK_a1[id];
      if (ialp == 1)
         out->b2blk = ATL_AMM_B2BLK_a1[id];
      else
         out->b2blk = (ialp == -1)?ATL_AMM_B2BLK_an[id]:ATL_AMM_B2BLK_aX[id];
   }
   return(nb);
}
#ifdef TREAL
/*
 * For TRSM, we need a kernel with mb == kb, but nb can differ.
 * Alpha for A will be -1, for B it will 1,  and Cblk2cm will be for beta=alpha,
 * while Cbk2cm_b1 will be for beta=1.0.
 * RETURNS: mb to use, 0 if ATL_trsmKL_rk4 should be called instead.
 */
#include "atlas_ttypes.h"
#include Mstr(Mjoin(ATLAS_PRE,tsamm_perf.h))
int Mjoin(PATL,GetTrsmInfo)
(
   amminfo_t *out,
   int ialp,            /* 0 alpha=0.0, 1:alpha=1.0, -1:-1.0, else alpha=X */
   enum ATLAS_TRANS TA,
   ATL_CSZT M,           /* size of triangular matrix */
   ATL_CSZT N,           /* NRHS */
   const SCALAR beta
)
{
   #define MAXIDX ATL_AMM_NCASES-1
   int ik = MAXIDX;
   int mu, nu, ku, nb, nnblks, mb, nmblks, mb0, ibest, bbest;
   double tslv;   /* predicted time to solve whole prob wt trsmK */
   double tbest;  /* start it at time using nb=4 (ik=0) */

/*
 * First, find speed of trsmK by taking MB closest to M
 */
   if (M >= ATL_AMM_MAXKB)
      tslv = ATL_tsAMM_TIME[MAXIDX];
   else
   {
      int i;
      for (i=MAXIDX; i > 0; i--)
         if (ATL_AMM_KBs[i] <= M)
            break;
      tslv = ATL_tsAMM_TIME[i];
   }
   tslv = ((1.0*M)*M*N) * tslv;
   tbest = tslv;
   ibest = -1;
   bbest = -1;
/*
 * Now loop over all square block factors, and find the best predicted perf
 */
   for (ik=0; ik < ATL_AMM_NCASES; ik++)
   {
      const int kb = ATL_AMM_KBs[ik];
      int mb, ndi, nsq;
      double tim, tfl;
      if (kb+kb >= M)  /* don't use blks leading to little amm */
         break;
      ndi = M/kb;              /* # of full diagonal blocks */
      nsq = ((ndi-1)*ndi)>>1; /* # of full amm blks */
      mb = M - ndi*kb;         /* partial block at beginning */
      tfl = kb;                /* triangular flops are half  */
      tfl = tfl*kb*N;          /* of amm flops for same kb */
/*
 *    Compute time to do full blocks portion of algorithm
 */
      tim = (ndi*tfl)*ATL_tsAMM_TIME[ik] +             /* slv time */
            (nsq*(tfl+tfl))*ATL_sqAMM_TIME[ik];        /* amm time */
      if (mb) /* need to find perf of partial block */
      {
         int i;
         const double pfl=(1.0*mb)*kb*N, mmfl=(2.0*ndi)*ndi*N;

         for (i=ik; i > 0; i--)
            if (ATL_AMM_KBs[ik] <= mb)
               break;
         tim += pfl * ATL_tsAMM_TIME[i];   /* extra slvtime */
         tim += mmfl * ATL_sqAMM_TIME[i];  /* extra mmtime */
      }
//    printf("idx=%d, kb=%d(%d), spdup=%e\n", ik, kb, ATL_AMM_KBs[ik], 
//           trk4/tim);
      if (tim <= tbest)
      {
         tbest = tim;
         ibest = ik;
         bbest = kb;
      }
   }
// best=0;   /* FOR TESTING!!!!! */
   if (ibest < 0)
      return(0);
   ik = ibest;

   out->IDX = ik;
   out->mb = mb = out->kb = bbest;
   out->nb = nb = ATL_AMM_NBs[ik];
   out->mu = mu = ATL_AMM_MUs[ik];
   out->nu = nu = ATL_AMM_NUs[ik];
   out->ku = ku = ATL_AMM_KUs[ik];
   out->kbmin = ATL_AMM_KBMINs[ik];
   out->mu = ATL_AMM_MUs[ik];
   out->nu = ATL_AMM_NUs[ik];
   out->ku = ATL_AMM_KUs[ik];
   out->flag = ATL_AMM_KFLAG[ik];
   out->amm_b0 = ATL_AMM_KERN_b0[ik];
   out->amm_b1 = ATL_AMM_KERN_b1[ik];
   out->amm_bn = ATL_AMM_KERN_bn[ik];
   out->amm_k1_b0 = ATL_AMM_KERN_K1[ik];
   out->amm_k1_b1 = ATL_AMM_KERN_K1_b1[ik];
   out->amm_k1_bn = ATL_AMM_KERN_K1_bn[ik];
   out->a2blk = (TA == AtlasNoTrans) ? 
                ATL_AMM_AT2BLK_an[ik]:ATL_AMM_A2BLK_an[ik];
   out->b2blk = ATL_AMM_B2BLK_a1[ik];
   if (ialp == 1)
      out->Cblk2cm = ATL_AMM_BLK2C_a1_b1[ik];
   else if (ialp == -1)
      out->Cblk2cm = ATL_AMM_BLK2C_a1_bn[ik];
   else
      out->Cblk2cm = (ialp) ? ATL_AMM_BLK2C_a1_bX[ik]:ATL_AMM_BLK2C_a1_b0[ik];
   out->Cblk2cm_b1 = ATL_AMM_BLK2C_a1_b1[ik];
   out->cm2Cblk = NULL;
   printf("ik=%d, mb=%d(%d), nb=%d, pred spdup=%.2f\n", ik, out->mb, mb, 
          out->nb, tslv/tbest);
   return(mb);
}

/*
 * For TRSM, we're going to get our main parellelism from the N dimension
 * We know that mb==kb, but nb is independent.  alpha for A will be -1,
 * and for B it will 1.  Cblk2cm will be beta=0, while Cbk2cm_b1 will be 1.
 * RETURNS: upper bound on useful nthreads to use
 */
#include "atlas_ttypes.h"
int Mjoin(PATL,tGetTrsmInfo)
(
   ATL_ttrsm_amm_t *pd,
   int P,
   enum ATLAS_TRANS TA,
   ATL_CSZT M,
   ATL_CSZT N,
   const SCALAR beta
)
{
   #ifdef ATL_CAMM_MAXINDX
      int ik = ATL_CAMM_MAXINDX;
   #else
      int ik = ATL_AMM_NCASES-1;
   #endif
   int mu, nu, ku, nb, nnblks, mb, nmblks, mb0;

@beginskip
   #ifdef TREAL
      nb = ATL_AMM_NBs[ik];
      nnblks = N / nb;
      if (nnblks > P && ik > ATL_AMM_98IDX)
      {
         ik = ATL_AMM_98IDX;
      }
   #endif
@endskip
/*
 * Get a KB smaller than M
 */
   for (; ik > 0 && ATL_AMM_KBs[ik] > M; ik--);

/*
 * Find a kernel where mb can be set to kb; we know these exist, since we insist
 * on square problems of moderate size
 */
   for (; ik > 0; ik--)
   {
      mu = ATL_AMM_MUs[ik];
      mb = ATL_AMM_KBs[ik];
      if (mb > M)
         continue;
/*
 *    Any kernel can be used if it can be called with MB = KB
 */
      if ((mb/mu)*mu == mb)       /* it is legal to call wt MB=KB */
         break;                   /* so use this kernel */
/*
 *    KRUNTIME kernels can vary their KB, and thus be made legal
 */
      if (ATL_AMM_KRUNTIME(ATL_AMM_KFLAG[ik]))
      {
         ku = ATL_AMM_KUs[ik];
         ku = ATL_lcm(ku, mu);
         mb = (mb/ku)*ku;
         if (mb)
            break;
      }
   }
// ik=0;   /* FOR TESTING!!!!! */
   pd->mb = mb = ATL_AMM_KBs[ik];
   nb = ATL_AMM_NBs[ik];
   nu = ATL_AMM_NUs[ik];
@beginskip
/*
 * Restrict either nb or P in order to split up RHS
 */
   if (nb*P > N)
   {
      if (nb > (nu<<2))  /* try reducing large NB to 4*nu,  */
      {                  /* still allows A reuse by factor 4 */
         int k = N / (nu<<2);
         if (k <= P)
         {
            nb = (nu<<2);
            P = (k*nb != N) ? k+1 : k;
         }
      }
      else
         P = (N+nb-1) / nb;
   }
@endskip
   if (P*nb > N)
      P = (N+nb-1)/nb;
   pd->nb = nb;
   mu = ATL_AMM_MUs[ik];
   ku = ATL_AMM_KUs[ik];
   pd->nmu = mb / mu;
   pd->nnu = nb / nu;
   nnblks = N / nb;
   pd->nbf = N - nb*nnblks;
   if (!pd->nbf)
   {
      pd->nbf = nb;
      pd->nnuf = pd->nnu;
   }
   else
   {
      nnblks++;
      pd->nnuf = (pd->nbf+nu-1)/nu;
   }
   pd->nnblks = nnblks;
   pd->amm_b0 = ATL_AMM_KERN_b0[ik];
   pd->amm_b1 = ATL_AMM_KERN_b1[ik];
   nmblks = M/mb;
   mb0 = (M - nmblks*mb);
   if (!mb0)
   {
      pd->MB0 = mb0 = mb;
      pd->nmu0 = pd->nmu;
   }
   else
   {
      nmblks++;
      if (ATL_AMM_KMAJOR(ik))
      {
         pd->MB0 = ((mb0+ku-1)/ku)*ku;
         if (!ATL_AMM_KRUNTIME(ik))
            pd->amm_b0 = ATL_AMM_KERN_K1[ik];
      }
      else if (!ATL_AMM_KRUNTIME(ik) || mb0 != (mb0/ku)*ku ||
               mb0 < ATL_AMM_KBMINs[ik])
      {
         pd->amm_b0 = ATL_AMM_KERN_K1[ik];
         pd->MB0 = mb0;
      }
      else
         pd->MB0 = mb0;
      pd->nmu0 = (mb0+mu-1)/mu;
   }
   pd->mb0 = mb0;
   pd->nmblks = nmblks;
   pd->nxblks = nnblks * nmblks;
   if (P > pd->nxblks)
      P = pd->nxblks;
   pd->mu = mu;
   pd->nu = nu;
   pd->ku = ATL_AMM_KUs[ik];
   #ifdef TCPLX
      if (TA == AtlasConjTrans)
         pd->a2blk = ATL_AMM_AC2BLK_an[ik];
      else if (TA == AtlasConj)
         pd->a2blk = ATL_AMM_AH2BLK_an[ik];
      else
   #endif
   pd->a2blk = (TA == AtlasNoTrans) ? 
               ATL_AMM_AT2BLK_an[ik] : ATL_AMM_A2BLK_an[ik];
   pd->b2blk = ATL_AMM_B2BLK_a1[ik];
/*
 * beta != 0, because then trsm simply zeros X and returns
 */
   if (SCALAR_IS_ONE(beta))
      pd->blk2c = ATL_AMM_BLK2C_a1_b1[ik];
   else if (SCALAR_IS_NONE(beta))
      pd->blk2c = ATL_AMM_BLK2C_a1_bn[ik];
   else
      pd->blk2c = ATL_AMM_BLK2C_a1_bX[ik];
// printf("ik=%d, mb=%d(%d), nb=%d(%d), MB0=%d\n", ik, pd->mb, pd->mb0, pd->nb, pd->nbf, pd->MB0);
   return(P);
}

ablk2cmat_t Mjoin(PATL,tGetSyammInfo)
(
   amminfo_t *out,
   const int P,          /* scale you want to use */
   enum ATLAS_TRANS TA,
   ATL_CSZT N,
   ATL_CSZT K,
   const SCALAR alpha,
   const SCALAR beta
)
{
   ablk2cmat_t dblk2cmat;
   int ik = ATL_MAXIDX;
   int nb, k;
   if (K < ATL_AMM_MAXKB)  
   {
      for (ik=0; ik <= ATL_MAXIDX && ATL_AMM_KBs[ik] < K; ik++);
   }
   nb = ATL_AMM_MBs[ik];
   #ifdef ATL_AMM_66IDX
      while (ik > ATL_AMM_66IDX)
      {
         k = N / nb;
         k = ((k-1)*k)>>1;
         if (k >= P)
            break;
         nb = ATL_AMM_MBs[--ik];
      }
   #endif
   out->IDX = ik;
   nb = Mmax(nb, ATL_AMM_NBs[ik]);
   if (nb > N)
      nb = N;
   out->mu = ATL_AMM_MUs[ik];
   out->nu = ATL_AMM_NUs[ik];
   out->ku = ATL_AMM_KUs[ik];
   k = ATL_lcm(out->mu, out->nu);
   nb = (nb > k) ? (nb/k)*k : k;
   out->nb = out->mb = nb;
   out->kb = ATL_AMM_KBs[ik];
/*   printf("tGetSyAMM, nb=%d, kb=%d, ik=%d\n", nb, out->kb, ik); */
   out->kbmin = ATL_AMM_KBMINs[ik];
   out->flag = ATL_AMM_KFLAG[ik];
   out->amm_b0 = ATL_AMM_KERN_b0[ik];
   out->amm_b1 = ATL_AMM_KERN_b1[ik];
   out->amm_bn = ATL_AMM_KERN_bn[ik];
   out->amm_k1_b0 = ATL_AMM_KERN_K1[ik];
   out->amm_k1_b1 = ATL_AMM_KERN_K1_b1[ik];
   out->amm_k1_bn = ATL_AMM_KERN_K1_bn[ik];
   if (TA == AtlasNoTrans)
   {
      out->a2blk = ATL_AMM_AT2BLK_a1[ik];
      out->b2blk =  ATL_AMM_BT2BLK_a1[ik];
   }
   else
   {
      out->a2blk = ATL_AMM_A2BLK_a1[ik];
      out->b2blk =  ATL_AMM_B2BLK_a1[ik];
   }
   if (SCALAR_IS_ONE(alpha))
   {
      dblk2cmat = ATL_AMM_BLK2C_a1_b0[ik];
      if (SCALAR_IS_ONE(beta))
         out->Cblk2cm = ATL_AMM_BLK2C_a1_b1[ik];
      else if (SCALAR_IS_NONE(beta))
         out->Cblk2cm = ATL_AMM_BLK2C_a1_bn[ik];
      else if (SCALAR_IS_ZERO(beta))
         out->Cblk2cm = ATL_AMM_BLK2C_a1_b0[ik];
      else
         out->Cblk2cm = ATL_AMM_BLK2C_a1_bX[ik];
   }
   else if (SCALAR_IS_NONE(alpha))
   {
      dblk2cmat = ATL_AMM_BLK2C_an_b0[ik];
      if (SCALAR_IS_ONE(beta))
         out->Cblk2cm = ATL_AMM_BLK2C_an_b1[ik];
      else if (SCALAR_IS_NONE(beta))
         out->Cblk2cm = ATL_AMM_BLK2C_an_bn[ik];
      else if (SCALAR_IS_ZERO(beta))
         out->Cblk2cm = ATL_AMM_BLK2C_an_b0[ik];
      else
         out->Cblk2cm = ATL_AMM_BLK2C_an_bX[ik];
   }
   else  /* alpha = X */
   {
      dblk2cmat = ATL_AMM_BLK2C_aX_b0[ik];
      if (SCALAR_IS_ONE(beta))
         out->Cblk2cm = ATL_AMM_BLK2C_aX_b1[ik];
      else if (SCALAR_IS_NONE(beta))
         out->Cblk2cm = ATL_AMM_BLK2C_aX_bn[ik];
      else if (SCALAR_IS_ZERO(beta))
         out->Cblk2cm = ATL_AMM_BLK2C_aX_b0[ik];
      else
         out->Cblk2cm = ATL_AMM_BLK2C_aX_bX[ik];
   }
   return(dblk2cmat);
}
/*
 * returns cblk2c_b0, cblk2c_b1 is in structure
 */
ablk2cmat_t Mjoin(PATL,tGetSyammInfo_K)
(
   amminfo_t *out,
   const int P,          /* scale you want to use */
   enum ATLAS_TRANS TA,
   ATL_CSZT N,
   ATL_CSZT K
)
{
   ablk2cmat_t dblk2cmat;
   int ik = ATL_AMM_NCASES-1;
   int mb, nb, k, mu, nu;

   if (K < ATL_AMM_MAXKB)  
      for (ik=0; ik < ATL_AMM_NCASES-1 && ATL_AMM_KBs[ik] < K; ik++);
   out->IDX = ik;
   mu = out->mu = ATL_AMM_MUs[ik];
   nu = out->nu = ATL_AMM_NUs[ik];
   out->ku = ATL_AMM_KUs[ik];
   out->mb = ((N+mu-1)/mu)*mu;
   out->nb = ((N+nu-1)/nu)*nu;
   out->kb = ATL_AMM_KBs[ik];
/*  printf("tGetSyAMM_K, mb=%d, nb=%d, kb=%d, ik=%d\n", mb, nb, out->kb, ik); */
   out->kbmin = ATL_AMM_KBMINs[ik];
   out->flag = ATL_AMM_KFLAG[ik];
   out->amm_b0 = ATL_AMM_KERN_b0[ik];
   out->amm_b1 = ATL_AMM_KERN_b1[ik];
   out->amm_bn = ATL_AMM_KERN_bn[ik];
   out->amm_k1_b0 = ATL_AMM_KERN_K1[ik];
   out->amm_k1_b1 = ATL_AMM_KERN_K1_b1[ik];
   out->amm_k1_bn = ATL_AMM_KERN_K1_bn[ik];
   if (TA == AtlasNoTrans)
   {
      out->a2blk = ATL_AMM_AT2BLK_a1[ik];
      out->b2blk =  ATL_AMM_BT2BLK_a1[ik];
   }
   else
   {
      out->a2blk = ATL_AMM_A2BLK_a1[ik];
      out->b2blk =  ATL_AMM_B2BLK_a1[ik];
   }
   out->Cblk2cm = ATL_AMM_BLK2C_a1_b1[ik];
   return(ATL_AMM_BLK2C_a1_b0[ik]);
}
#endif
@ROUT ATL_GetAmmmInfo
#include "atlas_misc.h"
#if !defined(ATL_NCLUSTER) || !defined(CLID)
#include Mstr(Mjoin(ATLAS_PRE,geamm_blk.h))
#include Mstr(Mjoin(ATLAS_PRE,geamm_ablk2cmat.h))
#include Mstr(Mjoin(ATLAS_PRE,geamm_cm2am_a1.h))
#include Mstr(Mjoin(ATLAS_PRE,geamm_cm2am_an.h))
#include Mstr(Mjoin(ATLAS_PRE,geamm_cm2am_aX.h))
#include Mstr(Mjoin(ATLAS_PRE,geamm_flag.h))
#include Mstr(Mjoin(ATLAS_PRE,geamm_kern.h))

int Mjoin(PATL,GetAmmmInfo)
(
   amminfo_t *out,
   enum ATLAS_TRANS TA,
   enum ATLAS_TRANS TB,
   ATL_CSZT M,
   ATL_CSZT N,
   ATL_CSZT K,
   const SCALAR alpha,
   const SCALAR beta
)
{
   #ifdef ATL_CAMM_MAXINDX
      int ik=ATL_CAMM_MAXINDX;
   #else
      int ik=ATL_AMM_NCASES-1; 
   #endif
   int appAl;  /* 0:A, 1:B, 2:C */
/*
 * For rank-K update, choose smallest KB that contains required K
 */
   if (K < ATL_AMM_MAXKB)  
   {
      for (ik=0; ik < ATL_AMM_NCASES && ATL_AMM_KBs[ik] < K; ik++);
   }
@ROUT ATL_GetAmmmInfo ATL_GetRankKInfo
   out->IDX = ik;
   out->mb = ATL_AMM_MBs[ik];
   out->nb = ATL_AMM_NBs[ik];
   out->kb = ATL_AMM_KBs[ik];
   #ifdef ATL_CAMM_MAXINDX
      if (ik == ATL_CAMM_MAXINDX)
      {
         out->mb = ATL_CAMM_MAXMB;
         out->nb = ATL_CAMM_MAXNB;
         out->kb = ATL_CAMM_MAXKB;
      }
   #endif
   out->kbmin = ATL_AMM_KBMINs[ik];
   out->mu = ATL_AMM_MUs[ik];
   out->nu = ATL_AMM_NUs[ik];
   out->ku = ATL_AMM_KUs[ik];
   out->flag = ATL_AMM_KFLAG[ik];
@ROUT ATL_GetAmmmInfo
   out->amm_b0 = ATL_AMM_KERN_b0[ik];
   out->amm_b1 = ATL_AMM_KERN_b1[ik];
   out->amm_bn = ATL_AMM_KERN_bn[ik];
   out->amm_k1_b0 = ATL_AMM_KERN_K1[ik];
   out->amm_k1_b1 = ATL_AMM_KERN_K1_b1[ik];
   out->amm_k1_bn = ATL_AMM_KERN_K1_bn[ik];
   @define pf @ATL_AMM_@
@ROUT ATL_GetRankKInfo
   out->amm_b0 = ATL_AMM_KERN_RKK[ik];
   out->amm_b1 = ATL_AMM_KERN_RKK_b1[ik];
   out->amm_bn = ATL_AMM_KERN_RKK_bn[ik];
   @define pf @ATL_RKK_@
@ROUT ATL_GetAmmmInfo ATL_GetRankKInfo
/*
 * Apply alpha to smallest matrix, and use alpha/beta to pick copy routines
 */
   if (SCALAR_IS_ONE(alpha))
   {
      appAl = 0;
      #ifdef TCPLX
         if (TA == AtlasNoTrans)
            out->a2blk = @(pf)AT2BLK_a1[ik];
         else if (TA == AtlasTrans)
            out->a2blk = @(pf)A2BLK_a1[ik];
         else if (TA == AtlasConjTrans)
            out->a2blk = @(pf)AC2BLK_a1[ik];
         else
            out->a2blk = @(pf)AH2BLK_a1[ik];
         if (TB == AtlasNoTrans)
             out->b2blk = @(pf)B2BLK_a1[ik];
         else if (TB == AtlasTrans)
             out->b2blk = @(pf)BT2BLK_a1[ik];
         else if (TB == AtlasConjTrans)
             out->b2blk = @(pf)BH2BLK_a1[ik];
         else
             out->b2blk = @(pf)BC2BLK_a1[ik];
      #else
         out->a2blk = (TA == AtlasNoTrans) ?
            @(pf)AT2BLK_a1[ik]:@(pf)A2BLK_a1[ik];
         out->b2blk = (TB == AtlasNoTrans) ?
            @(pf)B2BLK_a1[ik]:@(pf)BT2BLK_a1[ik];
      #endif
      if (SCALAR_IS_ONE(beta))
         out->Cblk2cm = @(pf)BLK2C_a1_b1[ik];
      else if (SCALAR_IS_ZERO(beta))
         out->Cblk2cm = @(pf)BLK2C_a1_b0[ik];
      else if (SCALAR_IS_NONE(beta))
         out->Cblk2cm = @(pf)BLK2C_a1_bn[ik];
      else
         out->Cblk2cm = @(pf)BLK2C_a1_bX[ik];
   }
   else  /* alpha is not one */
   {
@ROUT ATL_GetRankKInfo
      appAl = (M >= N) ? 1:0;
@ROUT ATL_GetAmmmInfo
      if (M >= N)                  /* A is larger than B, put alpha on C or B */
         appAl = (M >= K) ? 1 : 2;
      else                         /* B is larger than A, put alpha on C or A */
         appAl = (N >= K) ? 0 : 2;
      if (appAl == 2)  /* apply alpha to C */
      {
         #ifdef TCPLX
            if (TA == AtlasNoTrans)
               out->a2blk = @(pf)AT2BLK_a1[ik];
            else if (TA == AtlasTrans)
               out->a2blk = @(pf)A2BLK_a1[ik];
            else if (TA == AtlasConjTrans)
               out->a2blk = @(pf)AC2BLK_a1[ik];
            else
               out->a2blk = @(pf)AH2BLK_a1[ik];
            if (TB == AtlasNoTrans)
                out->b2blk = @(pf)B2BLK_a1[ik];
            else if (TB == AtlasTrans)
                out->b2blk = @(pf)BT2BLK_a1[ik];
            else if (TB == AtlasConjTrans)
                out->b2blk = @(pf)BH2BLK_a1[ik];
            else
                out->b2blk = @(pf)BC2BLK_a1[ik];
         #else
            out->a2blk = (TA == AtlasNoTrans) ?
                         @(pf)AT2BLK_a1[ik] : @(pf)A2BLK_a1[ik];
            out->b2blk = (TB == AtlasNoTrans) ?
                         @(pf)B2BLK_a1[ik] : @(pf)BT2BLK_a1[ik];
         #endif
         if (SCALAR_IS_ONE(beta))
            out->Cblk2cm = SCALAR_IS_NONE(alpha) ?
                           @(pf)BLK2C_an_b1[ik] : @(pf)BLK2C_aX_b1[ik];
         else if (SCALAR_IS_ZERO(beta))
            out->Cblk2cm = SCALAR_IS_NONE(alpha) ?
                           @(pf)BLK2C_an_b0[ik] : @(pf)BLK2C_aX_b0[ik];
         else if (SCALAR_IS_NONE(beta))
            out->Cblk2cm = SCALAR_IS_NONE(alpha) ?
                           @(pf)BLK2C_an_bn[ik] : @(pf)BLK2C_aX_bn[ik];
         else
            out->Cblk2cm = SCALAR_IS_NONE(alpha) ?
                           @(pf)BLK2C_an_bX[ik] : @(pf)BLK2C_aX_bX[ik];
      }
      else  /* not applying alpha to C */
      {
      @beginindent 1 3
@ROUT ATL_GetAmmmInfo ATL_GetRankKInfo
      if (SCALAR_IS_ONE(beta))
         out->Cblk2cm = @(pf)BLK2C_a1_b1[ik];
      else if (SCALAR_IS_ZERO(beta))
         out->Cblk2cm = @(pf)BLK2C_a1_b0[ik];
      else if (SCALAR_IS_NONE(beta))
         out->Cblk2cm = @(pf)BLK2C_a1_bn[ik];
      else
         out->Cblk2cm = @(pf)BLK2C_a1_bX[ik];
      if (!appAl)  /* apply to alpha to A */
      {
         #ifdef TCPLX
            if (TB == AtlasNoTrans)
                out->b2blk = @(pf)B2BLK_a1[ik];
            else if (TB == AtlasTrans)
                out->b2blk = @(pf)BT2BLK_a1[ik];
            else if (TB == AtlasConjTrans)
                out->b2blk = @(pf)BH2BLK_a1[ik];
            else
                out->b2blk = @(pf)BC2BLK_a1[ik];
            if (SCALAR_IS_NONE(alpha))
            {
               if (TA == AtlasNoTrans)
                  out->a2blk = @(pf)AT2BLK_an[ik];
               else if (TA == AtlasTrans)
                  out->a2blk = @(pf)A2BLK_an[ik];
               else if (TA == AtlasConjTrans)
                  out->a2blk = @(pf)AC2BLK_an[ik];
               else
                  out->a2blk = @(pf)AH2BLK_an[ik];
            }
            else
            {
               if (TA == AtlasNoTrans)
                  out->a2blk = @(pf)AT2BLK_aX[ik];
               else if (TA == AtlasTrans)
                  out->a2blk = @(pf)A2BLK_aX[ik];
               else if (TA == AtlasConjTrans)
                  out->a2blk = @(pf)AC2BLK_aX[ik];
               else
                  out->a2blk = @(pf)AH2BLK_aX[ik];
            }
         #else
            if (SCALAR_IS_NONE(alpha))
               out->a2blk = (TA == AtlasNoTrans) ?
                            @(pf)AT2BLK_an[ik] : @(pf)A2BLK_an[ik];
            else
               out->a2blk = (TA == AtlasNoTrans) ?
                            @(pf)AT2BLK_aX[ik] : @(pf)A2BLK_aX[ik];
            out->b2blk = (TB == AtlasNoTrans) ?
                         @(pf)B2BLK_a1[ik] : @(pf)BT2BLK_a1[ik];
         #endif
      }
      else /* apply alpha to B */
      {
         #ifdef TCPLX
            if (TA == AtlasNoTrans)
               out->a2blk = @(pf)AT2BLK_a1[ik];
            else if (TA == AtlasTrans)
               out->a2blk = @(pf)A2BLK_a1[ik];
            else if (TA == AtlasConjTrans)
               out->a2blk = @(pf)AC2BLK_a1[ik];
            else
               out->a2blk = @(pf)AH2BLK_a1[ik];
            if (SCALAR_IS_NONE(alpha))
            {
               if (TB == AtlasNoTrans)
                   out->b2blk = @(pf)B2BLK_an[ik];
               else if (TB == AtlasTrans)
                   out->b2blk = @(pf)BT2BLK_an[ik];
               else if (TB == AtlasConjTrans)
                   out->b2blk = @(pf)BH2BLK_an[ik];
               else
                   out->b2blk = @(pf)BC2BLK_an[ik];
            }
            else
            {
               if (TB == AtlasNoTrans)
                   out->b2blk = @(pf)B2BLK_aX[ik];
               else if (TB == AtlasTrans)
                   out->b2blk = @(pf)BT2BLK_aX[ik];
               else if (TB == AtlasConjTrans)
                   out->b2blk = @(pf)BH2BLK_aX[ik];
               else
                   out->b2blk = @(pf)BC2BLK_aX[ik];
            }
         #else
            out->a2blk = (TA == AtlasNoTrans) ?
                         @(pf)AT2BLK_a1[ik] : @(pf)A2BLK_a1[ik];
            if (SCALAR_IS_NONE(alpha))
               out->b2blk = (TB == AtlasNoTrans) ?
                            @(pf)B2BLK_an[ik] : @(pf)BT2BLK_an[ik];
            else
               out->b2blk = (TB == AtlasNoTrans) ?
                            @(pf)B2BLK_aX[ik] : @(pf)BT2BLK_aX[ik];
         #endif
      }
@ROUT ATL_GetAmmmInfo 
      @endindent
      }
@ROUT ATL_GetAmmmInfo  ATL_GetRankKInfo 
   }
   return(appAl);
}

@ROUT ATL_GetAmmmInfo 
#endif

/*
 * Following routines help pick NB for parallel routines
 */
#if defined(ATL_NCLUSTER) && defined(CLID)
   #include "atlas_cluster.h"
   #include Mstr(Mjoin(ATLAS_PRE, uamm_cluster.h))
   #ifndef UAMM_ID
      #error "UAMM_ID must be defined."
   #endif
   #define MM_PRE Mjoin(Mjoin(ATLAS_PRE, Mjoin(u,UAMM_ID)), amm)

   #include Mstr(Mjoin(MM_PRE,_blk.h))
   #include Mstr(Mjoin(MM_PRE,_ablk2cmat.h))
   #include Mstr(Mjoin(MM_PRE,_cm2am_a1.h))
   #include Mstr(Mjoin(MM_PRE,_cm2am_an.h))
   #include Mstr(Mjoin(MM_PRE,_cm2am_aX.h))
   #include Mstr(Mjoin(MM_PRE,_flag.h))
   #include Mstr(Mjoin(MM_PRE,_kern.h))

   #include Mstr(Mjoin(MM_PRE,_sum.h))
   #ifndef ATL_MAXIDX
      #define ATL_MAXIDX ATL_UAMM_NCASES-1
   #endif
   #define VAR_PRE ATL_UAMM
#else
   #include Mstr(Mjoin(AMM_PRE,_sum.h))
   #ifndef ATL_MAXIDX
      #define ATL_MAXIDX ATL_AMM_NCASES-1
   #endif
   #define VAR_PRE ATL_AMM
#endif


#if defined(ATL_NCLUSTER) && defined(CLID)
   int Mjoin(Mjoin(PATL,tGetAmmmInfoC), CLID)
#else
   int Mjoin(PATL,tGetAmmmInfo)
#endif
(
   amminfo_t *out,
   const unsigned int P,
   enum ATLAS_TRANS TA,
   enum ATLAS_TRANS TB,
   ATL_CSZT M,
   ATL_CSZT N,
   ATL_CSZT K,
   const SCALAR alpha,
   const SCALAR beta
)
{
   int ik=ATL_MAXIDX, mb, nb, nmblks, nnblks, ncblks;
   int appAl;  /* 0:A, 1:B, 2:C */
/*
 * For rank-K update, choose smallest KB that contains required K
 */
   if (K < Mjoin(VAR_PRE,_MAXKB))
   {
      for (ik=0; ik < Mjoin(VAR_PRE,_NCASES) && Mjoin(VAR_PRE,_KBs)[ik] < K; 
                     ik++);
   }
   ik++;
   do
   {
      ik--;
      mb = Mjoin(VAR_PRE,_MBs)[ik];
      nb = Mjoin(VAR_PRE,_NBs)[ik];
      nmblks = M / mb;
      nnblks = N / nb;
      ncblks = nmblks * nnblks;
   }
   while (ik >= Mjoin(VAR_PRE,_66IDX) && ncblks < P);
   out->IDX = ik;
   out->mb = mb;
   out->nb = nb;
   out->kb = Mjoin(VAR_PRE,_KBs)[ik];
   #ifdef ATL_CAMM_MAXINDX
      if (ik == ATL_CAMM_MAXINDX)
      {
         out->mb = ATL_CAMM_MAXMB;
         out->nb = ATL_CAMM_MAXNB;
         out->kb = ATL_CAMM_MAXKB;
      }
   #endif
   out->kbmin = Mjoin(VAR_PRE,_KBMINs)[ik];
   out->mu = Mjoin(VAR_PRE,_MUs)[ik];
   out->nu = Mjoin(VAR_PRE,_NUs)[ik];
   out->ku = Mjoin(VAR_PRE,_KUs)[ik];
   out->flag = Mjoin(VAR_PRE,_KFLAG)[ik];
   out->amm_b0 = Mjoin(VAR_PRE,_KERN_b0)[ik];
   out->amm_b1 = Mjoin(VAR_PRE,_KERN_b1)[ik];
   out->amm_bn = Mjoin(VAR_PRE,_KERN_bn)[ik];
   out->amm_k1_b0 = Mjoin(VAR_PRE,_KERN_K1)[ik];
   out->amm_k1_b1 = Mjoin(VAR_PRE,_KERN_K1_b1)[ik];
   out->amm_k1_bn = Mjoin(VAR_PRE,_KERN_K1_bn)[ik];
/*
 * Apply alpha to smallest matrix, and use alpha/beta to pick copy routines
 */
   if (SCALAR_IS_ONE(alpha))
   {
      appAl = 0;
      #ifdef TCPLX
         if (TA == AtlasNoTrans)
            out->a2blk = Mjoin(VAR_PRE,_AT2BLK_a1)[ik];
         else if (TA == AtlasTrans)
            out->a2blk = Mjoin(VAR_PRE,_A2BLK_a1)[ik];
         else if (TA == AtlasConjTrans)
            out->a2blk = Mjoin(VAR_PRE,_AC2BLK_a1)[ik];
         else
            out->a2blk = Mjoin(VAR_PRE,_AH2BLK_a1)[ik];
         if (TB == AtlasNoTrans)
             out->b2blk = Mjoin(VAR_PRE,_B2BLK_a1)[ik];
         else if (TB == AtlasTrans)
             out->b2blk = Mjoin(VAR_PRE,_BT2BLK_a1)[ik];
         else if (TB == AtlasConjTrans)
             out->b2blk = Mjoin(VAR_PRE,_BH2BLK_a1)[ik];
         else
             out->b2blk = Mjoin(VAR_PRE,_BC2BLK_a1)[ik];
      #else
         out->a2blk = (TA == AtlasNoTrans) ?
            Mjoin(VAR_PRE,_AT2BLK_a1)[ik]:Mjoin(VAR_PRE,_A2BLK_a1)[ik];
         out->b2blk = (TB == AtlasNoTrans) ?
            Mjoin(VAR_PRE,_B2BLK_a1)[ik]:Mjoin(VAR_PRE,_BT2BLK_a1)[ik];
      #endif
      out->Cblk2cm_b1 = Mjoin(VAR_PRE,_BLK2C_a1_b1)[ik];
      if (SCALAR_IS_ONE(beta))
         out->Cblk2cm = Mjoin(VAR_PRE,_BLK2C_a1_b1)[ik];
      else if (SCALAR_IS_ZERO(beta))
         out->Cblk2cm = Mjoin(VAR_PRE,_BLK2C_a1_b0)[ik];
      else if (SCALAR_IS_NONE(beta))
         out->Cblk2cm = Mjoin(VAR_PRE,_BLK2C_a1_bn)[ik];
      else
         out->Cblk2cm = Mjoin(VAR_PRE,_BLK2C_a1_bX)[ik];
   }
   else  /* alpha is not one */
   {
      if (M >= N)                  /* A is larger than B, put alpha on C or B */
         appAl = (M >= K) ? 1 : 2;
      else                         /* B is larger than A, put alpha on C or A */
         appAl = (N >= K) ? 0 : 2;
      if (appAl == 2)  /* apply alpha to C */
      {
         #ifdef TCPLX
            if (TA == AtlasNoTrans)
               out->a2blk = Mjoin(VAR_PRE,_AT2BLK_a1)[ik];
            else if (TA == AtlasTrans)
               out->a2blk = Mjoin(VAR_PRE,_A2BLK_a1)[ik];
            else if (TA == AtlasConjTrans)
               out->a2blk = Mjoin(VAR_PRE,_AC2BLK_a1)[ik];
            else
               out->a2blk = Mjoin(VAR_PRE,_AH2BLK_a1)[ik];
            if (TB == AtlasNoTrans)
                out->b2blk = Mjoin(VAR_PRE,_B2BLK_a1)[ik];
            else if (TB == AtlasTrans)
                out->b2blk = Mjoin(VAR_PRE,_BT2BLK_a1)[ik];
            else if (TB == AtlasConjTrans)
                out->b2blk = Mjoin(VAR_PRE,_BH2BLK_a1)[ik];
            else
                out->b2blk = Mjoin(VAR_PRE,_BC2BLK_a1)[ik];
         #else
            out->a2blk = (TA == AtlasNoTrans) ? Mjoin(VAR_PRE,_AT2BLK_a1)[ik] 
                         : Mjoin(VAR_PRE,_A2BLK_a1)[ik];
            out->b2blk = (TB == AtlasNoTrans) ?  Mjoin(VAR_PRE,_B2BLK_a1)[ik] 
                         : Mjoin(VAR_PRE,_BT2BLK_a1)[ik];
         #endif
         out->Cblk2cm_b1 = SCALAR_IS_NONE(alpha) ? 
                           Mjoin(VAR_PRE,_BLK2C_an_b1)[ik] 
                           : Mjoin(VAR_PRE,_BLK2C_aX_b1)[ik];
         if (SCALAR_IS_ONE(beta))
            out->Cblk2cm = SCALAR_IS_NONE(alpha) ?
                           Mjoin(VAR_PRE,_BLK2C_an_b1)[ik] 
                           : Mjoin(VAR_PRE,_BLK2C_aX_b1)[ik];
         else if (SCALAR_IS_ZERO(beta))
            out->Cblk2cm = SCALAR_IS_NONE(alpha) ?
                           Mjoin(VAR_PRE,_BLK2C_an_b0)[ik] 
                           : Mjoin(VAR_PRE,_BLK2C_aX_b0)[ik];
         else if (SCALAR_IS_NONE(beta))
            out->Cblk2cm = SCALAR_IS_NONE(alpha) ?
                           Mjoin(VAR_PRE,_BLK2C_an_bn)[ik] 
                           : Mjoin(VAR_PRE,_BLK2C_aX_bn)[ik];
         else
            out->Cblk2cm = SCALAR_IS_NONE(alpha) ?
                           Mjoin(VAR_PRE,_BLK2C_an_bX)[ik] 
                           : Mjoin(VAR_PRE,_BLK2C_aX_bX)[ik];
      }
      else  /* not applying alpha to C */
      {
         out->Cblk2cm_b1 = Mjoin(VAR_PRE,_BLK2C_a1_b1)[ik];
         if (SCALAR_IS_ONE(beta))
            out->Cblk2cm = Mjoin(VAR_PRE,_BLK2C_a1_b1)[ik];
         else if (SCALAR_IS_ZERO(beta))
            out->Cblk2cm = Mjoin(VAR_PRE,_BLK2C_a1_b0)[ik];
         else if (SCALAR_IS_NONE(beta))
            out->Cblk2cm = Mjoin(VAR_PRE,_BLK2C_a1_bn)[ik];
         else
            out->Cblk2cm = Mjoin(VAR_PRE,_BLK2C_a1_bX)[ik];
         if (!appAl)  /* apply to alpha to A */
         {
            #ifdef TCPLX
               if (TB == AtlasNoTrans)
                   out->b2blk = Mjoin(VAR_PRE,_B2BLK_a1)[ik];
               else if (TB == AtlasTrans)
                   out->b2blk = Mjoin(VAR_PRE,_BT2BLK_a1)[ik];
               else if (TB == AtlasConjTrans)
                   out->b2blk = Mjoin(VAR_PRE,_BH2BLK_a1)[ik];
               else
                   out->b2blk = Mjoin(VAR_PRE,_BC2BLK_a1)[ik];
               if (SCALAR_IS_NONE(alpha))
               {
                  if (TA == AtlasNoTrans)
                     out->a2blk = Mjoin(VAR_PRE,_AT2BLK_an)[ik];
                  else if (TA == AtlasTrans)
                     out->a2blk = Mjoin(VAR_PRE,_A2BLK_an)[ik];
                  else if (TA == AtlasConjTrans)
                     out->a2blk = Mjoin(VAR_PRE,_AC2BLK_an)[ik];
                  else
                     out->a2blk = Mjoin(VAR_PRE,_AH2BLK_an)[ik];
               }
               else
               {
                  if (TA == AtlasNoTrans)
                     out->a2blk = Mjoin(VAR_PRE,_AT2BLK_aX)[ik];
                  else if (TA == AtlasTrans)
                     out->a2blk = Mjoin(VAR_PRE,_A2BLK_aX)[ik];
                  else if (TA == AtlasConjTrans)
                     out->a2blk = Mjoin(VAR_PRE,_AC2BLK_aX)[ik];
                  else
                     out->a2blk = Mjoin(VAR_PRE,_AH2BLK_aX)[ik];
               }
            #else
               if (SCALAR_IS_NONE(alpha))
                  out->a2blk = (TA == AtlasNoTrans) ?
                               Mjoin(VAR_PRE,_AT2BLK_an)[ik] 
                               : Mjoin(VAR_PRE,_A2BLK_an)[ik];
               else
                  out->a2blk = (TA == AtlasNoTrans) ?
                               Mjoin(VAR_PRE,_AT2BLK_aX)[ik] 
                               : Mjoin(VAR_PRE,_A2BLK_aX)[ik];
               out->b2blk = (TB == AtlasNoTrans) ?
                            Mjoin(VAR_PRE,_B2BLK_a1)[ik] 
                            : Mjoin(VAR_PRE,_BT2BLK_a1)[ik];
            #endif
         }
         else /* apply alpha to B */
         {
            #ifdef TCPLX
               if (TA == AtlasNoTrans)
                  out->a2blk = Mjoin(VAR_PRE,_AT2BLK_a1)[ik];
               else if (TA == AtlasTrans)
                  out->a2blk = Mjoin(VAR_PRE,_A2BLK_a1)[ik];
               else if (TA == AtlasConjTrans)
                  out->a2blk = Mjoin(VAR_PRE,_AC2BLK_a1)[ik];
               else
                  out->a2blk = Mjoin(VAR_PRE,_AH2BLK_a1)[ik];
               if (SCALAR_IS_NONE(alpha))
               {
                  if (TB == AtlasNoTrans)
                      out->b2blk = Mjoin(VAR_PRE,_B2BLK_an)[ik];
                  else if (TB == AtlasTrans)
                      out->b2blk = Mjoin(VAR_PRE,_BT2BLK_an)[ik];
                  else if (TB == AtlasConjTrans)
                      out->b2blk = Mjoin(VAR_PRE,_BH2BLK_an)[ik];
                  else
                      out->b2blk = Mjoin(VAR_PRE,_BC2BLK_an)[ik];
               }
               else
               {
                  if (TB == AtlasNoTrans)
                      out->b2blk = Mjoin(VAR_PRE,_B2BLK_aX)[ik];
                  else if (TB == AtlasTrans)
                      out->b2blk = Mjoin(VAR_PRE,_BT2BLK_aX)[ik];
                  else if (TB == AtlasConjTrans)
                      out->b2blk = Mjoin(VAR_PRE,_BH2BLK_aX)[ik];
                  else
                      out->b2blk = Mjoin(VAR_PRE,_BC2BLK_aX)[ik];
               }
            #else
               out->a2blk = (TA == AtlasNoTrans) ?
                            Mjoin(VAR_PRE,_AT2BLK_a1)[ik] 
                            : Mjoin(VAR_PRE,_A2BLK_a1)[ik];
               if (SCALAR_IS_NONE(alpha))
                  out->b2blk = (TB == AtlasNoTrans) ?
                               Mjoin(VAR_PRE,_B2BLK_an)[ik] 
                               : Mjoin(VAR_PRE,_BT2BLK_an)[ik];
               else
                  out->b2blk = (TB == AtlasNoTrans) ?
                               Mjoin(VAR_PRE,_B2BLK_aX)[ik] 
                               : Mjoin(VAR_PRE,_BT2BLK_aX)[ik];
            #endif
         }
      }
   }
   return(appAl);
}

@ROUT ATL_GetRankKInfo

static INLINE void FillInRankKInf
   (rkinfo_t *out, int idx, enum ATLAS_TRANS TA, enum ATLAS_TRANS TB, 
    ATL_CSZT M, ATL_CSZT N, ATL_CSZT K, size_t lda, size_t ldb, size_t ldc,
    const SCALAR alpha, const SCALAR beta, int mb, int nb)
{
   int kb = ATL_AMM_KBs[idx];
   const int mu=ATL_AMM_MUs[idx], nu=ATL_AMM_NUs[idx], ku=ATL_AMM_KUs[idx];

   if (!mb)
      mb = ATL_AMM_MBs[idx];
   if (!nb)
      nb = ATL_AMM_NBs[idx];
   out->nfmb = M/mb;
   out->nfnb = N/nb;
   out->nfkb = K/kb;
   out->mu = mu;
   out->nu = nu;
   out->ku = ku;
   out->lda = lda;
   out->ldb = ldb;
   out->ldc = ldc;
   out->mb = mb;
   out->nb = nb;
   out->kb = kb;
   out->nmu = mb / mu;
   out->nnu = nb / nu;
   out->amm_b0 = ATL_AMM_KERN_RKK[idx];
   out->amm_b1 = ATL_AMM_KERN_RKK_b1[idx];
   out->flag = ATL_AMM_KFLAG[idx];
   out->mbL = M - out->nfmb*mb;
   out->nbL = N - out->nfnb*nb;
   out->kbL = K - out->nfkb*kb;
   out->nmuL = (out->mbL+mu-1)/mu;
   out->nnuL = (out->nbL+nu-1)/nu;
   out->MBL = out->nmuL*mu;
   out->NBL = out->nnuL*nu;
   out->KBL = ((out->kbL+ku-1)/ku)*ku;
   if (TA == AtlasNoTrans)
   {
      out->a2blk  = ATL_RKK_AT2BLK_a1[idx];
      out->incAm = mb;
      out->incAk = kb * (lda SHIFT);
   }
   #ifdef TCPLX
   else if (TA == AtlasConj)
   {
      out->a2blk  = ATL_RKK_AH2BLK_a1[idx];
      out->incAm = mb+mb;
      out->incAk = kb * (lda+lda);
   }
   else if (TA == AtlasConjTrans)
   {
      out->a2blk  = ATL_RKK_AC2BLK_a1[idx];
      out->incAm = mb*(lda+lda);
      out->incAk = kb+kb;
   }
   #endif
   else
   {
      out->a2blk  = ATL_RKK_A2BLK_a1[idx];
      out->incAm = mb*(lda SHIFT);
      out->incAk = kb SHIFT;
   }

   if (SCALAR_IS_ZERO(beta))
      out->blk2c  = ATL_RKK_BLK2C_a1_b0[idx];
   else if (SCALAR_IS_ONE(beta))
      out->blk2c  = ATL_RKK_BLK2C_a1_b1[idx];
   else
      out->blk2c  = SCALAR_IS_NONE(beta) ? 
                    ATL_RKK_BLK2C_a1_bn[idx]:ATL_RKK_BLK2C_a1_bX[idx];
   if (TB == AtlasNoTrans)
   {
      out->incBk = kb SHIFT;
      out->incBn = nb*(ldb SHIFT);
      if (SCALAR_IS_ONE(alpha))
         out->b2blk  = ATL_RKK_B2BLK_a1[idx];
      else
         out->b2blk  = SCALAR_IS_NONE(alpha) ? 
                       ATL_RKK_B2BLK_an[idx]:ATL_RKK_B2BLK_aX[idx];
   }
   #ifdef TCPLX
   else if (TB == AtlasConjTrans)
   {
      out->incBk = kb*(ldb+ldb);
      out->incBn = nb+nb;
      if (SCALAR_IS_ONE(alpha))
         out->b2blk  = ATL_RKK_BH2BLK_a1[idx];
      else if (SCALAR_IS_NONE(alpha))
         out->b2blk  = ATL_RKK_BH2BLK_an[idx];
      else /* alpha = X */
         out->b2blk  = ATL_RKK_BH2BLK_aX[idx];
   }
   else if (TB == AtlasConj)
   {
      out->incBk = kb+kb;
      out->incBn = nb*(ldb+ldb);
      if (SCALAR_IS_ONE(alpha))
         out->b2blk  = ATL_RKK_BC2BLK_a1[idx];
      else if (SCALAR_IS_NONE(alpha))
         out->b2blk  = ATL_RKK_BC2BLK_an[idx];
      else /* alpha = X */
         out->b2blk  = ATL_RKK_BC2BLK_aX[idx];
   }
   #endif
   else  /* TB == AtlasTrans */
   {
      out->incBk = kb*(ldb SHIFT);
      out->incBn = nb SHIFT;
      if (SCALAR_IS_ONE(alpha))
         out->b2blk  = ATL_RKK_BT2BLK_a1[idx];
      else if (SCALAR_IS_NONE(alpha))
         out->b2blk  = ATL_RKK_BT2BLK_an[idx];
      else /* alpha = X */
         out->b2blk  = ATL_RKK_BT2BLK_aX[idx];
   }
}

void Mjoin(PATL,GetBestKBInfo)
(
   rkinfo_t *out,            /* what to use for full-KB blocks */
   rkinfo_t *outR,           /* what to use for K-cleanup */
   enum ATLAS_TRANS TA,
   enum ATLAS_TRANS TB,
   ATL_CSZT M,
   ATL_CSZT N,
   ATL_CSZT K,
   size_t lda, 
   size_t ldb,
   size_t ldc,
   const SCALAR alpha,
   const SCALAR beta
)
{
   int idx;        /* amm index to use for full kb calls */
   int idr=(-1);   /* amm index for final colpan (-1: use ger1/2) */
   int KR;         /* K%kb */
   int i;

   #if 1
   if (K <= ATL_AMM_MAXKB)
   {
      idx = -1;
      idr = (K > 2) ? K-3 : -1;
      KR = K;
   }
   else
   #endif
   {
      int ibest=0;
      double timB=M*N*K*ATL_rkAMM_TIME[0];
      for (i=0; i < ATL_AMM_NCASES; i++)
      {
         ATL_CINT kb=ATL_AMM_KBs[i], nkb=K/kb, kr=K-nkb*kb;
         ATL_CINT mb=ATL_AMM_MBs[i], nb=ATL_AMM_MBs[i], nmb=M/mb, nnb=N/nb;
         ATL_CINT mu = ATL_AMM_MUs[i], mr = M-nmb*mb;
         ATL_CINT nu = ATL_AMM_NUs[i], nr = N-nnb*nb;
         double nfcblks, tkr, tpan, tim;

         nfcblks = nmb;
         nfcblks *= nnb;
         if (kr > 2)
         {
            idr = kr-3;
            tkr = ATL_rkAMM_TIME[idr];
            tkr /= ((double)ATL_AMM_KBs[idr])*ATL_AMM_MBs[idr]*ATL_AMM_KBs[idr];
            tkr *= ((double)mb)*nb*kb;
         }
         else if (!kr)
         {
            idr = -2;
            tkr = 0.0;
         }
/*
 *       Strongly penalize kr==1,2, since they require double write of C
 */
         else
         {
            if (kr == 1)
               tkr = ATL_rkAMM_TIME[0] * 8.0;
            else 
               tkr = ATL_rkAMM_TIME[0] * 6.0;
            tkr *= (0.015625*mb)*nb*kb;  /* b^3/4^3 */
         }
         tpan = nkb*ATL_rkAMM_TIME[i] + tkr;
         tim = nfcblks*tpan;
/*
 *       Rank-K perf not much affected by MB, so M cleanup only reduced
 *       by extra computation
 */
         if (mr)
            tim += nmb*tpan*mr / (double)mb;
#if 1
/*
 *       Small N drastically affects rank-K perf, so estimate it's speed
 *       as being equal to the mininum of rank-K or rank-nr
 *       We ignore kr for this, shouldn't be a big deal.
 */
         if (nr)
         {
            if (nr < K)
            {
               const int kk = (nr >= 3) ? nr-3 : 0;
               double tpe = ATL_rkAMM_TIME[kk];        /* time per element */
               tpe /= ((double)ATL_AMM_MBs[kk])*ATL_AMM_NBs[kk]*ATL_AMM_KBs[kk];
               tpe *= ((double)mb)*nr*kb;
               tim += tpe*nmb;
            }
            else
               tim += tpan;
         }
#endif
         if (tim < timB)
         {
            timB = tim;
            ibest = i;
            KR = kr;
         }
      }
#if 0
      ibest = 1;
      KR = K%4;
#elif 0
      ibest = 17;
      KR = K%20;
#endif
      idx = ibest;
      if (KR > 2)
         idr = KR-3;
      else
         idr = (KR == 0) ? -2 : -1;
   }
   out->idx = idx;
   if (idx != -1)
      FillInRankKInf(out, idx, TA, TB, M, N, K, lda, ldb, ldc,alpha,beta,0,0);
   outR->idx = idr;
   if (idr != -2)
   {
      const int mu=out->mu, nu=out->nu;
      int GOLOOK=(idr == -1);  /* should we look for kern wt same MU/NU? */

      if (!GOLOOK)
         GOLOOK = (mu != ATL_AMM_MUs[idr] || nu != ATL_AMM_NUs[idr]);
/*
 *    If present K-clean candidate doesn't have same C format, search
 *    for one that does
 */
      if (idx != -1 && GOLOOK)
      {
         int kbmin = ATL_AMM_KBMINs[idx];
/*
 *       See if present kernel can perform K-cleanup itself
 */
         if (ATL_AMM_KRUNTIME(idx) && ATL_AMM_KBMINs[idx] <= KR)
            idr = idx;
/*
 *       Look thru all avail kerns for one that matches MU/NU & can handle KR
 */
         else
         {
            int nidr=(-1);
            for (i=0; i < ATL_AMM_NCASES; i++)
            {
               if (ATL_AMM_KRUNTIME(i) && ATL_AMM_KBMINs[i] <= KR)
               {
                  nidr = i;
                  if (!ATL_AMM_KMAJOR(i)) /* K-vect kerns slow for small KR */
                     break;               /* so only quit if not K-vect */
               }
            }
/*
 *          May later want to search thru sq/ge KClean kerns for matching kerns.
 *          This will complicate things slighly, since the idx will be for
 *          the wrong header files.  For now, call present search OK
 */
            #if 0
            if (nidr == -1)
            {
               nidr = sqFindrkKClean(outR, mu, nu, KR);
               if (nidr == -1)
                  nidr = geFindrkKClean(outR, mu, nu, KR);
            }
            #endif
            if (nidr != -1)
               idr = nidr;
         }
      }
      if (idr >= 0)
      {
/*
 *       If we want to use this, will need to change amminstall to ensure
 *       this.  For now, simply assert it so we can assume compatible C
 */
         if (idx > 0)
         {
            FillInRankKInf(outR, idr, TA, TB, M, N, KR, lda, ldb, ldc, 
                           alpha, beta, out->mb, out->nb);
            ATL_assert(outR->mu == mu && outR->nu == nu);
         }
         else
            FillInRankKInf(outR, idr, TA, TB, M, N, KR, lda, ldb, ldc, 
                           alpha, beta, 0, 0);
      }
   }
   if (idx >= 0)
      printf("IDX=%d, B=(%d,%d,%d), U=(%d,%d,%d)\n",
             idx, out->mb, out->nb, out->kb, out->mu, out->nu, out->ku);
   else
      printf("IDX=%d\n", idx);
   if (idr >= 0)
      printf("IDR=%d, B=(%d,%d,%d), U=(%d,%d,%d)\n",
             idr, outR->mb, outR->nb, outR->kb, outR->mu, outR->nu, outR->ku);
   else
      printf("IDR=%d\n", idr);
}

@ROUT ATL_GetRankKInfo0000 
/*
 * This function provides an estimate on max number of threads to use to
 * perform a rank-K update.
 */
size_t GetRankKNthr(ATL_CSZT M, ATL_CSZT N, ATL_CSZT K)
{
   size_t nnblks=N/ATL_MAXN_RKK, nmblks=M/ATL_MAXM_RKK;
/*
 * For degenerate cases, require 32 blocks to pay for parallel overhead
 */
   if (N <= ATL_MAXN_RKK)
      return(nmblks>>5);
   if (M <= ATL_MAXM_RKK)
      return(nnblks>>5);
/*
 * In general case, rank-K is bus noisy, so ask that all threads have at least
 * 4 big blocks of C.  On some systems where memory scales poorly this will
 * vastly overestimate, and will underestimate on very good scaling, but
 * very good memory scaling should only occur for low number of cores, where
 * this won't hurt.
 */
   return((nnblks*nmblks)>>2);
}
@ROUT ATL_GetAmmmInfo00
/*
 * This function provides an estimate on max number of threads to use to
 * perform a access-major GEMM.
 */
size_t GetAmmmNthr(ATL_CSZT M, ATL_CSZT N, ATL_CSZT K)
{
   int GetRankNthr(ATL_CSZT M, ATL_CSZT N, ATL_CSZT K);
   size_t nnblks, nmblks, nkblks, p;

   nmblks = (M >= ATL_AMM_66MB) ? M/ATL_AMM_66MB : 1;
   nnblks = (N >= ATL_AMM_66NB) ? N/ATL_AMM_66NB : 1;
   nkblks = (K >= ATL_AMM_66KB) ? K/ATL_AMM_66KB : 1;
/*
 * Any shape with two degenerate dimensions causes a lot of bus traffic,
 * with very little computation to overcome threading overheads,
 * so demand at least 32 blocks before parallelizing
 */
   if ((nmblks==1 && nnblks==1) || (nmblks==1 && nkblks==1) || 
       (nnblks==1 && nkblks==1))
      return((nnblks*nmblks*nkblks)>>5)
/*
 * If it is a rank-K update, ask to have 4 big blocks of C
 */
   if (K <= ATL_MAXM_RKK)
   {
      nnblks=N/ATL_MAXN_RKK, nmblks=M/ATL_MAXM_RKK;
      return((nnblks*nmblks)>>2);
   }
   
/*
 * By default, give everyone 32 blocks to compute; for square problems,
 * the number of blocks is cubic, so this should not meaningfully restrict
 * parallelism.
 */
   return((nmblks*nnblks*nkblks)>>5);
}
@ROUT cnbtune
#include "atlas_misc.h"
#include Mstr(Mjoin(ATLAS_PRE,geamm_blk.h))
#include Mstr(Mjoin(ATLAS_PRE,geamm_ablk2cmat.h))
#include Mstr(Mjoin(ATLAS_PRE,geamm_cm2am_a1.h))
#include Mstr(Mjoin(ATLAS_PRE,geamm_cm2am_an.h))
#include Mstr(Mjoin(ATLAS_PRE,geamm_cm2am_aX.h))
#include Mstr(Mjoin(ATLAS_PRE,geamm_flag.h))
#include Mstr(Mjoin(ATLAS_PRE,geamm_kern.h))

static int IK=ATL_AMM_NCASES-1, MB=0, NB=0, KB=0;
#ifdef DCPLX
   static char MY_PRE='z', MY_PRE2='Z';
#elif defined(SCPLX)
   static char MY_PRE='c', MY_PRE2='C';
#elif defined(SREAL)
   static char MY_PRE='s', MY_PRE2='S';
#else
   static char MY_PRE='d', MY_PRE2='D';
#endif
/*
 * This routine overrides normal GetAmmmInfo, so we can tune kernel params
 */
int Mjoin(PATL,GetAmmmInfo)
(
   amminfo_t *out,
   enum ATLAS_TRANS TA,
   enum ATLAS_TRANS TB,
   ATL_CSZT M,
   ATL_CSZT N,
   ATL_CSZT K,
   const SCALAR alpha,
   const SCALAR beta
)
{
   int ik=IK, appAl;  /* 0:A, 1:B, 2:C */

   ATL_assert(ik >= 0 && ik < ATL_AMM_NCASES);
   while (K < ATL_AMM_KBs[ik] && ik)
      ik--;
   out->IDX = ik;
   out->mb = (MB) ? MB : ATL_AMM_MBs[ik];
   out->nb = (NB) ? NB : ATL_AMM_NBs[ik];
   out->kb = (KB) ? KB : ATL_AMM_KBs[ik];
   out->kbmin = ATL_AMM_KBMINs[ik];
   out->mu = ATL_AMM_MUs[ik];
   out->nu = ATL_AMM_NUs[ik];
   out->ku = ATL_AMM_KUs[ik];
   out->flag = ATL_AMM_KFLAG[ik];
   out->amm_b0 = ATL_AMM_KERN_b0[ik];
   out->amm_b1 = ATL_AMM_KERN_b1[ik];
   out->amm_bn = ATL_AMM_KERN_bn[ik];
   out->amm_k1_b0 = ATL_AMM_KERN_K1[ik];
   out->amm_k1_b1 = ATL_AMM_KERN_K1_b1[ik];
   out->amm_k1_bn = ATL_AMM_KERN_K1_bn[ik];
/*
 * Apply alpha to smallest matrix, and use alpha/beta to pick copy routines
 */
   if (SCALAR_IS_ONE(alpha))
   {
      appAl = 0;
      #ifdef TCPLX
         if (TA == AtlasNoTrans)
            out->a2blk = ATL_AMM_AT2BLK_a1[ik];
         else if (TA == AtlasTrans)
            out->a2blk = ATL_AMM_A2BLK_a1[ik];
         else if (TA == AtlasConjTrans)
            out->a2blk = ATL_AMM_AC2BLK_a1[ik];
         else
            out->a2blk = ATL_AMM_AH2BLK_a1[ik];
         if (TB == AtlasNoTrans)
             out->b2blk = ATL_AMM_B2BLK_a1[ik];
         else if (TB == AtlasTrans)
             out->b2blk = ATL_AMM_BT2BLK_a1[ik];
         else if (TB == AtlasConjTrans)
             out->b2blk = ATL_AMM_BH2BLK_a1[ik];
         else
             out->b2blk = ATL_AMM_BC2BLK_a1[ik];
      #else
         out->a2blk = (TA == AtlasNoTrans) ?
            ATL_AMM_AT2BLK_a1[ik]:ATL_AMM_A2BLK_a1[ik];
         out->b2blk = (TB == AtlasNoTrans) ?
            ATL_AMM_B2BLK_a1[ik]:ATL_AMM_BT2BLK_a1[ik];
      #endif
      if (SCALAR_IS_ONE(beta))
         out->Cblk2cm = ATL_AMM_BLK2C_a1_b1[ik];
      else if (SCALAR_IS_ZERO(beta))
         out->Cblk2cm = ATL_AMM_BLK2C_a1_b0[ik];
      else if (SCALAR_IS_NONE(beta))
         out->Cblk2cm = ATL_AMM_BLK2C_a1_bn[ik];
      else
         out->Cblk2cm = ATL_AMM_BLK2C_a1_bX[ik];
   }
   else  /* alpha is not one */
   {
      if (M >= N)                  /* A is larger than B, put alpha on C or B */
         appAl = (M >= K) ? 1 : 2;
      else                         /* B is larger than A, put alpha on C or A */
         appAl = (N >= K) ? 0 : 2;
      if (appAl == 2)  /* apply alpha to C */
      {
         #ifdef TCPLX
            if (TA == AtlasNoTrans)
               out->a2blk = ATL_AMM_AT2BLK_a1[ik];
            else if (TA == AtlasTrans)
               out->a2blk = ATL_AMM_A2BLK_a1[ik];
            else if (TA == AtlasConjTrans)
               out->a2blk = ATL_AMM_AC2BLK_a1[ik];
            else
               out->a2blk = ATL_AMM_AH2BLK_a1[ik];
            if (TB == AtlasNoTrans)
                out->b2blk = ATL_AMM_B2BLK_a1[ik];
            else if (TB == AtlasTrans)
                out->b2blk = ATL_AMM_BT2BLK_a1[ik];
            else if (TB == AtlasConjTrans)
                out->b2blk = ATL_AMM_BH2BLK_a1[ik];
            else
                out->b2blk = ATL_AMM_BC2BLK_a1[ik];
         #else
            out->a2blk = (TA == AtlasNoTrans) ?
                         ATL_AMM_AT2BLK_a1[ik] : ATL_AMM_A2BLK_a1[ik];
            out->b2blk = (TB == AtlasNoTrans) ?
                         ATL_AMM_B2BLK_a1[ik] : ATL_AMM_BT2BLK_a1[ik];
         #endif
         if (SCALAR_IS_ONE(beta))
            out->Cblk2cm = SCALAR_IS_NONE(alpha) ?
                           ATL_AMM_BLK2C_an_b1[ik] : ATL_AMM_BLK2C_aX_b1[ik];
         else if (SCALAR_IS_ZERO(beta))
            out->Cblk2cm = SCALAR_IS_NONE(alpha) ?
                           ATL_AMM_BLK2C_an_b0[ik] : ATL_AMM_BLK2C_aX_b0[ik];
         else if (SCALAR_IS_NONE(beta))
            out->Cblk2cm = SCALAR_IS_NONE(alpha) ?
                           ATL_AMM_BLK2C_an_bn[ik] : ATL_AMM_BLK2C_aX_bn[ik];
         else
            out->Cblk2cm = SCALAR_IS_NONE(alpha) ?
                           ATL_AMM_BLK2C_an_bX[ik] : ATL_AMM_BLK2C_aX_bX[ik];
      }
      else  /* not applying alpha to C */
      {
         if (SCALAR_IS_ONE(beta))
            out->Cblk2cm = ATL_AMM_BLK2C_a1_b1[ik];
         else if (SCALAR_IS_ZERO(beta))
            out->Cblk2cm = ATL_AMM_BLK2C_a1_b0[ik];
         else if (SCALAR_IS_NONE(beta))
            out->Cblk2cm = ATL_AMM_BLK2C_a1_bn[ik];
         else
            out->Cblk2cm = ATL_AMM_BLK2C_a1_bX[ik];
         if (!appAl)  /* apply to alpha to A */
         {
            #ifdef TCPLX
               if (TB == AtlasNoTrans)
                   out->b2blk = ATL_AMM_B2BLK_a1[ik];
               else if (TB == AtlasTrans)
                   out->b2blk = ATL_AMM_BT2BLK_a1[ik];
               else if (TB == AtlasConjTrans)
                   out->b2blk = ATL_AMM_BH2BLK_a1[ik];
               else
                   out->b2blk = ATL_AMM_BC2BLK_a1[ik];
               if (SCALAR_IS_NONE(alpha))
               {
                  if (TA == AtlasNoTrans)
                     out->a2blk = ATL_AMM_AT2BLK_an[ik];
                  else if (TA == AtlasTrans)
                     out->a2blk = ATL_AMM_A2BLK_an[ik];
                  else if (TA == AtlasConjTrans)
                     out->a2blk = ATL_AMM_AC2BLK_an[ik];
                  else
                     out->a2blk = ATL_AMM_AH2BLK_an[ik];
               }
               else
               {
                  if (TA == AtlasNoTrans)
                     out->a2blk = ATL_AMM_AT2BLK_aX[ik];
                  else if (TA == AtlasTrans)
                     out->a2blk = ATL_AMM_A2BLK_aX[ik];
                  else if (TA == AtlasConjTrans)
                     out->a2blk = ATL_AMM_AC2BLK_aX[ik];
                  else
                     out->a2blk = ATL_AMM_AH2BLK_aX[ik];
               }
            #else
               if (SCALAR_IS_NONE(alpha))
                  out->a2blk = (TA == AtlasNoTrans) ?
                               ATL_AMM_AT2BLK_an[ik] : ATL_AMM_A2BLK_an[ik];
               else
                  out->a2blk = (TA == AtlasNoTrans) ?
                               ATL_AMM_AT2BLK_aX[ik] : ATL_AMM_A2BLK_aX[ik];
               out->b2blk = (TB == AtlasNoTrans) ?
                            ATL_AMM_B2BLK_a1[ik] : ATL_AMM_BT2BLK_a1[ik];
            #endif
         }
         else /* apply alpha to B */
         {
            #ifdef TCPLX
               if (TA == AtlasNoTrans)
                  out->a2blk = ATL_AMM_AT2BLK_a1[ik];
               else if (TA == AtlasTrans)
                  out->a2blk = ATL_AMM_A2BLK_a1[ik];
               else if (TA == AtlasConjTrans)
                  out->a2blk = ATL_AMM_AC2BLK_a1[ik];
               else
                  out->a2blk = ATL_AMM_AH2BLK_a1[ik];
               if (SCALAR_IS_NONE(alpha))
               {
                  if (TB == AtlasNoTrans)
                      out->b2blk = ATL_AMM_B2BLK_an[ik];
                  else if (TB == AtlasTrans)
                      out->b2blk = ATL_AMM_BT2BLK_an[ik];
                  else if (TB == AtlasConjTrans)
                      out->b2blk = ATL_AMM_BH2BLK_an[ik];
                  else
                      out->b2blk = ATL_AMM_BC2BLK_an[ik];
               }
               else
               {
                  if (TB == AtlasNoTrans)
                      out->b2blk = ATL_AMM_B2BLK_aX[ik];
                  else if (TB == AtlasTrans)
                      out->b2blk = ATL_AMM_BT2BLK_aX[ik];
                  else if (TB == AtlasConjTrans)
                      out->b2blk = ATL_AMM_BH2BLK_aX[ik];
                  else
                      out->b2blk = ATL_AMM_BC2BLK_aX[ik];
               }
            #else
               out->a2blk = (TA == AtlasNoTrans) ?
                            ATL_AMM_AT2BLK_a1[ik] : ATL_AMM_A2BLK_a1[ik];
               if (SCALAR_IS_NONE(alpha))
                  out->b2blk = (TB == AtlasNoTrans) ?
                               ATL_AMM_B2BLK_an[ik] : ATL_AMM_BT2BLK_an[ik];
               else
                  out->b2blk = (TB == AtlasNoTrans) ?
                               ATL_AMM_B2BLK_aX[ik] : ATL_AMM_BT2BLK_aX[ik];
            #endif
         }
      }
   }
   return(appAl);
}

double time00();
double Time2Mflops(int M, int N, int K, double t0)
{
   return((((2.0*M)*N)*K) / (1000000.0*t0));
}

int FindLowerBlock(int *M, int *N, int *K)
{
   int iret=1;
   if (ATL_AMM_KRUNTIME(ATL_AMM_KFLAG[IK]) && *K > *M && *K > *N &&
       *K-ATL_AMM_KUs[IK] >=  ATL_AMM_KBMINs[IK])
      *K -= ATL_AMM_KUs[IK];
   else if (*M >= *N && *M > ATL_AMM_MUs[IK])
      *M -= ATL_AMM_MUs[IK];
   else if (*N > ATL_AMM_NUs[IK])
      *N -= ATL_AMM_NUs[IK];
   else 
      iret = 0;
   return(iret);
}

double GetMflops(ATL_CINT M, ATL_CINT N, ATL_CINT K, TYPE *A, TYPE *B, TYPE *C)
{
   double t0;
   const TYPE ONE[2] = {ATL_rone, ATL_rzero};

   t0 = time00();
   Mjoin(PATL,ammm)(AtlasNoTrans, AtlasNoTrans, M, N, K, ONE, A, M, B, K,
                    ONE, C, M);
   t0 = time00() - t0;
   return(Time2Mflops(M, N, K, t0));
}

double TuneBlocking(int M, int N, int K, TYPE *A, TYPE *B, TYPE *C, 
                    int *MB_, int *NB_, int *KB_)
{
   int mbB=ATL_AMM_MBs[IK], nbB=ATL_AMM_NBs[IK], kbB=ATL_AMM_KBs[IK];
   int mb=mbB, nb=nbB, kb=kbB, m, n, k;
   double t0, t1, mf0, mf, mfB;

   printf("\nTRYING REDUCED BLOCKING WITH INDEX=%d\n", IK);
   printf("        M       N       K  IDX   MB   NB   KB         MFLOPS\n");
   printf("   ======  ======  ======  ===  ===  ===  ===  =============\n");
   m = (M/mbB)*mbB;
   n = (N/nbB)*nbB;
   k = (K/kbB)*kbB;
   mf0 = mf = mfB = GetMflops(m, n, k, A, B, C);
   printf("  %7d %7d %7d %4d %4d %4d %4d %14.2f\n", 
          m, n, k, IK, mb, nb, kb, 4.0*mf);
   while(FindLowerBlock(&mb, &nb, &kb))
   {
      MB = mb;
      NB = nb;
      KB = kb;
      m = (M/mb)*mb;
      n = (N/nb)*nb;
      k = (K/kb)*kb;
      mf = GetMflops(m, n, k, A, B, C);
      printf("  %7d %7d %7d %4d %4d %4d %4d %14.2f\n", 
             m, n, k, IK, mb, nb, kb, 4.0*mf);
      if (mf > mfB)
      {
         mbB = mb;
         nbB = nb;
         kbB = kb;
         mfB = mf;
      }
      else if (mf*1.02 <= mfB)
         break;
   }
   printf("BEST BLOCKING: MB=%d, NB=%d, KB=%d speedup=%.3f\n", 
          mbB, nbB, kbB, (mfB/mf0));
   *MB_ = mbB;
   *NB_ = nbB;
   *KB_ = kbB;
   return(mfB);
}

int TuneIndx(int M, int N, int K, TYPE *A, TYPE *B, TYPE *C)
{
   double mfB=0.0, mf;
   int ik, iB=ATL_AMM_NCASES-1;

   printf("\n\nFINDING BEST INDEX:\n");
   printf("        M       N       K  IDX   MB   NB   KB         MFLOPS\n");
   printf("   ======  ======  ======  ===  ===  ===  ===  =============\n");
   for (ik=iB; ik >= 0; ik--)
   {
      const int mb=ATL_AMM_MBs[ik],nb=ATL_AMM_NBs[ik],kb=ATL_AMM_KBs[ik];
      const int m=(M/mb)*mb, n=(N/nb)*nb, k=(K/kb)*kb;
      IK = ik;
      mf = GetMflops(m, n, k, A, B, C);
      printf("  %7d %7d %7d %4d %4d %4d %4d %14.2f\n", 
             m, n, k, ik, mb, nb, kb, 4.0*mf);
      if (mf > mfB)
      {
         iB = ik;
         mfB = mf;
      }
      else if (ATL_AMM_KBs[ik] < 16)
         break;
   }
   printf("\nBEST INDEX=%d (%.2f)\n", iB, mfB);
   return(iB);
}

void TuneCplxNB(FILE *fpout, int M, int N, int K, TYPE *A, TYPE *B, TYPE *C)
{
   int ik, mb, nb, kb;
   double mfB;
   ik = TuneIndx(M, N, K, A, B, C);
   IK = ik;
   mfB = TuneBlocking(M, N, K, A, B, C, &mb, &nb, &kb);
   fprintf(fpout, "#ifndef ATL_%cAMM_SUM_H\n   #define ATLAS_%cAMM_SUM_H\n\n",
           MY_PRE2, MY_PRE2);
   fprintf(fpout, "   #define ATL_CAMM_MAXINDX %d\n", IK);
   fprintf(fpout, "   #define ATL_CAMM_MAXMB %d\n", mb);
   fprintf(fpout, "   #define ATL_CAMM_MAXNB %d\n", nb);
   fprintf(fpout, "   #define ATL_CAMM_MAXKB %d\n", kb);
   fprintf(fpout, "   #define ATL_CAMM_APERF %e\n", 4.0*mfB);
   fprintf(fpout, "\n#endif\n");
   fclose(fpout);
}

FILE *GetFlags(int nargs, char **args, int *M, int *N, int *K)
{
   FILE *fp=NULL;
   *K = 1200;
   *M = *N = 2000;
   if (!fp)
   {
      char nam[32];
      sprintf(nam, "res/atlas_%samm_sum.h", Mstr(PRE));
      fp = fopen(nam, "w");
      ATL_assert(fp);
   }
   return(fp);
}


int main(int nargs, char **args)
{
   void *vp;
   TYPE *A, *B, *C;
   int M, N, K;
   size_t szA, szB, szC;
   FILE *fpout;

   fpout = GetFlags(nargs, args, &M, &N, &K);
   M = ((M+ATL_AMM_MAXMB-1)/ATL_AMM_MAXMB)*ATL_AMM_MAXMB;
   N = ((N+ATL_AMM_MAXNB-1)/ATL_AMM_MAXNB)*ATL_AMM_MAXNB;
   K = ((K+ATL_AMM_MAXKB-1)/ATL_AMM_MAXKB)*ATL_AMM_MAXKB;
   szA = M*K;
   szB = K*N;
   szC = M*N;
   vp = malloc(ATL_MulBySize(szA + szB + szC) + 3*ATL_Cachelen);
   ATL_assert(vp);
   A = ATL_AlignPtr(vp);
   B = A + szA+szA;
   B = ATL_AlignPtr(B);
   C = B + szB+szB;
   C = ATL_AlignPtr(C);
   Mjoin(PATL,zero)(szA, A, 1);
   Mjoin(PATL,zero)(szB, B, 1);
   Mjoin(PATL,zero)(szC, C, 1);
   TuneCplxNB(fpout, M, N, K, A, B, C);
   free(vp);
   return(0);
}
@ROUT ATL_GetSqMNAmmmInfo
#include "atlas_misc.h"
#include Mstr(Mjoin(ATLAS_PRE,geamm_blk.h))
#include Mstr(Mjoin(ATLAS_PRE,geamm_ablk2cmat.h))
#include Mstr(Mjoin(ATLAS_PRE,geamm_cm2am_a1.h))
#include Mstr(Mjoin(ATLAS_PRE,geamm_cm2am_an.h))
#include Mstr(Mjoin(ATLAS_PRE,geamm_cm2am_aX.h))
#include Mstr(Mjoin(ATLAS_PRE,geamm_flag.h))
#include Mstr(Mjoin(ATLAS_PRE,geamm_kern.h))

/*
 * Chooses good square M & N blocking; starts from size that gets 98% of
 * performance, since smaller produces less wasted flops for triangular and
 * symmetric operations, which are what usually demand square M/N blocking
 */
int Mjoin(PATL,GetSqMNAmmmInfo)
(
   amminfo_t *out,
   enum ATLAS_TRANS TA,
   enum ATLAS_TRANS TB,
   ATL_CSZT M,
   ATL_CSZT N,
   ATL_CSZT K,
   const SCALAR alpha,
   const SCALAR beta
)
{
   #ifdef ATL_CAMM_MAXINDX
      int mb, nb, u, ik=ATL_CAMM_MAXINDX;
   #else
      int ik=ATL_AMM_98IDX;
   #endif
   int appAl;  /* 0:A, 1:B, 2:C */
/*
 * For rank-K update, choose smallest KB that contains required K
 */
   if (K < ATL_AMM_MAXKB)
   {
      for (ik=0; ik < ATL_AMM_NCASES && ATL_AMM_KBs[ik] < K; ik++);
   }
   out->IDX = ik;
   u = ATL_98LCMMN;
   mb = ATL_AMM_MBs[ik];
   nb = ATL_AMM_NBs[ik];
   out->kb = ATL_AMM_KBs[ik];
   #ifdef ATL_CAMM_MAXINDX
      if (ik >= ATL_CAMM_MAXINDX)
      {
         ik = ATL_CAMM_MAXINDX
         u = ATL_CAMM_LCMMN;
         mb = ATL_CAMM_MAXMB;
         nb = ATL_CAMM_MAXMB;
         out->kb = ATL_CAMM_MAXKB;
      } 
   #endif
   if(mb != nb)
      nb = (mb > u) ? (mb/u)*u : u;
   out->mb = mb = out->nb = nb;
   out->kbmin = ATL_AMM_KBMINs[ik];
   out->mu = ATL_AMM_MUs[ik];
   out->nu = ATL_AMM_NUs[ik];
   out->ku = ATL_AMM_KUs[ik];
   out->flag = ATL_AMM_KFLAG[ik];
   out->amm_b0 = ATL_AMM_KERN_b0[ik];
   out->amm_b1 = ATL_AMM_KERN_b1[ik];
   out->amm_bn = ATL_AMM_KERN_bn[ik];
   out->amm_k1_b0 = ATL_AMM_KERN_K1[ik];
   out->amm_k1_b1 = ATL_AMM_KERN_K1_b1[ik];
   out->amm_k1_bn = ATL_AMM_KERN_K1_bn[ik];
/*
 * Apply alpha to smallest matrix, and use alpha/beta to pick copy routines
 */
   if (SCALAR_IS_ONE(alpha))
   {
      appAl = 0;
      #ifdef TCPLX
         if (TA == AtlasNoTrans)
            out->a2blk = ATL_AMM_AT2BLK_a1[ik];
         else if (TA == AtlasTrans)
            out->a2blk = ATL_AMM_A2BLK_a1[ik];
         else if (TA == AtlasConjTrans)
            out->a2blk = ATL_AMM_AC2BLK_a1[ik];
         else
            out->a2blk = ATL_AMM_AH2BLK_a1[ik];
         if (TB == AtlasNoTrans)
             out->b2blk = ATL_AMM_B2BLK_a1[ik];
         else if (TB == AtlasTrans)
             out->b2blk = ATL_AMM_BT2BLK_a1[ik];
         else if (TB == AtlasConjTrans)
             out->b2blk = ATL_AMM_BH2BLK_a1[ik];
         else
             out->b2blk = ATL_AMM_BC2BLK_a1[ik];
      #else
         out->a2blk = (TA == AtlasNoTrans) ?
            ATL_AMM_AT2BLK_a1[ik]:ATL_AMM_A2BLK_a1[ik];
         out->b2blk = (TB == AtlasNoTrans) ?
            ATL_AMM_B2BLK_a1[ik]:ATL_AMM_BT2BLK_a1[ik];
      #endif
      if (SCALAR_IS_ONE(beta))
         out->Cblk2cm = ATL_AMM_BLK2C_a1_b1[ik];
      else if (SCALAR_IS_ZERO(beta))
         out->Cblk2cm = ATL_AMM_BLK2C_a1_b0[ik];
      else if (SCALAR_IS_NONE(beta))
         out->Cblk2cm = ATL_AMM_BLK2C_a1_bn[ik];
      else
         out->Cblk2cm = ATL_AMM_BLK2C_a1_bX[ik];
   }
   else  /* alpha is not one */
   {
      if (M >= N)                  /* A is larger than B, put alpha on C or B */
         appAl = (M >= K) ? 1 : 2;
      else                         /* B is larger than A, put alpha on C or A */
         appAl = (N >= K) ? 0 : 2;
      if (appAl == 2)  /* apply alpha to C */
      {
         #ifdef TCPLX
            if (TA == AtlasNoTrans)
               out->a2blk = ATL_AMM_AT2BLK_a1[ik];
            else if (TA == AtlasTrans)
               out->a2blk = ATL_AMM_A2BLK_a1[ik];
            else if (TA == AtlasConjTrans)
               out->a2blk = ATL_AMM_AC2BLK_a1[ik];
            else
               out->a2blk = ATL_AMM_AH2BLK_a1[ik];
            if (TB == AtlasNoTrans)
                out->b2blk = ATL_AMM_B2BLK_a1[ik];
            else if (TB == AtlasTrans)
                out->b2blk = ATL_AMM_BT2BLK_a1[ik];
            else if (TB == AtlasConjTrans)
                out->b2blk = ATL_AMM_BH2BLK_a1[ik];
            else
                out->b2blk = ATL_AMM_BC2BLK_a1[ik];
         #else
            out->a2blk = (TA == AtlasNoTrans) ?
                         ATL_AMM_AT2BLK_a1[ik] : ATL_AMM_A2BLK_a1[ik];
            out->b2blk = (TB == AtlasNoTrans) ?
                         ATL_AMM_B2BLK_a1[ik] : ATL_AMM_BT2BLK_a1[ik];
         #endif
         if (SCALAR_IS_ONE(beta))
            out->Cblk2cm = SCALAR_IS_NONE(alpha) ?
                           ATL_AMM_BLK2C_an_b1[ik] : ATL_AMM_BLK2C_aX_b1[ik];
         else if (SCALAR_IS_ZERO(beta))
            out->Cblk2cm = SCALAR_IS_NONE(alpha) ?
                           ATL_AMM_BLK2C_an_b0[ik] : ATL_AMM_BLK2C_aX_b0[ik];
         else if (SCALAR_IS_NONE(beta))
            out->Cblk2cm = SCALAR_IS_NONE(alpha) ?
                           ATL_AMM_BLK2C_an_bn[ik] : ATL_AMM_BLK2C_aX_bn[ik];
         else
            out->Cblk2cm = SCALAR_IS_NONE(alpha) ?
                           ATL_AMM_BLK2C_an_bX[ik] : ATL_AMM_BLK2C_aX_bX[ik];
      }
      else  /* not applying alpha to C */
      {
         if (SCALAR_IS_ONE(beta))
            out->Cblk2cm = ATL_AMM_BLK2C_a1_b1[ik];
         else if (SCALAR_IS_ZERO(beta))
            out->Cblk2cm = ATL_AMM_BLK2C_a1_b0[ik];
         else if (SCALAR_IS_NONE(beta))
            out->Cblk2cm = ATL_AMM_BLK2C_a1_bn[ik];
         else
            out->Cblk2cm = ATL_AMM_BLK2C_a1_bX[ik];
         if (!appAl)  /* apply to alpha to A */
         {
            #ifdef TCPLX
               if (TB == AtlasNoTrans)
                   out->b2blk = ATL_AMM_B2BLK_a1[ik];
               else if (TB == AtlasTrans)
                   out->b2blk = ATL_AMM_BT2BLK_a1[ik];
               else if (TB == AtlasConjTrans)
                   out->b2blk = ATL_AMM_BH2BLK_a1[ik];
               else
                   out->b2blk = ATL_AMM_BC2BLK_a1[ik];
               if (SCALAR_IS_NONE(alpha))
               {
                  if (TA == AtlasNoTrans)
                     out->a2blk = ATL_AMM_AT2BLK_an[ik];
                  else if (TA == AtlasTrans)
                     out->a2blk = ATL_AMM_A2BLK_an[ik];
                  else if (TA == AtlasConjTrans)
                     out->a2blk = ATL_AMM_AC2BLK_an[ik];
                  else
                     out->a2blk = ATL_AMM_AH2BLK_an[ik];
               }
               else
               {
                  if (TA == AtlasNoTrans)
                     out->a2blk = ATL_AMM_AT2BLK_aX[ik];
                  else if (TA == AtlasTrans)
                     out->a2blk = ATL_AMM_A2BLK_aX[ik];
                  else if (TA == AtlasConjTrans)
                     out->a2blk = ATL_AMM_AC2BLK_aX[ik];
                  else
                     out->a2blk = ATL_AMM_AH2BLK_aX[ik];
               }
            #else
               if (SCALAR_IS_NONE(alpha))
                  out->a2blk = (TA == AtlasNoTrans) ?
                               ATL_AMM_AT2BLK_an[ik] : ATL_AMM_A2BLK_an[ik];
               else
                  out->a2blk = (TA == AtlasNoTrans) ?
                               ATL_AMM_AT2BLK_aX[ik] : ATL_AMM_A2BLK_aX[ik];
               out->b2blk = (TB == AtlasNoTrans) ?
                            ATL_AMM_B2BLK_a1[ik] : ATL_AMM_BT2BLK_a1[ik];
            #endif
         }
         else /* apply alpha to B */
         {
            #ifdef TCPLX
               if (TA == AtlasNoTrans)
                  out->a2blk = ATL_AMM_AT2BLK_a1[ik];
               else if (TA == AtlasTrans)
                  out->a2blk = ATL_AMM_A2BLK_a1[ik];
               else if (TA == AtlasConjTrans)
                  out->a2blk = ATL_AMM_AC2BLK_a1[ik];
               else
                  out->a2blk = ATL_AMM_AH2BLK_a1[ik];
               if (SCALAR_IS_NONE(alpha))
               {
                  if (TB == AtlasNoTrans)
                      out->b2blk = ATL_AMM_B2BLK_an[ik];
                  else if (TB == AtlasTrans)
                      out->b2blk = ATL_AMM_BT2BLK_an[ik];
                  else if (TB == AtlasConjTrans)
                      out->b2blk = ATL_AMM_BH2BLK_an[ik];
                  else
                      out->b2blk = ATL_AMM_BC2BLK_an[ik];
               }
               else
               {
                  if (TB == AtlasNoTrans)
                      out->b2blk = ATL_AMM_B2BLK_aX[ik];
                  else if (TB == AtlasTrans)
                      out->b2blk = ATL_AMM_BT2BLK_aX[ik];
                  else if (TB == AtlasConjTrans)
                      out->b2blk = ATL_AMM_BH2BLK_aX[ik];
                  else
                      out->b2blk = ATL_AMM_BC2BLK_aX[ik];
               }
            #else
               out->a2blk = (TA == AtlasNoTrans) ?
                            ATL_AMM_AT2BLK_a1[ik] : ATL_AMM_A2BLK_a1[ik];
               if (SCALAR_IS_NONE(alpha))
                  out->b2blk = (TB == AtlasNoTrans) ?
                               ATL_AMM_B2BLK_an[ik] : ATL_AMM_BT2BLK_an[ik];
               else
                  out->b2blk = (TB == AtlasNoTrans) ?
                               ATL_AMM_B2BLK_aX[ik] : ATL_AMM_BT2BLK_aX[ik];
            #endif
         }
      }
   }
   return(appAl);
}
@ROUT ATL_ammmNKM
#include "atlas_amm.h"
/*
 * This function loops only over M.  Therefore, it updates 1 column-panel
 * of C using a rank-kb update of a column-panel of A * colpan of B
 * If A2blk non-NULL, copy A, else assume already available in a.
 */
void Mjoin(PATL,ammmM) /* C <= beta*C + A*B, B/C nb-wide colpan */
(
   rkinfo_t *rkinf,
   int nb,             /* # of cols to do */
   int nnu,            /* CEIL(NB/nu) */
   ammkern_t amm,      /* amm kern to use for this kb */
   TYPE *a,            /* workspace for A */
   ATL_CINT inca,      /* gap between blocks (>= mb*kb) */
   const TYPE *b,      /* access-major kbXnb workspace for B */
   TYPE *c,            /* access-major mbXnb workspace for C */
   ATL_CINT incc,      /* gap between M blocks (0 or >=mb*nb) */
   const TYPE *A,      /* col/row-major (original) A */
   TYPE *C,            /* col-major (original) C */
   TYPE beta           /* scale factor for C */
)
{
   cm2am_t a2blk=rkinf->a2blk;    /* copy from row/col major A to access-maj */
   ablk2cmat_t blk2C=rkinf->blk2c;/* frm C's access-maj storage to col-maj */
   TYPE *af=a;
   ATL_CINT nfmb=rkinf->nfmb, mb=rkinf->mb, nmu=rkinf->nmu, mbL=rkinf->mbL;
   ATL_CINT kb=rkinf->kb;
   const size_t lda=rkinf->lda, ldc=rkinf->ldc, incAm=rkinf->incAm;
   ATL_INT i;

   for (i=0; i < nfmb; i++)
   {
      TYPE *an = a + inca, *cn=c+incc;

      if (a2blk)
         a2blk(kb, mb, ATL_rone, A, lda, a);
      amm(nmu, nnu, kb, a, b, c, an, b, cn);
      if (blk2C)
      {
         blk2C(mb, nb, ATL_rone, c, beta, C, ldc);
         C += mb;
      }

      c = cn;
      a = an;
      A += incAm;
   }
   if (mbL)
   {
      if (a2blk)
         a2blk(kb, mbL, ATL_rone, A, lda, a);
      amm(rkinf->nmuL, nnu, kb, a, b, c, af, b, c);
      if (blk2C)
         blk2C(mbL, nb, ATL_rone, c, beta, C, ldc);
   }
}

void Mjoin(PATL,ammmKM)/* computes full answer for one column-panel of C */
(                      /* by looping over both M&K */
   rkinfo_t *rkinf,    /* amm info for kb-width cols */
   rkinfo_t *krinf,    /* amm info for K remainder cols */
   int nb,             /* # of cols to do */
   int nnu,            /* NB/nu */
   TYPE *a,            /* workspace for A */
   ATL_CINT incam,     /* gap between blocks (>= mb*kb) */
   ATL_CINT incak,     /* 0: reuse same col of a, else a M*K in size */
   TYPE *b,            /* access-major kbXnb workspace for B */
   TYPE *c,            /* access-major mbXnb workspace for C */
   ATL_CINT inccm,     /* 0: write to C, else: write only to c */
   const TYPE *A,      /* col/row-major (original) A */
   const TYPE *B,      /* col/row-major (original) B */
   TYPE *C,            /* col-major (original) C */
   enum ATLAS_TRANS TA,
   enum ATLAS_TRANS TB,
   ATL_CSZT M,
   ATL_CSZT N,
   const SCALAR alpha, /* scale factor for B */
   const SCALAR beta   /* scale factor for C */
)
{
   const size_t incAk=rkinf->incAk, incBk=rkinf->incBk;
   const size_t ldb=rkinf->ldb;
   cm2am_t b2blk=rkinf->b2blk;
   ablk2cmat_t blk2c=rkinf->blk2c;
   ammkern_t amm=rkinf->amm_b0, amm_b1=rkinf->amm_b1;
   ATL_CINT idr=krinf->idx;
   ATL_CINT kb=rkinf->kb, kbL=rkinf->kbL, nfkblks=rkinf->nfkb;
   ATL_INT k, nk=rkinf->nfkb, DOPEEL=1;
   
   ATL_assert(rkinf->idx != -1);  /* don't call w/o more than 1 K block */
/*
 * The last block must be peeled to write C unless the last block is actually
 * a partial K-block, which isn't handled here anyway.  We also must peel and
 * write C if the K-block doesn't use the same C storage, which requires
 * an additional write to the original C to handle.  So, the only time we
 * don't peel an iteration is when the K-cleaner exists, and uses the 
 * the same format as the mainline K
 */
   if (kbL == 0 || idr == -1) /* no K-clean or GER/GER2 clean forces peel */
      nk--;
   else if (krinf->mu != rkinf->mu || krinf->nu != rkinf->nu)
      nk--;
   else
      DOPEEL=0;

   rkinf->blk2c = NULL;           /* don't write C out until K loop done */
   for (k=0; k < nk; k++, A += incAk, B += incBk)
   {
      b2blk(kb, nb, alpha, B, ldb, b);
      Mjoin(PATL,ammmM)(rkinf, nb, nnu, amm, a, incam, b, c, inccm, A, C, beta);
      amm = amm_b1;
      a += incak;
   }
   rkinf->blk2c = blk2c;  /* next ammmM call should write to C */
/*
 * If we peeled to write C, do that along with last full M block
 */
   if (DOPEEL)
   {
      b2blk(kb, nb, alpha, B, ldb, b);
      Mjoin(PATL,ammmM)(rkinf, nb, nnu, amm, a, incam, b, c, inccm, A, C, beta);
      a += incak;
      A += incAk;
      B += incBk;
   }
/*
 * Do we have K-cleanup to do?
 */
   if (kbL)
   {
      if (idr >= 0)  /* K cleanup uses gemm kernel */
      {
         krinf->kb = kbL;
         krinf->b2blk(kbL, nb, alpha, B, ldb, b);
         Mjoin(PATL,ammmM)(krinf, nb, nnu, krinf->amm_b1, a, incam, b, 
                           c, inccm, A, C, (DOPEEL)?ATL_rone:beta);
      }
/*
 *    If we use GER1/GER2 for cleanup, beta has already been applied above
 */
      else if (kbL == 2)  /* use GER2 to clean up */
         Mjoin(PATL,ammm_rk2)(TA, TB, M, nb, alpha, A, rkinf->lda, B, ldb, 
                              ATL_rone, C, rkinf->ldc);
      else /* kbL == 1, use GER1 */
      {
         #ifdef TCPLX
            ATL_CINT incA = (TA==AtlasNoTrans || TA==AtlasConj) ? 1:rkinf->lda;
            ATL_CINT incB = (TB==AtlasNoTrans || TB==AtlasConj) ? ldb:1;
         #else
            ATL_CINT incA = (TA==AtlasNoTrans) ? 1:rkinf->lda;
            ATL_CINT incB = (TB==AtlasNoTrans) ? ldb:1;
         #endif
         Mjoin(PATL,ger)(M, nb, alpha, A, incA, B, incB, C, rkinf->ldc);
      }
   }
}


static int ATL_ammm_rkK
(
   rkinfo_t *krinf,
   ATL_CSZT N,
   const SCALAR alpha,
   const TYPE *A,
   const TYPE *B,
   TYPE *C,
   const SCALAR beta
)
{
   const size_t ldb=krinf->ldb, ldc=krinf->ldc;
   ATL_CINT NB=krinf->nb, mu=krinf->mu, MB=krinf->mb, kb=krinf->kb;
   ATL_CINT mbL=krinf->mbL, nfnb=krinf->nfnb, nnu=krinf->nnu;
   ATL_INT inca, j;
   const size_t incC=NB*ldc, incBn=krinf->incBn;
   size_t szA, szB, szC;
   cm2am_t b2blk = krinf->b2blk;
   TYPE *a, *b, *c;
   void *vp;

   if (N > NB)
   {
      szA = (MB*krinf->nfmb + krinf->MBL)*kb;
      inca = MB*kb;
   }
   else
   {
      szA = MB*kb;
      inca = 0;
   }
   szB = NB*kb;
   szC = MB*NB;
   vp = malloc(3*ATL_Cachelen + ATL_MulBySize(szA+szB+szC));
   ATL_assert(vp);
   if (!vp)
      return(1);
   a = ATL_AlignPtr(vp);
   b = a + szA;
   b = ATL_AlignPtr(b);
   c = b + szB;
   c = ATL_AlignPtr(c);

   if (nfnb)
   {
      b2blk(kb, NB, alpha, B, ldb, b);
      Mjoin(PATL,ammmM)(krinf, NB, nnu, krinf->amm_b0, a, inca, b, c, 0, A, 
                        C, beta);
      krinf->a2blk = NULL;
      C += incC;
      B += incBn;
      for (j=1; j < nfnb; j++, C += incC, B += incBn)
      {
         b2blk(kb, NB, alpha, B, ldb, b);
         Mjoin(PATL,ammmM)(krinf, NB, nnu, krinf->amm_b0, a, inca, b, c, 0, A, 
                           C, beta);
      }
   }
   if (krinf->nbL)
   {
      b2blk(kb, krinf->nbL, alpha, B, ldb, b);
      Mjoin(PATL,ammmM)(krinf, krinf->nbL, krinf->nnuL, krinf->amm_b0, a, inca,
                        b, c, 0, A, C, beta);
   }
   free(vp);
}

int Mjoin(PATL,ammmNKM)
(
   enum ATLAS_TRANS TA,
   enum ATLAS_TRANS TB,
   ATL_CSZT M,
   ATL_CSZT N,
   ATL_CSZT K,
   const SCALAR alpha,
   const TYPE *A,
   ATL_CSZT lda,
   const TYPE *B,
   ATL_CSZT ldb,
   const SCALAR beta,
   TYPE *C,
   ATL_CSZT ldc
)
{
   rkinfo_t kbinf, krinf;
   size_t szA, szB, szC, incak, inccm, incBn, incC;
   ATL_INT j, mb, nfmb, nb, mbL, kb, kbL, incam, nfnb, nfkb, RCPYA=0;
   ATL_INT nnu, nmblks, nkblks;
   TYPE *a, *b, *c;
   void *vp;
   void Mjoin(PATL,GetBestKBInfo)
      (rkinfo_t*, rkinfo_t*, enum ATLAS_TRANS, enum ATLAS_TRANS,
       ATL_CSZT, ATL_CSZT, ATL_CSZT, size_t, size_t, size_t,
       const SCALAR, const SCALAR);

   if (K < 3)
   {
      Mjoin(PATL,ammm)(TA, TB, M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
      return(0);
   }
   Mjoin(PATL,GetBestKBInfo)(&kbinf, &krinf, TA, TB, M, N, K, lda, ldb, ldc,
                             alpha, beta);
   if (kbinf.idx == -1)
      return(ATL_ammm_rkK(&krinf, N, alpha, A, B, C, beta));

   mb = kbinf.mb;
   nb = kbinf.nb;
   kb = kbinf.kb;
   mbL = kbinf.mbL;
   kbL = kbinf.kbL;
   nfmb = kbinf.nfmb;
   nfnb = kbinf.nfnb;
   nfkb = kbinf.nfkb;
   nmblks = (mbL) ? nfmb+1 : nfmb;
   nkblks = (kbL) ? nfkb+1 : nfkb;
   nnu = kbinf.nnu;
   incBn = kbinf.incBn;
   incC = nb*ldc;
   if (K > kb)
   {
      inccm = mb*nb;
      szC = (nfmb*mb+kbinf.MBL)*nb;
   }
   else
   {
      szC = mb*nb;
      inccm = 0;
   }
   if (N > nb)
   {
      incam = mb*kb;        
      incak = incam*nmblks;
      szA = incak * nkblks;
   }
   else
   {
      incam = incak = 0;
      szA = mb * kb;
   }

   if (krinf.idx >= 0)
      RCPYA = krinf.a2blk != kbinf.a2blk;
   szB = kb*nb;
   vp = malloc(3*ATL_Cachelen + ATL_MulBySize(szA+szB+szC));
   ATL_assert(vp);
   a = ATL_AlignPtr(vp);
   b = a + szA;
   b = ATL_AlignPtr(b);
   c = b + szB;
   c = ATL_AlignPtr(c);
   for (j=0; j < nfnb; j++, C += incC, B += incBn)
      Mjoin(PATL,ammmKM)(&kbinf, &krinf, nb, nnu, a, incam, incak, b,
                         c, inccm, A, B, C, TA, TB, M, N, alpha, beta);
   if (kbinf.nbL)
   {
      Mjoin(PATL,ammmKM)(&kbinf, &krinf, kbinf.nbL, kbinf.nnuL, a, incam, incak,
                         b, c, inccm, A, B, C, TA, TB, M, N, alpha, beta);
   }
   free(vp);
   return(0);
}
@ROUT ATL_ammmK ATL_cammmK
#include "atlas_misc.h"
#include "atlas_amm.h"
#include Mstr(Mjoin(AMM_PRE,_sum.h))

void Mjoin(PATL,ammmK)
(
   amminfo_t *mminf,
   const int mb,           /* # of rows of C to compute */
   const int nmu,          /* CEIL(mb/mu) */
   const int nb,  
   const int nnu,
   ATL_CINT nfkblks, /* FLOOR(K/kb) */
   const int kb,
   const int kb0,
   const int KB0,
   const TYPE *A,
   const size_t lda,   
   const size_t incAk, /* 0: no need to copy A, else incK for cpying A */
   const TYPE *B,
   const size_t ldb,   
   const size_t incBk, /* 0: no need to copy B, else incK for cpying A */
   const ablk2cmat_t blk2c,
   TYPE *C,
   const size_t ldc,   
   TYPE *a,
   ATL_CINT inca,      /* size of blocks of A, or 0 to reuse space */
   TYPE *b,
   ATL_CINT incb,      /* size of blocks of B, or 0 to reuse space */
   TYPE *rC, 
   TYPE *iC, 
   const SCALAR alpA,
   const SCALAR alpB,
   const SCALAR alpC,
   const SCALAR beta
)
@ROUT ATL_ammmK
{
   cm2am_t a2blk=mminf->a2blk, b2blk=mminf->b2blk;
   ammkern_t amm=mminf->amm_b0;
   TYPE *an=a+inca, *bn=b+incb;
   ATL_INT k;
/*
 * Peel first iteration to handle KR and use beta=0
 */
   if (kb0 != kb)
   {
      ATL_CINT ku=mminf->ku;
      amm = mminf->amm_k1_b0;
      if ( ATL_AMMFLG_KRUNTIME(mminf->flag) && (mminf->kbmin <= KB0) && 
           (ATL_AMMFLG_KMAJOR(mminf->flag) || (KB0 == kb0)) &&
           (kb0/ku)*ku == kb0)
         amm = mminf->amm_b0;
      if (incAk)
         a2blk(kb0, mb, alpA, A+incAk*nfkblks, lda, a);
      if (incBk)
         b2blk(kb0, nb, alpB, B+incBk*nfkblks, ldb, b);
      amm(nmu, nnu, KB0, a, b, rC, an, bn, rC);
   }
   else
   {
      if (incAk)
      {
         a2blk(kb0, mb, alpA, A, lda, a);
         A += incAk;
      }
      if (incBk)
      {
         b2blk(kb0, nb, alpB, B, ldb, b);
         B += incBk;
      }
      amm(nmu, nnu, KB0, a, b, rC, an, bn, rC);
   }
   amm = mminf->amm_b1;
   a = an;
   b = bn;

   for (k=0; k < nfkblks; k++)
   {
      if (incAk)
      {
         a2blk(kb, mb, alpA, A, lda, a);
         A += incAk;
      }
      if (incBk)
      {
         b2blk(kb, nb, alpB, B, ldb, b);
         B += incBk;
      }
      an = a + inca;
      bn = b + incb;
      amm(nmu, nnu, kb, a, b, rC, an, bn, rC);
      a = an;
      b = bn;
   }
   if (blk2c)
      blk2c(mb, nb, alpC, rC, beta, C, ldc);
}
@ROUT ATL_cammmK
{
   cm2am_t a2blk=mminf->a2blk, b2blk=mminf->b2blk;
   ammkern_t amm_b0=mminf->amm_b0, amm_b1=mminf->amm_b1, amm_bn=mminf->amm_bn;
   ATL_CINT inca2=inca+inca, incb2=incb+incb;
   ATL_INT szA = inca, szB = incb;
   TYPE *iA=a, *iB=b, *rA, *rB;
   TYPE *an=iA+inca2, *bn=iB+incb2;
   ATL_INT k;
   if (!szA)
      szA = nmu*mminf->mu*Mmax(kb,KB0);
   if (!szB)
      szB = nnu*mminf->nu*Mmax(kb,KB0);
   rA = iA + szA;
   rB = iB + szB;
/*
 * Peel first iteration to handle KR and use beta=0
 */
   if (kb0 != kb)
   {
      amm_b0 = mminf->amm_k1_b0;
      if ( ATL_AMMFLG_KRUNTIME(mminf->flag) && (mminf->kbmin <= KB0) && 
           (ATL_AMMFLG_KMAJOR(mminf->flag) || (KB0 == kb0)) )
         amm_b0 = mminf->amm_b0;
      if (amm_b0 != mminf->amm_b0)
      {
         amm_b1 = mminf->amm_k1_b1;
         amm_bn = mminf->amm_k1_bn;
      }
      if (incAk)
         a2blk(kb0, mb, alpA, A+incAk*nfkblks, lda, rA, iA);
      if (incBk)
         b2blk(kb0, nb, alpB, B+incBk*nfkblks, ldb, rB, iB);

      amm_b0(nmu, nnu, KB0, iA, iB, rC, rA, iB, iC);
      amm_b0(nmu, nnu, KB0, rA, iB, iC, rA, rB, rC);
      amm_bn(nmu, nnu, KB0, rA, rB, rC, iA, rB, iC);
      amm_b1(nmu, nnu, KB0, iA, rB, iC, an, bn, rC);

      amm_b1 = mminf->amm_b1;
      amm_bn = mminf->amm_bn;
   }
   else
   {
      if (incAk)
      {
         a2blk(kb, mb, alpA, A, lda, rA, iA);
         A += incAk;
      }
      if (incBk)
      {
         b2blk(kb, nb, alpB, B, ldb, rB, iB);
         B += incBk;
      }
      amm_b0(nmu, nnu, kb, iA, iB, rC, rA, iB, iC);
      amm_b0(nmu, nnu, kb, rA, iB, iC, rA, rB, rC);
      amm_bn(nmu, nnu, kb, rA, rB, rC, iA, rB, iC);
      amm_b1(nmu, nnu, kb, iA, rB, iC, an, bn, rC);
   }

   for (k=0; k < nfkblks; k++)
   {
      iA = an;
      iB = bn;
      rA = iA + szA;
      rB = iB + szB;
      an = iA + inca2;
      bn = iB + incb2;
      if (incAk)
      {
         a2blk(kb, mb, alpA, A, lda, rA, iA);
         A += incAk;
      }
      if (incBk)
      {
         b2blk(kb, nb, alpB, B, ldb, rB, iB);
         B += incBk;
      }
      amm_bn(nmu, nnu, kb, iA, iB, rC, rA, iB, iC);
      amm_b1(nmu, nnu, kb, rA, iB, iC, rA, rB, rC);
      amm_bn(nmu, nnu, kb, rA, rB, rC, iA, rB, iC);
      amm_b1(nmu, nnu, kb, iA, rB, iC, an, bn, rC);
   }
   if (blk2c)
      blk2c(mb, nb, alpC, rC, iC, beta, C, ldc);
}
@ROUT ATL_ammmKNMK
#include "atlas_misc.h"
#include "atlas_amm.h"
#include Mstr(Mjoin(AMM_PRE,_sum.h))

static void ATL_ammmMK
(
   amminfo_t *mminf,
   ATL_CSZT nfmblks,         /* FLOOR(M/mb) */
   const int mbL,            /* mbL=M%mb */
   const int nmuL,
   const int nb,
   const int nnu,
   ATL_CSZT nfkblks,         /* FLOOR(K/kb) */
   const int kb0,
   const int KB0,
   const TYPE *A,
   const size_t lda,
   const size_t incAk,       /* 0: no need to copy A, else incK for cpying A */
   const size_t incAm,
   const TYPE *B,
   const size_t ldb,
   const size_t incBk0,      /* 0: no need to copy B, else incK for cpying A */
   TYPE *C,
   const size_t ldc,
   const size_t incCm,
   TYPE *a,
   ATL_CINT inca,      /* size of blocks of A, or 0 to reuse space */
   ATL_CSZT incam,
   TYPE *b,
   ATL_CINT incb,      /* size of blocks of B, or 0 to reuse space */
   TYPE *rC,
   TYPE *iC,
   const SCALAR alpA,
   const SCALAR alpB,
   const SCALAR alpC,
   const SCALAR beta
)
{
   ATL_SZT i, incBk=incBk0;
   const int mu=mminf->mu, mb=mminf->mb, nmu=(mb+mu-1)/mu; 
   const int kb=mminf->kb;
   ablk2cmat_t blk2c=mminf->Cblk2cm;

   for (i=0; i < nfmblks; i++, A += incAm, C += incCm, a += incam)
   {
      Mjoin(PATL,ammmK)(mminf, mb, nmu, nb, nnu, nfkblks, kb, kb0, KB0, 
                        A, lda, incAk, B, ldb, incBk, blk2c, C, ldc, 
                        a, inca, b, incb, rC, iC, alpA, alpB, alpC, beta);
      incBk = 0; /* reuse B for rest of C colum panel */
   }
   if (mbL)
      Mjoin(PATL,ammmK)(mminf, mbL, nmuL, nb, nnu, nfkblks, kb, kb0, KB0, 
                        A, lda, incAk, B, ldb, incBk, blk2c, C, ldc, 
                        a, inca, b, incb, rC, iC, alpA, alpB, alpC, beta);
}

static void ATL_ammmNMK
(
   amminfo_t *mminf,
   enum ATLAS_TRANS TA,
   enum ATLAS_TRANS TB,
   ATL_CSZT M,
   ATL_CSZT N,
   ATL_CSZT K,
   const TYPE *A,
   ATL_CSZT lda,
   const TYPE *B,
   ATL_CSZT ldb,
   TYPE *C,
   ATL_CSZT ldc,
   ATL_SZT nmblks,            /* CEIL(M/mb) */
   ATL_SZT nkblks,            /* CEIL(K/kb) */
   TYPE *a,
   TYPE *b, 
   TYPE *c,
   const SCALAR alpA,
   const SCALAR alpB,
   const SCALAR alpC,
   const SCALAR beta
)
{
   const int mb=mminf->mb, nb=mminf->nb, kb=mminf->kb;
   const int mu=mminf->mu, nu=mminf->nu, ku=mminf->ku;
   const int nmu=(mb+mu-1)/mu, nnu=(nb+nu-1)/nu;
   const int inca=mb*kb, incb=kb*nb;
   int mbL=0, nmuL=0, nbF=nb, nnuF=nnu, KB0, kb0;
   ATL_CSZT incam = nkblks*(inca SHIFT), incCn = nb*(ldc SHIFT);
   ATL_SZT j, incAm, incAk, incBk, incBn, incBnF;
   ATL_SZT nnblks = (N-1)/nb;
   #ifdef TCPLX
      TYPE *iC=c, *rC=c+mb*nb;
      const int mb2=mb+mb;
   #else
      #define rC c
      #define iC c
      #define mb2 mb
   #endif

   j = nmblks*mb;
   if (j != M)
   {
      nmblks--;
      mbL = M - j + mb;
      nmuL = (mbL+mu-1)/mu;
   }
   j = nnblks*nb;
   nbF = N - j;
   if (nbF != nb)
      nnuF = (nbF+nu-1)/nu;
   nkblks--;
   j = nkblks*kb;
   KB0 = kb0 = K - j;
   #if ATL_AMM_MAXKMAJ > 1
      if (kb0 != kb && ATL_AMMFLG_KMAJOR(mminf->flag))
         KB0 = ((kb0+ku-1)/ku)*ku;
   #endif
   if (IS_COLMAJ(TA))
   {
      incAk = kb*lda;
      incAm = mb;
   }
   else
   {
      incAk = kb;
      incAm = mb*lda;
   }
   if (IS_COLMAJ(TB))
   {
      incBk = kb;
      incBn = nb*ldb;
      incBnF = nbF*ldb;
   }
   else
   {
      incBk = kb*ldb;
      incBn = nb;
      incBnF = nbF;
   }
   #ifdef TCPLX
      incAk += incAk;
      incAm += incAm;
      incBk += incBk;
      incBn += incBn;
      incBnF += incBnF;
   #endif
/*
 * In first nbF-wide panel, we copy all of A into workspace
 */
   ATL_ammmMK(mminf, nmblks, mbL, nmuL, nbF, nnuF, nkblks, kb0, KB0,
              A, lda, incAk, incAm, B, ldb, incBk, C, ldc, mb2,
              a, inca, incam, b, incb, rC, iC, alpA, alpB, alpC, beta);
   C += ldc*(nbF SHIFT);
   B += incBnF;
/*
 * In all other N-panel computation, reuse previously copied A!
 */
   if (nnblks)
   {
      incAk = 0;
      for (j=0; j < nnblks; j++, C += incCn, B += incBn)
         ATL_ammmMK(mminf, nmblks, mbL, nmuL, nb, nnu, nkblks, kb0, KB0,
                    A, lda, incAk, incAm, B, ldb, incBk, C, ldc, mb2,
                    a, inca, incam, b, incb, rC, iC, alpA, alpB, alpC, beta);
   }
}
#ifndef TCPLX
   #undef rC
   #undef iC
   #undef mb2
#endif

int Mjoin(PATL,ammmKNMK)
(
   enum ATLAS_TRANS TA,
   enum ATLAS_TRANS TB,
   ATL_CSZT M,
   ATL_CSZT N,
   ATL_CSZT K,
   const SCALAR alpha,
   const TYPE *A,
   ATL_CSZT lda,
   const TYPE *B,
   ATL_CSZT ldb,
   const SCALAR beta,
   TYPE *C,
   ATL_CSZT ldc
)
{
   #ifdef TCPLX
      const TYPE ONE[2]={ATL_rone,ATL_rzero}, ZERO[2]={ATL_rzero,ATL_rzero};
      const TYPE *alpA=ONE, *alpB=ONE, *alpC=ONE;
   #else
      #define ONE ATL_rone
      TYPE alpA=ATL_rone, alpB=ATL_rone, alpC=ATL_rone;
   #endif
   void *vp=NULL;
   TYPE *a, *b, *c;
   ATL_SZT szA, szB, szC, sz, nmblks, nkblks, nkblksP, k;
   ATL_INT nkP=0;
   int mu, nu, mb, nb, kb, incak, incbk;
   amminfo_t mminf;


   mu = Mjoin(PATL,GetAmmmInfo)(&mminf, TA, TB, M, N, K, alpha, beta);
   if (!mu)
      alpA = alpha;
   else if (mu == 1)
      alpB = alpha;
   else
      alpC = alpha;

   mu = mminf.mu;
   nu = mminf.nu;
   mb = mminf.mb;
   nb = mminf.nb;
   kb = mminf.kb;
   nmblks = (M+mb-1)/mb;
   nkblksP = nkblks = (K+kb-1)/kb;
   nkblksP <<= 1;
   incak = mb*kb;
   incbk = kb*nb;
   szC = mb*nb;
   #if 0
   if (nkblks > 1)
   {
      nkP++;
      nkblksP >>= 1;
   }
   #endif
   do
   {
      nkP++;
      nkblksP >>= 1;
      szA = nkblksP*nmblks*incak;
      szB = nkblksP*incbk;
      sz = ATL_MulBySize(szA+szB+szC+(mu+mu)*nu) + 2*ATL_Cachelen;
      if (sz <= ATL_MaxMalloc)
         vp = malloc(sz);
   }
   while (!vp && nkblksP >= 3);
   if (!vp)
      return(1);

   a = ATL_AlignPtr(vp);
   b = a + (szA SHIFT);
   c = b + (szB SHIFT);
   
   if (nkblksP == nkblks)
      ATL_ammmNMK(&mminf, TA, TB, M, N, K, A, lda, B, ldb, C, ldc, nmblks, 
                  nkblks, a, b, c, alpA, alpB, alpC, beta);
   else
   {
      ATL_CSZT KK = nkblksP*kb;
      ATL_SZT incAkp, incBkp;
      incBkp = incAkp = KK SHIFT;
      if (IS_COLMAJ(TA))
         incAkp *= lda;
      if (!IS_COLMAJ(TB))
         incBkp *= ldb;
      for (k=0; k < nkblks; k += nkblksP, A += incAkp, B += incBkp)
      {
         ATL_SZT nk=nkblks-k, kk;
         if (nk > nkblksP)
         {
            kk = KK;
            nk = nkblksP;
         }
         else
            kk = K - k*kb;
         ATL_ammmNMK(&mminf, TA, TB, M, N, kk, A, lda, B, ldb, C, ldc, nmblks, 
                     nk, a, b, c, alpA, alpB, alpC, beta);
      }
   }
   free(vp);
   return(0);
}
@ROUT ATL_ammmKMNK
#include "atlas_misc.h"
#include "atlas_amm.h"
#include Mstr(Mjoin(AMM_PRE,_sum.h))

static void ATL_ammmNK
(
   amminfo_t *mminf,
   const int mb,
   const int nmu,
   ATL_CSZT nfnblks,         /* FLOOR(N/nb) */
   const int nbL,            /* nbL=N%nb */
   const int nnuL,
   ATL_CSZT nfkblks,         /* FLOOR(K/kb) */
   const int kb0,
   const int KB0,
   const TYPE *A,
   const size_t lda,
   const size_t incAk0,      /* 0: no need to copy A, else incK for cpying A */
   const TYPE *B,
   const size_t ldb,
   const size_t incBk,       /* 0: no need to copy B, else incK for cpying A */
   const size_t incBn,
   TYPE *C,
   const size_t ldc,
   const size_t incCn,
   TYPE *a,
   ATL_CINT inca,      /* size of blocks of A, or 0 to reuse space */
   TYPE *b,
   ATL_CINT incb,      /* size of blocks of B, or 0 to reuse space */
   ATL_CSZT incbn,
   TYPE *rC,
   TYPE *iC,
   const SCALAR alpA,
   const SCALAR alpB,
   const SCALAR alpC,
   const SCALAR beta
)
{
   ATL_SZT j, incAk=incAk0;
   const int nu=mminf->nu, nb=mminf->nb, nnu=(nb+nu-1)/nu;
   const int kb=mminf->kb;
   ablk2cmat_t blk2c=mminf->Cblk2cm;

   for (j=0; j < nfnblks; j++, B += incBn, C += incCn, b += incbn)
   {
      Mjoin(PATL,ammmK)(mminf, mb, nmu, nb, nnu, nfkblks, kb, kb0, KB0,
                        A, lda, incAk, B, ldb, incBk, blk2c, C, ldc,
                        a, inca, b, incb, rC, iC, alpA, alpB, alpC, beta);
      incAk = 0; /* reuse A for rest of C row panel */
   }
   if (nbL)
      Mjoin(PATL,ammmK)(mminf, mb, nmu, nbL, nnuL, nfkblks, kb, kb0, KB0,
                        A, lda, incAk, B, ldb, incBk, blk2c, C, ldc,
                        a, inca, b, incb, rC, iC, alpA, alpB, alpC, beta);
}
static void ATL_ammmMNK
(
   amminfo_t *mminf,
   enum ATLAS_TRANS TA,
   enum ATLAS_TRANS TB,
   ATL_CSZT M,
   ATL_CSZT N,
   ATL_CSZT K,
   const TYPE *A,
   ATL_CSZT lda,
   const TYPE *B,
   ATL_CSZT ldb,
   TYPE *C,
   ATL_CSZT ldc,
   ATL_SZT nnblks,            /* CEIL(N/nb) */
   ATL_SZT nkblks,            /* CEIL(K/kb) */
   TYPE *a,
   TYPE *b, 
   TYPE *c,
   const SCALAR alpA,
   const SCALAR alpB,
   const SCALAR alpC,
   const SCALAR beta
)
{
   const int mb=mminf->mb, nb=mminf->nb, kb=mminf->kb;
   const int mu=mminf->mu, nu=mminf->nu, ku=mminf->ku;
   const int nmu=(mb+mu-1)/mu, nnu=(nb+nu-1)/nu;
   const int inca=mb*kb, incb=kb*nb;
   int nbL=0, nnuL=0, mbF=mb, nmuF=nmu, KB0, kb0;
   ATL_CSZT incbn = nkblks*(incb SHIFT), incCn = nb*(ldc SHIFT);
   ATL_SZT j, incAm, incAk, incBk, incBn, incAmF;
   ATL_SZT nmblks = (M-1)/mb;
   #ifdef TCPLX
      TYPE *iC=c, *rC=c+mb*nb;
      const int mb2=mb+mb;
   #else
      #define rC c
      #define iC c
      #define mb2 mb
   #endif

   j = nnblks*nb;
   if (j != N)
   {
      nnblks--;
      nbL = N - j + nb;
      nnuL = (nbL+nu-1)/nu;
   }
   j = nmblks*mb;
   mbF = M - j;
   if (mbF != mb)
      nmuF = (mbF+mu-1)/mu;
   nkblks--;
   j = nkblks*kb;
   KB0 = kb0 = K - j;
   #if ATL_AMM_MAXKMAJ > 1
      if (kb0 != kb && ATL_AMMFLG_KMAJOR(mminf->flag))
         KB0 = ((kb0+ku-1)/ku)*ku;
   #endif
   if (IS_COLMAJ(TA))
   {
      incAk = kb*lda;
      incAm = mb;
      incAmF = mbF;
   }
   else
   {
      incAk = kb;
      incAm = mb*lda;
      incAmF = mbF*lda;
   }
   if (IS_COLMAJ(TB))
   {
      incBk = kb;
      incBn = nb*ldb;
   }
   else
   {
      incBk = kb*ldb;
      incBn = nb;
   }
   #ifdef TCPLX
      incAk += incAk;
      incAm += incAm;
      incBk += incBk;
      incBn += incBn;
      incAmF += incAmF;
   #endif
/*
 * In first mbF-wide panel, we copy all of B into workspace
 */
   ATL_ammmNK(mminf, mbF, nmuF, nnblks, nbL, nnuL, nkblks, kb0, KB0,
              A, lda, incAk, B, ldb, incBk, incBn, C, ldc, incCn,
              a, inca, b, incb, incbn, rC, iC, alpA, alpB, alpC, beta);
   C += (mbF SHIFT);
   A += incAmF;
/*
 * In all other M-panel computation, reuse previously copied B!
 */
   if (nmblks)
   {
      for (j=0; j < nmblks; j++, C += mb2, A += incAm)
         ATL_ammmNK(mminf, mb, nmu, nnblks, nbL, nnuL, nkblks, kb0, KB0,
                    A, lda, incAk, B, ldb, 0, incBn, C, ldc, incCn,
                    a, inca, b, incb, incbn, rC, iC, alpA, alpB, alpC, beta);
   }
}
#ifndef TCPLX
   #undef rC
   #undef iC
   #undef mb2
#endif

int Mjoin(PATL,ammmKMNK)
(
   enum ATLAS_TRANS TA,
   enum ATLAS_TRANS TB,
   ATL_CSZT M,
   ATL_CSZT N,
   ATL_CSZT K,
   const SCALAR alpha,
   const TYPE *A,
   ATL_CSZT lda,
   const TYPE *B,
   ATL_CSZT ldb,
   const SCALAR beta,
   TYPE *C,
   ATL_CSZT ldc
)
{
   #ifdef TCPLX
      const TYPE ONE[2]={ATL_rone,ATL_rzero}, ZERO[2]={ATL_rzero,ATL_rzero};
      const TYPE *alpA=ONE, *alpB=ONE, *alpC=ONE;
   #else
      #define ONE ATL_rone
      TYPE alpA=ATL_rone, alpB=ATL_rone, alpC=ATL_rone;
   #endif
   void *vp=NULL;
   TYPE *a, *b, *c;
   ATL_SZT szA, szB, szC, sz, nnblks, nkblks, nkblksP, k;
   ATL_INT nkP=0;
   int mu, nu, mb, nb, kb, incak, incbk;
   amminfo_t mminf;


   mu = Mjoin(PATL,GetAmmmInfo)(&mminf, TA, TB, M, N, K, alpha, beta);
   if (!mu)
      alpA = alpha;
   else if (mu == 1)
      alpB = alpha;
   else
      alpC = alpha;

   mu = mminf.mu;
   nu = mminf.nu;
   mb = mminf.mb;
   nb = mminf.nb;
   kb = mminf.kb;
   nnblks = (N+nb-1)/nb;
   nkblksP = nkblks = (K+kb-1)/kb;
   nkblksP <<= 1;
   incak = mb*kb;
   incbk = kb*nb;
   szC = mb*nb;
   do
   {
      nkP++;
      nkblksP >>= 1;
      szA = nkblksP*incak;
      szB = nkblksP*nnblks*incbk;
      sz = ATL_MulBySize(szA+szB+szC+(mu+mu)*nu) + 2*ATL_Cachelen;
      if (sz <= ATL_MaxMalloc)
         vp = malloc(sz);
   }
   while (!vp && nkblksP >= 3);
   if (!vp)
      return(1);

   b = ATL_AlignPtr(vp);
   a = b + (szB SHIFT);
   c = a + (szA SHIFT);

   if (nkblksP == nkblks)
      ATL_ammmMNK(&mminf, TA, TB, M, N, K, A, lda, B, ldb, C, ldc, nnblks,
                  nkblks, a, b, c, alpA, alpB, alpC, beta);
   else
   {
      ATL_CSZT KK = nkblksP*kb;
      ATL_SZT incAkp, incBkp;
      incBkp = incAkp = KK SHIFT;
      if (IS_COLMAJ(TA))
         incAkp *= lda;
      if (!IS_COLMAJ(TB))
         incBkp *= ldb;
      for (k=0; k < nkblks; k += nkblksP, A += incAkp, B += incBkp)
      {
         ATL_SZT nk=nkblks-k, kk;
         if (nk > nkblksP)
         {
            kk = KK;
            nk = nkblksP;
         }
         else
            kk = K - k*kb;
         ATL_ammmMNK(&mminf, TA, TB, M, N, kk, A, lda, B, ldb, C, ldc, nnblks,
                     nk, a, b, c, alpA, alpB, alpC, beta);
      }
   }
   free(vp);
   return(0);
}
@ROUT ATL_ammm_syrk
#include "atlas_misc.h"
#include "atlas_amm.h"
#include Mstr(Mjoin(AMM_PRE,_sum.h))

int Mjoin(PATL,ammm_syrk)
(
   const enum ATLAS_UPLO  Uplo,
   const enum ATLAS_TRANS TA,
   ATL_CSZT  N,
   ATL_CSZT K,
   const SCALAR alpha,
   const TYPE *A,
   ATL_CSZT lda,
   const SCALAR beta,
   TYPE *C,
   ATL_CSZT ldc
)
{
   ablk2cmat_t blk2c, blk2c_b0;
   ATL_CSZT ldcp1=(ldc+1)SHIFT;
   ATL_SZT i, j, szA, pansz, sz, nnblks, nkblks, incCn, incAk, incAn, incAnF;
   const TYPE *B = A;
   const TYPE *a;
   TYPE *wa, *ar, *wb, *wc, *wC, *c;
   void *vp=NULL;
   const int ISHERK=(TA == AtlasConj || TA == AtlasConjTrans);
   int ibet=1, ialp=1;
   int mu, nu, ku, incw, nb, nnu, nmu, nbF, nnuF, nmuF, kb0, KB0;
   #ifdef TCPLX
      const TYPE ONE[2] = {ATL_rone, ATL_rzero};
      const TYPE ZERO[2] = {ATL_rzero, ATL_rzero};
      TYPE *rC, *CC=C;
      int incw2, nb2;
   #else
      #define ONE ATL_rone
      #define ZERO ATL_rzero
      #define rC wc
      #define incw2 incw
      #define nb2 nb
   #endif
   amminfo_t mminf;


//   printf("UP=%c, N=%d, K=%d\n", Uplo==AtlasLower?'L':'U', (int)N, (int)K);
   if (SCALAR_IS_NONE(alpha))
      ialp = -1;
   else if (!SCALAR_IS_ONE(alpha))
      ialp = 2;
   if (SCALAR_IS_ZERO(beta))
      ibet = 0;
   else if (SCALAR_IS_NONE(beta))
      ibet = -1;
   else if (!SCALAR_IS_ONE(beta))
      ibet = 2;

   nb = Mjoin(PATL,GetSyrkInfo)(&mminf, ialp, TA, N, K, ibet);
   blk2c = mminf.Cblk2cm;
   blk2c_b0 = mminf.Cblk2cm_b1;
   mu = mminf.mu;
   nu = mminf.nu;
   ku = mminf.ku;
   nmu = (nb+mu-1)/mu;
   nnu = (nb+nu-1)/nu;
   nnblks = (N+nb-1)/nb;
   nkblks = (K+nb-1)/nb;
   incw = nb*nb;
   #ifdef TCPLX
      nb2 = nb + nb;
      incw2 = incw + incw;
   #endif
   pansz = nkblks*incw;
   szA = Mmax(nnblks-1,1);
   szA *= pansz;
   sz = szA + pansz + incw + incw + (mu+mu)*nu;
   sz = ATL_MulBySize(sz) + ATL_Cachelen;
   if (sz <= ATL_MaxMalloc)
      vp = malloc(sz);
   if (!vp)
      return(1);
   #ifdef TCPLX
      pansz += pansz;
   #endif
   wa = ATL_AlignPtr(vp);
   wb = wa + (szA SHIFT);
   wc = wb + pansz;
   wC = wc + incw2;

   nbF = N - (--nnblks)*nb;
   if (nbF == nb)
   {
      nmuF = nmu;
      nnuF = nnu;
   }
   else
   {
      nmuF = (nbF+mu-1)/mu;
      nnuF = (nbF+nu-1)/nu;
   }
   KB0 = kb0 = K - (--nkblks)*nb;
   #if ATL_AMM_MAXKMAJ > 1
      if (kb0 != nb && ATL_AMMFLG_KMAJOR(mminf.flag))
         KB0 = ((kb0+ku-1)/ku)*ku;
   #endif
   #ifdef TCPLX
      rC = wc + incw;
   #endif
   if (IS_COLMAJ(TA))
   {
      incAk = nb*(lda SHIFT);
      incAn = nb2;
      incAnF = nbF SHIFT;
   }
   else
   {
      incAk = nb2;
      incAn = lda SHIFT;
      incAnF = incAn * nbF;
      incAn *= nb;
   }
   incCn = nb*ldcp1;
   if (Uplo == AtlasLower)
   {
/*
 *    Peel first column of C computation, which will handle all partial blocks
 *    First rowpan of A not reused, so set inca=0
 */
      Mjoin(PATL,ammmK)(&mminf, nbF, nmuF, nbF, nnuF, nkblks, nb, kb0, KB0,
                        A, lda, incAk, B, lda, incAk, blk2c_b0, wC, nb,
                        wa, 0, wb, incw, rC, wc, ONE, alpha, ONE, ZERO);
      Mjoin(PATL,tradd)(Uplo, nbF, wC, nb, beta, C, ldc);
      if (ISHERK)
         Mjoin(PATLU,zero)(nbF, C+1, ldcp1);
      c = C + (nbF SHIFT);
      A += incAnF;
      B += incAnF;
      C += nbF*ldcp1;
      ar = wa;
      for (i=0; i < nnblks; i++, c += nb2, A += incAn, ar += pansz)
         Mjoin(PATL,ammmK)(&mminf, nb, nmu, nbF, nnuF, nkblks, nb, kb0, KB0,
                           A, lda, incAk, B, lda, 0, blk2c, c, ldc,
                           ar, incw, wb, incw, rC, wc, ONE, alpha, ONE, beta);
      for (j=0; j < nnblks; j++, B += incAn, C += incCn, wa += pansz)
      {
         Mjoin(PATL,ammmK)(&mminf, nb, nmu, nb, nnu, nkblks, nb, kb0, KB0,
                           A, lda, 0, B, lda, incAk, blk2c_b0, wC, nb,
                           wa, incw, wb, incw, rC, wc, ONE, alpha, ONE, ZERO);
         Mjoin(PATL,tradd)(Uplo, nb, wC, nb, beta, C, ldc);
         if (ISHERK)
            Mjoin(PATLU,zero)(nb, C+1, ldcp1);
         c = C + nb2;
         ar = wa + pansz;
         for (i=j+1; i < nnblks; i++, c += nb2, ar += pansz)
            Mjoin(PATL,ammmK)(&mminf, nb, nmu, nb, nnu, nkblks, nb, kb0, KB0,
                              A, lda, 0, B, lda, 0, blk2c, c, ldc, ar, incw,
                              wb, incw, rC, wc, ONE, alpha, ONE, beta);
      }
   }
/*
 * Upper runs backwards: start from last (partial) colpan, go left.  This
 * allows col-major access on Upper, avoiding TLB problems on C access.
 * Within the panel, start at diag on bottom and go up.  This allows us to
 * use less A storage, as with lower.  
 */
   else /* if (TA == AtlasUpper) */
   {
      C += nnblks*incCn;
      A += nnblks*incAn;
      B = A;
      Mjoin(PATL,ammmK)(&mminf, nbF, nmuF, nbF, nnuF, nkblks, nb, kb0, KB0,
                        A, lda, incAk, B, lda, incAk, blk2c_b0, wC, nb,
                        wa, 0, wb, incw, rC, wc, ONE, alpha, ONE, ZERO);
      Mjoin(PATL,tradd)(Uplo, nbF, wC, nb, beta, C, ldc);
      if (ISHERK)
         Mjoin(PATLU,zero)(nbF, C+1, ldcp1);
      c = C - nb2;
      C -= incCn;
      A -= incAn;
      B -= incAn;
      ar = wa;
      for (i=0; i < nnblks; i++, c -= nb2, A -= incAn, ar += pansz)
         Mjoin(PATL,ammmK)(&mminf, nb, nmu, nbF, nnuF, nkblks, nb, kb0, KB0,
                           A, lda, incAk, B, lda, 0, blk2c, c, ldc,
                           ar, incw, wb, incw, rC, wc, ONE, alpha, ONE, beta);
      for (j=0; j < nnblks; j++, B -= incAn, C -= incCn, wa += pansz)
      {
         Mjoin(PATL,ammmK)(&mminf, nb, nmu, nb, nnu, nkblks, nb, kb0, KB0,
                           A, lda, 0, B, lda, incAk, blk2c_b0, wC, nb,
                           wa, incw, wb, incw, rC, wc, ONE, alpha, ONE, ZERO);
         Mjoin(PATL,tradd)(Uplo, nb, wC, nb, beta, C, ldc);
         if (ISHERK)
            Mjoin(PATLU,zero)(nb, C+1, ldcp1);
         c = C - nb2;
         ar = wa + pansz;
         for (i=j+1; i < nnblks; i++, c -= nb2, ar += pansz)
            Mjoin(PATL,ammmK)(&mminf, nb, nmu, nb, nnu, nkblks, nb, kb0, KB0,
                              A, lda, 0, B, lda, 0, blk2c, c, ldc, ar, incw,
                              wb, incw, rC, wc, ONE, alpha, ONE, beta);
      }
   }
   return(0);
}
#ifndef TCPLX
   #undef ONE
   #undef ZERO
   #undef rC
   #undef incw2
#endif
