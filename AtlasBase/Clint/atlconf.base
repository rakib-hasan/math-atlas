@extract -b @(topd)/gen.inc what=crsetup
@ROUT GetFlags
/*
 * Defined some macros for checking booleans passed by -Si
 */
#define SI_FKO 0
#define SI_BOZOL1 1
#define SI_ARCHDEF 2
#define SI_IEEE 3
#define SI_LATUNE 4
#define SI_NOF77  5
#define SI_NOCYGWIN 6
#define SI_OMP 6
#define SI_LAREF 7
#define SI_ADCLOSEP 8
#define SI_SKPTHRCHK 9
#define SI_IS_TRUE(bv_, b_) (((bv_)>>(b_))&1)
#define SI_SET_BIT(bv_, b_) (bv_) |= 1 << (b_)
#define SI_UNSET_BIT(bv_, b_) (bv_) &= ~(1 << (b_))

   @ifdef allflags
      @define -t @-t@
      @define -t2 @-t2@
      @define -t3 @-t3@
      @define -r  @-r@
      @define -O @-O@
      @define -s @-s@
      @define -A @-A@
      @define -V @-V@
      @define -O @-O@
      @define -b @-b@
      @define -o @-o@
      @define -C @-C@
      @define -Cg @-Cg@
      @define -D @-D@
      @define -d @-d@
      @define -ad @-ad@
      @define -f @-f@
      @define -lapackref @-lapackref@
@skip      @define -LAsrc @-LAsrc@
      @define -ADd @-ADd@
      @define -gcc3 @-gcc3@
      @define -S @-S@
      @define -m @-m@
      @define -nof77 @-nof77@
      @define -pmake @-pmake@
      @define -flapack @-flapack@
      @define -f77lib @-f77lib@
      @define -maflags @-maflags@
      @define -fko @-fko@
   @endifdef
void PrintUsage(char *name, int iarg, char *arg)
{
   fprintf(stderr, "\nERROR around arg %d (%s).\n", iarg, 
           arg ? arg : "unknown");
   fprintf(stderr, "USAGE: %s [flags] where flags are:\n", name);
   fprintf(stderr, "   -v <verb> : verbosity level\n");
@ifdef -O
   fprintf(stderr, "   -O <enum OSTYPE #>  : set OS type\n");
@endifdef
@ifdef -s
   fprintf(stderr, "   -s <enum ASMDIA #>  : set assembly dialect\n");
@endifdef
@ifdef -A
   fprintf(stderr, "   -A <enum MACHTYPE #> : set machine/architecture\n");
@endifdef
@ifdef -V
   fprintf(stderr, 
   "   -V #    # = ((1<<vecISA1) | (1<<vecISA2) | ... | (1<<vecISAN))\n");
@endifdef
@ifdef -b
   fprintf(stderr, "   -b <32/64> : set pointer bitwidth\n");
@endifdef
@ifdef -o
   fprintf(stderr, "   -o <outfile>\n");
@endifdef
@ifdef -C
   fprintf(stderr, "   -C [xc,ic,if,sk,dk,sm,dm,al,ac] <compiler>\n");
   fprintf(stderr, "   -F [xc,ic,if,sk,dk,sm,dm,al,ac,gc] '<comp flags>'\n");
   fprintf(stderr,    /* HERE */
           "   -Fa [xc,ic,if,sk,dk,sm,dm,al,ac,gc] '<comp flags to append>'\n");
   fprintf(stderr, "        al: append flags to all compilers\n");
   fprintf(stderr, "        ac: append flags to all C compilers\n");
   @ifdef -Cg
   fprintf(stderr, "        gc: append flags to gcc compiler used in user-contributed index files.\n");
   fprintf(stderr, "        acg: append to all C compilers & the index gcc\n");
   fprintf(stderr, "        alg: append to all compilers & the index gcc\n");
   @endifdef
   fprintf(stderr, 
      "   -T <targ> : ssh target for cross-compilation (probably broken)\n");
@endifdef
@ifdef -D
   fprintf(stderr, "   -D [c,f] -D<mac>=<rep> : cpp #define to add to [CDEFS,F2CDEFS]\n");
   fprintf(stderr, 
   "      eg. -D c -DL2SIZE=8388604 -D f -DADD__ -D f -DStringSunStyle\n");
@endifdef
@ifdef -d
   @ifdef ! -d2
   fprintf(stderr, "   -d [s,b]  : set source/build directory\n");
   @endifdef
   @ifdef -d2
   fprintf(stderr, "   -d [s,b,ms,md,ks,kd] <directory>  : set directory\n");
   fprintf(stderr, "      [s,b] : source/build directory\n");
   fprintf(stderr, 
   "      [ms,md] : single & double precision matmul archdef directory\n");
   fprintf(stderr, 
       "      [ks,kd] : single & double precision kernel archdef directory\n");
   @endifdef
@endifdef
@ifdef -f
   fprintf(stderr, "   -f <#> : size (in KB) to flush before timing\n");
@endifdef
@ifdef -t
   fprintf(stderr, 
           "   -t <#> : set # of threads (-1: autodect; 0: no threading)\n");
@endifdef
@ifdef -t3
   fprintf(stderr, 
           "   -tl <#> <list> : set # of threads, use list of affinity IDs\n");
@endifdef
@ifdef -r
   fprintf(stderr, 
           "   -r <#>: set the number of floating point registers to #\n");
@endifdef
@ifdef -m
   fprintf(stderr, "   -m <mhz> : set clock rate\n");
@endifdef
@ifdef -S
   fprintf(stderr, "   -S[i/s] <handle> <val>  : special int/string arg\n");
   @ifdef -ad
   fprintf(stderr, 
           "      -Si bozol1 <0/1> : supress/enable bozo L1 defaults\n");
   fprintf(stderr, 
           "      -Si archdef <1/0> : enable/supress arch default use\n");
   fprintf(stderr, 
"      -Si ieee <1/0> : dis/allow optimizations that break IEEE FP standard\n");
   fprintf(stderr, 
           "          (eg., NEON, 3DNow!)\n");
   fprintf(stderr, 
           "      -Si latune <1/0> : do/don't tune F77 LAPACK routines\n");
   @endifdef
   @ifdef -nof77
      fprintf(stderr, 
        "      -Si nof77 <0/1> : Have/don't have fortran compiler\n");
   @endifdef
   @ifdef -nocygwin
      fprintf(stderr, 
        "      -Si nocygwin <0/1> : Do/don't depend on GPL cygwin library\n");
      fprintf(stderr, 
        "                           (Windows compiler/cygwin install only)\n");
   @endifdef
   @ifdef -thrchk
/* Disabled due to abuse
      fprintf(stderr, 
        "      -Si cputhrchk <0/1> : Ignore/heed CPU throttle probe\n");
 */
   @endifdef
   @ifdef -t2
      fprintf(stderr, 
        "      -Si omp <0/1> : don'tuse/use OpenMP for threading\n");
#if 0
      fprintf(stderr,
"      -Si antthr <0/1/2> : nobuild/build/use Antoine's code for threading\n");
#endif
   @endifdef
   @ifdef -lapackref
      fprintf(stderr, 
              "      -Si lapackref <0/1>: Netlib lapack is not/is unpacked\n");
      fprintf(stderr, "                           to $BLDdir/src/lapack/ref\n");
   @endifdef
   @ifdef -gcc3
   fprintf(stderr, 
        "      -Ss kern <path/to/comp> : use comp for all kernel compilers\n");
   @endifdef
   @ifdef -LAsrc
   fprintf(stderr, 
      "      -Ss LAsrc <path/to/LAPACK/SRC> : Build full LAPACK using this\n");
   fprintf(stderr, 
      "                directory's LAPACK routines (must be in F77)\n");
   @endifdef
   @ifdef -ADd
   fprintf(stderr, 
      "      -Ss ADdir <path/to/archdefs> : Get archdefs frm custom path\n");
   @endifdef
   @ifdef -pmake
   fprintf(stderr, 
        "      -Ss pmake <parallel make invocation (eg '$(MAKE) -j 4')>\n");
   @endifdef
   @ifdef -f77lib
   fprintf(stderr, 
"      -Ss f77lib <path to f77 lib needed by C compiler>\n");
   @endifdef
   @ifdef -flapack
   fprintf(stderr, 
"      -Ss flapack <path to netlib lapack>: used to build full lapack lib\n");
   @endifdef
   @ifdef -maflags
   fprintf(stderr, "      -Ss [s,d]maflags 'flags'\n");
   @endifdef
@endifdef
   fprintf(stderr, 
      "NOTE: enum #s can be found by : make xprint_enums ; ./xprint_enums\n");
   exit(iarg);
}

void GetFlags(int nargs,                /* nargs as passed into main */
              char **args,              /* args as passed into main */
              int *verb,                /* verbosity setting */
   @define iflag @v@
   @define ivar  @verb@
@ifdef -O
   @define iflag @O@
   @define ivar  @OS@
              enum OSTYPE *OS,          /* OS to assume */
@endifdef
@ifdef -s
   @define iflag @s@
   @define ivar  @asmb@
              enum ASMDIA *asmb,        /* assembly dialect to assume */
@endifdef
@ifdef -V
   @define iflag @V@
   @define ivar  @vec@
              int *vec,                 /* Vector ISA extension bitfield */
@endifdef
@ifdef -A
@skip   @define iflag @A@
@skip   @define ivar  @mach@
              enum MACHTYPE *mach,     /* machine/arch to assume */
@endifdef
@ifdef -m
   @define iflag @m@
   @define ivar  @mhz@
              int *mhz,                /* Clock rate in Mhz */
@endifdef
@ifdef -b
   @define iflag @b@
   @define ivar @ptrbits@
              int *ptrbits             /* # of bits in ptr: -32/32/64 */,
@endifdef
@ifdef -r
              int *NREGS,
@endifdef
@ifdef -t
@skip   @define iflag @t@
@skip   @define ivar @nthreads@
              int *nthreads,           /* # of threads */
   @ifdef -t3
              int **tids,              /* thread affinity ID list */
   @endifdef
@endifdef
@ifdef -C
              char **comps,
@endifdef
@ifdef -Cg
              char **gccflags,        /* append flags for user-contrib gcc */
@endifdef
@ifdef -o
              char **outfile,
@endifdef
@ifdef -d
              char **srcdir,          /* path to top of source directory */
              char **bindir,          /* path to top of binary directory */
@endifdef
@ifdef -S
              int *SIflag,
@endifdef
@ifdef -d2
              char **archdefs,
@endifdef
@ifdef -D
              char **f2cdefs,         /* F77-to-C interface defines */
              char **ecdefs,          /* extra cpp defines to add to CDEFS */
@endifdef
@ifdef -pmake
              char **pmake,           /* parallel make command */
@endifdef
@ifdef -flapack
              char **flapack,         /* netlib F77 LAPACK  */
@endifdef
@ifdef -maflags
              char **smaflags,       /* single prec muladd flags */
              char **dmaflags,       /* double prec muladd flags */
@endifdef
@ifdef -f77lib
              char **f77lib,         /* netlib F77 LAPACK  */
@endifdef
@ifdef -LAsrc
              char **LAsrc,          /* netlib F77 LAPACK  SRC directory */
@endifdef
@ifdef -ADd
              char **ADd,            /* ArchDef directory */
@endifdef
@ifdef -f
   @define iflag @f@
   @define ivar @flush@
              int *flush,             /* size in KB to flush */
@endifdef
   @define sflag @T@
   @define svar  @targ@
              char **targ             /* mach to ssh to*/
             )
{
   int i, k, k0, kn, DoInt;
   char *sp, *sp0;
@ifdef -gcc3
   char *gcc3=NULL;
@endifdef
@ifdef -D
   char *cdefs=NULL, *fdefs=NULL;
   char ln[1024];
@endifdef

   *verb = 0;
@ifdef -A
   *mach = MACHOther;
@endifdef
@ifdef -LAsrc
   *LAsrc = NULL;
@endifdef
@ifdef -ADd
   *ADd = NULL;
@endifdef
@ifdef -d
   *srcdir = *bindir = NULL;
@endifdef
@ifdef -r
    *NREGS = 0;
@endifdef
@ifdef -flapack
    *flapack = NULL;
@endifdef
@ifdef -f77lib
    *f77lib = NULL;
@endifdef
@ifdef -maflags
    *smaflags = *dmaflags = NULL;
@endifdef
@ifdef -m
    *mhz = 0;
@endifdef
@ifdef -d2
   for (i=0; i < NARDEF; i++)
      archdefs[i] = NULL;
@endifdef
@ifdef -o
   *outfile = NULL;
@endifdef
@whiledef svar
   *@(svar) = NULL;
   @define svar2 @@(svar)@
@endwhile
@whiledef svar2
   @define svar @@(svar2)@
@endwhile
@ifdef -C
   for (k=0; k < NCOMP*3; k++)
      comps[k] = NULL;
@endifdef
@ifdef -Cg
   *gccflags = NULL;
@endifdef

@whiledef ivar
   *@(ivar) = 0;
   @define ivar2 @@(ivar)@
@endwhile
@whiledef ivar2
   @define ivar @@(ivar2)@
@endwhile
@ifdef -S
   *SIflag = 0;
   SI_SET_BIT(*SIflag, SI_IEEE);
   SI_SET_BIT(*SIflag, SI_LATUNE);
   SI_SET_BIT(*SIflag, SI_ARCHDEF);
@endifdef
@ifdef -t
   *nthreads = -1;
@endifdef
@ifdef -t3
   *tids = NULL;
@endifdef
@ifdef -pmake
   *pmake = NULL;
@endifdef
   for (i=1; i < nargs; i++)
   {
      if (args[i][0] != '-')
         PrintUsage(args[0], i, args[i]);
      switch(args[i][1])
      {
@ifdef -r
      case 'r':
         if (++i >= nargs)
            PrintUsage(args[0], i, "out of arguments");
         *NREGS = atoi(args[i]);
         break;
@endifdef
@ifdef -t
      case 't':
         if (++i >= nargs)
            PrintUsage(args[0], i, "out of arguments");
         *nthreads = atoi(args[i]);
   @ifdef -t3
         if (args[i-1][2] == 'l')
         {
            *tids = malloc(*nthreads * sizeof(int));
            assert(*tids);
            for (k=0; k < *nthreads; k++)
            {
               if (++i >= nargs)
                  PrintUsage(args[0], i, "out of arguments");
               (*tids)[k] = atoi(args[i]);
            }
         }
   @endifdef
         break;
@endifdef
@ifdef -A
      case 'A':
         if (++i >= nargs)
            PrintUsage(args[0], i, "out of arguments");
         if(args[i][0] >= '0' && args[i][0] <= '9') /* giving a # */
            *mach = atoi(args[i]);
         else /* giving a architecture name */
         {
            for (k=1; k < NMACH; k++)
               if (!strcmp(args[i], machnam[k]))
                  break;
            *mach = (k == NMACH) ? 0 : k;
         }
         break;
@endifdef
@whiledef iflag
      case '@(iflag)':
         if (++i >= nargs)
            PrintUsage(args[0], i, "out of arguments");
         *@(ivar) = atoi(args[i]);
         break;
   @undef ivar
@endwhile
@whiledef sflag
      case '@(sflag)':
         if (++i >= nargs)
            PrintUsage(args[0], i, "out of arguments");
         *@(svar) = args[i];
         break;
   @undef svar
@endwhile
@ifdef -S
      case 'S':
         if (args[i][2] != 'i' && args[i][2] != 's')
            PrintUsage(args[0], i, "-S needs i or s suffix!");
         DoInt = args[i][2] == 'i';
         if (++i >= nargs)
            PrintUsage(args[0], i, "out of arguments");
         sp0 = args[i];
         if (++i >= nargs)
            PrintUsage(args[0], i, "out of arguments");
         if (DoInt)
            k = atoi(args[i]);
         else 
            sp = NewStringCopy(args[i]);
   @define else @@
   @ifdef -ad
         if (!strcmp(sp0, "archdef"))
         {
            if (k)
            {
               SI_SET_BIT(*SIflag, SI_ARCHDEF);
               if (k == 2)
                  SI_SET_BIT(*SIflag, SI_ADCLOSEP);
            }
            else
               SI_UNSET_BIT(*SIflag, SI_ARCHDEF);
         }
         else if (!strcmp(sp0, "ieee"))
         {
            if (k)
               SI_SET_BIT(*SIflag, SI_IEEE);
            else
               SI_UNSET_BIT(*SIflag, SI_IEEE);
         }
         else if (!strcmp(sp0, "bozol1"))
         {
            if (k)
               SI_SET_BIT(*SIflag, SI_BOZOL1);
            else
               SI_UNSET_BIT(*SIflag, SI_BOZOL1);
         }
         else if (!strcmp(sp0, "latune"))
         {
            if (k)
               SI_SET_BIT(*SIflag, SI_LATUNE);
            else
               SI_UNSET_BIT(*SIflag, SI_LATUNE);
         }
         @define else @else@
   @endifdef
   @ifdef -t2
         @(else) if (!strcmp(sp0, "omp"))
         {
            if (k)
               SI_SET_BIT(*SIflag, SI_OMP);
            else
               SI_UNSET_BIT(*SIflag, SI_OMP);
         }
         else if (!strcmp(sp0, "latune"))
         {
            if (k)
               SI_SET_BIT(*SIflag, SI_LATUNE);
            else
               SI_UNSET_BIT(*SIflag, SI_LATUNE);
         }
   @endifdef
   @ifdef -lapackref
         @(else) if (!strcmp(sp0, "lapackref"))
         {
            if (k)
               SI_SET_BIT(*SIflag, SI_LAREF);
            else
               SI_UNSET_BIT(*SIflag, SI_LAREF);
         }
   @endifdef
   @ifdef -fko
         @(else) if (!strcmp(sp0, "fko"))
         {
            if (k)
               SI_SET_BIT(*SIflag, SI_FKO);
            else
               SI_UNSET_BIT(*SIflag, SI_FKO);
         }
      @define else @else@
   @endifdef
   @ifdef -nof77
         @(else) if (!strcmp(sp0, "nof77"))
         {
            if (k)
               SI_SET_BIT(*SIflag, SI_NOF77);
            else
               SI_UNSET_BIT(*SIflag, SI_NOF77);
         }
      @define else @else@
   @endifdef
   @ifdef -nocygwin
         @(else) if (!strcmp(sp0, "nocygwin"))
         {
            if (k)
               SI_SET_BIT(*SIflag, SI_NOCYGWIN);
            else
               SI_UNSET_BIT(*SIflag, SI_NOCYGWIN);
         }
      @define else @else@
   @endifdef
   @ifdef -thrchk
         @(else) if (!strcmp(sp0, "cripple-perf"))
            if (k)
               SI_SET_BIT(*SIflag, SI_SKPTHRCHK);
            else
               SI_UNSET_BIT(*SIflag, SI_SKPTHRCHK);
      @define else @else@
   @endifdef
   @ifdef -gcc3
         @(else) if (!strcmp(sp0, "kern"))
            gcc3 = sp;
      @define else @else@
   @endifdef
   @ifdef -LAsrc
         @(else) if (!strcmp(sp0, "LAsrc") || !strcmp(sp0, "lasrc"))
            *LAsrc = sp;
      @define else @else@
   @endifdef
   @ifdef -ADd
         @(else) if (!strcmp(sp0, "ADdir") || !strcmp(sp0, "addir"))
            *ADd = sp;
      @define else @else@
   @endifdef
   @ifdef -pmake
         else if (!strcmp(sp0, "pmake"))
            *pmake = sp;
   @endifdef
   @ifdef -flapack
        @(else) if (!strcmp(sp0, "flapack"))
           *flapack = sp;
   @endifdef
   @ifdef -f77lib 
        @(else) if (!strcmp(sp0, "f77lib"))
           *f77lib = sp;
   @endifdef
   @ifdef -maflags
        @(else) if (!strcmp(sp0, "smaflags"))
           *smaflags = sp;
        else if (!strcmp(sp0, "dmaflags"))
           *dmaflags = sp;
   @endifdef
         else
            PrintUsage(args[0], i-1, sp0);
         break;
   @whiledef else
   @endwhile
@endifdef
@ifdef -o
      case 'o':
         if (++i >= nargs)
            PrintUsage(args[0], i, "out of arguments");
         *outfile = args[i];
         break;
@endifdef
@ifdef -D
      case 'D':
         if (++i >= nargs)
            PrintUsage(args[0], i, "out of arguments");
         if (++i >= nargs)
            PrintUsage(args[0], i, "out of arguments");
         if (args[i-1][0] == 'f')
            fdefs = NewAppendedString(fdefs, args[i]);
         else
            cdefs = NewAppendedString(cdefs, args[i]);
         break;
@endifdef
@ifdef -d
      case 'd':
         if (++i >= nargs)
            PrintUsage(args[0], i, "out of arguments");
         if (++i >= nargs)
            PrintUsage(args[0], i, "out of arguments");
         sp = args[i-1];
         if (*sp == 's')
            *srcdir = args[i];
         else if (*sp == 'b')
            *bindir = args[i];
   @ifdef -d2
         else if (*sp == 'm' && sp[1] == 's')
            archdefs[ADsm] = args[i];
         else if (*sp == 'm' && sp[1] == 'd')
            archdefs[ADdm] = args[i];
         else if (*sp == 'k' && sp[1] == 's')
            archdefs[ADsk] = args[i];
         else if (*sp == 'k' && sp[1] == 'd')
            archdefs[ADdk] = args[i];
         else
            PrintUsage(args[0], i-1, sp);
   @endifdef
         break;
@endifdef
@ifdef -C
      case 'C':
      case 'F':
         if (++i >= nargs)
            PrintUsage(args[0], i, "out of arguments");
         sp = args[i];
         k = -1;
         if (*sp == 'i' && sp[1] == 'c') k = ICC_;
         else if (*sp == 'g' && sp[1] == 'c') k = GCC_;
         else if (*sp == 'i' && sp[1] == 'f') k = F77_;
         else if (*sp == 's' && sp[1] == 'k') k = SKC_;
         else if (*sp == 'd' && sp[1] == 'k') k = DKC_;
         else if (*sp == 's' && sp[1] == 'm') k = SMC_;
         else if (*sp == 'd' && sp[1] == 'm') k = DMC_;
         else if (*sp == 'x' && sp[1] == 'c') k = XCC_;
         if (*sp == 'a' && (sp[1] == 'l' || sp[1] == 'c'))
         {  /* only appended flags can be applied to all compilers */
            const int SKIPGCC=(sp[2] != 'g'), SKIPF=(sp[1] == 'c');
@skip            if (args[i-1][1] != 'F') PrintUsage(args[0], i, args[i]);
@skip            if (args[i-1][2] != 'a') PrintUsage(args[0], i, args[i]);
            if (args[i-1][1] == 'F') 
            {
               if (args[i-1][2] == 'a')
               {
                  k0 = NCOMP+NCOMP;
                  kn = k0 + NCOMP;
               }
               else
               {
                  k0 = NCOMP;
                  kn = NCOMP+NCOMP;
               }
            }
            else
            {
               k0 = 0;
               kn = NCOMP;
            }
            if (++i >= nargs)
               PrintUsage(args[0], i, "out of arguments");
            for (k=k0; k < kn; k++)
               if ((!SKIPF || k-k0 != F77_) && (!SKIPGCC || k-k0 != GCC_))
                  comps[k] = args[i];
@ifdef -Cg
            if (sp[2] == 'g' && args[i-2][1] == 'F')
               *gccflags = args[i];
@endifdef
         }
@ifdef -Cg
         else if (*sp == 'g' && sp[1] == 'c')
         {
            if (++i >= nargs)
               PrintUsage(args[0], i, "out of arguments");
            if (args[i-2][1] == 'C')
               comps[k] = args[i];
            else
               *gccflags = args[i];
         }
@endifdef
         else
         {
            if (k < 0) PrintUsage(args[0], i, args[i]);
            if (args[i-1][1] == 'F') 
            {
               k += NCOMP;
               if (args[i-1][2] == 'a') 
                  k += NCOMP;
            }
            if (++i >= nargs)
               PrintUsage(args[0], i, "out of arguments");
            comps[k] = args[i];
         }
         break;
@endifdef
      default:
         PrintUsage(args[0], i, args[i]);
      }
   }
@ifdef -C
/* 
 * allocate these strings ourselves so we can free them later if necessary
 */
   for (i=0; i < 3*NCOMP; i++)
   {
      if (comps[i])
      {
         if (!strcmp(comps[i], "default"))
            comps[i] = NULL;
         else
         {
            sp = malloc(sizeof(char)*(strlen(comps[i])+1));
            strcpy(sp, comps[i]);
            comps[i] = sp;
         }
      }
   }
@endifdef
@ifdef -gcc3
/*
 * If the special flag -Ss gcc3 is thrown, force gcc3's use for all kernel
 * compilers (standard gcc assumed to be gcc4)
 */
   if (gcc3)
   {
      for (i=0; i < NCOMP; i++)
      {
         if (!comps[i] && (i == SMC_ || i == DMC_ || i == SKC_ || i == DKC_))
            comps[i] = NewStringCopy(gcc3);
      }
   }
@endifdef
@ifdef -D
   *f2cdefs = fdefs;
   *ecdefs = cdefs;
@endifdef
@ifdef -b
   if (*ptrbits != 32 && *ptrbits != -32 && *ptrbits != 64)
      *ptrbits = 0;
@endifdef
}
@endextract
@ROUT atlconf.h
#ifndef ATLCONF_H
   #define ATLCONF_H

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>

#define NOS 13
static char *osnam[NOS] = 
   {"UNKNOWN", "Linux", "SunOS", "SunOS4", "OSF1", "IRIX", "AIX", 
    "Win9x", "WinNT", "Win64", "HPUX", "FreeBSD", "OSX"};
enum OSTYPE {OSOther=0, OSLinux, OSSunOS, OSSunOS4, OSOSF1, OSIRIX, OSAIX,
             OSWin9x, OSWinNT, OSWin64, OSHPUX, OSFreeBSD, OSOSX};
#define OSIsWin(OS_) ( ((OS_) == OSWinNT) || ((OS_) == OSWin9x) || \
                       ((OS_) == OSWin64) )

enum ARCHFAM {AFOther=0, AFPPC, AFSPARC, AFALPHA, AFX86, AFIA64, AFMIPS, 
              AFARM, AFS390};

/*
 * Corei1: Nahalem / Westmere
 * Corei2: ivy bridge, sandy bridge: AVX
 * Corei3: haswell: AVXMAC
 * Corei3EP: v3 Haswell, E5-26XX
 * Corei4 : skylake
 */
#define NMACH 65
static char *machnam[NMACH] = 
   {"UNKNOWN","PPCG4", "PPCG5", "POWER3", "POWER4", "POWER5", 
    "POWER6", "POWER7", "POWER8", "POWERe6500", 
    "IBMz9", "IBMz10", "IBMz196", "IBMz12","IBMz13",
    "x86x87", "x86SSE1", "x86SSE2", "x86SSE3",
    "P5", "P5MMX", "PPRO", "PII", "PIII", "PM", "CoreSolo", 
    "CoreDuo", "Core2Solo", "Core2", "Corei1", "Corei2", "Corei3", "Corei3EP",
    "Corei4", "Atom", "P4", "P4E", 
    "Efficeon", "K7", "HAMMER", "AMD64K10h", "AMDLLANO", "AMDDOZER","AMDDRIVER",
    "UNKNOWNx86", "IA64Itan", "IA64Itan2",
    "USI", "USII", "USIII", "USIV", "UST1", "UST2", "UnknownUS", 
    "MIPSR1xK", "MIPSICE9", "ARMa7", 
    "ARMa9", "ARMa15", "ARMa17", 
    "ARM64xgene1", "ARM64a53", "ARM64a57",
    "TI_C66_BM", "XeonPHI"};
enum MACHTYPE {MACHOther, PPCG4, PPCG5, IbmPwr3, IbmPwr4, IbmPwr5, 
               IbmPwr6, IbmPwr7, IbmPwr8, Pwre6500,
               IbmZ9, IbmZ10, IbmZ196, IbmZ12, IbmZ13, /* s390(x) in Linux */
               x86x87, x86SSE1, x86SSE2, x86SSE3, /* generic targets */
               IntP5, IntP5MMX, IntPPRO, IntPII, IntPIII, IntPM, IntCoreS,
               IntCoreDuo, IntCore2Solo, IntCore2, IntCorei1, IntCorei2,
               IntCorei3, IntCorei3EP, IntCorei4, IntAtom, IntP4, IntP4E, TMEff,
               AmdAthlon, AmdHammer, Amd64K10h, AmdLlano, AmdDozer, AmdDriver, 
               x86X, IA64Itan, IA64Itan2,
               SunUSI, SunUSII, SunUSIII, SunUSIV, SunUST1, SunUST2, SunUSX, 
               MIPSR1xK, /* includes R10K, R12K, R14K, R16K */
               MIPSICE9,  /* SiCortex ICE9 -- like MIPS5K */
@skip               ARMv7,     /* includes Cortex A8, A9 */
               ARM7,      /* odroid-little */
               ARM9,      /* pandaboard */
               ARM15,     /* tegra, odroid-big */
               ARM17,     /* lots of tablets */
               ARM64xg,   /* includes ARMv8 */
               ARM64a53, 
               ARM64a57,
               TI_C66_BM, /* TI accelerator */
               IntPhi     /* build for XEON Phi */
               };
#define MachIsX86(mach_) \
   ( (mach_) >= x86x87 && (mach_) <= x86X )
#define MachIsPWR(mach_) \
   ( (mach_) >= IbmPwr3 && (mach_) <= Pwre6500 )
#define MachIsIA64(mach_) \
   ( (mach_) >= IA64Itan && (mach_) <= IA64Itan2 )
#define MachIsUS(mach_) \
   ( (mach_) >= SunUSI && (mach_) <= SunUSX )
#ifdef __mips__
   #define MachIsMIPS(mach_) \
      ( (__mips__) || (mach_) >= MIPSR1xK && (mach_) <= MIPSICE9 )
#else
   #define MachIsMIPS(mach_) \
      ( (mach_) >= MIPSR1xK && (mach_) <= MIPSICE9 )
#endif
#define MachIsPPC(mach_) \
   ( (mach_) >= PPCG4 && (mach_) <= PPCG5 )
#define MachIsARM(mach_) \
   ( (mach_) >= ARM7 && (mach_) <= ARM17 )
#define MachIsARM64(mach_) \
   ( (mach_) >= ARM64xg && (mach_) <= ARM64a57 )
#define MachIsS390(mach_) \
   ( (mach_) >= IbmZ9 && (mach_) <= IbmZ13 )


static char *f2c_namestr[5] = {"UNKNOWN","Add_", "Add__", "NoChange", "UpCase"};
static char *f2c_intstr[5] =
       {"UNKNOWN", "F77_INTEGER=int", "F77_INTEGER=long", 
        "F77_INTEGER=\"long long\"", "F77_INTEGER=short"};
static char *f2c_strstr[5]=
       {"UNKNOWN", "SunStyle", "CrayStyle", "StructVal", "StructPtr"};

enum F2CNAME {f2c_NamErr=0, f2c_Add_, f2c_Add__, f2c_NoChange, f2c_UpCase};
enum F2CINT {f2c_IntErr=0, FintCint, FintClong, FintClonglong, FintCshort};
enum F2CSTRING {f2c_StrErr=0, fstrSun, fstrCray, fstrStructVal, fstrStructPtr};

#define NISA 16
static char *ISAXNAM[NISA] = 
   {"", "VSX", "VXZ", "AltiVec", "AVXZ",
    "AVXMAC", "AVXFMA4", "AVX", "SSE3", "SSE2", "SSE1", "3DNow", 
    "FPV3D2MACNEON", "FPV3D16MACNEON", "FPV3D32MAC", "FPV3D16MAC"};
enum ISAEXT 
   {ISA_None=0, ISA_VSX, ISA_VXZ, ISA_AV, ISA_AVXZ,
    ISA_AVXMAC, ISA_AVXFMA4, ISA_AVX, ISA_SSE3, ISA_SSE2, ISA_SSE1, ISA_3DNow, 
    ISA_NEON, ISA_NEON16, ISA_VFP3D32MAC, ISA_VFP3D16MAC};

@ROUT atlconf.h asmconf.h
#define NASMD 11
enum ASMDIA 
   {ASM_None=0, gas_x86_32, gas_x86_64, gas_sparc, gas_ppc, gas_parisc, 
    gas_mips, gas_arm, gas_arm64, gas_wow64, gas_s390};
static char *ASMNAM[NASMD] =
   {"",     "GAS_x8632", "GAS_x8664", "GAS_SPARC", "GAS_PPC", "GAS_PARISC",
    "GAS_MIPS", "GAS_ARM", "GAS_ARM64", "GAS_WOW64", "GAS_S390"};
@ROUT atlconf.h

/*
 * Used for archinfo probes (can pack in bitfield)
 */
enum WHATPROBE{Parch=1, P64=2, Pncpu=4, Pverb=8, Pncache=16, PCacheSize=32,
               PMhz=64, Pthrottle=128};

#define NARDEF 4
enum ARDEF{ADsk=0, ADdk, ADsm, ADdm};  /* m = matmul kernel, k = non-mm kern */
/*
 * Used for all the compilers ATLAS needs
 */
#define NCOMP 8
static char *COMPNAME[NCOMP]={"ICC","SMC","DMC","SKC","DKC","XCC","GCC","F77"};
#define ICC_ 0   /* Compiles non-computation routines, and all I/O */
#define SMC_ 1   /* single prec matmul compiler */
#define DMC_ 2   /* double prec matmul compiler */
#define SKC_ 3   /* single prec computation compiler (non-mm kernels) */
#define DKC_ 4   /* double prec computation compiler */
#define XCC_ 5   /* Compiler for frontend of cross-compilation */
#define GCC_ 6
#define F77_ 7   /* Valid fixed-format Fortran77 compiler */

typedef struct CompNode COMPNODE;
struct CompNode
{
   int priority;              /* priority of this definition */
   int comps[1];              /* bitfield: (1<<ICC)|...|(1<<F77) */
   int OS[(NOS+31)/32];       /* bitfield for OS */
   int arch[(NMACH+31)/32];   /* bitfields for architecture */
   char *comp, *flags;        /* compiler & flags as strings */
   COMPNODE *next;
};
#include "atlconf_misc.h"

#endif
@ROUT print_enums
#include "atlconf.h"

void BarfOutArchs(FILE *fpout, int ibeg, int iend)
{
   int i;

   assert(ibeg < NMACH && ibeg >= 0);
   assert(iend < NMACH && iend >= 0);
   if (ibeg == iend)
      fprintf(fpout, "\nMACHTYPE %d = '%s'\n", ibeg, machnam[ibeg]);
   else
   {
      fprintf(fpout, "Architectural enums (Config's enum MACHTYPE):\n");
      for (i=ibeg; i <= iend; i++)
         fprintf(fpout, "   %3d = '%s'\n", i, machnam[i]);
      fprintf(fpout, "\n");
   }
}

void BarfOutOSs(FILE *fpout, int ibeg, int iend)
{
   int i;

   assert(ibeg < NOS && ibeg >= 0);
   assert(iend < NOS && iend >= 0);
   if (ibeg == iend)
      fprintf(fpout, "\nOSTYPE %d = '%s'\n", ibeg, osnam[ibeg]);
   else
   {
      fprintf(fpout, "Operating System enums (Config's enum OSTYPE):\n");
      for (i=ibeg; i <= iend; i++)
         fprintf(fpout, "   %3d = '%s'\n", i, osnam[i]);
      fprintf(fpout, "\n");
   }
}

void BarfOutComps(FILE *fpout, int ibeg, int iend)
{
   int i;

   assert(ibeg < NCOMP && ibeg >= 0);
   assert(iend < NCOMP && iend >= 0);
   if (ibeg == iend)
      fprintf(fpout, "\nCOMPTYPE %d = '%s'\n", ibeg, COMPNAME[ibeg]);
   else
   {
      fprintf(fpout, "Compiler integer defines:\n");
      for (i=ibeg; i <= iend; i++)
         fprintf(fpout, "   %3d = '%s'\n", i, COMPNAME[i]);
      fprintf(fpout, "\n");
   }
}

void BarfOutISAs(FILE *fpout)
{
   int i;

   fprintf(fpout,
"\nISA extensions are combined by adding their values together (bitvector):\n");

   fprintf(fpout, "   %10s: %d\n", "none", 1);
   for (i=1; i < NISA; i++)
      fprintf(fpout, "   %10s: %d\n", ISAXNAM[i], 1<<i);
   fprintf(fpout, "\n");
}

void PrintUsage(char *name, int i)
{
   fprintf(stderr, "Error in arg %d, USAGE:\n", i);
   fprintf(stderr, 
"   %s [-a (archs)] [-o (OSes)] [-A ibeg iend] [-O ibeg iend] [-i (ISAext)\n",
           name);
   exit(i);
}

void GetFlags(int nargs, char **args, int *DoArch, int *abeg, int *aend, 
              int *DoOS, int *osbeg, int *osend, 
              int *DoComps, int *cbeg, int *cend, int *DoISA)
{
   int i, usrargs=0;

   *DoISA = *DoArch = *DoOS = *DoComps = 0;
   *abeg = 0;
   *aend = NMACH-1;
   *osbeg = 0;
   *osend = NOS-1;
   *cbeg = 0;
   *cend = NCOMP-1;
   for (i=1; i < nargs; i++)
   {
      if (args[i][0] != '-')
         PrintUsage(args[0], i);
      switch(args[i][1])
      {
      case 'a':
         *DoArch = usrargs = 1;
         break;
      case 'o':
         *DoOS = usrargs = 1;
         break;
      case 'c':
         *DoComps = usrargs = 1;
         break;
      case 'i':
         *DoISA = usrargs = 1;
         break;
      case 'C':
         if (++i >= nargs)
            PrintUsage(args[0], i);
         *cbeg = atoi(args[i]);
         if (++i >= nargs)
            PrintUsage(args[0], i);
         *cend = atoi(args[i]);
         usrargs = *DoComps = 1;
         break;
      case 'A':
         if (++i >= nargs)
            PrintUsage(args[0], i);
         *abeg = atoi(args[i]);
         if (++i >= nargs)
            PrintUsage(args[0], i);
         *aend = atoi(args[i]);
         usrargs = *DoArch = 1;
         break;
      case 'O':
         if (++i >= nargs)
            PrintUsage(args[0], i);
         *osbeg = atoi(args[i]);
         if (++i >= nargs)
            PrintUsage(args[0], i);
         *osend = atoi(args[i]);
         usrargs = *DoOS = 1;
         break;
      default:
         PrintUsage(args[0], i);
      }
   }
   if (!usrargs)
      *DoISA = *DoArch = *DoOS = *DoComps = 1;
}

int main(int nargs, char **args)
{
   int DoArch, abeg, aend, DoOS, osbeg, osend, DoComp, cbeg, cend, DoISA;

   GetFlags(nargs, args, &DoArch, &abeg, &aend, &DoOS, &osbeg, &osend,
            &DoComp, &cbeg, &cend, &DoISA);

   fprintf(stdout, "\n");
   if (DoArch)
      BarfOutArchs(stdout, abeg, aend);
   if (DoOS)
      BarfOutOSs(stdout, osbeg, osend);
   if (DoComp)
      BarfOutComps(stdout, cbeg, cend);
   if (DoISA)
      BarfOutISAs(stdout);
   return(0);
}
@ROUT IsGcc
@extract -b @(topd)/cw.inc lang=c -define cwdate 2011
#include <stdio.h>
#include <assert.h>
#include "atlconf_misc.h"
void PrintUsage(char *name, int iarg, char *flag)
{
   fprintf(stderr, "Unknown flag '%s' in position %d!\n", flag, iarg);
   fprintf(stderr, "USAGE: [-l <lvl>] <gcc candidate>\n");
   exit(iarg);
}
int main(int nargs, char **args)
{
   int lvl=0;  /* 0: is gcc, 1: is gcc 4 but not apple gcc 2: gcc 4.x, with x >= 4 */
   int i;
   char *comp=NULL;
   for (i=1; i < nargs; i++)
   {
      if (args[i][0] == '-')
      {
         if (args[i][1] == 'l')
	 {
	    if (++i >= nargs)
	       PrintUsage(args[0], i, "out of arguments");
	    lvl = atoi(args[i]);
	 }
	 else
	    PrintUsage(args[0], i, args[i]);
      }
      else
         comp = args[i];
   }
   assert(comp);
   if (!CompIsGcc(comp))
      return(1);
   if (lvl)
   {
      int icmp, major, minor, patch;

      GetGccVers(comp, &icmp, &major, &minor, &patch);
      #if 0
         fprintf(stderr, "comp='%s': cmp=%d, major=%d, minor=%d, patch=%d\n", 
	         comp, icmp, major, minor, patch);
      #endif
      if (icmp || major < 4)
         return(2);
      if (lvl > 1)
         if (minor < 4)
	    return(3);
   }
   printf("%s\n", comp);
   return(0);
}
@ROUT atlconf_misc
@extract -b @(topd)/gen.inc what=cw @(cw98)
#include "atlconf.h"
#include "atlconf_misc.h"

@extract -b @(incd)/query.inc

char *ATL_fgetln(FILE *fpin)
/*
 * RETURNS: dynamically allocates string containing a line from fpin, regardless
 *          of how long that line is; RETURNS NULL if EOF
 */
{
   char *ln, *sp;
   int len=128, i;
   ln = malloc(len*sizeof(char));
   assert(ln);
   if (!fgets(ln, len, fpin))
      return(NULL);
   i = strlen(ln);
/*
 * Keep extending lnlen and reading in more chars until \n is found
 */
   while (ln[i-1] != '\n')
   {
      char *ln2;
      len <<= 1;
      ln2 = malloc(len*sizeof(char));
      assert(ln2);
      strcpy(ln2, ln);
      free(ln);
      ln = ln2;
      if (!fgets(ln+i, len-i, fpin))
         return(ln);
      i += strlen(ln+i);
   }
   return(ln);
}

int fNumLines(char *fnam)
{
   FILE *fp;
   char ln[256];
   int i;

   fp = fopen(fnam, "r");
   assert(fp != NULL);
   for (i=0; fgets(ln, 256, fp); i++);
   return(i);
}

@ROUT atlar
char *CmndResultsNoErr(char *targ, char *cmnd)
{
   static char tnam[128];
   static int FirstTime=1;
   char ln[8196];

   if (FirstTime)
   {
      FirstTime = 0;
      assert(tmpnam(tnam));
   }
   if (targ) sprintf(ln, "ssh %s \"%s\" > %s 2>/dev/null \n", targ, cmnd, tnam);
   else sprintf(ln, "%s > %s 2>/dev/null\n", cmnd, tnam);
   system(ln); 
   return(tnam);
}
char *CmndResults(char *targ, char *cmnd)
{
   static char tnam[128];
   static int FirstTime=1;
   char ln[8196];

   if (FirstTime)
   {
      FirstTime = 0;
      assert(tmpnam(tnam));
   }
   if (targ) sprintf(ln, "ssh %s \"%s\" > %s 2>&1 \n", targ, cmnd, tnam);
   else sprintf(ln, "%s > %s 2>&1\n", cmnd, tnam);
   if (!system(ln)) return(tnam);
   return(NULL);
}

int CmndOneLine(char *targ, char *cmnd, char *ln)
/*
 * executes a system call with contents of cmnd, returns the output in ln;
 * Returns value returned by system call
 * if targ is set, we ssh to that machine
 */
{
   int i;
   FILE *fp;
   char *tnam;

   ln[0] = '\0';
   tnam = CmndResults(targ, cmnd);
   if (tnam)
   {
      fp = fopen(tnam, "r");
      assert(fp);
      if (!fgets(ln, 2048, fp)) ln[0] = '\0';
      fclose(fp);
      return(0);
   }
   else ln[0] = '\0';
   return(1);
}
@ROUT atlconf_misc atlar findgcc

int GetIntBeforeWord(char *word, char *ln)
/* 
 * Finds integer before word in sentence.  
 * RETURNS: integer on success, BADINT on failure
 */
{
   char *sp;
   sp = strstr(ln, word);
   if (sp == ln) return(BADINT);
   sp--;
   while(isspace(*sp) && sp != ln) sp--;
   if (sp == ln) return(BADINT);
   while (isdigit(*sp) && sp != ln) sp--;
   if (sp == ln) return(BADINT);
   return(atoi(sp));
}

@ROUT atlconf_misc
int GetScreenHeight()
/* 
 * Returns the number of vertical lines window has
 */
{
   int i;
   for (i=160; i; i--) fprintf(stdout, "%03d\n", i);
   i = GetIntRange(0, 0, 160, "", "number at top left of screen");
   return(i);
}

void GetEnter(FILE *fpout)
{
   char ln[128];
   fprintf(fpout, "---------- PRESS ENTER TO CONTINUE ---------- ");
   assert(fgets(ln, 128, stdin));
}

int DisplayFile(char *fnam, FILE *fpout, int nlines)
{
   FILE *fp;
   char ln[256];
   int i, GoOn=1;

   fp = fopen(fnam, "r");
   if (fp == NULL)
   {
      fprintf(stderr, "Unable to open file '%s', continuing without display.\n",
              fnam);
      return(-1);
   }
   if (nlines)
   {
@skip      nlines--;
      do
      {
         for (i=0; i < nlines; i++)
         {
            GoOn = (fgets(ln, 256, fp) != NULL);
            if (!GoOn) break;
            fprintf(fpout, "%s", ln);
         }
         if (GoOn) GetEnter(stdout);
         else break;
      }
      while(GoOn);
   }
   else while (fgets(ln, 256, fp)) fprintf(fpout, "%s", ln);
   i = ferror(fp);
   fclose(fp);
   return(i);
}

int DisplayFile0(char *fnam, FILE *fpout)
{
   FILE *fp;
   char ln[256];
   int i;

   fp = fopen(fnam, "r");
   if (fp == NULL)
   {
      fprintf(stderr, "Unable to open file '%s', continuing without display.\n",
              fnam);
      return(-1);
   }
   while (fgets(ln, 256, fp)) fprintf(fpout, "%s", ln);
   i = ferror(fp);
   fclose(fp);
   return(i);
}

int FoundInFile(char *fnam, char *str)
{
   FILE *fp;
   int found=0;
   char ln[256];

   fp = fopen(fnam, "r");
   assert(fp);
   while (fgets(ln, 256, fp))
   {
      if (strstr(ln, str))
      {
         found=1;
         break;
      }
   }
   fclose(fp);
   return(found);
}

char *FindUname(char *targ)
{
   static int FirstTime=1;
   static char unam[64];
   static char unamT[6];
   if (FirstTime)
   {
      if (FileIsThere("/bin/uname")) strcpy(unam, "/bin/uname");
      else if (FileIsThere("/usr/bin/uname")) strcpy(unam, "/usr/bin/uname");
      else strcpy(unam, "uname");
      strcpy(unamT, "uname");
      FirstTime = 0;
   }
   if (targ && targ[0] != '\0')
      return(unamT);
   return(unam);
}

enum ARCHFAM ProbeArchFam(char *targ)
/*
 * Tries to guess broad architectural family using uname
 */
{
   enum ARCHFAM fam=AFOther;
   char *cmnd, *res;
   char *uname;
   int i;

   uname = FindUname(targ);
   i = strlen(uname) + 4;

   cmnd = malloc(i*sizeof(char));
   assert(cmnd);
   sprintf(cmnd, "%s -m", uname);
   res = atlsys_1L(targ, cmnd, 0, 0);
   if (res)
   {
      if (strstr(res, "ppc") || strstr(res, "Power Macintosh") ||
          strstr(res, "powerpc")) fam = AFPPC;
      else if (strstr(res, "sparc")) fam = AFSPARC;
      else if (strstr(res, "alpha")) fam = AFALPHA;
      else if (strstr(res, "ia64")) fam = AFIA64;
      else if (strstr(res, "mips")) fam = AFMIPS;
      else if (strstr(res, "arm")) fam = AFARM;
      else if (strstr(res, "aarch64")) fam = AFARM;
      else if (strstr(res, "s390")) fam = AFS390;
      else if ( strstr(res, "i686") || strstr(res, "i586") ||
                strstr(res, "i486") || strstr(res, "i386") ||
                strstr(res, "x86") || strstr(res, "x86_64")  ||
                strstr(res, "k1om")
               ) fam = AFX86;
      free(res);
   }
/*
 * Try uname -p if uname -m didn't work
 */
   if (fam == AFOther)
   {
      sprintf(cmnd, "%s -p", uname);
      res = atlsys_1L(targ, cmnd, 0, 0);
      if (res)
      {
         if (strstr(res, "ppc") || strstr(res, "Power Macintosh") ||
             strstr(res, "powerpc")) fam = AFPPC;
         else if (strstr(res, "sparc")) fam = AFSPARC;
         else if (strstr(res, "alpha")) fam = AFALPHA;
         else if (strstr(res, "ia64")) fam = AFIA64;
         else if ( strstr(res, "i686") || strstr(res, "i586") ||
                   strstr(res, "i486") || strstr(res, "i386") ||
                   strstr(res, "x86_64") ) fam = AFX86;
         else if (strstr(res, "mips")) fam = AFMIPS;
         else if (strstr(res, "arm")) fam = AFARM;
         else if (strstr(res, "aarch64")) fam = AFARM;
         else if (strstr(res, "s390")) fam = AFS390;
         free(res);
      }
   }
   free(cmnd);
   return(fam);
}

/* 
 * ===========================================================================
 * These files handle setting/checking bits in (possibly) multi-word bitfields
 * ===========================================================================
 */
int IsBitSetInField(int *field, int bit)
/*
 * RETURNS: 1 if bit bit is 1, else 0
 */
{
   int word;
/*
 * Find which word the bit is in (assume 32-bit ints for safety), and what
 * bit in that word it is
 */
   word = bit >> 5;
   bit -= (word<<5);
   return(field[word] & (1<<bit));
}

void SetBitInField(int *field, int bit)
/*
 * Sets bit bit in multiword bitfield field
 */
{
   int word;
   word = bit >> 5;
   bit -= (word<<5);
   field[word] |= (1<<bit);
}

/*
 * ===================================================================
 * These files do some string processing for some crude pseudo-parsing
 * ===================================================================
 */

void KillUselessSpace(char *str)
/*
 * This routine removes all whitespace from beginning & end of str, and 
 * collapses multiple intra-word whitespace to one space
 * NOTE: killing whitespace means '\n' are transformed to ' ' or '\0'!
 * NOTE: This implementation ignores ' and ", so will collapse substrings
 */
{
   int i;  /* index to uncopied portion */
   int j;  /* index to place to copy next character */

   if (str)
   {
      for (i=0; str[i] && isspace(str[i]); i++);
      if (str[i])
      {
         j = 0;
         while (str[i])
         {
            while (str[i] && !isspace(str[i]))
               str[j++] = str[i++];
            if (str[i])
            {
               str[j++] = ' ';
            }
            while (isspace(str[i])) i++;
         }
         if (isspace(str[j-1]))
            str[j-1] = '\0';
         else str[j] = '\0';
      }
      else str[0] = '\0';
   }
}

char *GetPathWithoutName(char *file)
/* 
 *RETURNS: string containing path without last file/dir
 */
{
   char *sp;
   int i, lastslash;
   char ch;
   char *NewStringCopy(char *old);

   for (lastslash=i=0; file[i]; i++)
      if (file[i] == '/')
         lastslash = i;
   i = lastslash;
   ch = file[i];
   file[i] = '\0';
   sp = NewStringCopy(file);
   file[i] = ch;
   return(sp);
}
char *NameWithoutPath(char *file)
/*
 * Strips off path from file, assuming unix / for path
 * RETURNS: string containing file w/o path
 */
{
   int i, lastslash;
   char *cp;

   for (lastslash=i=0; file[i]; i++)
      if (file[i] == '/')
         lastslash = i;
   cp = malloc(sizeof(char)*(i-lastslash+1));
   assert(cp);
   strcpy(cp, file+((file[lastslash] == '/') ? lastslash+1 : 0));
   KillUselessSpace(cp);
   return(cp);
}

int GetIntVers(char *str, int *nskip)
{
   char ln[64];
   int i, j;

   *nskip = 0;
   for (i=0; str[i] && !isdigit(str[i]); i++);  /* skip non-digits */
   if (str[i])
   {
      for (j=0; j < 64 && str[j+i] && isdigit(str[j+i]); j++) ln[j] = str[j+i];
      ln[j] = '\0';
      if (j)
      {
         *nskip = i+j;
         return(atoi(ln));
      }
   }
   return(-1);
}

@beginskip
int GccIsApple(char *gcc)
{
   char ln[2048], ln2[2048];
   sprintf(ln, "%s --version", gcc);
   if (CmndOneLine(NULL, ln, ln2) == 0)
   {
      if (strstr(ln2, "Apple Computer"))
         return(1);
   }
   return(0);
}
@endskip
void GetGccVers(char *gcc, int *comp, int *major, int *minor, int *patch)
/*
 * comp: 0: gcc;  1: egcs;  2: pgcc, 3: apple's gcc, 4: clang
 */
{
   char *cmnd, *res;
   int i, j;

   *comp = *major = *minor = *patch = -1;
   i = strlen(gcc) + 12;
   cmnd = malloc(i * sizeof(char));
   assert(cmnd);
   sprintf(cmnd, "%s --version", gcc);
   res = atlsys_1L(NULL, cmnd, 0, 0);
   free(cmnd);
   if (res)
   {
      if (strstr(res, "clang") || strstr(res, "LLVM"))
         *comp = 4;
      else if (strstr(res, "Apple Computer") || strstr(res, "Apple Inc"))
         *comp = 3;
/*
 *    Skip compiler name, which may have digits in it
 */
      for (i=0; res[i] && !isspace(res[i]); i++);
      *major = GetIntVers(res+i, &j); j += i;
      if (*major != -1)
      {
         *minor = GetIntVers(res+j, &i); j += i;
         if (*minor != -1)
         {
            *patch = GetIntVers(res+j, &i); j += i;
            if (strstr(res, "egcs")) *comp = 1;
            else if (strstr(res, "pgcc")) *comp = 2;
            else if (*comp == -1) *comp = 0;
         }
      }
      free(res);
   }
}

char *GetPathEnvVar(void)
/*
 * returns users path with inter-name spaces replaced by "\ " 
 * and dirs separated by spaces
 */
{
   char *path, *pp, *p;
   int i, n;

   path = getenv("PATH");
   if (!path)
      return(NULL);
   
   n = strlen(path);
   p = pp = malloc((2*n+1)*sizeof(char));
   assert(pp);
   for (i=0; i < n; i++)
   {
      if (path[i] == ':')
         *p++ = ' ';
      else if (path[i] == ' ')
      {
         *p = '\\';
	 p[1] = ' ';
	 p += 2;
      }
      else
         *p++ = path[i];
   }
   *p = '\0';
   return(pp);
}

int CompIsGcc(char *comp)
/*
 * Tries to detect if compiler is gcc w/o scoping name of compiler
 * However, rejects compilers with c89 and c90 in name, since these
 * guys turn off inline assembly, which hurts the ATLAS install on performance.
 */
{
   char *cmnd, *res;
   char *cmpname;
   int i;

   cmpname = NameWithoutPath(comp);
   if (strstr(cmpname, "c89") || strstr(cmpname, "c90"))
   {
      free(cmpname);
      return(0);
   }
   free(cmpname);
   i = strlen(comp) + 16;
   cmnd = malloc(i*sizeof(char));
   assert(cmnd);
   sprintf(cmnd, "%s --version", comp);
   res = atlsys_1L(NULL, cmnd, 0, 0);
   free(cmnd);
   if (res)
   {
/*
 *    The direct comps added because Ubuntu stopped printing (GCC) in the
 *    version line.  Don't want to search for just "gcc", since that will
 *    match with pgcc
 */
      if (strstr(res, "(GCC)")  || strstr(res, " GCC ") ||
          strstr(res, "gcc-mp") || strstr(res, "(GCC ") ||
          strstr(res, "GNU Fortran") || 
          (res[0] == 'g' && res[1] == 'c' && res[2] == 'c' && 
           (res[3] == ' ' || res[3] == '-'))
         )
      {
         free(res);
         return(1);
      }
      free(res);
   }
   return(0);
}

int CompIsClang(char *comp)
/*
 * Tries to detect if compiler is clang w/o scoping name of compiler
 */
{
   char *cmnd, *res;
   char *cmpname;
   int i, iret=0;

   i = strlen(comp) + 16;
   cmnd = malloc(i*sizeof(char));
   assert(cmnd);
   sprintf(cmnd, "%s --version", comp);
   res = atlsys_1L(NULL, cmnd, 0, 0);
   free(cmnd);
   if (res)
   {
      iret = (strstr(res, "clang") || strstr(res, "LLVM"));
      free(res);
   }
   return(iret);
}

int CompIsMinGW(char *comp)
/*
 * Tries to detect if compiler is MinGW compiler
 */
{
   if (CompIsGcc(comp))
   {
      char *cmnd, *res;
      int i;
      i = strlen(comp) + 24;
      cmnd = malloc(sizeof(char)*i);
      assert(cmnd);
      sprintf(cmnd, "%s -v 2>&1 | fgrep mingw", comp);
      res = atlsys_1L(NULL, cmnd, 0, 0);
      free(cmnd);
      if (res)
      {
         if (strstr(res, "mingw"))
         {
            free(res);
            return(1);
         }
         free(res);
      }
   }
   return(0);
}

int CompIsAppleGcc(char *comp)
/*
 * Tries to detect if compiler is Apple's funked-up gcc 
 */
{
   char *cmnd, *res;

   if (CompIsGcc(comp))
   {
      int i;
      i = strlen(comp) + 24;
      cmnd = malloc(sizeof(char)*i);
      assert(cmnd);
      sprintf(cmnd, "%s -v 2>&1 | fgrep Apple", comp);
      res = atlsys_1L(NULL, cmnd, 0, 0);
      free(cmnd);
      if (res)
      {
         if (strstr(res, "Apple"))
         {
            free(res);
            return(1);
         }
         free(res);
      }
   }
   return(0);
}

int CompIsMIPSpro(char *comp)
/*
 * RETURNS: 1 if compiler is MIPSpro compiler, 0 otherwise
 */
{
   char *cmnd, *res;
   int i;

   i = strlen(comp) + 4;
   cmnd = malloc(sizeof(char)*i);
   assert(cmnd);
   sprintf(cmnd, "%s -v", comp);
   res = atlsys_1L(NULL, cmnd, 0, 0);
   free(cmnd);
   if (res)
   {
      if (strstr(res, "MIPSpro Compiler"))
      {
         free(res);
         return(1);
      }
      free(res);
   }
   return(0);
}

int CompIsPathScale(char *comp)
{
   char *cmnd, *res;
   int i;

   i = strlen(comp) + 4;
   cmnd = malloc(sizeof(char)*i);
   assert(cmnd);
   sprintf(cmnd, "%s -v", comp);
   res = atlsys_1L(NULL, cmnd, 0, 0);
   free(cmnd);
   if (res)
   {
      if (strstr(res, "PathScale"))
      {
         free(res);
         return(1);
      }
      free(res);
   }
   return(0);
}

int CompIsSunWorkshop(char *comp)
/*
 * RETURNS: 1 if compiler is Sun WorkShop compiler, 0 otherwise
 */
{
   char *cmnd, *res;
   int i;

   i = strlen(comp) + 4;
   cmnd = malloc(sizeof(char)*i);
   assert(cmnd);
   sprintf(cmnd, "%s -V", comp);
   res = atlsys_1L(NULL, cmnd, 0, 0);
   free(cmnd);
   if (res)
   {
      if (strstr(res, "Sun WorkShop"))
      {
         free(res);
         return(1);
      }
      free(res);
   }
   return(0);
}

int CompIsIBMXL(char *comp)
/*
 * RETURNS: 1 if compiler is an IBM XL compiler, 0 otherwise
 */
{
   char *cmnd, *res;
   int i;

   i = strlen(comp) + 11;
   cmnd = malloc(sizeof(char)*i);
   assert(cmnd);
   sprintf(cmnd, "%s -qversion", comp);
   res = atlsys_1L(NULL, cmnd, 0, 0);
   free(cmnd);
   if (res)
   {
      if (strstr(res, "IBM XL"))
      {
         free(res);
         return(1);
      }
      free(res);
   }
   return(0);
}

@beginskip
char *NewStringCopy(char *old)
/*
 * RETURNS: newly allocates string containing copy of string old
 */
{
   char *new;
   new = malloc(sizeof(char)*(strlen(old)+1));
   strcpy(new, old);
   return(new);
}
char *NewAppendedString0(char *old, char *app)
/*
 * RETURNS: string holding : old + app
 * NOTE: frees old string after copy
 */
{
   char *new;
   if (!old)
   {
      new = malloc(sizeof(char)*(strlen(app)+1));
      assert(new);
      strcpy(new, app);
   }
   else
   {
      new = malloc(sizeof(char)*(strlen(old) + strlen(app)+1));
      assert(new);
      strcpy(new, old);
      strcat(new, app);
      free(old);
   }
   return(new);
}
char *NewAppendedString(char *old, char *app)
/*
 * RETURNS: string holding : old + " " + app
 * NOTE: frees old string after copy
 */
 
{
   char *new;
   if (!old)
   {
      new = malloc(sizeof(char)*(strlen(app)+1));
      assert(new);
      strcpy(new, app);
   }
   else
   {
      new = malloc(sizeof(char)*(strlen(old) + strlen(app)+2));
      assert(new);
      strcpy(new, old);
      strcat(new, " ");
      strcat(new, app);
      free(old);
   }
   return(new);
}
@endskip
char **GetLinesFromFile
(
   FILE *fpin,    /* stream to read from */
   char **curlns  /* NULL-termed list of lines to prepend to file list ret */
)
/*
 * Read all lines from file fnam, suffix them to lines in curlns, delete 
 * curlns, and return them as NULL-terminated array of strings
 */
{
   char **lns=NULL;
   int i, n, nc=0, N;
   char ln[2048];

   assert(fpin);
   for (n=0; fgets(ln, 2048, fpin); n++);  /* count number of lines in file */
   rewind(fpin);
   if (curlns)
      for (nc=0; curlns[nc]; nc++);
   N = n+nc;
   if (N < 1)
      return(NULL);
   lns = malloc((N+1)*sizeof(char*));
   assert(lns);
   if (nc)
   {
      for (i=0; i < nc; i++)
         lns[i] = curlns[i];
      free(curlns);
   }
   for (i=0; i < n; i++)
   {
      int k;
      char *sp;
      assert(fgets(ln, 2048, fpin));
      k = strlen(ln)+1;
      lns[i+nc] = sp = malloc(k*sizeof(char));
      assert(sp);
      strcpy(sp, ln);
/* 
 *    Get rid of whitespace on end of line
 */
      for (k -= 2; isspace(sp[k]); k--) sp[k] = '\0';
   }
   lns[N] = NULL;
   return(lns);
}

void PrintAllStringsInList
(
   char *exp,
   char **strs  /* NULL terminated arrayof strings to be printed */
)
{
   int i;
   if (!strs)
   {
      printf("%s: NULL\n", exp);
      return;
   }
   printf("%s:\n", exp);
   for (i=0; strs[i]; i++)
      printf("   '%s'\n", strs[i]);
}
void KillAllStringsInList
(
   char **strs  /* NULL terminated arrayof strings to be freed */
)
{
   int i;
   if (!strs)
      return;
   for (i=0; strs[i]; i++)
      free(strs[i]);
   free(strs);
}

char *FreeListGetString
(
   char **strs, /* NULL-terminated array of strings to be freed */
   int n        /* only string you want to retain from array (returned) */
)
{
   char *ret;
   int i;

   if (!strs)
      return(NULL);
   ret = strs[n];
   for (i=0; strs[i]; i++)
   {
      if (i != n)
         free(strs[i]);
   }
   free(strs);
   return(ret);
}

char **NewOneStringList
(
   char **strs, /* NULL-terminated array of strings to be freed */
   int n        /* only string you want to retain from array (returned) */
)
{
   char **nstrs;
   nstrs = malloc(2*sizeof(char*));
   assert(nstrs);
   nstrs[0] = FreeListGetString(strs, n);
   nstrs[1] = NULL;
   return(nstrs);
}
@endextract
@ROUT atlconf_misc.h
#ifndef ATLCONF_MISC_H
   #define ATLCONF_MISC_H

#include "atlas_sys.h"
char *ATL_fgetln(FILE *fpin);
void GetDate(int *month, int *day, int *year, int *hour, int *min);
long GetInt(FILE *fpin, long Default, char *spc, char *expstr);
long GetIntRange(long Default, long Min, long Max, char *spc, char *expstr);
long GetIntVer(long Default, long Min, long Max, char *spc, char *expstr);
void GetString(FILE *fpin, char *Default, char *spc, char *expstr,
               int len, char *str0);
void GetStrVer(char *def, char *spc, char *expstr, int len, char *str);
int IsYes(char def, char *spc, char *expstr);
char GetChar(char def, char *spc, char *expstr);
int FileIsThere(char *nam);
void ATL_mprintf(int np, ...);
int GetFirstInt(char *ln);
int GetFirstHex(char *ln);
long long GetFirstLongHex(char *ln);
long long GetFirstLong(char *ln);
double GetFirstDouble(char *ln);
int GetLastInt(char *ln);
long long GetLastLong(char *ln);
long long GetLastLongWithRound(char *ln);
int fNumLines(char *fnam);
char *GetPathEnvVar(void);
@skip char *CmndResults(char *targ, char *cmnd);
@skip char *CmndResultsNoErr(char *targ, char *cmnd);
@skip int CmndOneLine(char *targ, char *cmnd, char *ln);
int GetIntBeforeWord(char *word, char *ln);
int GetScreenHeight();
void GetEnter(FILE *fpout);
int DisplayFile(char *fnam, FILE *fpout, int nlines);
int DisplayFile0(char *fnam, FILE *fpout);
int FoundInFile(char *fnam, char *str);
char *FindUname(char *targ);
enum ARCHFAM ProbeArchFam(char *targ);
void KillUselessSpace(char *str);
int IsBitSetInField(int *field, int bit);
void SetBitInField(int *field, int bit);
void KillUselessSpace(char *str);
char *NameWithoutPath(char *file);
char *GetPathWithoutName(char *file);
void GetGccVers(char *gcc, int *comp, int *major, int *minor, int *patch);
int CompIsGcc(char *comp);
int CompIsAppleGcc(char *comp);
int CompIsMIPSpro(char *comp);
int CompIsPathScale(char *comp);
int CompIsSunWorkshop(char *comp);
int CompIsIBMXL(char *comp);
char *NewStringCopy(char *old);
char *NewAppendedString0(char *old, char *app);
char *NewAppendedString(char *old, char *app);
char **GetLinesFromFile(FILE *fpin, char **curlns); /* append lines in fnam */
void KillAllStringsInList(char **strs);
void PrintAllStringsInList(char *exp, char **strs);
char *FreeListGetString(char **strs, int n);
char **NewOneStringList(char **strs, int n);

#define syschk(ln_) \
{ \
   int ierr; \
   ierr = system(ln_); \
   if (ierr) \
   { \
      fprintf(stderr, "ERROR %d IN SYSCMND: '%s'\n", ierr, (ln_)); \
      exit(ierr); \
   } \
}

#define Mciswspace(C) ( (((C) > 8) && ((C) < 14)) || ((C) == 32) )
#define Mlowcase(C) ( ((C) > 64 && (C) < 91) ? (C) | 32 : (C) )

#define BADINT -777938

#endif
@ROUT cputhrottle.txt
It appears that your Operating System is doing CPU throttling.  Because
the OS adjusts the Mhz of the CPU as things are running, timings become
extremely unreliable.  An ATLAS install, therefore, is completely useless
(ATLAS makes optimization decisions on essentially random data).  Therefore,
you need to disable CPU throttling before continuing the install.  On most
machines this may be done by changing the BIOS settings (eg., on my Athlon-64
machine, I can say "No" to "Cool and Quiet" under "Power Management").
Alternatively, most operating systems allow you to set it yourself.  Under
many Linux distros, a command similar to this will work:
   /usr/bin/cpufreq-selector -g performance \
      -f `cat /sys/devices/system/cpu/cpu0/cpufreq/cpuinfo_max_freq`

For multiprocessors, you have to issue this command for each cpu, adding
the '-c #' flag for each.

On Kubuntu, I had problems with this not working because scaling_max_freq
was set to the minimal speed.  To fix, I had to first increase the max scaling
frequency, which you can do (as root) by (where <#> below is replaced by each processor
number (eg., 0 and 1 for dual processor system):
   cd /sys/devices/system/cpu/cpu<#>/cpufreq
   cp cpuinfo_max_freq scaling_max_freq

Under MacOS or Windows, you may be able to change this under the power settings.
In any case, either change this using your OS or BIOS, and try again, as ATLAS
cannot achieve a valid install in the face of CPU throttling.
@ROUT CompMake.txt
#  ---------------------------------------------------------------------------
#  Various compilers and linkers.  The compilers recognized by ATLAS are:
#    F77 :  Compiler to compile f77 interface code with -- Should match what
#           user compile's his own code with; has no affect on ATLAS 
#           performance
#    ICC :  Compiler to used to compile all non-kernels in ATLAS, including
#           C interface codes.  Should match whatever compiler user compiles
#           with.  Impact on performance should be minimal.
#    SMC :  Compiler to use to compile single precision matmul kernels
#    DMC :  Compiler to use to compile double precision matmul kernels
#    SKC :  Compiler to use to compile single precision non-matmul kernels
#    DKC :  Compiler to use to compile double precision non-matmul kernels
#    XCC :  Compiler to be used on the compile engine of a cross-compiler
#  These C compiler are mostly the same, but flags are often different.
#  Note that if you specify no F77 compiler, F77 will be set to a C compiler
#  to aid in linking.
#  ---------------------------------------------------------------------------
@ROUT probe_os
#include "atlconf.h"

enum OSTYPE ProbeOS(int verb, char *targ)
{
   int i, ierr=0;
   char ln[1024], ln2[1024];
   char *cmnd, *res;
   enum OSTYPE OS;
   char *unam;

   if (verb) printf("Probing to make operating system determination:\n");
   unam = FindUname(targ);

   i = strlen(unam) + 4;
   cmnd = malloc(sizeof(char)*i);
   assert(cmnd);
   sprintf(cmnd, "%s -s", unam);
   res = atlsys_1L(targ, cmnd, verb, 0);
   if (res)
   {
/* 
 *    Accept GNU (HURD) as Linux, since they seem to use same stuff;
 *    This is patch from Sylvestre Ledru; I have no direct experience wt HURD
 */
      if(strstr(res, "Linux") || strstr(res, "GNU")) OS = OSLinux;
      else if(strstr(res, "FreeBSD")) OS = OSFreeBSD;
      else if (strstr(res, "Darwin")) OS = OSOSX;
      else if(strstr(res, "SunOS")) 
      {
         sprintf(cmnd, "%s -r", unam);
         free(res);
         res = atlsys_1L(targ, cmnd, verb, 0);
         if (res[0] == '4') OS = OSSunOS4;
         else OS = OSSunOS;
      }
      else if(strstr(res, "OSF1")) OS = OSOSF1;
      else if(strstr(res, "IRIX")) OS = OSIRIX;
      else if(strstr(res, "AIX")) OS = OSAIX;
      else if(strstr(res, "WIN"))
      {
         if (strstr(res, "95") || strstr(res, "98") || strstr(res, "_ME")) 
            OS = OSWin9x;
/*
 *       Need to confirm what is returned under cygwin for XP, etc.
 */
         else if (strstr(res, "WOW64")) OS =OSWin64;
         else if (strstr(res, "CYGWIN"))
         {
            free(res);
            sprintf(cmnd, "%s -m", unam);
            res = atlsys_1L(targ, cmnd, verb, 0);
            if (strstr(res, "x86_64") || strstr(res, "AMD64") || 
                strstr(res, "Intel64"))
               OS = OSWin64;
            else
               OS = OSWinNT;
         }
         else if (strstr(res, "NT")) OS = OSWinNT;
         else ierr = 1;
      }
      else if (strstr(res, "HP-UX")) OS = OSHPUX;
      else ierr = 1;
      free(res);
   }
   free(cmnd);
   if (ierr)
   {
      printf("\n\nUnable to determine OS, quitting\n\n");
      exit(-1);
   }
   if (verb)
      printf("Operating system configured as %s\n\n", osnam[OS]);

   return(OS);
}

void PrintUsage(char *name, int i)
{
   fprintf(stderr, "Error around argument %d\n", i);
   fprintf(stderr, "USAGE: %s -v <verbose #> -T <targ machine>\n", name);
   exit(-1);
}

int GetFlags(int nargs, char **args, char *targ)
{
   int verb=1, i;
   *targ = '\0';
   for (i=1; i < nargs; i++)
   {
      if (args[i][0] != '-')
         PrintUsage(args[0], i);
      switch(args[i][1])
      {
      case 'v':
         if (++i >= nargs)
            PrintUsage(args[0], i);
         verb = atoi(args[i]);
         break;
      case 'T':                    /* target machine for spawn */
         if (++i >= nargs)
            PrintUsage(args[0], i);
         strcpy(targ, args[i]);
         break;
      default:
         PrintUsage(args[0], i);
      }
   }
   return(verb);
}

int main(int nargs, char **args)
{
   int verb;
   char targ[1024];
   enum OSTYPE OS;
   verb = GetFlags(nargs, args, targ);
   OS = ProbeOS(verb, *targ == '\0' ? NULL : targ);
   printf("OS=%d\n", OS);
   return(OS == OSOther);
}
@ROUT probe_asm
#include "atlconf.h"

int RunASMProbe(char *targ, int verb, enum OSTYPE OS, char *asmnam)
{
   char ln[2048], ln2[2048];
   char *cmnd, *res, *frm;
   int i = 0;
   if (targ)
   {
      frm = "make IRun_%s atlrun=atlas_runX args=\"-v %d\" MYFLAGS=\"-DATL_OS_%s\" targ=%s 2> /dev/null | fgrep SUCCESS";
      i = strlen(targ);
   }
   else
      frm = "make IRun_%s args=\"-v %d\" MYFLAGS=\"-DATL_OS_%s\" 2> /dev/null | fgrep SUCCESS";

   i += strlen(frm) + strlen(asmnam) + 11 + strlen(osnam[OS]) + 1;
   cmnd = malloc(i*sizeof(char));
   assert(cmnd);
   if (targ)
      sprintf(cmnd, frm, asmnam, verb, osnam[OS], targ);
   else
      sprintf(cmnd, frm, asmnam, verb, osnam[OS]);
   if (verb > 1)
      fprintf(stderr, "system(%s)\n", cmnd);
   res = atlsys_1L(NULL, cmnd, verb, 0);
   free(cmnd);
   if (res)
   {
      if (strstr(res, "SUCCESS"))
      {
         if (verb)
            fprintf(stdout, "   %s: DETECTED!\n", asmnam);
         free(res);
         return(1);
      }
      free(res);
   }
   if (verb)
      fprintf(stdout, "   %s: NO.\n", asmnam);
   return(0);
}

enum ASMDIA ProbeASM(char *targ, int verb, enum OSTYPE OS)
{
   int i;
   for (i=1; i < NASMD; i++)
      if (RunASMProbe(targ, verb, OS, ASMNAM[i]))
         return(i);
   return(ASM_None);
}

@beginskip
void PrintUsage(char *name, int i)
{
   fprintf(stderr, "Error around argument %d\n", i);
   fprintf(stderr, "USAGE: %s -O <os#> [-v <verbose #> -T <targ machine>]\n", name);
   exit(-1);
}
@endskip

@extract -b @(basd)/atlconf.base rout=GetFlags -def -O "" -def -v ""

int main(int nargs, char **args)
{
   char *targ;
   int verb;
   enum OSTYPE OS;
   enum ASMDIA asmd;
   GetFlags(nargs, args, &verb, &OS, &targ);
   asmd = ProbeASM(targ, verb, OS);
   printf("ASM=%d\n", asmd);
   return(asmd == ASM_None);
}
@ROUT Makefile
@beginskip
SHELL=/bin/sh
@skip TOPdir = /home/whaley/TEST
@skip CC = gcc
@skip CFLAGS = -g
SRCdir = $(TOPdir)/CONFIG/src
INCdir = $(TOPdir)/CONFIG/include
mydir = $(BLDdir)
INCFLAGS = -I$(INCdir)
MYFLAGS =
CCFLAGS = $(INCFLAGS) $(MYFLAGS) $(CFLAGS)
XCC = $(CC)
XCFLAGS = $(CCFLAGS)
@endskip
LIBS =
args =
rdir = /tmp
arch=
BUNZIP = bunzip2
TAR = tar
wind=$(BLDdir)

all : build
xconfig : $(SRCdir)/config.c atlconf_misc.o
	$(XCC) $(XCFLAGS) -o xconfig $(SRCdir)/config.c atlconf_misc.o $(LIBS)
xspew : $(SRCdir)/SpewMakeInc.c atlconf_misc.o
	$(XCC) $(XCFLAGS) -o xspew $(SRCdir)/SpewMakeInc.c atlconf_misc.o \
               $(LIBS)
xisgcc : $(SRCdir)/IsGcc.c atlconf_misc.o
	$(XCC) $(XCFLAGS) -o $@ $(SRCdir)/IsGcc.c atlconf_misc.o $(LIBS)
mgwgfortran : $(SRCdir)/mgwcmp.c
	$(XCC) $(XCCFLAGS) "-DDEFDF=$(cmppath)" -o $@ $(SRCdir)/mgwcmp.c
mgwgcc : $(SRCdir)/mgwcmp.c
	$(XCC) $(XCCFLAGS) "-DDEFDF=$(cmppath)" -o $@ $(SRCdir)/mgwcmp.c
mgwar : $(SRCdir)/mgwcmp.c
	$(XCC) $(XCCFLAGS) "-DDEFDF=$(cmppath)" -o $@ $(SRCdir)/mgwcmp.c
mgwranlib : $(SRCdir)/mgwcmp.c
	$(XCC) $(XCCFLAGS) "-DDEFDF=$(cmppath)" -o $@ $(SRCdir)/mgwcmp.c

$(wind)/ATLwin_ifort.exe : $(SRCdir)/winf77.c
	cp $(SRCdir)/wincc.c $(wind)/.
	cd $(wind) ; icl /FeATLwin_ifort.exe /DDEFDF=ifort wincc.c
	rm -f $(wind)/wincc.c
$(wind)/ATLwin_icc.exe : $(SRCdir)/wincc.c
	cp $(SRCdir)/wincc.c $(wind)/.
	cd $(wind) ; icl /FeATLwin_icc.exe /DDEFDF=icl wincc.c
	rm -f $(wind)/wincc.c
$(wind)/ATLwin_cl.exe : $(SRCdir)/wincc.c
	cp $(SRCdir)/wincc.c $(wind)/.
	cd $(wind) ; cl /FeATLwin_cl.exe /DDEFDF=cl wincc.c
	rm -f $(wind)/wincc.c
@beginskip
@whiledef wcc icl
$(wind)/ATLwin_@(wcc).exe : $(SRCdir)/wincc.c
	cp $(SRCdir)/wincc.c $(wind)/.
	gcc -mno-cygwin -o $(wind)/ATLwin_@(wcc).exe -DDEFDF=@(wcc) \
            $(SRCdir)/wincc.c
@endwhile
@endskip
xprobe_comp : xisgcc probe_comp.o atlconf_misc.o
	$(XCC) $(XCFLAGS) -o xprobe_comp probe_comp.o atlconf_misc.o $(LIBS)
@whiledef prb OS asm vec arch f2c pmake aff
xprobe_@(prb) : probe_@(prb).o atlconf_misc.o
	$(XCC) $(XCFLAGS) -o xprobe_@(prb) probe_@(prb).o atlconf_misc.o $(LIBS)
@endwhile

xprint_enums : $(SRCdir)/print_enums.c
	$(XCC) $(XCFLAGS) -o xprint_enums $(SRCdir)/print_enums.c
xatlbench : atlbench.o atlconf_misc.o
	$(XCC) $(XCFLAGS) -o xatlbench atlbench.o atlconf_misc.o
@whiledef file atlconf_misc probe_OS probe_asm probe_vec probe_arch probe_comp probe_f2c probe_pmake atlbench probe_aff probe_aff_self
@(file).o : $(SRCdir)/@(file).c
	$(XCC) $(XCFLAGS) -c $(SRCdir)/@(file).c
@endwhile
@whiledef file atlconf_misc
@(file)_BE.o : $(SRCdir)/@(file).c
	$(CC) $(CCFLAGS) -o @(file)_BE.o -c $(SRCdir)/@(file).c
@endwhile

atlas_run :
	cd $(atldir) ; ./$(exe) $(args) > $(redir)
atlas_runX :
	./ATLrun.sh $(BLDdir) $(exe) $(args)
#	scp $(atldir)/$(exe) $(targ):$(rdir)/$(exe)
#	ssh $(targ) 'cd $(rdir) ; ./$(exe) $(args)' > $(redir)
atlas_run_TI :
	./ATLrun.sh $BLDdir $(exe) $(args)
force_build:

#
# General probes always ran locally (possibly cross-compiling machine)
# General probes call system (they're essentially shell scripts)
#
@whiledef prb comp
IRun_@(prb): xprobe_@(prb) force_build
	- rm -f config1.out
	$(MAKE) atlas_run atldir=$(mydir) exe=xprobe_@(prb) redir=config1.out \
                args="$(args) -d b $(BLDdir)"
	- cat config1.out
@endwhile
@whiledef prb OS
IRun_@(prb): xprobe_@(prb) force_build
	- rm -f config1.out
	$(MAKE) atlas_run atldir=$(mydir) exe=xprobe_@(prb) args="$(args)" \
                redir=config1.out
	- cat config1.out
@endwhile
@whiledef prb f2c asm vec arch pmake aff
IRun_@(prb): xprobe_@(prb) force_build
	- rm -f config2.out
	$(MAKE) atlas_run atldir=$(mydir) exe=xprobe_@(prb) args="$(args)" \
                redir=config2.out
	- cat config2.out
@endwhile

#
# Machine-level probes run on machine lib being compiled for
# These probes do not call system, but actually do something
#
IRun_ARM_HARDFP :
	$(CC) $(CCFLAGS) -o xprobe_hardfp \
              $(SRCdir)/backend/probe_arm32_FPABI.c \
              $(SRCdir)/backend/hardfptst.S
	$(MAKE) $(atlrun) atldir=$(mydir) exe=xprobe_hardfp args="$(args)" \
                redir=config0.out
	- cat config0.out
IRun_NEON :
	$(CC) $(CCFLAGS) -mfpu=neon -o xprobe_neon \
              $(SRCdir)/backend/probe_svec.c $(SRCdir)/backend/probe_NEON.S
	$(MAKE) $(atlrun) atldir=$(mydir) exe=xprobe_neon args="$(args)" \
                redir=config0.out
	- cat config0.out
IRun_VXZ :
	$(CC) $(CCFLAGS) -march=native -mvx -mzvector -o xprobe_vxz \
           $(SRCdir)/backend/probe_dvec.c $(SRCdir)/backend/probe_vxz.c
	$(MAKE) $(atlrun) atldir=$(mydir) exe=xprobe_vxz args="$(args)" \
                redir=config0.out
	- cat config0.out
@multidef pre s              s              d          d
@multidef prb vec            vec            mac        mac
@multidef asm FPV3D32MACNEON FPV3D16MACNEON FPV3D32MAC FPV3D16MAC
@whiledef fpu neon           neon-fp16      vfpv3      vfpv3-d16
IRun_@(asm) :
	$(CC) $(CCFLAGS) -mfpu=@(fpu) -o xprobe_@low@(asm) $(SRCdir)/backend/probe_@(pre)@(prb).c $(SRCdir)/backend/probe_@(asm).S
	$(MAKE) $(atlrun) atldir=$(mydir) exe=xprobe_@low@(asm) args="$(args)" \
                redir=config0.out
	- cat config0.out
   @undef pre
   @undef prb
   @undef asm
@endwhile
@multidef pre s    d    s       d   s
@whiledef asm SSE1 SSE2 AltiVec VSX 3DNow
IRun_@(asm) :
	$(CC) $(CCFLAGS) -o xprobe_@low@(asm) $(SRCdir)/backend/probe_@(pre)vec.c $(SRCdir)/backend/probe_@(asm).S
	$(MAKE) $(atlrun) atldir=$(mydir) exe=xprobe_@low@(asm) args="$(args)" \
                redir=config0.out
	- cat config0.out
   @undef pre
@endwhile
IRun_SSE3 :
	$(CC) $(CCFLAGS) -o xprobe_sse3 $(SRCdir)/backend/probe_dSSE3.c $(SRCdir)/backend/probe_SSE3.S
	$(MAKE) $(atlrun) atldir=$(mydir) exe=xprobe_sse3 args="$(args)" \
                redir=config0.out
	- cat config0.out
IRun_AVXZ :
	$(CC) $(CCFLAGS) -o xprobe_avxz $(SRCdir)/backend/probe_dAVXZ.c \
              $(SRCdir)/backend/probe_AVXZ.S
	$(MAKE) $(atlrun) atldir=$(mydir) exe=xprobe_avxz args="$(args)" \
                redir=config0.out
	- cat config0.out
IRun_AVXFMA4 :
	$(CC) $(CCFLAGS) -o xprobe_avxmac $(SRCdir)/backend/probe_dAVX.c \
              $(SRCdir)/backend/probe_AVXFMA4.S
	$(MAKE) $(atlrun) atldir=$(mydir) exe=xprobe_avxmac args="$(args)" \
                redir=config0.out
	- cat config0.out
IRun_AVXMAC :
	$(CC) $(CCFLAGS) -o xprobe_avxmac $(SRCdir)/backend/probe_dAVX.c \
              $(SRCdir)/backend/probe_AVXMAC.S
	$(MAKE) $(atlrun) atldir=$(mydir) exe=xprobe_avxmac args="$(args)" \
                redir=config0.out
	- cat config0.out
IRun_AVX :
	$(CC) $(CCFLAGS) -o xprobe_avx $(SRCdir)/backend/probe_dAVX.c \
              $(SRCdir)/backend/probe_AVX.S
	$(MAKE) $(atlrun) atldir=$(mydir) exe=xprobe_avx args="$(args)" \
                redir=config0.out
	- cat config0.out
@whiledef aff BINDP PBIND PLPA RUNON SCHED SETAFFNP SETPROCNP CPUSET WIN WIN64
IRun_@(aff) :
	$(CC) $(CCFLAGS) -o xprobe_@(aff) $(SRCdir)/backend/probe_aff_@(aff).c \
              $(LIBS)
	$(MAKE) $(atlrun) atldir=$(mydir) exe=xprobe_@(aff) args="$(args)" \
                redir=config0.out
	- cat config0.out
@endwhile

@whiledef asm GAS_x8632 GAS_x8664 GAS_PPC GAS_PARISC GAS_SPARC GAS_ARM GAS_ARM64 GAS_S390
IRun_@(asm) :
	$(CC) $(CCFLAGS) -o xprobe_@low@(asm) $(SRCdir)/backend/probe_this_asm.c $(SRCdir)/backend/probe_@low@(asm).S
	$(MAKE) $(atlrun) atldir=$(mydir) exe=xprobe_@low@(asm) args="$(args)" \
                redir=config0.out
	- cat config0.out
@endwhile

@whiledef asm GAS_WOW64
IRun_@(asm) :
	$(CC) $(CCFLAGS) -DATL_USE64BITS=1 -o xprobe_@low@(asm) \
        $(SRCdir)/backend/probe_this_asm.c $(SRCdir)/backend/probe_@low@(asm).S
	$(MAKE) $(atlrun) atldir=$(mydir) exe=xprobe_@low@(asm) args="$(args)" \
                redir=config0.out
	- cat config0.out
@endwhile

IRunC2C :
	- rm -f config0.out xc2c c2cslave.o
	$(CC1) $(CC1FLAGS) -c $(SRCdir)/backend/c2cslave.c
	$(CC) $(CCFLAGS) -o xc2c $(SRCdir)/backend/c2cmaster.c c2cslave.o
	$(MAKE) $(atlrun) atldir=$(mydir) exe=xc2c args="$(args)" \
                redir=config0.out
	- cat config0.out
IRunFlib :
	@ - rm config0.out
	@ $(F77) $(F77FLAGS) -v -o xtst $(SRCdir)/backend/comptestF.f 2>&1 | \
           fgrep -e '-L' > config0.out
	@ rm -f xtst
	@ - cat config0.out
IRunTestCFLink :
	@ - rm -f flibchk[F,C].o xflibchk
	$(F77) $(F77FLAGS) -c $(SRCdir)/backend/flibchkF.f
	$(CC) $(CCFLAGS) -o xflibchk $(SRCdir)/backend/flibchkC.c \
              flibchkF.o -l $(F77LIB) $(LIBS)
@whiledef nam name int str
IRunF2C_@(nam):
	- rm -f f2c@(nam)F.o f2c@(nam)C.o xfc@(nam) config0.out
	$(CC) $(CCFLAGS) -c $(SRCdir)/backend/f2c@(nam)C.c
	$(F77) $(F77FLAGS) -o xf2c@(nam) $(SRCdir)/backend/f2c@(nam)F.f \
               f2c@(nam)C.o
	$(MAKE) $(atlrun) atldir=$(mydir) exe=xf2c@(nam) args="$(args)" \
                redir=config0.out
	- cat config0.out
@endwhile
IRunF77Comp :
	- rm -f xf77test comptestF.o config0.out
	$(F77) $(F77FLAGS) -o xf77test $(SRCdir)/backend/comptestF.f
	$(MAKE) $(atlrun) atldir=$(mydir) exe=xf77test args="$(args)" \
                redir=config0.out
	- cat config0.out
IRunCComp :
	- rm -f xctest comptestC.o config0.out
	$(CC) $(CCFLAGS) -o xctest $(SRCdir)/backend/comptestC.c
	$(MAKE) $(atlrun) atldir=$(mydir) exe=xctest args="$(args)" \
                redir=config0.out
	- cat config0.out
IRunXCComp :
	- rm -f xctest comptestC.o config0.out
	$(CC) $(CCFLAGS) -o xctest $(SRCdir)/backend/comptestC.c
	$(MAKE) atlas_run atldir=$(mydir) exe=xctest args="$(args)" \
                redir=config0.out
	- cat config0.out

@whiledef prb x86 linux freebsd sunos irix aix sfu win
IRunArchInfo_@(prb): xarchinfo_@(prb)
	- rm -f config0.out
	$(MAKE) $(atlrun) atldir=$(mydir) exe=xarchinfo_@(prb) args="$(args)" \
                redir=config0.out
	- cat config0.out
@endwhile
xarchinfo_x86: $(SRCdir)/backend/archinfo_x86.c $(SRCdir)/backend/cpuid.S
	$(CC) $(CCFLAGS) -o xarchinfo_x86 $(SRCdir)/backend/archinfo_x86.c \
              $(SRCdir)/backend/cpuid.S
@whiledef OS linux freebsd sunos irix aix sfu win
xarchinfo_@(OS) : $(SRCdir)/backend/archinfo_@(OS).c atlconf_misc_BE.o
	$(CC) $(CCFLAGS) -o xarchinfo_@(OS) $(SRCdir)/backend/archinfo_@(OS).c \
              atlconf_misc_BE.o
@endwhile
@whiledef file wow64 x8664 x8632 ppc sparc parisc
xprobe_@(file) : $(SRCdir)/backend/probe_this_asm.c $(SRCdir)/backend/probe_gas_@(file).S
	$(CC) $(CCFLAGS) -o xprobe_@(file) $(SRCdir)/backend/probe_this_asm.c \
              $(SRCdir)/backend/probe_gas_@(file).S
@endwhile

DoNothing:

make_subdirs:
	mkdir src bin tune interfaces timing
	cd src ; mkdir testing auxil blas lapack pthreads threads
	cd src/lapack ; mkdir amm
	cd src/blas ; \
           mkdir f77reference reference gemv ger ammm kbmm \
                 level1 level2 level3 pklevel3
	cd src/blas/reference ; mkdir level1 level2 level3
	cd src/blas/level2 ; mkdir kernel
	cd src/blas/pklevel3 ; mkdir gpmm sprk
	cd src/blas/level3 ; mkdir rblas kernel
	cd src/pthreads ; mkdir blas misc
	cd src/pthreads/blas ; mkdir level1 level2 level3
	cd src/threads ; mkdir cbc cbc2d blas lapack
	cd src/threads/lapack ; mkdir amm
	cd src/threads/blas ; mkdir level3 level2
@skip	cd src/threads/blas/level3 ; mkdir omp
	cd tune ; mkdir blas sysinfo lapack threads
	cd tune/blas ; mkdir gemm gemv ger level1 level3
@beginskip
@whiledef rt sysinfo blas/gemm blas/gemv blasger blas/level1 blas/level3
        cd tune/@(rt) ; mkdir res
@endwhiledef
@endskip
	cd interfaces ; mkdir blas lapack
@whiledef rt blas lapack
	cd interfaces/@(rt) ; mkdir C F77
	cd interfaces/@(rt)/C ; mkdir src testing
	cd interfaces/@(rt)/F77 ; mkdir src testing
@endwhile
	cd interfaces/lapack ; mkdir C2F
	cd interfaces/lapack/C2F ; mkdir src
	mkdir ARCHS

#
# Simple test returns error if directory doesn't exist
#
DirIsThere :
	cd $(tdir)
$(arch)_defs : $(SRCdir)/CONFIG/$(arch).tar.gz
	$(BUNZIP) -c $(SRCdir)/CONFIG/$(ARCH).tar.bz2 | $(TAR) xvf -
archdef :
	$(MAKE) -f Make.top archdef
time : xatlbench
	$(MAKE) -f Make.top time
build :
	$(MAKE) -f Make.top build
	$(MAKE) clean
error_report:
	$(MAKE) -f Make.top error_report
startup : 
	$(MAKE) -f Make.top startup
refresh :
	$(MAKE) -f Make.top refresh
kill  :
	$(MAKE) -f Make.top kill
killall:
	$(MAKE) -f Make.top killall
C_test :
	$(MAKE) -f Make.top C_sanity_test
C_pttest :
	$(MAKE) -f Make.top C_ptsanity_test
check : $(TESTS)
ptcheck : $(PTTESTS)
full_test :
	$(MAKE) -f Make.top full_test
full_test_nh :
	$(MAKE) -f Make.top full_test_nh
scope_full_test :
	$(MAKE) -f Make.top scope_full_results
@whiledef la fl sl al pt
   @whiledef bl fb sb ab pt
scope_lapack_test_@(la)_@(bl) :
	$(MAKE) -f Make.top scope_lapack_test_@(la)_@(bl)
lapack_test_@(la)_@(bl) :
	$(MAKE) -f Make.top lapack_test_@(la)_@(bl)
   @endwhile
@endwhile
test :
	$(MAKE) -f Make.top sanity_test
pttest :
	$(MAKE) -f Make.top ptsanity_test
$(INCINSTdir) :
	mkdir -p $(INCINSTdir)
	chmod 0755 $(INCINSTdir)
$(INCINSTdir)/atlas :
	mkdir -p $(INCINSTdir)/atlas
	chmod 0755 $(INCINSTdir)/atlas
$(LIBINSTdir) :
	mkdir -p $(LIBINSTdir)
	chmod 0755 $(LIBINSTdir)
install : $(INCINSTdir) $(LIBINSTdir) $(INCINSTdir)/atlas
	$(MAKE) -f Make.top install_inc INSTdir=$(INCINSTdir) 
	$(MAKE) -f Make.top install_lib INSTdir=$(LIBINSTdir)

confclean: $(CLEANdep)
	rm -f *core* *.o config?.out
clean : $(CLEANdep)
	rm -f *.o x* config?.out *core*
cleanall: clean
	$(MAKE) -f Make.top clean
@ROUT atlas_asm.h
#ifndef ATLAS_ASM_H
   #define ATLAS_ASM_H

#ifndef Mjoin
   #define Mjoin(pre, nam) my_join(pre, nam)
   #define my_join(pre, nam) pre ## nam
#endif

@beginskip
#if (defined(ATL_OS_Win64) && !defined(ATL_USE64BITS)) || \
    defined(ATL_OS_Win9x) || defined(ATL_OS_OSX) || defined(ATL_OS_WinNT)
   #define ATL_asmdecor(nam) Mjoin(_,nam)
@endskip
#if defined(ATL_OS_Win9x) || defined(ATL_OS_OSX)
   #define ATL_asmdecor(nam) Mjoin(_,nam)
#elif defined(ATL_OS_Win64) || defined(ATL_OS_WinNT)
   #if defined(ATL_GAS_WOW64) || defined (ATL_USE64BITS)
      #define ATL_asmdecor(nam) nam
   #else
      #define ATL_asmdecor(nam) Mjoin(_,nam)
   #endif
#elif defined(ATL_OS_AIX) && defined(ATL_GAS_PPC)
   #define ATL_asmdecor(nam) Mjoin(.,nam)
#elif !defined(ATL_OS_OSX) && defined(ATL_GAS_PPC) && defined(ATL_USE64BITS)
   #define ATL_asmdecor(nam) Mjoin(.,nam)
#else
   #define  ATL_asmdecor(nam) nam
#endif

#ifdef ATL_GAS_PARISC
   #ifdef ATL_OS_HPUX
      #define ATL_HPUX_PARISC
   #else
      #define ATL_LINUX_PARISC
   #endif
#endif

#ifdef ATL_GAS_PPC
   #ifdef ATL_OS_OSX
      #define ATL_AS_OSX_PPC
   #elif defined(ATL_OS_AIX)
      #define ATL_AS_AIX_PPC
   #else
      #define ATL_GAS_LINUX_PPC
   #endif
#endif

#if defined(ATL_GAS_LINUX_PPC) || defined(ATL_AS_AIX_PPC)

@define i @0@
@iwhile i < 32
   #define r@(i) @(i)
   #define f@(i) @(i)
   #define v@(i) @(i)
   @iexp i 1 @(i) +
@endiwhile
@iwhile i < 64
   #define v@(i) @(i)
   @iexp i 1 @(i) +
@endiwhile
@define i @0@
@iwhile i < 8
   #define cr@(i) @(i)
   @iexp i 1 @(i) +
@endiwhile
@iexp i 32 0 +


#endif

#ifdef ATL_OS_OSX
@multidef l   7  6  5  4 3 2 1
@whiledef b 128 64 32 16 8 4 2
   #define ALIGN@(b) .align @(l)
   @undef l
@endwhile
   #define global globl
   #define local  locl
#else
@whiledef b 128 64 32 16 8 4 2
   #define ALIGN@(b) .align @(b)
@endwhile
#endif

#if defined(ATL_SSE1) && !defined(ATL_3DNow)
   #define prefetchw prefetchnta
#endif
/*
 * Solaris doesn't allow division in integer expressions in assembly, but
 * many x86 kernels need to do $MB/mu; we work around this insanity with
 * this kludge
 */
#if defined(ATL_DIV_NUM) && defined(ATL_DIV_DEN)
   #if (ATL_DIV_NUM/ATL_DIV_DEN) == 0
      #define ATL_DivAns 0
@define i @1@
@iwhile i < 129
   #elif (ATL_DIV_NUM/ATL_DIV_DEN) == @(i)
      #define ATL_DivAns @(i)
   @iexp i 1 @(i) +
@endiwhile
   #endif
#endif

/*
 * For GNU/Linux, set no-execute bit for all ATLAS assembly
 */
#if defined(ATL_OS_Linux) && defined(__ELF__) && defined(__GNUC__) && \
    defined(ATL_SSE1)
.section .note.GNU-stack,"",%progbits
#endif

#endif
@ROUT probe_this_asm
#include <stdio.h>
#include <stdlib.h>

int main(int nargs, char **args)
{
   int asm_probe(int i);
   int i;
   i = asm_probe(7);
   if (i != 21)
   {
      fprintf(stdout, "FAILURE, i=%d!!\n", i);
      fprintf(stderr, "FAILURE, i=%d!!\n", i);
      exit(-1);
   }
   fprintf(stdout, "SUCCESS\n");
   return(0);
}
@ROUT probe_gas_arm64.S
#include "atlas_asm.h"
#
# Linux ARM assembly for:
# int asm_probe(int i)
# RETURNS: i*3
#

.text
.globl  ATL_asmdecor(asm_probe)
.type   ATL_asmdecor(asm_probe), %function
ATL_asmdecor(asm_probe):
        add     x0, x0, x0, LSL #1
        ret
.size ATL_asmdecor(asm_probe),.-ATL_asmdecor(asm_probe)
@ROUT probe_arm32_FPABI
#include <stdio.h>
#define STOMP_FPREGS __asm__ __volatile__ ( \
   "mov r0, #0 ; fmsr s0, r0 ; fcpys s1, s0 ; fcpys s2, s0" \
   : /* no output */ \
   : /* no input */ \
   : "r0", "s0", "s1", "s2"  /* clobbered */ \
)
int main(int nargs, char **args)
{
   float hardfptst(float f0, float f1, float f2);
   STOMP_FPREGS;
   if (hardfptst(-2.0, 2.0, 4.0) == 6.0)
      printf("FPABI='HARDFP'\n");
   else
      printf("FPABI='SOFTFP'\n");
   return(0);
}
@ROUT hardfptst.S
#define ATL_GAS_ARM
#include "atlas_asm.h"
.code   32
.text
.align  2
.globl  ATL_asmdecor(hardfptst)
.type   ATL_asmdecor(hardfptst), %function
/*
 * float hardfptst(float f0, float f1, float f2);
 * RETURNS: f0 + f1*f2, assuming HARDFP ABI
 */
ATL_asmdecor(hardfptst):
        fmuls s1, s1, s2
        fadds s0, s0, s1
        bx      lr
.size ATL_asmdecor(hardfptst),.-ATL_asmdecor(hardfptst)

@ROUT probe_gas_arm.S
#define ATL_GAS_ARM
#include "atlas_asm.h"
#
# Linux ARM assembler for:
# int asm_probe(int i)
# RETURNS: i*3
#
.code   32
.text
.align  2
.globl  ATL_asmdecor(asm_probe)
.type   ATL_asmdecor(asm_probe), %function
ATL_asmdecor(asm_probe):
        add     r0, r0, r0, LSL #1
        bx      lr
.size ATL_asmdecor(asm_probe),.-ATL_asmdecor(asm_probe)
@ROUT probe_gas_wow64.S
#include "atlas_asm.h"
# WOW64 assembler for:
# int asm_probe(int i)
# RETURNS: i*3
#
.text
.global ATL_asmdecor(asm_probe)
ATL_asmdecor(asm_probe):
        xor     %rax, %rax
        lea (%ecx, %ecx,2), %eax
        ret
@ROUT probe_gas_x8664.S
#include "atlas_asm.h"
# x86-64 assembler for:
# int asm_probe(int i)
# RETURNS: i*3
#
.text
.global ATL_asmdecor(asm_probe)
ATL_asmdecor(asm_probe):
        xor     %rax, %rax
        movl    %edi, %eax
        shl     $1, %eax
        addl    %edi, %eax
        ret
@ROUT probe_gas_x8632.S
#include "atlas_asm.h"
#
# x86-32 assembler for:
# int asm_probe(int i)
# RETURNS: i*3
#
.text
.globl ATL_asmdecor(asm_probe)
ATL_asmdecor(asm_probe):
        movl    4(%esp), %eax
        movl    %eax, %ecx
        shl     $1, %eax
        addl    %ecx, %eax
        ret
@ROUT probe_gas_s390.S
#define ATL_GAS_PPC
#include "atlas_asm.h"
/*
 * Linux S390 assembler for:
 * int asm_probe(int i)
 * RETURNS: i*3
 */
.globl ATL_asmdecor(asm_probe)
ATL_asmdecor(asm_probe):
       lr      r3,r2
       ar      r2,r3
       ar      r2,r3
       br      r14
@ROUT probe_gas_mips.S
#include "atlas_asm.h"

; MIPS assembler for:
; int asm_probe(int i)
; RETURNS: i*3
.globl ATL_asmdecor(asm_probe)
ATL_asmdecor(asm_probe):
        daddu   $2, $4, $4
        j       $31
        daddu   $2, $2, $4    /* delay slot of return */
@ROUT probe_gas_ppc.S
#define ATL_GAS_PPC
#include "atlas_asm.h"
/*
 * Linux PPC assembler for:
 * int asm_probe(int i)
 * RETURNS: i*3
 */
.globl ATL_asmdecor(asm_probe)
ATL_asmdecor(asm_probe):
        add     r4, r3, r3
        add     r3, r3, r4
        blr
@ROUT probe_gas_sparc.S
!
! sparc assembler for:
! int asm_probe(int i)
! RETURNS: i*3
!
.section        ".text"
        .align 4
        .global asm_probe
@skip        .type   asm_probe,#function
asm_probe:
        sll     %o0, 1, %o1
        add     %o1, %o0, %o0
        retl
        nop
@ROUT probe_gas_parisc.S
        .LEVEL 2.0
#ifdef ATL_OS_HPUX
        .SPACE $TEXT$
        .SUBSPA $CODE$,QUAD=0,ALIGN=8,ACCESS=44,CODE_ONLY
#else
        .text
#endif
; PA-RISC assembler for:
; int asm_probe(int i)
; RETURNS: i*3
        .align 4
#ifdef ATL_OS_HPUX
        .SUBSPA $CODE$
        .EXPORT asm_probe,ENTRY,PRIV_LEV=3
asm_probe
#else
        .globl asm_probe
asm_probe:
#endif
        .PROC
        .CALLINFO FRAME=0,NO_CALLS
        .ENTRY
        depw,z  %r26, 29,30, %r28  ; r28 = 4 * i
        sub     %r28, %r26, %r28
        bve     (%r2)
        nop
        .EXIT
        .PROCEND
@ROUT probe_dSSE3
#include <stdio.h>
#include <stdlib.h>
int main(int nargs, char **args)
{
   double *x, *y, *z, ans[2];
   void *vp;
   void do_vsum(double *z, double *x, double *y); 

   vp = malloc(2*3*sizeof(double) + 16);
   x = (double*) ( 16 + ((((size_t)(vp))>>4)<<4) );
   y = x + 2;
   z = y + 2;
   x[0] = 1.0; x[1] = 2.0;
   y[0] = 4.0; y[1] = 8.0;
   ans[0] = x[0] + x[1];
   ans[1] = y[0] + y[1];
   do_vsum(z, x, y);   /* z[0]=x[0]+x[1], z[1]=y[0]+y[1]; */
   if (z[0] != ans[0] || z[1] != ans[1])
   {
      fprintf(stderr, "wanted={%.2f,%.2f}, got={%.2f,%.2f}\n",
              ans[0], ans[1], z[0], z[1]);
      printf("FAILURE\n");
      free(vp);
      exit(1);
   }
   printf("SUCCESS\n");
   free(vp);
   return(0);
}
@ROUT probe_dAVXZ
#include <stdio.h>
#include <stdlib.h>
int main(int nargs, char **args)
{
   double *x, *y, *z, ans[8];
   void *vp;
   void do_vmacc(double *z, double *x, double *y); 
   int i;

   vp = malloc(8*3*sizeof(double) + 64);
   x = (double*) ( 64 + ((((size_t)(vp))>>6)<<6) );
   y = x + 8;
   z = y + 8;
   x[0] = 1.0; x[1] = 2.0; x[2] = 4.0; x[3] = 8.0;
   x[4] = 16.0; x[5] = 32.0; x[6] = 64.0; x[7] = 128.0;
   y[0] = -4.0; y[1] = -8.0; y[2] = -16.0; y[3] = -32.0;
   y[4] = -64.0; y[5] = -128.0; y[6] = -256.0; y[7] = -512.0;
   z[0] = 0.0; z[1] = 1.0; z[2] = -1.0; z[3] = -4.0;
   z[4] = 4.0; z[5] = -8.0; z[6] = 8.0; z[7] = -16.0;
   for (i=0; i < 8; i++)
      ans[i] = z[i] + x[i] * y[i];
   do_vmacc(z, x, y);   /* z += x * y */
   if (z[0] != ans[0] || z[1] != ans[1] || z[2] != ans[2] || z[3] != ans[3] ||
       z[4] != ans[4] || z[5] != ans[5] || z[6] != ans[6] || z[7] != ans[7])
   {
      fprintf(stderr, "wanted={%.2f,%.2f,%.2f,%.2f,%.2f,%.2f,%.2f,%.2f}\n",
              ans[0],ans[1],ans[2],ans[3],ans[4],ans[5],ans[6],ans[7]);
      fprintf(stderr, "got   ={%.2f,%.2f,%.2f,%.2f,%.2f,%.2f,%.2f,%.2f}\n",
              z[0],z[1],z[2],z[3],z[4],z[5],z[6],z[7]);
      printf("FAILURE\n");
      free(vp);
      exit(1);
   }
   printf("SUCCESS\n");
   free(vp);
   return(0);
}
@ROUT probe_dAVX
#include <stdio.h>
#include <stdlib.h>
int main(int nargs, char **args)
{
   double *x, *y, *z, ans[4];
   void *vp;
   void do_vmacc(double *z, double *x, double *y); 
   int i;

   vp = malloc(4*3*sizeof(double) + 32);
   x = (double*) ( 32 + ((((size_t)(vp))>>5)<<5) );
   y = x + 4;
   z = y + 4;
   x[0] = 1.0; x[1] = 2.0; x[2] = 4.0; x[3] = 8.0;
   y[0] = -4.0; y[1] = -8.0; y[2] = -16.0; y[3] = -32.0;
   z[0] = 0.0; z[1] = 1.0; z[2] = -1.0; z[3] = -4.0;
   for (i=0; i < 4; i++)
      ans[i] = z[i] + x[i] * y[i];
   do_vmacc(z, x, y);   /* z += x * y */
   if (z[0] != ans[0] || z[1] != ans[1] || z[2] != ans[2] || z[3] != ans[3])
   {
      fprintf(stderr, 
              "wanted={%.2f,%.2f,%.2f,%.2f}, got={%.2f,%.2f,%.2f,%.2f}\n",
              ans[0], ans[1], ans[2], ans[3], z[0], z[1], z[2], z[3]);
      printf("FAILURE\n");
      free(vp);
      exit(1);
   }
   printf("SUCCESS\n");
   free(vp);
   return(0);
}
@ROUT probe_smac
   @define typ @float@
@ROUT probe_dmac
   @define typ @double@
@ROUT probe_dmac probe_smac
#include <stdio.h>
#include <stdlib.h>
int main(int nargs, char **args)
{
   @(typ) x=2.0, y=4.0, z=(-8.0), ans;
   void do_fmac(@(typ)*, @(typ)*, @(typ)*);

   ans = z + x*y;
   do_fmac(&z, &x, &y);
   if (z != ans)
   {
      fprintf(stderr, "wanted=%.2f, got=%.2f\n", ans, z);
      printf("FAILURE\n");
      exit(1);
   }
   printf("SUCCESS\n");
   return(0);
}
   @undef typ
@ROUT probe_dvec
#include <stdio.h>
#include <stdlib.h>
int main(int nargs, char **args)
{
   double *x, *y, *z, ans[2];
   void *vp;
   void do_vsum(double *, double *, double *);

   vp = malloc(2*3*sizeof(double) + 16);
   x = (double*) ( 16 + ((((size_t)(vp))>>4)<<4) );
   y = x + 2;
   z = y + 2;
   x[0] = 1.0; x[1] = 2.0;
   y[0] = 4.0; y[1] = 8.0;
   ans[0] = x[0] + y[0];
   ans[1] = x[1] + y[1];
   do_vsum(z, x, y);
   if (z[0] != ans[0] || z[1] != ans[1])
   {
      fprintf(stderr, "wanted={%.2f,%.2f}, got={%.2f,%.2f}\n",
              ans[0], ans[1], z[0], z[1]);
      printf("FAILURE\n");
      free(vp);
      exit(1);
   }
   printf("SUCCESS\n");
   free(vp);
   return(0);
}
@ROUT probe_svec
#include <stdio.h>
#include <stdlib.h>
int main(int nargs, char **args)
{
   float *x, *y, *z, ans[4];
   void *vp;
   void do_vsum(float *, float *, float *);

   vp = malloc(4*3*sizeof(float) + 16);
   x = (float*) ( 16 + ((((size_t)(vp))>>4)<<4) );
   y = x + 4;
   z = y + 4;
   x[0] = 8.0;  x[1] = 4.0;  x[2] = 2.0;  x[3] = 1.0;
   y[0] = 16.0; y[1] = 32.0; y[2] = 64.0; y[3] = 128.0;
   ans[0] = x[0] + y[0];
   ans[1] = x[1] + y[1];
   ans[2] = x[2] + y[2];
   ans[3] = x[3] + y[3];
   do_vsum(z, x, y);
   if (z[0] != ans[0] || z[1] != ans[1] || z[2] != ans[2] || z[3] != ans[3])
   {
      fprintf(stderr, 
              "wanted={%.2f,%.2f,%.2f,%.2f}, got={%.2f,%.2f,%.2f,%.2f}\n",
              ans[0], ans[1], ans[2], ans[3], z[0], z[1], z[2], z[3]);
      printf("FAILURE\n");
      free(vp);
      exit(1);
   }
   printf("SUCCESS\n");
   free(vp);
   return(0);
}
@ROUT probe_zvec
/*
 * This code provided by IBM.  RCW reformatted it closer to ATLAS coding style,
 * fixed cpp error.
 */
#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>
#include <fcntl.h>
#include <regex.h>
#include <string.h>

#if defined (__IBMC__) || defined (__IBMCPP__)
 #include <builtins.h>
#elsif defined(__GNUC__)
 #include <vecintrin.h>
#endif

#define vec_add(a,b) (a + b)

static int readfile(char *dir,char *file, char **buffer, int *size)
{
   int length = strlen(dir);
   int ret_code = -1;
   if (file)
   {
      strcat(dir,"/");
      strcat(dir,file);
   }
       
   if (access(dir, 4) == 0)
   {
      int fd = open(dir,O_RDONLY);
      if (fd >=0)
      {
         struct stat my_stat;
         int read_size;
         if (fstat(fd,&my_stat)==0)
         { 
/*
 *          if size of file is 0, then increase it arbitrarily to 4kbytes */
 */
            if (my_stat.st_size == 0) my_stat.st_size = 4096;

            if (*buffer==NULL)
            {
               *buffer = malloc(my_stat.st_size+1);
               *size = my_stat.st_size+1;
            }
            else if (*size < my_stat.st_size +1)
            {
               *buffer = realloc(*buffer,my_stat.st_size+1);
               *size = my_stat.st_size+1;
            }

            read_size = read(fd,*buffer,my_stat.st_size);
            if (read_size>=0)
            {
               (*buffer)[read_size] = '\x0';
               ret_code = 1;
            }
            close(fd);
         }
      }
   }
   if (file) dir[length] = '\x0';
       return ret_code;
}

int checkMachineSupportsVector()
{
   char *upbuff=NULL;
   int upsize;

/* Looking for stuff like:
 * 
 * features        : ... vx ...
 *
 * in file /cpu/procinfo
 */

   if (readfile("/proc/cpuinfo", NULL, &upbuff, &upsize) >=0)
   {
      regex_t myregex;
      int ret_code;

      /* Compile regular expression */
    
      if (regcomp(&myregex, 
"features([[:blank:]]+)[:](([[:blank:]]+)(.*)|)([[:blank:]]+)vx([[:space:]]+)",
                  REG_EXTENDED))
      {
         fprintf(stderr, "Error compiling regular expression\n");
         return(0);
      }
    
      ret_code = regexec(&myregex, upbuff, 0, NULL, 0);
      if (ret_code ==0)  /* Match */
         return(1);
      else if (ret_code == REG_NOMATCH) /* Could not find the feature */
         return(0);
      else 
      {
         fprintf(stderr, "Regex match failed\n");
         return (0);
      }

      regfree(&myregex);  
   }
   return(0);
}

int main(int nargs, char **args)
{
/* Check whether this is the appropriate platform */
#if !defined (__s390__) && !defined(__TOS_LINUX__)
   printf("OS FAILURE\n");
   return(1);
/* 
 * Ensure -mzvector and the proper architecture level have been specified 
 */
#elif !defined(__VEC__)
   printf("Vectors not enabled.\nFAILURE\n");
   return(1);
#else

   vector double x;
   vector double y;
   vector double z;
   vector double ans;
 
   if (checkMachineSupportsVector()==0) /* hardware support vectors? */
   {
      printf ("Current machine/hw does not support vectors\nFAILURE\n");
      return(1);
   }
/* 
 * Check whether the proper results are produced 
 */
   x[0] = 1.0; x[1] = 2.0;
   y[0] = 4.0; y[1] = 8.0;
   ans[0] = x[0] + y[0];
   ans[1] = x[1] + y[1];
   z = vec_add(x, y);

   if (z[0] != ans[0] || z[1] != ans[1])
   {
      fprintf(stderr, "wanted={%.2f,%.2f}, got={%.2f,%.2f}\n",
              ans[0], ans[1], z[0], z[1]);
      printf("FAILURE\n");
      exit(1);
   }

   printf("SUCCESS\n");
   return(0);
#endif
}
@ROUT probe_3DNow.S
#include "atlas_asm.h"
#
# x86 assembler for:
# void do_vsum(z, x, y)
# RETURNS: z = x + y;
#
.text
.globl ATL_asmdecor(do_vsum)
ATL_asmdecor(do_vsum):
#ifdef ATL_GAS_x8664
        movq    (%rsi), %mm0
        movq    8(%rsi), %mm1
        movq    (%rdx), %mm2
        movq    8(%rdx), %mm3
        pfadd   %mm2, %mm0
        pfadd   %mm3, %mm1
        movq    %mm0, (%rdi)
        movq    %mm1, 8(%rdi)
        emms
        ret
#else
        movl    12(%esp), %eax
        movq    (%eax), %mm0
        movq    8(%eax), %mm1
        movl    8(%esp), %eax
        movq    (%eax), %mm2
        movq    8(%eax), %mm3
        pfadd   %mm2, %mm0
        pfadd   %mm3, %mm1
        movl    4(%esp), %eax
        movq    %mm0, (%eax)
        movq    %mm1, 8(%eax)
        emms
        ret
#endif
@ROUT probe_fpv3D32MACNEON.S probe_fpv3D16MACNEON.S
#include "atlas_asm.h"
/*
  ARM NEON assembler for:
                     r0        r1       r2
  void do_vsum(float* z, float* x,float* y)
   where x, y, and z are vectors of length 4
   RETURNS: z = x + y
*/ 
.code   32
.fpu    neon
.text
.align 2
.globl  ATL_asmdecor(do_vsum)
.type   ATL_asmdecor(do_vsum), %function
ATL_asmdecor(do_vsum):
@ROUT probe_fpv3D16MACNEON.S
   vldm     r1,     {d0-d1}
   vldm     r2,     {d2-d3}
   vadd.f32 d0,     d0,      d2
   vadd.f32 d1,     d1,      d3
   vstm     r0,     {d0-d1}
@ROUT probe_fpv3D32MACNEON.S
   vldm     r1,     {d16-d17}
   vldm     r2,     {d18-d19}
   vadd.f32 d16,     d16,      d18
   vadd.f32 d17,     d17,      d19
   vstm     r0,     {d16-d17}
@ROUT probe_fpv3D32MACNEON.S probe_fpv3D16MACNEON.S
.size ATL_asmdecor(do_vsum),.-ATL_asmdecor(do_vsum)
@ROUT probe_fpv3D32MAC.S probe_fpv3D16MAC.S @\
      probe_fpv3D32NOMAC.S probe_fpv3D16NOMAC.S
#include "atlas_asm.h"
/*
  ARM vfpv3 assembler for:
                      r0        r1       r2
  void do_fmac(double* z, double* x,double* y)
   RETURNS: *z += *x * *y
*/ 
.code   32
.fpu    vfpv3
.text
.align 2
.globl  ATL_asmdecor(do_fmac)
.type   ATL_asmdecor(do_fmac), %function
ATL_asmdecor(do_fmac):
@ROUT probe_fpv3D16MAC.S probe_fpv3D16NOMAC.S
   fldd d0, [r0]
   fldd d1, [r1]
   fldd d2, [r2]
@ROUT probe_fpv3D16NOMAC.S
   fmuld d1, d1, d2
   faddd d0, d0, d1
@ROUT probe_fpv3D16MAC.S
   fmacd d0, d1, d2
@ROUT probe_fpv3D16MAC.S probe_fpv3D16NOMAC.S
   fstd d0, [r0]
@ROUT probe_fpv3D32MAC.S probe_fpv3D32NOMAC.S
   fldd d31, [r0]
   fldd d30, [r1]
   fldd d29, [r2]
@ROUT probe_fpv3D32NOMAC.S
   fmuld d30, d30, d29
   faddd d31, d31, d30
@ROUT probe_fpv3D32MAC.S
   fmacd d31, d30, d29
@ROUT probe_fpv3D32MAC.S probe_fpv3D32MAC.S
   fstd d31, [r0]
@ROUT probe_fpv3D32MAC.S probe_fpv3D16MAC.S
   bx lr
.size ATL_asmdecor(do_fmac),.-ATL_asmdecor(do_fmac)
@ROUT probe_NEON.S
#include "atlas_asm.h"
#
# ARM NEON assembler for:
# void do_vsum(float* z,float* x,float* y)
#  where x, y, and z are vectors of length 4
# RETURNS: z = x + y;
#
.code   32
.fpu    neon
.text
.align 2
.globl  ATL_asmdecor(do_vsum)
.type   ATL_asmdecor(do_vsum), %function
ATL_asmdecor(do_vsum):
   vldm     r1,     {d0-d1}
   vldm     r2,     {d2-d3}
   vadd.f32 d0,     d0,      d2
   vadd.f32 d1,     d1,      d3
   vstm     r0,     {d0-d1}
   bx lr
.size ATL_asmdecor(do_vsum),.-ATL_asmdecor(do_vsum)
@ROUT probe_SSE1.S
#include "atlas_asm.h"
#
# x86 assembler for:
# void do_vsum(z, x, y)
# RETURNS: z = x + y;
#
.text
.globl ATL_asmdecor(do_vsum)
ATL_asmdecor(do_vsum):
#ifdef ATL_GAS_x8664
        movups  0(%rsi), %xmm0
        movups  0(%rdx), %xmm1
        addps   %xmm1, %xmm0
        movups  %xmm0, 0(%rdi)
        ret
#elif defined(ATL_GAS_WOW64)
        movups  0(%rdx), %xmm0
        movups  0(%r8), %xmm1
        addps   %xmm1, %xmm0
        movups  %xmm0, 0(%rcx)
        ret
#else
        movl    12(%esp), %eax
        movups  0(%eax), %xmm0
        movl    8(%esp), %eax
        movups  (%eax), %xmm1
        addps   %xmm1, %xmm0
        movl    4(%esp), %eax
        movups  %xmm0, 0(%eax)
        ret
#endif
@ROUT probe_SSE2.S
#include "atlas_asm.h"
#
# x86 assembler for:
# void do_vsum(z, x, y)
# RETURNS: z = x + y;
#
.text
.globl ATL_asmdecor(do_vsum)
ATL_asmdecor(do_vsum):
#ifdef ATL_GAS_x8664
        movupd  0(%rsi), %xmm0
        movupd  0(%rdx), %xmm1
        addpd   %xmm1, %xmm0
        movupd  %xmm0, 0(%rdi)
        ret
#elif defined(ATL_GAS_WOW64)
        movupd  0(%rdx), %xmm0
        movupd  0(%r8), %xmm1
        addpd   %xmm1, %xmm0
        movupd  %xmm0, 0(%rcx)
        ret
#else
        movl    12(%esp), %eax
        movupd  0(%eax), %xmm0
        movl    8(%esp), %eax
        movupd  (%eax), %xmm1
        addpd   %xmm1, %xmm0
        movl    4(%esp), %eax
        movupd  %xmm0, 0(%eax)
        ret
#endif
@ROUT probe_SSE3.S
#include "atlas_asm.h"
#
# x86 assembler for:
# void do_vsum(z, x, y)
# RETURNS: z[0] = x[0]+x[1]; z[1] = y[0]+y[1];
#
.text
.globl ATL_asmdecor(do_vsum)
ATL_asmdecor(do_vsum):
#ifdef ATL_GAS_x8664
        movupd  0(%rsi), %xmm0
        movupd  0(%rdx), %xmm1
        haddpd  %xmm1, %xmm0
        movupd  %xmm0, 0(%rdi)
        ret
#elif defined(ATL_GAS_WOW64)
        movupd  0(%rdx), %xmm0
        movupd  0(%r8), %xmm1
        haddpd  %xmm1, %xmm0
        movupd  %xmm0, 0(%rcx)
        ret
#else
        movl    12(%esp), %eax
        movupd  0(%eax), %xmm0
        movl    8(%esp), %eax
        movupd  (%eax), %xmm1
        haddpd  %xmm0, %xmm1
        movl    4(%esp), %eax
        movupd  %xmm1, 0(%eax)
        ret
#endif
@ROUT probe_AVXZ.S
#include "atlas_asm.h"
#
# x86 assembler for:
# void do_vmacc(z, x, y)
# RETURNS: z[0:7] += x[0:7] *  y[0:7];
#
.text
.globl ATL_asmdecor(do_vmacc)
ATL_asmdecor(do_vmacc):
   #ifdef ATL_GAS_x8664
      vmovapd 0(%rdi), %zmm0                  /* load z */
      vmovapd 0(%rsi), %zmm1                  /* load x */
      vmovapd 0(%rdx), %zmm2                  /* load y */
      vfmadd231pd %zmm2, %zmm1, %zmm0         /* z += x*y */
      vmovapd %zmm0, (%rdi)                   /* store z */
   #elif defined(ATL_GAS_WOW64)
      vmovapd 0(%rcx), %zmm0                  /* load z */
      vmovapd 0(%rdx), %zmm1                  /* load x */
      vmovapd 0(%r8),  %zmm2                  /* load y */
      vfmadd231pd %zmm2, %zmm1, %zmm0         /* z += x*y */
      vmovapd %zmm0, (%rcx)                   /* store z */
   #else
      movl    12(%esp), %eax
      vmovapd (%eax), %zmm2                   /* load y */
      movl    8(%esp), %eax
      vmovapd  (%eax), %zmm1                  /* load x */
      movl    4(%esp), %eax
      vmovapd (%eax), %zmm0                   /* load z */
      vfmadd231pd %zmm2, %zmm1, %zmm0         /* z += x*y */
      vmovapd %zmm0, (%eax)                   /* store z */
   #endif
   ret
@ROUT probe_AVX.S probe_AVXMAC.S probe_AVXFMA4.S
#include "atlas_asm.h"
#
# x86 assembler for:
# void do_vmacc(z, x, y)
# RETURNS: z[0:3] += x[0:3] *  y[0:3];
#
.text
.globl ATL_asmdecor(do_vmacc)
ATL_asmdecor(do_vmacc):
@beginskip
#ifdef ATL_GAS_x8664
        vmovupd 0(%rdi), %ymm0                  /* load z */
        vmovupd 0(%rsi), %ymm1                  /* load x */
        vmovupd 0(%rdx), %ymm2                  /* load y */
@endskip
#if defined(ATL_GAS_x8664) || defined(ATL_GAS_WOW64)
   #ifdef ATL_GAS_x8664
      #define Z %rdi
      #define X %rsi
      #define Y %rdx
   #else
      #define Z %rcx
      #define X %rdx
      #define Y %r8
   #endif
     vmovupd (Z), %ymm0                  /* load z */
     vmovupd (X), %ymm1                  /* load x */
     vmovupd (Y), %ymm2                  /* load y */
@ROUT probe_AVX.S
        vmulpd %ymm1, %ymm2, %ymm3
        vaddpd %ymm3, %ymm0, %ymm0
@ROUT probe_AVXMAC.S
        vfmadd231pd %ymm2, %ymm1, %ymm0         /* z += x*y */
@ROUT probe_AVXFMA4.S
        vfmaddpd %ymm0, %ymm1, %ymm2, %ymm0     /* z += x*y */
@ROUT probe_AVX.S probe_AVXMAC.S probe_AVXFMA4.S
        vmovupd %ymm0, (Z)                      /* store z */
        ret
#else
        movl    12(%esp), %eax
        vmovupd 0(%eax), %ymm2                  /* load y */
        movl    8(%esp), %eax
        vmovupd  (%eax), %xmm1                  /* load x */
        movl    4(%esp), %eax
        vmovupd  (%eax), %xmm0                  /* load z */
@ROUT probe_AVX.S
        vmulpd %ymm1, %ymm2, %ymm3
        vaddpd %ymm3, %ymm0, %ymm0
@ROUT probe_AVXMAC.S
        vfmadd231pd %ymm2, %ymm1, %ymm0         /* z += x*y */
@ROUT probe_AVXFMA4.S
        vfmaddpd %ymm0, %ymm1, %ymm2, %ymm0     /* z += x*y */
@ROUT probe_AVX.S probe_AVXMAC.S probe_AVXFMA4.S
        vmovupd %xmm0, 0(%eax)                  /* store z */
        ret
#endif
@ROUT probe_vxz
#include <vecintrin.h>
void do_vsum(double *z, double *x, double *y) // RETURNS: z = x + y
{
   vector double vx, vy;
   vx[0] = x[0];
   vx[1] = x[1];
   vy[0] = y[0];
   vy[1] = y[1];
   vy += vx;
   z[0] = vy[0];
   z[1] = vy[1];
}
@ROUT probe_AltiVec.S probe_VSX.S
#include "atlas_asm.h"
/*

 * void do_vsum(z, x, y)
 * RETURNS: z = x + y
 *
 */
.text
#if defined(ATL_USE64BITS) && defined (ATL_OS_Linux) && _CALL_ELF != 2
        .align 2
        .globl  ATL_asmdecor(do_vsum)
        .section        ".opd","aw"
        .align 3
#else
.globl ATL_asmdecor(do_vsum)
#endif
ATL_asmdecor(do_vsum):
@ROUT probe_AltiVec.S
        lvx     v0,0,r5
        lvx     v1,0,r4
        vaddfp  v3,v0,v1
        stvx    v3,0,r3
@ROUT probe_VSX.S
        lxvd2x  v0,0,r5
        lxvd2x  v1,0,r4
        xvadddp v3,v0,v1
        stxvd2x  v3,0,r3
@ROUT probe_AltiVec.S probe_VSX.S
        blr
@ROUT probe_vec
@extract -b @(topd)/gen.inc what=cw @(cw06)
#include "atlconf.h"

int RunISAProbe(char *isaxnam, int verb, char *targ, char *opt)
{
   char *cmnd, *res, *frm;
   int i=1;
   if (targ)
   {
      frm = "make IRun_%s atlrun=atlas_runX targ=%s MYFLAGS='%s' 2> /dev/null | fgrep SUCCESS";
      i += strlen(targ);
   }
   else
      frm = "make IRun_%s MYFLAGS='%s' 2> /dev/null | fgrep SUCCESS";
   i += strlen(frm) + strlen(isaxnam) + strlen(opt);
   cmnd = malloc(sizeof(char)*i);
   assert(cmnd);
   if (targ)
      sprintf(cmnd, frm, isaxnam, targ, opt);
   else
      sprintf(cmnd, frm, isaxnam, opt);
   res = atlsys_1L(targ, cmnd, verb, 0);
   if(res)
   {
      if (strstr(res, "SUCCESS"))
      {
         if (verb)
            fprintf(stdout, "   %s: DETECTED!\n", isaxnam);
         free(res);
         return(1);
      }
   }
   if (verb > 1)
      fprintf(stdout, "   cmnd='%s' out='%s'\n", cmnd, res);
   free(cmnd);
   free(res);
   if (verb)
      fprintf(stdout, "   %s: NO.\n", isaxnam);
   return(0);
}

int GetAllISAExt(int verb, char *targ, enum OSTYPE OS, enum ASMDIA asmb)
{
   int i, iret=0;
   char ln[256];

   if (verb)
      fprintf(stdout, "\nProbing for supported ISA extensions:\n");

/*
 * For OS X, throw try throwing their random-ass annoyance flag
 */
   if (OS == OSOSX)
   {
@skip      sprintf(ln, "-DATL_OS_%s -DATL_%s -force_cpusubtype_ALL", 
@skip              osnam[OS], ASMNAM[asmb]);
      if (RunISAProbe(ISAXNAM[ISA_AV], verb, targ, ln))
         iret |= (1<<ISA_AV);
   }
   sprintf(ln, "-DATL_OS_%s -DATL_%s", osnam[OS], ASMNAM[asmb]);
   for (i=1; i < NISA; i++)
   {
      if (i >= ISA_NEON && i <= ISA_VFP3D16MAC)
      {
         if (asmb != gas_arm)
         {
            printf("   %s: SKIPPED (bad assembly)\n", ISAXNAM[i]);
            continue;
         }
         #if defined(ATL_NONIEEE) && ATL_NONIEEE != 0
            if (i >= ISA_NEON && i <= ISANEON16)
            {
               printf("   %s: SKIPPED (non_IEEE)\n", ISAXNAM[i]);
               continue;
            }
         #endif
      }
      else if (i >= ISA_AVXZ && i <= ISA_3DNow)
      {
         if (asmb != gas_x86_32 && asmb != gas_x86_64)
         {
            printf("   %s: SKIPPED (bad assembly)\n", ISAXNAM[i]);
            continue;
         }
      }
      if (RunISAProbe(ISAXNAM[i], verb, targ, ln))
         iret |= (1<<i);
   }
   return(iret);
}

@beginskip
PrintUsage(char *name, int i)
{
   fprintf(stderr, "Error around argument %d.\n", i);
   fprintf(stderr, "USAGE: %s -O <OS> -s <asm> [-v <verb> -T <targ>]\n", name);
   exit(-1);
}
@endskip
@extract -b @(basd)/atlconf.base rout=GetFlags -def -O "" -def -s ""

int main(int nargs, char **args)
{
   int verb, iret;
   enum OSTYPE OS;
   enum ASMDIA asmb;
   char *targ;

   GetFlags(nargs, args, &verb, &OS, &asmb, &targ);
   iret = GetAllISAExt(verb, targ, OS, asmb);
   printf("VECFLAG=%d\n", iret);
   return(0);
}
@ROUT probe_aff
#include "atlconf.h"

#define NAFF 11
static char *AFFS[NAFF] = 
   {"NONE", "SETAFFNP", "SETPROCNP", "WIN64", "WIN", "PBIND", "BINDP", "RUNON",
    "SCHED", "PLPA", "CPUSET"};
@multidef aff NONE SETAFFNP SETPROCNP WIN64 WIN PBIND BINDP RUNON SCHED PLPA CPUSET
@whiledef ii     0       1         2      3     4     5     6    7      8     9 10
#define IA_@(aff) @(ii)
   @undef aff
@endwhile
#define IA_FIRST_SELF IA_PBIND

int RunAffProbe(int iaff, int verb, char *targ, int iproc)
{
   char ln[512], ln2[512];
   char *cmnd, *res, *frm;
   char *lib;
   int i=1;

   if (iaff == IA_WIN || iaff == IA_WIN64)
      lib = "-lkernel32";
@skip   else if (iaff == IA_WIN64)
@skip      lib = "/usr/local/lib/msvcrt.lib";    /* works w/o -l for 64-bit MinGW */
   else
      lib = "-lpthread";
   if (targ)
   {
      i += strlen(targ);
      frm = "make IRun_%s atlrun=atlas_runX targ=%s LIBS='%s' args='%d' 2> /dev/null | fgrep SUCCESS";
   }
   else
      frm = "make IRun_%s LIBS='%s' args='%d' 2> /dev/null | fgrep SUCCESS";
   i += strlen(frm) + strlen(AFFS[iaff]) + strlen(lib) + 11;
   cmnd = malloc(sizeof(char)*i);
   assert(cmnd);
   if (targ)
      sprintf(cmnd, frm, AFFS[iaff], targ, lib, iproc);
   else
      sprintf(cmnd, frm, AFFS[iaff], lib, iproc);
   res = atlsys_1L(NULL, cmnd, verb, 0);
   if (res)
   {
      if (strstr(res, "SUCCESS"))
      {
         free(cmnd);
         free(res);
         if (verb)
            fprintf(stdout, "   %s: DETECTED!\n", AFFS[iaff]);
         return(1);
      }
   }
   if (verb > 1)
      fprintf(stdout, "   cmnd='%s' out='%s'\n", cmnd, res);
   free(cmnd);
   free(res);
   if (verb)
      fprintf(stdout, "   %s: NO.\n", AFFS[iaff]);
   return(0);
}

int GetPreferredAffinity(enum OSTYPE OS, int OMP)
/*
 * RETURNS: most likely affinity to work according to the OS reading
 */
{
   #ifdef ATL_OS_Linux
      return(OMP ? IA_SCHED : IA_SETAFFNP);
   #elif defined(ATL_OS_SunOS)
      return(IA_PBIND);
   #elif defined(ATL_OS_IRIX)
      return(IA_RUNON);
   #elif defined(ATL_OS_AIX)
      return(IA_BINDP);
   #elif defined(ATL_OS_HPUX)
      return(OMP ? IA_SCHED : IA_SETPROCNP);
   #elif defined(ATL_OS_WinNT)
      return(IA_WIN);
   #elif defined(ATL_OS_Win64)
      return(IA_WIN64);
   #else
      int iret=1;
      if (OS == OSSunOS)
         iret = IA_PBIND;
      else if (OSIsWin(OS))
         iret = IA_WIN;
      else if (OS == OSAIX)
         iret = IA_BINDP;
      else if (OS == OSHPUX)
         iret = OMP ? IA_SCHED : IA_SETPROCNP;
      else if (OSIRIX)
         iret = IA_RUNON;
      else if (OS == OSLinux && OMP)
         iret = IA_SCHED;
      return(iret);
   #endif
}

int ProbeSelfAffinity
(
   int verb,            /* verbosity */
   char *targ,          /* target machine */
   enum OSTYPE OS,      /* detected OS */
   int iaff             /* affinity used during spawn */
)
{
   int i;

   if (iaff == IA_NONE || iaff >= IA_FIRST_SELF)
      return(iaff);
   for (i=IA_FIRST_SELF; i < NAFF; i++)
      if (RunAffProbe(i, verb, targ, 0))
         return(i);
   return(IA_NONE);
}

int ProbeAffinity
(
   int verb,            /* verbosity */
   char *targ,          /* target machine */
   enum OSTYPE OS,      /* detected OS */
   int OMP              /* use OpenMP? */
)
/*
 * Searches all known affinities in AFFS for one that works to spawn to ID=0
 * RETURNS: integer indicating index in AFFS of the type of affinity
 */
{
   int ipref, iret, i;

   ipref = GetPreferredAffinity(OS, OMP);
   if (RunAffProbe(ipref, verb, targ, 0))
      return(ipref);

   for (i=1; i < NAFF; i++)
   {
/*
 *    For OpenMP, try only those methods you can use after thread startup
 */
      if (OMP && (i == IA_SETAFFNP || i == IA_SETPROCNP))
         continue;
      if (i != ipref)
      {
         if (RunAffProbe(i, verb, targ, 0))
            return(i);
      }
   }
   return(0);
}

int *ProbeAffIDs
(
   int verb,            /* verbosity */
   char *targ,          /* target machine */
   enum OSTYPE OS,      /* detected OS */
   int OMP,             /* use OpenMP? */
   int iaff             /* which entry in AFFS to search with */
)
/*
 * Finds list of IDs that can be successfully used in setting affinity
 * RETURNS: integer array, first entry is number of IDs, then IDs.
 *          If all sequential IDs work, then first entry is -maxID,
 *          and remaining entries are ignored.
 */
{
   int i, nID=0, *IDs=NULL, maxlog2, maxID, SEQ=1;

   if (!iaff)
      return(NULL);
/*
 * Find maximum power of two that works as an estimate on max assignable ID.
 * We work on the following assumptions:
 * 1. Systems that have unassignable virtual processors will have physical
 *    processors that are powers of two
 * 2. 128 is big enough to capture at least one physical processor
 * Try powers of two until at least 128.
 */
   if (verb)
      printf("FINDING LARGEST POWER OF 2 ID THAT CAN BE USED IN AFFINITY:\n");
   maxlog2 = -1;
   for (i=0; i < 8; i++)
   {
      if (RunAffProbe(iaff, 0, targ, (1<<i)))
      {
         printf("   ID=%d works.\n", (1<<i));
         maxlog2 = i;
      }
      else
         printf("   ID=%d FAILS.\n", (1<<i));
/*
 *    Windows appears to roll IDs after 32, so don't test past this point
 */
      #if defined(ATL_OS_WinNT) || defined(ATL_OS_Win9x) || \
          defined(ATL_OS_Win64)
         if (i == 5)
            break;
      #endif
   }
   if (maxlog2 == -1)
   {
      fprintf(stderr, "ONLY ID=0 WORKS FOR AFFINITY!");
      return(NULL);
   }
/*
 * If 128 worked, continue to search for even more legal assignable IDs,
 * but don't search 4096
 */
   if (maxlog2 == 7)
   {
      for (i=maxlog2+1;  i < 12; i++)
      {
         if (RunAffProbe(iaff, 0, targ, (1<<i)))
         {
            printf("   ID=%d works.\n", (1<<i));
            maxlog2 = i;
         }
         else
            break;
      }
   }
   if (verb)
      printf("LARGEST SUCCESSFUL POWER OF 2 = %d\n\n", (1<<maxlog2));
/*
 * maxlog2 is now the largest (1<<maxlog2) that we successfully can use
 * affinity on.  Note that non-power2 systems like the 3 processor phenom,
 * 6-node MIPS, etc, will still detect something (2 & 4, respectively).
 * Estimate maxID as one beneath the next maxlog2 setting in order to
 * handle these non-power2 cases.  
 */
   maxID = (1 << (maxlog2+1));
   IDs = malloc(sizeof(int)*(maxID+1));
   assert(IDs);
/*
 * Now simply try all IDs between these regions, and record the good ones
 */
   if (verb)
      printf("FINDING ALL VALID IDs BETWEEN 0 AND %d:\n", maxID-1);
   IDs[++nID] = 0;
   SEQ = 1;             /* assume all sequential IDs work */
   for (i=1; i < maxID; i++)
   {
      if (RunAffProbe(iaff, 0, targ, i))
      {
         printf("   ID=%d works.\n", i);
         IDs[++nID] = i;
      }
      else
      {
         printf("   ID=%d FAILS.\n", i);
         SEQ = 0;
      }
   }
/*
 * Indicate all IDs valid between 0 & maxID by setting nID = -maxID
 */
   IDs[0] = (SEQ) ? -IDs[nID] : nID;
   return(IDs);
}
@extract -b @(basd)/atlconf.base rout=GetFlags -def -O "" -def -o "" -def -t "" -def -S "" -def -t2 "" -def -t3 ""

void PrintResults
(
   char *outfile,  /* NULL or stdout, : stdout, else filename to print to */
   int iaff,       /* detected affinity entry in AFFS */
   int iaffS,      /* self-affinity */
   int *IDs        /* valid ID list */
)
{
   FILE *fpout;
   if (!outfile || !strcmp(outfile, "stdout"))
      fpout = stdout;
   else if (!strcmp(outfile, "stderr"))
      fpout = stderr;
   else
   {
      fpout = fopen(outfile, "w");
      assert(fpout);
   }
   fprintf(fpout, "/* Generated by %s */\n", __FILE__);
   fprintf(fpout, "#ifndef ATL_TAFFINITY_H\n   #define ATL_TAFFINITY_H\n\n");

@beginskip
   switch(iaff)
   {
   case IA_WIN64:
   case IA_WIN:
      fprintf(fpout, "#include <windows.h>\n");
      break;
   case IA_SETAFFNP:
   case IA_SCHED:
      fprintf(fpout,
   "#define _GNU_SOURCE 1 /* what manpage says you need to get CPU_SET */\n");
      fprintf(fpout,
   "#define __USE_GNU   1 /* what actually works on linuxes I've seen */\n");
      fprintf(fpout, "#include <sched.h>    /* must be included with above defs before pthread.h */\n");
      fprintf(fpout, "\n");
      break;
   case IA_PLPA:
      fprintf(fpout, "#include <plpa.h>\n");
      break;
   case IA_PBIND:
      fprintf(fpout, "#include <sys/types.h>\n");
      fprintf(fpout, "#include <sys/processor.h>\n");
      fprintf(fpout, "#include <sys/procset.h>\n\n");
   case IA_BINDP:
      fprintf(fpout, "#include <sys/thread.h>    /* thread_self header */ \n");
      fprintf(fpout, "#include <sys/processor.h> /* bindprocessor header */\n");
      break;
   case IA_CPUSET:
      fprintf(fpout, "#include <sys/param.h>\n");
      fprintf(fpout, "#include <sys/cpuset.h>\n");
      break;
   }
@endskip
   fprintf(fpout, "#define ATL_HAS_AFFINITY %d\n", iaff);
   fprintf(fpout, "#define ATL_PAFF_%s 1\n", AFFS[iaff]);
   fprintf(fpout, "#define ATL_SPAFF_%s 1\n", AFFS[iaffS]);
   if (iaff)
   {
      if (iaff == IA_SETAFFNP || iaff == IA_SETPROCNP || 
          iaff == IA_WIN64 || iaff == IA_WIN)
         fprintf(fpout, 
"#define ATL_PAFF_LAUNCH 1  /* affinity can be set during thread launch */\n");
      else
         fprintf(fpout, 
"#define ATL_PAFF_SELF 1  /* affinity must be set by thr after launched */\n");
      if (IDs[0] < 0)
      {
         fprintf(fpout, "#define ATL_AFF_NUMID %d\n", -IDs[0]+1);
         fprintf(fpout, "#define ATL_AFF_IDSTRIDE 1\n");
         fprintf(fpout, 
                 "#define ATL_RANK_IS_PROCESSORID 1 /* good IDs [0,%d] */\n",
                 -IDs[0]);
      }
      else
      {
         int i, stride;
/*
 *       Special MIC code maximizes # of physical cores as long as possible.
 *       This minimizes cache thrashing due to competing contexts. 
 *       For now, reduce the scale to the number of physical cores, simply
 *       because we can't use all that scale with the small problems that
 *       can fit on the card.
 */
         #ifdef ATL_ARCH_XeonPHI
         {
            int RP = IDs[0] - 3;
            int p = IDs[0]-4;
            int n = p>>2;

            assert(IDs[1] == 0 && IDs[2] == 1);
            fprintf(fpout, "#define ATL_AFF_NUMID %d\n", p);
            fprintf(fpout, "static int ATL_affinityIDs[%d]\n", p);
            fprintf(fpout, "   = {1");
            for (i=1; i < n; i++)
               fprintf(fpout, ", %d", (i*4+1)%RP);
            for (i=0; i < n; i++)
               fprintf(fpout, ", %d", (i*4+2)%RP);
            for (i=0; i < n; i++)
               fprintf(fpout, ", %d", (i*4+3)%RP);
            for (i=0; i < n; i++)
               fprintf(fpout, ", %d", (i*4+4)%RP);
            stride = 4;
         }
         #else
            fprintf(fpout, "#define ATL_AFF_NUMID %d\n", IDs[0]);
            fprintf(fpout, "static int ATL_affinityIDs[%d]\n", IDs[0]);
            fprintf(fpout, "   = {%d", IDs[1]);
            stride = IDs[2] - IDs[1];
            for (i=1; i < IDs[0]; i++)
            {
               fprintf(fpout, ", %d", IDs[i+1]);
               if (IDs[i+1] - IDs[i] != stride)
                  stride = 0;
            }
         #endif
         fprintf(fpout, "};\n");
         if (stride)
            fprintf(fpout, "#define ATL_IDSTRIDE %d\n", stride);
         else
            fprintf(fpout, 
"#define ATL_IDSTRIDE 0 /* valid IDs not separated by constant stride */\n");
      }
   }
   else /* no affinity detected */
   {
      fprintf(fpout, "#define ATL_NOAFFINITY 1\n");
      if (fpout != stderr && fpout != stdout)
      {
         FILE *fpo;
         fpo = fopen("res/aff.h", "w");
         fprintf(fpo, "#define ATL_TAFFINITY 0\n");
         fclose(fpo);
      }
   }
   fprintf(fpout, "\n#endif /* end multiple inclusion guard */\n");
   if (fpout != stderr && fpout != stdout)
      fclose(fpout);
}

int main(int nargs, char **args)
{
   int verb, iaff, iaff2, maxT, OMP, *IDs=NULL, i, max;
   enum OSTYPE OS;
   char *targ, *outfile;

   GetFlags(nargs, args, &verb, &OS, &maxT, &IDs, &outfile, &i, &targ);
   OMP = SI_IS_TRUE(i, SI_OMP);
   iaff = ProbeAffinity(verb, targ, OS, OMP);
   iaff2 = ProbeSelfAffinity(verb, targ, OS, iaff);
   if (IDs)
   {
      int *ids;
      if (!iaff)
      {
         fprintf(stderr, 
         "You have assigned particular IDs, but affinity does not work!\n");
         exit(-1);
      }
      ids = malloc((maxT+1)*sizeof(int));
      ids[0] = maxT;
      for (i=0; i < maxT; i++)
         ids[i+1] = IDs[i];
      free(IDs);
      IDs = ids;
   }
   if (iaff && !IDs)
   {
      IDs = ProbeAffIDs(verb, targ, OS, OMP, iaff);
      assert(IDs);
   }

   printf("AFFINITY TYPES= '%s' ('%s')\n", AFFS[iaff], AFFS[iaff2]);
   if (iaff)
   {
      if (IDs[0] < 0)
         printf("All IDs between [0, %d] are valid\n", -IDs[0]);
      else
      {
         max = IDs[0] + 1;
         printf("IDs[%d]=[%d", IDs[0], IDs[1]);
         for (i=2; i < max; i++)
            printf(", %d", IDs[i]);
         printf("]\n");
      }
   }
   PrintResults(outfile, iaff, iaff2, IDs);
   free(IDs);
   return(0);
}
@ROUT probe_aff_WIN probe_aff_WIN64
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <windows.h>
#ifndef CREATE_SUSPENDED
   #define CREATE_SUSPENDED 0x00000004
#endif
#ifndef WAIT_FAILED
   #define WAIT_FAILED (~0)
#endif


static int rank=0;

void *DumbTest(void *vp)
{
@ROUT probe_aff_WIN   `   ExitThread((DWORD)(vp));`
@ROUT probe_aff_WIN64 `   _endthread((unsigned)vp);`
}
int main(int nargs, char **args)
{
   HANDLE thrH;
@ROUT probe_aff_WIN   `   DWORD thrID;`
@ROUT probe_aff_WIN64 `   unsigned thrID;`
   void *vp, *vpret;

   if (nargs > 1)
      rank = atoi(args[1]);
   vp = (void*) &thrID;
   vpret = NULL;
@ROUT probe_aff_WIN64
   thrH = (HANDLE)_beginthreadex(NULL, 0, DumbTest, vp, CREATE_SUSPENDED, 
                                 &thrID);
@ROUT probe_aff_WIN
   thrH = CreateThread(NULL, 0, DumbTest, vp, CREATE_SUSPENDED, &thrID);
@ROUT probe_aff_WIN probe_aff_WIN64
   assert(thrH);
   assert(SetThreadAffinityMask(thrH, (((long long)1)<<rank)));
   assert(ResumeThread(thrH) == 1);
   assert(WaitForSingleObject(thrH, INFINITE) != WAIT_FAILED);
   assert(CloseHandle(thrH));

   printf("SUCCESS rank %d\n", rank);
   exit(0);
}
@ROUT probe_aff_SETAFFNP probe_aff_SETPROCNP probe_aff_PLPA probe_aff_SCHED @\
      probe_aff_PBIND probe_aff_BINDP probe_aff_RUNON probe_aff_CPUSET 
@ROUT @push
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
@ROUT probe_aff_SCHED probe_aff_SETAFFNP
#define _GNU_SOURCE 1 /* what manpage says you need to get CPU_SET */
#define __USE_GNU   1 /* what you actually have to set on linuxes I've seen */
#include <sched.h>    /* must include this before pthreads */
@ROUT @peek
#include <pthread.h>
@ROUT probe_aff_PLPA `#include <plpa.h>`
@ROUT probe_aff_PBIND
#include <sys/types.h>
#include <sys/processor.h>
#include <sys/procset.h>
@ROUT probe_aff_BINDP
#include <sys/thread.h>      /* thread_self header */
#include <sys/processor.h>   /* bindprocessor header */
@ROUT probe_aff_CPUSET
#include <sys/param.h>      
#include <sys/cpuset.h>    
@ROUT @peek

static int rank=0;

void *DumbTest(void *vp)
{
@ROUT probe_aff_PLPA 
   plpa_cpu_set_t cpuset;
   PLPA_CPU_ZERO(&cpuset);
   PLPA_CPU_SET(rank, &cpuset);
   assert(!plpa_sched_setaffinity((pid_t)0, sizeof(cpuset), &cpuset));
@ROUT probe_aff_PBIND
   assert(!processor_bind(P_LWPID, P_MYID, rank, NULL));
@ROUT probe_aff_BINDP
   assert(!bindprocessor(BINDTHREAD, thread_self(), rank));
@ROUT probe_aff_RUNON
   assert(!pthread_setrunon_np(rank));
@ROUT probe_aff_CPUSET
   cpuset_t mycpuset;
   CPU_ZERO(&mycpuset);         /* no manpage, so guess works like linux */
   CPU_SET(bindID, &mycpuset);
   assert(!cpuset_setaffinity(CPU_LEVEL_WHICH, CPU_WHICH_TID, -1,
                              sizeof(mycpuset), &mycpuset));
@ROUT probe_aff_SCHED
   cpu_set_t cpuset;
   CPU_ZERO(&cpuset);
   CPU_SET(rank, &cpuset);
   assert(!sched_setaffinity((pid_t)0, sizeof(cpuset), &cpuset));
@ROUT @peek
   pthread_exit(vp);
}
int main(int nargs, char **args)
{
   pthread_attr_t attr;
   pthread_t thr;
@ROUT probe_aff_SETAFFNP `   cpu_set_t *cpuset;`
   void *vp, *vpret;

   if (nargs > 1)
      rank = atoi(args[1]);
   vp = (void*) &thr;
   vpret = NULL;
   assert(!pthread_attr_init(&attr));
   #ifdef IBM_PT_ERROR
      assert(!pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_UNDETACHED));
   #else
      assert(!pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE));
   #endif
   pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM); /* OK to fail */
@ROUT probe_aff_SETAFFNP
/*
 * On POWER8/Linux, pthread_attr_setaffinity_np sometimes reallocs() the
 * cpuset variable, thus it must be malloced and not taken from stack!
 */
   cpuset = malloc(sizeof(cpu_set_t));
   CPU_ZERO(cpuset);
   CPU_SET(rank, cpuset);
   assert(!pthread_attr_setaffinity_np(&attr, sizeof(cpu_set_t), cpuset));
   free(cpuset);
@ROUT probe_aff_SETPROCNP
   assert(!pthread_attr_setprocessor_np(&attr, (pthread_spu_t)rank, 
                                        PTHREAD_BIND_FORCED_NP));
@ROUT @pop
   assert(!pthread_create(&thr, &attr, DumbTest, vp));
   assert(!pthread_attr_destroy(&attr));
   assert(!pthread_join(thr, &vpret));
   if (vpret == vp)
      printf("SUCCESS rank %d\n", rank);
   else
      printf("FAILURE rank %d\n", rank);
   exit(vpret == vp ? 0 : 1);
}
@ROUT probe_arch
#include "atlconf.h"

void PrintUsage(char *name, int iarg)
{
   fprintf(stderr, "error in arg %d USAGE: \n", iarg);
   fprintf(stderr, "   %s -O <os> -s <asm> -v <verb#> -c (cpu) -b (@ bits) -a (arch) -n (ncpu) -m (Mhz) -t (cpu throttling) -T <targ>\n", name);
   exit(iarg);
}

int GetFlags(int nargs, char **args, int *CacheLevel, enum OSTYPE *OS,
             enum ASMDIA *asmd, char **targ)
{
   int i, flag=0, k;
   *CacheLevel = 0;
   *targ = NULL;
   for (i=1; i < nargs; i++)
   {
      if (args[i][0] != '-')
         PrintUsage(args[0],i);
      switch(args[i][1])
      {
      case 'T':
         if (++i >= nargs)
            PrintUsage(args[0], i);
         *targ = args[i];
          break;
      case 's':
         if (++i >= nargs)
            PrintUsage(args[0], i);
         *asmd = atoi(args[i]);
         break;
      case 'O':
         if (++i >= nargs)
            PrintUsage(args[0], i);
         *OS = atoi(args[i]);
         break;
      case 'n':
         flag |= Pncpu;
         break;
      case 'c':
         flag |= Pncache;
         break;
      case 'C':
         if (++i >= nargs)
            PrintUsage(args[0], i);
         *CacheLevel = atoi(args[i]);
         break;
      case 'v':
         if (++i >= nargs)
            PrintUsage(args[0], i);
         k = atoi(args[i]);
         if (k)
            flag |= Pverb;
         break;
      case 'm':
         flag |= PMhz;
         break;
      case 'a':
         flag |= Parch;
         break;
      case 'b':
         flag |= P64;
         break;
      case 't':
         flag |= Pthrottle;
         break;
      default:
         PrintUsage(args[0], i);
      }
   }
   if (!flag)
     flag = Parch;
   return(flag);
}

void strlowcpy(char *out, char *in)
{
   if (in && out)
   {
      do *out++ = tolower(*in);
      while (*in++);
   }
}

int ProbeOneInt(enum OSTYPE OS0, enum ASMDIA asmd0, char *targ0, 
                char *flag, char *find, int *sure)
/*
 * Handles calls to all available backend probes that return one int,
 * keeps trying them until out of probes or one returns good (non-zero) value
 */
{
   char osname[128];
   char *cmnd, *res, *frm, *targ;
   enum OSTYPE OS;
   enum ASMDIA asmd;
   int i, iret=0;

   *sure = 0;
   asmd = (asmd0 > ASM_None && asmd0 < NASMD) ? asmd0 : gas_x86_32;
   OS = (OS0 > OSOther && OS0 < NOS) ? OS0 : OSLinux;
   if (OS == OSOSX)
      strlowcpy(osname, osnam[OSFreeBSD]);
   else if (OSIsWin(OS))
      strcpy(osname, "win");
   else
      strlowcpy(osname, osnam[OS]);
   if (targ0)
   {
      i = strlen(targ0) + 24;
      targ = malloc(sizeof(char)*i);
      assert(targ);
      sprintf(targ, "atlrun=atlas_runX targ=%s", targ0);
   }
   else
   {
      targ = malloc(sizeof(char));
      assert(targ);
      targ[0] = '\0';
   }

/* 
 * If Assembler right or unspecified, try x86 probe
 */
   if (asmd == gas_x86_32 || asmd == gas_x86_64 || asmd == gas_wow64)
   {
      frm = "make IRunArchInfo_x86 MYFLAGS=\"-DATL_OS_%s -DATL_%s\" args=\"%s\" %s | fgrep '%s'";
      i = strlen(frm) + strlen(osnam[OS]) + strlen(ASMNAM[asmd]) + strlen(flag)
          + strlen(targ) + strlen(find) + 1;
      cmnd = malloc(sizeof(char)*i);
      assert(cmnd);
      sprintf(cmnd, frm, osnam[OS], ASMNAM[asmd], flag, targ, find);
      res = atlsys_1L(NULL, cmnd, 0, 0);
      if (res)
      {
         iret = GetFirstInt(res);
         *sure = GetLastInt(res);
         free(res);
      }
      free(cmnd);
   }
/*
 * If that didn't work, try OS-specific probe
 */
   if (!iret)
   {
      frm = "make IRunArchInfo_%s MYFLAGS=\"-DATL_OS_%s -DATL_%s\" args=\"%s\" %s | fgrep '%s'";
      i = 1 + strlen(frm) + strlen(osname) + 3+strlen(osnam[OS]) + 
          strlen(ASMNAM[asmd]) + strlen(flag) + strlen(targ) + strlen(find);
      cmnd = malloc(sizeof(char)*i);
      assert(cmnd);
      sprintf(cmnd, frm, osname, osnam[OS], ASMNAM[asmd], flag, targ, find);
      res = atlsys_1L(NULL, cmnd, 0, 0);
      if (res)
      {
         iret = GetFirstInt(res);
         *sure = GetLastInt(res);
         free(res);
      }
@beginskip
/*
 *    Interix has its own probe under Windows, if all else fails
 */
      if (!iret && OS == OSWinSFU)
      {
         sprintf(cmnd, "make IRunArchInfo_sfu MYFLAGS=\"-DATL_OS_%s -DATL_%s\" args=\"%s\" %s | fgrep '%s'",
              osnam[OS], ASMNAM[asmd], flag, targ, find);
      }
@endskip
      free(cmnd);
   }
   return(iret);
}

int ConfirmPtrbits(enum OSTYPE OS0, enum ASMDIA asmd0, char *targ0, 
                   char *flag, char *find, int *sure)
/*
 * Retries pointer width probe using -m64; OK to fail: use prior val in that
 * case
 */
{
   char osname[128];
   char *cmnd, *res, *targ;
   char *frm="make IRunArchInfo_%s MYFLAGS=\"-m64 -DATL_OS_%s -DATL_%s\" args=\"%s\" %s | fgrep '%s'";
   enum OSTYPE OS;
   enum ASMDIA asmd;
   int i, iret=0;

   *sure = 0;
   asmd = (asmd0 > ASM_None && asmd0 < NASMD) ? asmd0 : gas_x86_32;
   OS = (OS0 > OSOther && OS0 < NOS) ? OS0 : OSLinux;
   i = (OS == OSOSX) ? OSFreeBSD : OS;
   assert(strlen(osnam[i]) < 128);
   strlowcpy(osname, osnam[i]);
   if (targ0)
   {
      i = strlen(targ0) + 24;
      targ = malloc(sizeof(char)*i);
      assert(targ);
      sprintf(targ, "atlrun=atlas_runX targ=%s", targ0);
   }
   else
   {
      targ = malloc(sizeof(char));
      assert(targ);
      targ[0] = '\0';
   }

/*
 * Try OS-specific probe, compiling with -m64 (assumes gcc workalike)
 */
   i = 1 + strlen(frm) + strlen(osnam) + strlen(osnam[OS]) + 
       strlen(ASMNAM[asmd]) + strlen(flag) + strlen(targ) + strlen(find);
   cmnd = malloc(i*sizeof(char));
   assert(cmnd);
   sprintf(cmnd, frm, osname, osnam[OS], ASMNAM[asmd], flag, targ, find);
   free(targ);
   res = atlsys_1L(NULL, cmnd, 0, 0);
   free(cmnd);
   if (res)
   {
      iret = GetFirstInt(res);
      *sure = GetLastInt(res);
      free(res);
   }
   return(iret);
}

int main(int nargs, char **args)
{
   int flags, CacheLevel, osname[128], sure, bits, i, j;
   enum OSTYPE OS;
   enum ASMDIA asmd;
   enum MACHTYPE arch;
   char *targ;

   flags = GetFlags(nargs, args, &CacheLevel, &OS, &asmd, &targ);
   if (flags & Parch)
   {
      arch = ProbeOneInt(OS, asmd, targ, "-a", "MACHTYPE=", &sure);
      if (arch == MACHOther && 
          (asmd == gas_x86_32 || asmd == gas_x86_64 || asmd == gas_wow64))
         arch = x86X;
      if (flags & Pverb)
         printf("Architecture detected as %s.\n", machnam[arch]);
      printf("MACHTYPE=%d\n", arch);
   }
   if (flags & Pncpu)
      printf("NCPU=%d\n", ProbeOneInt(OS, asmd, targ, "-n", "NCPU=", &sure));
   if (flags & PMhz)
      printf("CPU MHZ=%d\n", 
             ProbeOneInt(OS, asmd, targ, "-m", "CPU MHZ=", &sure));
   if (flags & Pthrottle)
      printf("CPU THROTTLE=%d\n", 
             ProbeOneInt(OS, asmd, targ, "-t", "CPU THROTTLE=", &sure));
   if (flags & P64)
   {
      if (asmd == gas_x86_64 || asmd == gas_wow64)
      {
         sure = 1;
         bits = 64;
      }
      else
      {
         bits = ProbeOneInt(OS, asmd, targ, "-b", "PTR BITS=", &sure);
         if (bits != 64)
         {
            i = ConfirmPtrbits(OS, asmd, targ, "-b", "PTR BITS=", &j);
            if (j)
            {
               bits = i;
               sure = j;
            }
         }
      }
      printf("PTR BITS=%d, SURE=%d\n", bits, sure);
   }
      
/*
 * Here for future, presently unsupported
 */
   if (flags & Pncache)
      printf("NCACHES=0\n");
   if (flags & PCacheSize)
      printf("%d Cache size (kb) = 0\n", CacheLevel);
   return(0);
}
@ROUT probe_pmake
#include "atlconf.h"

void GetPmake(int verb, enum OSTYPE OS, int ncpu, char *pmake)
{
   FILE *fp;
   if (ncpu == 0) ncpu = 1;
   if (!OSIsWin(OS))
   { /* using gnu make */
      char *res;
      res = atlsys_1L(NULL, "make DoNothing --version | fgrep GNU", verb, 1);
      if (res)
      {
         free(res);
         #if defined(ATL_GCCCLANG) || defined(ATL_GCC3P)
            sprintf(pmake, "$(MAKE) -j 1");
         #else
            if (ncpu == 1) sprintf(pmake, "$(MAKE) -j 2");
            else sprintf(pmake, "$(MAKE) -j %d", ncpu);
         #endif
      }
   }
   else
   {  /* AIX, HP-UX, SunOS make do not have parallel option */
      switch(OS)
      {
      case OSIRIX:
         #if defined(ATL_GCCCLANG) || defined(ATL_GCC3P)
            strcpy(pmake, "$(MAKE)");
         #else
            strcpy(pmake, "$(MAKE) -P");
         #endif
         break;
      case OSFreeBSD:
         #if defined(ATL_GCCCLANG) || defined(ATL_GCC3P)
            sprintf(pmake, "$(MAKE) -j 1");
         #else
            if (ncpu == 1) sprintf(pmake, "$(MAKE) -j 2");
            else sprintf(pmake, "$(MAKE) -j %d", ncpu);
         #endif
         break;
      default:
         strcpy(pmake, "$(MAKE)");
      }
   }
}

@extract -b @(basd)/atlconf.base rout=GetFlags -def -O "" -def -v "" -def -t ""

int main(int nargs, char **args)
{
   int verb, OS, arch, ncpu;
   char *targ;
   char pmake[256];
   GetFlags(nargs, args, &verb, &OS, &ncpu, &targ);
   GetPmake(verb, OS, ncpu, pmake);
   printf("PMAKE='%s'\n", pmake);
   return(0);
}
@ROUT probe_comp
#include "atlconf.h"

COMPNODE *GetCompNode(void)
{
   COMPNODE *p;
   p = calloc(1, sizeof(COMPNODE));
   assert(p);
   return(p);
}
COMPNODE *KillCompNode(COMPNODE *die)
{
   COMPNODE *p=NULL;
   if (die)
   {
      p = die->next;
      if (die->comp)
         free(die->comp);
      if (die->flags)
         free(die->flags);
      free(die);
   }
   return(p);
}

void KillAllCompNodes(COMPNODE *kill)
{
   while(kill)
      kill = KillCompNode(kill);
}

COMPNODE *CloneCompNode(COMPNODE *orig)
{
   COMPNODE *new;

   new = GetCompNode();
/*
 * Copy everything but strings wt memcopy
 */
   memcpy(new, orig, sizeof(COMPNODE));
   if (orig->comp)
   {
      new->comp = malloc(sizeof(char)*(strlen(orig->comp)+1));
      assert(new->comp);
      strcpy(new->comp, orig->comp);
   }
   if (orig->flags)
   {
      new->flags = malloc(sizeof(char)*(strlen(orig->flags)+1));
      assert(new->flags);
      strcpy(new->flags, orig->flags);
   }
   return(new);
}

void PrintCompNodes(FILE *fpout, COMPNODE *q, char *id)
{
   int i;
   COMPNODE *p;

   fprintf(fpout, "\nCompiler nodes: %s\n", id);
   if (!q)
      fprintf(fpout, "***NONE***\n");
   for (i=0, p=q; p; p=p->next, i++)
   {
      fprintf(fpout, 
         "%3d. priority=%d, comps,OS,arch[0]=(%d,%d,%d), comp='%s'\n",
              i, p->priority, p->comps[0], p->OS[0], p->arch[0], p->comp);
      fprintf(fpout, "     '%s'\n", p->flags);
   }
   fprintf(fpout, "\n");
}

COMPNODE *SortCompsByPriority(COMPNODE *q)
/* 
 * Builds new queue out of q, by first adding largest priority to newq, etc.
 */
{
   COMPNODE *newq=NULL, *p, *prev, *maxprev;
   int maxpri;

   while(q)  /* BFI N^2 sort */
   {
/*
 *    Find remaining element wt largest priority
 */
      maxprev = NULL;
      prev = q;
      maxpri = q->priority;
      for (p=q->next; p; p = p->next)
      {
         if (p->priority > maxpri)
         {
            maxpri = p->priority;
            maxprev = prev;
         }
         prev = p;
      }
/*
 *    Take max node off of q, add to newq
 */
      if (maxprev)  /* max elt wasn't stop of stack (q) */
      {
         p = maxprev->next->next;
         maxprev->next->next = newq;
         newq = maxprev->next;
         maxprev->next = p;
      }
      else
      {
         p = q->next;
         q->next = newq;
         newq = q;
         q = p;
      }
   }
   return(newq);
}

void DivideCompsByComp(COMPNODE *q, COMPNODE **comps)
/* 
 * Builds individual queues for each compiler camp, and then kills the original
 * queue.  Note that original q is sorted smallest-to-largest, and since we
 * add in order to a stack, we wind up with largest-to-smallest, as we want.
 * Note comps is really COMPNODE *comps[NCOMP], and can be indexed by ICC_, etc.
 */
{
   int i;
   COMPNODE *p, *new;

   for (i=0; i < NCOMP; i++)
      comps[i] = NULL;
   for (p=q; p; p = p->next)
   {
      for (i=0; i < NCOMP; i++)
      {
         if (IsBitSetInField(p->comps, i))
         {
            new = CloneCompNode(p);
            new->next = comps[i];
            comps[i] = new;
         }
      }
   }
   KillAllCompNodes(q);
}

static int OSMatches(enum OSTYPE OS, int *bits)
/*
 * RETURNS: 0 if no OS of arch in bitfield, nonzero otherwise
 */
{
   if (IsBitSetInField(bits, 0))   /* If 0 bit set, matches all OS */
      return(1);
   if (IsBitSetInField(bits, OS))  /* If OS bit set, matches this OS */
      return(2);
   return(0);
}

static int ArchMatches(enum MACHTYPE arch, int *bits)
/*
 * RETURNS: 0 if no match of arch in bitfield, nonzero otherwise
 */
{
   if (IsBitSetInField(bits, 0))     /* If 0 bit set, matches all archs */
      return(1);
   if (IsBitSetInField(bits, arch)) /* If arch bit set, matches this arch */
      return(2);
   return(0);
}

COMPNODE *KillBadArchOS(enum OSTYPE OS, enum MACHTYPE arch, COMPNODE *q)
/*
 * Deletes all non-matching OS/arch from queue; Note any node wt these
 * quantities set to 0 is a wildcard, and so stays
 */
{
   COMPNODE *prev, *next, *p;
   if (!OS && !arch)
      return(q);
/*
 * Delete all beginning nodes until we find one for this arch
 */
   while(q && (!ArchMatches(arch, q->arch) || !OSMatches(OS, q->OS)))
      q = KillCompNode(q);
/*
 * With good top of stack, delete trailing nodes that don't match
 */
   if (q)
   {
      prev = q;
      for (p=q->next; p; p = next)
      {
         next = p->next;
         if (!ArchMatches(arch, p->arch) || !OSMatches(OS, p->OS))
            prev->next = KillCompNode(p);
         else 
            prev = p;
      }
   }
   return(q);
}

int OSNameToInt(char *name)
{
   int i;
   for (i=1; i < NOS; i++)
   {
      if (!strcmp(name, osnam[i]))
         return(i);
   }
   return(0);
}

int MachNameToInt(char *name)
{
   int i;
   for (i=1; i < NMACH; i++)
   {
      if (!strcmp(name, machnam[i]))
         return(i);
   }
   return(0);
}
void NamesToBitField(int MACH, char *str, int *bits)
/*
 * Takes a list of machine (MACH=1) or OS (MACH=0) names and translates them
 * to their enumerated type numbers, and sets the appropriate bit in the
 * bits field
 */
{
   char name[128];
   int i=0;
   while(*str)
   {
      if (*str == ',' || *str == ' ' || *str == '\t' || *str == '\n' || 
          *str == '\0')
      {  /* finished a name */
         name[i] = '\0';
         if (!strcmp(name, "all") || !strcmp(name, "ALL")) 
            i = 0;
         else
         {
            if (MACH)
               i = MachNameToInt(name);
            else
               i = OSNameToInt(name);
            if (!i)
            {
               fprintf(stderr, "Nonsensical %s name in list: '%s' (%s)\n", 
                       MACH ? "machine" : "OS", name, str);
               exit(1);
            }
         }
         SetBitInField(bits, i);
         if (*str != ',')  /* anything but ',' ends list */
            return;
         str++;
         i = 0;
      }
      else 
         name[i++] = *str++;
   }
}

void NumListToBitfield(char *str, int *bits)
/*
 * Takes a list of number like : '5,3,2,8,0' and turns on those bits
 */
{
   char num[16], *sp;
   int i, j;

   while (*str)
   {
      for (sp=num,i=0; i < 15; i++)
      {
         if (!isdigit(str[i])) break;
         *sp++ = str[i];
      }
      assert(i != 15);
      *sp = '\0';
      j = atoi(num);
      SetBitInField(bits, j);
      if (str[i] != ',') break;
      str += i+1;
   }
}

COMPNODE *ParseNewCompLine(char *ln)
{
   COMPNODE *p;
   char *sp;
   p = GetCompNode();

   sp = strstr(ln, "MACH=");
   assert(sp);
   sp += 5;
/*   NumListToBitfield(sp, p->arch); */
   NamesToBitField(1, sp, p->arch);


   sp = strstr(ln, "OS=");
   assert(sp);
   sp += 3;
/*   NumListToBitfield(sp, p->OS); */
   NamesToBitField(0, sp, p->OS);

   sp = strstr(ln, "LVL=");
   assert(sp);
   sp += 4;
   p->priority = atoi(sp);
/*
 * Parse 'COMPS=[icc,smc,dmc,skc,dkc,xcc,gcc,f77]', at least one comp must exist
 */
   sp = strstr(ln, "COMPS=");
   assert(sp);
   sp += 6;
   while (*sp)
   {
      if (sp[0] == 'i' && sp[1] == 'c' && sp[2] == 'c')
         SetBitInField(p->comps, ICC_);
      else if (sp[0] == 's' && sp[1] == 'm' && sp[2] == 'c')
         SetBitInField(p->comps, SMC_);
      else if (sp[0] == 'd' && sp[1] == 'm' && sp[2] == 'c')
         SetBitInField(p->comps, DMC_);
      else if (sp[0] == 's' && sp[1] == 'k' && sp[2] == 'c')
         SetBitInField(p->comps, SKC_);
      else if (sp[0] == 'd' && sp[1] == 'k' && sp[2] == 'c')
         SetBitInField(p->comps, DKC_);
      else if (sp[0] == 'x' && sp[1] == 'c' && sp[2] == 'c')
         SetBitInField(p->comps, XCC_);
      else if (sp[0] == 'g' && sp[1] == 'c' && sp[2] == 'c')
         SetBitInField(p->comps, GCC_);
      else if (sp[0] == 'f' && sp[1] == '7' && sp[2] == '7')
         SetBitInField(p->comps, F77_);
      else
      {
         fprintf(stderr, "WTF(%d of %s): '%s'??\n", __LINE__, __FILE__, sp);
         exit(-1);
      }
      if (sp[3] != ',') break;
      sp += 4;
   }
   return(p);
}

char *CopySingleQuoteString(char *str, char *out)
/*
 * Finds the leading ' in str, and copies quoted text to out until closing '
 * is found or end of string.  
 * RETURNS: pointer in str at closing ', NULL if closing ' not found
 */
{
/*
 * Skip text before staring quote, return if quote not found
 */
   *out = '\0';
   while (*str != '\'' && *str) str++;
   if (*str == '\0')
      return(NULL);
/*
 * Copy quoted text, return pointer to end quote if it exists
 */
   str++;
   while (*str != '\'' && *str) *out++ = *str++;
   *out++ = '\0';
   if (*str == '\'')
      return(str);
   return(NULL);
}

COMPNODE *ParseCompLine(char *ln)
{
   static int NewComp=1;
   static COMPNODE *p=NULL;
   int i;
   char *sp;
   char ln2[2048];

   if (NewComp)
      p = ParseNewCompLine(ln);
/* 
 * Should be line of form "'compiler' 'flags'"
 */
   else
   {
      sp = CopySingleQuoteString(ln, ln2);
      assert(sp);
      i = strlen(ln2) + 1;
      p->comp = malloc(sizeof(char)*i);
      assert(p->comp);
      strcpy(p->comp, ln2);

      sp = CopySingleQuoteString(sp+1, ln2);
      i = strlen(ln2) + 1;
      p->flags = malloc(sizeof(char)*i);
      assert(p->flags);
      strcpy(p->flags, ln2);
   }
   NewComp = !NewComp;
   return(p);
}

COMPNODE *ReadComps(char *file)
/*
 * Reads in a file describing the compilers ATLAS knows about, and returns
 * a queue of them for later manipulation.
 */
{
   char ln[2048];
   FILE *fpin;
   COMPNODE *compq=NULL, *p;

   fpin = fopen(file, "r");
   while (fgets(ln, 2048, fpin))
   {
      if (ln[0] != '#')
      {
         KillUselessSpace(ln);
         if (ln[0] != '#' && ln[0] != '\0')
         {
            p = ParseCompLine(ln);
            if (p != compq)
            {
               p->next = compq;
               compq = p;
            }
         }
      }
   }
   fclose(fpin);
   return(compq);
}

COMPNODE **GetDefaultComps(enum OSTYPE OS, enum MACHTYPE arch, int verb, 
                           int vecexts)
/*
 * This routine reads the file atlcomp.txt, and returns them sorted by
 * order of priority for each compiler ATLAS needs.  This list can then
 * be matched with the user's input to give final compiler and flags.
 */
{
   COMPNODE *q, *p, **comps;
   char *vp=NULL;
   int i;

   if ((vecexts & (1<<ISA_AVXFMA4)) && arch == AmdDozer)
      vp = "-msse4.2 -mfma4";
   else if ((vecexts & (1<<ISA_AVXMAC)) && arch == AmdDriver)
      vp = "-mavx -mno-sse2avx -mfma";
   else if ((vecexts & (1<<ISA_AVXMAC)))
      vp = "-mavx2 -mfma";
   else if (vecexts & (1<<ISA_VSX))
      vp = "-mvsx";
   else if (vecexts & (1<<ISA_VXZ))
      vp = "-mvx -mzvector";
   else if (vecexts & (1<<ISA_AV))
      vp = "-maltivec";
   else if (vecexts & (1<<ISA_AVX))
      vp = "-mavx";
   else if (vecexts & (1<<ISA_SSE3))
      vp = "-msse3";
   else if (vecexts & (1<<ISA_SSE2))
      vp = "-msse2";
   else if (vecexts & (1<<ISA_SSE1))
      vp = "-msse";
   else if (vecexts & (1<<ISA_NEON))
      vp = "-mfpu=neon";
   else if (vecexts & (1<<ISA_NEON16))
      vp = "-mfpu=neon-fp16";
   else if (vecexts & (1<<ISA_VFP3D32MAC))
      vp = "-mfpu=vfpv3";
   else if (vecexts & (1<<ISA_VFP3D16MAC))
      vp = "-mfpu=vfpv3-d16";
   comps = malloc(sizeof(COMPNODE)*NCOMP);
   q = ReadComps("atlcomp.txt");    /* get all compiler lines */
   if (verb > 1)
      PrintCompNodes(stderr, q, "Fresh Read");
   q = KillBadArchOS(OS, arch, q);  /* discard comps for other platforms */
   if (verb > 1)
      PrintCompNodes(stderr, q, "Targeted");
   q = SortCompsByPriority(q);      /* q is smallest, bottom is largest */
   if (verb > 1)
      PrintCompNodes(stderr, q, "Sorted");
   DivideCompsByComp(q, comps);     /* split into individual queues */
/*
 * Add the ISA extension-using flags to any gcc compiler.  Since we have just
 * read in the compilers from compflags.txt, we can be sure that any gcc
 * compiler has gcc in the name
 * Don't add these flags to XCC, since it doesn't matter there
 */
   if (vp)
   {
      int i;
      for (i=0; i < NCOMP; i++)
      { 
         if (i == XCC_)
	    continue;
         for (p=comps[i]; p; p = p->next)
         {
            #if defined(ATL_GCCCLANG) || defined(ATL_GCC3P)
               if (strstr(p->comp, "gfortran"))
               {
                  if (!strcmp(vp, "-mavx"))
                     p->flags = NewAppendedString(p->flags, "-msse3");
                  else
                     p->flags = NewAppendedString(p->flags, vp);
               }
               else if (strstr(p->comp, "gcc"))
                  p->flags = NewAppendedString(p->flags, vp);
            #else
               if (strstr(p->comp, "gcc") || strstr(p->comp, "gfortran") ||
                   strstr(p->comp, "clang"))
                  p->flags = NewAppendedString(p->flags, vp);
            #endif
         }
      }
   }
/*
 * Add appropriate ISA extension flags to all compilers except XCC
 */
   return(comps);
}

int CompTest(int verb, char *targ, int icomp, char *comp, char *flag)
/*
 * Tries to build simple program and run it.
 * RETURNS: 0: success: non-zero on error
 */
{
   char *cmnd, *res, *frm, *trg;
   int i, iret=1;

   if (targ)
   {
      i = 32 + strlen(targ);
      trg = malloc(i*sizeof(char));
      assert(trg);
      sprintf(trg, "atlrun=atlas_runX targ=%s ", targ);
   }
   else
   {
      trg = malloc(sizeof(char));
      assert(trg);
      trg[0] = '\0';
   }
   if (icomp == F77_)
      frm = "make IRunF77Comp F77='%s' F77FLAGS='%s' %s | fgrep SUCCESS";
   else if (icomp == XCC_)
   {
      targ = NULL;
      frm = "make IRunXCComp CC='%s' CCFLAGS='%s' %s | fgrep SUCCESS";
   }
   else
      frm = "make IRunCComp CC='%s' CCFLAGS='%s' %s | fgrep SUCCESS";
   i = 1 + strlen(frm) + strlen(comp) + strlen(flag) + strlen(trg);
   cmnd = malloc(sizeof(char)*i);
   assert(cmnd);
   sprintf(cmnd, frm, comp, flag, trg);
   free(trg);
   res = atlsys_1L(NULL, cmnd, verb, 0);
   if (res)
   {
      iret = !strstr(res, "SUCCESS");
      free(res);
   }
   if (verb > 1)
      fprintf(stderr, "cmnd=%s\n", cmnd);
   free(cmnd);
   if (verb)
      fprintf(stderr, "   %s %s : %s!\n", comp, flag, 
              iret ? "FAILURE":"SUCCESS");
   return(iret);
}

void CompError(int icomp)
/*
 * Prints out informative error message when we die because a compiler doesn't
 * work
 */
{
   fprintf(stderr, "\n\nUnable to find usable compiler for %s; aborting", 
           COMPNAME[icomp]);
   fprintf(stderr, "Make sure compilers are in your path, and specify good compilers to configure\n");
   fprintf(stderr, 
           "(see INSTALL.txt or 'configure --help' for details)");
   exit(icomp+1);
}

@ROUT probe_comp getptrbits
char *GetPtrbitsFlag(enum OSTYPE OS, enum MACHTYPE arch, int ptrbits, 
                     char *comp)
/*
 * RETURNS: string forcing setting of ptrbits for gcc
 */
{
   char *sp = "";
   int i, j, k;

   if (MachIsIA64(arch))
      return(sp);
   if (MachIsMIPS(arch))
      return((ptrbits == 64) ? "-mabi=64" : "-mabi=n32");
   if (MachIsS390(arch))
      return((ptrbits == 64) ? "-m64" : "-m31");
   if (!CompIsGcc(comp))
   {
/*
 *    Add correct 64/32 bit flags for Sun workshop compilers
 */
      if (MachIsUS(arch) && CompIsSunWorkshop(comp))
      {
         if (ptrbits == 64)
            sp = (arch == SunUSI || arch == SunUSII) ? 
                 "-xarch=v9" : "-xarch=v9b";
         else
            sp = (arch == SunUSI || arch == SunUSII) ? 
                 "-xarch=v8plusa" : "-xarch=v8plusb";
      }
      else if (CompIsIBMXL(comp))  /* IBM xl compilers */
         sp = (ptrbits == 64) ? "-q64" : "-q32";
      return(sp);
   }
   GetGccVers(comp, &k, &j, &k, &k);
   if ( !(j >= 3 && (OS != OSOSX || j > 3 || !CompIsAppleGcc(comp))) )
      return(sp);
@beginskip
   {
      if (OS == OSIRIX)
         sp = (ptrbits == 64) ? "-mabi=64" : "-mabi=32";
      else
         sp = (ptrbits == 64) ? "-mips64" : "-mips32";
   }
@endskip
@skip   else if (MachIsPPC(arch))
@skip      sp = (ptrbits == 64) ? "-mpowerpc64" : "-mpowerpc -mno-powerpc64";
   else if (OS == OSAIX)
      sp = (ptrbits == 64) ? "-maix64" : "-maix32";
   else if ((MachIsX86(arch) || MachIsPPC(arch) || MachIsUS(arch)) ||
            MachIsPWR(arch))
   {
      if (ptrbits == 64)
         sp = "-m64";
      else if (ptrbits == 32)
         sp = "-m32";
      else if (ptrbits == -32)
         sp = "-mx32";
   }
   return(sp);
}
@ROUT getptrbits
  @endextract
@ROUT probe_comp
char *GetStandardCompName(char *comp, int f77)
{
   int i, j, k;
   char *ucomp;
/*
 * Recognize gnu compiler regardless of name string (eg. ev6-gcc-3.2)
 */
   if (CompIsGcc(comp))
   {
      GetGccVers(comp, &k, &j, &k, &k);
      if (j < 4)
         ucomp = (f77) ? "g77" : "gcc";
      else
         ucomp = (f77) ? "gfortran" : "gcc";
   }
   else if (CompIsClang(comp))
      ucomp = (f77) ? "gfortran" : "clang";
   else
      ucomp = NameWithoutPath(comp);
   return(ucomp);
}

char *GetWinComp(enum OSTYPE OS, char *comp, char *bindir, int if77)
{
   char *ln;
   char *ucomp;
   int i;
   if (!OSIsWin(OS))
      return(NULL);
   ucomp = GetStandardCompName(comp, if77);
   if (!strcmp(ucomp, "icc") || !strcmp(ucomp, "icl"))
      ucomp = "ATLwin_icc";
   else if (!strcmp(ucomp, "ifort") || !strcmp(ucomp, "ivf"))
      ucomp = "ATLwin_ifort";
   else if (!strcmp(ucomp, "mvc") || !strcmp(ucomp, "cl"))
      ucomp = "ATLwin_cl";
   else /* not a recognized windows compiler that needs wrapping, done */
      return(NULL);
   i = strlen(bindir);
   ln = malloc(i+16+strlen(ucomp));
   assert(ln);
   sprintf(ln, "make %s/%s.exe", bindir, ucomp);
   if (system(ln))
   {
      fprintf(stderr, "Unable to to build %s, quitting\n", ucomp);
      fprintf(stderr, "cmnd='%s'\n", ln);
      free(ln);
      exit(-1);
   }
   sprintf(ln, "%s/%s", bindir, ucomp);
   return(ln);
}

@beginskip
COMPNODE *WinnowBadComps
(
   int verb,           /* verbosity */
   COMPNODE *bc,       /* queue of compilers to try */
   char **usrcomps,    /* user overrides for comp flags and appended flags */
   char *mgwd,         /* non-NULL if are wrapping 64-bit MinGW comps */
   char *mgwf,         /* C MinGW wrapper */
   char *mgwc,         /* C MinGW wrapper */
)
/*
 * This routine takes a queue of COMPNODEs, and gets rid of all those
 * compilers that don't pass our test using the flags specified in usrcomps
 * or defaults in COMPNODE
 */
{
   COMPNODE *p, *prev;
   prev = p = bc;

   if (verb)
      printf("Testing all discovered compilers:\n");
   while (p)
   {
      char *flg, *sp;
      flg = NewStringCopy(usrcomps[NCOMP+i]?usrcomps[NCOMP+i]:p->flags);
      if (usrcomps[NCOMP*2+i])
         flg = NewAppendedString(flg, usrcomps[NCOMP*2+i]);
      sp = GetWinComp(OS, p->comp, (i==F77_));  /* non-MinGW Windows comp wrapper */
      if (!sp) 
      {
/*
 *       If mgwd is set, we must substitute MinGW wrap comps for gcc and
 *       gfortran
 */
         if (mgwd && i != XCC_)
         {
            if (CompIsGcc(p->comp))
            {
               if (strstr(p->comp, "fortran") || strstr(p->comp, "f77"))
                  sp = mgwf;
               else 
                  sp = mgwc;
            }
            else
               sp = p->comp;
         }
         else
            sp = p->comp;
      }
      if (ptrbits)
      {
         if (OS == OSWin64 && ptrbits == 64 && i == XCC_)
            flg = NewAppendedString(flg, "-m32");
         else
            flg = NewAppendedString(flg, GetPtrbitsFlag(OS, arch, ptrbits, sp));
      }
      if (sp == mgwf)
         flg = NewAppendedString(flg, "-static");
      if (CompTest(verb, targ, i, sp, flg))  /* did not work! */
      {
         if (verb)
            printf("   FAILED: '%s %s'\n", sp, flg);
         if (p == bc)
            p = bc = KillCompNode(bc);
         else
         {
            prev->next = p->next;
            p = KillCompNode(p);
         }
         break;
      }
      else  /* compiler works, retain it */
      {
         if (verb)
            printf("   'RETAINED: %s %s'\n", sp, flg);
         prev = p;
         p = p->next;
      }
      free(flg);
   }
   return(bc);
}
@endskip

int ReadMinGW(int ptrbits, int nof77,
              char **mgar, char **mgran, char **mgc, char **mgf)
/*
 * Reads MinGW library building tools from file MinGW[32,64].dat, of form:
 * <MinGW ar>
 * <MinGW ranlib>
 * <MinGW gcc>
 * <MinGW gfortran>
 * RETURNS: 1 if file exists, otherwise 0.
 */
{
   FILE *fpin;

   if (ptrbits == 64)
      fpin = fopen("MinGW64.dat", "r");
   else
      fpin = fopen("MinGW32.dat", "r");
   if (!fpin)
      return(0);
   *mgar = ATL_fgetln(fpin);
   *mgran = ATL_fgetln(fpin);
   *mgc = ATL_fgetln(fpin);
   *mgf = ATL_fgetln(fpin);
   if (!nof77)
      assert(*mgf);
   assert(*mgar && *mgran && *mgc);
   return(1);
}

void FindMinGW(int verb, int ptrbits, int nof77,
               char **mgar, char **mgran, char **mgc, char **mgf)
/*
 * Searches for MinGW compilers using cygwin's standard name/path on 06/11/2012
 */
{
   const char *pref = (ptrbits == 64) ? "/usr/bin/x86_64-w64-mingw32-" : 
                                        "/usr/bin/i686-w64-mingw32-";
   char ln[64], *res, *cmnd;
   sprintf(ln, "ls -1 %sgcc-4*", pref);
   res = atlsys_1L(NULL, ln, verb, 1);
   if (!res)
   {
      sprintf(ln, "ls %sgcc.exe", pref);
      res = atlsys_1L(NULL, ln, verb, 1);
   }
   if (!res)
   {
      fprintf(stderr,
              "Cannot find MinGW gcc in /usr/bin, with names beginning with\n");
      fprintf(stderr,
              "%s* ; Make sure MinGW is installed, then try again.\n", pref);
      fprintf(stderr,
      "If your MinGW compiler not named like this, specify them using file\n");
      exit(-1);
   }
   *mgc = res;
   if (!nof77)
   {
      sprintf(ln, "ls -1 %sgfortran*", pref);
      res = atlsys_1L(NULL, ln, verb, 1);
      if (!res)
      {
         fprintf(stderr, "MinGW gfortran not found!\n");
         exit(-1);
      }
      *mgf = res;
   }
   else
      *mgf = NULL;
   sprintf(ln, "ls -1 %sar.exe", pref);
   res = atlsys_1L(NULL, ln, verb, 1);
   if (!res)
   {
      fprintf(stderr, "MinGW ar not found!\n");
      exit(-1);
   }
   *mgar = res;

   sprintf(ln, "ls -1 %sranlib.exe", pref);
   res = atlsys_1L(NULL, ln, verb, 1);
   if (!res)
   {
      fprintf(stderr, "MinGW ranlib not found!\n");
      exit(-1);
   }
   *mgran = res;
}

char *BuildMinGW(int verb, int ptrbits, int nof77, 
                 char *mgar, char *mgran, char *mgc, char *mgf)
/* 
 * Build the MinGW wrappers using the provided MinGW tool path/names
 * RETURNS: fully qualified path to BLDdir, where MinGW wrappers are built
 */
{
   char *cmnd, *mgwd;
   int mlen, i;
   mgwd = atlsys_1L(NULL, "pwd", verb, 1);
   assert(mgwd);
   mlen = strlen(mgar);
   i = strlen(mgran);
   mlen = (mlen >= i) ? mlen : i;
   i = strlen(mgc);
   mlen = (mlen >= i) ? mlen : i;
   if (mgf)
   {
      i = strlen(mgc);
      mlen = (mlen >= i) ? mlen : i;
   }
   cmnd = malloc((mlen+32)*sizeof(char));
   assert(cmnd);

   sprintf(cmnd, "make mgwar cmppath=%s", mgar);
   syschk(cmnd);

   sprintf(cmnd, "make mgwranlib cmppath=%s", mgran);
   syschk(cmnd);

   sprintf(cmnd, "make mgwgcc cmppath=%s", mgc);
   syschk(cmnd);

   if (mgf)
   {
      sprintf(cmnd, "make mgwgfortran cmppath=%s", mgf);
      syschk(cmnd);
   }
   return(mgwd);
}

char *SetupMinGW(int verb, int ptrbits, int nof77)
/*
 * RETURNS: BLDdir, where MinGW tools have been built
 */
{
   char *mgar=NULL, *mgran=NULL, *mgc=NULL, *mgf=NULL, *mgd;
   if (!ReadMinGW(ptrbits, nof77, &mgar, &mgran, &mgc, &mgf))
      FindMinGW(verb, ptrbits, nof77, &mgar, &mgran, &mgc, &mgf);
   mgd = BuildMinGW(verb, ptrbits, nof77, mgar, mgran, mgc, mgf);
   free(mgar);
   free(mgran);
   free(mgc);
   if (mgf)
      free(mgf);
   return(mgd);
}

void GetComps(enum OSTYPE OS, enum MACHTYPE arch, int verb, char *targ,
              int ptrbits, char **usrcomps, int nof77, int nocygwin, int vecext,
              char *goodgcc, char *bindir)
/*
 * This routine gives config a list of compilers to use.  The first NCOMP
 * entries in usrcomps indicate a user override of the default compiler,
 * and the next NCOMP entries indicate user override of flags.  The next
 * NCOMP entries indicate that those flags should be appended to prior flags.
 * A NULL in any entry says the user is happy to use the defaults (or no
 * appending).  Chosen compilers and flags are returned in usrcomps array.
 */
{
   COMPNODE **comps, *p;
   char *ucomp, *dcomp, *flg, *sp, *sp2, *mgwd=NULL, *mgwc=NULL, *mgwf=NULL;
   char *cmnd, *res;
   int i, j, k, h;
   const int WIN64_32 = (OS == OSWin64 && ptrbits == 32);
/*
 * Look through input compilers; any of them that is simply "gcc" gets replaced
 * with goodgcc;  If user has overridden with path or specific name (gcc-4) 
 * leave it at his choice
 */
   for (i=0; i < NCOMP; i++)
   {
      if (usrcomps[i])
      {
         if (!strcmp(usrcomps[i], "gcc") && goodgcc)
	 {
	    free(usrcomps[i]);
	    usrcomps[i] = NewStringCopy(goodgcc);
	 }
      }
   }

/* 
 * If the user requests MinGW install build wrapper code
 */
   if (nocygwin)
   {
      int fndit;
      mgwd = SetupMinGW(verb, ptrbits, nof77);
      i = strlen(mgwd);
      mgwc = malloc(sizeof(char)*(i+7+1));
      assert(mgwc);
      sprintf(mgwc, "%s/mgwgcc", mgwd);
      mgwf = malloc(sizeof(char)*(i+12+1));
      assert(mgwf);
      sprintf(mgwf, "%s/mgwgfortran", mgwd);
   }
@beginskip
/*
 * If on Win64, build MinGW compiler wrappers. 
 * Look in /usr/bin/ for standard cygwin names for the cygwin compilers
 */
   if (OS == OSWin64 && ptrbits == 64)
   {
      int fndit;
      mgwd = SetupMinGW(verb, ptrbits, nof77)
      i = strlen(mgwd);
      mgwc = malloc(sizeof(char)*(i+7+1));
      assert(mgwc);
      sprintf(mgwc, "%s/mgwgcc", mgwd);
      mgwf = malloc(sizeof(char)*(i+12+1));
      assert(mgwf);
      sprintf(mgwf, "%s/mgwgfortran", mgwd);
/*
 *    Get the present directory, which is BLDdir, to have full path to
 *    MinGW compiler wrappers
 */
      mgwd = atlsys_1L(NULL, "pwd", verb, 1);
      assert(mgwd);
      res = atlsys_1L(targ, "ls /usr/bin/x86_64-w64-mingw32-gcc-4*", verb, 1);
      if (!res)
         res = atlsys_1L(targ, "ls /usr/bin/x86_64-w64-mingw32-gcc.exe", 
                         verb, 1);
      
      if (!res)
      {
         fprintf(stderr, 
"Cannot find MinGW compilers in /usr/bin, with names beginning with\n");
         fprintf(stderr, 
"x86_64-w64-mingw32* ; Make sure they are installed, then try again.\n");
         fprintf(stderr, 
"If your MinGW compiler not named like this, make symbolic link in /usr/bin\n");
         fprintf(stderr, 
"eg., ln -s /my/comp /usr/bin/x86_64-w64-mingw32-gcc-4.exe\n");
         exit(-1);
      }
      i = 22 + strlen(res);
      cmnd = malloc(i*sizeof(char));
      assert(cmnd);
      sprintf(cmnd, "make mgwgcc cmppath=%s", res);  /* build C comp */
      syschk(cmnd);
      free(cmnd);
      i = strlen(mgwd);
      mgwc = malloc(sizeof(char)*(i+7+1));
      assert(mgwc);
      sprintf(mgwc, "%s/mgwgcc", mgwd);
/*
 *    Build the wrapper for ar and ranlib
 */
      res = atlsys_1L(targ, "ls /usr/bin/x86_64-w64-mingw32-ar.exe", verb, 1);
      assert(res);
      i = 21 + strlen(res);
      cmnd = malloc(i*sizeof(char));
      assert(cmnd);
      sprintf(cmnd, "make mgwar cmppath=%s", res);  /* build ar wrapper */
      syschk(cmnd);
      free(cmnd);
      res = atlsys_1L(NULL, "ls /usr/bin/x86_64-w64-mingw32-ranlib.exe", 
                      verb, 1);
      assert(res);
      i = 24 + strlen(res);
      cmnd = malloc(i*sizeof(char));
      assert(cmnd);
      sprintf(cmnd, "make mgwranlib cmppath=%s", res);  /* build ar wrapper */
      free(res);
      syschk(cmnd);
      free(cmnd);
/*
/*
 *    Build the gfortran wrapper unless doing an all-C install
 */
      if (!nof77)
      {
         res = atlsys_1L(NULL, "ls /usr/bin/x86_64-w64-mingw32-gfortran*",
                         verb, 1);
         if (!res)
         {
            fprintf(stderr, "MinGW gfortran not found!\n");
            exit(-1);
         }
         i = strlen(res);
         cmnd = malloc((i+28)*sizeof(char));
         assert(cmnd);
         sprintf(cmnd, "make mgwgfortran cmppath=%s", res);
         free(res);
         syschk(cmnd);
         free(cmnd);
         i = strlen(mgwd);
         mgwf = malloc(sizeof(char)*(i+12+1));
         assert(mgwf);
         sprintf(mgwf, "%s/mgwgfortran", mgwd);
      }
   }
@endskip
/*
 * Get the ATLAS-suggested compilers and flags
 */
   comps = GetDefaultComps(OS, arch, verb, vecext);
/*
 * Look through comps, and substitute any "gcc" with goodgcc
 */
   if (goodgcc)
   {
      for (i=0; i < NCOMP; i++)
      {
         for (p=comps[i]; p; p = p->next)
         {
            if (!strcmp(p->comp, "gcc"))
            {
               free(p->comp);
               p->comp = NewStringCopy(goodgcc);
            }
         }
      }
   }
   if (verb > 1)
      fprintf(stdout, "Finding good compilers:\n");
   for (i=0; i < NCOMP; i++)
   {
      if (nof77 && i == F77_) continue;
/*
 *    If the user has not specified the compiler, look through all available
 *    compilers with one that works (with user flags, if specified)
 */
      if (!usrcomps[i])
      {
         for (p=comps[i]; p; p = p->next)
         {
            char *freeme=NULL;
            flg = NewStringCopy(usrcomps[NCOMP+i]?usrcomps[NCOMP+i]:p->flags);
            if (usrcomps[NCOMP*2+i])
               flg = NewAppendedString(flg, usrcomps[NCOMP*2+i]);
            freeme = sp = GetWinComp(OS, p->comp, bindir, (i==F77_));
            if (!sp) 
            {
/*
 *             If mgwd is set, we must substitute MinGW wrap comps for gcc and
 *             gfortran
 */
               if (mgwd && i != XCC_)
               {
                  if (CompIsGcc(p->comp))
                  {
                     if (strstr(p->comp, "fortran") || strstr(p->comp, "f77"))
                        sp = mgwf;
                     else 
                        sp = mgwc;
                  }
                  else
                     sp = p->comp;
               }
               else
                  sp = p->comp;
            }
            if (ptrbits && (!WIN64_32 || i != XCC_))
            {
               flg = NewAppendedString(flg, 
                        GetPtrbitsFlag(OS, arch, ptrbits, sp));
            }
            if (sp == mgwf)
               flg = NewAppendedString(flg, "-static");
            if (!CompTest(verb, targ, i, sp, flg))
               break;
            free(flg);
            if (freeme)
               free(freeme);
         }                              /* end loop over compilers */
         if (!p)
            CompError(i);
         else
            free(flg);
	 if (mgwd)
	    usrcomps[i] = NewStringCopy(sp);
         else if (i == GCC_ || !strcmp(p->comp, "gcc"))
	    usrcomps[i] = goodgcc ? NewStringCopy(goodgcc) : "gcc";
	 else
	 {
	    usrcomps[i] = p->comp;
            p->comp = NULL;                /* so it isn't deleted by Kill */
	 }
         if (!usrcomps[NCOMP+i])
         {
            usrcomps[NCOMP+i] = p->flags;
            p->flags = NULL;            /* so it isn't deleted by Kill */
         }
      }  
/*
 *    If user specified comp w/o flags, get default flags or error 
 */
      else if (!usrcomps[NCOMP+i])
      {
         p = comps[i];
         ucomp = GetStandardCompName(usrcomps[i], (i==F77_));
@beginskip
         ucomp = NameWithoutPath(usrcomps[i]);
/*
 *       Recognize gnu compiler regardless of name string (eg. ev6-gcc-3.2)
 */
         if (CompIsGcc(usrcomps[i]))
         {
            GetGccVers(usrcomps[i], &k, &j, &k, &k);
            if (j < 4)
            {
               if (i == F77_)
                  ucomp = "g77";
               else
                  ucomp = "gcc";
            }
            else if (i == F77_)
               ucomp = "gfortran";
            else
               ucomp = goodgcc;
         }
@endskip
         for (p=comps[i]; p; p = p->next)
         {
            dcomp = NameWithoutPath(p->comp);
            if (!strcmp(p->comp, ucomp))
               break;
            free(dcomp);
         }
         if (!p)
         {
            fprintf(stderr, 
               "UNKNOWN COMPILER '%s' for %s: you must also supply flags!\n",
                    usrcomps[i], COMPNAME[i]);
            exit(i+1);
         }
         usrcomps[NCOMP+i] = p->flags;
         p->flags = NULL;
      } /* If user specifed both flags and compiler, accept them */
/*
 *    On windows, build compiler wrapper for MSVC++ or Intel compilers
 */
      sp = GetWinComp(OS, usrcomps[i], bindir, (i==F77_));
      if (sp)
      {
         free(usrcomps[i]);
         usrcomps[i] = sp;
      }
/*
 *    Test selected compiler and flags, and die if they don't work
 */
      flg = NewStringCopy(usrcomps[NCOMP+i]?usrcomps[NCOMP+i]:p->flags);
      if (usrcomps[NCOMP*2+i])
         flg = NewAppendedString(flg, usrcomps[NCOMP*2+i]);
      if (ptrbits && (!WIN64_32 || i != XCC_))
      {
@skip         if (OS == OSWin64 && ptrbits == 64 && i == XCC_)
@skip            flg = NewAppendedString(flg, "-m32");
@skip         else
         flg = NewAppendedString(flg, 
                  GetPtrbitsFlag(OS, arch, ptrbits,usrcomps[i]));
      }
      if (strstr(usrcomps[i], "mgwgfortran"))
         flg = NewAppendedString(flg, "-static");
      if (CompTest(verb, targ, i, usrcomps[i], flg))
         CompError(i);
      free(flg);
   } /* end of loop over compilers */
   for (i=0; i < NCOMP; i++)
      KillAllCompNodes(comps[i]);
   free(comps);
/*
 * modify base flags by appending user flags
 */
   for (i=2*NCOMP; i < 3*NCOMP; i++)
   {
      if (usrcomps[i])  /* user has appended flags for compiler i-2*NCOMP */
         usrcomps[i-NCOMP] = NewAppendedString(usrcomps[i-NCOMP], usrcomps[i]);
   }
/*
 * If nof77, set fortran compiler & flags to ICC to avoid linking problems
 */
   if (nof77)
   {
      usrcomps[F77_] = NewStringCopy(usrcomps[ICC_]);
      usrcomps[F77_+NCOMP] = NewStringCopy(usrcomps[ICC_+NCOMP]);
   }
/*
 * If ptrbits is set to manual override, add -m32/64 to gnu compilers
 * but not on Itaniums or Apple's munged gcc 3 compiler!
 */
   if (ptrbits && arch != IA64Itan && arch != IA64Itan2)
   {
      for (i=0; i < NCOMP; i++)
      {
         sp = GetPtrbitsFlag(OS, arch, ptrbits, usrcomps[i]);
@skip         if (OS == OSWin64 && ptrbits == 64 && i == XCC_)
@skip            usrcomps[i+NCOMP] = NewAppendedString(usrcomps[i+NCOMP], "-m32");
@skip         else
         usrcomps[i+NCOMP] = NewAppendedString(usrcomps[i+NCOMP], sp);
      }
   }
/*
 * Add -static to mgmfortran 
 */
   if (OSIsWin(OS) && ptrbits == 64)
   {
      if (strstr(usrcomps[i], "mgwgfortran"))
         usrcomps[F77_+NCOMP] = NewAppendedString(usrcomps[F77_+NCOMP], 
                                               " -static");
   }
/*
 * On windows, add required -mstackrealign to all gnu comps,
 * since gcc breaks the x86 ABI by default.
 */
   if (OSIsWin(OS) && ptrbits != 64)
   {
      for (i=0; i < NCOMP; i++)
      {
         if (i != F77_ && CompIsGcc(usrcomps[i]))
            usrcomps[i+NCOMP] = NewAppendedString(usrcomps[i+NCOMP], 
                                                  " -mstackrealign");
      }
   }
/*
 * Need to add target & bitwidth args for MIPSpro compilers on IRIX
 */
   if (OS == OSIRIX)
   {
      char *fnd;
      fnd = FindUname(targ);
      i = strlen(fnd) + 4;
      cmnd = malloc(sizeof(char)*i);
      assert(cmnd);
      sprintf(cmnd, "%s -m", fnd);
      res = atlsys_1L(NULL, cmnd, verb, 1);
      free(cmnd);
      assert(res);
      sp = strstr(res, "IP");
      assert(sp);
      for (i=2; isdigit(sp[i]); i++);
      sp[i] = '\0';
      i = strlen(sp) + 20;
      cmnd = malloc(sizeof(char)*i);
      assert(cmnd);
      sprintf(cmnd, "-TARG:platform=%s", sp);
      if (ptrbits == 64 || !ptrbits)
         strcat(cmnd, " -64");
      else
         strcat(cmnd, " -32");
      for (i=0; i < NCOMP; i++)
      {
         if (CompIsMIPSpro(usrcomps[i]))
         {
            usrcomps[i+NCOMP] = NewAppendedString(usrcomps[i+NCOMP], cmnd);
         }
      }
      free(res);
      free(cmnd);
   }
}  /* end of routine GetComps */ 

int NameIsExactGcc(char *nam)
{
   int k, ls=(-1);  /* last slash found starts at not found */
   for (k=0; nam[k]; k++)
      if (nam[k] == '/')
         ls = k+1;
   if (k-ls == 3)
   {
      if (nam[ls] == 'g' && nam[ls+1] == 'c' && nam[ls+2] == 'c')
         return(1);
   }               
   return(0);
}

int SelectBestGcc
(
   int verb,
   char *targ,
   int GMAJOR,
   int GMINOR,
   char **gccs,  /* NULL-terminated list of possible gcc compilers */
   int USEMINGW  /* 0/1: reject/accept MINGW compilers */
)
/*
 * RETURNS: 0 if no gcc compiler,
 *          -i if ith compiler is best compiler we found
 *          i if ith compiler is gnu gcc with matching major & minor
 */
{
   int ibest=0, igood=0, ileastbad=0, ibgcc=0, iggcc=0;
   int gmaj=0, gmin=0, lmaj=0, lmin=0, i;
   if (!gccs)
      return(0);

   for (i=0; gccs[i]; i++)
   {
      int icmp, major, minor, patch;
      if (!USEMINGW && CompIsMinGW(gccs[i]))
         continue;
      GetGccVers(gccs[i], &icmp, &major, &minor, &patch);
      if (verb)
         printf("   icmp=%d, maj=%d, min=%d, pat=%d: %s\n", 
                icmp, major, minor, patch, gccs[i]);
      if (major == GMAJOR && minor == GMINOR)
      {
         if (!CompTest(verb, targ, GCC_, gccs[i], "-O"))
         {
            if (CompIsMinGW(gccs[i]) || CompIsAppleGcc(gccs[i]))
               ibest = i+1;
            else if (!CompTest(verb, targ, GCC_, gccs[i], "-O"))
            {
               if (NameIsExactGcc(gccs[i]))
                  return(i+1);
               ibest = i+1;
            }
         }
      }
      else if (major == GMAJOR && minor >= GMINOR && !ibest)
      {
         if (!CompTest(verb, targ, GCC_, gccs[i], "-O"))
         {
            ibest = i+1;
            if (NameIsExactGcc(gccs[i]))
               ibgcc = i+1;
         }
      }
      else if (major == GMAJOR)
      {
         if (major > gmaj || (major == gmaj && minor > gmin))
	 {
            if (!CompTest(verb, targ, GCC_, gccs[i], "-O"))
	    {
               igood = i+1;
               if (NameIsExactGcc(gccs[i]))
                  iggcc = i+1;
	       gmaj = major;
	       gmin = minor;
	    }
         }
      }
      else if (major > lmaj || (major == lmaj && minor > lmin))
      {
         if (!CompTest(verb, targ, GCC_, gccs[i], "-O"))
	 {
            ileastbad = i+1;
	    lmaj = major;
	    lmin = minor;
         }
      }
   }
   if (ibgcc)
      return(ibgcc);
   if (ibest)
      return(ibest);
   if (iggcc)
      return(-iggcc);
   if (igood)
      return(-igood);
   return(-ileastbad);
}


char *CheckStrLen(char *str, int *len, int reqlen)
{
   if (*len < reqlen)
   {
      free(str);
      str = malloc(reqlen*sizeof(char));
      *len = reqlen;
   }
   return(str);
}

void GetBestGccVers(enum OSTYPE OS, enum MACHTYPE arch, 
                    int *GMAJOR, int *GMINOR, int *GPATCH)
{
   *GMAJOR = 4;
   switch(arch)
   {
   case IbmZ12:
   case IbmZ13:
   case IntCorei3:
   case IntCorei3EP:
   case IntCorei4:
   case IntCorei2:
   case Amd64K10h:
      *GMAJOR = 6;
      *GMINOR = 1;
      *GPATCH = 0;
      break;
   case PPCG4:          /* cannot install 4.7.0 */
   case PPCG5:          /* cannot install 4.7.0 */
   case SunUSII:        /* cannot install 4.7.0 */
   case IntPIII:
   case IntPPRO:        /* no longer have access */
   case IntAtom:
      *GMINOR = 6;
      *GPATCH = 2;
      break;
   case ARM64xg:
      *GMAJOR = 5;
      *GMINOR = 3;
      *GPATCH = 0;
      break;
   case IbmPwr8:
       *GMAJOR = 5;
       *GMINOR = 3;
       *GPATCH = 0;
       break;
   case IbmPwr7:
       *GMAJOR = 5;
       *GMINOR = 1;
       *GPATCH = 0;
       break;
   case ARM7:
       *GMAJOR = 4;
       *GMINOR = 9;
       *GPATCH = 2;
       break;
   case ARM9:
       *GMAJOR = 4;
       *GMINOR = 6;
       *GPATCH = 3;
       break;
   case ARM15:
       *GMAJOR = 4;
       *GMINOR = 8;
       *GPATCH = 4;
       break;
   case x86SSE1:
   case x86SSE2:
   case x86SSE3:
   case x86x87:
   case IntCore2:
   case IntCorei1:
   default:
      *GMINOR = 7;
      *GPATCH = 0;
      break;
   }
}
char *FindGoodGcc(enum OSTYPE OS, enum MACHTYPE arch, int verb, char *targ,
                  int USEMINGW)
{
   char *OSpaths=NULL, *sp, **gccs=NULL;
   char *ln;
   FILE *fp;
   int i, lnlen=1024;
   int GMAJOR, GMINOR, GPATCH;

   if (arch == IntPhi)  /* Xeon PHI uses icc for everything, inc gcc */
      return(NewStringCopy("icc"));

   GetBestGccVers(OS, arch, &GMAJOR, &GMINOR, &GPATCH);
   ln = malloc(lnlen*sizeof(char));
   assert(ln);
/*
 * See if we have some OS-specific places to search for good gcc
 */
   if (OS == OSOSX)  /* /sw is for fink, /opt is for macports */
   {
      OSpaths = "/sw/bin /opt/local/bin /opt/local/sbin";
   }
/*
 * We first look in any high-priority OS-specific spots for the right files
 */
   if (OSpaths)
   {
      i = 64 + strlen(OSpaths);
      ln = CheckStrLen(ln, &lnlen, i);
      sprintf(ln, "find %s -maxdepth 1 -name '*gcc*' -exec ./xisgcc '{}' \\;", 
              OSpaths);
      gccs = GetLinesFromFile(atlsys(NULL, ln, verb, 1), gccs);
      i = SelectBestGcc(verb, targ, GMAJOR, GMINOR, gccs, USEMINGW);
      if (i > 1)
      {
         free(ln);
         return(FreeListGetString(gccs, i-1));
      }
      if (i < 0)
         gccs = NewOneStringList(gccs, -(i+1));
      else
      {
         KillAllStringsInList(gccs);
	 gccs = NULL;
      }
   }
/*
 * If we are not satisfied with the places we've looked so far, 
 * try the user's path environment variables, don't search recursively
 */
   sp = GetPathEnvVar();
   if (sp)
   {
      i = 64 + strlen(sp);
      ln = CheckStrLen(ln, &lnlen, i);
      sprintf(ln, "find %s -maxdepth 1 -name '*gcc*' -exec ./xisgcc '{}' \\;", 
              sp);
      free(sp);
      fp = atlsys(NULL, ln, verb, 1);
      if (fp)
      {
         gccs = GetLinesFromFile(fp, gccs);
         i = SelectBestGcc(verb, targ, GMAJOR, GMINOR, gccs, USEMINGW);
         if (i > 0)
         {
            free(ln);
            return(FreeListGetString(gccs, i-1));
         }
         if (i < 0)
            gccs = NewOneStringList(gccs, -(i+1));
         else
         {
            KillAllStringsInList(gccs);
	    gccs = NULL;
         }
      }
   }
/*
 * Try searching in $HOME/local, including all subdirs
 */
   ln = CheckStrLen(ln, &lnlen, 64);
   sprintf(ln, "find $HOME/local -name '*gcc*' -exec ./xisgcc '{}' \\;");
   fp = atlsys(NULL, ln, verb, 1);
   if (fp)
   {
      gccs = GetLinesFromFile(fp, gccs);
      i = SelectBestGcc(verb, targ, GMAJOR, GMINOR, gccs, USEMINGW);
      if (i > 0)
      {
         free(ln);
         return(FreeListGetString(gccs, i-1));
      }
      if (i < 0)
         gccs = NewOneStringList(gccs, -(i+1));
      else
      {
         KillAllStringsInList(gccs);
         gccs = NULL;
      }
   }
/*
 * If we still haven't found it, try standard unix places, recursively searched
 */
   {
      char *stdpaths =
         "/usr/local /bin /sbin /usr/bin /usr/sbin /opt/bin /opt/sbin";

      i = 64 + strlen(stdpaths);
      ln = CheckStrLen(ln, &lnlen, i);
      i = sprintf(ln, "find %s -name '*gcc*' -exec ./xisgcc '{}' \\;",  
                  stdpaths);
      gccs = GetLinesFromFile(atlsys(NULL, ln, verb, 1), gccs);
      i = SelectBestGcc(verb, targ, GMAJOR, GMINOR, gccs, USEMINGW);
      if (i > 1)
      {
         free(ln);
         return(FreeListGetString(gccs, i-1));
      }
      if (i < 0)
      {
         free(ln);
         return(FreeListGetString(gccs, -(i+1)));
      }
      else
         KillAllStringsInList(gccs);
   }
   free(ln);
   return(NULL);
}

char *FindGoodGfortran(enum OSTYPE OS, enum MACHTYPE arch, int verb, 
                       char *targ, char *gcc, int USEMINGW)
{
   char *OSpaths=NULL, *sp, **gccs=NULL;
   char *ln;
   FILE *fp;
   int i, lnlen=1024;
   int ccomp, cmaj, cmin, cpat;

   ln = malloc(lnlen*sizeof(char));
   assert(ln);
/*
 * Get gcc's version; we'll try to find a matching gfortran
 */
   GetGccVers(gcc, &ccomp, &cmaj, &cmin, &cpat);
/*
 * See if we can find gfortran in the same place we found gcc
 */
   sp = GetPathWithoutName(gcc);  /* get path to gcc */
   if (sp)
   {
      i = 64 + strlen(sp);
      ln = CheckStrLen(ln, &lnlen, i);
      sprintf(ln, 
         "find %s -maxdepth 1 -name '*gfortran*' -exec ./xisgcc '{}' \\;", sp);
      gccs = GetLinesFromFile(atlsys(NULL, ln, verb, 1), gccs);
      i = SelectBestGcc(verb, targ, cmaj, cmin, gccs, USEMINGW);
      if (i > 1)
      {
         free(ln);
         return(FreeListGetString(gccs, i-1));
      }
      if (i < 0)
         gccs = NewOneStringList(gccs, -(i+1));
      else
      {
         KillAllStringsInList(gccs);
	 gccs = NULL;
      }
      free(sp);
   }
/*
 * See if we have some OS-specific places to search for good gcc
 */
   if (OS == OSOSX)  /* /sw is for fink, /opt is for macports */
   {
      OSpaths = "/sw/bin /opt/local/bin /opt/local/sbin";
   }
/*
 * We first look in any high-priority OS-specific spots for the right files
 */
   if (OSpaths)
   {
      i = 64 + strlen(OSpaths);
      ln = CheckStrLen(ln, &lnlen, i);
      sprintf(ln, 
         "find %s -maxdepth 1 -name '*gfortran*' -exec ./xisgcc '{}' \\;",
         OSpaths);
      gccs = GetLinesFromFile(atlsys(NULL, ln, verb, 1), gccs);
      i = SelectBestGcc(verb, targ, cmaj, cmin, gccs, USEMINGW);
      if (i > 1)
      {
         free(ln);
         return(FreeListGetString(gccs, i-1));
      }
      if (i < 0)
         gccs = NewOneStringList(gccs, -(i+1));
      else
      {
         KillAllStringsInList(gccs);
	 gccs = NULL;
      }
   }
/*
 * If we are not satisfied with the places we've looked so far, 
 * try the user's path environment variable and HOME/local
 */
   sp = GetPathEnvVar();
   if (sp)
   {
      i = 64 + strlen(sp);
      ln = CheckStrLen(ln, &lnlen, i);
      sprintf(ln, 
         "find %s -maxdepth 1 -name '*gfortran*' -exec ./xisgcc '{}' \\;", sp);
      free(sp);
      gccs = GetLinesFromFile(atlsys(NULL, ln, verb, 1), gccs);
      i = SelectBestGcc(verb, targ, cmaj, cmin, gccs, USEMINGW);
      if (i > 0)
      {
         free(ln);
         return(FreeListGetString(gccs, i-1));
      }
      if (i < 0)
         gccs = NewOneStringList(gccs, -(i+1));
      else
      {
         KillAllStringsInList(gccs);
	 gccs = NULL;
      }
   }
/*
 * Try searching in $HOME/local, including all subdir
 */
   ln = CheckStrLen(ln, &lnlen, 64);
   sprintf(ln, "find $HOME/local -name '*gfortran*' -exec ./xisgcc '{}' \\;");
   fp = atlsys(NULL, ln, verb, 1);
   if (fp)
   {
      gccs = GetLinesFromFile(fp, gccs);
      i = SelectBestGcc(verb, targ, cmaj, cmin, gccs, USEMINGW);
      if (i > 0)
      {
         free(ln);
         return(FreeListGetString(gccs, i-1));
      }
      if (i < 0)
         gccs = NewOneStringList(gccs, -(i+1));
      else
      {
         KillAllStringsInList(gccs);
         gccs = NULL;
      }
   }
/*
 * If we still haven't found it, try standard unix places
 */
   {
      char *stdpaths =
         "/usr/local /bin /sbin /usr/bin /usr/sbin /opt/bin /opt/sbin";

      i = 64 + strlen(stdpaths);
      ln = CheckStrLen(ln, &lnlen, i);
      i = sprintf(ln, "find %s -name '*gcc*' -exec ./xisgcc '{}' \\;",  
                  stdpaths);
      i = sprintf(ln, "find %s -name '*gfortran*' -exec ./xisgcc '{}' \\;", 
                   stdpaths);
      gccs = GetLinesFromFile(atlsys(NULL, ln, verb, 1), gccs);
      i = SelectBestGcc(verb, targ, cmaj, cmin, gccs, USEMINGW);
      if (i > 1)
      {
         free(ln);
         return(FreeListGetString(gccs, i-1));
      }
      if (i < 0)
      {
         free(ln);
         return(FreeListGetString(gccs, -(i+1)));
      }
      else
         KillAllStringsInList(gccs);
   }
   free(ln);
   return(NULL);
}

char *FindNamedComp(enum OSTYPE OS, enum MACHTYPE arch, int verb, 
                    char *targ, char *comp)
/*
 * This routine searches for a named compiler only in the user's path.
 * RETURNS: fully qualified name
 */
{
   char *sp, *ln=NULL, **gccs=NULL;
   int i, lcmp, lnlen=0;

   if (!comp)
      return(NULL);
/*
 * Return copy of original name if it already contains a path
 */
   for (i=0; comp[i] != '\0'; i++)
      if (comp[i] == '/')
         return(NewStringCopy(comp));
   lcmp = i;
/*
 * Otherwise, search the user's path to find which compiler to use
 */
   sp = GetPathEnvVar();
   if (sp)
   {
      i = 64 + lcmp + strlen(sp);
      ln = CheckStrLen(ln, &lnlen, i);
      sprintf(ln, "find %s -maxdepth 1 -name '%s'", sp, comp);
      free(sp);
      gccs = GetLinesFromFile(atlsys(NULL, ln, verb, 1), gccs);
      free(ln);
      for (i=0; gccs[i]; i++)
         if (strstr(gccs[i], comp))
            break;
      assert(gccs[i]);
      return(FreeListGetString(gccs, i));
   }
   return(NewStringCopy(comp));
}

void TestComps(enum OSTYPE OS, enum MACHTYPE arch, int verb, char *targ,
               char *targarg, char **comps, enum F2CNAME *f2cnam, 
               enum F2CINT *f2cint, enum F2CSTRING *f2cstr, int nof77)
/*
 * This file tests that all C compilers work and interact w/o any changes,
 * and figure out how to have the fortran compiler call the C compiler
 */
{
   char *sp;
   int i, ierr;
   if (verb)
      fprintf(stdout, "C compiler interoperation probe unimplemented!\n\n");
/* 
 * C interoperation checks
 */
   if (verb > 1)
      fprintf(stderr, "ICC interoperation tests:\n");
   for (i=0; i < NCOMP; i++)
   {
      if (i != XCC_ && i != F77_ && i != ICC_)
      {
         if (strcmp(comps[i], comps[ICC_])) /* only check if different */
         {
            char *frm = "make IRunC2C CC='%s' CCFLAGS='%s' CC1='%s' CC1FLAGS='%s' | fgrep SUCCESS";
            char *cmnd, *res;
            int j;

            j = strlen(frm) + strlen(comps[ICC_]) + strlen(comps[NCOMP+ICC_])
                + strlen(comps[i]) + strlen(comps[i+NCOMP]) + 1;
            cmnd = malloc(j*sizeof(char));
            assert(cmnd);
            sprintf(cmnd, frm,
                    comps[ICC_], comps[NCOMP+ICC_], comps[i], comps[i+NCOMP]);
            if (verb > 1)
               fprintf(stderr, "cmnd='%s'\n", cmnd);
            res = atlsys_1L(NULL, cmnd, verb, 0);
            free(cmnd);
            ierr = (res) ? !strstr(res, "SUCCESS") : 1;
            if (ierr)
            {
               fprintf(stderr, "Compiler %d (%s) does not interoperate with interface compiler (%s), aborting!\n", i, comps[i], comps[ICC_]);
               fprintf(stderr, "ierr=%d, res='%s'\n", ierr, res);
               exit(ierr);
            }
            free(res);
            if (verb > 1)
               fprintf(stderr, 
                       "   C2C %s/%s -- SUCCESS\n", comps[ICC_], comps[i]);
         }
      }
   }
/*
 * F2c tests
 */
   if (nof77)
   {
      *f2cnam = f2c_NamErr;
      *f2cint = f2c_IntErr;
      *f2cstr = f2c_StrErr;
   }
   else
   {
      char *frm, *cmnd, *res;
      int j;
      j = (strstr(comps[F77_], "mgwgfortran") != NULL);
      if (j)
         frm = "make IRun_f2c args=\"%s -C ic '%s' -F ic '%s' -C if '%s' -F if '%s -static'\" | fgrep 'F2C=('";
      else
         frm = "make IRun_f2c args=\"%s -C ic '%s' -F ic '%s' -C if '%s' -F if '%s'\" | fgrep 'F2C=('";

      j = strlen(frm) + strlen(targarg) + strlen(comps[ICC_]) +
          strlen(comps[ICC_+NCOMP]) + strlen(comps[F77_]) + 
          strlen(comps[F77_+NCOMP]) + 1;
      cmnd = malloc(j*sizeof(char));
      assert(cmnd);
      sprintf(cmnd, frm, targarg, comps[ICC_], comps[ICC_+NCOMP], 
              comps[F77_], comps[F77_+NCOMP]);
      *f2cnam = f2c_NamErr;
      *f2cint = f2c_IntErr;
      *f2cstr = f2c_StrErr;
      if (verb > 1)
         fprintf(stderr, "cmnd='%s'\n", cmnd);
      res = atlsys_1L(NULL, cmnd, verb, 0);
      free(cmnd);
      if (res)
      {
         if (verb > 1)
            fprintf(stderr, "res='%s'\n", res);
         i = sscanf(res, " F2C=(%d,%d,%d)", f2cnam, f2cint, f2cstr);
         if (verb > 1)
            fprintf(stderr, "nread=%d, f2cname=%d, f2cint=%d, f2cstr=%d\n",
                    i, *f2cnam, *f2cint, *f2cstr);
         if (i != 3)
           *f2cnam = *f2cint = *f2cstr = 0;
         free(res);
      }
      if (verb)
      {
         printf("F2C name = %s\n", f2c_namestr[*f2cnam]);
         printf("F2C int  = %s\n", f2c_intstr[*f2cint]);
         printf("F2C str  = %s\n", f2c_strstr[*f2cstr]);
      }
   }
}

void PrintCompResults(char *file, char **comps, enum F2CNAME f2cnam, 
                      enum F2CINT f2cint, enum F2CSTRING f2cstr)
{
   FILE *fpout;
   int i;

   if (file)
      fpout = fopen(file, "w");
   else fpout = stdout;
   assert(fpout);

   for (i=0; i < NCOMP; i++)
   {
      if (comps[i])
         fprintf(fpout, "%d '%s' '%s'\n", i, comps[i], comps[i+NCOMP]);
   }
   if (comps[F77_])
      fprintf(fpout, "F2CNAME,F2CINT,F2CSTRING=(%d,%d,%d)\n",
              f2cnam, f2cint, f2cstr);
   if (fpout != stdout && fpout != stderr)
      fclose(fpout);
}

@beginskip
void PrintUsage(char *name, int i)
{
   fprintf(stderr, "Error around argument %d.  USAGE:", i);
   fprintf(stderr, "%s [-O <OS> -v <verb> -A <mach> -T <targ>\n", name);
   fprintf(stderr, "   -C [xc,ic,if,sk,dk,sm,dm] <compiler>\n");
   fprintf(stderr, "   -F [xc,ic,if,sk,dk,sm,dm] '<comp flags>'\n");
   fprintf(stderr, 
           "   -Fa [xc,ic,if,sk,dk,sm,dm,al] '<comp flags to append>'\n");
   fprintf(stderr, "        al: append flags to all compilers\n");
   exit(-1);
}
@endskip

@extract -b @(basd)/atlconf.base rout=GetFlags -def -O "" -def -v "" -def -A "" -def -V "" -def -b "" -def -C "" -def -o "" -def -S "-S" -def -nof77 "-nof77" -def -d "" -def -nocygwin "-nocygwin"

int main(int nargs, char **args)
/*
 * probe_comp has the following responsibilities:
 * 1. Read in atlcomp.txt for recommended compiler and flags
 * 2. Find a GOODGCC to override generic "gcc" name and to assemble assembly codes
 * 3. If on Windows wt 64 bits, build MinGW compiler wrappers, for 64-bit comps
 * 4. Accept user override of compiler/flags
 * 5. Append any user appended flags
 * 6. Ensure all non-xcc C compilers interoperate by calling probe_ccomps
 * 7. Figure out F77/C interoperating rules by calling probe_f772c
 * 8. Printing out results of these probes for later use
 */
{
   enum OSTYPE OS;
   enum MACHTYPE mach;
   int ptrbits, verb, vecexts, i, nof77, nocygwin;
   char *usrcomps[3*NCOMP];
   char *outfile, *targ, *targarg, *goodgcc, *srcdir, *bindir;
   enum F2CNAME f2cnam;
   enum F2CINT f2cint; 
   enum F2CSTRING f2cstr;

   GetFlags(nargs, args, &verb, &OS, &vecexts, &mach, &ptrbits, usrcomps, 
            &outfile, &srcdir, &bindir, &i, &targ);
   nof77 = SI_IS_TRUE(i,SI_NOF77);
   nocygwin = SI_IS_TRUE(i,SI_NOCYGWIN);
/*
 * Fully qualify any usr-override compilers
 */
   for (i=0; i < NCOMP; i++)
   {
      if (usrcomps[i])
      {
         char *sp = usrcomps[i];
         usrcomps[i] = FindNamedComp(OS, mach, verb, targ, sp);
         free(sp);
      }
   }
   if (verb > 1)
   {
      fprintf(stdout, "User Override Compilers:\n");
      for (i=0; i < NCOMP; i++)
         fprintf(stdout, "   '%s' : '%s' '%s'\n", 
            usrcomps[i] ? usrcomps[i]:"none", 
            usrcomps[i+NCOMP] ? usrcomps[i+NCOMP]:"none", 
            usrcomps[i+2*NCOMP] ? usrcomps[i+2*NCOMP]:"none");
      fprintf(stdout, "\n");
   }
   if (targ)
   {
      targarg = malloc(sizeof(char)*(strlen(targ)+24));
      assert(targarg);
      sprintf(targarg, "-T '%s'", targ);
   }
   else
      targarg = "";
   #if defined(ATL_GCCCLANG) || defined(ATL_GCC3P)
   {
      char *topd;
      int dlen;
      topd = atlsys_1L(NULL, "pwd", verb, 1);
      assert(topd);
      dlen = strlen(topd);
      goodgcc = malloc(dlen + 10);
      assert(goodgcc);
      #ifdef ATL_GCCCLANG
         sprintf(goodgcc, "%s/gccclang", topd);
      #else
         sprintf(goodgcc, "%s/gcc3p", topd);
      #endif
      free(topd);
   }
   #else
      if (usrcomps[GCC_])
         goodgcc = NewStringCopy(usrcomps[GCC_]);
      else if (mach == IntPhi)
         goodgcc = NewStringCopy("icc");
      else
         goodgcc = FindGoodGcc(OS, mach,  verb, targ, nocygwin);
   #endif
   GetComps(OS, mach, verb, targ, ptrbits, usrcomps, nof77, nocygwin, vecexts, 
            goodgcc, bindir);
/* 
 * See if we need to search for gfortran
 */
   if (!nof77 && usrcomps[F77_] && !strcmp(usrcomps[F77_], "gfortran"))
   {
      free(usrcomps[F77_]);
      usrcomps[F77_] = FindGoodGfortran(OS, mach, verb, targ, goodgcc,nocygwin);
      if (!usrcomps[F77_])
         usrcomps[F77_] = NewStringCopy("gfortran");
   }
   free(goodgcc);
   TestComps(OS, mach, verb, targ, targarg, usrcomps, 
             &f2cnam, &f2cint, &f2cstr, nof77);
   if (verb)
   {
      fprintf(stdout, "Compilers:\n");
      for (i=0; i < NCOMP; i++)
         fprintf(stdout, "   '%s' : '%s'\n", usrcomps[i], usrcomps[NCOMP+i]);
      fprintf(stdout, "\n");
   }
   PrintCompResults(outfile, usrcomps,  f2cnam, f2cint, f2cstr);
   for (i=0; i < 3*NCOMP; i++)
      if (usrcomps[i])
         free(usrcomps[i]);
   if (targ)
      free(targarg);
   return(0);
}
@ROUT flibchkF.f
       SUBROUTINE flibchk(A)
       COMPLEX*16  A(*)
       INTRINSIC   DIMAG
*
*      Perform complex arith and I/O to link in f77 libs
*
       A(1) = (A(1) * A(2)) / A(3)
       if (DIMAG(A(1)) .EQ. 99999.97) STOP
       PRINT*,' SUCCESS'

       RETURN
       END
@ROUT flibchkC
#include <stdio.h>
#include <stdlib.h>
#ifdef NoChange
   #define flibchk_ flibchk
#elif defined(UpCase)
   #define flibchk_ FLIBCHK
#endif
int main(int nargs, char **args)
{
   void flibchk_(double*);
   double A[6];
   A[0] = A[1] = A[2] = A[3] = A[5] = 0.0;
   A[4] = 1.0;
   flibchk_(A);
   return(0);
}
@ROUT probe_f2c
#include "atlconf.h"

int probe_name(char *targarg, int verb, char **usrcomps)
{
   char *frm = "make IRunF2C_name %s F77=\"%s\" F77FLAGS=\"%s\" CC=\"%s\" CCFLAGS=\"%s\" | fgrep 'F2C name'";
   char *cmnd, *res;
   enum F2CNAME f2cname = f2c_NamErr;
   int i;

   i = 1 + strlen(frm) + strlen(targarg) + strlen(usrcomps[F77_]) +
       strlen(usrcomps[F77_+NCOMP]) + strlen(usrcomps[ICC_]) +
       strlen(usrcomps[ICC_+NCOMP]);
   cmnd = malloc(i*sizeof(char));
   assert(cmnd);
   sprintf(cmnd, frm, targarg, usrcomps[F77_], usrcomps[F77_+NCOMP],
           usrcomps[ICC_], usrcomps[ICC_+NCOMP]);
   if (verb > 1)
      fprintf(stderr, "cmnd = '%s'\n", cmnd);
   res = atlsys_1L(NULL, cmnd, verb, 0);
   free(cmnd);
   if (res)
   {
      if (verb > 1)
         fprintf(stderr, "res = '%s'\n", res);
      if (strstr(res, "Add__"))
         f2cname = f2c_Add__;
      else if (strstr(res, "Add_"))
         f2cname = f2c_Add_;
      else if (strstr(res, "NoChange"))
         f2cname = f2c_NoChange;
      else if (strstr(res, "UpCase"))
         f2cname = f2c_UpCase;
      free(res);
   }
   if (verb)
      printf("F2C Name Decoration = %s\n", f2c_namestr[f2cname]);
   return(f2cname);
}

int probe_int(char *targarg, int verb, char **usrcomps, int f2cname)
{
   char *frm="make IRunF2C_int %s F77=\"%s\" F77FLAGS=\"%s\" CC=\"%s\" CCFLAGS=\"-D%s %s\" | fgrep 'F2C int'";
   char *cmnd, *res;
   enum F2CINT f2c_int = f2c_IntErr;
   int i;
   i = 1 + strlen(frm) + strlen(targarg) + strlen(usrcomps[F77_]) 
       + strlen(usrcomps[F77_+NCOMP]) + strlen(usrcomps[ICC_]) 
       + strlen(f2c_namestr[f2cname]) + strlen(usrcomps[ICC_+NCOMP]);
   cmnd = malloc(i*sizeof(char));
   assert(cmnd);
   sprintf(cmnd, frm, targarg, usrcomps[F77_], usrcomps[F77_+NCOMP],
           usrcomps[ICC_], f2c_namestr[f2cname], usrcomps[ICC_+NCOMP]);
   if (verb > 1)
      fprintf(stderr, "cmnd = '%s'\n", cmnd);
   res = atlsys_1L(NULL, cmnd, verb, 0);
   free(cmnd);
   if (res)
   {
      if (verb > 1)
         fprintf(stderr, "res = '%s'\n", res);
      if (strstr(res, " C int"))
         f2c_int = FintCint;
      else if (strstr(res, " C long long"))
         f2c_int = FintClonglong;
      else if (strstr(res, " C long"))
         f2c_int = FintClong;
      else if (strstr(res, " C short"))
         f2c_int = FintCshort;
      free(res);
   }
   if (verb)
      printf("F2C int = %s\n", f2c_intstr[f2c_int]);
   return(f2c_int);
}

int probe_str(char *targarg, int verb, char **usrcomps, int f2cname, int f2cint)
{
   char *frm = "make IRunF2C_str %s F77=\"%s\" F77FLAGS=\"%s\" CC=\"%s\" CCFLAGS=\"-D%s -D%s -DString%s %s\" | fgrep 'F2C string'";
   enum F2CSTRING f2cstr = f2c_StrErr;
   int i, len;

   len = 1 + strlen(frm) + strlen(targarg) + strlen(usrcomps[F77_]) +
        strlen(usrcomps[F77_+NCOMP]) + strlen(usrcomps[ICC_]) +
        strlen(f2c_namestr[f2cname]) + strlen(f2c_intstr[f2cint]) + 
        strlen(usrcomps[ICC_+NCOMP]);
   for (i=1; i < 5; i++)
   {
      char *cmnd, *res;
      int k;
      k = len + strlen(f2c_strstr[i]);
      cmnd = malloc(k*sizeof(char));
      assert(cmnd);
      sprintf(cmnd, frm, targarg, usrcomps[F77_], usrcomps[F77_+NCOMP],
              usrcomps[ICC_], f2c_namestr[f2cname], f2c_intstr[f2cint], 
              f2c_strstr[i], usrcomps[ICC_+NCOMP]);
      if (verb > 1)
         fprintf(stderr, "cmnd = '%s'\n", cmnd);
      res = atlsys_1L(NULL, cmnd, verb, 0);
      free(cmnd);
      if (res)
      {
         if (verb > 1)
            fprintf(stderr, "res = '%s'\n", res);
         free(res);
         f2cstr = i;
         break;
      }
   }
   if (verb)
      printf("F2C string = %s\n", f2c_strstr[f2cstr]);
   return(f2cstr);
}

@extract -b @(basd)/atlconf.base rout=GetFlags -def -v "v" -def -C "C"
int main (int nargs, char **args)
/*
 * This probe discovers the details of how fortran should call C for the
 * given compilers.  In particular, it discovers:
 *    (1) Name decoration C rout should do to be callable from fortran
 *    (2) What intergral type F77 integer corresponds to
 *    (3) How fortran strings are passed
 */
{
   int verb;
   int f2cname, f2cint, f2cstr;
   char *usrcomps[3*NCOMP];
   char *targ, *targarg;
   int i, ierr = 0;

   GetFlags(nargs, args, &verb, usrcomps, &targ);
   if (targ)
   {
      targarg = malloc(sizeof(char)*(strlen(targ)+24));
      assert(targarg);
      sprintf(targarg, "atlrun=atlas_runX targ=%s", targ);
   }
   else
      targarg = "";
   f2cname = probe_name(targarg, verb, usrcomps);
   if (f2cname)
   {
      f2cint = probe_int(targarg, verb, usrcomps, f2cname);
      f2cstr = probe_str(targarg, verb, usrcomps, f2cname, f2cint);
      printf("F2C=(%d,%d,%d)\n", f2cname, f2cint, f2cstr);
   }
   else
   {
      ierr = 1;
      if (verb)
         fprintf(stderr, "Cannot determine f2cname, quitting f2c probe!\n");
   }
   if (targ)
      free(targarg);
   for (i=0; i < 3*NCOMP; i++)
      if (usrcomps[i])
         free(usrcomps[i]);
   return(ierr);
}
@ROUT f2cnameC
#include <stdio.h>
void c_routine_(double *d)  { *d = 1.0; }
void c_routine(double *d)   { *d = 2.0; }
void C_ROUTINE(double *d)  { *d = 3.0; }
void c_routine__(double *d) { *d = 4.0; }
@ROUT f2cnameF.f
      program namtst
      external c_routine
      double precision d

      d = 0.0
      call c_routine(d)
      if (d .eq. 1.0) then
         print*,'F2C name=-DAdd_'
      else if (d .eq. 2.0) then
         print*,'F2C name=-DNoChange'
      else if (d .eq. 3.0) then 
         print*,'F2C name=-DUpCase'
      else if (d .eq. 4.0) then
         print*,'F2C name=-DAdd__'
      else 
         print*, 'ERROR'
      endif

      stop
      end
@ROUT f2cnameC_old
#include <stdio.h>
void c_routine_(void)  { printf("F2C name=-DAdd_\n"); }
void c_routine(void)   { printf("F2C name=-DNoChange\n"); }
void C_ROUTINE(void)  { printf("F2C name=-DUpCase\n"); }
void c_routine__(void) { printf("F2C name=-DAdd__\n"); }
@ROUT f2cnameF.f_old
      program namtst
      external c_routine

      call c_routine()

      stop
      end
@ROUT f2cintF.f
       program f2cintf
       integer iarr(8)
       double precision d
       iarr(1) = 1
       iarr(2) = -1
       iarr(3) = -1
       iarr(4) = -1
       iarr(5) = -1
       iarr(6) = -1
       iarr(7) = -1
       iarr(8) = -1
       d = 0.0
       call f2cintc(iarr, d)
      if (d .eq. 1.0) then
         print*,'F2C int = C int'
      else if (d .eq. 2.0) then
         print*,'F2C int = C long'
      else if (d .eq. 3.0) then 
         print*,'F2C int = C long long'
      else if (d .eq. 4.0) then
         print*,'F2C int = C short'
      else 
         print*, 'ERROR'
      endif

       stop
       end
@ROUT f2cintC
#include <stdio.h>
#include <stdlib.h>
#if defined(Add_) || defined(Add__)
   #define f2cintc f2cintc_
#elif defined(UpCase)
   #define f2cintc F2CINTC
#endif
void f2cintc(void *vp, double *d)
{
   int *ip=vp;
   long *lp=vp;
   long long *llp=vp;
   short *sp=vp;

   *d = 0.0;
   if ( (sizeof(long) != sizeof(int)) && (*lp == 1) )
      *d = 2.0;
   else if (*ip == 1)  *d = 1.0;
   else if (*lp == 1)  *d = 2.0;
   else if (*llp == 1) *d = 3.0;
   else if (*sp == 1)  *d = 4.0;
}
@ROUT f2cintF.f_old
       program f2cintf
       integer iarr(8)
       iarr(1) = 1
       iarr(2) = -1
       iarr(3) = -1
       iarr(4) = -1
       iarr(5) = -1
       iarr(6) = -1
       iarr(7) = -1
       iarr(8) = -1
       call f2cintc(iarr)
       stop
       end
@ROUT f2cintC_old
#include <stdio.h>
#include <stdlib.h>
#if defined(Add_) || defined(Add__)
   #define f2cintc f2cintc_
#elif defined(UpCase)
   #define f2cintc F2CINTC
#endif
void f2cintc(void *vp)
{
   int *ip=vp;
   long *lp=vp;
   long long *llp=vp;
   short *sp=vp;

   if ( (sizeof(long) != sizeof(int)) && (*lp == 1) )
      printf("F2C int = C long\n");
   else if (*ip == 1)  printf("F2C int = C int\n");
   else if (*lp == 1)  printf("F2C int = C long\n");
   else if (*llp == 1) printf("F2C int = C long long\n");
   else if (*sp == 1)  printf("F2C int = C short\n");
}
@ROUT f2cstrF.f
      program chartst
      external crout
      double precision d

      d = 0.0
      call crout(d, '123', -1, '12345', -2)
      if (d .eq. 1.0) then
         print*,'F2C string = -DStringSunStyle'
      else if (d .eq. 2.0) then
         print*,'F2C string = -DStringCrayStyle'
      else if (d .eq. 3.0) then 
         print*,'F2C string = -DStringStructVal'
      else if (d .eq. 4.0) then
         print*,'F2C string = -DStringStructPtr'
      else 
         print*, 'ERROR'
      endif

      stop
      end
@ROUT f2cstrC
#include <stdlib.h>
#if defined(Add_) || defined(Add__)
   #define crout crout_
#elif defined(UpCase)
   #define crout CROUT
#endif
#ifdef StringSunStyle

void crout(double *d, char *str1, F77_INTEGER *n1, char *str2, F77_INTEGER *n2, 
           F77_INTEGER three, F77_INTEGER five)
{
   if ( (*n1 != -1) || (*n2 != -2) || (three != 3) || (five != 5) ) exit(-1);
   if (str1[0] != '1' || str1[1] != '2' || str1[2] != '3') exit(-1);
   if (str2[0] != '1' || str2[1] != '2' || str2[2] != '3' ||
       str2[3] != '4' || str2[4] != '5') exit(-1);
   *d = 1.0;
@skip   printf("F2C string = -DStringSunStyle\n");
}

#elif defined(StringCrayStyle)

#include <fortran.h>
void crout(double *d, _fcd str1, F77_INTEGER *n1, _fcd str2, F77_INTEGER *n2)
{
   if ( (*n1 != -1) || (*n2 != -2) ) exit(-1);
   if (*(_fcdtocp(str1)) != '1' || *(_fcdtocp(str2)) != '1' ) exit(-1);
   *d = 2.0;
@skip   printf("F2C string = -DStringCrayStyle\n");
}

#elif defined(StructVal)

typedef struct {char *cp; F77_INTEGER len;} F77_CHAR;
void crout(double *d, F77_CHAR str1, F77_INTEGER *n1, 
           F77_CHAR str2, F77_INTEGER *n2)
{
   if ( (*n1 != -1) || (*n2 != -2) || (str1.len != 3) || (str2.len != 5) )
      exit(-1);
   if (str1.cp[0] != '1' || str1.cp[1] != '2' || str1.cp[2] != '3') exit(-1);
   if (str2.cp[0] != '1' || str2.cp[1] != '2' || str2.cp[2] != '3' ||
       str2.cp[3] != '4' || str2.cp[4] != '5') exit(-1);
   *d = 3.0;
@skip   printf("F2C string = -DStringStructVal\n");
}
#elif defined(StructPtr)
typedef struct {char *cp; F77_INTEGER len;} *F77_CHAR;
void crout(double *d, F77_CHAR str1, F77_INTEGER *n1, 
           F77_CHAR str2, F77_INTEGER *n2)
{
   if ( (*n1 != -1) || (*n2 != -2) || (str1->len != 3) || (str2->len != 5) )
      exit(-1);
   if (str1->cp[0] != '1' || str1->cp[1] != '2' || str1->cp[2] != '3') exit(-1);
   if (str2->cp[0] != '1' || str2->cp[1] != '2' || str2->cp[2] != '3' ||
       str2->cp[3] != '4' || str2->cp[4] != '5') exit(-1);
   *d = 4.0;
@skip   printf("F2C string = -DStringStructPtr\n");
}
#endif
@ROUT f2cstrF.f_old
      program chartst
      external crout

      call crout('123', -1, '12345', -2)

      stop
      end
@ROUT f2cstrC_old
#if defined(Add_) || defined(Add__)
   #define crout crout_
#elif defined(UpCase)
   #define crout CROUT
#endif
#ifdef StringSunStyle

void crout(char *str1, F77_INTEGER *n1, char *str2, F77_INTEGER *n2, 
           F77_INTEGER three, F77_INTEGER five)
{
   if ( (*n1 != -1) || (*n2 != -2) || (three != 3) || (five != 5) ) exit(-1);
   if (str1[0] != '1' || str1[1] != '2' || str1[2] != '3') exit(-1);
   if (str2[0] != '1' || str2[1] != '2' || str2[2] != '3' ||
       str2[3] != '4' || str2[4] != '5') exit(-1);
   printf("F2C string = -DStringSunStyle\n");
}

#elif defined(StringCrayStyle)

#include <fortran.h>
void crout(_fcd str1, F77_INTEGER *n1, _fcd str2, F77_INTEGER *n2)
{
   if ( (*n1 != -1) || (*n2 != -2) ) exit(-1);
   if (*(_fcdtocp(str1)) != '1' || *(_fcdtocp(str2)) != '1' ) exit(-1);
   printf("F2C string = -DStringCrayStyle\n");
}

#elif defined(StructVal)

typedef struct {char *cp; F77_INTEGER len;} F77_CHAR;
void crout(F77_CHAR str1, F77_INTEGER *n1, F77_CHAR str2, F77_INTEGER *n2)
{
   if ( (*n1 != -1) || (*n2 != -2) || (str1.len != 3) || (str2.len != 5) )
      exit(-1);
   if (str1.cp[0] != '1' || str1.cp[1] != '2' || str1.cp[2] != '3') exit(-1);
   if (str2.cp[0] != '1' || str2.cp[1] != '2' || str2.cp[2] != '3' ||
       str2.cp[3] != '4' || str2.cp[4] != '5') exit(-1);
   printf("F2C string = -DStringStructVal\n");
}
#elif defined(StructPtr)
typedef struct {char *cp; F77_INTEGER len;} *F77_CHAR;
void crout(F77_CHAR str1, F77_INTEGER *n1, F77_CHAR str2, F77_INTEGER *n2)
{
   if ( (*n1 != -1) || (*n2 != -2) || (str1->len != 3) || (str2->len != 5) )
      exit(-1);
   if (str1->cp[0] != '1' || str1->cp[1] != '2' || str1->cp[2] != '3') exit(-1);
   if (str2->cp[0] != '1' || str2->cp[1] != '2' || str2->cp[2] != '3' ||
       str2->cp[3] != '4' || str2->cp[4] != '5') exit(-1);
   printf("F2C string = -DStringStructPtr\n");
}
#endif
@ROUT c2cmaster
#include <stdio.h>
#include <stdlib.h>
int main(int nargs, char **args)
{
   int i;
   int c2cslave(char, int, double, float);
   i = c2cslave('y', 2, 2.0, 3.0);
   if (i != -2)
   {
      printf("FAILURE\n");
      exit(1);
   }
   printf("SUCCESS\n");
   return(0);
}
@ROUT c2cslave
int c2cslave(char c, int i, double d, float f)
{
   if (c == 'y' && i == 2 && d == 2.0 && f == 3.0)
      return(-2);
   return(0);
}
@ROUT comptestF.f
      program comptest
      print*, 'SUCCESS'
      stop
      end
@ROUT comptestC
#include <stdio.h>
#include <stdlib.h>

int main(int nargs, char **args)
{
   printf("SUCCESS");
   return(0);
}
@ROUT atlcomp.txt
#
# In this file, any line beginning with a '#' is ignored, but the # must be in
# column 0.  All multiple whitespace is reduced to one space (i.e. used only
# to distinguish where words begin/end)
#
# The file has the following format:
# MACH=<#>,...,<#> OS=<#>,...,<#> LVL=<#> COMPS=[icc,smc,dmc,skc,dkc,xccf77]
#  'compiler' 'flags'
# Where MACH indicates the MACHTYPE(s) that the compiler should be available
# on, the OS indicates which Operating systems that compiler is available on,
# and both of these can take the value of 0, which means the compiler and
# associated flags can be used for any machine/OS.  There should be no
# space in the #,# strings.
#
# LVL gives a priority, and the highest available priority compiler is used
# by ATLAS by default.  If the user overrides to a compiler that's listed
# as a possiblity, the flags given in this line will be used (if the user
# does not also override flags) regardless of priority.  In general, here
# are some reserved priorities:
#   1000: Default compiler for particular OS/flag
#    500: Alternative compiler getting roughly same performance
#    100: Alternative compiler getting crappier performance
#     50: Default compiler for particular OS / general family
#     10: Default compiler for particular OS / completely unknown arch
#      0: Fallback compiler when nothing is known
#
# COMPS is a list saying which of ATLAS's compiler this comp/flag combo are
#  to be used for:
#  icc: Used to compiler interface; perf neutral, so set to anything user
#       uses for interoperability
#  f77: Same as above but for f77 interface.
#  dkc: Used to compile all non-matmul double prec computational kernels.
#  skc: Used to compile all non-matmul single prec computational kernels.
#  dmc: Used to compile all matmul single prec computational kernels.
#  smc: Used to compile all matmul single prec computational kernels.
#*****************************************************************************
#
# All non-core x86 like these params for MMFLAGS (probably want -O3 for
# Level 1 & 2, but must confirm)
#
# Core2/Corei1/Corei2/Corei3/Corei4
MACH=Corei3,Corei3EP,Corei4 OS=ALL LVL=1000 COMPS=smc,dmc,skc,dkc,icc,gcc,xcc
   'gcc' '-fomit-frame-pointer -mfpmath=sse -O2'
MACH=Corei4 OS=all LVL=1100 COMPS=dmc,smc
   'gcc' '-fomit-frame-pointer -mfpmath=sse -O2 -fschedule-insns'
MACH=Corei2 OS=Win9x,WinNT,Win64 LVL=1005 COMPS=smc,dmc,skc,dkc,icc
   'gcc-4' '-fomit-frame-pointer -mfpmath=sse -O2 -fno-schedule-insns2'
MACH=Corei2 OS=ALL LVL=1000 COMPS=dmc
   'gcc' '-O1 -mfpmath=sse -mavx'
MACH=Corei2 OS=ALL LVL=1000 COMPS=smc,skc,dkc,icc,gcc,xcc
   'gcc' '-fomit-frame-pointer -mfpmath=sse -O2 -fno-schedule-insns2'
@skip MACH=Corei2 OS=ALL LVL=50 COMPS=skc,dkc,icc,xcc
@skip    'clang' '-fomit-frame-pointer -mavx -O2 -m64 -Wno-parentheses'
MACH=Corei1 OS=Win9x,WinNT,Win64 LVL=1005 COMPS=smc,dmc,skc,dkc,icc,gcc
   'gcc-4' '-fomit-frame-pointer -mfpmath=sse -O2 -fno-schedule-insns2'
MACH=Corei1 OS=ALL LVL=1000 COMPS=smc,dmc,skc,dkc,icc,gcc
   'gcc' '-fomit-frame-pointer -mfpmath=sse -O2 -fno-schedule-insns2'
MACH=Core2 OS=Win9x,WinNT,Win64 LVL=1005 COMPS=smc,dmc,skc,dkc,icc
   'gcc-4' '-fomit-frame-pointer -mfpmath=sse -O2'
MACH=Core2 OS=ALL LVL=1000 COMPS=smc,dmc,skc,dkc,icc,gcc
   'gcc' '-fomit-frame-pointer -mfpmath=sse -O2'
MACH=Atom OS=ALL LVL=1000 COMPS=smc,dmc,skc,dkc
   'gcc' '-O3 -fno-schedule-insns2 -funroll-all-loops -fno-tree-ch'
MACH=Atom OS=ALL LVL=1000 COMPS=icc,gcc
   'gcc' '-O'
# Generic x86 defaults for building portable, low-performance libs
MACH=x86x87 OS=ALL LVL=1000 COMPS=smc,dmc,skc,dkc,icc,gcc
   'gcc' '-fomit-frame-pointer -mfpmath=387 -O2 -falign-loops=4'
MACH=x86x87,x86SSE1 OS=ALL LVL=1000 COMPS=f77
   'gfortran' '-fomit-frame-pointer -mfpmath=387 -O2 -falign-loops=4'
MACH=x86SSE1 OS=ALL LVL=1000 COMPS=dmc,dkc,icc,gcc
   'gcc' '-fomit-frame-pointer -mfpmath=387 -O2 -falign-loops=4'
MACH=x86SSE1 OS=ALL LVL=1000 COMPS=smc,skc
   'gcc' '-fomit-frame-pointer -mfpmath=sse -O2'
MACH=x86SSE1 OS=ALL LVL=1000 COMPS=f77
   'gfortran' '-fomit-frame-pointer -mfpmath=387 -O2 -falign-loops=4'
MACH=x86SSE2 OS=ALL LVL=1000 COMPS=smc,skc,dmc,dkc,icc,gcc
   'gcc' '-fomit-frame-pointer -mfpmath=sse -O2'
MACH=x86SSE2 OS=ALL LVL=1000 COMPS=f77
   'gfortran' '-fomit-frame-pointer -mfpmath=sse -O2'
MACH=x86SSE3 OS=ALL LVL=1000 COMPS=dmc,smc,dkc,skc,icc,gcc
   'gcc' '-fomit-frame-pointer -mfpmath=sse -O2'
MACH=x86SSE3 OS=ALL LVL=1000 COMPS=f77
   'gfortran' '-fomit-frame-pointer -mfpmath=sse -O2'
@skip # PPRO,PII,PIII,P4,P4E,K7,HAMMER
@skip MACH=PPRO,PII,PIII,P4,P4E,K7,HAMMER OS=ALL LVL=2000 COMPS=smc,dmc,skc,dkc
@skip    'gcc32' '-fomit-frame-pointer -mfpmath=387 -O2 -falign-loops=4'
# P4E, P4
MACH=P4E,P4 OS=ALL LVL=1000 COMPS=f77
   'gfortran' '-O2 -fomit-frame-pointer -mfpmath=sse'
MACH=P4E OS=ALL LVL=1000 COMPS=skc,dkc,icc
   'gcc' '-O2 -fomit-frame-pointer -mfpmath=sse'
MACH=P4E,P4 OS=ALL LVL=1000 COMPS=smc,dmc
   'gcc' '-O2 -fomit-frame-pointer -mfpmath=sse -fno-schedule-insns -fno-optimize-register-move'
MACH=P4E,P4 OS=Win9x,WinNT,Win64 LVL=1005 COMPS=smc,dmc
   'gcc-4' '-O2 -fomit-frame-pointer -mfpmath=sse -fno-schedule-insns -fno-optimize-register-move'
MACH=P4E,P4 OS=ALL LVL=1000 COMPS=skc,dkc,icc
   'gcc-4' '-O2 -fomit-frame-pointer -mfpmath=sse'
# Hammer
MACH=HAMMER OS=ALL LVL=1000 COMPS=f77
   'gfortran' '-fomit-frame-pointer -mfpmath=387 -O2'
MACH=HAMMER OS=Win9x,WinNT,Win64 LVL=1005 COMPS=smc,dmc,skc,dkc,icc
   'gcc-4' '-fomit-frame-pointer -mfpmath=387 -O2'
MACH=HAMMER OS=ALL LVL=1000 COMPS=smc,dmc,skc,dkc,icc,gcc
   'gcc' '-fomit-frame-pointer -mfpmath=387 -O2'
# PPRO,PII,PIII,K7
MACH=PPRO,PII,PIII,K7 OS=ALL LVL=1000 COMPS=f77
   'gfortran' '-fomit-frame-pointer -mfpmath=387 -O2 -falign-loops=4'
MACH=PPRO,PII,PIII,K7 OS=Win9x,WinNT,Win64 LVL=1005 COMPS=smc,dmc,skc,dkc,icc
   'gcc-4' '-fomit-frame-pointer -mfpmath=387 -O2 -falign-loops=4'
MACH=PPRO,PII,PIII,P4,P4E,K7 OS=ALL LVL=1000 COMPS=smc,dmc,skc,dkc,icc,gcc
   'gcc' '-fomit-frame-pointer -mfpmath=387 -O2 -falign-loops=4'
# CoreSolo,CoreDuo
MACH=CoreSolo,CoreDuo OS=WinNT,Win9x,Win64 LVL=1005 COMPS=smc,dmc,skc,dkc,icc
   'gcc-4' '-fomit-frame-pointer -O3 -mfpmath=387'
MACH=CoreSolo,CoreDuo OS=ALL LVL=1000 COMPS=smc,dmc,skc,dkc,icc,gcc
   'gcc' '-fomit-frame-pointer -O3 -mfpmath=387'
# 3rd generation opteron (Barcelona and descendents)
MACH=AMD64K10h OS=ALL LVL=1000 COMPS=f77
   'gfortran' '-fomit-frame-pointer -mfpmath=sse -O2'
MACH=AMD64K10h OS=ALL LVL=1000 COMPS=smc,dmc,skc,dkc,icc,gcc
   'gcc' '-fomit-frame-pointer -mfpmath=sse -O2'
MACH=AMD64K10h OS=Win9x,WinNT,Win64 LVL=1005 COMPS=smc,dmc,skc,dkc,icc,gcc
   'gcc' '-fomit-frame-pointer -mfpmath=sse -O2'
MACH=AMDDRIVER OS=ALL LVL=1000 COMPS=smc,dmc,skc,dkc,icc,gcc
   'gcc' '-Os -fomit-frame-pointer'
MACH=AMDDOZER OS=ALL LVL=1000 COMPS=smc,dmc,skc,dkc,icc,gcc
   'gcc' '-fomit-frame-pointer -mfpmath=sse -mfma4 -O2 -fno-tree-loop-optimize'
# UltraSPARC T2
MACH=UST2 OS=ALL LVL=1000 COMPS=smc,dmc,skc,dkc,icc,xcc,gcc
   'gcc' '-mcpu=niagara2 -mtune=niagara2 -Os'
MACH=UST2 OS=ALL LVL=1000 COMPS=f77
   'gfortran' '-mcpu=niagara2 -mtune=niagara2 -Os'
# UltraSPARC III & IV
MACH=USIII,USIV OS=ALL LVL=1000 COMPS=smc,
   'gcc' '-O1 -mcpu=ultrasparc3 -mtune=ultrasparc3 -fschedule-insns -fmodulo-sched'
MACH=USIII,USIV OS=ALL LVL=1000 COMPS=dmc,skc,dkc,icc
   'gcc' '-O3 -mcpu=ultrasparc3 -mtune=ultrasparc3 -fno-schedule-insns2 -fschedule-insns'
MACH=USIII,USIV OS=ALL LVL=1000 COMPS=xcc,gcc
   'gcc' '-mcpu=ultrasparc3 -mtune=ultrasparc3 -O'
MACH=USIII,USIV OS=ALL LVL=1000 COMPS=f77
   'f77' '-dalign -native -xO5'
MACH=USIII,USIV OS=ALL LVL=100 COMPS=f77
   'gfortran' '-O -mcpu=ultrasparc3 -mtune=ultrasparc3'
MACH=USIII,USIV OS=ALL LVL=10 COMPS=f77
   'g77' '-O -mcpu=ultrasparc3 -mtune=ultrasparc3'
#
# Itanium & Itanium 2 
#
# These gcc 4 default flags will die on gcc3, allowing gcc3's flags to be used
MACH=IA64Itan,IA64Itan2 OS=ALL LVL=1010 COMPS=smc,dmc,skc,dkc
   'gcc' '-fomit-frame-pointer -O2 -fno-tree-loop-optimize'
MACH=IA64Itan,IA64Itan2 OS=ALL LVL=1000 COMPS=smc,dmc,skc,dkc
   'gcc' '-fomit-frame-pointer -O2'
MACH=IA64Itan,IA64Itan2 OS=ALL LVL=1010 COMPS=f77
   'gfortran' '-fomit-frame-pointer -O2 -fno-tree-loop-optimize'
#
# IRIX/MIPS
#
MACH=MIPSR1xK OS=IRIX LVL=1000 COMPS=smc,dmc,skc,dkc
   'cc' '-O3 -OPT:Olimit=15000 -LNO:blocking=OFF -LOPT:alias=typed'
MACH=MIPSR1xK OS=IRIX LVL=1000 COMPS=icc,xcc,gcc
   'cc' '-O2 -OPT:Olimit=15000 -LNO:blocking=OFF'
MACH=MIPSR1xK OS=IRIX LVL=1000 COMPS=f77
   'f77' '-O2'
#
# Linux/MIPSICE9
# pathcc priorities set below gcc because threaded syrk won't work with
# pathcc at -O2 -- seems to be a compiler error
#
MACH=MIPSICE9 OS=ALL LVL=500 COMPS=icc,smc,dmc,skc,dkc,xcc,gcc
   'gcc' '-O2 -mips64 -march=5kf -mtune=5kf -fno-schedule-insns -fschedule-insns2 -fno-peephole -fno-peephole2'
MACH=MIPSICE9 OS=ALL LVL=1000 COMPS=f77
   'pathf95' '-march=auto -O2'
MACH=MIPSICE9 OS=ALL LVL=1 COMPS=skc,dkc
   'pathcc' '-O3 -OPT:Olimit=15000 -LNO:blocking=OFF -LOPT:alias=typed -march=auto'
MACH=MIPSICE9 OS=ALL LVL=1 COMPS=smc,dmc
   'pathcc' '-O3 -OPT:Olimit=15000 -LNO:blocking=OFF -LOPT:alias=typed -march=auto -LNO:opt=0 -LNO:full_unroll_outer=OFF -LNO:fusion=0 -LNO:prefetch=2'
MACH=MIPSICE9 OS=ALL LVL=1 COMPS=icc,xcc
   'pathcc' '-march=auto -O2 -OPT:Olimit=15000 -LNO:blocking=OFF'
#
# G4 flags, has a slightly less important case of the gcc perf bug of the POWER5
# confirmed in gcc 4.3.2.
#
MACH=PPCG4 OS=ALL LVL=1000 COMPS=dmc
   'gcc' '-Os -maltivec -mabi=altivec -mcpu=7400 -mtune=7400'
MACH=PPCG4 OS=ALL LVL=1000 COMPS=smc
   'gcc' '-Os -maltivec -mabi=altivec -mcpu=7400 -mtune=7400'
MACH=PPCG4 OS=ALL LVL=1000 COMPS=icc,skc,dkc,xcc,gcc
   'gcc' '-O3 -maltivec -mabi=altivec -mcpu=7400 -mtune=7400 -fno-schedule-insns -fschedule-insns2'
#
# PowerPC970
#
MACH=PPCG5 OS=ALL LVL=1000 COMPS=smc
   'gcc' '-Os -mpowerpc64 -maltivec -mabi=altivec -mcpu=970 -mtune=970 -mvrsave -fno-schedule-insns2 -fno-schedule-insns'
MACH=PPCG5 OS=ALL LVL=1000 COMPS=dmc,icc,dkc,xcc,gcc
   'gcc' '-mpowerpc64 -maltivec -mabi=altivec -mcpu=970 -mtune=970 -O2'
MACH=PPCG5 OS=ALL LVL=1000 COMPS=skc
   'gcc' '-mpowerpc64 -maltivec -mabi=altivec -mcpu=970 -mtune=970 -O2 -mvrsave'
MACH=POWER7 OS=ALL LVL=1010 COMPS=icc,smc,dmc,skc,dkc,xcc,gcc
   'gcc' '-O2 -mvsx -mcpu=power7 -mtune=power7 -m64 -mvrsave -funroll-all-loops'
MACH=POWER7 OS=ALL LVL=1010 COMPS=f77
   'gfortran' '-O2 -mvsx -mcpu=power7 -mtune=power7 -m64 -mvrsave -funroll-all-loops'
MACH=POWER8 OS=ALL LVL=1010 COMPS=icc,smc,dmc,skc,dkc,xcc,gcc
   'gcc' '-O2 -mvsx -mcpu=power8 -mtune=power8 -m64 -mvrsave -funroll-all-loops'
MACH=POWER8 OS=ALL LVL=1010 COMPS=f77
   'gfortran' '-O2 -mvsx -mcpu=power8 -mtune=power8 -m64 -mvrsave -funroll-all-loops'
MACH=POWER6 OS=ALL LVL=1010 COMPS=icc,smc,dmc,skc,dkc,xcc,gcc
   'gcc' '-mcpu=power6 -mtune=power6 -maltivec -O3 -fno-schedule-insns -fschedule-insns2 -minsert-sched-nops=2'
MACH=POWER5 OS=ALL LVL=1010 COMPS=icc,smc,dmc,skc,dkc,xcc,gcc
   'gcc' '-mcpu=power5 -mtune=power5 -O3 -fno-schedule-insns -fno-rerun-loop-opt'
MACH=POWER6 OS=ALL LVL=1010 COMPS=f77
   'gfortran' '-mcpu=power6 -mtune=power6 -maltivec -O3 -fno-schedule-insns -fschedule-insns2 -minsert-sched-nops=2'
MACH=POWER5 OS=ALL LVL=1010 COMPS=f77
   'gfortran' '-mcpu=power5 -mtune=power5 -O3 -fno-schedule-insns -fno-rerun-loop-opt'
MACH=POWER7 OS=ALL LVL=1010 COMPS=f77
   'xlf' '-qtune=pwr7 -qarch=pwr7 -O3 -qmaxmem=-1 -qfloat=hsflt'
MACH=POWER5 OS=ALL LVL=1010 COMPS=f77
   'xlf' '-qtune=pwr5 -qarch=pwr5 -O3 -qmaxmem=-1 -qfloat=hsflt'
MACH=POWER4 OS=ALL LVL=1010 COMPS=icc,dmc,smc,dkc,skc,xcc,gcc
   'gcc' '-mcpu=power4 -mtune=power4 -O3 -fno-schedule-insns -fno-rerun-loop-opt'
MACH=POWER4 OS=ALL LVL=1010 COMPS=f77
   'xlf' '-qtune=pwr4 -qarch=pwr4 -O3 -qmaxmem=-1 -qfloat=hsflt'
#
# IBM System z or zEnterprise.
# These compiler flags given by IBM; -O3 -funroll-loops are chosen because
# its what their compiler group supports, not necessarily because they are best
MACH=IBMz9 OS=ALL LVL=1000 COMPS=smc,dmc,skc,dkc,icc,xcc,gcc
   'gcc' '-march=z9-109 -O3 -funroll-loops'
MACH=IBMz10 OS=ALL LVL=1000 COMPS=smc,dmc,skc,dkc,icc,xcc,gcc
   'gcc' '-march=z10 -O3 -funroll-loops -fno-prefetch-loop-arrays'
# Try to fallback to z9 for older compilers
MACH=IBMz10 OS=ALL LVL=600 COMPS=f77
   'gfortran' '-march=z9-109 -O3 -funroll-loops'
MACH=IBMz10 OS=ALL LVL=600 COMPS=smc,dmc,skc,dkc,icc,xcc,gcc
   'gcc' '-march=z9-109 -O3 -funroll-loops -fno-prefetch-loop-arrays'
# z196
MACH=IBMz196 OS=ALL LVL=1000 COMPS=f77
   'gfortran' '-march=z196 -O3 -funroll-loops -fno-prefetch-loop-arrays'
MACH=IBMz196 OS=ALL LVL=1000 COMPS=smc,dmc,skc,dkc,icc,xcc,gcc
   'gcc' '-march=z196 -O3 -funroll-loops -fno-prefetch-loop-arrays'
# We also try to fallback to z10 or z9 for older compilers
MACH=IBMz196 OS=ALL LVL=800 COMPS=smc,dmc,skc,dkc,icc,xcc,gcc
   'gcc' '-march=z10 -O3 -funroll-loops -fno-prefetch-loop-arrays'
MACH=IBMz196 OS=ALL LVL=800 COMPS=f77
   'gfortran' '-march=z10 -O3 -funroll-loops -fno-prefetch-loop-arrays'
MACH=IBMz196 OS=ALL LVL=600 COMPS=smc,dmc,skc,dkc,icc,xcc,gcc
   'gcc' '-march=z9-109 -O3 -funroll-loops'
MACH=IBMz196 OS=ALL LVL=600 COMPS=f77
   'gfortran' '-march=z9-109 -O3 -funroll-loops'
# ALL march options failed, go back to conservative defaults
MACH=IBMz9,IBMz10,IBMz196,IBMz12 OS=ALL LVL=500 COMPS=f77
   'gfortran' '-O3 -funroll-loops'
MACH=IBMz9,IBMz10,IBMz196,IBMz12 OS=ALL LVL=500 COMPS=smc,dmc,skc,dkc,icc,xcc,gcc
   'gcc' '-O3 -funroll-loops'
MACH=IBMz13 OS=ALL LVL=1000 COMPS=dmc,skc,dkc,icc,xcc,gcc
   'gcc' '-march=native -O -mvx -mzvector'
MACH=IBMz13 OS=ALL LVL=1000 COMPS=smc
   'gcc' '-march=native -O -mvx -mzvector -fno-peephole -fno-peephole2'
MACH=IBMz13 OS=ALL LVL=1000 COMPS=f77
   'gfortran' '-march=native -O -mvx -mzvector'
#
# Windows defaults ; need to make SSE/SSE2 arch dep.
#
MACH=P5,P5MMX,PPRO,PII OS=WinNT,Win64 LVL=4 COMPS=icc,dmc,smc,dkc,skc,xcc
   'cl' '-Oy -Ox'
MACH=PIII,K7 OS=WinNT,Win64 LVL=4 COMPS=icc,dmc,smc,dkc,skc,xcc
   'cl' '-Oy -Ox -arch:SSE -nologo'
MACH=ALL OS=WinNT,Win64 LVL=0 COMPS=icc,dmc,smc,dkc,skc,xcc
   'cl' '-Oy -Ox -arch:SSE2 -nologo'
MACH=ALL OS=WinNT,Win64 LVL=0 COMPS=f77
   'ifort' '-O2 -fltconsistency -nologo'
MACH=P4,PM OS=WinNT,Win64 LVL=0 COMPS=icc,dmc,smc,dkc,skc,xcc
   'icl' '-QxN -O3 -Qprec -fp:extended -fp:except -nologo -Oy'
#
# ARM defaults
#
MACH=ARMa7,ARMa9,ARMa15 OS=ALL LVL=1000 COMPS=xcc
   'gcc' '-O2'
MACH=ARMa7,ARMa9,ARMa15 OS=ALL LVL=1000 COMPS=smc,skc,gcc,icc
   'gcc' '-O2 -fselective-scheduling2'
MACH=ARMa15 OS=ALL LVL=1000 COMPS=dmc,dkc
   'gcc' '-O2 -fno-schedule-insns -fno-schedule-insns2 -fprefetch-loop-arrays'
MACH=ARMa7 OS=ALL LVL=1100 COMPS=dmc
   'gcc' '-O2 -mcpu=cortex-a7 -fno-schedule-insns -fselective-scheduling2'
MACH=ARMa9 OS=ALL LVL=1100 COMPS=dmc
   'gcc' '-O3 -mcpu=cortex-a9 -fno-schedule-insns -fno-schedule-insns2'
MACH=ARMa9 OS=ALL LVL=1100 COMPS=smc,skc,dkc
   'gcc' '-O2 -mcpu=cortex-a9 -fschedule-insns'
MACH=ARMa7,ARMa9,ARMa15 OS=ALL LVL=1000 COMPS=f77
   'gfortran' '-O2'
#
# ARM64xgene1 defaults
#
MACH=ARM64xgene1 OS=ALL LVL=1000 COMPS=xcc
   'gcc' '-O2'
MACH=ARM64xgene1 OS=ALL LVL=1000 COMPS=icc
   'gcc' ' -mcpu=xgene1 -mtune=xgene1 -O2'
MACH=ARM64xgene1 OS=ALL LVL=1000 COMPS=skc,gcc,dkc
   'gcc' ' -mcpu=xgene1 -mtune=xgene1 -O3  -ftree-vect-loop-version -ftree-vectorize -fprefetch-loop-arrays'
MACH=ARM64xgene1 OS=ALL LVL=1000 COMPS=smc
   'gcc' '-O2 -mcpu=xgene1 -mtune=xgene1 -fprefetch-loop-arrays'
MACH=ARM64xgene1 OS=ALL LVL=1000 COMPS=dmc
   'gcc' '-O1 -mcpu=xgene1 -mtune=xgene1 -fexpensive-optimizations -fprefetch-loop-arrays'
MACH=ARM64xgene1 OS=ALL LVL=1000 COMPS=f77
   'gfortran' '-O2'
#
# ARM64 cortex-a57 defaults (untested)
#
MACH=ARM64a57 OS=ALL LVL=1000 COMPS=f77
   'gfortran' '-mcpu=cortex-a57 -O2'
MACH=ARM64a57 OS=ALL LVL=1000 COMPS=xcc
   'gcc' '-mcpu=cortex-a57 -O2'
MACH=ARM64a57 OS=ALL LVL=1000 COMPS=icc
   'gcc' '-mcpu=cortex-a57 -mtune=cortex-a57 -O2'
MACH=ARM64a57 OS=ALL LVL=1000 COMPS=skc,gcc,dkc
   'gcc' ' -mcpu=cortex-a57 -mtune=cortex-a57 -O3'
MACH=ARM64a57 OS=ALL LVL=1100 COMPS=dmc,smc
   'gcc' '-O1 -mcpu=cortex-a57 -mtune=cortex-a57'
MACH=ARM64a57 OS=ALL LVL=1000 COMPS=f77
   'gfortran' '-O2 -mcpu=cortex-a57'
#
# ARM64 cortex-a53 defaults (untested)
#
MACH=ARM64a53 OS=ALL LVL=1000 COMPS=f77
   'gfortran' '-march=native -O2'
MACH=ARM64a53 OS=ALL LVL=1000 COMPS=xcc
   'gcc' '-march=native -O2'
MACH=ARM64a53 OS=ALL LVL=1000 COMPS=icc
   'gcc' '-mcpu=cortex-a53 -mtune=cortex-a53 -O2'
MACH=ARM64a53 OS=ALL LVL=1000 COMPS=skc,gcc,dkc
   'gcc' ' -mcpu=cortex-a53 -mtune=cortex-a53 -O3  -ftree-vect-loop-version -ftree-vectorize'
MACH=ARM64a53 OS=ALL LVL=1000 COMPS=smc
   'gcc' '-O2 -mcpu=cortex-a53 -mtune=cortex-a53'
MACH=ARM64a53 OS=ALL LVL=1000 COMPS=dmc
   'gcc' '-O1 -mcpu=cortex-a53 -mtune=cortex-a53 -fexpensive-optimizations'
MACH=ARM64a53 OS=ALL LVL=1000 COMPS=f77
   'gfortran' '-O2 -mcpu=cortex-a53'
#
# Untuned flags for XeonPHI
#
MACH=XeonPHI OS=ALL LVL=1000 COMPS=smc,dmc,skc,dkc,icc,gcc
   'icc' '-fomit-frame-pointer -O2 -mmic -pthread'
MACH=XeonPHI OS=ALL LVL=1000 COMPS=xcc
   'icc' '-fomit-frame-pointer -O2 -g'
MACH=XeonPHI OS=ALL LVL=1000 COMPS=f77
   'ifort' '-fomit-frame-pointer -O2 -mmic -reentrancy threaded'
#
# Generic defaults
#
MACH=ALL OS=ALL LVL=4 COMPS=smc,dmc,skc,dkc,icc,gcc,xcc
   'clang' '-O2'
MACH=ALL OS=ALL LVL=5 COMPS=icc,smc,dmc,skc,dkc,xcc,gcc
   'gcc' '-O -fomit-frame-pointer'
MACH=ALL OS=ALL LVL=5 COMPS=f77
   'gfortran' '-O'
MACH=ALL OS=ALL LVL=4 COMPS=f77
   'g77' '-O'
MACH=ALL OS=ALL LVL=0 COMPS=f77
   'f77' '-O'
@ROUT config
#include "atlconf.h"

char *GetStrProbe(int verb, char *targarg, char *prb, char *id)
/*
 * Performs probe where output is string delimited by '', returning string
 * RETURNS: NULL on error, else requested string.
 */
{
   char *sp, *sret=NULL;
   char *ln, *res;
   int i;

   i = strlen(targarg) + strlen(prb) + strlen(id) + 48;
   ln = malloc(i*sizeof(char));
   assert(ln);
   sprintf(ln, "make IRun_%s args=\"-v %d %s\" | fgrep '%s='", 
           prb, verb, targarg, id);
   
   if (verb > 1)
      printf("cmnd=%s\n", ln);
   res = atlsys_1L(NULL, ln, verb, 0);
   if (res)
   {
      sprintf(ln, "%s='", id);
      sp = strstr(res, ln);
      if (sp)
      {
         sp += strlen(ln);  /* sp pts to start of string */
         for (i=0; sp[i] != '\'' && sp[i] != '\0'; i++);
         if (sp[i] == '\'')  
         {
            sp[i] = '\0';  /* get rid of trailing ' and everything behind it */
            sret = NewStringCopy(sp);
         }
      }
      free(res);
   }
   free(ln);
   return(sret);
}

int GetIntProbe(int verb, char *targarg, char *prb, char *id, int N)
{
   char *ln, *res;
   int iret=0, i;

   i = strlen(targarg) + strlen(prb) + strlen(id) + 48;
   ln = malloc(i*sizeof(char));
   assert(ln);
   sprintf(ln, "make IRun_%s args=\"-v %d %s\" | fgrep '%s='", 
           prb, verb, targarg, id);
   if (verb > 1)
      printf("cmnd=%s\n", ln);
   res = atlsys_1L(NULL, ln, verb, 0);
   free(ln);
   if (res)
   {
      iret = GetLastInt(res);
      free(res);
   }
   if (N)
   {
      if (iret > N || iret < 1)
      {
         printf("\nBad %s value=%d, res='%s'\n", id, iret, res ? res:"NULL");
         iret = 0;
      }
   }
   return(iret);
}

int GetIntProbeSure(int verb, char *targarg, char *prb, char *id, 
                    int *sure)
{
   char *ln, *res;
   int iret=0, ierr, i;

   i = strlen(targarg) + strlen(prb) + strlen(id) + 48;
   ln = malloc(i*sizeof(char));
   assert(ln);
   sprintf(ln, "make IRun_%s args=\"-v %d %s\" | fgrep '%s='", 
           prb, verb, targarg, id);
   if (verb > 1)
      printf("cmnd=%s\n", ln);
   res = atlsys_1L(NULL, ln, verb, 0);
   free(ln);
   if (res)
   {
      iret = GetFirstInt(res);
      *sure = GetLastInt(res);
      free(res);
   }
   return(iret);
}

char *TransCompsToFlags(char **comps)
{
   int len, newlen;
   int i, j;
/*
 * WARNING: if you change the order of the ICC_, etc, must change
 *          compnames!
 */
   char *compnames[NCOMP] = {"ic", "sm", "dm", "sk",  "dk", "xc", "gc", "if"};
   char *flags=NULL, *sp;
   char flgtmp[8], aflg[9];
/* 
 * Up-to-date check, failure will remind me to update this routine!
 */
   assert(NCOMP == 8);
   assert(ICC_ == 0);
   assert(SMC_ == 1);
   assert(DMC_ == 2);
   assert(SKC_ == 3);
   assert(DKC_ == 4);
   assert(XCC_ == 5);
   assert(GCC_ == 6);
   assert(F77_ == 7);
/*
 * Setup prefixes of form "-X xx '" and "-Fa xx '" for appending
 * X will be replaced by F or C, xx by compiler prefix of compnames
 */
   flgtmp[0] = '-';
   flgtmp[5] = flgtmp[2] = ' ';
   flgtmp[6] = '\'';
   flgtmp[7] = '\0';
   aflg[0] = '-'; aflg[1] = 'F'; aflg[2] = 'a'; aflg[3] = ' ';
   aflg[6] = ' '; aflg[7] = '\''; aflg[8] = '\0';
/*
 * Pass any override compilers/flags and appends to probe
 */
   for (i=0; i < NCOMP; i++)
   {
      flgtmp[3] = compnames[i][0];
      flgtmp[4] = compnames[i][1];
      if (comps[i])
      {
         flgtmp[1] = 'C';
         flags = NewAppendedString(flags, flgtmp);  /* append "-C cc '" */
         flags = NewAppendedString0(flags, comps[i]);
         flags = NewAppendedString0(flags, "'");
      }
      if (comps[NCOMP+i])
      {
         flgtmp[1] = 'F';
         flags = NewAppendedString(flags, flgtmp);  /* append "-F cc '" */
         flags = NewAppendedString0(flags, comps[NCOMP+i]);
         flags = NewAppendedString0(flags, "'");
      }
      if (comps[2*NCOMP+i])
      {
         aflg[4] = compnames[i][0];
         aflg[5] = compnames[i][1];
         flags = NewAppendedString(flags, aflg);  /* append "-Fa cc '" */
         flags = NewAppendedString0(flags, comps[2*NCOMP+i]);
         flags = NewAppendedString0(flags, "'");
      }
   }
   if (!flags)
   {
      flags = malloc(sizeof(char));
      flags[0] = '\0';
   }
   return(flags);
}

char *ProbeComp(int verb, char *targarg, enum OSTYPE OS, enum MACHTYPE arch, 
                 char **comps, int nof77, int nocygwin, int ptrbits, int vecext)
/*
 * RETURNS: f2c define string
 */
{
   char *ln, *comp=NULL, *flag=NULL, *flags=NULL; 
   char stmp[32];
   int f2cname, f2cint, f2cstr;
   char *f2cdefs;
   int len, i, cflen=0, if77=0;
   FILE *fpin;

   flags = TransCompsToFlags(comps);
   i = strlen(targarg) + strlen(flags) + 128;
   ln = malloc(i*sizeof(char));
   i = sprintf(ln, "make IRun_comp args=\"-v %d -o atlconf.txt -O %d -A %d -Si nof77 %d -V %d %s %s",
               verb, OS, arch, nof77, vecext, targarg, flags);
   free(flags);
   if (ptrbits == 64 || ptrbits == 32 || ptrbits == -32)
   {
      sprintf(stmp, "-b %d", ptrbits);
      ln = NewAppendedString(ln, stmp);
   }
   if (nocygwin)
      ln = NewAppendedString(ln, "-Si nocygwin 1");
   ln = NewAppendedString0(ln, "\"");
   len = strlen(ln);
   if (verb > 1)
      fprintf(stderr, "cmnd='%s'\n", ln);
@skip   assert(CmndResults(NULL, ln));
   syschk(ln);
   fpin = fopen("atlconf.txt", "r");
   assert(fpin);
   while ((ln=ATL_fgets(ln, &len, fpin)))
   {
      if (cflen < len)
      {
         if (comp)
            free(comp);
         cflen = len;
         comp = malloc(2*len*sizeof(char));
         assert(comp);
         flag = comp+len;
      }
      if (ln[0] != '#')
      {
         if (isdigit(ln[0]))
         {
            assert(sscanf(ln, "%d '%[^']' '%[^']", &i, comp, flag) == 3);
            assert(i >= 0 && i < NCOMP);
            comps[i] = NewStringCopy(comp);
            comps[NCOMP+i] = NewStringCopy(flag);
         }
         else
         {
            for (i=0; ln[i] && ln[i] != '('; i++);
            assert(ln[i] = '(');
            assert(sscanf(ln+i+1, "%d,%d,%d", &f2cname, &f2cint, &f2cstr) == 3);
            if77 = 1;
         }
      }
   }
   fclose(fpin);
   if (comp)
      free(comp);
/*
 * Add the flag to build shared objects, if we know what it is
 */
#ifdef ATL_DYLIBS
   for (i=0; i < NCOMP; i++)
   {
      if (i != XCC_)
      {
         if (CompIsGcc(comps[i]) || CompIsAppleGcc(comps[i]) || 
             CompIsPathScale(comps[i]))
         {
            if (!OSIsWin(OS))  /* windows/gcc bitches about -fPIC flag */
               comps[i+NCOMP] = NewAppendedString(comps[i+NCOMP],"-fPIC");
         }
         else if (CompIsMIPSpro(comps[i]))
            comps[i+NCOMP] = NewAppendedString(comps[i+NCOMP],"-KPIC");
         else if (CompIsSunWorkshop(comps[i]))
            comps[i+NCOMP] = NewAppendedString(comps[i+NCOMP],"-KPIC");
#if 0 /* I don't think a special flag is needed for shared obj wt xlc */
         else if (CompIsIBMXL(comps[i]))
            comps[i+NCOMP] = NewAppendedString(comps[i+NCOMP],"????");
#endif
      }
   }
#endif
/*
 * Only f77 and xcc allowed to be NULL
 */
   for (i=0; i < NCOMP; i++)
   {
      if (comps[i] == NULL)
      {
         if (i == XCC_)
         {
            comps[XCC_] = NewStringCopy(comps[ICC_]);
            comps[NCOMP+XCC_] = NewStringCopy(comps[ICC_+NCOMP]);
         }
         else assert(i == F77_);
      }
      if (comps[i+NCOMP] == NULL)
      {
         if (i == XCC_)
            comps[XCC_+NCOMP] = NewStringCopy(comps[ICC_+NCOMP]);
         else assert(i == F77_);
      }
   }
/*
 * Echo compiler info to screen if user has asked for verbose output
 */
   if (verb)
   {
      fprintf(stdout, "Selected compilers:\n");
      for (i=0; i < NCOMP; i++)
      {
         fprintf(stdout, "%s = '%s' '%s'\n", COMPNAME[i], 
                 comps[i] ? comps[i]:"none", 
                 comps[NCOMP+i]?comps[NCOMP+i]:"none");
      }
      if (if77)
      {
         fprintf(stdout, "\nF77 calling C interface information:\n");
         fprintf(stdout, "   Name decoration = %s\n", f2c_namestr[f2cname]);
         fprintf(stdout, "   Integer style   = %s\n", f2c_intstr[f2cint]);
         fprintf(stdout, "   String style    = %s\n", f2c_strstr[f2cstr]);
      }
      else
         fprintf(stderr, "F77/C interface not defined!");
   }
   if (!if77)
      f2cdefs = NULL;
   else
   {
      i = strlen(f2c_namestr[f2cname]) + strlen(f2c_intstr[f2cint]) +
          strlen(f2c_strstr[f2cstr]) + 16;
      f2cdefs = malloc(i*sizeof(char));
      assert(f2cdefs);
      sprintf(f2cdefs, "-D%s -D%s -DString%s", 
              f2c_namestr[f2cname], f2c_intstr[f2cint], f2c_strstr[f2cstr]);
   }
   return(f2cdefs);
}

int PathLength(char *str)
/*
 * Given string, finds end unix path, allowing \ to mean sticky space, stops at 
 * first non-sticky space.  Skips any leading spaces.
 * RETURNS: index of first non-sticky space
 * NOTE: Assumes str[-1] valid 
 */
{
   int i;
   for (i=0; isspace(str[i]); i++);  /* skip leading spaces */
   for (; str[i]; i++)
      if (str[i] == ' ' && i > 0 && str[i-1] != '\\') 
         break;
   return(i);
}

int TestF77LIB(int verb, char *targarg, enum OSTYPE OS, enum MACHTYPE arch, 
               char **comps, char *incd, char *f77lib)
{
   const char *frm ="make IRunTestCFLink F77='%s' F77FLAGS='%s' CC='%s' CCFLAGS='%s -L%s' F77LIB='%s' LIBS='-lm'";
   char *ln;
   int i;

   i = strlen(frm) + strlen(incd) + strlen(f77lib) +
       strlen(comps[F77_]) + strlen(comps[ICC_]) +
       strlen(comps[NCOMP+F77_]) + strlen(comps[NCOMP+ICC_]) + 1;
   ln = malloc(i*sizeof(char));
   assert(ln);
   sprintf(ln, frm, comps[F77_], comps[NCOMP+F77_], 
           comps[ICC_], comps[NCOMP+ICC_], incd, f77lib);
   if (verb > 1)
      fprintf(stderr, "cmnd = %s\n", ln);
   if (verb) 
      fprintf(stderr, "Trying F77 link path of %s ... ", incd);
   if (!system(ln))
   {
      if (verb) fprintf(stderr, "SUCCESS!\n");
      free(ln);
      return(1);
   }
   else if (verb)
      fprintf(stderr, "REJECTED!!!!\n");
   free(ln);
   return(0);
}

char *FindF77LIBInList(int verb, char *targarg, enum OSTYPE OS, 
                       enum MACHTYPE arch, char **comps, char *f77lib, 
                       char **paths)
{
   int i;
   if (!paths)
      return(NULL);
   for (i=0; paths[i]; i++)
   {
      char *path;
      path = GetPathWithoutName(paths[i]);
      if (path && TestF77LIB(verb, targarg, OS, arch, comps, path, f77lib))
      {
         free(path);
         return(FreeListGetString(paths, i));
      }
      free(path);
   }
   KillAllStringsInList(paths);
   return(NULL);
}

char *FindF77LIB0(int verb, char *targarg, enum OSTYPE OS, enum MACHTYPE arch, 
                  char **comps, char *f77lib, char *f77libnam, char *path)
{
   char *frm="find %s -name '%s'", *cmnd;
   char **libs=NULL;
   int i;
   i = strlen(frm) + strlen(f77libnam) + strlen(path) + 1;
   cmnd = malloc(i*sizeof(char));
   assert(cmnd);
   sprintf(cmnd, frm, path, f77libnam);
fprintf(stderr, "cmnd='%s'\n", cmnd);
   libs = GetLinesFromFile(atlsys(NULL, cmnd, verb, 1), NULL);
PrintAllStringsInList("FOUND:", libs);
   free(cmnd);
   if (!libs)
      return(NULL);

   return(FindF77LIBInList(verb, targarg, OS, arch, comps, f77lib, libs));
}

char *FindF77LIB(int verb, char *targarg, enum OSTYPE OS, enum MACHTYPE arch, 
                 char **comps, char *f77lib, char *f77libnam)
{
   char *path, *sp;
   int i;

/*
 * See if we can find by substituting "lib" for "bin" in compiler path
 */
   path = GetPathWithoutName(comps[F77_]);
   if (path)
   {
      sp = strstr(path, "/bin");
      if (sp)
      {
         sp[1] = 'l';
         sp[2] = 'i';
         sp[3] = 'b';
      }
      sp = FindF77LIB0(verb, targarg, OS, arch, comps, f77lib, f77libnam, path);
      free(path);
      if (sp)
         return(sp);
   }
/*
 * Scope some OS-specific places
 */
   if (OS == OSOSX)  /* /sw is for fink, /opt for macports */
   {
      sp = FindF77LIB0(verb, targarg, OS, arch, comps, f77lib, f77libnam, 
                       "/sw/lib /opt/lib /opt/local/lib");
      if (sp)
         return(sp);
   }
/*
 * Scope standard unix places
 */
   sp = FindF77LIB0(verb, targarg, OS, arch, comps, f77lib, f77libnam, 
           "/lib /usr/lib /usr/local/lib /lib64 /usr/lib64 /usr/local/lib64");
   if (verb)
   {
      if (sp)
         printf("F77libdir = %s\n", sp);
      else
         printf("F77LIB left blank\n");
   }
   return(sp);
}

char *BuildF77LinkLine(enum OSTYPE OS, char *path, char *libnam)
{
   char *sp, *OSextra="";
   int i;

   if (OSIsWin(OS))
      OSextra = "-lgcc";
   i = strlen(path) + strlen(libnam) + strlen(OSextra) + 2 + 2 + 1 + 1 + 1;
   sp = malloc(i*sizeof(char));
   assert(sp);
   sprintf(sp, "-L%s -l%s %s", path, libnam, OSextra);
   return(sp);
}

char *ProbeF77LIB(int verb, char *targarg, enum OSTYPE OS, 
                  enum MACHTYPE arch, char **comps, char *f2cdefs, int nof77)
/*
 * Tries to find the directory that needs to be included to link in f77
 * routines
 */
{
   char *cmnd, *res;
   char *f77lib, *F77LIBdir, *sp, *suff, *f77libnam;
   int i;
   char ch;

   if (nof77 || !f2cdefs) return(NULL);
   if (CompIsGcc(comps[F77_]))
   {
      if  (strstr(comps[F77_], "g77")) f77lib = "g2c";
      else f77lib = "gfortran";
   }
   else
   {
      if (verb > 1)
         fprintf(stderr, "Unknown F77 compiler, leaving F77LIBS blank!\n");
      return(NULL);
   }
/*
 * Figure out full name of the libgfortran we are looking ofr
 */
   if (OS == OSOSX)
      suff = ".dylib";
   else if (OSIsWin(OS))
      suff = ".dll.a";
   else
      suff = ".so";
   i = 3 + strlen(f77lib) + strlen(suff) + 1;
   f77libnam = malloc(i*sizeof(char));
   assert(f77libnam);
   sprintf(f77libnam, "lib%s%s", f77lib, suff);
/*
 * First, see if we can use 'gfortran -print-file-name=<f77libnam>' to
 * get definitive answer.  If so, return it.
 */
   i = strlen(comps[F77_]) + strlen(comps[F77_+NCOMP]) + strlen(f77libnam) + 21;
   sp = malloc(i*sizeof(char));
   assert(sp);
   sprintf(sp, "%s %s -print-file-name=%s", 
           comps[F77_], comps[F77_+NCOMP], f77libnam);
   res = atlsys_1L(NULL, sp, verb, 0);
   if (res)
   {
      free(f77libnam);
      free(sp);
      fprintf(stdout, "REPORTED: res=%s\n", res);
      sp = GetPathWithoutName(res);
      free(res);
      F77LIBdir = BuildF77LinkLine(OS, sp, f77lib);
      free(sp);
      if (verb)
         fprintf(stderr, "F77LIB = %s\n", F77LIBdir);
      return(F77LIBdir);
   }
   free(sp);
/*
 * If we are using a gfortran without the above option, try to parse
 * a verbose link line for the answer
 */
   i = strlen(comps[F77_]) + strlen(comps[NCOMP+F77_]) + 33;
   cmnd = malloc(i*sizeof(char));
   assert(cmnd);
   sprintf(cmnd,  "make IRunFlib F77='%s' F77FLAGS='%s'",
           comps[F77_], comps[NCOMP+F77_]);
   if (verb > 1)
      fprintf(stderr, "LIBDIR cmnd = %s\n", cmnd);
   res = atlsys_1L(NULL, cmnd, verb, 0);
   free(cmnd);
   if (verb > 1)
      fprintf(stderr, "LIBDIR res = %s\n", res);
/*
 * Find which -L leads us to f77lib
 */
   sp = res;
   while (sp = strstr(sp, "-L"))
   {
      sp += 2;
      i = PathLength(sp); 
      if (i)
      {
         char *sp2;
         ch = sp[i];
         sp[i] = '\0';
         sp2 = NewStringCopy(sp);
         sp2 = NewAppendedString(sp2, f77libnam);
         if (FileIsThere(sp2) &&
             TestF77LIB(verb, targarg, OS, arch, comps, sp, f77lib))
         {
            F77LIBdir = NewStringCopy(sp-2);
            F77LIBdir = NewAppendedString(F77LIBdir, "-l");
            F77LIBdir = NewAppendedString0(F77LIBdir, f77lib);
            if (OSIsWin(OS))
               F77LIBdir = NewAppendedString(F77LIBdir, "-lgcc");
            if (verb)
               fprintf(stderr, "F77LIB = %s\n", F77LIBdir);
            free(sp2);
            free(f77libnam);
            free(res);
            return(F77LIBdir);
         }
         free(sp2);
         sp[i] = ch;
         sp += i;
      }
   }
   free(res);
   sp = FindF77LIB(verb, targarg, OS, arch, comps, f77lib, f77libnam);
   free(f77libnam);
   if (sp)
   {
      F77LIBdir = NewStringCopy("-L");
      suff = GetPathWithoutName(sp);
      F77LIBdir = NewAppendedString0(F77LIBdir, suff);
      free(suff);
      free(sp);
      F77LIBdir = NewAppendedString(F77LIBdir, "-l");
      F77LIBdir = NewAppendedString0(F77LIBdir, f77lib);
      if (OSIsWin(OS))
         F77LIBdir = NewAppendedString(F77LIBdir, "-lgcc");
      if (verb)
         fprintf(stderr, "F77LIB = %s\n", F77LIBdir);
   }
   return(NULL);
}

enum OSTYPE ProbeOS(int verb, char *targarg)
{
   enum OSTYPE iret;

   iret = GetIntProbe(verb, targarg, "OS", "OS", NOS);
   printf("\nOS configured as %s (%d)\n", osnam[iret], iret);
   assert(iret);
   return(iret);
}

enum ASMDIA ProbeAsm(int verb, char *targarg, enum OSTYPE OS)
{
   enum ASMDIA asmd=ASM_None;
   char *ln;
   int i;

   i = strlen(targarg) + 11 + 5;
   ln = malloc(i*sizeof(char));
   assert(ln);
   sprintf(ln, "%s -O %d", targarg, OS);
   asmd = GetIntProbe(verb, ln, "asm", "ASM", NASMD);
   free(ln);
   printf("\nAssembly configured as %s (%d)\n", ASMNAM[asmd], asmd);
   return(asmd);
}

int ProbeVecs(int verb, char *targarg, enum OSTYPE OS, enum ASMDIA asmb)
{
   int i, iret;
   char *ln;

   i = strlen(targarg) + 22 + 9;
   ln = malloc(i*sizeof(char));
   assert(ln);
   sprintf(ln, "%s -O %d -s %d", targarg, OS, asmb);
   iret = GetIntProbe(verb, ln, "vec", "VECFLAG", (1<<NISA));
   free(ln);
   for (i=0; i < NISA && (iret & (1<<i)) == 0; i++);
   if (i == NISA)
      i = 0;
   printf("\nVector ISA Extension configured as  %s (%d,%d)\n", 
          ISAXNAM[i], i, iret);
   return(iret);
}

int ProbeArch(int verb, char *targarg, enum OSTYPE OS, enum ASMDIA asmb)
{
   int i, iret;
   char *ln;

   i = strlen(targarg) + 22 + 12;
   ln = malloc(i*sizeof(char));
   assert(ln);
   sprintf(ln, "%s -O %d -s %d -a", targarg, OS, asmb);
   iret = GetIntProbe(verb, ln, "arch", "MACHTYPE", NMACH);
   free(ln);
   printf("\nArchitecture configured as  %s (%d)\n", 
          machnam[iret], iret);
   return(iret);
}

int ProbeMhz(int verb, char *targarg, enum OSTYPE OS, enum ASMDIA asmb)
{
   int i, iret;
   char *ln;

   i = strlen(targarg) + 22 + 12;
   ln = malloc(i*sizeof(char));
   assert(ln);
   sprintf(ln, "%s -O %d -s %d -m", targarg, OS, asmb);
   if (verb > 2)
      printf("Mhz Probe = '%s'\n", ln);
   iret = GetIntProbe(verb, ln, "arch", "CPU MHZ", 16384);
   free(ln);
   printf("\nClock rate configured as %dMhz\n", iret);
   return(iret);
}

int ProbeNcpu(int verb, char *targarg, enum OSTYPE OS, enum ASMDIA asmb)
{
   int i, iret;
   char *ln;

   i = strlen(targarg) + 22 + 12;
   ln = malloc(i*sizeof(char));
   assert(ln);
   sprintf(ln, "%s -O %d -s %d -n", targarg, OS, asmb);
   iret = GetIntProbe(verb, ln, "arch", "NCPU", 2048);
   printf("\nMaximum number of threads configured as  %d\n", iret);
   free(ln);
   return(iret);
}

int ProbePtrbits(int verb, char *targarg, enum OSTYPE OS, enum ASMDIA asmb)
{
   int i, iret;
   char *ln;

   i = strlen(targarg) + 22 + 12;
   ln = malloc(sizeof(char)*i);
   assert(ln);
   sprintf(ln, "%s -O %d -s %d -b", targarg, OS, asmb);
   iret = GetIntProbeSure(verb, ln, "arch", "PTR BITS", &i);
   free(ln);
/*
 * If it's not 64-bit, make sure it's not just because of flag setting
 */
   if (iret != 64)
   {
   }
   if (iret != 64)
      iret = 32;
   printf("\nPointer width configured as %d\n", iret);
   return(iret);
}

int ProbeCPUThrottle(int verb, char *targarg, enum OSTYPE OS, enum ASMDIA asmb)
{
   int i, iret;
   char *ln;
   i = strlen(targarg) + 22 + 12;
   ln = malloc(i*sizeof(char));
   assert(ln);
   sprintf(ln, "%s -O %d -s %d -t", targarg, OS, asmb);
   iret = GetIntProbe(verb, ln, "arch", "CPU THROTTLE", 0);
   free(ln);
   if (iret) printf("CPU Throttling apparently enabled!\n");
   else printf("Cannot detect CPU throttling.\n");
   return(iret);
}

char *NewAppendedString_SFLAG(char *old, char *flag, char *str)
/*
 * RETURNS: string holding <old> + " <flag> '<str>'"
 * NOTE: frees old string after copy
 */
{
   char *new;
   int i;

   i = (old) ? strlen(old)+1 : 1;
   i += 1 + strlen(flag) + 1 + 1 + strlen(str) + 1 + 1;
   new = malloc(i*sizeof(char));
   assert(new);
   sprintf(new, "%s %s '%s'", (old)?old:"", flag, str);
   free(old);
   return(new);
}

char *NewAppendedString_IFLAG(char *old, char *flag, int iflag)
/*
 * RETURNS: string holding <old> + " <flag> <iflag>"
 * NOTE: frees old string after copy
 */
{
   char *new;
   int i;

   i = (old) ? strlen(old)+1 : 1;
   i += 1 + strlen(flag) + 1 + 11;
   new = malloc(i*sizeof(char));
   assert(new);
   sprintf(new, "%s %s %d", (old)?old:"", flag, iflag);
   free(old);
   return(new);
}

char *Comps2Flags(char **comps)
/*
 * Takes the comps array (1st NCOMP entries are compilers, next NCOMP entries
 * flags for those compilers) and translates them into the corresponding flags
 * for xspew (or indeed this config.c)
 * NOTE: assumes appended flags (2*NCOMP+i) already appended to flags (NCOMP+i)
 */
{
   char *cname[NCOMP] = {"ic", "sm", "dm", "sk", "dk", "xc", "gc", "if"};
   char *flags=NULL;
   int i, j=0;

   for (i=0; i < NCOMP; i++)
   {
      char stmp[6] = {'-', 'X', ' ', cname[i][0], cname[i][1], '\0'};
      if (comps[i])
      {
         stmp[1] = 'C';
         flags = NewAppendedString_SFLAG(flags, stmp, comps[i]);
      }
      if (comps[NCOMP+i])
      {
         stmp[1] = 'F';
         flags = NewAppendedString_SFLAG(flags, stmp, comps[NCOMP+i]);
      }
   }
   return(flags);
}

char *ProbePmake(int verb, enum OSTYPE OS, int ncpu)
/*
 * WARNING: if cross-comp really worked, this would be ncpu of front-end,
 *          not backend!
 */
{
   char args[32], *res;
   char *sp;
   int i;

   sprintf(args, "-O %d -t %d", OS, ncpu);

   res = GetStrProbe(verb, args, "pmake", "PMAKE");
   if (res) printf("Parallel make command configured as '%s'\n", res);
   else printf("Parallel make not configured.\n");
   return(res);
}


@extract -b @(basd)/atlconf.base rout=GetFlags -def allflags "1" -def -thrchk "1" -def -nocygwin "1"

void SpewItForth(int verb, enum OSTYPE OS, enum MACHTYPE arch, int mhz,
                 enum ASMDIA asmb, int vecexts, int ptrbits, int nreg,
                 int ncpu, int *tids, int l2size, char *srcdir, char *bindir,
                 int SIflag, char **comps, char *gccflags,
                 char *f2cdefs, char *cdefs, char *pmake, char *flapack, 
                 char *smaflags, char *dmaflags, char *f77libs, char *ADd)
/*
 * Calls xspew with correct arguments to build required Make.inc
 */
{
   char *frm = "./xspew -v %d -O %d -A %d -m %d -s %d -V %d -b %d -f %d -d s '%s' -d b '%s' -D c '%s' -D f '%s' %s -Si archdef %d -Si ieee %d -Si bozol1 %d -Si latune %d -Si nof77 %d -Si fko %d -o Make.inc";
   char *ln, *compsflags, archflags[1024];
   int i;

   assert(!system("make xspew"));
   compsflags = Comps2Flags(comps);  /* Xlate comp/flag array to xspew flags */
   i = strlen(frm) + 11*14 + strlen(srcdir) + strlen(bindir);
   if (cdefs)
      i += strlen(cdefs);
   if (nreg)
      i += 16;
   if (f2cdefs)
      i += strlen(f2cdefs);
   i += strlen(compsflags);
   if (tids)
   {
      i += ncpu * 12 + 6;
   }
   else
      i += 16;
   ln = malloc(i*sizeof(char));
   assert(ln);
   i = sprintf(ln, frm, verb, OS, arch, mhz, asmb, vecexts, ptrbits, l2size,
               srcdir, bindir, cdefs ? cdefs:"", f2cdefs? f2cdefs : "", 
               compsflags, SI_IS_TRUE(SIflag,SI_ARCHDEF), 
               SI_IS_TRUE(SIflag,SI_IEEE), SI_IS_TRUE(SIflag,SI_BOZOL1), 
               SI_IS_TRUE(SIflag,SI_LATUNE), SI_IS_TRUE(SIflag,SI_NOF77),
               SI_IS_TRUE(SIflag,SI_FKO));
   free(compsflags);
   if (tids)
   {
      int k;
      i += sprintf(ln+i, " -tl %d", ncpu);
      for (k=0; k < ncpu; k++)
         i += sprintf(ln+i, " %d", tids[k]);
   }
   else
      i += sprintf(ln+i, " -t %d", ncpu);
   if (nreg)
      i += sprintf(ln+i, " -r %d", nreg);
   if (pmake)
      ln = NewAppendedString_SFLAG(ln, "-Ss pmake", pmake);
   if (flapack)
      ln = NewAppendedString_SFLAG(ln, "-Ss flapack", flapack);
   if (smaflags)
      ln = NewAppendedString_SFLAG(ln, "-Ss smaflags", smaflags);
   if (dmaflags)
      ln = NewAppendedString_SFLAG(ln, "-Ss dmaflags", dmaflags);
   if (f77libs)
      ln = NewAppendedString_SFLAG(ln, "-Ss f77lib", f77libs);
   if (ADd)
      ln = NewAppendedString_SFLAG(ln, "-Ss ADdir", ADd);
   if (SI_IS_TRUE(SIflag,SI_OMP))
      ln = NewAppendedString_IFLAG(ln, "-Si omp", SI_IS_TRUE(SIflag,SI_OMP));
@skip   if (AntThr)
@skip      ln = NewAppendedString_IFLAG(ln, "-Si antthr", AntThr);
   if (SI_IS_TRUE(SIflag,SI_LAREF))
      ln = NewAppendedString_IFLAG(ln, "-Si lapackref", 
                                   SI_IS_TRUE(SIflag,SI_LAREF));
   if (gccflags)
      ln = NewAppendedString_SFLAG(ln, "-Fa gc", gccflags);
   if (verb > 1)
      fprintf(stderr, "cmnd='%s'\n", ln);
   syschk(ln);
   free(ln);
}

int main(int nargs, char **args)
{
   enum OSTYPE OS;
   enum MACHTYPE mach=MACHOther;
   int i, verb, asmb, f2cname, f2cint, f2cstr, ncpu, nof77, nocygwin;
   int thrchk, mhz, omp, AntThr, nreg;
   int j, k, h, vecexts;
   int ptrbits, l2size, SIflag;
   int *tids;
   char *targ, *f2cdefs, *cdefs, *srcdir, *bindir, *outfile, *sp;
   char targarg[256];
   char *comps[3*NCOMP], *gccflags;
   char *pmake, *flapack, *smaflags, *dmaflags, *f77libs, *ADd;
@skip   char *archdefs[NARDEF], *ad2[NARDEF];

   GetFlags(nargs, args, &verb, &OS, (enum ASMDIA*) &asmb, &vecexts, &mach, 
            &mhz, &ptrbits, &nreg, &ncpu, &tids, comps, &gccflags, &outfile, 
            &srcdir, &bindir, &SIflag, &f2cdefs, 
            &cdefs, &pmake, &flapack, &smaflags, &dmaflags, &f77libs, &ADd, 
            &l2size, &targ);
   nof77 = SI_IS_TRUE(SIflag,SI_NOF77);
   nocygwin = SI_IS_TRUE(SIflag,SI_NOCYGWIN);
   thrchk = !SI_IS_TRUE(SIflag, SI_SKPTHRCHK);
   if (targ)
      sprintf(targarg, "-T %s", targ);
   else
      targarg[0] = '\0';
   if (OS == OSOther)
      OS = ProbeOS(verb, targarg);
   if (asmb == ASM_None)
      asmb = ProbeAsm(verb, targarg, OS);
   else if (asmb < 0)
      asmb = 0;
   if (asmb == gas_arm)
   {
      char defs[32], *sp;
      sprintf(defs, "-DATL_OS_%s", osnam[OS]);
      sp = GetStrProbe(verb, defs, "ARM_HARDFP", "FPABI");
      if (sp)
      {
         if (!strcmp(sp, "HARDFP"))
            cdefs = NewAppendedString(cdefs, "-DATL_ARM_HARDFP=1");
         else if (!strcmp(sp, "SOFTFP"))
            cdefs = NewAppendedString(cdefs, "-DATL_ARM_SOFTFP=1");
         free(sp);
      }
   }
   if (!vecexts)
      vecexts = ProbeVecs(verb, targarg, OS, asmb);
   else if (vecexts < 0)
      vecexts = 0;
   if (mach == MACHOther)
      mach = ProbeArch(verb, targarg, OS, asmb);
   if (!mhz)
      mhz = ProbeMhz(verb, targarg, OS, asmb);
   if (ncpu < 0)
      ncpu = ProbeNcpu(verb, targarg, OS, asmb);
   if (!pmake && ncpu > 1)
      pmake = ProbePmake(verb, OS, ncpu);
   if (ptrbits == 0)
   {
      if (asmb == gas_x86_64 || asmb == gas_wow64)
         ptrbits = 64;
      else
         ptrbits = ProbePtrbits(verb, targarg, OS, asmb);
   }
   if (mach != TI_C66_BM && ProbeCPUThrottle(verb, targarg, OS, asmb))
   {
      fprintf(stderr, 
         "It appears you have cpu throttling enabled, which makes timings\n");
      fprintf(stderr, 
              "unreliable and an ATLAS install nonsensical.\n\n");

      fprintf
      (stderr,
"OS-controlled CPU throttling is so course grained, that timings become\n"
"essentially random.  What this means for an ATLAS install is that ATLAS\n"
"cannot tell the difference between a good and bad kernel, and so the\n"
"tuning step may result in arbitrarily bad performance.  If you don't care\n"
"about performance, you are usually better off just using the reference BLAS.\n"
"\nIf you fear overheating, setting clock speed to some lower, constant\n"
"value should give you a decent install.\n\n"
"Hardware-controlled throttling is usually much finer grained, and therefore\n"
"may result in mediocre tuning, but this will depend quite bit on luck.\n\n"
"If your machine has OS throttling enabled, it is critical that you disable\n"
"it (with something like cpufreq-set).  See INSTALL.txt for details.\n\n"
"If you you do not care at all about performance, you can rerun configure\n"
"with --cripple-atlas-performance to proceed in the face of throttling.\n"
"Do not do this unless you really don't care about performance.\n"
"If you are able to turn off throttling, rerun configure as normal\n"
"once you have done so.\n\n"
      );
      if (thrchk)
      {
         fprintf(stderr, "Aborting due to throttling\n");
         exit(1);
      }
   }
/* 
 * Override 32/64 bit assembler if asked
 */
@skip   if (asmb == gas_x86_64 && ptrbits == 32)
   if ((asmb == gas_x86_64 || asmb == gas_wow64) && ptrbits == 32)
      asmb = gas_x86_32;
   else if (asmb == gas_x86_32 && (ptrbits == 64 || ptrbits == -32))
      asmb = gas_x86_64;
/*
 * Now that we've detected architecture stuff, kill assembly dialect for
 * 64-bit install of Win64, since we can't use our normal AMD64 assembly
 * there due to incompatable ABI
 */
   if (OS == OSWin64 && ptrbits == 64)
      asmb = ASM_None;
/*
 * Don't try to use assembly for TI accelerator install
 */
   if (mach == TI_C66_BM)
      asmb = ASM_None;

   sp = ProbeComp(verb, targarg, OS, mach, comps, nof77, nocygwin, ptrbits, 
                  vecexts);
   if (nof77)
      f2cdefs = NewStringCopy("-DATL_NoF77");
   else if (!f2cdefs) f2cdefs = sp;
   if (!f77libs)
      f77libs = ProbeF77LIB(verb, targarg, OS, mach, comps, f2cdefs, nof77);
/*
 * If user has not specified muladd flags (which are suffixed to kernel flags),
 * add flags to keep gcc 4 from hanging, if necessary
 */
   SpewItForth(verb, OS, mach, mhz, asmb, vecexts, ptrbits, nreg, ncpu, tids,
               l2size, srcdir, bindir, SIflag, comps, gccflags, f2cdefs, cdefs, 
               pmake, flapack, smaflags, dmaflags, f77libs, ADd);
   for (i=0; i < 3*NCOMP; i++)
      if (comps[i])
         free(comps[i]);
   free(f77libs);
   free(cdefs);
   free(f2cdefs);
   free(pmake);
/*
 * Cleanup directory, and exit
 */
   system("make confclean");
   return(0);
}
@ROUT ATLrun_TI.sh
#!/bin/sh
atldir=\$1
shift
atlexe=\$1
shift
#
# Replace this if with your setup structure
#
if [ ! -e "/tmp/evm-input.fifo" ]
then
   pushd ~/runscript
   ./mmsetup
   popd
fi
start=\$((\$(date +%s%N)/1000000))
echo \"[\`date -R\`] \$atldir/\$atlexe.out \$*\" >> ATLrun.log
echo \"\$atldir/\$atlexe.out \$*\" >> ATLrun.log

#
# Replace this line with your accelerator runscript
#
~/runscript/mmrun \$atldir/\$atlexe.out \$*

finish=\$((\$(date +%s%N)/1000000))
echo \"[\`date -R\`] \$atldir/\$atlexe.out \$*\" >> ATLrun.log
let z=finish-start
duration=\`bc <<< \"scale=3; \$z/1000\"\`
echo \"[\`date -R\`] command finished in \$duration seconds\" >> ATLrun.log
@ROUT ATLrun_ssh.sh
#!/bin/sh
# This script is for machines with shared filesystems.
#
#
# User should replace this macro def with the name of target machine
#
mach=MyMach

atldir=$1
shift
ssh $mach "cd $atldir ; ./$exe $*"
@ROUT ATLrun.sh
#!/bin/sh
atldir=$1
shift
$atldir/$*
#mach=MyMach
#rdir=/tmp
#atldir=$1
#shift
#exe=$1
#shift
#scp $atldir/$exe $mach:$(rdir)/$exe
#ssh $mach "cd $rdir ; ./$exe $*"
@ROUT configure
#!/bin/sh
#
# BFI configure-like script to bootstrap ATLAS's C-based config scripts
# dependencies: sed, pwd
# shell built-in deps: echo, test
#
cc=gcc
cflags="-g -w"
prefix=/usr/local/atlas
incinstdir=ATL_NoOverride
libinstdir=ATL_NoOverride
flapack=ATL_NoOverride
flapacktar=ATL_NoOverride
f77=1
aff=1
fulllapack=0
usefko=0
usetids=0
tidlist=
#
# path is configure path without trailing configure :)
#
path=`echo $0 | sed -e "s/configure$//"`
#
# blddir is present directory
#
blddir=`pwd`
#
# If on cygwin, prefix blddir with /cygdrive/[c,d]/
#
if [ -d /cygdrive ]
then
   if [ -d /cygdrive/c/cygwin/$blddir ]
   then
        blddir=/cygdrive/c/cygwin/$blddir
   else
      if [ -d /cygdrive/d/cygwin/$blddir ]
      then
        blddir=/cygdrive/d/cygwin/$blddir
      fi
   fi
fi
#
# topdir is simply path if the line does not begin with "../" and is
#  blddir/path otherwise
chk=`echo "$path" | sed -e "s/^\.\.\///"`
if test "$chk" = "$path"
then
   topdir="$path"
else
   topdir="$blddir"/"$path"
fi
#
# Error out if topdir == blddir
#
touch $blddir/TstBld973.txt
if [ -f "$topdir/TstBld973.txt" ]
then
   echo "ATLAS can no longer be  configured in the exact source directory,"
   echo "create a subdir such as MyObj.  See ATLAS/INSTALL.txt for help."
   rm $blddir/TstBld973.txt
   exit 1
fi
rm $blddir/TstBld973.txt

#
# grab --cc=<c comp> and --cflags=<flags> to be used to build ATLAS's ANSI C
# config.c, and save the rest of the arguments to by passed to the 
# soon-to-be-built xconfig
#
#echo other args=$*
bitwidth=0
rdbitwidth=0
dylib=0
accel=0  # 1: TI_C66_BM, 2: Xeon Phi
irtarg=0
rtarg=
for arg in "$@"
do
   handled=0
   flag=`echo "$arg" | sed -e "s/--help//"`
   if test "$flag" != "$arg"
   then
      echo "ATLAS config includes this script, and probes written in C."
      echo "Therefore, configure flags are union of script and probe flags."
      echo "This configure script accepts the following flags:"
      echo "   --force-clang=/path/to/clang : use clang not gcc all C comps"
      echo "   --cc=<C compiler> : compiler to compile configure probes"
      echo "   --cflags='<flags>' : flags for above"
      echo "   --prefix=<dirname> : Toplevel installation directory."
      echo "                        Default: /usr/local/atlas"
      echo "   --incdir=<dirname> : Installation dir for include files"
      echo "                        Default: $prefix/include"
      echo "   --libdir=<dirname> : Installation dir for libraries"
      echo "                        Default: $prefix/lib"
      echo "   --rtarg=<mach> : remote cross-compile target machine"
      echo "   --accel=[0/1/2] : build for accelerator:"
      echo "     0: Don't build for accelerator"
      echo "     1: Build for TI_C66_BM"
      echo "     2: Build for Xeon Phi"
      echo "   --shared : same as --dylibs"
      echo "   --dylibs : build dynamic/shared libs in addition to static libs"
      echo '   --force-tids="<#> threadIDlist"'
      echo "   --nof77 : You have no Fortran compiler installed.  Note that"
      echo "             this will disallow building the F77 interface, and"
      echo "             some of the tests (eg, standard BLAS testers)"
      echo "  --with-netlib-lapack-tarfile=<path to lapack tarfile>"
      echo "  --use-ifko : use iFKO to improve ATLAS performance"
      echo "  --no-affinity : do not use affinity for threads"
@beginskip
      echo "  --with-netlib-lapack=<path to lapack.a>"
      echo "     Use this library to build a mixed netlib/ATLAS LAPACK."
      echo "     The two libs will be merged so they must be built wt compatible compilers."
@endskip
      echo "  --gcc3pass=<gcc for frontend>,<assembler>:<linker>"
      echo "     Provide full paths for all compilers/assemblers"
@skip      echo "  --apple-is-evil=<gcc for frontend>,<clang for backend>"
@skip      echo "     Provide full paths to both compilers"
      echo "Attempting to build xconfig to get probe flags:"
      rm -f Makefile > /dev/null 2>&1
      echo BLDdir="$blddir" >> Makefile
      echo TOPdir="$topdir" >> Makefile
      echo "SRCdir = \$(TOPdir)/CONFIG/src" >> Makefile
      echo "INCdir = \$(TOPdir)/CONFIG/include" >> Makefile
      echo "mydir = \$(BLDdir)" >> Makefile
      echo XCC="$cc" >> Makefile
      echo CFLAGS="$cflags" >> Makefile
      echo "INCFLAGS = -I\$(INCdir)" >> Makefile
      echo "MYFLAGS =" >> Makefile
      echo "XCFLAGS = \$(INCFLAGS) \$(MYFLAGS) \$(CFLAGS)" >> Makefile
      cat "$path"/CONFIG/src/Makefile >> Makefile
      make xconfig # > /dev/null 2>&1
      ./xconfig --help
@skip      rm -f Makefile xconfig atlconf_misc.o > /dev/null 2>&1
      exit 1
   fi
#
# Look for config flag -b <bidwidth>, if we find it set bitwidth to read next
# args val, but don't set handled, since flag must be passed to config as well
#
   if test $rdbitwidth -eq 1
   then
      rdbitwidth=0
      if test "$arg" -eq "64"
      then
         bitwidth=64
      fi
      if test "$arg" -eq "32"
      then
         bitwidth=32
      fi
   fi
   if test "$arg" = "-b"
   then
      rdbitwidth=1
   fi
#
#
   flag=`echo "$arg" | sed -e "s/--prefix=//"`
   if test "$flag" != "$arg"
   then
      prefix="$flag"
      handled=1
   fi
#
   flag=`echo "$arg" | sed -e "s/--libdir=//"`
   if test "$flag" != "$arg"
   then
      libinstdir="$flag"
      handled=1
   fi
#
   flag=`echo "$arg" | sed -e "s/--rtarg=//"`
   if test "$flag" != "$arg"
   then
      irtarg=1
      rtarg="$flag"
      handled=1
   fi
#
   flag=`echo "$arg" | sed -e "s/--incdir=//"`
   if test "$flag" != "$arg"
   then
      incinstdir="$flag"
      handled=1
   fi
   flag=`echo "$arg" | sed -e "s/--force-clang=//"`
   if test "$flag" != "$arg"
   then
      cc=$flag
      pass="$pass -C ac $flag -C gc $flag"
      handled=1
   fi
   flag=`echo "$arg" | sed -e "s/--accel=//"`
   if test "$flag" != "$arg"
   then
      if test "$flag" -eq "1"
      then
         pass="$pass -A TI_C66_BM -D c -DATL_NOPREFETCH=1"
         accel=1
      elif test "$flag" -eq "2"
      then
         accel=2
         pass="$pass -A XeonPHI"
      fi
      handled=1
   fi
   flag=`echo "$arg" | sed -e "s/--cripple-atlas-performance//"`
   if test "$flag" != "$arg"
   then
      pass="$pass -Si cripple-perf 1"
      handled=1
   fi
   flag=`echo "$arg" | sed -e "s/--force-tids=//"`
   if test "$flag" != "$arg"
   then
      usetids=1
      tidlist=$flag
      pass="$pass -tl $flag"
      handled=1
   fi
   flag=`echo "$arg" | sed -e "s/--shared//"`
   if test "$flag" != "$arg"
   then
      dylib=1
      pass="$pass -D c -DATL_DYLIBS"
      cflags="$cflags -DATL_DYLIBS"
      handled=1
   fi
   flag=`echo "$arg" | sed -e "s/--dylibs//"`
   if test "$flag" != "$arg"
   then
      dylib=1
      pass="$pass -D c -DATL_DYLIBS"
      cflags="$cflags -DATL_DYLIBS"
      handled=1
   fi
#  --gcc3pass=gcc,as:lnk
   flag=`echo "$arg" | sed -e "s/--gcc3pass=//"`
   if test "$flag" != "$arg"
   then
      ccC=`echo "$flag" | sed -e "s/,.*//"`
      ccA=`echo "$flag" | sed -e "s/.*,//" -e "s/:.*//"`
      ccL=`echo "$flag" | sed -e "s/.*://"`
      echo "#define MYGCC \"$ccC\"" > $blddir/gcc3p.c
      echo "#define MYASM \"$ccA\"" >> $blddir/gcc3p.c
      echo "#define MYLNK \"$ccL\"" >> $blddir/gcc3p.c
      cat $topdir/CONFIG/src/gcc3p.c >> $blddir/gcc3p.c
      $ccL -O -o $blddir/gcc3p $blddir/gcc3p.c
      cc=$blddir/gcc3p
      cflags="$cflags -DATL_GCC3P"
      handled=1
   fi
#
   flag=`echo "$arg" | sed -e "s/--apple-is-evil=//"`
   if test "$flag" != "$arg"
   then
      ccF=`echo "$flag" | sed -e "s/,.*//"`
      ccB=`echo "$flag" | sed -e "s/.*,//"`
      echo "#define MYGCC \"$ccF\"" > $blddir/gccclang.c
      echo "#define MYASM \"$ccB\"" >> $blddir/gccclang.c
      echo "#define MYLNK \"$ccB\"" >> $blddir/gccclang.c
      cat $topdir/CONFIG/src/gnuccw.c >> $blddir/gccclang.c
      $ccB -O -o $blddir/gccclang $blddir/gccclang.c
      cc=$blddir/gccclang
      cflags="$cflags -DATL_GCCCLANG"
      handled=1
   fi
#
   flag=`echo "$arg" | sed -e "s/--with-netlib-lapack-tarfile=//"`
   if test "$flag" != "$arg"
   then
      flapacktar="$flag"
      pass="$pass -Si lapackref 1"
@skip      pass="$pass -Ss lasrc $blddir/src/lapack/reference/src/"
      handled=1
      fulllapack=1
   fi
   flag=`echo "$arg" | sed -e "s/--use-ifko//"`
   if test "$flag" != "$arg"
   then
      usefko=1
      pass="$pass -Si fko 1"
      handled=1
   fi
#
@beginskip
   flag=`echo "$arg" | sed -e "s/--with-netlib-lapack=//"`
   if test "$flag" != "$arg"
   then
      flapack="$flag"
      pass="$pass -Ss flapack $flapack"
      handled=1
      fulllapack=1
   fi
@endskip
#
   flag=`echo "$arg" | sed -e "s/--noaffinity//"`
   if test "$flag" != "$arg"
   then
      aff=0
      handled=1
   fi
#
   flag=`echo "$arg" | sed -e "s/--nof77//"`
   if test "$flag" != "$arg"
   then
      f77=0
      pass="$pass -Si nof77 1"
      handled=1
      fulllapack=0
   fi
#
   flag=`echo "$arg" | sed -e "s/--cc=//"`
   if test "$flag" != "$arg"
   then
      cc="$flag"
       handled=1
   else
      flag=`echo "$arg" | sed -e "s/--cflags=//"`
      if test "$flag" != "$arg"
      then
         handled=1
         if test $dylib -eq 0
         then
            cflags="$flag"
         else
            cflags="$flag -DATL_DYLIBS"
         fi
      fi
   fi
   if test $handled -eq 0
   then
#
#     Get rid of leading and trailing spaces
#
      arg=`echo "$arg" | sed -e "s/^ +//"`
      arg=`echo "$arg" | sed -e "s/ +$//"`
# 
#     If flag have internal spaces, surround it with ''
#
      flag=`echo "$arg" | sed -e "s/ //"`
      if (test "$flag" != "$arg")
      then
         pass="$pass '`echo "$arg"`'"
      else
         pass="$pass $arg"
      fi
   fi
done
OSGUESS=`uname`
#
# Need to do some special crap for AIX installs
#
flag=`echo "$OSGUESS" | sed -e "s/AIX//"`
if test "$flag" != "$OSGUESS"
then
   if test $bitwidth -eq 64
   then
      export OBJECT_MODE=64
      if test $cc = "gcc"
      then
         flag=`echo "$cflags" | sed -e "s/-maix//"`
         if test "$flag" = "$cflags"
         then
             cflags="$cflags -maix64"
         fi
      fi
   else
      export OBJECT_MODE=32
   fi
fi
if test $incinstdir = "ATL_NoOverride"
then
   incinstdir='$(DESTDIR)/include'
fi
if test $libinstdir = "ATL_NoOverride"
then
   libinstdir='$(DESTDIR)/lib'
fi
#
# Copy the correct ATLrun.sh over
#
if test $accel -eq 1
then
   cp "$path"/CONFIG/src/ATLrun_TI.sh ATLrun.sh
elif test $irtarg -ne 0
then
   echo "#!/bin/sh" > ATLrun.sh
   echo "rtarg=$rtarg" >> ATLrun.sh
   echo "atldir=\$1" >> ATLrun.sh
   echo "shift"  >> ATLrun.sh
   echo "exe=\$1" >> ATLrun.sh
   echo "shift"  >> ATLrun.sh
   echo "ssh \$rtarg \"cd \$atldir ; ./\$exe \$*\"" >> ATLrun.sh
   chmod u+x ATLrun.sh
elif test $usetids -eq 1
then
   echo "#!/bin/sh" > ATLrun.sh
   echo "atldir=\$1" >> ATLrun.sh
   echo "shift" >> ATLrun.sh
   flag=`echo "$tidlist" | sed -e "s/[0-9]* // ; s/\([0-9]\) /\1,/g ; s/, *$//"`
   echo "taskset -c $flag \$atldir/\$*" >> ATLrun.sh
   chmod u+x ATLrun.sh
else
   cp "$path"/CONFIG/src/ATLrun.sh ATLrun.sh
fi
#
# Create the Makefile and copy the compiler info file
#
echo SHELL=/bin/sh > Makefile
echo BLDdir="$blddir" >> Makefile
echo TOPdir="$topdir" >> Makefile
echo "SRCdir = \$(TOPdir)/CONFIG/src" >> Makefile
echo "INCdir = \$(TOPdir)/CONFIG/include" >> Makefile
echo "mydir = \$(BLDdir)" >> Makefile
echo XCC="$cc" >> Makefile
echo CFLAGS="$cflags" >> Makefile
echo "INCFLAGS = -I\$(INCdir)" >> Makefile
echo "MYFLAGS =" >> Makefile
echo "XCFLAGS = \$(INCFLAGS) \$(MYFLAGS) \$(CFLAGS)" >> Makefile
if test $accel -eq 2
then
   echo "CC = icc" >> Makefile
   echo "CCFLAGS = \$(XCFLAGS) -mmic" >> Makefile
else
   echo "CC = \$(XCC)" >> Makefile
   echo "CCFLAGS = \$(XCFLAGS)" >> Makefile
fi
echo DESTDIR="$prefix" >> Makefile
echo INCINSTdir="$incinstdir" >> Makefile
echo LIBINSTdir="$libinstdir" >> Makefile
if test $accel -eq 1
then
   echo atlrun = atlas_runTI >> Makefile
elif test $irtarg -ne 0
then
   echo atlrun = atlas_runX >> Makefile
else
   echo atlrun = atlas_run >> Makefile
fi
if test $f77 -eq 0
then
   fulllapack=0
   echo TESTS=C_test >> Makefile
   echo PTTESTS=C_pttest >> Makefile
else
   echo TESTS=test >> Makefile
   echo PTTESTS=pttest >> Makefile
fi
#
# Setup targets to build dynamic/shared libs if user has requested it
#
echo "def : build" >> Makefile
echo "shared : dylibs" >> Makefile
echo "dylibs:" >> Makefile
if test $dylib -ne 0
then
   echo "	cd lib ; \$(MAKE) shared_all" >> Makefile
fi
#
# OS X/Darwin 10.5 or later needs special clean commands to get rid of *.dSYM
# directories that gcc creates whenever -g is thrown
# If we are doing dynamic/shared libs, we also need to look for Apple's libtool
# in preference to the gnu version
#
LIBTOOL=libtool
flag=`echo "$OSGUESS" | sed -e "s/Darwin//"`
if test "$flag" != "$OSGUESS"
then
   echo "CLEANdep = OSXClean" >> Makefile
   if test $dylib -eq 1
   then
      OUTTMP=`$LIBTOOL -V`
      flag=`echo "$OUTTMP" | sed -e "s/Apple//"`
      if test "$flag" != "$OUTTMP"
      then
         OUTTMP=`/usr/bin/libtool -V`
         flag=`echo "$OUTTMP" | sed -e "s/Apple//"`
         if test "$flag" != "$OUTTMP"
         then
            LIBTOOL=/usr/bin/libtool
         else
            echo "Cannot find Apple libtool for making shared libraries!"
            exit 10 
         fi
      fi
   fi
else
   echo "CLEANdep = " >> Makefile
fi
cat "$path"/CONFIG/src/Makefile >> Makefile
flag=`echo "$OSGUESS" | sed -e "s/Darwin//"`
if test "$flag" != "$OSGUESS"
then
   echo "OSXClean:" >> Makefile
   echo "	rm -rf *.dSYM" >> Makefile
fi
cp "$path"/CONFIG/src/atlcomp.txt .
#
# Build and run xconfig
#
make -f Makefile xconfig
@skip ./xconfig -d s "$topdir" -d b "$blddir" `echo "$pass"`
echo ./xconfig -d s "$topdir" -d b "$blddir" "$pass"
#./xconfig -d s "$topdir" -d b "$blddir" `echo "$pass"`
if test $fulllapack -eq 0
then
   echo ./xconfig -d s "$topdir" -d b "$blddir" "$pass" | /bin/sh
else
   echo ./xconfig -d s "$topdir" -d b "$blddir" "$pass" \
        -D c -DATL_FULL_LAPACK | /bin/sh
fi
ierr=$?
if test $ierr -ne 0
then
   echo xconfig exited with $ierr
   exit $ierr
fi
#
# Build subdirectory structure and copy all makefiles
#
make -f Makefile make_subdirs
cp -f "$path"/Make.top .
cp -f "$path"/CONFIG/src/ATLrun.sh bin/.
make -f Makefile startup
if test $flapacktar != "ATL_NoOverride"
then
    chk=`echo "$flapacktar" | sed -e "s/^\.\.\///"`
    if test "$chk" = "$flapacktar"
    then
       flatar="$flapacktar"
    else
       flatar="$blddir"/"$flapacktar"
    fi
    if [ -f "$flatar" ]
    then
#
#      Unpack the LAPACK tarfile into $blddir/src/lapack/reftmp
#
       mkdir $blddir/src/lapack/reftmp
       cd  $blddir/src/lapack/reftmp
       flag=`echo "$flatar" | sed -e "s/\.bz2//"`
       if (test "$flag" != "$flatar")
       then
          bunzip2 -c $blddir/$flatar | tar xf -
       else
          flag=`echo "$flatar" | sed -e "s/\.gz//"`
          if (test "$flag" != "$flatar")
          then
             gunzip -c $flatar | tar xf -
          else
             flag=`echo "$flatar" | sed -e "s/\.tgz//"`
             if (test "$flag" != "$flatar")
             then
                gunzip -c $flatar | tar xf -
             else
                tar xf $flatar
             fi
          fi
       fi
#
#      LAPACK directory name changes with version, so we untar it to a temp
#      directory, and then move it to a  fixed name (reference).  We don't
#      use tar's ability to ignore the first directory, because this doesn't
#      port to all OSes tars (would require gnu-tar specifically)
#      Should only be one file!
#
       for file in *
       do
          if [ -d "$file" ]
          then
             mv $file ../reference
          fi
       done
       cd ..
       rm -rf reftmp
@beginskip
#
#      Go into subdir for needed files, should only be one file created by tar
#      Done in this brain-dead way 'cause we can't count on gnu tar
#
       for file in *
       do
          if [ -d "$file" ]
          then
             cd $file 
             if [ -d "SRC" ]
             then
                mv SRC ../src
             else
                echo "No SRC directory in $blddir/src/lapack/reference/$file!!"
                exit -2
             fi
             if [ -d "INSTALL" ]
             then
                mkdir ../INSTALL
                mv INSTALL/?lamch.f ../INSTALL/.
             else
             echo "No INSTALL directory in $blddir/src/lapack/reference/$file!!"
                exit -3
             fi
             if [ -e "COPYING" ]
             then
                mv COPYING ../.
             fi
             if [ -e "README" ]
             then
                mv README ../.
             fi
             cd ..
             rm -rf $file
          fi
       done
@endskip
    else
       echo "Cannot find '$flatar'"
       exit -1
    fi
fi
cd $blddir
if test $flapack != "ATL_NoOverride"
then
   cp -f $flapack lib/liblapack.a
   ar d lib/liblapack.a lsame.o xerbla.o csrot.o zdrot.o
fi
#
# Provide INSTALL directories to lib/Makefile
#
mv lib/Makefile lib/Make.tmp
echo LIBTOOL="$LIBTOOL" > lib/Makefile
echo DESTDIR="$prefix" >> lib/Makefile
echo INCINSTdir="$incinstdir" >> lib/Makefile
echo LIBINSTdir="$libinstdir" >> lib/Makefile
#
# Create initial version of MaxMalloc based on 32/64 bit address space
#
echo "#ifndef ATL_MaxMalloc" > include/atlas_maxmalloc.h
if test $bitwidth -eq 32
then
   echo "   #define ATL_MaxMalloc 268435456UL" >> include/atlas_maxmalloc.h
else
   echo "   #define ATL_MaxMalloc 1073741824UL" >> include/atlas_maxmalloc.h
fi 
echo "#endif" >> include/atlas_maxmalloc.h
#
# Create standard target for making dynamic/shared according to flags
#
if test $dylib -eq 1
then
#
#  OS X uses the dylib/libtool targets
#
   flag=`echo "$OSGUESS" | sed -e "s/Darwin//"`
   if test "$flag" != "$OSGUESS"
   then
      if test $f77 -eq 0
      then
         echo "shared_all :" >> lib/Makefile
         echo "	\$(MAKE) cdylib" >> lib/Makefile
         echo "	- \$(MAKE) ptcdylib" >> lib/Makefile
      else
         echo "shared_all :" >> lib/Makefile
         echo "	\$(MAKE) dylib" >> lib/Makefile
         echo "	- \$(MAKE) ptdylib" >> lib/Makefile
      fi
   else
#
#     Cygwin uses dll targets
#
      flag=`echo "$OSGUESS" | sed -e "s/CYGWIN//"`
      if test "$flag" != "$OSGUESS"
      then
         if test $f77 -eq 0
         then
            echo "shared_all :" >> lib/Makefile
            echo "	\$(MAKE) cdlls" >> lib/Makefile
            echo "	- \$(MAKE) ptcdlls" >> lib/Makefile
         else
            echo "shared_all :" >> lib/Makefile
            echo "	\$(MAKE) dlls" >> lib/Makefile
            echo "	- \$(MAKE) ptdlls" >> lib/Makefile
         fi
#
#     For everybody else, we use the .so/shared targets (only tested on Linux)
#
      else
         if test $f77 -eq 0
         then
            echo "shared_all :" >> lib/Makefile
            echo "	\$(MAKE) cshared" >> lib/Makefile
            echo "	- \$(MAKE) cptshared" >> lib/Makefile
         else
            echo "shared_all :" >> lib/Makefile
            echo "	\$(MAKE) shared" >> lib/Makefile
            echo "	- \$(MAKE) ptshared" >> lib/Makefile
         fi
     fi
   fi
fi
cat lib/Make.tmp >> lib/Makefile
rm -f lib/Make.tmp
if test $usefko -eq 1
then
   if [ ! -e "$topdir/iFKO" ]
   then
      cd $topdir
      bunzip2 -c CONFIG/ARCHS/ifko.tar.bz2 | tar xfm -
      cd $blddir
   fi
   $topdir/iFKO/fko_atlconf
   cd $blddir/iFKO
   make fkoc
   cd $blddir
fi
#
# Determine if affinity will be used; by default yes
#
echo "#define ATL_TAFFINITY $aff" > $blddir/tune/threads/res/aff.h
echo "DONE configure"
#
@ROUT SpewMakeInc
#include "atlconf.h"

@extract -b @(basd)/atlconf.base rout=GetFlags -punymac -def allflags ""
@extract -b @(basd)/atlconf.base rout=getptrbits -punymac

char *GetArch(enum MACHTYPE mach, int ISAX, int SIflag, int ptrbits)
{
   char *ap;
   int i, k;

   i = strlen(machnam[mach]);
   #if defined(__powerpc64__) && defined(__ORDER_LITTLE_ENDIAN__)
      i += 2; /* LE */
   #endif
   i += 2;   /* 64/32 */
   if (ISAX)
      i += strlen(ISAXNAM[ISAX]);
   if (!SI_IS_TRUE(SIflag,SI_IEEE))
      i += 7;  /* NONIEEE */
   ap = malloc(i+1);
   assert(ap);
   k = sprintf(ap, "%s", machnam[mach]);
   #if defined(__powerpc64__) && defined(__ORDER_LITTLE_ENDIAN__)
      k += sprintf(ap+k, "%dLE", ptrbits);
   #else
      k += sprintf(ap+k, "%d", ptrbits);
   #endif
   if (ISAX)
      k += sprintf(ap+k, "%s", ISAXNAM[ISAX]);
   if (!SI_IS_TRUE(SIflag,SI_IEEE))
      sprintf(ap+k, "NONIEEE");
   assert (k <= i);
   return(ap);
}
/*
 * RETURNS: string with path to archdef to use.  If np was exact match,
 *   *BAD is zeroed, else set non-zero.
 */
char *GetArchDef(char *srcd, char *mach, int np, int *BAD)
{
   char *ap=NULL;
   int k, i, l;
   *BAD = 0;
   k = l = strlen(srcd);
   l += 1 + strlen(mach);
   l += 4 + 8;        /* 4 digits np, 8 for .tar.bz2 */
   ap = malloc(l+1);
   assert(ap);
   assert(np < 10000);
   if (srcd[k-1] == '/')
      i = sprintf(ap, "%s%sp%d.tar.bz2", srcd, mach, np);
   else
      i = sprintf(ap, "%s/%sp%d.tar.bz2", srcd, mach, np);
   assert(i < l);
   if (!FileIsThere(ap))
   {
      int d;
      for (d=1; d < 64; d++)
      {
         int p;
         *BAD = 1;
         p = np + d;
         if (p < 10000)
         {
            i = sprintf(ap, "%s/%sp%d.tar.bz2", srcd, mach, p);
            assert(i < l);
            if (FileIsThere(ap))
               return(ap);
         }
         p = np - d;
         if (p > 0)
         {
            i = sprintf(ap, "%s/%sp%d.tar.bz2", srcd, mach, p);
            assert(i < l);
            if (FileIsThere(ap))
               return(ap);
         }
      }
      free(ap);
      ap = NULL;
   }
   return(ap);
}
int main(int nargs, char **args)
{
   enum OSTYPE OS;
   enum MACHTYPE mach;
   int h, i, j, k, verb, asmb, nof77, mhz;
   int vecexts, ISAX;
   int ptrbits, l2size;
   int delay=0;  /* change this to come from "special" ints in GetFlags */
   int THREADS=0;
   int nreg=0;
   int Use3DNow=0;  /* this needs to come from getflags */
   int ncpu, omp=0, AntThr=0, lapackref;
   int SIflag, USEDEFL1, USEMINGW, FKO, NOMATCH;
   int *tids;
   #define NPREC 4
   char pres[NPREC] = {'s', 'd', 'c', 'z'};
   char *targ, *sp, *pmake, *flapack, *ADd;
   char *comps[3*NCOMP], *comp, *flags, *srcdir, *blddir, *f2cdefs, *cdefs;
   char *outfile, *smaflags, *dmaflags, *f77lib, *gccflags, *goodgcc;
   char *arch, *archdef;
   char targarg[256], ln[1024];
   FILE *fpout;
   char *adnames[NARDEF] = {"sKERNDEF", "dKERNDEF", "sMMDEF", "dMMDEF"};

   GetFlags(nargs, args, &verb, &OS, (enum ASMDIA*) &asmb, &vecexts, &mach, 
            &mhz, &ptrbits, &nreg, &ncpu, &tids, comps, &gccflags, 
            &outfile, &srcdir, &blddir, &SIflag, &f2cdefs, &cdefs, &pmake, 
            &flapack, &smaflags, &dmaflags, &f77lib, &ADd, &l2size, &targ);
   USEDEFL1 = SI_IS_TRUE(SIflag,SI_BOZOL1);
   nof77 = SI_IS_TRUE(SIflag,SI_NOF77);
   lapackref = SI_IS_TRUE(SIflag,SI_LAREF);
   FKO = SI_IS_TRUE(SIflag,SI_FKO);
   if (ncpu > 1) THREADS = 1;
   if (!outfile)
      fpout = stdout;
   else
      fpout = fopen(outfile, "w");
   assert(fpout);
   assert(srcdir && blddir);
/*
 * If archdef directory not given, default to srcdir/CONFIG/ARCHS[/WIN64]
 */
   if (!ADd)
   {
      int l;
      l = strlen(srcdir);
      if (srcdir[l-1] == '/')
         l--;
      ADd = malloc(l+21);
      assert(ADd);
      strncpy(ADd, srcdir, l);
      strcpy(ADd+l, "/CONFIG/ARCHS");
      if (OS == OSWin64 && ptrbits == 64)
         strcat(ADd, "/WIN64");
   }
/*
 * Update l2size, and set f2cdefs/cdefs if they are null 
 */
   if (!l2size) 
   {
      if (mach == IntPhi)
         l2size = 1024*1024;
      else if (ptrbits == 64)
         l2size = 32*1024*1024;
      else
         l2size = 4*1024*1024;
   }
   else 
      l2size *= 1024;
   if (!f2cdefs) f2cdefs = "";
/*
 * Append any appended flags, and then we have just compilers and flags
 */
   for (i=2*NCOMP; i < 3*NCOMP; i++)
   {
      if (comps[i])
      {
         comps[i-NCOMP] = NewAppendedString(comps[i-NCOMP], comps[i]);
         free(comps[i]);
         comps[i] = NULL;
      }
   }
/*
 * If any C compiler is unspecified, use it to specify the others
 * Use DKC preferentially if it is specified
 */
   if (comps[DKC_] && comps[NCOMP+DKC_])
      k = DKC_;
   else
   {
      k = -1;
      for (i=0; i < F77_; i++)
      {
         if (comps[i] && comps[NCOMP+i])
         {
            k = i;
            break;
         }
      }
      if (k < 0)
      {
         fprintf(stderr, "Need a valid C compiler and flags\n");
         exit(100);
      }
   }
   for (i=0; i < F77_; i++)
   {
      if (!comps[i])
         comps[i] = comps[k];
      if (!comps[NCOMP+i])
         comps[NCOMP+i] = comps[NCOMP+k];
   }
   USEMINGW = (OSIsWin(OS) && strstr(comps[GCC_], "mgwgcc"));
/*
 * If F77 compiler unspecified or nof77 asserted, set it to ICC for linking
 */
   if (!comps[F77_] || nof77)
   {
      comps[F77_] = comps[ICC_];
      comps[NCOMP+F77_] = comps[NCOMP+ICC_];
   }
/*
 * Find dominant ISA extension
 */
   ISAX = 0;
   for (i=1; i < NISA && !ISAX; i++)
      if (vecexts & (1<<i))
         ISAX = i;

   fprintf(fpout, "#  ----------------------------\n");
   fprintf(fpout, "#  Make.inc for ATLAS@(ver)\n");
   fprintf(fpout, "#  ----------------------------\n\n");

   fprintf(fpout, "#  ----------------------------------\n");
   fprintf(fpout, "#  Make sure we get the correct shell\n");
   fprintf(fpout, "#  ----------------------------------\n");
   fprintf(fpout, "   SHELL = /bin/sh\n\n");

   fprintf(fpout, "#  -------------------------------------------------\n");
   fprintf(fpout, "#  Name indicating the platform to configure BLAS to\n");
   fprintf(fpout, "#  -------------------------------------------------\n");
   arch = GetArch(mach, ISAX, SIflag, ptrbits);
   archdef = GetArchDef(ADd, arch, ncpu, &NOMATCH);
   fprintf(fpout, "   ARCH = %s\n\n", arch);
@beginskip
   fprintf(fpout, "   ARCH = %s", machnam[mach]);
   fprintf(fpout, "%d", ptrbits);
   #if defined(__powerpc64__) && defined(__ORDER_LITTLE_ENDIAN__)
      fprintf(fpout, "LE");
   #endif
   if (ISAX)
      fprintf(fpout, "%s", ISAXNAM[ISAX]);
   if (!SI_IS_TRUE(SIflag,SI_IEEE))
      fprintf(fpout, "NONIEEE");
   fprintf(fpout, "\n\n");
@endskip

   fprintf(fpout, "#  ----------------------------\n");
   fprintf(fpout, "#  Paths to various directories\n");
   fprintf(fpout, "#  ----------------------------\n");
   fprintf(fpout, "   BLDdir = %s\n", blddir);
   fprintf(fpout, "   SRCdir = %s\n", srcdir);
   fprintf(fpout, "   INCAdir = $(BLDdir)/include\n");
   fprintf(fpout, "   INCSdir = $(SRCdir)/include\n");
   fprintf(fpout, "   BINdir = $(BLDdir)/bin\n");
   fprintf(fpout, "   LIBdir = $(BLDdir)/lib\n\n");
   fprintf(fpout, "   SYSdir = $(BLDdir)/tune/sysinfo\n");
   fprintf(fpout, "   GMMdir = $(BLDdir)/src/blas/gemm\n");
   fprintf(fpout, "   AMMdir = $(BLDdir)/src/blas/ammm\n");
   fprintf(fpout, "   GMVdir = $(BLDdir)/src/blas/gemv\n");
   fprintf(fpout, "   GR1dir = $(BLDdir)/src/blas/ger\n");
   fprintf(fpout, "   L1Bdir = $(BLDdir)/src/blas/level1\n");
   fprintf(fpout, "   L2Bdir = $(BLDdir)/src/blas/level2\n");
   fprintf(fpout, "   L3Bdir = $(BLDdir)/src/blas/level3\n");
   fprintf(fpout, "   TSTdir = $(BLDdir)/src/testing\n");
   fprintf(fpout, "   AUXdir = $(BLDdir)/src/auxil\n");
   fprintf(fpout, "   CBLdir = $(BLDdir)/interfaces/blas/C/src\n");
   fprintf(fpout, "   FBLdir = $(BLDdir)/interfaces/blas/F77/src\n");
   fprintf(fpout, "   MMTdir = $(BLDdir)/tune/blas/gemm\n");
   fprintf(fpout, "   MVTdir = $(BLDdir)/tune/blas/gemv\n");
   fprintf(fpout, "   R1Tdir = $(BLDdir)/tune/blas/ger\n");
   fprintf(fpout, "   L1Tdir = $(BLDdir)/tune/blas/level1\n");
   fprintf(fpout, "   L3Tdir = $(BLDdir)/tune/blas/level3\n");
   fprintf(fpout, "   FLAdir = $(BLDdir)/src/lapack/reference\n");
@skip   if (ADd)
   fprintf(fpout, "   ADdir  = %s\n", ADd);
@skip   else
@skip      fprintf(fpout, "   ADdir  = $(SRCdir)/CONFIG/ARCHS\n");
   free(ADd);
   if (FKO)
   {
      fprintf(fpout, "   FKOSRCdir = $(SRCdir)/iFKO\n");
      fprintf(fpout, "   FKOBLDdir = $(BLDdir)/iFKO\n");
   }
   fprintf(fpout, "\n");

   fprintf(fpout,
"#  ---------------------------------------------------------------------\n");
   fprintf(fpout,
"#  Name and location of scripts for running executables during tuning\n");
   fprintf(fpout,
"#  ---------------------------------------------------------------------\n");
   fprintf(fpout, "   ATLRUN = $(BLDdir)/ATLrun.sh\n");
   fprintf(fpout, "   ATLFWAIT = $(BLDdir)/bin/xatlas_waitfile\n\n");

   fprintf(fpout, "#  ---------------------\n");
   fprintf(fpout, "#  Libraries to be built\n");
   fprintf(fpout, "#  ---------------------\n");
   fprintf(fpout, "   ATLASlib = $(LIBdir)/libatlas.a\n");
   fprintf(fpout, "   CBLASlib = $(LIBdir)/libcblas.a\n");
   fprintf(fpout, "   F77BLASlib = $(LIBdir)/libf77blas.a\n");
   fprintf(fpout, "   LAPACKlib = $(LIBdir)/liblapack.a\n");
   fprintf(fpout, "   UAMMlib = $(LIBdir)/libuamm.a\n");
@skip   fprintf(fpout, "   CLAPACKlib = $(LIBdir)/libclapack.a\n");
@skip   fprintf(fpout, "   F77LAPACKlib = $(LIBdir)/libf77lapack.a\n");
@skip   fprintf(fpout, "   CLALIBS = $(CLAPACKlib) $(LAPACKlib)\n");
@skip   fprintf(fpout, "   FLALIBS = $(F77LAPACKlib) $(LAPACKlib)\n");
@skip   fprintf(fpout, "   FCLALIBS = $(F77LAPACKlib) $(CLAPACKlib)\n");
   if (THREADS)
   {
      fprintf(fpout, "   PTCBLASlib = $(LIBdir)/libptcblas.a\n");
      fprintf(fpout, "   PTF77BLASlib = $(LIBdir)/libptf77blas.a\n");
      fprintf(fpout, "   PTLAPACKlib = $(LIBdir)/libptlapack.a\n");
@skip      fprintf(fpout, "   PTCLAPACKlib = $(LIBdir)/libptclapack.a\n");
@skip      fprintf(fpout, "   PTF77LAPACKlib = $(LIBdir)/libptf77lapack.a\n");
@skip      fprintf(fpout, "   PTCLALIBS = $(PTCLAPACKlib) $(LAPACKlib)\n");
@skip      fprintf(fpout, "   PTFLALIBS = $(PTF77LAPACKlib) $(LAPACKlib)\n");
@skip      fprintf(fpout, 
@skip         "   PTFCLALIBS = $(PTF77LAPACKlib) $(PTCLAPACKlib)\n");
   }
   fprintf(fpout, "   TESTlib = $(LIBdir)/libtstatlas.a\n\n");

   fprintf(fpout, "#  -------------------------------------------\n");
   fprintf(fpout, "#  Upper bound on largest cache size, in bytes\n");
   fprintf(fpout, "#  -------------------------------------------\n");
   fprintf(fpout, "   L2SIZE = -DL2SIZE=%d\n\n", l2size);

   fprintf(fpout, "#  ---------------------------------------\n");
   fprintf(fpout, "#  Command setting up correct include path\n");
   fprintf(fpout, "#  ---------------------------------------\n");
   fprintf(fpout, 
           "   INCLUDES = -I$(INCAdir) -I$(INCSdir) -I$(INCSdir)/contrib\n\n");

   fprintf(fpout, "#  -------------------------------------------\n");
   fprintf(fpout, "#  Defines for setting up F77/C interoperation\n");
   fprintf(fpout, "#  -------------------------------------------\n");
   fprintf(fpout, "   F2CDEFS = %s\n\n", f2cdefs);

   fprintf(fpout, "#  ------------------------------\n");
   fprintf(fpout, "#  Architecture identifying flags\n");
   fprintf(fpout, "#  ------------------------------\n");
   fprintf(fpout, "   ARCHDEFS =");
   if (ptrbits == 32)
      fprintf(fpout, " -DATL_PTR32");
   else
      fprintf(fpout, " -DATL_PTR64");
   if (OS != OSOther) 
      fprintf(fpout, " -DATL_OS_%s", osnam[OS]);
   if (mach != MACHOther) 
      fprintf(fpout, " -DATL_ARCH_%s", machnam[mach]);
   if (mhz) 
      fprintf(fpout, " -DATL_CPUMHZ=%d", mhz);
   if (OS == OSSunOS) 
      fprintf(fpout, " -DSUN_HR");
   if (OSIsWin(OS))
      fprintf(fpout, " -DGCCWIN -DUseClock");
   for (i=1; i < NISA; i++)
      if (vecexts & (1<<i))
         fprintf(fpout, " -DATL_%s", ISAXNAM[i]);
   if (Use3DNow) fprintf(fpout, " -DATL_3DNowFLOPS");
@skip   if (vecexts & (1<<ISA_3DNow))
@skip      fprintf(fpout, " -DATL_Has3DNow");
   if (ptrbits == 64)
      fprintf(fpout, " -DATL_USE64BITS");
   if (mach == IA64Itan || mach == IA64Itan2 )
      fprintf(fpout, " -DATL_MAXNREG=128");
   if (asmb != ASM_None) fprintf(fpout, " -DATL_%s", ASMNAM[asmb]);
   if (mach == IA64Itan2)
      fprintf(fpout, " -DATL_IntelIccBugs");
/* 
 * Need up update handling of apple vs. gnu gcc for altivec
 */
   if ((ISAX == ISA_AV || ISAX == ISA_VSX) && CompIsGcc(comps[DMC_]) && 
        !CompIsAppleGcc(comps[DMC_]))
      fprintf(fpout, " -DATL_AVgcc");
   fprintf(fpout, "\n\n");
   if (tids)
   {
      int k;
      fprintf(fpout, "   TIDLIST= -tl %d", ncpu);
      for (k=0; k < ncpu; k++)
         fprintf(fpout, " %d", tids[k]);
   }
   else
      fprintf(fpout, "   TIDLIST=");
   fprintf(fpout, "\n\n");

   fprintf(fpout,
   "#  -------------------------------------------------------------------\n");
   fprintf(fpout,
   "#  NM is the flag required to name a compiled object/executable\n");
   fprintf(fpout,
   "#  OJ is the flag required to compile to object rather than executable\n");
   fprintf(fpout, "#  These flags are used by all compilers.\n");
   fprintf(fpout,
   "#  -------------------------------------------------------------------\n");
   fprintf(fpout, "   NM = -o\n");
   fprintf(fpout, "   OJ = -c\n\n");

   sprintf(ln, "%s/CONFIG/src/CompMake.txt", srcdir);
   DisplayFile(ln, fpout, 0);
/*
 * For PHI, have plenty of cores, so don't press luck by using core that
 * may be busy communicating with host
 */
   if (mach == IntPhi && ncpu > 4)
      fprintf(fpout, "   NPROC=%d\n", ncpu-4);
   else
      fprintf(fpout, "   NPROC=%d\n", ncpu);
   fprintf(fpout, "   CDEFS = $(L2SIZE) $(INCLUDES) $(F2CDEFS) $(ARCHDEFS)");
   if (SI_IS_TRUE(SIflag,SI_FKO))
      fprintf(fpout, " -DATL_FKO=1");
   if (!SI_IS_TRUE(SIflag,SI_IEEE))
      fprintf(fpout, " -DATL_NONIEEE=1");
/*
 * Dump -m32/-m64 to CDEFS if it is in normal flags, so that generic flags
 * given in index files will still work.  If the user mixes gcc which mandates
 * these flags, with other compilers that can't take them, there will be
 * trouble.
 */
   if (strstr(comps[NCOMP+DKC_], " -m32"))
      fprintf(fpout, " -m32");
   else if (strstr(comps[NCOMP+DKC_], " -m64"))
      fprintf(fpout, " -m64");
   else if (strstr(comps[NCOMP+DKC_], " -mx32"))
      fprintf(fpout, " -mx32");
   if (cdefs) fprintf(fpout, " %s", cdefs);
   if (THREADS)
   {
      fprintf(fpout, " -DATL_NCPU=$(NPROC)");
@skip      if (OS == OSLinux || OS == OSIRIX || OS == OSOSF1 || OS == OSAIX ||
@skip          OS == SunOS) fprintf(fpout, " -DDUseSystemScope");
      if (OS == OSFreeBSD) fprintf(fpout, " -D_THREAD_SAFE -D_REENTRANT");
      if (OS == OSAIX) fprintf(fpout, " -DIBM_PT_ERROR");
      if (OS == OSIRIX) fprintf(fpout, " -D_POSIX_C_SOURCE=199506L");
      if (AntThr) fprintf(fpout, " -DATL_TRUST_ANTPT");
      else if (omp) fprintf(fpout, " -DATL_OMP_THREADS");
      if (AntThr > 1) fprintf(fpout, " -DATL_ANTOINE_THREADS");
   }
   if (delay) fprintf(fpout, " -DATL_FOPENDELAY");
   fprintf(fpout, "\n\n");
   for (i=0; i < NCOMP; i++)
   {
      fprintf(fpout, "   %s = %s\n", COMPNAME[i], comps[i]);
      if (i == F77_)
         fprintf(fpout, "   %sFLAGS = %s\n", COMPNAME[i], comps[NCOMP+i]);
      else if (i == ICC_ || i == XCC_)
         fprintf(fpout, "   %sFLAGS = $(CDEFS) %s\n", 
                 COMPNAME[i], comps[NCOMP+i]);
      else /* non-interf comps don't include CDEFS by default (added later) */
         fprintf(fpout, "   %sFLAGS = %s\n", 
                 COMPNAME[i], comps[NCOMP+i]);
   }
   fprintf(fpout, "   F77NOOPT = $(F77FLAGS) -O0   # turn off optimization\n");
   fprintf(fpout, "   SMAFLAGS =");
   if (smaflags) 
      fprintf(fpout, " %s", smaflags);
   fprintf(fpout, "\n   DMAFLAGS =");
   if (dmaflags) 
      fprintf(fpout, " %s", dmaflags);
   fprintf(fpout, "\n");
   fprintf(fpout, "   CKC = $(SKC)\n");
   fprintf(fpout, "   ZKC = $(DKC)\n");
   fprintf(fpout, "   sKCFLAGS = $(CDEFS) $(SKCFLAGS)\n");
   fprintf(fpout, "   dKCFLAGS = $(CDEFS) $(DKCFLAGS)\n");
   fprintf(fpout, "   cKCFLAGS = $(CDEFS) $(SKCFLAGS)\n");
   fprintf(fpout, "   zKCFLAGS = $(CDEFS) $(DKCFLAGS)\n");

   for (i=0; i < NCOMP; i++)
   {
      if (i == XCC_) continue;  /* do not accept cross-compiler */
      j = strlen(comps[i]);
      if (j >= 3 && comps[i][j-3] == 'g' && 
          comps[i][j-2] == 'c' && comps[i][j-1] == 'c')
         break;
   }
   if (i < NCOMP)
      goodgcc = comps[i];
   else
      goodgcc = comps[GCC_] ? comps[GCC_] : "gcc";
   if (mach == IntPhi)
      fprintf(fpout, "   GOODGCC = icc");
   else
      fprintf(fpout, "   GOODGCC = %s", goodgcc);
   if (gccflags)
      fprintf(fpout, " %s", gccflags);
   GetGccVers(goodgcc, &i, &j, &k, &k);
@skip   if (OS == OSOSX && j > 3)  /* need bullshit apple annoyance flag */
@skip      fprintf(fpout, " -force_cpusubtype_ALL");
   if (OSIsWin(OS) && ptrbits != 64)  /* stop gcc breaking ABI */
      fprintf(fpout, " -mstackrealign");
   sp = GetPtrbitsFlag(OS, mach, ptrbits, goodgcc);
   if (strlen(sp) > 0)
       fprintf(fpout, " %s", sp);
   #ifdef ATL_DYLIBS
      if (!OSIsWin(OS))
         fprintf(fpout, " -fPIC");
   #endif
   fprintf(fpout, "\n");
   if (FKO)
   {
      fprintf(fpout, "   FKO = $(FKOBLDdir)/fko\n");
      fprintf(fpout, "   FKOC = $(FKOBLDdir)/fkoc\n");
   }
   fprintf(fpout, "   KC = $(DKC)\n   KCFLAGS = $(CDEFS) $(DKCFLAGS)\n");

   fprintf(fpout, "   LDFLAGS =");
   if (MachIsX86(mach))
   {
      if (OSIsWin(OS))
         fprintf(fpout, " -mi386pe");
      else
      {
         if (ptrbits == 32)
            fprintf(fpout, " -melf_i386");
         else if (ptrbits == 64)
            fprintf(fpout, " -melf_x86_64");
         else if (ptrbits == -32)
            fprintf(fpout, " -melf_x32_x86_64");
         if (OS == OSFreeBSD)
            fprintf(fpout, "_fbsd");
      }
   }
   if (MachIsS390(mach))
      fprintf(fpout, ptrbits == 32 ? "-m31" : "-m64");
   fprintf(fpout, "\n   F77SYSLIB = %s\n", f77lib ? f77lib : "");
   fprintf(fpout, "   BC = $(KC)\n");
   fprintf(fpout, "   NCFLAGS = $(KCFLAGS)\n");
   fprintf(fpout, "\n   CLINKER = $(KC)\n   CLINKFLAGS = $(KCFLAGS)\n");
   fprintf(fpout, "   FLINKER = $(F77)\n");
   if (strstr(comps[F77_], "mgwgfortran"))
      fprintf(fpout, "   FLINKFLAGS = $(F77FLAGS) -static\n");
   else
      fprintf(fpout, "   FLINKFLAGS = $(F77FLAGS)\n");
   fprintf(fpout, "   FCLINKFLAGS = $(FLINKFLAGS)");
   if (strstr(comps[F77_], "ifort") && !OSIsWin(OS))
      fprintf(fpout, " -nofor_main");
   if (USEMINGW)
      fprintf(fpout, "\n   ARCHIVER = $(BLDdir)/mgwar\n");
   else if (mach == TI_C66_BM)
      fprintf(fpout, "\n   ARCHIVER = ar6x # For TI_C66_BM.\n");
   else
      fprintf(fpout, "\n   ARCHIVER = ar\n");
   fprintf(fpout, "   ARFLAGS  = r\n");
/*
 * JF Mertens says that even x86 OS X still need ranlib for safety
 */
   if (OS == OSOSX)
      fprintf(fpout, "   RANLIB   = ranlib\n\n");
   else if (USEMINGW)
      fprintf(fpout, "   RANLIB   = $(BLDdir)/mgwranlib\n\n");
   else
      fprintf(fpout, "   RANLIB   = echo\n\n");

   fprintf(fpout, "#  -------------------------------------\n");
   fprintf(fpout, "#  tar, gzip, gunzip, and parallel make\n");
   fprintf(fpout, "#  -------------------------------------\n");
   fprintf(fpout, "   TAR    = tar\n");
   fprintf(fpout, "   BZIP   = bzip2\n");
   fprintf(fpout, "   BUNZIP = bunzip2\n");
   if (mach == IntPhi)
      fprintf(fpout, "   PMAKE  = $(MAKE) -j 4\n\n");
   else
      fprintf(fpout, "   PMAKE  = %s\n\n", pmake ? pmake : "$(MAKE)");
/*
 * Need to add libs to GetFlags and update GetSysLib to do this right
*/
   fprintf(fpout, "#  ------------------------------------\n");
   fprintf(fpout, "#  Reference and system libraries\n");
   fprintf(fpout, "#  ------------------------------------\n");
   fprintf(fpout, "   FBLASlib = $(LIBdir)/libf77refblas.a\n");
   fprintf(fpout, "   FLAPACKlib = ");
   if (flapack) fprintf(fpout, "%s", flapack);
   else if (lapackref) fprintf(fpout, "$(FLAdir)/lapack_$(ARCH).a");
   fprintf(fpout, "\n");
   fprintf(fpout, "   SBLASlib = $(FBLASlib)  # should be serial sysblas\n");
   fprintf(fpout, "   BLASlib = $(FBLASlib)   # should be parallel sysblas\n");
   fprintf(fpout, "   SLAPACKlib =   # set to parallel system lapack\n");
   fprintf(fpout, "   SSLAPACKlib =  # set to serial system lapack\n");
   if (THREADS)
   {
      if (USEMINGW || (ptrbits == 32 && OSIsWin(OS)))
         fprintf(fpout, "   LIBS = -lkernel32 -lm\n\n");
      else if (OSIsWin(OS))
         fprintf(fpout, "   LIBS = -lm\n\n");
      else
         fprintf(fpout, "   LIBS = -lpthread -lm\n\n");
   }
   else
      fprintf(fpout, "   LIBS = -lm\n\n");
@skip   if (!OSIsWin(OS))

   fprintf(fpout, 
   "#  ----------------------------------------------------------\n");
   fprintf(fpout, 
   "#  Info for architectural defaults and flags to atlas_install\n");
   fprintf(fpout, 
   "#  ----------------------------------------------------------\n");
   for (i=0; i < NCOMP; i++)
   {
      sp = NewStringCopy(COMPNAME[i]);
      for (j=0; sp[j]; j++)
        sp[j] = tolower(sp[j]);
      fprintf(fpout, "   %sD = ", sp);
      free(sp);
/*
 *    Regardless of actual names, use standard gnu compiler names for defs
 */
      if (CompIsGcc(comps[i]))
      {
         if (i == F77_)
         {
            GetGccVers(comps[i], &k, &j, &k, &k);
            if (j < 4) 
               sp = NewStringCopy("g77");
            else
               sp = NewStringCopy("gfortran");
         }
         else sp = NewStringCopy("gcc");
      }
      else if (CompIsClang(comps[i]))
         sp = NewStringCopy((i==F77_) ? "gfortran" : "clang");
      else
      {
         sp = NameWithoutPath(comps[i]);
         if (!strncmp(sp, "ATLwin_", 7))
            sp = NewStringCopy(comps[i]+7);
      }
@skip      if (!strcmp(sp, "gcc32")) sp[3] = '\0'; /* count gcc32 as gcc */
      fprintf(fpout, "%s\n", sp);
      free(sp);
   }
   fprintf(fpout, "   ADnew = %sp%d\n", arch, ncpu);
   free(arch);
   if (archdef)
   {
      fprintf(fpout, "   ADtar = %s\n", archdef);
      i = strlen(archdef) - 8;
      archdef[i] = '\0';
      for (i--; i > 0 && archdef[i] != '/'; i--);
      if (i)
         i++;
      fprintf(fpout, "   ADuse = $(BLDdir)/ARCHS/%s\n", archdef+i);
   }
   else
   {
      fprintf(fpout, "   ADtar = \n");
      fprintf(fpout, "   ADuse = \n");
   }
   if (!SI_IS_TRUE(SIflag,SI_ARCHDEF) || !archdef)
   {
      if (USEDEFL1)
         fprintf(fpout, "   ADtarg = do_bozoL1\n");
      else
         fprintf(fpout, "   ADtarg = do_nothing\n");
   }
   else if (NOMATCH && !SI_IS_TRUE(SIflag,SI_ADCLOSEP))
      fprintf(fpout, "   ADtarg = do_basic\n");
   else
      fprintf(fpout, "   ADtarg = do_full\n");
   if (!nreg)
      fprintf(fpout, "   INSTFLAGS = -1 %d -a %d -l %d\n\n", 
              USEDEFL1, SI_IS_TRUE(SIflag,SI_ARCHDEF), 
              SI_IS_TRUE(SIflag,SI_LATUNE));
   else
      fprintf(fpout, "   INSTFLAGS = -1 %d -a %d -l %d -r %d\n\n", 
              USEDEFL1, SI_IS_TRUE(SIflag,SI_ARCHDEF), 
              SI_IS_TRUE(SIflag,SI_LATUNE), nreg);
@beginskip
   fprintf(fpout,
      "#  --------------------------------------------------------\n");
   fprintf(fpout,
      "#  ATLAS install flags (controlling architectural defaults)
   fprintf(fpout,
      "#  --------------------------------------------------------\n");
   fprintf(fpout, "   INSTFLAGS = -1 %d -a %d\n\n", USEDEFL1, 
           SI_IS_TRUE(SIflag,SI_ARCHDEF));
@endskip

fprintf(fpout,
   "#  -------------------------------------------------------------------\n");
fprintf(fpout,
   "#  Dependence info for building optional external threading interfaces\n");
fprintf(fpout,
   "#  -------------------------------------------------------------------\n");
   for (i=0; i < NPREC; i++)
   {
      fprintf(fpout, "   %cextthr =", pres[i]);
@skip      if (omp)
@skip         fprintf(fpout, " %comp", pres[i]);
      if (AntThr)
         fprintf(fpout, " %cpt", pres[i]);
      fprintf(fpout, "\n");
   }
@beginskip
   fprintf(fpout, 
  "#\n# Hack to get around gcc ABI violation when using winthreads\n#\n");
   if (OS == OSWin64 && ptrbits == 32)
      fprintf(fpout, "   tstackfix = ATL_gccstackfix.o\n");
   else
      fprintf(fpout, "   tstackfix = "\n");
@endskip
   fprintf(fpout, "#  ---------------------------------------\n");
   fprintf(fpout, "#  Generic targets needed by all makefiles\n");
   fprintf(fpout, "#  ---------------------------------------\n");
   fprintf(fpout, "do_it: all\n");
   if (delay)
   {
      fprintf(fpout, "   waitfile = wfdefault\n");
      fprintf(fpout, "waitfile:\n\tcd $(BINdir) ; $(MAKE) xatlas_waitfile\n");
      fprintf(fpout, "\t$(ATLFWAIT) -s %d -f $(waitfile)\n", delay);
   }
   else fprintf(fpout, "waitfile:\n");
   if (fpout != stdout && fpout != stderr) fclose(fpout);
   return(0);
}
@ROUT atlbench
#include "atlconf.h"

/*
 * The number of results, and their ordering (this must match the file).
 */
#define NBENCH 6
#define KMV_N  0
#define KMV_T  1
#define KGER   2
#define KGER2  3
#define SELKMM 4
#define MM_BIG 5
#define CLKRATE 6

@skip #define KMM_NT 2
@skip #define KMM_TN 3

char *BNCHNAMES[NBENCH] = 
   {"kMV_N", "kMV_T", "kGER", "kGER2", "kgemm", "BIG_MM"};

void PrintUsage(char *name, int iarg, char *flag)
{
   if (iarg) 
      fprintf(stderr, "Error around argument %d (%s)!\n", iarg, flag);
   fprintf(stderr, "USAGE: %s [flags]\n", name);
   fprintf(stderr, "   -dp <prior benchmark directory>\n");
   fprintf(stderr, "   -dc <current benchmark directory>\n");
   fprintf(stderr, "   -f <filename w/o prefix>\n");
   fprintf(stderr, "   -o <outfile> : default=stdout\n");
   exit(iarg ? iarg : -1);
}

FILE *GetFlags(int nargs, char **args, char **fname, char **currd, char **oldd)
{
   char *sp;
   FILE *fpout;
   int i;

   *fname = "PerfSumm.txt";
   *currd = "bin/INSTALL_LOG";
   *oldd = NULL;
   fpout = stdout;

   for (i=1; i < nargs; i++)
   {
      if (args[i][0] != '-') PrintUsage(args[0], i, args[i]);
      switch(args[i][1])
      {
      case 'd':
         if (++i >= nargs)
            PrintUsage(args[0], i, "Out of args");
         sp = args[i];
         if (args[i-1][2] == 'p') *oldd = sp;
         else if (args[i-1][2] == 'c') *currd = sp;
         else PrintUsage(args[0], i-1, args[i-1]);
         break;
      case 'f':
         if (++i >= nargs)
            PrintUsage(args[0], i, "Out of args");
         *fname = args[i];
         break;
      case 'o':
         if (++i >= nargs)
            PrintUsage(args[0], i, "Out of args");
         fpout = fopen(args[i], "w");
         assert(fpout);
      default:
         PrintUsage(args[0], i, args[i]);
      }
   }
   if (*oldd == NULL)
      fprintf(stderr, 
      "No prior benchmark directory given, no comparison will be made.\n");
   return(fpout);
}

@beginskip
long GetInt(FILE *fpin, long Default, char *spc, char *expstr)
/*
 * Gets a signed integral type from fpin.  If nothing or garbage is entered,
 * Default is returned.
 */
{
   char str[64];
   long iin;
   if (expstr) fprintf(stdout, "%sEnter %s [%d]: ", spc, expstr, Default);
   if (fgets(str, 64, fpin) == NULL) return(Default);
   if (sscanf(str, " %ld ", &iin) != 1) return(Default);
   return(iin);
}
@endskip

double RunBigMM(char pre, double clkrate, int *N)
/*
 * Calls gemmtst to find asymptotic performance.
 * RETURNS: mflop of large matmul of precision pre.
 */
{
   char cmnd[2048], res[2048];
   int i, n=1600, offset;
   double mf0, mf1;
   FILE *fpin;

   offset = 67;
@skip   offset = (pre == 's' || pre == 'd') ? 67 : 61;
@skip   sprintf(cmnd, "cd bin ; make x%cmmtst_big", pre);
@skip   syschk(cmnd);
/*
 * Don't run case taking longer than 1 minute, assuming 1flop/cycle
 */
   mf0 = clkrate*1000000.0 * 60.0;
   while (((pre=='c' || pre=='z') ? 8.0 : 2.0)*n*n*n > mf0)
      n -= 200;
   n = (n >= 1200) ? n :1200;
/*
 * May fail for lack of memory, so keep reducing N until we have success
 */
   do
   {
      assert(n > 200);
      remove("big.out");
@skip      sprintf(cmnd, "./bin/x%cmmtst_big -n %d -Test 0 > big.out\n", pre, n);
      sprintf(cmnd, "cd bin ; make IRun_%cbigmm nb=%d", pre, n);
      n -= 200;
/*      fprintf(stderr, "cmnd='%s'", cmnd); */
   }
   while(system(cmnd));
   *N = n + 200;
/*
 * This section parses xdsl3time_ab output to get mflop; note it is fragile,
 * so if we change the formatting of xdsl3time, we must change this!
 */
   fpin = fopen("big.out", "r");
   assert(fpin);
/*
 * Skip headers/blank lines, get 1st line of output
 */
   for (i=0; i < 5; i++)
      assert(fgets(res, 2048, fpin));
   mf0 = atof(res+offset);
   fprintf(stderr, "res+off=%s\n", res+offset);
@skip   assert(fgets(res, 2048, fpin));
   mf1 = atof(res+offset);
   fclose(fpin);
   fprintf(stderr, "BIG_MM N=%d, mf=%.2f,%.2f!\n", *N, mf0, mf1);
   return((mf0 >= mf1) ? mf0 : mf1);
}

double **ReadBenchmarks(char *dir, char *basename)
/*
 * Allocates a benchmark array with 4 (one for each precision) vectors of
 * NBENCH+1 length.  The MM_BIG element may not be present, in which case it is
 * filled in as 0. The extra element is the clock rate.
 */
{
   char ln[2048];
   char pre[4] = {'s', 'c', 'd', 'z'};
   int i, j, RECOMPUTE=0, N;
   FILE *fpin;
   double *mf, **res;

   if (dir == NULL || basename == NULL)
      return(NULL);
/*
 * If no files exist, return NULL
 */
   for (fpin=NULL, i=0; i < 4 && !fpin; i++)
   {
      sprintf(ln, "%s/%c%s", dir, pre[i], basename);
      fpin = fopen(ln, "r");
   }
   if (!fpin)
      return(NULL);
   fclose(fpin);

   res = malloc(sizeof(double*)*4);
   assert(res);
   for (i=0; i < 4; i++)
   {
      res[i] = mf = malloc(sizeof(double)*(NBENCH+1));
      assert(mf);
      sprintf(ln, "%s/%c%s", dir, pre[i], basename);
      fpin = fopen(ln, "r");
      if (!fpin)
      {
         for (j=0; j <= NBENCH; j++)
            mf[j] = 0.0;
         continue;
      }
      assert(fgets(ln, 2048, fpin));
      assert(ln[10] == '=');
      mf[CLKRATE] = atof(ln+11);
      if (mf[CLKRATE] < 100) 
         RECOMPUTE = 8;
      else RECOMPUTE = 0;
      if (i)
         mf[CLKRATE] = res[i-1][CLKRATE];
      else
      {
         while (mf[CLKRATE] < 100.0)
            mf[CLKRATE] = GetInt(stdin, 0, "", "Clock rate in Mhz");
      }
/*
 *    Skip table headers
 */
      assert(fgets(ln, 2048, fpin));
      assert(fgets(ln, 2048, fpin));
/*
 *    Read mandatory NBENCH-1 elements of table
 */
      for (j=0; j < NBENCH-1; j++)
      {
         assert(fgets(ln, 2048, fpin));
         mf[j] = atof(ln+RECOMPUTE);
         if (RECOMPUTE)
            mf[j] = (mf[j]/mf[CLKRATE])*100.0;
      }
/*
 *    If large-case MM in file, read as normal
 */
      if (fgets(ln, 2048, fpin) != NULL)
      {
         mf[j] = atof(ln+RECOMPUTE);
         if (RECOMPUTE)
            mf[j] = (mf[j]/mf[CLKRATE])*100.0;
      }
/*
 *    If large-case MM not in file, must run it, and then add to file
 */
      else
      {
         fclose(fpin);
         mf[j] = RunBigMM(pre[i], mf[CLKRATE], &N);
         sprintf(ln, "%s/%c%s", dir, pre[i], basename);
         fpin = fopen(ln, "a");
         assert(fpin);
         fprintf(fpin, "%7.1f %10.1f  N=%d GEMM\n", 
                 (mf[j]/mf[CLKRATE])*100.0, mf[j], N);
         mf[j] = (mf[j]/mf[CLKRATE])*100.0;
      }
      fclose(fpin);
   }
   return(res);
}

void PrintNameDefs(FILE *fpout)
{
   fprintf(fpout, 
"\nThe times labeled Reference are for ATLAS as installed by the authors.\n");
   fprintf(fpout, "NAMING ABBREVIATIONS:\n");
   fprintf(fpout, "   kMV_N  : NoTranspose matvec kernel\n");
   fprintf(fpout, "   kMV_T  : Transpose matvec kernel\n");
   fprintf(fpout, "   kGER   : GER (rank-1 update) kernel\n");
   fprintf(fpout, "   kGER2  : GER2 (rank-2 update) kernel\n");
   fprintf(fpout, "   kSelMM : selected matmul kernel (may be hand-tuned)\n");
   fprintf(fpout, "   BIG_MM : large GEMM timing (usually N=1600); estimate of asymptotic peak\n");
   fprintf(fpout, 
           "Kernel routines are not called by the user directly, and their\n");
   fprintf(fpout, "performance is often somewhat different than the total\n");
   fprintf(fpout, "algorithm (eg, dGER perf may differ from dkGER)\n\n");
}

void PrintComparison(FILE *fpout, double **oldres, double **newres)
{
   int i, j, k;

   PrintNameDefs(fpout);
   fprintf(fpout, "\nReference clock rate=%dMhz, new rate=%dMhz\n",
           (int) oldres[0][NBENCH], (int) newres[0][NBENCH]);
   fprintf(fpout, 
      "   Refrenc : %% of clock rate achieved by reference install\n");
   fprintf(fpout, 
      "   Present : %% of clock rate achieved by present ATLAS install\n\n");

   fprintf(fpout, "                    single precision                  double precision\n");
   fprintf(fpout, "            ********************************   *******************************\n");
   fprintf(fpout, "                  real           complex           real           complex\n");
   fprintf(fpout, "            ---------------  ---------------  ---------------  ---------------\n");
   fprintf(fpout, "Benchmark   Refrenc Present  Refrenc Present  Refrenc Present  Refrenc Present\n");
   fprintf(fpout, "=========   ======= =======  ======= =======  ======= =======  ======= =======\n");
   for (i=0; i < NBENCH; i++)
   {
      if (i == KMV_N) j = MM_BIG;
      else if (i > KMV_N) j = i-1;
      else j = i;
      fprintf(fpout, "%8.8s  ", BNCHNAMES[j]);
      for (k=0; k < 4; k++)
         fprintf(fpout, " %8.1f %7.1f", oldres[k][j], newres[k][j]);
      fprintf(fpout, "\n");
   }
}

void PrintSum(FILE *fpout, double **res)
{
   int i, j, k;

   PrintNameDefs(fpout);
   fprintf(fpout, "\nClock rate=%dMhz\n", (int) res[0][NBENCH]);

   fprintf(fpout, 
           "               single precision        double precision\n");
   fprintf(fpout, 
           "            *********************    ********************\n");
   fprintf(fpout, 
           "               real      complex       real      complex\n");
   fprintf(fpout, 
           "Benchmark   %%   Clock   %%   Clock   %%   Clock   %%   Clock\n");
   fprintf(fpout, 
           "=========   =========   =========   =========   =========\n");
   for (i=0; i < NBENCH; i++)
   {
      if (i == KMV_N) j = MM_BIG;
      else if (i > KMV_N) j = i-1;
      else j = i;
      fprintf(fpout, "%8.8s  ", BNCHNAMES[j]);
      for (k=0; k < 4; k++)
         fprintf(fpout, " %9.1f ", res[k][j]);
      fprintf(fpout, "\n");
   }
}

int main(int nargs, char **args)
/*
 * This program benchmarks an ATLAS install, and compares it against a prior
 * install, if such a prior install exists.  If necessary, it runs 
 * gemmtst to figure out asymptotic performance of GEMM.
 */
{
   char *fname, *currd, *oldd;
   FILE *fpout;
   double **refres=NULL, **newres;

   fpout = GetFlags(nargs, args, &fname, &currd, &oldd);
   newres = ReadBenchmarks(currd, fname);
   assert(newres);
   refres = ReadBenchmarks(oldd, fname);
   if (refres)
      PrintComparison(fpout, refres, newres);
   else PrintSum(fpout, newres);
   if (fpout != stdout && fpout != stderr)
      fclose(fpout);
   return(0);
}
@ROUT mgwcmp
@extract -b @(topd)/cw.inc lang=c -define cwdate 2011
/*
 * This is a BFI wrapper around MinGW compilers/ar for use in cygwin build
 * framework.  Its only job is to substutute 'c:' for 'cygdrive/c' (where
 * 'c' can be any single letter) in all paths (except that of the
 * compiler itself).
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#define Mstr2(m) # m
#define Mstr(m) Mstr2(m)
#ifndef DEFDF
   #ifdef WRAP_FORTRAN
      #define DEFDF /usr/bin/x86_64-w64-mingw32-gfortran.exe
   #elif defined(WRAP_AR)
      #define DEFDF /usr/bin/x86_64-w64-mingw32-ar.exe
   #else
      #define DEFDF /usr/bin/x86_64-w64-mingw32-gcc-4.5.3.exe
   #endif
#endif

int cygdrivesub(char *ln)
/*
 * replaces /cygdrive/c/ with c://, returns change in string length
 */
{
   char *sp;
   int i=0;

/*
 * 01234567890
 * /cygdrive/L...
 */
   while(sp = strstr(ln, "/cygdrive/"))
   {
      i++;
      sp[0] = sp[10];
      sp[1] = ':';
      sp[2] = '/';
      sp += 3;
      while (*sp = sp[8]) sp++;
   }
   return(i*8);
}

#ifdef DEBUG
   #define system SYSTEM
   int system(char *ln)
   {
      fprintf(stdout, "%s\n", ln);
      return(0);
   }
#endif

char *GetLongerString(char *old, int len)
{
   char *sp;

   assert(len);
   sp = malloc(sizeof(char)*(len+1));
   assert(sp);
   if (old)
   {
      assert(len > strlen(old));
      strcpy(sp, old);
      free(old);
   }
   return(sp);
}

int main(int nargs, char **args)
{
   char *ln;
   int i, j, k, lnlen=0, ierr, ii;

/*
 * The path to the compiler does not substitute c:/, since it is cygwin
 * handling it, not MinGW
 */
   lnlen = (strlen(Mstr(DEFDF))+2)*2;
   ln = GetLongerString(NULL, lnlen);
   ii = sprintf(ln, "%s", Mstr(DEFDF));

/*
 * Just paste all commandline arguments together, getting rid of // from make
 * and then substituting c:// for any /cygdrive/c/
 */
   for (i=1; i < nargs; i++)
   {
      char *sp;
      j = strlen(args[i]) + 1;
      if (lnlen < ii+j)
      {
         lnlen = (lnlen+j)*2;
         ln = GetLongerString(ln, lnlen);
      }
      ln[ii++] = ' ';
      strcpy(ln+ii, args[i]);
/*
 *    ATLAS makefiles often put in // by accident, which is no problem under
 *    Unix, but means something special in Windows.  Therefore replace all
 *    // with / before doing cygdrivesub
 */
      while (sp = strstr(ln+ii, "//"))
      {
         strcpy(sp, sp+1);
         j--;
      }
      j -= cygdrivesub(ln+ii);   /* sub c:// for /cygdrive/c */
      ii += j - 1;
   }
//   fprintf(stdout, "%s", ln);
   ierr = system(ln);
   if (ierr)
      fprintf(stderr, "\nMINGW COMPILER WRAP '%s' GAVE ERROR FOR `%s'\n\n", 
              args[0], ln);
/*
 * Error returns don't translate well between MinGW/cygwin; returning 0 or 1
 * just experimentally works.
 */
   return((!ierr)?0:1);
}

@ROUT wincc winar winf77
@extract -b @(topd)/gen.inc what=cw @(cw99)
#include <stdio.h>
#include <stdlib.h>
@ROUT wincc winf77
#include <string.h>
#include <assert.h>
@ROUT wincc winar winf77
#define Mstr2(m) # m
#define Mstr(m) Mstr2(m)
@ROUT wincc
#ifndef DEFDF
/*   #define DEFDF "c:/Program Files/Microsoft Visual Studio/VC/BIN/CL.EXE" */
   #define DEFDF CL.EXE
#endif
@ROUT winf77
#ifndef DEFDF
   #define DEFDF IFORT.EXE
#endif
@ROUT wincc winar winf77 MinGWPATH

int slashdrivesub(char *ln)
/*
 * replaces \\c\ with c:\, returns change in string length
 * this version required for older cygwins
 */
{
   char *sp, *lp=ln, ctmp;
   int nrep=0;
   do
   {
      sp = strstr(lp, "\\\\");
      if (sp && strlen(sp) > 3)
      {
         if (sp[2] == 'a' || sp[2] == 'b' || sp[2] == 'c' || sp[2] == 'd' ||
             sp[2] == 'e' || sp[2] == 'f' || sp[2] == 'g' || sp[2] == 'h')
         {
            if (sp[3] == '\\')
            {
               ctmp = sp[2];
               sp[0] = sp[2];
               sp[1] = ':';
               sp[2] = '\\';
               for (lp=sp+3; *lp = lp[1]; lp++);
               lp = sp + 3;
               nrep++;
            }
            else lp = sp + 2;
         }
         else lp = sp + 2;
      }
      else lp = sp + 2;
   }
   while (sp);
   return(-nrep);
}

int cygdrivesub(char *ln)
/*
 * replaces \cygdrive\c\ with c:\, returns change in string length
 * this version works cygnus version 1.1.0
 */
{
   char *sp;
   int i=0;

   while(sp = strstr(ln, "\\cygdrive\\"))
   {
      i++;
      sp[0] = sp[10];
      sp[1] = ':';
      sp[2] = '\\';
      sp += 3;
      while (*sp = sp[9]) sp++;
   }
   return( slashdrivesub(ln) - (i*9) );
}

void slashsub(char *ln)
/* 
 * changes forward slash of unix to backslash of windoze
 */
{
   int i;
   for (i=0; ln[i]; i++) if (ln[i] == '/') ln[i] = '\\';
}
@ROUT wincc winar winf77

void doto2dotobj(char *ln)
/*
 * changes all occurences of unix's .o extension to windoze-friendly obj
 */
{
   char ln2[4096];
   int i, j=0;
   for (i=0; ln[i]; i++)
   {
      ln2[j++] = ln[i];
      if (ln[i] == '.' && ln[i+1] == 'o' && isspace(ln[i+2]))
      {
         ln2[j] = 'o';
         ln2[j+1] = 'b';
         ln2[j+2] = 'j';
         ln2[j+3] = ln[i+2];
         j += 4;
         i += 2;
      }
   }
   ln2[j] = '\0';
   sprintf(ln, "%s", ln2);
}

@ROUT wincc winf77
#ifdef DEBUG

#define system SYSTEM
int system(char *ln)
{
   fprintf(stdout, "%s\n", ln);
   return(0);
}

#endif

typedef struct wOrDs WORDS;
struct wOrDs
{
   char *word;
   WORDS *next;
};

void KillWords(WORDS *wp)
{
   WORDS *wpn;

   while (wp)
   {
      free(wp->word);
      wpn = wp->next;
      free(wp);
      wp = wpn;
   }
}

WORDS *AddWord(WORDS *wbas, char *wrd, int wlen)
{
   WORDS *wp;
   int i;

   wp = malloc(sizeof(WORDS));
   assert(wp);
   wp->word = malloc( (wlen+1) * sizeof(char) );
   for (i=0; i != wlen; i++) wp->word[i] = wrd[i];
   wp->word[i] = '\0';
   wp->next = wbas;
   return(wp);
}

WORDS *AddFile(WORDS *wbase, char *fnam)
{
   int i, len;
   len = strlen(fnam);
   assert(len > 2);
@ROUT wincc
   if (fnam[len-1] = 'c' && fnam[len-2] == '.');
@ROUT winf77
   if (fnam[len-1] = 'f' && fnam[len-2] == '.');
@ROUT wincc winf77
   {
      for (i=len-3; i > 0; i--)
      {
         if (fnam[i] == ' ' || fnam[i] == '/' || fnam[i] == '\\')
         {
            i++;
            break;
         }
      }
      wbase = AddWord(wbase, fnam+i, len-i-2);
   }
   return(wbase);
}

int RenameFiles(WORDS *wbase)
{
   WORDS *wp;
   char ln[4096];

   for (wp=wbase; wp; wp = wp->next)
   {
      sprintf(ln, "MOVE %s.obj %s.o\n", wp->word, wp->word);
      fprintf(stdout, "%s", ln);
      if (system(ln)) return(1);
   }
   return(0);
}

int NeedsQuotes(char *str)
/*
 * This func added 07/20/07, as cygwin now requires us to put quotes
 * around any path containing windows \ path character or space.
 * Note that you need to compile prog without -mno-cygwin.  With
 * -mno-cygwin, seem to get same shell as when compiled with cl, which
 * seems to not work at all
 * RETURNS: 1 if need quotes, 0 else
 */
{
   int i, k;
   return(0);
   for (i=0; str[i]; i++)
   {
       if (str[i] == '\\') return(1);
       else if (str[i] == '/') return(2);
       else if (str[i] == ' ')
       {
          for (k=0; str[k]; k++)
             if (str[k] != ' ') return(4);
       }
   }
   return(0);
}

int main(int nargs, char **args)
{
   char ln[4096], *cptr=NULL;
   int i, j, k, ierr, ic, ii;
   int COMP=0, RENAME=0;
   WORDS *wbase=NULL;

@skip   ic = sprintf(ln, "\"%s\" /iface:cref ", DEFDF);
   ic = sprintf(ln, "\"%s\" ", Mstr(DEFDF));
@skip   assert(ln[2] == ':');
@skip   ln[2] == ln[1];
@skip   ln[1] = '/';
   slashsub(ln);
@ROUT winf77
   ic += sprintf(ln+ic, "/iface:cref ");
@ROUT wincc winar winf77

@skip   ic = sprintf(ln, "\"c:\\Program Files\\DevStudio\\DF\\BIN\\DF.EXE\" /iface:cref ");
   for (i=1; i < nargs; i++)
   {
      if (args[i][0] == '-')  /* compiler flag */
      {
         if (args[i][1] == 'o') /* handle renaming, guess exe not .obj */
         {
            RENAME = 1;
            k = strlen(args[++i]);
            if (NeedsQuotes(args[i]))
               j = sprintf(ln+ic, "'/Fe%s.exe' ", args[i]);
            else
               j = sprintf(ln+ic, "/Fe%s.exe ", args[i]);
            cptr = ln+ic;
            slashsub(ln+ic+3);
         }
         else if (args[i][1] == 'l') /* library to link against */
         {
            if (NeedsQuotes(args[i]))
               j = sprintf(ln+ic, "'/link:DEFAULTLIB:%s'", &args[i][2]);
            else
               j = sprintf(ln+ic, "/link:DEFAULTLIB:%s", &args[i][2]);
            slashsub(ln+ic+17);
         }
         else if (args[i][1] == 'm' && args[i][2] == '3' 
                  && args[i][3] == '2' && args[i][4] == '\0')
            j=0;  /* do not pass on -m32/64 to windows compilers */
         else if (args[i][1] == 'm' && args[i][2] == '3' 
                  && args[i][3] == '2' && args[i][4] == '\0')
            j=0;  /* do not pass on -m32/64 to windows compilers */
         else if (args[i][1]=='m' && args[i][2]=='s' && args[i][3]=='s' && 
                  args[i][4] == 'e')
         {
            if (args[i][5] == '\0')
               j = sprintf(ln+ic, "/arch:sse");
            else
               j = sprintf(ln+ic, "/arch:sse2");
         }
         else if (args[i][1]=='m' && args[i][2]=='a' && args[i][3]=='v' && 
                  args[i][4] == 'x')
            j = sprintf(ln+ic, "/arch:avx");
         else if (args[i][1] == 'm' && args[i][2] == '3' 
                  && args[i][3] == '2' && args[i][4] == '\0')
              ;  /* do not pass on -m32/64 to windows compilers */
         else
         {
            if (args[i][1] == 'c') COMP=1;
            if (NeedsQuotes(args[i]))
            {
               j = sprintf(ln+ic, "'/%s' ", &args[i][1]);
               slashsub(ln+ic+2);
            }
            else
            {
               j = sprintf(ln+ic, "/%s ", &args[i][1]);
               slashsub(ln+ic+1);
            }
         }
      }
      else  /* must be files, not flags */
      {
         if (NeedsQuotes(args[i]))
         {
            ii = 1;
            j = sprintf(ln+ic, "'%s' ", args[i]);
         }
         else
         {
            ii = 0;
            j = sprintf(ln+ic, "%s ", args[i]);
         }
@ROUT wincc
         if (j+ii > 3 && ln[ic+j-2-ii] == 'c' && ln[ic+j-3-ii] == '.')
@ROUT winf77
         if (j+ii > 3 && ln[ic+j-2-ii] == 'f' && ln[ic+j-3-ii] == '.')
@ROUT wincc winf77
         { /* add this file to list of files to be moved to .o */
            wbase = AddFile(wbase, args[i]);
         }
         slashsub(ln+ic);
      }
      ic += j;
   }
   sprintf(ln+ic, "\n");
   cygdrivesub(ln);
   if (RENAME && COMP) /* gotta use different rename command if not exe */
   {
      cptr = strstr(ln, "/Fe");
      assert(cptr);
      cptr[2] = 'o';
      cptr = strstr(cptr, ".exe");
      assert(cptr);
      cptr[0] = cptr[1] = cptr[2] = cptr[3] = ' ';
   }
   fprintf(stdout, "%s", ln);
   ierr = system(ln);
   if (!ierr && COMP && !RENAME) /* rename the .obj to .o */
      ierr = RenameFiles(wbase);
   KillWords(wbase);
   return(ierr);
}
@ROUT run_cl6x
#!/bin/sh
# Note: the shell language lets us extract substrings; see the following page for help:
# http://tldp.org/LDP/abs/html/string-manipulation.html.
# short version: ${string:start:len} is a substring; ${string:(-n)} takes last n chars, 
# ${string:position} takes all of string from position on, ${string#pattern} takes shortest
# match of 'pattern' off the front, ${string##pattern} takes longest match of pattern off
# the front; % and %% delete shortest / longest match of pattern from the END of string.
# The position is zero relative; so ${arg:0:2} is first two characters of string. A negative
# number must be enclosed in parens and counts back from the end of the string.
#
# This is our interface to the cl6x compiler, for ATLAS. We just prefix the list of args, $*, 
# with the necessary parameters for a compile and/or link. We rebuild the parameters as we 
# go, so we can do replacements as needed. 
# Replacement: for compile only, '-o' is replaced with '--output_file'.
# Replacement: the flag '-fomit-frame-pointer' is deleted.
# Replacement: The flag '-On' (n=0,1,2,3) is deleted and replaced with '--opt_level=n'.
# HIJACK: If we see --version or -qversion, we execute cl6x with just --compiler_revision and exit.
LINKARGS="-x -c /home/tony/C6678_unified.cmd --args=512 --search_path=/opt/ti/TI_CGT_C6000_7.4.2/lib/"
# -x means re-read libraries, -c means link using ROM initialization. 
# --args=N allows N bytes for argument passing.
# The C6678_unified.cmd is a linker command file, sets stack size, heap size, memory map.
# /home/tony/C6678_unified.cmd: Obviously, change directory to your source of the cmd file.

COMPARGS="-mv6600 -q --gcc --openmp -I=/opt/ti/TI_CGT_C6000_7.4.2/include/"
# -mv6600 forces the compiler to our C6678 architecture.
# -q is just quiet.
# --gcc enables (some?) GCC extensions that are available in cl6x.
# --openmp means enable openmp hooks.
# -I is the include files like stdio.h, you must use the TI C6678 versions.
# --opt_level=n is the optimization level; We have to translate any gcc style -On used by ATLAS,
# because cl6x mistakes any "-O" as an alternative to their --output_file.
# This script restricts optimization level to 2. 

OPTLEVEL="--opt_level=2"
COMPILE_ONLY=0 
EXENAME=""
GETNAME=0
OPTZERO=0
OBJNAME=""
SRCNAME=""
FORCEO3=0
pass=""
passobj=""

# Loop through all variables, see if '-c' is present.
echo "Start run_cl6x:" >> run_cl6x.log
for arg in $*
do 
   echo "Arg: $arg" >> run_cl6x.log
   if test "$arg" = "--version" -o "$arg" = "-qversion"
   then
      echo "Hijacked to cl6x --compiler_revision." >> run_cl6x.log
      cl6x --compiler_revision
      exit
   fi

   if test "$arg" = "-c"
   then
      COMPILE_ONLY=1
   fi
done

# We have to do this in two passes; '-o' in a link is
# correct, -o in a compile only is not. 
# Compile only loop: we change -o to --output_file.
# Compile only loop: we change -On to --opt_level=n.
# Compile only loop: we delete -fomit-frame-pointer.
if test $COMPILE_ONLY -eq 1
then 
for arg in $*
do 
   if test $GETNAME -eq 1
   then
      OBJNAME="$arg"
      pass="$pass $arg"
      GETNAME=2               # Say we do not NEED --output_file.
   elif test "$arg" = "-o"
   then 
      pass="$pass --output_file"
      GETNAME=1
   elif test "${arg:(-2)}" = ".c"  # if a C file, get obj name.
   then
      SRCNAME="$arg"               # collect source name.
      pass="$pass $arg"            # add to passed parameters.
      FileLines=`wc -l <$SRCNAME`  # Executes cmd, puts in var.
      if test $FileLines -gt 1000  # If more than 1000 lines,
      then
         OPTZERO=1                 # Remember to downgrade optim.
      fi

      if test "$OBJNAME" = "" #If no OBJNAME yet, set default.
      then
         OBJNAME="${arg##*/}"  #Kill any leading directory info.
         OBJNAME="${OBJNAME%.c}.o" #Strip final .c, add .o.
      fi
   elif test "$arg" = "-O0"
   then 
      OPTLEVEL="--opt_level=0"
   elif test "$arg" = "-O1"
   then 
      OPTLEVEL="--opt_level=1"
   elif test "$arg" = "-O2" -o "$arg" = "-O"
   then 
      OPTLEVEL="--opt_level=2"
   elif test "$arg" = "-O3"
   then 
      OPTLEVEL="--opt_level=2"
   elif test "$arg" = "--FORCE-O3"
   then 
      FORCEO3=1
   elif test "$arg" = "--opt_level=3"
   then 
      OPTLEVEL="--opt_level=2"
   elif test "${arg:0:11}" = "--opt_level" # If not 3, use as is.
   then
      OPTLEVEL="$arg"         # strip out so only passed once.
   elif test "$arg" != "-fomit-frame-pointer"
   then 
      pass="$pass $arg"
   fi
done

# Compile and LINK: We do not change -o, we have to find
# a '.c' file, and compile it separately, and build a separate
# list of '.o' files and '.a' files and '-l' commands.
else  # We are going to compile AND link.
for arg in $*
do 
   if test $GETNAME -eq 1 #If this arg is EXE NAME,
   then
      EXENAME="$arg"
      GETNAME=0      #Don't need it.
   elif test "$arg" = "-o"
   then
      GETNAME=1
   elif test "${arg:(-2)}" = ".o"  # If an object file,
   then
      passobj="$passobj $arg"
   elif test "${arg:(-2)}" = ".a"  # If a library file,
   then
      passobj="$passobj $arg"
   elif test "$arg" = "-lm"        # If a library flag,
   then
      echo "-lm flag ignored." >>run_cl6x.log
   elif test "${arg:(-2)}" = ".c"  # if a C file, get obj name.
   then
      SRCNAME="$arg"
      OBJNAME="${arg##*/}"  #Kill any leading directory info.
      OBJNAME="${OBJNAME%.c}.o" #Strip final .c, add .o.
      FileLines=`wc -l <$SRCNAME`  # Executes cmd, puts in var.
      if test $FileLines -gt 1000  # If more than 1000 lines,
      then
         OPTZERO=1                 # Remember to downgrade optim.
      fi
   elif test "$arg" = "-O0"
   then 
      OPTLEVEL="--opt_level=0"
   elif test "$arg" = "-O1"
   then 
      OPTLEVEL="--opt_level=1"
   elif test "$arg" = "-O2" -o "$arg" = "-O"
   then 
      OPTLEVEL="--opt_level=2"
   elif test "$arg" = "-O3"
   then 
      OPTLEVEL="--opt_level=2"
   elif test "$arg" = "--FORCE-O3"
   then 
      FORCEO3=1
   elif test "$arg" = "--opt_level=3"
   then 
      OPTLEVEL="--opt_level=2"
   elif test "${arg:0:11}" = "--opt_level"
   then
      OPTLEVEL="$arg"         # strip out so only passed once.
   elif test "$arg" != "-fomit-frame-pointer"
   then 
      pass="$pass $arg"       # Just pass through to compile.
   elif test "$arg" = "ATL_sger1k.c"   # if THIS file,
   then  
      echo "Forcing ATL_sger1k.c to --opt_level=0 to avoid opt6x v. 7.4.2 Out-Of-Memory bug." >> run_cl6x.log
      OPTZERO=1                        # opt6x (v 7.4.2) sometimes runs out of memory.
   fi
done
fi

if test $OPTZERO -eq 1        # If we have reason to zero optimization,
then
   OPTLEVEL="--opt_level=0"   # Do not try to optimize.
fi

if test $FORCEO3 -eq 1        # If we forcing o3 anyway,
then
   echo "Changing --FORCE-O3 to --opt_level=2." >> run_cl6x.log
   OPTLEVEL="--opt_level=2"   # Optimize it.
fi

if test $COMPILE_ONLY -eq 0
then
   if test "$SRCNAME" != ""             # If we have a source, compile.
   then
      echo "Compile with Link." >> run_cl6x.log
      echo cl6x $COMPARGS $OPTLEVEL -c $SRCNAME $pass --output_file $OBJNAME >> run_cl6x.log
      cl6x $COMPARGS $OPTLEVEL -c $SRCNAME $pass --output_file $OBJNAME
   else                                 # No Source, so we only link.
      echo "No source; Link alone." >> run_cl6x.log
   fi

   echo lnk6x -o $EXENAME.out ${OBJNAME} -m ${EXENAME}.map $LINKARGS $passobj >> run_cl6x.log
   lnk6x -o $EXENAME.out ${OBJNAME} -m ${EXENAME}.map $LINKARGS $passobj

else # We are doing a compile only; assume $pass contains file names we need.
   echo "Compile Only." >> run_cl6x.log
   if test $GETNAME -eq 2                 # If we already have --output_file in $pass... 
   then
      echo cl6x $COMPARGS $OPTLEVEL $pass >> run_cl6x.log
      cl6x $COMPARGS $OPTLEVEL $pass
   else                                   # Need to add --output_file.
      echo cl6x $COMPARGS $OPTLEVEL $pass --output_file $OBJNAME >> run_cl6x.log
      cl6x $COMPARGS $OPTLEVEL $pass --output_file $OBJNAME
   fi
fi # end handle compile and link vs. compile only.
 
@ROUT atlas_sys.h
#ifndef ATLAS_SYS_H
   #define ATLAS_SYS_H
/*
 * This file contains routines to interact with the system (as in the C 
 * `system' command), and related I/O
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <assert.h>

static char *NewStringCopy(char *old)
/*
 * RETURNS: newly allocates string containing copy of string old
 * NOTE: old is not modified.
 */
{
   char *new;
   if (!old)
      return(NULL);
   new = malloc(sizeof(char)*(strlen(old)+1));
   assert(new);
   strcpy(new, old);
   return(new);
}

static char *NewAppendedString0(char *old, char *app)
/*
 * RETURNS: string holding : old + app
 * NOTE: frees old string after copy
 */
{
   char *new;
   if (!old)
   {
      new = malloc(sizeof(char)*(strlen(app)+1));
      assert(new);
      strcpy(new, app);
   }
   else
   {
      new = malloc(sizeof(char)*(strlen(old) + strlen(app)+1));
      assert(new);
      strcpy(new, old);
      strcat(new, app);
      free(old);
   }
   return(new);
}

static char *NewAppendedString(char *old, char *app)
/*
 * RETURNS: string holding : old + " " + app
 * NOTE: frees old string after copy
 */
 
{
   char *new;
   if (!old)
   {
      new = malloc(sizeof(char)*(strlen(app)+1));
      assert(new);
      strcpy(new, app);
   }
   else
   {
      new = malloc(sizeof(char)*(strlen(old) + strlen(app)+2));
      assert(new);
      strcpy(new, old);
      strcat(new, " ");
      strcat(new, app);
      free(old);
   }
   return(new);
}

static char *NewAppendedStrings(char *old, char *app0, char *app1)
/*
 * RETURNS: string holding : old + " " + app0 + " " + app1
 * NOTE: frees old string after copy
 */
 
{
   char *new;
   int len;

   assert(app0 && app1);
   len = strlen(app0) + strlen(app1) + 2;
   if (!old)
   {
      new = malloc(sizeof(char)*len);
      assert(new);
      sprintf(new, "%s %s", app0, app1);
   }
   else
   {
      len += strlen(old) + 1;
      new = malloc(sizeof(char)*len);
      assert(new);
      sprintf(new, "%s %s %s", old, app0, app1);
      free(old);
   }
   return(new);
}

static char *ATL_fgets(char *sout, int *plen, FILE *fpin)
/*
 * This routine returns a pointer to a single line of of file fpin.
 * If the plen-length string sout is long enough to hold the file's line,
 * then sout will be the return value.  Otherwise sout will be freed and
 * a new string will be returned.  
 * Upon EOF/error: sout is de-allocated, *len=0, & NULL is returned;
 * *len is the length of sout on input, and of the returned string on output.
 */
{
   int len = *plen;
   if (!sout || len < 1)
   {
      *plen = len = 128;
      sout = malloc(len*sizeof(char));
      assert(sout);
   }
/*
 * See if there is a line left in file
 */
   if (fgets(sout, len, fpin))
   {
      int i;
      for (i=0; sout[i]; i++);
      assert(i > 0);
      if (sout[i-1] == '\n')    /* if this is complete line */
         return(sout);          /* we are done, return it */
/*
 *    Continue doubling string length until we can fit the whole string
 */
      while (sout[i-1] != '\n')
      {
         char *sp;
         int len0 = len;

         *plen = (len += len);
         sp = malloc(len*sizeof(char));
         assert(sp);
         strcpy(sp, sout);
         free(sout);
         sout = sp;
         sp += i;
         if (!fgets(sp, len0, fpin))
            return(sout);
         for (; sout[i]; i++);
      }
      return(sout);

   }
   else
   {
      *plen = 0;
      free(sout);
   }
   return(NULL);
}

static char *ATL_fgets_CWS(char *sout, int *plen, FILE *fpin)
/*
 * This routine returns a pointer to a single line of of file fpin.
 * It then compresses the whitespace in the line for ease of parsing:
 * (1) The first character in the line is non-whitespace
 * (2) The last character in the line is non-whitespace
 * (3) Any whitespace string of 1 or more ws chars is replaced with 1 ' '
 * (4) If the entire line is whitespace, get another until EOF or non-ws
 * If the size-len string sout is long enough to hold the file's line,
 * then sout will be the return value.  Otherwise sout will be freed and
 * a new string will be returned.  
 * Upon EOF/error: sout is de-allocated, *len=0, & NULL is returned;
 * *len is the length of sout in input, and of the returned string on output.
 */
{
   int i, j;
   char *sp;
/* 
 * Find the end of any preceding whitespace line; if the whole line is 
 * whitespace, keep getting lines until we've got one with some non-ws chars
 */
   do
   {
      sout = ATL_fgets(sout, plen, fpin);
      if (!sout)
         return(NULL);
      for (i=0; isspace(sout[i]); i++);
   }
   while (sout[i] == '\0');
/*
 * Now, go through line, replacing all whitespace with single ' '
 */
   for (sp=sout+i,j=0; sp[j]; j++)
   {
      if (isspace(sp[j]))
      {
         sout[j] = ' ';
         while (isspace(sp[j])) sp++;
         sp--;
      }
      else
         sout[j] = sp[j];
   }
/*
 * Shave off any trailing ws (can only be one due to above)
 */
   if (isspace(sout[j-1]))
      sout[j-1] = '\0';
   else
      sout[j] = '\0';
   return(sout);
}

static char *ATL_tmpnam(void)
{
   static char tnam[L_tmpnam];
   static char FirstTime=1;
   if (FirstTime)
   {
      FirstTime = 0;
      assert(tmpnam(tnam));
   }
   return(tnam);
}

static FILE *atlsys(char *targ, char *cmnd, int verb, int IgnoreErr)
/*
 * Executes command cmnd, returns open ("r" mode) file stream to output of 
 * command.  If IgnoreErr is 0, then return NULL on error.
 */
{
   char *tnam, *sp;
   int i;
   FILE *output=NULL;

   tnam = ATL_tmpnam();
   if (targ)
   {
      i = strlen(targ) + strlen(cmnd) + strlen(tnam) + 24;
      sp = malloc(i*sizeof(char));
      assert(sp);
      sprintf(sp, "ssh %s \"%s\" > %s 2>&1 \n", targ, cmnd, tnam);
   }
   else
   {
      i = strlen(cmnd) + strlen(tnam) + 16;
      sp = malloc(i*sizeof(char));
      assert(sp);
      sprintf(sp, "%s > %s 2>&1\n", cmnd, tnam);
   }
   i = system(sp);
   if (i && verb)
   {
      fprintf(stderr, "\nierr=%d in command='%s'!\n\n", i, cmnd);
      if (verb > 1)
      {
         int gccsucks;
         fprintf(stderr, "OUTPUT:\n=======\n");
         sprintf(sp, "cat %s", tnam);
         gccsucks = system(sp);
      }
   }
   free(sp);
   if (!i || IgnoreErr)
      output = fopen(tnam, "r");
   return(output);
}

static char *atlsys_1L(char *targ, char *cmnd, int verb, int CWS)
/*
 * Executes system(cmnd), returns 1st line as allocated string.  Returns NULL
 * on error.
 */
{
   FILE *fp;
   char *ln=NULL;
   int len=0;

   fp = atlsys(targ, cmnd, verb, 0);
   if (fp)
   {
      if (CWS)
         ln = ATL_fgets_CWS(ln, &len, fp);
      else
         ln = ATL_fgets(ln, &len, fp);
      fclose(fp);
   }
   return(ln);
}
#endif
@ROUT gnuccw gnuf90w gcc3p fkoc
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <ctype.h>
#include <string.h>
#define DEBUG 1
#ifdef DEBUG
   FILE *fplog=NULL;
#endif
@ROUT fkoc
#ifndef MYPP 
   #define MYPP "xextract"
#endif
#ifndef MYFKO
   #define MYFKO "fko"
#endif
#ifndef MYASM 
   #define MYASM "gcc"
#endif
/*
 * This is a helper wrapper for fko (floating point kernel optimizer) to make
 * it act more like a compiler, with an option to apply a preprocessor.
 * fko takes only one source file, and output assembly, whereas most
 * build processes assume that multiple files can be passed, with the
 * output being an object file.  This wrapper does *not* support linking.
 * This wrapper does:
 * (1) For files ending in .B, run MYPP (extract) as preprocessor to create
 *     an FKO HIL file (ending in .b) for compiling by fko
 * (2) Run MYFKO fko on all .b files to produce assembly (.s)
 * (3) Run MYASM on all .s files to produce an object file (.o)
 * The script itself takes flags of (ones w/o -- are standard unix flags):
 * --<flag> : as shown in PrintUsage
 * -Dhand=def -D hand=def -> only used for .B files, passed as -def to extract
 * -o file.[o,obj] -> output object file name (must not contain ., or end 
 *    in .o or .obj)
 * -@[extract flag] : eg. -@type=sreal -@-langC -@'-def type double'
 *                    embedded spaces muse be surrounded by '' (not "")
 * -s : produce assembly rather than object file
 * NOTE: any arg not beginning with - and ending in ".b" or ".B" is assumed to
 *       be a file to be compiled.
 */
@ROUT gcc3p
#ifndef MYGCC
   #define MYGCC "gcc"
#endif
#ifndef MYASM
   #define MYASM "as"
#endif
#ifndef MYLNK
   #define MYLNK "clang"
#endif
@ROUT gnuccw gnuf90w
#if 1
   #ifndef MYGCC
      #define MYGCC "/sw/bin/gcc-fsf-4.6"
   #endif
   #ifndef MYASM
      #define MYASM "clang"
   #endif
   #ifndef MYLNK
      #define MYLNK "clang"
   #endif
#else
   #ifndef MYGCC
      #define MYGCC "gcc"
   #endif
   #ifndef MYASM
      #define MYASM "gcc"
   #endif
   #ifndef MYLNK
      #define MYLNK "gcc"
   #endif
#endif
@ROUT gnuccw gnuf90w gcc3p
/*
 * This is a wrapper around a GNU gcc installation which is using the
 * native assembler and linker rather than the gnu alternatives.  This
 * scenario happens extremely often, for example on Mac OS 10.7 where
 * the native gnu binutils are broken old versions, or on Solaris with the same.
 * This wrapper parses the input and breaks the command into 1-3 separate
 * actions, depending on the flags and files given:
 * (1) Compile any .c or .S files to .s using the provided gcc
 * (2) Assemble these new .s files to .o using the provided assembler
 * (3) Link these files together using the provided linker
 *
 * Compiles with "-c" as a flag do only steps 1-2.
 */
@ROUT gnuccw gnuf90w gcc3p fkoc
char *CatStrs(char *s1, char *s2)
{
   int i1, i2, i;
   char *sp;
   i1 = strlen(s1);
   i2 = strlen(s2);
   sp = malloc(i1 + i2 + 1);
   assert(sp);
   for (i=0; i < i1; i++)
      sp[i] = s1[i];
   for (i=0; i < i2; i++)
      sp[i1+i] = s2[i];
   sp[i1+i2] = '\0';
   return(sp);
}

typedef struct ARGNODE ATL_arg_t;
struct ARGNODE
{
   ATL_arg_t *next;
   char *arg;
   int len, nespc;    /* len of arg, # of embedded spaces in arg */
};

ATL_arg_t *NewArg(char *arg)
{
   ATL_arg_t *ap;
   char *sp;
   int ib, ie, i, nes, len;

   ap = malloc(sizeof(ATL_arg_t));
   assert(ap);
   ap->next = NULL;

   if (!arg)
   {
      ap->arg = NULL;
      ap->len = ap->nespc = 0;
      return(ap);
   }
   for (ib=0; arg[ib] != '\0' && isspace(arg[ib]); ib++);
   for (ie=ib; arg[ie] != '\0'; ie++);
   for (ie--; isspace(arg[ie]); ie--);
   len = ie - ib + 1;
   ap->arg = sp = malloc(len+1);
   assert(sp);
   for (len=nes=0,i=ib; i <= ie; i++)
   {
      char ch;
      sp[len++] = ch = arg[i];
      if (isspace(ch))
         nes++;
   }
   sp[len] = '\0';
   ap->len = len;
   ap->nespc = nes;
   return(ap);
}

ATL_arg_t *DupArg(ATL_arg_t *ap)
{
   ATL_arg_t *np;
   np = malloc(sizeof(ATL_arg_t));
   assert(np);
   np->len = ap->len;
   np->nespc = ap->nespc;
   np->next = NULL;
   np->arg = malloc(ap->len+1);
   assert(np->arg);
   strcpy(np->arg, ap->arg);
   return(np);
}

ATL_arg_t *KillArg(ATL_arg_t *ap)
{
   ATL_arg_t *ret=NULL;
   if (ap)
   {
      ret = ap->next;
      if (ap->arg)
         free(ap->arg);
      free(ap);
   }
   return(ret);
}

void KillAllArgs(ATL_arg_t *ap)
{
   while(ap)
      ap = KillArg(ap);
}

ATL_arg_t *CombineArgs(ATL_arg_t *a1, ATL_arg_t *a2)
/*
 * RETURNS: one argument that cats the two args together, separated by a space
 */
{
   ATL_arg_t *np;
   int l1, l2, len;
   assert(a1 && a2);
   assert(a1->arg && a2->arg);
   l1 = a1->len;
   l2 = a2->len;
   len = l1 + l2 + 1;
   np = malloc(sizeof(ATL_arg_t));
   assert(np);
   np->arg = malloc(len);
   assert(np->arg);
   np->len = len;
   strcpy(np->arg, a1->arg);
   np->arg[l1] = ' ';
   strcpy(np->arg+l1+1, a2->arg);
   np->nespc = a1->nespc + a2->nespc + 1;
   np->next = NULL;
   return(np);
}

ATL_arg_t *CombAndKill(ATL_arg_t *ap, char *str)
/*
 * Cats string to argument in ap.
 */
{
   ATL_arg_t *np, *tp;

   tp = NewArg(str);
   np = CombineArgs(ap, tp);
   np->next = NULL;
   KillArg(ap);
   return(np);
}

int FindTotLen(ATL_arg_t *ap)
/*
 * Finds total length of all arguments, including enclosing "" for args with
 * embedded spaces and space added to end to seperate with next flag
 */
{
   int len = 0;
   while (ap)
   {
      len += ap->len + 1;
      if (ap->nespc > 0)
         len += 2;
      ap = ap->next;
   }
   return(len);
}

int FindMaxLen(ATL_arg_t *ap)
/*
 * Finds max length of any arg, including enclosing "" for args with
 * embedded spaces
 */
{
   int maxlen = 0;
   while (ap)
   {
      int len;
      len = ap->len;
      if (ap->nespc > 0)
         len += 2;
      maxlen = (maxlen >= len) ? maxlen : len;
      ap = ap->next;
   }
   return(maxlen);
}

int PrintArgToStr(ATL_arg_t *ap, char *str)
/*
 * Prints ap->arg to str, RETURNS: # of characters printed
 */
{
   int i;

   if (ap->nespc > 0)
      i = sprintf(str, "\"%s\" ", ap->arg);
   else
      i = sprintf(str, "%s ", ap->arg);
   return(i);
}

int PrintAllArgsToStr(ATL_arg_t *ab, char *str)
/*
 * Prints all arguments in ab to str, RETURNS: # of characters printed
 * Args with embedded spaces are placed in quotes (kept as 1 arg)
 */
{
   int i=0;

   while (ab)
   {
      if (ab->nespc > 0)
         i += sprintf(str+i, "\"%s\" ", ab->arg);
      else
         i += sprintf(str+i, "%s ", ab->arg);
      ab = ab->next;
   }
   return(i);
}

int PrintAllArgsToStrNoQuote(ATL_arg_t *ab, char *str)
/*
 * Prints all arguments in ab to str, RETURNS: # of characters printed
 * Args with embedded spaces not quoted (allowed to be mult commandline args)
 */
{
   int i=0;

   while (ab)
   {
      i += sprintf(str+i, "%s ", ab->arg);
      ab = ab->next;
   }
   return(i);
}

char *ArgsToStrNQ(ATL_arg_t *ab, ATL_arg_t *ab1)
{
   char *sp;
   int i0, i1, i;

   i0 = FindTotLen(ab);
   i1 = FindTotLen(ab1);
   sp = malloc(i0+i1+1);
   assert(sp);
   i = PrintAllArgsToStrNoQuote(ab, sp);
   assert(i <= i0);
   i += PrintAllArgsToStrNoQuote(ab1, sp+i);
   assert(i <= i0+i1);
   return(sp);
}
@ROUT fkoc
#define FKO_DOCMP 0
#define FKO_DOASM 1
#define FKO_SVTMP 2
char *ParseCompFlags(int nargs, char **args, int *FLAG, ATL_arg_t **files,
                     ATL_arg_t **PP, ATL_arg_t **CMP, ATL_arg_t **ASM)
{
   int i, nfiles=0, DOCMP=1, DOASM=1, SVTMP=0, flg, k;
   ATL_arg_t *ppb, *pp, *cmpb, *cp, *asmb, *ap, *filb;
   char *sp, *ks;
   char *outnm=NULL;
/*
 * Go through compiler flags and separate them into flags affecting
 * preprocessing, compilation, and assembling
 */
   ppb = pp = NewArg(MYPP);
   cmpb = cp = NewArg(MYFKO);
   asmb = ap = NewArg(MYASM);
   filb = NULL;
   for (i=1; i < nargs; i++)
   {
      ATL_arg_t *at;
      at = NewArg(args[i]);
      if (at->arg[0] != '-')  /* file name or arg to flag */
      {
         flg = 1;  /* by default assume flag */
         if (at->len > 2 && at->arg[at->len-2] == '.') /* poss filename */
         {
            char ch = at->arg[at->len-1];
            if (ch == 's' || ch == 'B' || ch == 'b')
            {
               flg = 0;
               at->next = filb;
               filb = at;
            }
         }
         if (flg)
         {
            cp->next = at;
            cp = cp->next;
         }
      }
      else if (at->len == 4 && at->arg[0] == '-' && at->arg[1] == 'm' &&
               ((at->arg[2] == '6' && at->arg[3] == '4') || 
                (at->arg[2] == '3' && at->arg[3] == '2')))
      {  /* -m32/-m64 is passed to assembler, but not fko */
         ap->next = at;
         ap = ap->next;
      }
      else /* if (at->arg[0] == '-')  */ 
      {
         switch (at->arg[1])
         {
/*
 *       FKO has -I that means start from intermediate files, but fkoc can't
 *       use this option.  Instead, this is assumed to be cpp include 
 *       directories, and thus ignored by fkoc
 */
         case 'I' : 
            if (at->len == 2) /* path in next arg */
               assert(++i < nargs);
            KillArg(at);
            break;
         case 'o' :  /* -o : found name of output file */
            if (outnm)
               free(outnm);
/*
 *          If this is just -o, then actual name is given in the next arg
 */
            if (at->len == 2)
            {
               assert(++i < nargs);
               sp = args[i];
            }
            else
            {
               sp = at->arg + 2;
               while (*sp && isspace(*sp)) 
                  sp++;
            }
            flg = strlen(sp);
            outnm = malloc(flg+1);
            assert(outnm);
            strcpy(outnm, sp);
            KillArg(at);
            break;
         case 's' : /* possible -save-temps */
            if (at->len == 11 && !strcmp(at->arg, "-save-temps"))
            {
               SVTMP = 1;
               KillArg(at);
            }
            else /* fko flag */
            {
               cp->next = at;
               cp = cp->next;
            }
            break;
         case 'D' :  /* -Dhan=def or -D han=def are extract arg */
            if (at->len == 2)  /* next arg has definition */
            {
               assert(++i < nargs);
               sp = args[i];
            }
            else  /* is -Dhan=def */
               sp = at->arg + 2;
            for (k=0; sp[k] && sp[k] != '='; k++);  /* find = */
            pp->next = NewArg("-def");
            pp = pp->next;
            pp->next = NewArg(sp);
            pp = pp->next;
            if (sp[k] == '\0') /* if no = in def, define it to 1 */
            {
               pp->next = NewArg("1");
               pp = pp->next;
            }
            else
               pp->arg[k] = ' ';  /* change = to space */
            KillArg(at);
            break;
         case '@' : /* -@ args go only to preprocessor (extract)  */
            if (at->len == 2) /* next arg has extract command */
            {
               assert(++i < nargs);
               sp = args[i];
            }
            else  /* rest of line has extract command */
               sp = at->arg+2;
/*
 *          If extract command surrounded by '' or "", remove quotes
 */
            if (*sp == '\"' || *sp == '\'')
            {
               char q=*sp;
               int k;
               k = strlen(sp+1);
               assert(q == sp[k]);
               ks = malloc(k+1);
               assert(ks);
               strcpy(ks, sp+1);
               ks[k-1] = '\0';
               sp = ks;
            }
            else
               ks = NULL;
            pp->next = NewArg(sp);
            pp = pp->next;
            KillArg(at);
            if (ks)
               free(ks);
            break;
         case 'S' :  /* I only use -x asg-with-cpp, so pass to comp only */
            if (at->len == 2) /* -S alone means emit assembly, not object */
            {
               DOASM = 0;
               KillArg(at);
            }
            else  /* otherwise, must be an fko flag */
            {
               cp->next = at;
               cp = cp->next;
            }
            break;
         case 'E' :  /* I only use -x asg-with-cpp, so pass to comp only */
            if (at->len == 2) /* -E alone means emit assembly, not object */
            {
               DOCMP = 0;
               KillArg(at);
            }
            else  /* otherwise, must be an fko flag */
            {
               cp->next = at;
               cp = cp->next;
            }
            break;
         case 'c' :      /* -c is flag meaning same thing as default */
            KillArg(at); /* so don't remember seeing it, and continue */
            break;   
         default:  /* fko flag */
@beginskip
            flg = 1;  /* by default, say it's a flag */
            if (at->arg[0] != '-' && at->len > 2 &&
                at->arg[at->len-2] == '.')           /* possible filename */
            {
               char ch = at->arg[at->len-1];
               if (ch == 's' || ch == 'B' || ch == 'b')
               {
                  flg = 0;
                  at->next = filb;
                  filb = at;
               }
            }
            if (flg)
            {
@endskip
            cp->next = at;
            cp = cp->next;
@skip            }
         }
      }
   }
   if (!filb)
   {
      fprintf(stderr, "%s: no files specified!\n\n", args[0]);
      exit(1);
   }
   *FLAG = (DOASM<<FKO_DOASM) | (DOCMP<<FKO_DOCMP) | (SVTMP<<FKO_SVTMP);
   *files = filb;
   *CMP = cmpb;
   *ASM = asmb;
   *PP = ppb;
   if (outnm && filb->next)  /* must use particular output name */
   {                         /* can only have one file when renaming! */
      fprintf(stderr, "%s: can't use -o for multiple source files!\n", 
              args[0]);
      exit(2);
   }
   return(outnm);
}

char GetNextFileExt(ATL_arg_t *ap)
{
   int i = ap->len - 1;
   char ch = ap->arg[i];
   assert(ap->arg[i-1] == '.');
   if (ch == 'B')
      return('b');
   else if (ch == 'b')
      return('s');
   else if (ch == 's')
      return('o');
   return(0);
}

char *FindNameInPath(char *ptnm)
/*
 * RETURNS: ptr in ptnm one past last '/'
 */
{
   int i, isl=0;
   for (i=0; ptnm[i]; i++)
      if (ptnm[i] == '/')
         isl = i+1;
   return(ptnm+isl);
}

@beginskip
char *NewNameWithPath(char *ptnm, char *nam)
/*
 * RETURNS: new string with nam substuted for filename at end of path
 *          of ptnm.  ptnm is untouched.
 */
{
   int l0, l1;
   char *new;

   assert(nam && ptnm);
   l0 = strlen(ptnm);
   l1 =  strlen(nam);
   assert(l0);
   for (l0--, l0 && ptnm[l0] != '/'; l0--); /* find end of path */
   new = malloc(l0+l1+1);
   assert(new);
   strncpy(new, ptnm, l0);
   strcpy(new+l0, nam);
   return(new);
}
@endskip
char *GetOutFileName(ATL_arg_t *ap, char extc)
{
   char *sp, *fn;
   int i;

   sp = FindNameInPath(ap->arg);  /* ignore path of input file */
   i = strlen(sp);
   assert(i > 2);         /* must end in .[B,b,S] */
   fn = malloc(i+1);
   assert(fn);
   i -= 2;               /* get past [.B,b,S] */
   assert(sp[i] == '.'); /* must be '.' for proper fkoc file extension */
   strncpy(fn, sp, i+1);   /* copy everything except extension */
   fn[i+1] = extc;
   fn[i+2] = '\0';
   return(fn);
}
/*
 * ap->arg should be a file name that ends in ".[B,b,s]".  We will create
 * a temporary file that has the same name plus a random integer (in hex),
 * with file extension ".<extc>", and open the new file, returning the
 * stream in *FPOUT.
 * NOTE: like tmpnam, not completely safe!  In particular, imagine two
 *       instances of fkoc running at same time, with same input file
 *       name.  Both could use same integer, and get same proposed filename.
 *       then both processes check that no such file exists, see that it
 *       does not, and then both do an fopen, which only one of them "wins".
 *       To minimize likelihood of this happening, we to fopen immediately
 *       after checking, and use a random integer rather than a count.
 */
char *GetTempFile(ATL_arg_t *ap, FILE **FPOUT, char extc)
{
   FILE *fp;
   char *fn, *sp;
   int i, cnt;
   char ch;

   sp = FindNameInPath(ap->arg);  /* ignore path of input file */
   i = strlen(sp);
   assert(i > 2);         /* must end in .[B,b,S] */
   fn = malloc(i+9);
   assert(fn);
   i -= 2;               /* get past [.B,b,S] */
   assert(sp[i] == '.'); /* must be '.' for proper fkoc file extension */
   strncpy(fn, sp, i);   /* copy everything except .[B,b,s] */
   ch = sp[i+1];
   if (ch != 'B' && ch != 'b' && ch != 's')
   {
      printf("UNKNOWN FILE EXTENSION: '%c' (FILE='%s')\n", ch, ap->arg);
      exit(10);
   }
   sp = fn+i;
   cnt = 0;
   do
   {
      int k;
      k = rand();
      cnt++;
      sprintf(sp, "%8.8x.%c", k, extc);
      fp = fopen(fn, "r");
      if (fp)            /* if file already exists */
      {
         fclose(fp);
         fp = NULL;      /* try again with different integer */
      }
      else
         fp = fopen(fn, "w");
   }
   while(!fp && cnt < 10000);
   assert(fp);
   *FPOUT = fp;
   return(fn);
}

int main(int narg, char **args)
{
   int flag, DOCOMP, DOASM, SVTMP;
   ATL_arg_t *fileb, *ppb, *cmpb, *asmb, *fp, *inf;
   char *outnm;

   outnm = ParseCompFlags(narg, args, &flag, &fileb, &ppb, &cmpb, &asmb);
   printf("flag=%x\n", flag);
   DOCOMP = flag & (1<<FKO_DOCMP);
   DOASM = flag & (1<<FKO_DOASM);
   SVTMP = flag & (1<<FKO_SVTMP);
   for (fp=fileb; fp; fp = fp->next)
   {
      char extc, *bf=NULL, *sf=NULL, *of=NULL, *pf=NULL;
      FILE *fpout;
      extc = GetNextFileExt(fp);
      pf = fp->arg;
      if (extc == 'b')
      {
         char *sp;
         ATL_arg_t *at;

         at = NewArg("-b");
         at->next = NewArg(fp->arg);
         at->next->next = NewArg("-o");
         pf = bf = GetTempFile(fp, &fpout, extc);
         at->next->next->next = NewArg(bf);
         sp = ArgsToStrNQ(ppb, at);
         printf("BPP='%s'\n", sp);
         assert(!system(sp));
         free(sp);
         KillAllArgs(at);
         fclose(fpout);
         if (!DOCOMP)  /* if this is final stage */
         {
            if (outnm)
            {
               if (rename(bf, outnm))
               {
                  fprintf(stderr, "Can't rename '%s' to '%s'!\n", 
                          bf, outnm);
                  exit(-1);
               }
               free(outnm);
            }
            else  /* final stage w/o renaming gets orig filename .b */
            {
               sp = GetOutFileName(fp, 'b');
               assert(!rename(bf, sp));
               free(sp);
            }
            free(bf);
            continue;
         }
         else
            extc = 's';
      }
      if (extc == 's')
      {
         char *sp;
         ATL_arg_t *at;

         at = NewArg(pf);
         at->next = NewArg("-o");
         if (!DOASM)  /* this is final stage */
         {
            if (outnm)
               sp = outnm;
            else 
               sp = GetOutFileName(fp, 's');
            fpout = fopen(sp, "w");
            at->next->next = NewArg(sp);
            free(sp);
         }
         else
         {
            pf = sf = GetTempFile(fp, &fpout, extc);
            at->next->next = NewArg(sf);
         }
         sp = ArgsToStrNQ(cmpb, at);
         printf("FKO='%s'\n", sp);
         assert(!system(sp));
         free(sp);
         KillAllArgs(at);
         fclose(fpout);
         if (bf)
         {
            if (!SVTMP)
               assert(!remove(bf));  /* delete temporary file */
            free(bf);
         }
         if (!DOASM)  /* if this is final stage */
            continue;
         extc = 'o';
      }
      if (extc == 'o')
      {
         char *sp;
         ATL_arg_t *at;

         at = NewArg(pf);
         if (outnm)
            sp = outnm;
         else 
            sp = GetOutFileName(fp, 'o');
         at->next = NewArg("-c -o");
         at->next->next = NewArg(sp);
         free(sp);
         sp = ArgsToStrNQ(asmb, at);
         KillAllArgs(at);
         printf("ASM='%s'\n", sp);
         assert(!system(sp));
         free(sp);
         if (pf != fp->arg)
         {
            assert(!remove(pf));
            free(pf);
         }
      }
   }
   KillAllArgs(ppb);
   KillAllArgs(cmpb);
   KillAllArgs(asmb);
   KillAllArgs(fileb);
   return(0);
}

@ROUT gnuccw gnuf90w gcc3p
char *ParseCompFlags(int nargs, char **args, int *BITS, ATL_arg_t **files,
                     ATL_arg_t **CMP, ATL_arg_t **ASM, ATL_arg_t **LNK,
                     int *CPPONLY)
{
   int i, nfiles=0, DOASM=1, DOLNK=1;
   ATL_arg_t *cmpb, *cp, *asmb, *ap, *lnkb, *lp, *filb, *fp, *an;
   char *outn=NULL;
   *CPPONLY = 0;
/*
 * Go through compiler flags and separate them into flags affecting
 * compilation, assembling, and linking
 */
   cmpb = cp = NewArg(MYGCC);
   asmb = ap = NewArg(MYASM);
   lnkb = lp = NewArg(MYLNK);
   filb = NULL;
   for (i=1; i < nargs; i++)
   {
      ATL_arg_t *at;
      at = NewArg(args[i]);
      if (at->arg[0] == '-')  /* flag */
      {
         switch (at->arg[1])
         {
         case 'o' :  /* -o : found name of output file */
/*
 *          If this is just -o, then actual name is given in the next arg
 */
            if (at->len == 2)
            {
               assert(++i < nargs);
               outn = args[i];
            }
/*
 *          is of form -o<name>
 */
            else
               outn = args[i]+2;
            break;
         case 'L' : /* -L/l args go only to linker  */
         case 'l' :
            if (at->len == 2)
            {
               assert(++i < nargs);
               lp->next = at;
               lp = at->next = NewArg(args[i]);
            }
            else
            {
               lp->next = at;
               lp = at;
            }
            break;
         case 'x' :  /* I only use -x asg-with-cpp, so pass to comp only */
            *CPPONLY = 1;
            cp->next = at;
            assert(++i < nargs);
            assert(!strcmp(args[i], "assembler-with-cpp"));
            cp = at->next = NewArg(args[i]);
            break;
         case 'c' :
            DOLNK = 0;
            break;
         case 'S' :
            DOASM = DOLNK = 0;
            break;
         case 'E':
         case 'X':
         case 'T':
         case 'u':
            fprintf(stderr, "FLAG '-%c' NOT HANDLED, DYING\n", at->arg[1]);
            assert(0); /* not implemented at moment */
         case 'W': /* possible linker/assembler pass-thru */
           if (at->len > 3)
           {
              if (at->arg[2] == 'a' && at->arg[3] == ',') /* asm pass-thru */
              {
@ROUT gcc3p 
                 strcpy(at->arg, at->arg+4);
                 at->len -= 4;
@ROUT gnuccw gnuf90w gcc3p
                 ap->next = at;
                 ap = at;
              }
              else if (at->arg[2] == 'l' && at->arg[3] == ',') /* lnk pass */
              {
@ROUT gcc3p 
@skip                 strcpy(at->arg, at->arg+4);
@skip                 at->len -= 4;
@ROUT gnuccw gnuf90w gcc3p
                 lp->next = at;
                 lp = at;
              }
           }
           /* else fall-thru to default */
         default:  /* everything else assumed to be a compiler-only flag */
/*
 *          In default, compare against all known linker options
 */
            if ( (at->len == 13 && !strcmp(at->arg, "-nostartfiles")) ||
                 (at->len == 14 && !strcmp(at->arg, "-nodefaultlibs")) ||
                 (at->len == 9 && !strcmp(at->arg, "-nostdlib")) ||
                 (at->len == 4 && !strcmp(at->arg, "-pie")) ||
                 (at->len == 9 && !strcmp(at->arg, "-rdynamic")) ||
                 (at->len == 2 && at->arg[1] == 's') ||
                 (at->len == 7 && !strcmp(at->arg, "-static")) ||
                 (at->len == 14 && !strcmp(at->arg, "-static-libgcc")) ||
                 (at->len == 9 && !strcmp(at->arg, "-symbolic"))
               )
            {
               lp->next = at;
               lp = at;
            }
            else if (at->len == 8 && !strcmp(at->arg, "-Xlinker"))
            {
               assert(++i < nargs);
@skip @ROUT gcc3p 
@skip               lp->next = NewArg(args[i]);
@ROUT gnuccw gnuf90w gcc3p
               lp->next = at;
               lp = at->next = NewArg(args[i]);
@ROUT gnuccw gnuf90w gcc3p
            }
            else if (at->len == 11 && !strcmp(at->arg, "-Xassembler"))
            {
               assert(++i < nargs);
@ROUT gcc3p 
              ap->next = NewArg(args[i]);
@ROUT gnuccw gnuf90w
               ap->next = at;
               ap = at->next = NewArg(args[i]);
@ROUT gnuccw gnuf90w gcc3p
            }
/*
 *          -m64/32 args get passed to comp, asm & linker
 */
            else if (at->len == 4 && 
                     (!strcmp(at->arg, "-m64") || !strcmp(at->arg, "-mx32") ||
                      !strcmp(at->arg, "-m32")))
            {
@ROUT gcc3p
               if (at->arg[2] == '6')
               {
                  ap->next = NewArg("--64");
                  *BITS = 64;
               }
               else
               {
                  ap->next = NewArg("--32");
                  *BITS = 32;
               }
@ROUT gcc3p
               lp->next = DupArg(at);
               lp = lp->next;
@ROUT gnuccw gnuf90w
               if (at->arg[2] == '6')
                  *BITS = 64;
               else 
                  *BITS = 32;
               lp->next = DupArg(at);
               lp = lp->next;
               ap->next = DupArg(at);
               ap = ap->next;
@ROUT gnuccw gnuf90w gcc3p
               cp->next = at;
               cp = at;
            }
            else if (at->len == 9 && !strcmp(at->arg, "--version"))
            {
               char *sp;
               int i;
               i = strlen(MYGCC);
               sp = malloc(i + 12);
               strcpy(sp, MYGCC);
               strcpy(sp+i, " --version");
               system(sp);
               free(sp);
               #ifdef DEBUG
                  fclose(fplog);
               #endif
               exit(0);  /* ugly uncleaned-up exit; live with it */
            }
            else
            {
               cp->next = at;
               cp = at;
            }
         }
      }
@skip      if (at->arg[0] != '-')  /* must be filename */
      else  /* anything not beginning with - must be a filename */
      {
         char ch;
@ROUT gnuf90w `         int F90=0;`
         int len = at->len;

         assert(len > 2);
         ch = at->arg[len-1];
         nfiles++;
@ROUT gnuf90w
         if (at->arg[len-2] == '.') /* .f or .F */
            assert(ch == 'f' || ch == 'F' || ch == 'o' || ch == 'a');
         else  /* .f90 */
         {
            F90 = 1;
            ch = at->arg[len-3];
            assert(len > 4)
            assert(at->arg[len-4] == '.' && 
                   (ch == 'f' || ch == 'F') ||
                   (at->arg[len-2] == '9'));
         }
@ROUT gnuccw gcc3p
         assert(at->arg[len-2] == '.' && 
            (ch == 'c' || ch == 'S' || ch == 's' || ch == 'o' || ch == 'a'));
@ROUT gnuccw gnuf90w gcc3p
/*
 *       If it isn't already an object file, add it to list of files to be
 *       renamed during compilation
 */
         if (ch != 'o' && ch != 'a')
         {
            if (!filb)
               filb = fp = at;
            else
            {
               fp->next = at;
               fp = at;
            }
/*
 *          Put empty node in linker options to indicate where to put in the 
 *          generated file names
 */
            lp->next = NewArg(NULL);
            lp = lp->next;
         }
/*
 *       If it is a object/archive file, just add it to link line and forget it
 */
         else
         {
            lp->next = NewArg(at->arg);
            lp = lp->next;
         }
/*
 *       If the file is already an object file, add it to linker
 */
@beginskip
/*
 *       Put file on link line with language extension replaced by ".o"
 */
         lp->next = NewArg(at->arg);
         lp = lp->next;
@ROUT gnuccw gcc3p
         lp->arg[len-1] = 'o';
@ROUT gnuf90w
         if (!F90)
            lp->arg[len-1] = 'o';
         else
         {
            lp->arg[len-3] = 'o';
            lp->arg[len-2] = '\0';
            lp->len = len - 2;
         }
@ROUT gnuccw gnuf90w gcc3p
@endskip
      }
   }
   if (outn)  /* must use particular output name */
   {
      ATL_arg_t *tp;
      tp = (DOLNK) ? lp : ap;
      tp->next = NewArg("-o");
      tp->next->next = NewArg(outn);
      tp = tp->next->next;
   }
   if (outn && !DOLNK)
      assert(nfiles == 1);
   else
      assert(nfiles > 0);
/*
 * If there are no files in filb, that means nothing need be compiled, so
 * the only thing we are doing is linking
 */
   if (!filb)
   {
      assert(DOLNK);
      if (cmpb)
         KillAllArgs(cmpb);
      if (asmb)
         KillAllArgs(asmb);
      *CMP = NULL;
      *ASM = NULL;
   }
   else
   {
      *CMP = cmpb;
      if (DOASM)
         *ASM = asmb;
      else
      {
         *ASM = NULL;
         KillAllArgs(asmb);
      }
   }
   if (DOLNK)
      *LNK = lnkb;
   else
   {
      *LNK = NULL;
      KillAllArgs(lnkb);
   }
   *files = filb;
   return(outn);
}

#ifdef DEBUG
void PrintFlags(int nargs, char **args)
{
   int i;

   fprintf(fplog, "\nINPUT:\n");
   for (i=0; i < nargs; i++)
      fprintf(fplog, "%s ", args[i]);
   fprintf(fplog, "\n");
   fflush(fplog);
}
#endif

char *GetDefObjNam(char *infile)
/*
 * When -c is specified, output file should be same as infile but w/o path
 */
{
   int ib, ie, len;
   char *sp;

   ie = strlen(infile);
   for (ib=ie-1; ib >=0 && infile[ib] != '/'; ib--);
   ib++;
   len = ie-ib;
   sp = malloc(len+1);
   assert(sp);
   strcpy(sp, infile+ib);
/*
 * Substitute .o for any 1 letter extension (eg: .c,.f,.s, etc)
 */
   if (sp[len-2] == '.')
      sp[len-1] = 'o';
@ROUT gnuf90w
   else if (sp[len-4] == '.')  /* 3 letter extension (.f90) */
   {
      sp[len-3] = 'o';
      sp[len-2] = '\0';
   }
@ROUT gnuccw gnuf90w gcc3p
   return(sp);
}

int main(int nargs, char **args)
{
   ATL_arg_t *cmpb, *asmb, *lnkb, *filb, *ap, *rmb=NULL, *rp;
   int bits, lcmp, lasm, llnk, lfil, i, lout=0, CPPONLY;
   char *cmps, *asms, *lnks, *outn;
   #ifdef DEBUG
      fplog = fopen("ATL_CCWRAP.log", "w");
      PrintFlags(nargs, args);
   #endif

   outn = ParseCompFlags(nargs, args, &bits, &filb, &cmpb, &asmb, &lnkb,
                         &CPPONLY);
   if (outn)
      lout = strlen(outn);
/*
 * Now, compile each file to the standard name ATL_tmp#.s using gcc -S
 */
   if (cmpb)
   {
      rp = rmb = NewArg("rm");
      lcmp = FindTotLen(cmpb);
      lfil = FindMaxLen(filb);
      cmps = malloc(lcmp + lfil + 32);
      assert(cmps);
      i = PrintAllArgsToStr(cmpb, cmps);
      if (i != lcmp)
      {
         fprintf(stderr, "ERROR: lcmp=%d, i=%d, strlen=%d, str='%s'\n", 
                 lcmp, i, (int)strlen(cmps), cmps);
         #ifdef DEBUG
            fprintf(fplog, "ERROR: lcmp=%d, i=%d, strlen=%d, str='%s'\n", 
                    lcmp, i, (int)strlen(cmps), cmps);
            fflush(fplog);
         #endif
         assert(i == lcmp);
      }
      for (i=0,ap=filb; ap; i++, ap = ap->next)
      {
         int k;
         char tmpnam[16];
         sprintf(tmpnam, "ATL_tmp%d.[s,o]", i);
         rp->next = NewArg(tmpnam);
         rp = rp->next;
         if (ap->arg[ap->len-1] == 'S' || CPPONLY)
            k = lcmp + sprintf(cmps+lcmp, "-E -o ATL_tmp%d.s ", i);
         else
            k = lcmp + sprintf(cmps+lcmp, "-S -o ATL_tmp%d.s ", i);
         PrintArgToStr(ap, cmps+k);
         #ifdef DEBUG
            fprintf(fplog, "COMP: %s\n", cmps);
            fflush(fplog);
         #endif
         assert(!system(cmps));
      }
      KillAllArgs(cmpb);
      free(cmps);
/*
 *    If we aren't linking and we have only one file with a specified name,
 *    assemble the .s file to the specified .o file
 */
      lasm = FindTotLen(asmb);
      cmps = malloc(lasm + lfil + 64);
      assert(cmps);
      i = PrintAllArgsToStr(asmb, cmps);
      assert(i == lasm);
      if (!lnkb && !filb->next)
      {
         int k;
         char *sp;
         if (outn)
            sp = outn;
         else
            sp = GetDefObjNam(filb->arg);
@ROUT gcc3p
   /* still need to add arch+isaext flag */
         k = lasm + sprintf(cmps+lasm, "ATL_tmp0.s -o %s", sp);
@ROUT gnuccw gnuf90w
         k = lasm + sprintf(cmps+lasm, "-c ATL_tmp0.s");
         if (sp != outn)
            sprintf(cmps+k, " -o %s", sp);
@ROUT gnuccw gnuf90w gcc3p
         #ifdef DEBUG
            fprintf(fplog, "ASSEMBLE: %s\n", cmps);
         #endif
         k = system(cmps);
         KillAllArgs(filb);
         KillAllArgs(asmb);
         free(cmps);
         if (sp != outn)
            free(sp);
         return(k);
      }
/*
 *    Now assemble every .s into a .o
 */
      for (i=0,ap=filb; ap; i++, ap = ap->next)
      {
         int k;
@skip @ROUT gcc3p
@skip         k = lasm + sprintf(cmps+lasm, "ATL_tmp%d.s -o ATL_tmp%d.o", i, i);
@ROUT gnuccw gnuf90w gcc3p
         k = lasm + sprintf(cmps+lasm, "-c ATL_tmp%d.s -o ATL_tmp%d.o", i, i);
@ROUT gnuccw gnuf90w gcc3p
         #ifdef DEBUG
            fprintf(fplog, "ASSEMBLE: %s\n", cmps);
            fflush(fplog);
         #endif
         assert(!system(cmps));
      }
      KillAllArgs(asmb);
      free(cmps);
   }
/*
 * Now issue link line
 */
   if (lnkb)
   {
/*
 *    Put files back into link line in the order in which they were found
 *    NULL-arg nodes are placeholders for the names.
 */
      for (i=0,ap=filb; ap; i++,ap = ap->next)
      {
         ATL_arg_t *tp;
         for (tp=lnkb; tp && tp->arg; tp = tp->next);
         assert(tp);
         tp->arg = malloc(16);
         assert(tp->arg);
         tp->len = sprintf(tp->arg, "ATL_tmp%d.o", i);
      }
      llnk = FindTotLen(lnkb);
      cmps = malloc(llnk + 1);
      assert(cmps);
      i = PrintAllArgsToStr(lnkb, cmps);
      assert(i == llnk);
      #ifdef DEBUG
         fprintf(fplog, "LINK: '%s'\n", cmps);
         fflush(fplog);
      #endif
      assert(!system(cmps));
      KillAllArgs(lnkb);
      free(cmps);
   }
   KillAllArgs(filb);
/*
 * Now delete the temporary files that we have created
 */
   i = FindTotLen(rmb);
   cmps = malloc(i + 1);
   assert(cmps);
   assert(i == PrintAllArgsToStr(rmb, cmps));
   KillAllArgs(rmb);
   printf("%s\n", cmps);
   system(cmps);
   free(cmps);

   #ifdef DEBUG
      system("cat ATL_CCWRAP.log");
      fclose(fplog);
   #endif
   return(0);
}
@ROUT GetArchDefs
void PrintUsage(char *name, int iarg, char *arg)
{
   fprintf(stderr, "\nERROR around arg %d (%s).\n", iarg,
           arg ? arg : "unknown");
   fprintf(stderr, 
      "USAGE: %s [flags] where flags are ($ vars from Make.inc):\n", name);
   fprintf("   -A $ARCH \n");
   fprintf("   -A $ARCH \n");

}
int GetFlags(int nargs, char **args, char *ASRCD, char *ADSTD, char *MACH, 
             int FLAG)
{
   char *srcd=NULL, *dstd=NULL, *mach=NULL;
   for (i=1; i < nargs; i++)
   {
      if (args[i][0] != '-')
         PrintUsage(args[0], i, args[i]);
   }
}

int main(int nargs, char **args)
{
   int np, flag;
   char *asrcd, *adstd, *mach;
   np = GetFlags(nargs, args, &asrcd, &adstd, &mach, &flag);
}
