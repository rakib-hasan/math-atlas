@ROUT cpuid.S
#include "atlas_asm.h"
        .text
        .globl ATL_asmdecor(do_cpuid)
ATL_asmdecor(do_cpuid):
#
#                rdi        rsi
# void cpuid(int *out, int what);
# NOTE: cpuid overwrites eax, ebx, ecx, and edx, takes eax as input
#       -- save ebx
#
#ifdef ATL_GAS_x8664
        movq    %rbx, -8(%rsp)
#
#       Load input reg, and call cpuid
#
        movl    %esi, %eax
        cpuid
#  
#       Load address of output array, and fill in its entries
#
        movl    %eax, (%rdi)
        movl    %ebx, 4(%rdi)
        movl    %ecx, 8(%rdi)
        movl    %edx, 12(%rdi)

        movq    -8(%rsp), %rbx
        ret
 #else
# 
#       Prologue
#
        subl    $8, %esp
        movl    %ebx, (%esp)
        movl    %edi, 4(%esp)
#
#       Load input reg, and call cpuid
#
        movl    16(%esp), %eax
        cpuid
#  
#       Load address of output array, and fill in its entries
#
        movl    12(%esp), %edi
        movl    %eax, (%edi)
        movl    %ebx, 4(%edi)
        movl    %ecx, 8(%edi)
        movl    %edx, 12(%edi)
#
#       Epilogue
#
        movl    (%esp), %ebx
        movl    4(%esp), %edi
        addl    $8, %esp
        ret
#endif
@ROUT archinfo_x86
@extract -b @(topd)/gen.inc what=cw -def cdate 2006 -def contrib "Dean Gaudet" -def author "R. Clint Whaley"
/*
 * This code written for ATLAS use by R. Clint Whaley based on code and info
 * submitted by Dean Gaudet, with the later help of the following websites:
 *   http://www.sandpile.org/ia32/cpuid.htm
 *   http://en.wikipedia.org/wiki/CPUID
 */

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "atlconf.h"

#define uint unsigned int

/*
 * This routine returns the contents of registers set by the cpuid instruction
 * in the array res:
 *   res[0] : eax
 *   res[1] : ebx
 *   res[2] : ecx
 *   res[3] : edx
 */
void do_cpuid(uint *res, uint level);
/* result defines */
#define EAX 0
#define EBX 1
#define ECX 2
#define EDX 3


/* My driver, based on Dean's */
int ProbeArch(char *vendor, unsigned *family, unsigned *model, int *x86_64)
/*
 * Returns 0 on success, non-zero on error
 */
{
   uint r[4];
   uint max_level;
   uint *vp = (uint*) vendor;

   *x86_64 = 0;
/*
 * In this call, we ask for max supported cpuid support, and return if
 * we can't get any usuable info.  Also sets ebx,edx and ecx (16 chars of data)
 * to vendor ID string
 */
   do_cpuid(r, 0);
   max_level = r[EAX];
   if (!max_level)
      return(1);
/*
 * Copy vendor string as 3 ints rather than 16 char, then null-term at 12
 */
   *vp = r[EBX];
   vp[1] = r[EDX];
   vp[2] = r[ECX];
   vendor[12] = '\0';

/*
 * Find processor family and model, ouput EAX
 * According to latest docs, extended family and model should always be
 * added in, not just in the cases shown in the commented-out if statements
 * below.  The original "only do it in certain cases" was from the official
 * IA32 ISA, but doing this causes problems on Xeons, so now we do like the
 * newer docs indicate and always add the extended values in 
 */
   do_cpuid(r, 1);
   *family = (r[EAX] >> 8) & 0xf;      /* base family in bits 11-8 */
/*   if (*family == 0xf || *family == 0) */ /* extended family is added in */
       *family += ((r[EAX] >> 20) & 0xff);

   *model = (r[0] >> 4) & 0xf;         /* model in bits 7-4 */
/* if (*model == 0xf) */               /* extended model is concatenated */
      *model |= ((r[0] >> 12) & 0xf0);

/* 
 * Find out if we have extended cpuid level, and if so, see if we've got
 * x86-64 capability or not
 */
   do_cpuid(r, 0x80000000);
   if (r[0] >= 0x80000001)
   {
      do_cpuid(r, 0x80000001);
      *x86_64 = (r[EDX] & (1<<29)) != 0;   /* x86-64 in bit 29 */
   }
   return(0);
}

/*
 * constants used to check family + extended family
 */
#define EF_486       4        /* also AMD 5x86 and Cyrix 5x86 */
#define EF_P5        5        /* P5, K5 and K6 */
#define EF_P6        6        /* P6, Core and K7 (athlon) */
#define EF_ITAN0     7        /* Itanium */
#define EF_K8_P4_EFF 0x00F    /* P4, Hammer, Efficien */
#define EF_K8_ITAN   0x01F    /* Hammer, Itanium */
#define EF_K8        0x02F    /* Hammer */
#define EF_ITAN      0x020    /* Itanium */
#define EF_K8b      16        /* 3rd gen opteron */
#define EF_k1om     11
#define EF_K15h     21        /* AMD K15 (eg, bulldozer, piledriver, etc.) */

enum FAM {ERR,         /* cannot decipher */
          i486,        /* 486 & AMD 5x86 and Cyrix 5x86 */
          P5,          /* Original Pentium and AMD K5 & K6 */
          P6,          /* Intel PIII, Core and AMD K7 (orig athlon) */
          P7,          /* Intel P4, AMD hammer, Efficeon */
          P8B,         /* 3rd generation hammer */
          K15h,        /* AMD K15 */
          k1om,        /* XeonPHI */
          ITAN};       /* Intel Itanium */

enum FAM GetFamily(int efam)  /* efam = (family+ext fam) from cpuid */
/*
 * Translates CPUID (family+extended family) to FAM enum type
 */
{
   enum FAM iret;
   switch (efam)
   {
   case EF_486:               /* also AMD 5x86 and Cyrix 5x86 */
      iret = i486;
      break;
   case EF_P5:                /* P5, K5 and K6 */
      iret = P5;
      break;
   case EF_P6:                /* P6, Core and K7 (athlon) */
      iret = P6;
      break;
   case EF_K8_P4_EFF:         /* P4, Hammer, Efficien */
      iret = P7;
      break;
   case EF_K15h:
      iret = K15h;
      break;
   case EF_K8_ITAN:           /* Hammer, Itanium */
   case EF_K8:                /* Hammer */
      iret = P7;
      break;
   case EF_K8b:
      iret = P8B;
      break;
   case EF_ITAN:              /* Itanium */
   case EF_ITAN0:             /* Itanium */
      iret = ITAN;
      break;
   case EF_k1om:
      iret = k1om;
      break;
   default:
      iret = ERR;
   }
   return (iret);
}

enum VEND {VERR, Intel, AMD, TM};
enum VEND str2vend(char *vendor)
/*
 * Translates vendor string to enum type
 */
{
   enum VEND iret;
   if (strstr(vendor, "GenuineIntel") != NULL)
      iret = Intel;
   else if (strstr(vendor, "AuthenticAMD") != NULL)
      iret = AMD;
   else if (strstr(vendor, "GenuineTMx86") != NULL)
      iret = TM;
   else
      iret = VERR;
   return(iret);
}

/*
 * Specific chip (family, but disambiguated using vendor string 
 */
enum CHIP {CERR, Pentium, IntP6, Pentium4, Itanium, K7, Hammer, HammerB,
           AMDK15h, Crusoe, Efficeon, K1om};

enum CHIP Family2Chip(char *vendor, enum FAM family)
/*
 * Disambiguates family based on vendor string
 */
{
   enum CHIP iret=CERR;
   enum VEND ivend;
   
/*
 * Figure out the vendor
 */
   ivend = str2vend(vendor);
   if (ivend == VERR)
      return(CERR);

   switch(family)
   {
   case   i486:        /* 486 & AMD 5x86 and Cyrix 5x86; unsupported */
      break;
   case   P5:          /* Original Pentium and AMD K5 & K6 */
      if (ivend == Intel)
         iret = Pentium;
      break;
   case   P6:          /* Intel PIII, Core and AMD K7 (orig athlon) */
      if (ivend == Intel)
         iret = IntP6;
      else if (ivend == AMD)
         iret = K7;
      else if (ivend == TM)
         iret = Crusoe;
      break;
   case   P7:          /* Intel P4, AMD hammer, Efficeon */
      if (ivend == Intel)
         iret = Pentium4;
      else if (ivend == AMD)
         iret = Hammer;
      else if (ivend == TM)
         iret = Efficeon;
      break;
   case P8B:
      if (ivend == AMD)
         iret = HammerB;
      break;
   case K15h:
      iret = AMDK15h;
      break;
   case k1om:
      iret = K1om;
      break;
   case   ITAN:        /* Intel Itanium */
      iret = Itanium;
      break;
   default:
      iret = CERR;
   }
   return(iret);
}

enum MACHTYPE Chip2Mach(enum CHIP chip, int model, int x8664)
/*
 * translates chip and cpuid's model to config's machine enum
 */
{
   enum MACHTYPE iret=MACHOther;
   const int extmodel = (model & 0xFFFFFFF0) >> 4,
             lowmodel = model & 0x0000000F;

   switch(chip)
   {
   case AMDK15h:
      iret = MACHOther;
      if (model == 1)
         iret = AmdDozer;
      else if (model == 2)
         iret = AmdDriver;
      break;
   case Pentium:
      switch(model)
      {
      case 1:
         iret = IntP5;
         break;
      case 4:
      case 8:
         iret = IntP5MMX;
         break;
      default:
         iret = MACHOther;
      }
      break;
   case IntP6:  /* includes PPRO, PII, PIII, Core and Pentium-M */
      switch(model)
      {
      case 0:
      case 1:
         iret = IntPPRO;
         break;
      case 3:
      case 5:
      case 6:
         iret = IntPII;
         break;
      case 7:
      case 8:
      case 10:
      case 11:
         iret = IntPIII;
         break;
      case  9:
      case 13:
         iret = IntPM;
         break;
      case 14:
         iret = IntCoreDuo;
         break;
      case 15:
      case 23: 
      case 29:
         iret = IntCore2;
         break;
      case 0x1C:
         iret = IntAtom;
         break;
      case 0x1A:
      case 0x1E:
      case 0x1F:
      case 0x25:
      case 0x2C:
      case 0x2E:
         iret = IntCorei1;
         break;
      case 0x2D:
      case 0x3A:
      case 0x2A:
      case 0x3E:  
         iret = IntCorei2;
	 break;
      case 0x45:
      case 0x3C:
         iret = IntCorei3;
         break;
      case 0x3F:  /* 63 */
         iret = IntCorei3EP;
         break;
      default:
         iret = MACHOther;
      }
      break;
   case Pentium4:
      switch(model)
      {
      case 0:
      case 1:
      case 2:
         iret = IntP4;
         break;
      case 3:
      case 4:
      case 6:
         iret = IntP4E;
         break;
      default:
         iret = MACHOther;
      }
      break;
   case Itanium:
      switch(model)
      {
      case 7:
         iret = IA64Itan;
         break;
      case 0x1F:
         iret = IA64Itan2;
         break;
      default:
         iret = MACHOther;
      }
      break;
   case K7:
      switch(model)
      {
      case 4:
      case 6:
      case 8:
      case 10:
         iret = AmdAthlon;
         break;
      default:
         iret = MACHOther;
      }
      break;
   case Hammer:
      iret = AmdHammer;
      break;
   case HammerB:
      iret = Amd64K10h;
      break;
   case Efficeon:
      iret = TMEff;
      break;
   case K1om:
      iret = IntPhi;
      break;
   case Crusoe:  /* unsupported */
   default:
      iret = MACHOther;
   }
   return(iret);
}

@ROUT archinfo_x86 arch_getflags
void PrintUsage(char *name, int i)
{
   fprintf(stderr, "USAGE: %s -v (verb) -b (@ bits) -a (arch) -n (ncpu) -c <ncache> -C <lvl> (cache size) -m (Mhz) -t (cpu throttling) -P (cpu clusters)\n", name);
   exit(i);
}

int GetFlags(int nargs, char **args, int *CacheLevel)
{
   int i, flag = 0;

   *CacheLevel = 0;
   for (i=1; i < nargs; i++)
   {
      if (args[i][0] != '-') PrintUsage(args[0], i);
      switch(args[i][1])
      {
      case 'n':
         flag |= Pncpu;
         break;
      case 'c':
         flag |= Pncache;
         break;
      case 'C':
         if (++i > nargs)
            PrintUsage(args[0], i);
         *CacheLevel = atoi(args[i]);
         break;
      case 'v':
         flag |= Pverb;
         break;
      case 'm':
         flag |= PMhz;
         break;
      case 'a':
         flag |= Parch;
         break;
      case 'b':
         flag |= P64;
         break;
      case 't':
         flag |= Pthrottle;
         break;
      case 'P':
         flag |= Pcluster;
         break;
      default:
         PrintUsage(args[0], i);
      }
   }
   if (!flag)
     flag = Parch | P64;
   return(flag);
}
@ROUT arch_getflags
   @endextract
@ROUT archinfo_x86 arch_getflags

main(int nargs, char **args)
{
   int ierr, x86_64, flags, CacheLevel;
   unsigned family, model;
   char *cpu="UNKNOWN", vendor[13];
   enum FAM fam;
   enum CHIP chip;
   enum MACHTYPE mach;

   flags = GetFlags(nargs, args, &CacheLevel);
   cpu = NULL;
   vendor[0] = '\0';
   ierr = ProbeArch(vendor, &family, &model, &x86_64);
/*
 * If ProbeArch worked, translate vendor+family+model to ATLAS config-name
 */
   if (!ierr)
   {
       fam = GetFamily(family);
       if (fam)
       {
          chip = Family2Chip(vendor, fam);
          if (chip)
          {
             mach = Chip2Mach(chip, model, x86_64);
             if (!mach) ierr = 300;
          }
          else ierr = 200;
       }
       else ierr = 100;
   }
   if (ierr)
   {
      fprintf(stderr, "ERROR: enum fam=%d, chip=%d, model=%d, mach=%d\n", 
              fam, chip, model, mach);
      printf("ERROR %d: vendor='%s', family=%d, model=%d, x86_64=%d\n",
             ierr, vendor, family, model, x86_64);
   }
   else
   {
/*
 *    If verbatim set, print strings as well as enums
 */
      if (flags & Parch)
      {
         if (flags & Pverb)
            printf("cpu: %s\n", machnam[mach]);
         printf("MACHTYPE=%d\n", mach);
      }
      if (flags & P64)
         printf("PTR BITS=%d\n", x86_64 ? 64 : 32);
/*
 *    Not sure how to detect this.  cpuid has some features that might work,
 *    will need to experiment later
 */
      if (flags & Pthrottle)
         printf("CPU THROTTLE=0\n");
/*
 *    These guys can't be supported by cpuid, AFAIK
 */
      if ((flags & PMhz) || (flags & Pncpu))
         printf("Mhz/ncpu=0\n");
/*
 *    Cache info could be returned, but I'm lazy, so don't
 */
      if ((flags & Pncache) || (flags & PCacheSize))
         printf("ncache/CacheSize=0\n");
      if ((flags & (~Pverb)) == 0)
         printf("family=%d, model=%d, cpu='%s', Ptr bits=%d, arch#=%d\n",
                family, model, machnam[mach], x86_64?64:32, mach);
   }
   exit(ierr);
}
@ROUT archinfo_linux archinfo_freebsd archinfo_sunos archinfo_irix @\
      archinfo_aix archinfo_SFU archinfo_win
#include "atlconf.h"
@ROUT archinfo_win `#include <windows.h>`

@extract -b @(basd)/atlarch.base rout=arch_getflags

@ROUT archinfo_SFU archinfo_win
enum MACHTYPE ProbeArch()
/*
 * This function should never be needed under windows, because archinfo_x86
 * should determine this for us;  May want to change this so it actually
 * builds & calls archinfo_x86 at some point.
 */
{
   return(MACHOther);
}
@ROUT archinfo_linux archinfo_freebsd archinfo_sunos archinfo_irix archinfo_aix
enum MACHTYPE ProbeArch()
{
   enum ARCHFAM fam;
   enum MACHTYPE mach=MACHOther;
   int ierr, i;
   char *res;

   fam = ProbeArchFam(NULL);
   switch(fam)
   {
@ROUT archinfo_sunos
   case AFSPARC:
      res = atlsys_1L(NULL, "/usr/sbin/psrinfo -pv | fgrep UltraSPARC", 0, 0);
      if (res)
      {
         if (strstr(res, "UltraSPARC-IV"))
            mach = SunUSIV;
         else if (strstr(res, "UltraSPARC-T2"))
            mach = SunUST2;
         else if (strstr(res, "UltraSPARC-III"))
            mach = SunUSIII;
         else if (strstr(res, "UltraSPARC-II"))
            mach = SunUSII;
         else if (strstr(res, "UltraSPARC-I"))
            mach = SunUSI;
         free(res);
      }
/*
 *    sparcv9 could be UltraSPARC I,II, III or IV.  Only USIII/IV run faster
 *    than 650Mhz (AFAIK), and as far as ATLAS is concerned, USIII & IV are
 *    same processor; so declare anything with Mhz > 700 as an USIII.  Newer
 *    chips should have the newer psrinfo used above, which allows more
 *    precise determination anyway.  Actually, USIII redesign happened at
 *    1050Mhz, so I should probably call anything Mhz > 1040 an USIV, but
 *    I assume most USIV will have the newer SunOS/psrinfo above, so declare
 *    anything using this to be USIII, to minimize user confusion.
 */
      else if (res=atlsys_1L(NULL, "/usr/sbin/psrinfo -v | fgrep sparcv9", 0,0))
      {
         free(res);
         mach = SunUSX;
         res = atlsys_1L(NULL,  "/usr/sbin/psrinfo -v | fgrep MHz", 0, 0);
         if (res)
         {
            i = GetIntBeforeWord("MHz", res);
            if (i != BADINT && i > 700) mach = SunUSIII;
            free(res);
         }
         else if (res=atlsys_1L(NULL, "/usr/sbin/psrinfo -v | fgrep GHz", 0, 0))
         {
            mach = SunUSIII;
            free(res);
         }
      }
      break;
@ROUT archinfo_aix
   case AFPPC: /* don't know */
      res = atlsys_1L(NULL, "/usr/sbin/prtconf | fgrep 'Processor Type'", 0, 0);
      if (res)
      {
         if (strstr(res, "PowerPC_POWER5"))
            mach = IbmPwr5;
         else if (strstr(res, "PowerPC_POWER7"))
            mach = IbmPwr7;
         else if (strstr(res, "PowerPC_POWER8"))
            mach = IbmPwr8;
         else if (strstr(res, "PowerPC_POWER6"))
            mach = IbmPwr6;
         else if (strstr(res, "PowerPC_POWER4"))
            mach = IbmPwr4;
         free(res);
      }
      break;
@ROUT archinfo_freebsd
   case AFPPC: /* don't know */
      res = atlsys_1L(NULL, "sysctl hw.model", 0, 0);
      if (res)
      {
         if (strstr(res, "PowerMac"))
         {
            if (strstr(res,"c1,2")||strstr(res,"c3,1")||strstr(res,"c3,2")|| 
                strstr(res,"c3,3")||strstr(res,"c3,4")||strstr(res,"c3,5")|| 
                strstr(res,"c3,6")||strstr(res,"c4,2")||strstr(res,"c4,5")||
                strstr(res,"c5,1")||strstr(res,"c10,1"))
               mach = PPCG4;
            else if (strstr(res,"c11,2")|| strstr(res,"c12,1")||
                     strstr(res,"c7,2") || strstr(res,"c7,3") || 
                     strstr(res,"c8,1") || strstr(res,"c8,1") ||
                     strstr(res,"c8,2") || strstr(res,"c9,1"))
               mach = PPCG5;
         }
         else if (strstr(res, "PowerBook"))
         {
            if (strstr(res,"k3,2") || strstr(res,"k3,3") || strstr(res,"k3,4")||
                strstr(res,"k3,5") || strstr(res,"k5,1") || strstr(res,"k5,2")||
                strstr(res,"k5,3") || strstr(res,"k5,4") || strstr(res,"k5,5")||
                strstr(res,"k5,6") || strstr(res,"k5,7") || strstr(res,"k5,8")||
                strstr(res,"k5,9") || strstr(res,"k6,1") || strstr(res,"k6,2")||
                strstr(res,"k6,3") || strstr(res,"k6,4") || strstr(res,"k6,5")||
                strstr(res,"k6,7") || strstr(res,"k6,8"))
               mach = PPCG4;
         }
         else if (strstr(res, "RackMac"))
         {
            if (strstr(res, "c1,1") || strstr(res, "c1,2"))
               mach = PPCG4;
            else if (strstr(res, "c3,1"))
               mach = PPCG5;
         }
         free(res);
      }
      break;
   case AFSPARC: /* don't know */
      break;
   case AFALPHA:
      #if 0
      res = atlsys_1L(NULL, "sysctl hw.model", 0, 0);
      if (res)
      {
         if (strstr(res, "433au")) mach = Dec21164;
         else if (strstr(res, "XP1000")) mach = Dec21264;
         free(res);
      }
      #endif
      break;
   case AFIA64: /* don't know */
      break;
   case AFX86:
      res = atlsys_1L(NULL, "sysctl hw.model", 0, 0);
      if (res)
      {
         if (strstr(res, "Pentium Pro")) mach = IntPPRO;
         else if (strstr(res, "Pentium III")) mach = IntPIII;
         else if (strstr(res, "Pentium II ")) mach = IntPII;
         else if (strstr(res, "Athlon")) mach = AmdAthlon;
         else if (strstr(res, "AMD-K7")) mach = AmdAthlon;
         else if (strstr(res, "32 bit Hammer")) mach = AmdHammer;
         else if (strstr(res, "64 bit Hammer")) mach = AmdHammer;
         else if (strstr(res, "Pentium/P55C")) mach = IntP5MMX; /* sent by */
         else if (strstr(res, "Pentium")) mach=IntP5;       /* Nakata Maho */
         else if (strstr(res, "iMac4,1")) mach=IntCoreDuo;
         free(res);
      }
      break;
   default:;
@ROUT archinfo_irix
   case AFIA64:
      res = atlsys_1L(NULL, "hinv -c processor | fgrep 'Itanium'", 0, 0);
      if (res) 
      {
         if (res[0] != '\0')
         {
            if (strstr(res, "Itanium 2")) mach = IA64Itan2;
            else if (strstr(res, "Itanium")) mach = IA64Itan;
         }
         free(res);
      }
      break;
   case AFMIPS:
      res = atlsys_1L(NULL, "hinv -c processor | fgrep 'CPU'", 0, 0);
      if (!ierr && res[0] != '\0')
      {
         if (res[0] != '\0')
         {
            if (strstr(res, "R12000") || strstr(res, "R10000") ||
                strstr(res, "R14000") || strstr(res, "R16000"))
               mach = MIPSR1xK;
         }
         free(res);
      }
      break;
@ROUT archinfo_linux
   case AFPPC:
      res = atlsys_1L(NULL, "cat /proc/cpuinfo | fgrep cpu", 0, 0);
      if (res)
      {
#if 0
         if (strstr(res, "604e")) mach = PPC604e;
         else if (strstr(res, "604")) mach = PPC604;
         else
#endif
         if (strstr(res, "G4")) mach = PPCG4;
         else if (strstr(res, "7400")) mach = PPCG4;
         else if (strstr(res, "7410")) mach = PPCG4;
         else if (strstr(res, "7447")) mach = PPCG4;
         else if (strstr(res, "7455")) mach = PPCG4;
         else if (strstr(res, "PPC970FX")) mach = PPCG5;
         else if (strstr(res, "PPC970MP")) mach = PPCG5;
         else if (strstr(res, "POWER8")) mach = IbmPwr8;
         else if (strstr(res, "POWER7")) mach = IbmPwr7;
         else if (strstr(res, "POWER6")) mach = IbmPwr6;
         else if (strstr(res, "POWER5")) mach = IbmPwr5;
         else if (strstr(res, "POWER4")) mach = IbmPwr4;
         else if (strstr(res, "e6500")) mach = Pwre6500;
         free(res);
      }
      break;
   case AFMIPS:
      res = atlsys_1L(NULL, "fgrep 'cpu model' /proc/cpuinfo", 0, 0);
      if (res)
      {
         if (res[0] != '\0')
         {
            if (strstr(res, "ICE9"))
               mach = MIPSICE9;
/*
 *          I have no access to what cpuinfo on Linux does for this procs, 
 *          so this is a WAG as to what it would say
 */
            else if (strstr(res, "R10000") || strstr(res, "R12000") ||
                     strstr(res, "R12000") || strstr(res, "R14000"))
               mach = MIPSR1xK;
         }
         free(res);
      }
      break;
   case AFARM:
      res = atlsys_1L(NULL, "fgrep 'Processor' /proc/cpuinfo", 0, 0);
      if (res)
      {
         if (strstr(res, "ARMv7") || strstr(res,"v7l")) mach = ARMv7;
         else if (strstr(res, "AArch64")) mach = ARM64;
         free(res);
      }
      else if ( res=atlsys_1L(NULL, "fgrep cpu /proc/cpuinfo", 0, 0) )
      {
         if (strstr(res, "ARMv7") || strstr(res,"v7l")) mach = ARMv7;
         else if (strstr(res, "AArch64")) mach = ARM64;
         free(res);
      }
      break;
   case AFIA64:
      res = atlsys_1L(NULL, "fgrep 'Itanium' /proc/cpuinfo", 0, 0);
      if (res && res[0] == '\0')
      {
         free(res);
         res = NULL;
      }
      if (!res)
         res = atlsys_1L(NULL, "fgrep \"model name\" /proc/cpuinfo", 0, 0);
      if (res)
      {
         if (res[0] != '\0')
         {
            if (strstr(res, "Itanium 2") || strstr(res, "McKinley")) 
               mach = IA64Itan2;
            else if (strstr(res, "Itanium")) mach = IA64Itan;
         }
         free(res);
      }
      break;
   case AFX86:
      res = atlsys_1L(NULL, "fgrep 'model name' /proc/cpuinfo", 0, 0);
      if (res && res[0] == '\0')
      {
         free(res);
         res = NULL;
      }
      if (!res)
         res = atlsys_1L(NULL, "fgrep model /proc/cpuinfo", 0, 0);
      if (res && res[0] == '\0')
      {
         free(res);
         res = NULL;
      }
      if (res)
      {
         if (strstr(res, "Pentium"))
         { /* Pentium of some flavor */
            if (strstr(res, " III ")) mach = IntPIII;
            else if (strstr(res, " II ")) mach = IntPII;
            else if (strstr(res, "Pro")) mach = IntPPRO;
            else if (strstr(res, "MMX")) mach = IntP5MMX;
            else if (strstr(res, " 4 "))
            {
               char *rs2;
               rs2 = atlsys_1L(NULL, 
                      "fgrep 'model' /proc/cpuinfo | fgrep -v 'name'", 0, 0);
               if (rs2)
               {
                  i = GetLastInt(res);
                  if (i < 3) mach = IntP4;
                  else if (i == 3) mach = IntP4E;
                  free(rs2);
               }
            }
         }
         else if (strstr(res, "Atom"))
            mach = IntAtom;
         else if (strstr(res, "Core"))
         {
            if (strstr(res, "i7")) 
            {
               if (strstr(res, "4770") || strstr(res, "4765"))
                  mach = IntCorei3;
               else if (strstr(res, "2600") || strstr(res, "3770"))
                  mach = IntCorei2;
               else
                  mach = IntCorei1;
            }
            if (strstr(res, "i5")) 
            {
               if (strstr(res, "4670") || strstr(res, "4570") ||
                   strstr(res, "4430"))
                  mach = IntCorei3;
               else if (strstr(res, "i5-2500") || strstr(res, "i5-2400") || 
	           strstr(res, "i5-2390") || strstr(res, "i5-2300"))
                  mach = IntCorei2;
               else
                  mach = IntCorei1;
            }
         }
         else if (strstr(res, "Xeon")) /* dreaded Xeon-is-anything */
         {
            if (strstr(res, "E5420")) mach = IntCore2;
            else if (strstr(res, "X7560")) mach = IntCorei1;
         }
         else if (strstr(res, "A8-3850"))
            mach = AmdLlano;
         else if (strstr(res, "Efficeon")) mach = TMEff;
         else if (strstr(res, "Athlon HX")) mach = AmdHammer;
         else if (strstr(res, "Opteron") || strstr(res, "Hammer") ||
                  strstr(res, "Athlon(tm) 64"))
            mach = AmdHammer;
         else if (strstr(res, "Athlon")) mach = AmdAthlon;
         else if (strstr(res, "AMD-K7")) mach = AmdAthlon;
         free(res);
      }
      break;
/*
 *    Add these back if we get machine access and can test
 */
   case AFSPARC:  /* don't know here anymore */
      res = atlsys_1L(NULL, "fgrep cpu /proc/cpuinfo", 0, 0);
      if (res)
      {
         if (strstr(res, "UltraSparc IV")) mach = SunUSIV;
         else if (strstr(res, "UltraSparc III")) mach = SunUSIII;
         else if (strstr(res, "UltraSparc II")) mach = SunUSII;
         else if (strstr(res, "UltraSparc I")) mach = SunUSI;
         else if (strstr(res, "UltraSparc")) mach = SunUSX;
         free(res);
      }
      break;
   case AFALPHA:
      #if 0
      res[0] = '\0';
      ierr = CmndOneLine(NULL, "fgrep 'model name' /proc/cpuinfo", res);
      if (ierr || res[0] == '\0')
         ierr = CmndOneLine(NULL, "fgrep model /proc/cpuinfo", res);
      if (!ierr && res[0] != '\0')
      {
         if (strstr(res, "EV5")) mach = Dec21164;
         else if (strstr(res, "EV4")) mach = Dec21064;
         else if (strstr(res, "EV6")) mach = Dec21264;
      }
      #endif
      break;
   case AFS390:
      res = atlsys_1L(NULL, "cat /proc/cpuinfo | fgrep \"processor \"", 0, 0);
      if (res)
      {
         if (strstr(res, "2094") || strstr(res, "2096")) mach = IbmZ9;
         else if (strstr(res, "2097") || strstr(res, "2098")) mach = IbmZ10;
         /* we consider anything else to be a z196 or later */
         else mach = IbmZ196;  /* looks risky to me, but IBM folks did it */
         free(res);
      }
      break;
   default:
#if 0
      if (!CmndOneLine(NULL, "fgrep 'cpu family' /proc/cpuinfo", res))
         if (strstr(res, "PA-RISC 2.0")) mach = HPPA20;
#else
     ;
#endif
@ROUT archinfo_linux archinfo_freebsd archinfo_sunos archinfo_irix archinfo_aix
   }
   return(mach);
}
@ROUT archinfo_win
int ProbeNCPU()
{
   SYSTEM_INFO sysinf;
   GetSystemInfo(&sysinf);
   return(sysinf.dwNumberOfProcessors);
}
@ROUT archinfo_SFU
int ProbeNCPU()
/*
 * This code provided by Vishwanathan S.V.N.
 */
{
  struct cpuinfo_list cil;
  int ncpu = 0, ret;
  
  ret = ioctl(0, KIOCGCPU, &cil);

  assert(!ret);
  assert(cil.cpu[0] != NULL);
  
  while(cil.cpu[ncpu] != NULL)
    ncpu++;
  
  free(cil.cpu[0]);
  /* svnvish: BUGBUG
   * I am sure we are leaking memory here
   *free(cil);
   */
  return ncpu;
  
}
@ROUT archinfo_linux archinfo_freebsd archinfo_sunos archinfo_irix archinfo_aix
int ProbeNCPU()
{
   int ncpu = 0;
   char *res;
   
@ROUT archinfo_aix
   res = atlsys_1L(NULL, "/usr/sbin/prtconf | fgrep 'Number Of Processors'",
                   0, 0);
   if (res)
   {
      ncpu = GetLastInt(res);
      free(res);
   }
@ROUT archinfo_freebsd
   res = atlsys_1L(NULL, "sysctl hw.ncpu", 0, 0);
   if (res) 
   {
      ncpu = GetLastInt(res);
      free(res);
   }
@ROUT archinfo_sunos
   res = atlsys_1L(NULL, "uname -X | fgrep NumCPU", 0, 0);
   if (res)
   {
      ncpu = GetFirstInt(res);
      free(res);
   }
   else if ((res=atlsys_1L(NULL, "/bin/uname -X | fgrep NumCPU", 0, 0)))
   {
      ncpu = GetFirstInt(res);
      free(res);
   }
@ROUT archinfo_irix
   res = atlsys_1L(NULL, 
                   "hinv -c processor | fgrep Processor | fgrep -v 'CPU:'", 
                   0, 0);
   if (res)
   {
      ncpu = GetFirstInt(res);
      free(res);
   }
@ROUT archinfo_linux
   #if 0
   if (mach == Dec21264 || mach == Dec21164 || mach == Dec21064)
   {
      if ( !CmndOneLine(NULL, "fgrep 'cpus detected' /proc/cpuinfo", res) )
         ncpu = GetLastInt(res);
   }
   #endif
   if (!ncpu)
   {
      FILE *fpres;
      int len=0;
      fpres = atlsys(NULL, "grep '^processor' /proc/cpuinfo", 0, 0);
      if (fpres)
      {
         for (ncpu=0; res = ATL_fgets(res, &len, fpres); ncpu++);
         fclose(fpres);
      }
   }
@ROUT archinfo_linux archinfo_freebsd archinfo_sunos archinfo_irix archinfo_aix
   return(ncpu);
}

@ROUT archinfo_linux archinfo_freebsd archinfo_sunos archinfo_irix @\
      archinfo_aix archinfo_sfu archinfo_win
int ProbePointerBits(int *sure)
{
   int i;
   char *uname;
   char *cmnd, *res;

   *sure = 0;
/*
 * This probe should be running on backend; if its ptr length is 8, we've
 * definitely got a 64 bit machine
 * NOTE: getting 4 could be a result of compiler flags on a 64-bit arch,
 * so reverse is not dispositive
 */
   if (sizeof(void*) == 8)
   {
      *sure = 1;
      return(64);
   }

@rout archinfo_aix
   res = atlsys_1L(NULL, "/usr/sbin/prtconf | fgrep 'Kernel Type'", 0, 0);
   if (res)
   {
      if (GetLastInt(res) == 64)
      {
         *sure = 1;
         free(res);
         return(64);
      }
      free(res);
   }
@ROUT archinfo_linux archinfo_freebsd archinfo_sunos archinfo_irix @\
      archinfo_aix archinfo_SFU archinfo_win
/*
 * Note this is a weak probe, archinfo_x86 much better . . .
 */
   uname = FindUname(NULL);
   i = strlen(uname) + 4;
   cmnd = malloc(sizeof(char)*i);
   assert(cmnd);
   sprintf(cmnd, "%s -a", uname);

   res = atlsys_1L(NULL, cmnd, 0, 0);
   free(cmnd);
   if (res)
   {
/*
 *    If uname is a known 64-bit platform, we're sure we've got OS support
 *    for 64bits (may not have compiler support, but that's not our fault)
 */
      if (strstr(res, "x86_64") || strstr(res, "ppc64") || strstr(res, "ia64"))
      {
         *sure = 1;
         free(res);
         return(64);
      }
      free(res);
   }
@ROUT archinfo_linux archinfo_freebsd archinfo_sunos archinfo_irix @\
      archinfo_aix archinfo_SFU archinfo_win
   return(32);
}

int ProbeMhz()
{
   int mhz=0;
   char *res;
@ROUT archinfo_win00   @SKIP not reliable for Mhz, gives timer res instead
   LARGE_INTEGER msout;
   unsigned long long freq;

   QueryPerformanceFrequency(&msout);
   freq = msout.HighPart;
   freq = (freq<<32) | msout.LowPart;
   freq /= 1000000;
   mhz = freq;
@ROUT archinfo_aix
   res = atlsys_1L(NULL, "/usr/sbin/prtconf | fgrep 'Processor Clock Speed'",
                   0, 0);
   if (res)
   {
      mhz = GetLastInt(res);  /* assumes clock speed always given in MHz */
      free(res);
   }
@ROUT archinfo_freebsd
   res = atlsys_1L(NULL, "sysctl hw.cpufrequency", 0, 0);
   if (res)
   {
      mhz = GetFirstDouble(res) / 1000000;
      free(res);
   }
@ROUT archinfo_linux archinfo_win
   res = atlsys_1L(NULL, "fgrep 'cpu MHz' /proc/cpuinfo", 0, 0);
   if (res)
   {
@skip      mhz = GetFirstInt(res);
      mhz = GetFirstDouble(res) + 0.5;
      free(res);
   }
   if (!mhz)
   {
      res = atlsys_1L(NULL, "cat /proc/cpuinfo | fgrep clock | fgrep MHz",0,0);
      if (res)
      {
@skip         mhz = GetLastInt(res);
         mhz = GetLastLongWithRound(res);
         free(res);
      }
   }
@ROUT archinfo_irix
   res = atlsys_1L(NULL, "hinv -c processor | fgrep MHz", 0, 0);
   if (res)
   {  /* Itanium's use MHz */
      mhz = GetIntBeforeWord("MHz", res);
      if (mhz == BADINT) mhz = 0;
      free(res);
   }
   if (!mhz)
   {
      res = atlsys_1L(NULL, "hinv -c processor | fgrep MHZ", 0, 0);
      if (res)
      {   /* MIPS uses MHZ */
         mhz = GetIntBeforeWord("MHZ", res);
         if (mhz == BADINT) mhz = 0;
         free(res);
      }
   }
   if (!mhz)
   {
      res = atlsys_1L(NULL, "hinv -c processor | fgrep GHz", 0, 0);
      if (res)
      {  /* Don't think MIPS will ever get here, nobody pres uses GHz */
         mhz = GetIntBeforeWord("GHz", res);
         mhz = (mhz == BADINT) ? 0 : mhz*1000;
         free(res);
      }
   }
@ROUT archinfo_sunos
   res = atlsys_1L(NULL, "/usr/sbin/psrinfo -v | fgrep MHz", 0, 0);
   if (res)
   {
      mhz = GetIntBeforeWord("MHz", res);
      if (mhz == BADINT) mhz = 0;
      free(res);
   }
   if (!mhz)
   {
      res = atlsys_1L(NULL, "/usr/sbin/psrinfo -v | fgrep GHz", 0, 0);
      if (res)
      {
         mhz = GetIntBeforeWord("GHz", res);
         mhz = (mhz == BADINT) ? 0 : mhz*1000;
         free(res);
      }
   }
@ROUT archinfo_SFU
   mhz=0;  /* don't know how do do this on interix */
@ROUT archinfo_linux archinfo_freebsd archinfo_sunos archinfo_irix @\
      archinfo_aix archinfo_SFU archinfo_win
   return(mhz);
}

int ProbeCluster()
/*
 * RETURNS: number of different CPU clusters found.
 */
{
   int iret=1;
@ROUT archinfo_sunos archinfo_irix archinfo_aix archinfo_SFU archinfo_win
/*
 * I have no idea how to do this for SunOS/Irix/AIX/Windows/interix
 */
@ROUT archinfo_freebsd archinfo_linux
   int imax=0;
   char *res;

@ROUT archinfo_linux
/*
 * For now, check for cpuinfo_max_freq for all CPUs.
 * If all are same, then there is only one cluster.
 */
   int ncpu = ProbeNCPU();
   int *freqs = malloc(sizeof(int)*ncpu);
   int i, j, ncluster = 0;
   char *frm = "cat /sys/devices/system/cpu/cpu%d/cpufreq/cpuinfo_max_freq";
   char fnam[256];
   for (i=0; i<ncpu; i++)
   {
      sprintf(fnam, frm, i);
      res = atlsys_1L(NULL, fnam, 0, 0);
      if (res)
      {
         imax = GetFirstInt(res);
         free(res);
         for (j=0; j<ncluster; j++)
         {
            if (freqs[j] == imax)
               break;
         }
         if (j == ncluster) /* loop was exhausted, so new cluster */
         {
            freqs[ncluster] = imax;
            ncluster++;
         }
      }
   }
   iret = ncluster;
@ROUT archinfo_freebsd
/*
 * Not implemented yet!
 */
@ROUT archinfo_freebsd archinfo_linux archinfo_sunos archinfo_irix @\
      archinfo_aix archinfo_SFU archinfo_win
   return(iret);
}

int ProbeThrottle()
/*
 * RETURNS: 1 if cpu throttling is detected, 0 otherwise
 */
{
   int iret=0;
@ROUT archinfo_sunos archinfo_irix archinfo_aix archinfo_SFU archinfo_win
/*
 * I have no idea how to do this for SunOS/Irix/AIX/Windows/interix
 */
@ROUT archinfo_freebsd archinfo_linux
   int imax=0, imin=0, icur=0;
   char *res;

@ROUT archinfo_linux   
/*
 * If cpufreq directory doesn't exist, guess no throttling.  If
 * cpufreq exists, and cur Mhz < max, throttling is enabled,
 * throttling also enabled if governer is not "performance", and min freq
 * is less than max
 */
   res = atlsys_1L(NULL, 
                   "cat /sys/devices/system/cpu/cpu0/cpufreq/cpuinfo_max_freq",
                   0, 0);
   if (res)
   {
      imax = GetFirstInt(res);
      free(res);
      res = atlsys_1L(NULL, 
            "cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_min_freq", 0, 0);
      assert(res);
      imin = GetFirstInt(res);
      free(res);
      res = atlsys_1L(NULL, 
            "cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_cur_freq", 0, 0);
      assert(res);
      icur = GetFirstInt(res);
      free(res);
      res = atlsys_1L(NULL, 
            "cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor", 0, 0);
      assert(res);
      if (icur < imax) 
         iret = 1;
      else if (!strstr(res, "performance") && imin < imax)
         iret = 1;
      free(res);
   }
@ROUT archinfo_freebsd 
   res = atlsys_1L(NULL, "sysctl hw.cpufrequency_max", 0, 0);
   if (res)
   {
      imax = GetFirstInt(res);
      free(res);
   }
   res = atlsys_1L(NULL, "sysctl hw.cpufrequency_min", 0, 0);
   if (res)
   {
      imin = GetFirstInt(res);
      free(res);
   }
   if (imax)
   {
      if (imax != imin)
         iret = 1;
   }
@ROUT archinfo_freebsd archinfo_linux archinfo_sunos archinfo_irix @\
      archinfo_aix archinfo_SFU archinfo_win
   return(iret);
}

main(int nargs, char **args)
{
   int flags, CacheLevel, ncpu, mhz, bits, sure;
   enum MACHTYPE arch=MACHOther;

   flags = GetFlags(nargs, args, &CacheLevel);
   if (flags & Parch)
   {
      arch = ProbeArch();
      if (flags & Pverb)
         printf("Architecture detected as %s.\n", machnam[arch]);
      printf("MACHTYPE=%d\n", arch);
   }
   if (flags & Pncpu)
      printf("NCPU=%d\n", ProbeNCPU());
   if (flags & PMhz)
      printf("CPU MHZ=%d\n", ProbeMhz());
   if (flags & Pthrottle)
      printf("CPU THROTTLE=%d\n", ProbeThrottle());
   if (flags & Pcluster)
      printf("CPU CLUSTER=%d\n", ProbeCluster());
   if (flags & P64)
   {
      bits = ProbePointerBits(&sure);
      printf("PTR BITS=%d, SURE=%d\n", bits, sure);
   }
      
/*
 * Here for future, presently unsupported
 */
   if (flags & Pncache)
      printf("NCACHES=0\n");
   if (flags & PCacheSize)
      printf("%d Cache size (kb) = 0\n", CacheLevel);
   exit(0);
}
