@define ip @0@
@ROUT smvcases.idx dmvcases.idx cmvcases.idx zmvcases.idx
#
# In this file, any line beginning with a '#' is ignored, but the # must be in
# column 0.  All multiple whitespace is reduced to one space (i.e. used only
# to distinguish where words begin/end).  Lines may be extended by putting '\'
# as the *last* character of line.
#
# The file has the following format:
# ROUT='routine name' AUTH='author names' COMP='compiler name' FLAGS='flags'
# ID=<id> NU=<nu> MU=<mu> minN=<#> minM=<#> alignX=<#> alignY=<#> alignA=<#>,
# TA='[t,n,c]' TB='[t,n,c]' SSE=[0,1,2,3] X87=[0,1] 
# LDTOP=[0,1] ALLALIGNXY=[0,1] AXPYBASED=[0,1] GEMMBASED=[0,1] CONJDEF=[0,1]
# ASM=[asmlist], eg., asmlist is "GAS_x8664,GAS_x8632" or "GAS_SPARC"
# ASM defaults to no assembly dialect required.
# If NU/MU is negative, then the routine can only handle multiples of NU/MU.
#
# Assuming N is the length of X, and M is the length of Y, all routines
# are assumed to handle any runtime value of M >= minN, N >= minM.
# They must respect the compile-time macros BETA0, BETA1, & BETAX.
# Some less-obvious keywords:
# LDTOP     : set to 1 if load Y at top of MV loop (more error)
# CONJDEF   : Defining Conj_ will cause A to be conjugated before use
#             if 0, then can only be used for TA setting
# ALLALIGNXY: Create k copies of X and Y, where k is the number of times
#             the native alignment goes into the required alignment.  So,
#             if ALIGNX=16, and we are doing single precision, X will be
#             passed as float *X[4], and X[0] will be 16-byte aligned,
#             X[1]: 4-byte aligned, X[2]: 8-byte aligned, X[3]: 12 byte aligned
#             if ALIGN[X/Y] == native length, then this flag has no effect on
#             that vector.
# AXPYBASED : Routine employs the outer-product matvec (mainly for NoTrans)
# GEMMBASED : Kernel calls GEMM to do matvec
# PFTUNEx   : Kernel uses pref_x(mem) macro for each op=x (A,y,x).  prefetch
#             inst can be varied wt this macro, as can fetch distance.
#
@ROUT cpread
#ifndef ATLAS_CPPARSE_H
   #define ATLAS_CPPARSE_H

#include "atlas_genparse.h"
#include "atlas_enum.h"

#define ATL_CPMAXGEN  6  /* maximum generated code */
#define ATL_CPMAXACCMAJ  4  /* max access-major copy */
#define ATL_CPMVECAB  1
#define ATL_CPMVECC   2
#define ATL_CPKVECAB  3
#define ATL_CPKVECC   4
#define ATL_CPBLKMJAB 5
#define ATL_CPBLKMJC  6

#define CPF_TOBLK    0  /* set: copy to blk format;  unset: opposite direc */
#define CPF_CBLK     1  /* set: C format;  unset:A/B */
#define CPF_ABLK     2  /* only used in old ammgen-style */
#define CPF_MVEC     3  /* 1: vectorize on M dim */
#define CPF_NVEC     4  /* 1: vectorize on N dim */
#define CPF_TRANS    5  /* 1: transpose, else NoTrans */
#define CPF_CONJ     6  /* 1: Conjugate, else NoConj */
#define CPF_SINGLE   7  /* 1: single, else double */
#define CPF_REAL     8  /* 1: real, else complex */
#define CPF_BE1      9
#define CPF_BEN     10
#define CPF_BEX     11
#define CPF_BE0     12
#define CPF_AL1     13
#define CPF_ALN     14
#define CPF_ALX     15
#define CPF_SYRK    16
#define CPF_SYMM    17
#define CPF_TRMM    18
#define CPF_TRSM    19
#define CPF_ASM     20 /* only set during gen */
#define CPF_TMP     21 /* always unset after use */

#define CPF_DEFAULT   0  /* default is no bits set */
#define CPF_ALLALP ((1<<CPF_AL1)|(1<<CPF_ALN)|(1<<CPF_ALX))
#define CPF_ALLBET ((1<<CPF_BE0)|(1<<CPF_BE1)|(1<<CPF_BEN)|(1<<CPF_BEX))
#define CPF_ALLKERN ((1<<CPF_SYRK)|(1<<CPF_SYMM)|(1<<CPF_TRMM)|(1<<CPF_TRSM))

typedef struct CPNode ATL_cpnode_t;
struct CPNode
{
   ATL_cpnode_t *next;
   char *auth, *comp, *cflags;
   char *rout;     /* callable routine name w/o alpha/beta suffix */
   char *genstr;   /* string that will generate, or NULL for hand-tuned */
   char *exflags;
   char *str;
   double mflop[4];
   int ID;         /* ID unique in <pre>copy.idx */
   int STGID;      /* storage ID predefined vals: [1-6] */
   int mu, nu;     /* unrolling for C-M&N, A-K&M, B-K&N */
   int mb, nb;     /* M/N dims to use for timing */
   int vlen;       /* > 1: vector length used in copy generation */
   int kvec;       /* > 1: vec with size kvec along K dim */
   int rtlen;      /* # of chars/bytes in rout */
   unsigned int flag, asmbits;
};
@ROUT mmread
#ifndef ATLAS_MMPARSE_H
   #define ATLAS_MMPARSE_H

#include "atlas_genparse.h"
#include "atlas_enum.h"
/*
 * BLAS kernel types that we've potentially got generators for
 */
#define ATL_KGEMM       0
#define ATL_KSYRK       1
#define ATL_KSYMM       2 /* not yet supported */
#define ATL_KTRMM       3 /* not yet supported */
#define ATL_KTRSM       4 /* only supported for non-generated case */
#define ATL_KGECPFA     5 /* TA trans setting, TB row/col matrix access */
#define ATL_KGECP2A     6 /* TA trans setting, TB row/col matrix access */
#define ATL_KGECPFC     7
#define ATL_KGECP2C     8
#define ATL_KSKCPFC     9 /* syrk C copy */
#define ATL_KSKCP2C    10 /* syrk C copy */
/*
 * Structure bit position in flag
 */
#define MMF_SINGLE      0  /* 1: single precision, else double */
#define MMF_COMPLEX     1  /* 1: complex type, else real */
#define MMF_LDCTOP      2  /* 1: load C before K-loop, 0: ld after */
#define MMF_KRUNTIME    3  /* 1: K dim is run-time variable? */
#define MMF_X87         4  /* 1: requires the Intel x87 unit */
#define MMF_AOUTER      5  /* 1: MNK loop order, 0: NMK loop order */
#define MMF_PFACOLS     6  /* 1: prefetch next mu cols of A */
#define MMF_PFABLK      7  /* 1: prefetch next KBxNB block of A */
#define MMF_PFBCOLS     8  /* 1: prefetch next nu cols of B */
#define MMF_PFCELTS     9  /* 1: pf elts of C at top of loop, load at bottom */
#define MMF_L14NB      10  /* 1: need to fit all 3 matrices+nextA in L1 */
#define MMF_MVA        11  /* 1: A expected to change between calls */
#define MMF_MVB        12  /* 1: B expected to change between calls */
#define MMF_MVC        13  /* 1: C expected to change between calls */
#define MMF_CPC        14  /* 1: copy out to col of C like rank-K */
#define MMF_KVEC       15  /* 1: vectorize on K-dim. 0: do not vec on K dim */
#define MMF_KUISKB     16  /* 1: only works for fully unrolled, constant K */
#define MMF_NOBCAST    17  /* 1: use ld/splat to get B, rather than bcast */
#define MMF_FKO        18  /* 1: compile using FKO, else [d,s]MC */
/*
 * Right now, NOBCAST overrides BREG1.  Could eventually make it so 
 * BREG1+NOBCAST means we do splat wt 0 dep distance, but not supported now
 */
#define MMF_BREG1      19  /* 1: use only 1 reg for B, else use NU */
#define MMF_KCLN       20  /* 1: cleaner for K dim is required */
#define MMF_ALLTRANS   21  /* 1: do C^T = B^T * A^T, not C=A*B */
#define MMF_MAXBIT     21
#define MMF_ALLPF ( (1<<MMF_PFACOLS)|(1<<MMF_PFABLK)|(1<<MMF_PFBCOLS) \
                    |(1<<MMF_PFCELTS) )
#define MMF_MVSET  ( (1<<MMF_MVA) | (1<<MMF_MVB) | (1<<MMF_MVC) | (1<<MMF_CPC) )
#define MMF_MVDEF  ( (1<<MMF_MVA) | (1<<MMF_MVB) )
#define MMF_DIFFMSK (~((1<<MMF_KCLN)|MMF_MVSET))
#define MMF_STKBTS (1<<MMF_KCLN)
#define MMF_DEFAULT ( (1<<MMF_LDCTOP) | (1<<MMF_AOUTER) | MMF_MVDEF )
#ifndef  FLAG_IS_SET
   #define FLAG_IS_SET(field_, bit_) ( ((field_) & (1<<(bit_))) != 0 )
#endif
#define ATL_MMF_MVGET(field_) (((field_) >> MMF_MVA) & 0xF)
#define ATL_MMF_MVPUT(field_, v_) \
   (field_) = ( ((field_) & ~MMF_MVSET) | (((v_) & 0xF) << MMF_MVA) )

typedef struct MMStg ATL_mmstg_t;
struct MMstg
{
   int extelts;
   short ID, flag;
   char *szfunc;
};

#define uchar unsigned char
#define uint  unsigned int
typedef struct MMNode ATL_mmnode_t;
struct MMNode
{
   ATL_mmnode_t *next;
   double mflop[8];             /* 1st entry perf using mbB, nbB, kbB */
   char *rout, *auth, *comp, *cflags;
   char *str;                   /* tmp string used in generation */
   char *genstr;                /* system(genstr) will generate gened kernel */
   char *exflags;               /* extra flags to pass test/time call */
   char *moves;                 /* -DMove[A,B,C] to use, NULL default */
   int ID, mu, nu, ku;          /* ID, and unrolling on each loop */
   int kbmin, kbmax;            /* min/max KB this kernel can handle */
   int SSE;                     /* 0: no SSE, 1: SSE1 req, 2: SSE2 req, etc */
   int vlen;                    /* vector length, 0 or 1 if scalar code */
@skip   int kmaj;                  /* k-major access storage? */
   int pref;                    /* pref strategy used */
   int pfLS;                    /* pref line size */
   int ivar;                    /* int param used for various purposes */
   int mbB, nbB, kbB;           /* best blocking dims found by search */
   int szA, szB, szC;           /* size in elts for block; 0: use normal */
   int szExtra;                 /* extra elts needed at end of alloc */
   int stgA, stgB, stgC;        /* storage ID, 0: access major */
   enum ATLAS_TRANS TA, TB;
   int asmbits;   /* bitfield indicating which assembly(ies) is required */
   uint flag;
   uchar blask;   /* 0:ammm, 1:syrk, 2:symm, 3:trmm */
};
#undef uchar
#undef uint

@ROUT r1read
#ifndef ATLAS_R1PARSE_H
   #define ATLAS_R1PARSE_H

#include "atlas_genparse.h"


#define R1F_INCACHE     0  /* consider kernel for in-cache gemv */
#define R1F_OUTCACHE    1  /* consider kernel for out-of-cache gemv */
#define R1F_ALLALIGNXY  2  /* X&Y are copied into all legal alignments */
#define R1F_ALIGNX2A    3  /* X forced to same alignment as A */
#define R1F_SINGLE      4  /* single precision */
#define R1F_COMPLEX     5  /* complex arithmetic */
#define R1F_APTRS       6  /* use ptrs rather than lda for column indexing */
#define R1F_X87         7  /* requires the Intel x87 unit */
#define R1F_FNU         8  /* N must be a multiple of NU */
#define R1F_ADDCFLAGS   9  /* don't replace: append cflags to default flags */
#define R1F_INCYISONE  10
#define R1F_NFLAGS     11
#define R1F_PFTUNABLE  14  /* Can tune PFDIST & INST? */
char *R1F_exp[R1F_NFLAGS] = 
{
"Consider kernel for in-cache use only",
"Consider kernel for out-of-cache use only",
"X&Y are copied into all legal alignments",
"X forced to have same alignment as A",
"Data uses single precision",
"Data is of complex type",
"use ptrs rather than lda for column indexing",
"Kernel requires the x87 unit for correct operation",
"N must be a multiple of NU"
};

#define R1F_DEFAULT ((1<<R1F_INCACHE) | (1<<R1F_OUTCACHE))
typedef struct R1NODE ATL_r1node_t;
struct R1NODE
{
   double mflop[8];
   ATL_r1node_t *next;
   char *rout;                  /* filename/path for kernel */
   char *auth;                  /* author of kernel */
   char *comp;                  /* particular compiler required for kernel */
   char *cflags;                /* compiler flags required for kernel */
   char *kname;                 /* The name kernel should be compiled to */
   char *str;                   /* tmp string used in generation */
   char *exflags;               /* extra flags to pass test/time call */
   char *genstr;                /* system(genstr) will generate gened kernel */
   int alignA, alignX, alignY;  /* required alignments */
   int ldamul;                  /* lda must be a multiple of ldamul */
   int ID, NU, MU;              /* unrolling for Y & X vectors */
   int NMU;                     /* # of repetitions of MU */
   int minN, minM;              /* min veclen to call the rout with */
   int SSE;                     /* 0: no SSE, 1: SSE1 req, 2: SSE2 req, etc */
   int asmbits;                 /* valid assemblies in this file */
   int CacheElts;               /* # of cache elts to assume for blocking */
   int rankR;                   /* restriction rank, higher faster kern */
   int flag;                    /* bit vector of R1F_* */
};

@ROUT mvread
#ifndef ATLAS_MVPARSE_H
   #define ATLAS_MVPARSE_H

#include "atlas_genparse.h"
#include "atlas_enum.h"

#define MVF_INCACHE     0  /* consider kernel for in-cache gemv */
#define MVF_OUTCACHE    1  /* consider kernel for out-of-cache gemv */
#define MVF_ALLALIGNXY  2  /* X&Y are copied into all legal alignments */
#define MVF_AXPYBASED   3  /* 0:ddot based, 1: axpy-based */
#define MVF_GEMMBASED   4  /* gemm-based */
#define MVF_LDYTOP      5  /* 0: load Y value after dot product */
#define MVF_CONJDEF     6  /* 1: conj(A) if Conj_ is defined */
#define MVF_X87         7  /* requires the Intel x87 unit */
#define MVF_FNU         8  /* Length of Y must be a multiple of NU */
#define MVF_SINGLE      9  /* 1: single precision, else double */
#define MVF_COMPLEX    10  /* 1: complex type, else real */
#define MVF_ADDCFLAGS  11  /* don't replace: append cflags to default flags */
#define MVF_ALIGNX2A   12  /* X (Y if AXPYBASED) forced to same alignmnt as A */
#define MVF_INCYISONE  13
#define MVF_PFTUNABLE  14  /* Can tune PFDIST & INST? */

#define MVF_DEFAULT ((1<<MVF_INCACHE) | (1<<MVF_OUTCACHE))
typedef struct MVNODE ATL_mvnode_t;
struct MVNODE
{
   double mflop[8];
   ATL_mvnode_t *next;
   char *rout, *auth, *comp, *cflags;
   char *kname;                 /* The name kernel should be compiled to */
   char *str;                   /* tmp string used in generation */
   char *genstr;                /* system(genstr) will generate gened kernel */
   char *exflags;               /* extra flags to pass test/time call */
   int alignA, alignX, alignY;  /* required alignments */
   int ldamul;                  /* lda must be a multiple of ldamul */
   int ID, NU, MU;              /* unrolling for Y & X vectors */
   int minN, minM;              /* min veclen to call the rout with */
   int CacheElts;               /* # of cache elts to assume for blocking */
   int SSE;                     /* 0: no SSE, 1: SSE1 req, 2: SSE2 req, etc */
   int asmbits;                 /* valid assemblies in this file */
   int rankR;                   /* restriction rank, higher faster kern */
   int ntlb;                    /* for dot-based alg, col blocking for TLB */
   enum ATLAS_TRANS TA;         /* transpose setting */
   int flag;                    /* bit vector of MVF_* */
};

@ROUT genparse
#ifndef ATLAS_GENPARSE_H
   #define ATLAS_GENPARSE_H

#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <string.h>
#include <ctype.h>
@extract -b @(basd)/atlconf.base rout=asmconf.h
/*
 * Basic data structure for forming queues with some minimal info
 */
typedef struct SIDNode ATL_sidnode_t;
struct SIDNode  /* holds string, integer, and double */
{
   double d;
   char *str;
   int i;
   ATL_sidnode_t *next;
};

#define SET_FLAG(bits_, MMR_, val_) \
{\
   if (val_) (bits_) |= (1<<(MMR_)); \
   else (bits_) &= ~(1<<(MMR_)); \
}
#define FLAG_IS_SET(field_, bit_) ( ((field_) & (1<<(bit_))) != 0 )

@iexp ip @(ip) 1 +
/* procedure @(ip) */
int Sys2File(char *cmnd, char *file)
/*
 * Executes cmnd, and redirects stdout to file
 * RETURNS: 0 for success, else error code from system call
 */
{
   int lF, lC, i;
   char *sp, *sys;
   assert(cmnd);
   if (!file)
      file = "/dev/null";
   else if (!strcmp(file, "stdout"))
      file = NULL;
   lC = strlen(cmnd);
   if (file)
      lF = strlen(file);
   else 
      lF = 0;
   sys = malloc((lC+lF+10)*sizeof(char));
   assert(sys);
   for (i=0; i < lC; i++)
      sys[i] = cmnd[i];
   if (file)
   {
      sp = sys + lC;
      *sp = ' ';
      sp[1] = '>';
      sp[2] = ' ';
      sp += 3;
      for (i=0; i < lF; i++)
         sp[i] = file[i];
      sp[lF] = ' ';
      sp[lF+1] = '2';
      sp[lF+2] = '>';
      sp[lF+3] = '&';
      sp[lF+4] = '1';
      sp[lF+5] = '\0';
   }
   else
      sys[lC] = '\0';
   i = system(sys);
   if (i)
      fprintf(stderr, "\nERROR %d for '%s'!\n\n", i, sys);
   free(sys);
   return(i);
}
@BEGINSKIP
@iexp ip @(ip) 1 +
/* procedure @(ip) */
char *GetSysStr(char *cmnd)
/*
 * Executes cmnd, and returns stdout as string
 */
{
   int len;
   len strlen(cmnd)
}
@ENDSKIP

@iexp ip @(ip) 1 +
/* procedure @(ip) : allocates ATL_sidnode_t */
static ATL_sidnode_t *ATL_NewSIDNode(void)
{
   ATL_sidnode_t *sp;
   sp = calloc(1, sizeof(ATL_sidnode_t));
   assert(sp);
   return(sp);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) : allocates ATL_sidnode_t */
static ATL_sidnode_t *ATL_FreeSIDNode(ATL_sidnode_t *die)
{
   ATL_sidnode_t *sp=NULL;
   if (die)
   {
      sp = die->next;
      if (die->str)
         free(die->str);
      free(die);
   }
   return(sp);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static int GetL1CacheElts(char pre)
{
   FILE *L1f;
   int L1Size, i;

   L1f = fopen("res/L1CacheSize", "r");
   if (!L1f)
   {
      assert(system("make res/L1CacheSize\n") == 0);
      L1f = fopen("res/L1CacheSize", "r");
   }
   assert(L1f);
   assert(fscanf(L1f, "%d", &L1Size) == 1);
   fclose(L1f);
   assert(L1Size > 0);
   if (pre == 'c' || pre == 'd')
      i = 1024/8;
   else if (pre == 's')
      i = 1024/4;
   else if (pre == 'z')
      i = 1024/16;
   else
      assert(0);
   return(i*L1Size);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static char *ExtendString(char *str, int len)
/*
 * Given already-allocated str, allocate a new string of total length len,
 * copy str to it (strlen(str)<= len)
 */
{
   char *sp;
   sp = realloc(str, len);
   assert(sp);
   return(sp);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static char *GetStrForSprintf
(
   char *form,  /* format string that will be passed to printf */
   int extra,   /* extra chars over format length to allocate */
   char *old    /* original ptr to pass to realloc */
)
{
   old = realloc(old, strlen(form)+extra);
   assert(old);
   return(old);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static int NumDecDigits(int num)
/*
 * RETURNS: number of decimal digits required to hold num, wt sign of neg #s
 *          counted as a digit
 */
{
   int bound, nd;
   if (num < 0)
   {
      nd = 2;
      num = -num;
   }
   else
      nd = 1;
   for (bound=9; num > bound; nd++)
      bound = bound*10 + 9;
   return(nd);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static int NumHexDigits(unsigned int num)
{
   int dig;

   for (dig=1; num; num >>= 4) 
      dig++;
   return(dig);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static char *DupString(char *str)
{
   int i,n;
   char *s;

   if (!str)
      return(NULL);
   n = strlen(str)+1;
   s = malloc(sizeof(char)*n);
   assert(s);
   for (i=0; i < n; i++)
      s[i] = str[i];
   return(s);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static char *NewMergedString(char *st0, char *st1)
/*
 * RETURNS: new string with st1 concatonated to st0
 */
{
   int i, n0, n1;
   char *s;

   if (!st0)
   {
      if (!st1)
         return(NULL);
      else 
         return(DupString(st1));
   }
   n0 = strlen(st0);
   n1 = strlen(st1) + 1;
   s = malloc(sizeof(char)*(n0+n1));
   assert(s);
   for (i=0; i < n0; i++)
      s[i] = st0[i];
   s += n0;
   for (i=0; i < n1; i++)
      s[i] = st1[i];
   return(s-n0);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static char *GetSingleQuoteString(char *str)
{
   char *sp;
   int i, n;

   assert(str[0] == '\'');
   for (i=1; str[i] && str[i] != '\''; i++);
   assert(str[i]);
   sp = malloc(i*sizeof(char));
   for (n=i,i=1; i < n; i++)
      sp[i-1] = str[i];
   sp[n-1] = '\0';
   return(sp);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static FILE *OpenFileWithPath(char *path, char *file, char *perm)
{
   char *fn;
   FILE *fp;
   assert(file && perm);
   if (path)
   {
      int plen, flen;
      char *fn;

      plen = strlen(path);
      flen = strlen(file);
      fn = malloc(plen+flen+2);
      assert(fn);
      memcpy(fn, path, plen);
      fn[plen] = '/';
      memcpy(fn+plen+1, file, flen);
      fn[plen+flen+1] = '\0';
      fp = fopen(fn, perm);
      free(fn);
   }
   else
      fp = fopen(file, perm);

   return(fp);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static int asmNames2bitfield(char *str)
/*
 * Takes str containing an assembly name list.  The list is ended by the first
 * white space or end of string.  List items are seperated by ',', and there
 * can be no whitespace in list.
 * RETURNS: bitfield with bits set corresponding to assemblies, 0 on error.
 */
{
   char asmname[64];
   int i, KeepOn, bits=0;

   do
   {
      for (i=0; !isspace(str[i]) && str[i] != ',' && str[i] && i < 64; i++)
         asmname[i] = str[i];
      asmname[i] = '\0';
      KeepOn = str[i] == ',';
      str += i+1;
      if (i >= 64)
         return(0);  /* no asm name > 63 in length */
      for (i=0; i < NASMD; i++)
      {
         if (!strcmp(ASMNAM[i], asmname))
         {
            bits |= (1<<i);
            break;
         }
      }
   }
   while(KeepOn);
   return(bits);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static int GetDoubleArr(char *str, int N, double *d)
/*
 * Reads in a list with form "%le,%le...,%le"; N-length d recieves doubles.
 * RETURNS: the number of doubles found, or N, whichever is less
 */
{
   int i=1;
   assert(sscanf(str, "%le", d) == 1);
   while (i < N)
   {
      str = strstr(str, ",");
      if (!str)
         break;
      str++;
      assert(sscanf(str, "%le", d+i) == 1);
      i++;
   }
   return(i);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static char *GetLongerString(char *shrt, int newlen)
/*
 * Allocates new string of size newlen, copies shrt into it, and frees shrt.
 */
{
   char *sp;

   sp = malloc(sizeof(char)*newlen);
   assert(sp);
   if (shrt)
   {
      strcpy(sp, shrt);
      free(shrt);
   }
   else if (newlen >= 0)
      sp[0] = '\0';
   return(sp);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static char *GetOneLine(FILE *fpin)
/*
 * RETURNS: string of one line from stream fpin,  NULL if stream exhausted.
 */
{
   const int inc=256;
   static int len=0;
   static char *ln, *sp;
   int i, j, KeepOn;

   if (!len)
   {
      ln = malloc(inc*sizeof(char));
      assert(ln);
      len = inc;
   }
   if (!fgets(ln, len, fpin))
      return(NULL);

   for (i=0; ln[i]; i++);  /* find end of string */
   if (!i) return(ln);
   while (ln[i-1] != '\n')    /* if last char not \n, read rest of line */
   {
      len += inc;
      ln = GetLongerString(ln, len);
      if (!fgets(ln+i, inc, fpin))
         return(ln);
       for (; ln[i]; i++);  /* find end of string */
   }
   return(ln);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static char *GetJoinedLines(FILE *fpin)
/*
 * Gets lines from file fpin; if last non-whitespace char is '\', joins lines
 * RETURNS: line from file including joining, NULL if fpin exhausted
 */
{
   char *ln, *sp;
   static char *join=NULL;
   static int jlen=0;
   int i, j, k;

   sp = ln = GetOneLine(fpin);
   if (!sp)
      return(NULL);
   j = 0;   /* current length of join string */
   if (ln)
   {
      for (i=0; ln[i]; i++);  /* find end of string */
      if (!i) return(NULL);
      for (i--; isspace(ln[i]) && i > 0; i--);  /* find last non-wspace char */
      while (ln[i] == '\\')
      {
         if (jlen < j+i+3)
         {
            jlen = j+i+i+3;
            join = GetLongerString(join, jlen);
         }
         for (k=0; k < i; k++)
            join[j+k] = ln[k];
         j += k;
         join[j++] = ' ';
         join[j] = '\0';
         ln = GetOneLine(fpin);   /* get new line that should be joined */
         assert(ln);              /* can't end file with continue */
         for (i=0; ln[i]; i++);   /* find end of new line */
         for (i--; isspace(ln[i]) && i > 0; i--); /* find last non-wspc char */
         sp = join;
      }
      if (sp == join)
      {
         if (jlen < j+i+3)
         {
            jlen = j+i+i+3;
            join = GetLongerString(join, jlen);
         }
         for (k=0; k <= i; k++)
            join[j+k] = ln[k];
         j += k;
         join[j] = '\n';
         join[j+1] = '\0';
         sp = join;
      }
   }
   return(sp);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static void ATL_isortG2L(int N, int *X)
/*
 * Sort X from greatest-to-least via selection sort (O(N^2))
 */
{
   int i;
   if (N < 2)
      return;
   for (i=0; i < N-1; i++)
   {
      int imax=X[i], idx=i, j;
      for (j=i+1; j < N; j++)
      {
         const int xj=X[j];
         if (xj > imax)
         {
            imax = xj;
            idx = j;
         }
      }
      if (idx != i)
      {
         X[idx] = X[i];
         X[i] = imax;
      }
   }
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static char *GetGoodGcc()
/*
 * Gets gcc path and name along with mandatory flags (-g/-m64/-pg,etc) by
 * querying Make.inc setting
 */
{
   static char gcc[2048];
   static int INIT=0;
   if (!INIT)
   {
      FILE *fpin;
      assert(system("make res/goodgcc.txt > /dev/null 2>&1") == 0);
      fpin = fopen("res/goodgcc.txt", "r");
      assert(fpin);
      assert(fscanf(fpin, "'%[^\']", gcc) == 1);
      fclose(fpin);
   }
   return(gcc);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static char *GetKCFlags(char pre)
/*
 * Gets flags being used for <pre>KCFLAGS
 */
{
   char ln[4096];
   FILE *fpin;
   int i;

   if (pre == 'z')
      pre = 'd';
   else if (pre == 'c')
      pre = 's';
   i = system("rm -f res/kcflags.txt");
   sprintf(ln, "grep \"%cKCFLAGS = \" Make.inc | sed s/%cKCFLAGS\\ =\\ // > res/kcflags.txt", toupper(pre), toupper(pre));
   assert(system(ln) == 0);
   fpin = fopen("res/kcflags.txt", "r");
   assert(fpin);
   assert(fgets(ln, 4096, fpin) != NULL);
   fclose(fpin);
/*
 * Get rid of trailing and leading whitespaces
 */
   for (i=0; ln[i]; i++);
   for (i--; isspace(ln[i]); i--);
   ln[i+1] = '\0';
   for (i=0; isspace(ln[i]); i++);
   return(DupString(ln+i));
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static int *GF_GetIntList1(int ival)
/*
 * returns integer array with iarr[0] = 1, iarr[1] = ival
 */
{
   int *iarr;
   iarr = malloc(2*sizeof(int));
   assert(iarr);
   iarr[0] = 1;
   iarr[1] = ival;
   return(iarr);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static int *GF_GetIntList2(int ival1, int ival2)
/*
 * returns integer array with iarr[0] = 1, iarr[1] = ival1, ival[2] = ival2
 */
{
   int *iarr;
   iarr = malloc(3*sizeof(int));
   assert(iarr);
   iarr[0] = 2;
   iarr[1] = ival1;
   iarr[2] = ival2;
   return(iarr);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static int *GF_DupIntList(int *L)
/*
 * dups a list of integers L, whose data length is given by L[0];
 * list is this length+1, since 0'th location gets data length.
 */
{
   int *ip, n;
   if (!L)
      return(NULL);
   n = L[0] + 1;
   ip = malloc(n*sizeof(int));
   assert(ip);
   memcpy(ip, L, n*sizeof(int));
   return(ip);
}
#ifdef ATL_GETFLAGS
@iexp ip @(ip) 1 +
/* procedure @(ip) */
static double *GF_GetNDoubleArgs(int nargs, char **args, int i, int n)
/*
 * Reads in n doubles from commandline args to produce n-len double array.
 */
{
   int k;
   double *darr;
   void PrintUsage(char*, int, char*);

   if (n < 1)
      return(NULL);
   darr = malloc(sizeof(double)*n);
   assert(darr);

   for (k=0; k < n; k++)
   {
      if (++i >= nargs)
         PrintUsage(args[0], i, NULL);
      darr[k] = atof(args[i]);
   }
   return(darr);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static double *GF_GetDoubleList(int nargs, char **args, int i, int nmul)
/*
 * Gets a list of doubles, whose length is given by atoi(args[i])*nmul
 * list is this length+1, since 0'th location gets atoi(args[i])
 */
{
   int n, k;
   double *darr;
   void PrintUsage(char*, int, char*);

   if (++i >= nargs)
      PrintUsage(args[0], i, NULL);
   n = atoi(args[i]) * nmul;
   assert(n > 0);
   darr = malloc(sizeof(double)*(n+1));
   assert(darr);

   darr[0] = n / nmul;
   for (k=0; k < n; k++)
   {
      if (++i >= nargs)
         PrintUsage(args[0], i, NULL);
      darr[k+1] = atof(args[i]);
   }
   return(darr);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static int *GF_GetIntList(int nargs, char **args, int i, int nmul)
/*
 * Gets a list of integers, whose length is given by atoi(args[i])*nmul
 * list is this length+1, since 0'th location gets atoi(args[i])
 */
{
   int n, *iarr, k;
   void PrintUsage(char*, int, char*);

   if (++i >= nargs)
      PrintUsage(args[0], i, NULL);
   n = atoi(args[i]) * nmul;
   assert(n > 0);
   iarr = malloc(sizeof(int)*(n+1));
   assert(iarr);

   iarr[0] = n / nmul;
   for (k=0; k < n; k++)
   {
      if (++i >= nargs)
         PrintUsage(args[0], i, NULL);
      iarr[k+1] = atoi(args[i]);
   }
   return(iarr);
}
#endif

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static int *GF_IntRange2IntList(int N0, int NN, int incN)
{
   int i, n;
   int *iarr;

   for (i=N0, n=0; i <= NN; i += incN) n++;
   iarr = malloc(sizeof(int)*(n+1));
   assert(iarr);
   iarr[0] = n;
   for (i=N0, n=1 ; i <= NN; i += incN, n++)
      iarr[n] = i;
   return(iarr);
}
@iexp ip @(ip) 1 +
/* procedure @(ip) */
static int GetNativeVLEN(char pre)
{
#if defined(ATL_AVX) || defined(ATL_AVXMAC)
   if (pre == 's' || pre == 'c' || pre == 'S' || pre == 'C')
      return(8);
   return(4);
#elif defined(ATL_GAS_ARM64)
      if (pre == 's' || pre == 'c' || pre == 'S' || pre == 'C')
         return(4);
      return(2);
#elif defined(ATL_GAS_ARM)
   #ifndef ATL_NONIEEE
      return(1);
   #else
      if (pre == 's' || pre == 'c' || pre == 'S' || pre == 'C')
         return(4);
      return(1);
   #endif
#elif defined(ATL_SSE2) || defined(ATL_VECARM1) || defined(ATL_VSX)
   if (pre == 's' || pre == 'c' || pre == 'S' || pre == 'C')
      return(4);
   return(2);
#elif defined(ATL_SSE1)
   if (pre == 's' || pre == 'c' || pre == 'S' || pre == 'C')
      return(4);
   return(1);
#else
   return(0);   /* 0 means: I don't know */
#endif
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static int ATL_numBitsNeeded(int N)
/*
 * RETURNS: min number of bits to store value N
 * NOTE: assumes negative numbers are flags meaning not stored!
 */
{
   int i;
   if (N <= 0)
      return(0);
   for (i=0; (1<<i) <= N; i++);
   return(i);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static int GetNumVecRegs(char pre)
{
#ifdef ATL_SSE1
   #ifdef ATL_USE64BITS
      return(16);
   #else
      return(8);
   #endif
#elif defined(ATL_VECARM1) || defined(ATL_FPV3D32MAC)
   return(32);
#elif defined(ATL_FPV3D16MAC)
   if (pre == 's' || pre == 'c' || pre == 'S' || pre == 'C')
      return(32);
    return(16);
#elif defined(ATL_VSX)
   return(64);
#else
   return(0);   /* 0 means: I don't know */
#endif
}

/*
 * The following are functions that allow us to operate on generic lists
 * of any structure.  The idea is that you pass the byte offset where
 * the next pointer is found, as well as the data item you want to access.
 * Since we are loading raw memory, note that your type must match precisely.
 * Eg., GetIntAtOff is only used with int (signed or unsigned), not any 
 * intergral (it will fail for short or char).  Assuming you have a pointer
 * to the structure in question:
 *    GetOffset(&p->next, p);
 * can be used to calculate the offnxt these funcs require.
 */
@iexp ip @(ip) 1 +
/* procedure @(ip) */
static int GetOffset(void *v0, void *v1)
/*
 * Find (postive) gap between addresses.  Used inside structs, where dist
 * is short enough that size_t not required.
 */
{
   size_t i0=(size_t)v0, i1=(size_t)v1;
   if (v1 > v0)
      return(v1-v0);
   return(v0-v1);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static int GetIntAtOff(void *p, int off)
/*
 * RETURNS: derefence *(p+off) interpeted an integer address.
 */
{
   return(*((int*)(((char*)p)+off)));
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static void *GetPtrAtOff(void *p, int off)
{
   return( *((void**)(((char*)p)+off)) );
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static char *GetStrAtOff(void *p, int off)
{
   return( *((char**)(((char*)p)+off)) );
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static double GetDoubleAtOff(void *mp, int off)
{
   return(*((double*)(((char*)mp)+off)));
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static void SetPtrAtOff(void *vb, int off, void *p)
{
   *((void**)(((char*)vb)+off)) = p;
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static int CountListEntries(void *vb, int nxtoff)
{
   int i=0;
   char *cp = vb;
   while (cp)
   {
      cp = GetStrAtOff(cp, nxtoff);
      i++;
   }
   return(i);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static int CountListMaskALL(void *vb, int msk, int nxtoff, int ioff)
/*
 * counts number of nodes where all bits set in msk are set in int at ioff
 */
{
   int i=0;
   char *cp = vb;
   while (cp)
   {
      int flag;
      flag = GetIntAtOff(cp, ioff);
      if ((flag&msk) == msk)
         i++;
      cp = GetStrAtOff(cp, nxtoff);
   }
   return(i);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static int GetIntMaxMinAtOff(void *vb, int nxtoff, int off, int *MAX, int *MIN)
/*
 * Find the max and min of any integer in vb+off in list, next ptr at nxtoff;
 * Works for any list with a next ptr, and any int stored as int native
 * (will not work for short/char/etc).
 * RETURNS: number of nodes searched.
 */
{
   char *cp=vb;
   register int max=0, min=0, n=0;

   if (vb)
   {
      min = max = GetIntAtOff(cp, off);
      n = 1;
      while( (cp = GetStrAtOff(cp, nxtoff)) )
      {
         register int i;
         i = GetIntAtOff(cp, off);
         max = (max >= i) ? max : i;
         min = (min <= i) ? min : i;
         n++;
      }
   }
   *MAX = max;
   *MIN = min;
   return(n);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
void *iFindMinAtOff(void *vb, int nxtoff, int off)
/*
 * RETURNS: ptr to struct containing minimum integer at off
 */
{
   void *ret=NULL;
   if (vb)
   {
      char *cp=vb;
      int min;

      ret = vb;
      min = GetIntAtOff(cp, off);
      while( (cp = GetStrAtOff(cp, nxtoff)) )
      {
         int i;
         i = GetIntAtOff(cp, off);
         if (i < min)
         {
            ret = vb;
            min = i;
         }
      }
   }
   return(ret);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static int *GetIntsFromQ(void *vb, int nxtoff, int off)
/*
 * Given N nodes in vb, returns an N+1 int array, with 1st elt storing N,
 * and subsequent elts storing the integer found at off in the struct.
 * RETURNS: NULL for NULL vb, else above.
 */
{

   if (vb)
   {
      char *cp=vb;
      int *ip;
      int i, n;

      n = CountListEntries(vb, nxtoff);
      ip = malloc((n+1)*sizeof(int));
      assert(ip);
      ip[0] = n;
      for (i=0; i < n; i++)
      {
         ip[i+1] = GetIntAtOff(vb, off);
         vb = GetPtrAtOff(vb, nxtoff);
      }
      return(ip);
   }
   return(NULL);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
void *ATL_FindLastNode(void *vp, int nxtoff)
{
   if (vp)
   {
      char *nxt;
      while ( (nxt = GetStrAtOff(vp, nxtoff)) )
         vp = nxt;
   }
   return(vp);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
void *FindNodeWithMaskOR(void *p, int nxtoff, int bvoff, int mask)
/*
 * Assuming list with next ptr at nxtoff, and bitvec at bvoff, search
 * for any node with any bits present int mask set.
 * RETURNS: ptr to first node with bits matching any bit in mask, if none, NULL
 * NOTE: this function does a logical OR (any mask bit set) operation, not AND!
 */
{
   while (p)
   {
      int bv;
      bv = GetIntAtOff(p, bvoff);
      if (bv & mask)
         return(p);
      p = GetStrAtOff(p, nxtoff);
   }
   return(NULL);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
void PrefixStrAllNodes(void *p, int nxtoff, int stoff, char *str)
/*
 * Prefixes all strings at stoff in queue starting at p if not already prefxd
 */
{
   unsigned int len;
   if (!str || !p)
      return;
   len = strlen(str);
   if (!len)
      return;
   while(p)
   {
      char *os, *ns;
      unsigned int olen;
      int DOPREF;

      os = GetStrAtOff(p, stoff);
      if (os)
      {
         olen = strlen(os);
         if (olen < len)
            DOPREF = 1;
         else
            DOPREF = strncmp(os, str, len);
         if (DOPREF)
         {
            ns = malloc(len+olen+1);
            assert(ns);
            strcpy(ns, str);
            strcpy(ns+len, os);
            free(os);
            SetPtrAtOff(p, stoff, ns);
         }
      }
      p = GetPtrAtOff(p, nxtoff);
   }
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
void *FindNodeWithIval(void *p, int nxtoff, int ivoff, int val)
{
   while (p)
   {
      int iv;
      iv = GetIntAtOff(p, ivoff);
      if (iv == val)
         return(p);
      p = GetStrAtOff(p, nxtoff);
   }
   return(NULL);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
void *RemoveNodeFromList(void *vb, void *vp, int nxtoff)
/*
 * Finds struct ptr vp in vb, and removes it from singly-linked list
 * RETURNS: possibly changed vb (only in case vb == vp)
 */
{
   if (vb)
   {
      char *nxt, *prv=vb, *cur;
      nxt = GetStrAtOff(vb, nxtoff);
      if (vb == vp)
      {
         SetPtrAtOff(vb, nxtoff, NULL);
         return((void*)nxt);
      }
      cur = nxt;

      while (cur)
      {
         nxt = GetStrAtOff(cur, nxtoff);
         if (cur == vp)
         {
            SetPtrAtOff(prv, nxtoff, nxt);
            SetPtrAtOff(cur, nxtoff, NULL);
            return(vb);
         }
         prv = cur;
         cur = nxt;
      }
   }
   if (vb)
   {
      fprintf(stderr, "ERROR: cannot find %p in basefile %p!\n", vp, vb);
      exit(1);
   }
   return(NULL);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
void *SortListByIval_G2L(void *vb, int nxtoff, int ivoff)
/*
 * RETURNS: base ptr of list bv sorted from greatest-to-least by int at ivoff
 * NOTE: original list is reordered, so vb must be replaced by return baseptr!
 */
{
   void *sb=NULL;
   while (vb)
   {
      void *minp;
      minp = iFindMinAtOff(vb, nxtoff, ivoff);
      vb = RemoveNodeFromList(vb, minp, nxtoff);
      SetPtrAtOff(minp, nxtoff, sb);
      sb = minp;
   }
   return(sb);
}
#endif /* end atlas_genparse.h guard */
@ROUT cpread
   @define rt @cp@
@ROUT mmread
#ifndef ATL_DEF_MMFLAG
   #define ATL_DEF_MMFLAG @up@(rt)F_DEFAULT
#endif
   @define rt @mm@
@ROUT mvread
   @define rt @mv@
@ROUT r1read
   @define rt @r1@
@ROUT r1read mvread mmread cpread
@iexp ip @(ip) 1 +
/* procedure @(ip) */
static ATL_@(rt)node_t *Get@up@(rt)Node(void)
{
   ATL_@(rt)node_t *p;
   p = calloc(1, sizeof(ATL_@(rt)node_t));
   assert(p);
@ROUT mvread `   p->TA = AtlasNoTrans;`
@ROUT mmread `   p->TA = AtlasTrans; p->TB = AtlasNoTrans;`
   p->flag = @up@(rt)F_DEFAULT;
   return(p);
}

@whiledef cc Clone Copy
@iexp ip @(ip) 1 +
/* procedure @(ip) */
@mif cc = "Clone
static ATL_@(rt)node_t *Clone@up@(rt)Node(ATL_@(rt)node_t *dup)
@endmif
@mif cc = "Copy
static void Copy@up@(rt)Node(ATL_@(rt)node_t *p, ATL_@(rt)node_t *dup)
@endmif
{
@mif cc = "Clone
   ATL_@(rt)node_t *p;
   p = malloc(sizeof(ATL_@(rt)node_t));
   assert(p);
@endmif
@mif cc = "Copy
   ATL_@(rt)node_t *nxt=p->next;
   @whiledef st auth comp cflags rout genstr exflags str
   if (p->@(st))
      free(p->@(st));
   @endwhile
@endmif
   memcpy(p, dup, sizeof(ATL_@(rt)node_t));
   @whiledef st auth comp cflags rout genstr exflags str
   if (dup->@(st))
      p->@(st) = DupString(dup->@(st));
   @endwhile
@ROUT mmread
   if (dup->moves)
      p->moves = DupString(dup->moves);
@ROUT r1read mvread
   if (dup->kname)
      p->kname = DupString(dup->kname);
@ROUT r1read mvread mmread cpread
@mif cc = "Copy
   p->next = nxt;
@endmif
@mif cc = "Clone
   p->next = NULL;
   return(p);
@endmif
}
@endwhile

@iexp ip @(ip) 1 +
/* procedure @(ip): clones a queue of @up@(rt) structs */
static ATL_@(rt)node_t *Clone@up@(rt)Queue(ATL_@(rt)node_t *dupb)
{
   ATL_@(rt)node_t *p, *pd, *nb;
   if (!dupb)
      return(NULL);
   p = nb = Clone@up@(rt)Node(dupb);
   for (pd=dupb->next; pd; pd = pd->next)
   {
      p->next = Clone@up@(rt)Node(pd);
      p = p->next;
   }
   return(nb);
}

@iexp ip @(ip) 1 +
/* procedure @(ip): clones a queue of strided @up@(rt) structs */
static ATL_@(rt)node_t *CloneStrided@up@(rt)Queue
(
   ATL_@(rt)node_t *dupb,   /* queue of nodes to clone */
   int stride               /* increment between nodes to take */
)
/*
 * Creates a queue of cloned nodes from dupb; move stride each time
 * (stride must be >= 1); i.e. skip stride-1 structs in original queue
 */
{
   ATL_@(rt)node_t *p, *pd, *nb;
   int i;

   if (!dupb)
      return(NULL);
   if (stride == 1)
      return(Clone@up@(rt)Queue(dupb));
   assert(stride > 1);
   p = nb = Clone@up@(rt)Node(dupb);
   pd = nb;
   while(pd)
   {
      for (i=0; i < stride && pd; i++, pd = pd->next);
      if (pd)
      {
         p->next = Clone@up@(rt)Node(pd);
         p = p->next;
      }
      else
         p->next = NULL;
   }
   return(nb);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static ATL_@(rt)node_t *Kill@up@(rt)Node(ATL_@(rt)node_t *die)
{
   ATL_@(rt)node_t *p=NULL;
   if (die)
   {
      p = die->next;
      if (die->rout)
         free(die->rout);
      if (die->auth)
         free(die->auth);
      if (die->comp)
         free(die->comp);
      if (die->cflags)
         free(die->cflags);
      if (die->str)
         free(die->str);
      if (die->genstr)
         free(die->genstr);
      if (die->exflags)
         free(die->exflags);
@ROUT mmread
      if (die->moves)
         free(die->moves);
@ROUT r1read mvread
      if (die->kname)
         free(die->kname);
@ROUT r1read mvread mmread cpread
      free(die);
   }
   return(p);
}

@iexp ip @(ip) 1 +
/* procedure @(ip): safely remove nukeme from Q, reseting all links */
static ATL_@(rt)node_t *Remove@up@(rt)NodeFromQ
(
   ATL_@(rt)node_t *Q,     /* queue of nodes */
   ATL_@(rt)node_t *nukeme /* node to remove from queue */
)
/*
 * Removes nukeme from Q, sets nukeme->next=NULL, and returns updated Q
 */
{
   ATL_@(rt)node_t *p, *prev;

   if (!nukeme)
      return(Q);
   assert(Q);
   if (Q == nukeme)
   {
      Q = Q->next;
      nukeme->next = NULL;
      return(Q);
   }
   prev = Q;
   for (p=Q->next; p && p != nukeme; p = p->next)
      prev = p;
   assert(p);
   prev->next = nukeme->next;
   nukeme->next = NULL;
   return(Q);
}

@iexp ip @(ip) 1 +
/* procedure @(ip): swap two nodes in Q */
static ATL_@(rt)node_t *Swap@up@(rt)NodeInQ
(
   ATL_@(rt)node_t *Q,     /* queue of nodes */
   ATL_@(rt)node_t *p0,    /* first node to be swap */
   ATL_@(rt)node_t *p1     /* second node to be swap */
)
/*
 * Puts p0 in queue at place p1 was, and p1 in place p0 was.
 * RETURNS: possibly changed Q
 */
{
   ATL_@(rt)node_t *p, *prv0=NULL, *prv1=NULL, *nxt;
   unsigned int fnd=0;

   if (!Q || !p0 || !p1 || p1 == p0) /* need different pair to swap */
      return(Q);
   for (p=Q; fnd != 3 && p; p = p->next)
   {
      if ((fnd&1) == 0) /* still looking for p0 */
      {
         if (p == p0)
            fnd |= 1;
         else 
         {
            prv0 = p;
         }
      }
      if ((fnd&2) == 0) /* still looking for p1 */
      {
         if (p == p1)
            fnd |= 2;
         else
         {
            prv1 = p;
         }
      }
   }
   if (fnd != 3)
   {
      fprintf(stderr, "\nFND=%u!!\n\n", fnd);
      assert(fnd == 3);
   }
   if (prv0 == p1)  /* p1->p0-> */
   {
      if (prv1)
         prv1->next = p0;
      p1->next = p0->next;
      p0->next = p1;
   }
   else if (prv1 == p0) /* p0->p1-> */
   {
      if (prv0)
         prv0->next = p1;
      p0->next = p1->next;
      p1->next = p0;
   }
   else /* neither predecessor of other */
   {
      nxt = p0->next;
      p0->next = p1->next;
      p1->next = nxt;
      if (prv0)
         prv0->next = p1;
      if (prv1)
         prv1->next = p0;
   }
   if (Q == p1)
      Q = p0;
   else if (Q == p0)
      Q = p1;
   return(Q);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static ATL_@(rt)node_t *Kill@up@(rt)NodeFromQ
(
   ATL_@(rt)node_t *Q,     /* queue of nodes */
   ATL_@(rt)node_t *nukeme /* node to remove from queue */
)
{
   Q = Remove@up@(rt)NodeFromQ(Q, nukeme);
   Kill@up@(rt)Node(nukeme);
   return(Q);
}

@iexp ip @(ip) 1 +
/* procedure @(ip): frees all ->rout entries in queue b */
static void KillAll@up@(rt)Routs(ATL_@(rt)node_t *b)
{
   while (b)
   {
      if (b->rout)
      {
         free(b->rout);
         b->rout = NULL;
      }
      b = b->next;
   }
}

@ROUT mmread
/* procedure @(ip) */
void *KillAllMMStrings(ATL_mmnode_t *mb)
{
   ATL_mmnode_t *mp;

   for (mp=mb; mp; mp = mp->next)
   {
      @whiledef sv rout auth comp cflags str genstr exflags moves
      if (mp->@(sv))
         free(mp->@(sv));
      mp->@(sv) = NULL;
      @endwhile
   }
}

@ROUT r1read mvread mmread cpread
@iexp ip @(ip) 1 +
/* procedure @(ip): frees all ->genstr entries in queue b */
static void KillAll@up@(rt)Genstr(ATL_@(rt)node_t *b)
{
   while (b)
   {
      if (b->genstr)
      {
         free(b->genstr);
         b->genstr = NULL;
      }
      b = b->next;
   }
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static void KillAll@up@(rt)Nodes(ATL_@(rt)node_t *die)
{
   while (die)
      die = Kill@up@(rt)Node(die);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static void ATL_SubGoodGccIn@up@(rt)Nodes
(
   ATL_@(rt)node_t *bp   /* queue to make sub in */
)
/*
 *  Gets GOODGCC (from Make.inc), and substitutes it for all comp == "gcc"
 *  in the queue.  This gets us mandatory flags like -pg,-m64,etc.
 */
{
   ATL_@(rt)node_t *kp;  /* queue to make sub in */
   char *gcc;
   gcc = GetGoodGcc();
   for (kp=bp; kp; kp = kp->next)
   {
      if (kp->comp && !strcmp(kp->comp, "gcc"))
      {
         free(kp->comp);
	 kp->comp = DupString(gcc);
      }
   }
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static void ATL_UnsubGoodGccIn@up@(rt)Nodes
(
   ATL_@(rt)node_t *bp   /* queue to make reverse sub in */
)
/*
 *  Gets GOODGCC (from Make.inc); Any comp string matching that is switched
 *  back to "gcc".  This is usually necessary so that output files don't
 *  use an old GOODGCC that lacks something like -pg.
 */
{
   ATL_@(rt)node_t *kp;  /* queue to make sub in */
   char *gcc;
   gcc = GetGoodGcc();
   for (kp=bp; kp; kp = kp->next)
   {
      if (kp->comp && !strcmp(kp->comp, gcc))
      {
         free(kp->comp);
	 kp->comp = DupString("gcc");
      }
   }
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static void ResubGoodGccIn@up@(rt)Nodes
(
   ATL_@(rt)node_t *bp   /* queue to make sub in */
)
/*
 * Takes gcc compiler that use GOODGCC, and replaces them with "gcc"
 * to help portability
 */
{
   ATL_@(rt)node_t *kp;  /* queue to make sub in */
   char *gcc;
   gcc = GetGoodGcc();
   for (kp=bp; kp; kp = kp->next)
   {
      if (kp->comp && !strcmp(kp->comp, gcc))
      {
         free(kp->comp);
	 kp->comp = DupString("gcc");
      }
   }
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static int ATL_CountNumberOf@up@(rt)Nodes
(
    ATL_@(rt)node_t *bp   /* queue to count */
)
{
   int i;
   for (i=0; bp; i++, bp = bp->next);
   return(i);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static ATL_@(rt)node_t *ATL_Last@up@(rt)Node(ATL_@(rt)node_t *bp)
/*
 * RETURNS: pointer to last node in queue
 */
{
   ATL_@(rt)node_t *p;
   if (!bp)
      return(NULL);
   for (p=bp; p->next; p = p->next);
   return(p);
}

@iexp ip @(ip) 1 +
/* procedure @(ip): adds q1 to end of q0 */
static ATL_@(rt)node_t *ATL_Join@up@(rt)Qs(ATL_@(rt)node_t *q0, ATL_@(rt)node_t *q1)
{
   ATL_@(rt)node_t *mp;
   if (!q1)
      return(q0);
   if (!q0)
      return(q1);
   mp = ATL_Last@up@(rt)Node(q0);
   mp->next = q1;
   return(q0);
}

@iexp ip @(ip) 1 +
/* procedure @(ip): finds node with max mflop[imf]  */
static ATL_@(rt)node_t *FindMaxMflop@up@(rt)Q
(
   ATL_@(rt)node_t *bp,   /* queue to be searched */
   int imf
)
/*
 * RETURNS: ptr to structure containing max value in mflop[imf]
 */
{
   ATL_@(rt)node_t *mp, *p;
   double mfm;
   if (!bp)
      return(NULL);
   mp = bp;
   mfm = mp->mflop[imf];
   for (p=bp->next; p; p = p->next)
   {
      const double mf=p->mflop[0];
      if (mf > mfm)
      {
         mfm = mf;
         mp = p;
      }
   }
   return(mp);
}
@multidef cmp < >
@whiledef op Min Max
   @iexp ip @(ip) 1 +
/* procedure @(ip): finds @low@(op) integer at ip0 in struct */
static ATL_@(rt)node_t *Find@(op)IntIn@up@(rt)Q
(
   ATL_@(rt)node_t *bp,   /* queue to be searched */
   void *ip0           /* ptr to integer withinin node bp */
)
/*
 * RETURNS: ptr to structure containing @low@(op) int value at byte offset 
 *          offset in struct
 */
{
   ATL_@(rt)node_t *mp=NULL, *p;
   int *ip;
   int val;
   const int offset = (int)((char*)((char*) ip0) - ((char*)bp));

   if (!bp)
      return(NULL);
   
   mp = bp;
   ip = (int*)(((char*)bp) + offset);
   val = *ip;
   for (p=bp->next; p; p = p->next)
   {
      ip = (int*)(((char*)p) + offset);
      if (*ip @(cmp) val)
      {
         mp = p;
         val = *ip;
      }
   }
   return(mp);
}
   @undef cmp
@endwhile

@iexp ip @(ip) 1 +
/* procedure @(ip): finds first integer equal to val at ip0 in struct */
static ATL_@(rt)node_t *FindIntValIn@up@(rt)Q
(
   ATL_@(rt)node_t *bp,   /* queue to be searched */
   void *ip0,          /* ptr to integer withinin node bp */
   int val             /* value being searched for */
)
/*
 * RETURNS: ptr to first structure containing value val at byte offset 
 *          offset in struct, or NULL if no such value found
 */
{
   ATL_@(rt)node_t *mp=NULL, *p;
   int *ip;
   const int offset = (int)((char*)((char*) ip0) - ((char*)bp));

   if (!bp)
      return(NULL);
   
   for (p=bp; p; p = p->next)
   {
      ip = (int*)(((char*)p) + offset);
      if (*ip == val)
         return(p);
   }
   return(NULL);
}

@iexp ip @(ip) 1 +
/* procedure @(ip): sorts Q from least-to-greatest on int val at ip0 in struc */
static ATL_@(rt)node_t *Sort@up@(rt)QByIntVal
(
   ATL_@(rt)node_t *bp,   /* queue to be sorted */
   void *ip0           /* ptr to integer withinin node bp to sort on*/
)
/*
 * RETURNS: possibly new queue base, sorted from least-to-greatest on int at ip0
 */
{
   ATL_@(rt)node_t *sb=NULL, *p;
   int *ip;
   const int offset = (int)((char*)((char*) ip0) - ((char*)bp));

   if (!bp)
      return(NULL);
   
   while(bp)
   {
      ip = (int*)(((char*)bp) + offset);
      p = FindMaxIntIn@up@(rt)Q(bp, ip);
      bp = Remove@up@(rt)NodeFromQ(bp, p);
      p->next = sb;
      sb = p;
   }
   return(sb);
}

@iexp ip @(ip) 1 +
/* procedure @(ip): reverses order in Q */
static ATL_@(rt)node_t *Reverse@up@(rt)Q(ATL_@(rt)node_t *bp)
/*
 * RETURNS: new base ptr of reversed queue
 */
{
   ATL_@(rt)node_t *nb=NULL, *p;
   while(bp)
   {
      p = bp;
      bp = bp->next;
      p->next = nb;
      nb = p;
   }
   return(nb);
}

@iexp ip @(ip) 1 +
/* procedure @(ip): places all nodes wt int value val at ip0 in new queue */
static ATL_@(rt)node_t *Yank@up@(rt)NodesByIntVal
(
   ATL_@(rt)node_t **bp0,  /* queue to be searched */
   void *ip0,          /* ptr to integer withinin node *bp */
   int val             /* value to be yanked out of original Q */
)
/*
 * Finds all nodes that have the integeral value val stored in position
 * ip0-bp0 in nodes.  These nodes are removed from bp0, and placed in
 * their own queue, which is returned.  bp0 is modified in the process.
 * RETURNS: ptr to queue of nodes wt integer value val
 */
{
   ATL_@(rt)node_t *bp=(*bp0), *p, *valb=NULL, *vp;
   int *ip;
   const int offset = (int)((char*)((char*) ip0) - ((char*)bp));

   while(bp)
   {
      p = FindIntValIn@up@(rt)Q(bp, (((char*)bp)+offset), val);  /* find node */
      if (!p)       /* if there are no more in bp, we are done */
         break;
      bp = Remove@up@(rt)NodeFromQ(bp, p);   /* remove it from original queue */
/*
 *    Add node at front of new value-only queue 
 */
      if (valb)
      {
         vp->next = p;
         vp = p;
      }
      else
         vp = valb = p;
   }
   *bp0 = bp;
   return(valb);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static ATL_@(rt)node_t *ATL_Sort@up@(rt)NodesByMflop
(
   int imf,            /* which mflop entry to sort on */
   ATL_@(rt)node_t *bp    /* queue to be sorted */
)
/* 
 * kills original queue, and returns a greatest-to-least sorted queue
 * on p->mflop[imf].  Does it with O(N^2) alg, but if this is a bottleneck,
 * we never get here because timing takes an eternity.
 */
{
   ATL_@(rt)node_t *p, *prev, *sb=NULL;   /* ptr, prev, sorted base */
   ATL_@(rt)node_t *minp, *minprev;
   double mf;

/*
 * Sort from greatest-to-least by always adding smallest entry in old
 * list to head of greatest-to-least list
 */
   while (bp)
   {
/*
 *    Find slowest remaining kernel
 */
      mf = bp->mflop[imf];
      for (minp=prev=bp, p=bp->next; p; p = p->next)
      {
         if (p->mflop[imf] < mf)
         {
            minp = p;
            mf = p->mflop[imf];
            minprev = prev;
         }
         prev = p;
      }
/*
 *    Remove it from unsorted queue, and add as new head of sorted
 */
      if (minp == bp)
      {
         bp = bp->next;
         minp->next = sb;
      }
      else   /* in the middle of unsorted queue */
      {
         minprev->next = minp->next;
         minp->next = sb;
      }
      sb = minp;
   }
   return(sb);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static ATL_@(rt)node_t *Parse@up@(rt)Line(char *ln)
/*
 * Given a line from a @(rt) index file (with multiple lines pasted together
 * into one line (ln), return a structure describing that line.
 */
{
   ATL_@(rt)node_t *p;
   char *sp;
   int itmp;
   char ch;

   p = Get@up@(rt)Node();

@ROUT r1read mvread
@whiledef kk ldamul
   sp = strstr(ln, "@up@(kk)=");
   if (sp)
      p->@(kk) = atoi(sp+@len@(kk)+1);
   else
      p->@(kk) = 0;

@endwhile
@ROUT mmread
@whiledef jj vlen
   sp = strstr(ln, "@up@(jj)=");
   if (sp)
      p->@(jj) = atoi(sp+@len@(jj)+1);
   else
      p->@(jj) = 1;
@endwhile
@ROUT cpread
@whiledef jj mu nu
   sp = strstr(ln, "@up@(jj)=");
   if (sp)
      p->@(jj) = atoi(sp+@len@(jj)+1);
   else
      p->@(jj) = 1;
@endwhile
@whiledef jj vlen kvec ID STGID mb nb
   sp = strstr(ln, "@up@(jj)=");
   if (sp)
      p->@(jj) = atoi(sp+@len@(jj)+1);
   else
      p->@(jj) = 0;
@endwhile
@whiledef jj ALPHA BETA
   sp = strstr(ln, "@(jj)=");
   if (sp)
   {
      int cnt=0;
      sp += @len@(jj) + 1;
      GET_@(jj):
      {
         switch(*sp)
         {
         @mif jj = "BETA
         case '0':
            p->flag |= (1L<<CPF_@2l@(jj)0);
            break;
         @endmif
         case '1':
            p->flag |= (1L<<CPF_@2l@(jj)1);
            break;
         case 'N':
            p->flag |= (1L<<CPF_@2l@(jj)N);
            break;
         case 'X':
            p->flag |= (1L<<CPF_@2l@(jj)X);
            break;
         default:
            assert(0);
         }
      }
      if (*(++sp) == ',')
      {
         sp++;
         goto GET_@(jj);
      }
   }
@endwhile
@ROUT mmread
@whiledef jj mu nu ku kbmin kbmax pref ivar pfLS szExtra stgA stgB stgC blask
   sp = strstr(ln, "@up@(jj)=");
   if (sp)
      p->@(jj) = atoi(sp+@len@(jj)+1);
   else
      p->@(jj) = 0;
@endwhile
@whiledef jj kb nb mb
   sp = strstr(ln, "@up@(jj)=");
   if (sp)
      p->@(jj)B = atoi(sp+@len@(jj)+1);
   else
      p->@(jj)B = 0;
@endwhile
   @multidef jj ID SSE
@ROUT mvread r1read 
   @multidef jj ID MU NU minN minM alignX alignY alignA SSE CacheElts rankR
@ROUT r1read mvread mmread
@whiledef jj
   sp = strstr(ln, "@(jj)=");
   if (sp)
      p->@(jj) = atoi(sp+@len@(jj)+1);
   else
      p->@(jj) = 0;

@endwhile
@ROUT mmread
   sp = strstr(ln, "OPMV=");
   if (sp)
   {
      int imv;
      imv = atoi(sp+5);
      ATL_MMF_MVPUT(p->flag, imv);
   }
@multidef fl 
   X87 LDCTOP KRUNTIME AOUTER PFACOLS PFABLK PFBCOLS PFCELTS L14NB KVEC
   KUISKB NOBCAST BREG1 KCLN FKO COMPLEX
@endmultidef

@ROUT cpread
@multidef fl 
   TOBLK CBLK ABLK MVEC NVEC TRANS CONJ SINGLE REAL 
   SYRK SYMM TRSM TRMM
@endmultidef
@ROUT mvread
@multidef fl X87 LDYTOP ALLALIGNXY AXPYBASED GEMMBASED CONJDEF FNU ALIGNX2A ADDCFLAGS PFTUNABLE
@ROUT r1read
@multidef fl X87 ALLALIGNXY FNU INCYISONE ALIGNX2A ADDCFLAGS PFTUNABLE
@ROUT r1read mvread mmread cpread
@whiledef fl
   sp = strstr(ln, "@(fl)=");
   if (sp)
   {
      if (atoi(sp+@len@(fl)+1))
         p->flag |= (1<<@up@(rt)F_@(fl));
      else
         p->flag &= ~(1<<@up@(rt)F_@(fl));
   }
@endwhile

   sp = strstr(ln, "MFLOP=");
   if (sp)
@ROUT cpread
      GetDoubleArr(sp+6, 4, p->mflop);
@ROUT r1read mvread mmread
      GetDoubleArr(sp+6, 8, p->mflop);

   sp = strstr(ln, "ASM=");
   if (sp)
      p->asmbits = asmNames2bitfield(sp+4);


@ROUT mmread
@multidef TA TA TB
@ROUT mvread
@multidef TA TA 
@ROUT mvread mmread
@whiledef TA
   sp = strstr(ln, "@(TA)='");
   if (sp)
   {
      ch = tolower(sp[4]);
      if (ch == 'n')
         p->@(TA) = AtlasNoTrans;
      else if (ch == 'c')
         p->@(TA) = AtlasConjTrans;
      else if (ch == 't')
         p->@(TA) = AtlasTrans;
      else
         assert(0);
   }
@endwhile
@ROUT mvread r1read mmread cpread

@ROUT mvread r1read `@define kw @kname@`
@whiledef kw rout auth comp cflags
   sp = strstr(ln, "@up@(kw)='");
   if (sp)
      p->@(kw) = GetSingleQuoteString(sp+@len@(kw)+1);
   else
      p->@(kw) = NULL;

@endwhile
   return(p);
}

/* procedure 18 */
static void Print@up@(rt)Line(FILE *fpout, ATL_@(rt)node_t *np)
{
   int i, j, k;
   char ta, tb;

   if (!np)
      return;
   if (!np->rout)
      np->ID = 0;
@ROUT cpread
   if (np->rout)
      fprintf(fpout, "ID=%d STGID=%d ROUT='%s' AUTH='%s' \\\n   ", np->ID, 
              np->STGID, np->rout, np->auth?np->auth:"R. Clint Whaley");
   else
      fprintf(fpout, "ID=%d STGID=%d AUTH='%s' \\\n   ",
              np->ID, np->STGID, np->auth ? np->auth : "R. Clint Whaley");
   i = 3;
@ROUT r1read
   fprintf(fpout, "ID=%d ROUT='%s' AUTH='%s'",
           np->ID, np->rout ? np->rout : "generated", 
           np->auth ? np->auth : "R. Clint Whaley");
@ROUT mvread mmread
   if (np->TA == AtlasConjTrans) ta = 'C';
   else if (np->TA == AtlasTrans) ta = 'T';
   else ta = 'N';
@ROUT mvread
   fprintf(fpout, "ID=%d ROUT='%s' AUTH='%s' TA='%c'",
           np->ID, np->rout ? np->rout : "generated", 
           np->auth ? np->auth : "R. Clint Whaley", ta);
@ROUT mvread r1read
   if (np->kname)
      fprintf(fpout, " KNAME='%s' \\\n", np->kname);
   else
      fprintf(fpout, " \\\n");
@ROUT mmread
   if (np->TB == AtlasConjTrans) tb = 'C';
   else if (np->TB == AtlasTrans) tb = 'T';
   else tb = 'N';
   fprintf(fpout, "ID=%d ROUT='%s' AUTH='%s' TA='%c' TB='%c' \\\n",
           np->ID, np->rout ? np->rout : "generated", 
           np->auth ? np->auth : "R. Clint Whaley", ta, tb);

@ROUT mvread r1read mmread
   fprintf(fpout, "   ");
   i = 3;
@ROUT cpread
   @multidef ns 3     4
   @whiledef sc ALPHA BETA
   if (np->flag & CPF_ALL@3l@(sc))
   {
      int b, f = (np->flag >> CPF_@2l@(sc)1) & 15;
      int ch[4] = {'1', 'N', 'X', '0'};
      if (i > 70) { fprintf(fpout, " \\\n   "); i = 3; }
      for (k=0; k < @(ns); k++, f >>= 1)
         if (f&1)
            break;
      if (f&1)
      {
         i += fprintf(fpout, "@(sc)=%c", ch[k]);
         for (f >>= 1,k++; k < @(ns); k++, f >>= 1)
            if (f&1)
               i += fprintf(fpout, ",%c", ch[k]);
         i += fprintf(fpout, " ");
      }
   }
      @undef ns
   @endwhile
@whiledef kw mu nu vlen kvec mb nb
   if (np->@(kw))
   {
      if (i > 70) { fprintf(fpout, " \\\n   "); i = 3; }
      i += fprintf(fpout, "@up@(kw)=%d ", np->@(kw));
   }
@endwhile
@ROUT mvread r1read
@whiledef kw MU NU minN minM alignX alignY alignA SSE CacheElts rankR
   if (i > 70) { fprintf(fpout, " \\\n   "); i = 3; }
   i += fprintf(fpout, "@(kw)=%d ", np->@(kw));
@endwhile
@whiledef kw ldamul
   if (i > 70) { fprintf(fpout, " \\\n   "); i = 3; }
   i += fprintf(fpout, "@up@(kw)=%d ", np->@(kw));
@endwhile

@ROUT mmread 
   if (i > 70) { fprintf(fpout, " \\\n   "); i = 3; }
   i += fprintf(fpout, "OPMV=%d ", ATL_MMF_MVGET(np->flag));
@whiledef kw ivar kbmin kbmax pref pfLS vlen blask
   if (np->@(kw))
   {
      if (i > 70) { fprintf(fpout, " \\\n   "); i = 3; }
      i += fprintf(fpout, "@up@(kw)=%d ", np->@(kw));
   }
@endwhile
@whiledef kw mu nu ku
   if (i > 70) { fprintf(fpout, " \\\n   "); i = 3; }
   i += fprintf(fpout, "@up@(kw)=%d ", np->@(kw));
@endwhile

   @define kwd @@
   @multidef kw
      X87 LDCTOP KRUNTIME AOUTER PFACOLS PFABLK PFBCOLS PFCELTS L14NB KVEC
      KUISKB NOBCAST FKO KCLN BREG1 COMPLEX
   @endmultidef
@ROUT cpread
@multidef kw SYRK SYMM TRMM TRSM
@whiledef kw TOBLK CBLK ABLK MVEC NVEC TRANS CONJ SINGLE REAL
   if (FLAG_IS_SET(np->flag, @up@(rt)F_@(kw)))
   {
      if (i+@len@(kw) > 72) { fprintf(fpout, " \\\n   "); i = 3; }
      i += fprintf(fpout, "@(kw)=1 ");
   }
@endwhile
@ROUT r1read 
   @define kwd @X87 INCYISONE FNU ADDCFLAGS ALIGNX2A PFTUNABLE@
@ROUT mvread 
   @define kwd @X87 FNU LDYTOP ALLALIGNXY AXPYBASED GEMMBASED ADDCFLAGS ALIGNX2A PFTUNABLE@
@ROUT mmread
@whiledef jj kb nb mb
   if (i > 70) { fprintf(fpout, " \\\n   "); i = 3; }
   if (np->@(jj)B != 0)
      i += fprintf(fpout, "@up@(jj)=%d ", np->@(jj)B);
@endwhile
@ROUT mvread r1read mmread
@whiledef kw @(kwd)
   if (FLAG_IS_SET(np->flag, @up@(rt)F_@(kw)))
   {
      if (i+@len@(kw) > 72) { fprintf(fpout, " \\\n   "); i = 3; }
      i += fprintf(fpout, "@(kw)=1 ");
   }
@endwhile
@ROUT mvread r1read mmread cpread

   k = 0;  /* no need to write mflop */
@ROUT cpread `@define nmf @4@`
@ROUT mvread r1read mmread `@define nmf @8@`
   for (j=0; j < @(nmf); j++)
   {
      if (np->mflop[j] != 0.0)
      {
         k = 1;
         break;
      }
   }
   if (k)
   {
      if (i > 3) { fprintf(fpout, " \\\n   "); i = 3; }
      i += fprintf(fpout, "MFLOP=%le", np->mflop[0]);
      for (j=@(nmf)-1; j && np->mflop[j] == 0.0; j--);
      for (k=1; k <= j; k++)
         i += fprintf(fpout, ",%le", np->mflop[k]);
   }
   if (np->asmbits)
   {
      if (i > 40) { fprintf(fpout, " \\\n   "); i = 3; }
      for (j=0; !(np->asmbits & (1<<j)); j++);
      assert(j < NASMD);
      i += fprintf(fpout, "  ASM=%s", ASMNAM[j]);
      for (j++; j < NASMD; j++)
         if (np->asmbits & (1<<i))
            i += fprintf(fpout, ",%s", ASMNAM[j]);
   }
@whiledef kw comp cflags
   if (np->@(kw))
   {
      if (i+@len@(kw)+strlen(np->@(kw)) > 70) 
         { fprintf(fpout, " \\\n   "); i = 3; }
      i += fprintf(fpout, "  @up@(kw)='%s'", np->@(kw));
   }
@endwhile
   if (i)
      fprintf(fpout, "\n");
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static ATL_@(rt)node_t *Kill@up@(rt)NodesByFlag(int flag, int msk, ATL_@(rt)node_t *bp)
{
   ATL_@(rt)node_t *p=bp;
   while(p)
   {
      ATL_@(rt)node_t *next = p->next;
      if ((p->flag & msk) != (flag & msk))
        bp = Kill@up@(rt)NodeFromQ(bp, p);
      p = next;
   }
   return(bp);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static void Print@up@(rt)Nodes(FILE *fpout, ATL_@(rt)node_t *bp)
{
   while (bp)
   {
      Print@up@(rt)Line(fpout, bp);
      bp = bp->next;
   }
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static void Write@up@(rt)File(char *file, ATL_@(rt)node_t *nq)
{
   FILE *fpout;

   if (!file || !strcmp(file, "stdout"))
      fpout = stdout;
   else if (!strcmp(file, "stderr"))
      fpout = stderr;
   else
   {
      fpout = fopen(file, "w");
      assert(fpout);
   }
   Print@up@(rt)Nodes(fpout, nq);
   if (fpout != stdout && fpout != stderr)
      fclose(fpout);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static void Write@up@(rt)FileWithPath
   (char pre, char *path, char *file, ATL_@(rt)node_t *nq)
{
   char ln[2048];
   sprintf(ln, "%s/%c%s", path, pre, file);
   Write@up@(rt)File(ln, nq);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static ATL_@(rt)node_t *Read@up@(rt)File(char *file)
/*
 * Reads in a standard ATLAS parsable @up@(rt) index file, and returns a
 * list of all the kernels defined there.
 */
{
   ATL_@(rt)node_t *nq=NULL, *p;
   FILE *fpin;
   char *ln, *sp;
   int i, j, KeepOn, len;

   if (!file || !strcmp(file, "stdin"))
      fpin = stdin;
   else
      fpin = fopen(file, "r");
   if (!fpin)
      return(NULL);
   nq = p = Get@up@(rt)Node();
   while (ln = GetJoinedLines(fpin))
   {
      if (ln[0] != '#' && ln[0] != '\0')
      {
         p->next = Parse@up@(rt)Line(ln);
         p = p->next;
      }
   }
   fclose(fpin);
   return(Kill@up@(rt)Node(nq));
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static ATL_@(rt)node_t *Read@up@(rt)FileWithPath
   (char pre, char *path, char *file)
{
   char ln[2048];
   sprintf(ln, "%s/%c%s", path, pre, file);
   return(Read@up@(rt)File(ln));
}


@iexp ip @(ip) 1 +
/* procedure @(ip) */
static ATL_@(rt)node_t *DelRepeated@up@(rt)Kernels(ATL_@(rt)node_t *bp)
/*
 * Deletes any repeated IDs
 */
{
   ATL_@(rt)node_t *prev, *p, *np;
   int ID;

   for (p=bp; p; p = p->next)
   {
      ID = p->ID;
      prev = p;
      do
      {
         for (np=p->next; np && np->ID != ID; np = np->next)
            prev = np;
         if (np)  /* found duplicate */
            prev->next = Kill@up@(rt)Node(np);
      }
      while (np);
   }
   return(bp);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static ATL_@(rt)node_t *DelBadArch@up@(rt)Kernels(ATL_@(rt)node_t *bp)
/*
 * Weeds out kernels that require SSE/assembly that we haven't got
 */
{
   int asmb=0, die;
   ATL_@(rt)node_t *p, *prev;
@multidef sh          1         2        3        4          5        6       7         8
@whiledef asm GAS_x8632 GAS_x8664 GAS_SPARC GAS_PPC GAS_PARISC GAS_MIPS GAS_ARM GAS_ARM64
   #ifdef ATL_@(asm)
      asmb |= (1<<@(sh));
   #endif
   @undef sh
@endwhile

   prev = p = bp;
   while (p)
   {
      die = (p->asmbits) ? !(asmb & p->asmbits) : 0;
@ROUT mvread r1read mmread
      #ifndef ATL_SSE3
         if (p->SSE)
         {
            die |= (p->SSE >= 3);
            #ifndef ATL_SSE2
               die |= (p->SSE >= 2);
            #endif
            #ifndef ATL_SSE1
               die |= (p->SSE >= 1);
            #endif
         }
      #endif
@ROUT mvread r1read mmread cpread
      if (die) 
      {
         if (p == bp) 
            bp = p = Kill@up@(rt)Node(p);
         else 
            prev->next = p = Kill@up@(rt)Node(p);
      }
      else
      {
         prev = p;
         p = p->next;
      }
   }
   return(bp);
}

@ROUT mvread r1read
#define MAXBASES 4
@iexp ip @(ip) 1 +
/* procedure @(ip) */
static int ATL_@up@(rt)SplitContexts
(
   ATL_@(rt)node_t *kb,   /* pointer to all read in kernels */
   ATL_@(rt)node_t **ocb, /* set to all out-of-cache kernels */
   ATL_@(rt)node_t **i2b, /* set to all in-L2 kernels */
   ATL_@(rt)node_t **i1b, /* set to all in-L1 kernels */
   ATL_@(rt)node_t **syb  /* NULL, or all SYR/SYR2 kernels (may not exist) */
)
/*
 *  Takes unified bp, and splits it into separate pieces.  bp is invalidated
 *  in the process (is split into child queues)
 *  RETURNS: number of children found
 */
{
   ATL_@(rt)node_t *kp, *kn;
   ATL_@(rt)node_t *bases[MAXBASES] = {NULL, NULL, NULL, NULL};
   int nbases;

/*
 * Kernels come as a series of kernels that are ranked by efficiency from
 * high to low based on the integer rankR.  All series must end with a
 * general kernel with no restrictions with a rankR of 0 (all non-zero
 * kernels have restrictions).  This loop splits these kernels into 
 * their seperate series (series indicates calling context).
 */
   kn = kb;
   nbases = 0;
   while (kn)
   {
      bases[nbases++] = kn;
      for (kp=kn; kp && kp->rankR; kp = kp->next);  /* find end of series */
      if (!kp)
         break;
      kn = kp->next;
      kp->next = NULL;
   }
   if (ocb)
      *ocb = bases[0];
   else
      KillAll@up@(rt)Nodes(bases[0]);
   if (i2b)
      *i2b = bases[1];
   else
      KillAll@up@(rt)Nodes(bases[1]);
   if (i1b)
      *i1b = bases[2];
   else
      KillAll@up@(rt)Nodes(bases[2]);
   if (syb)
      *syb = bases[3];
   else
      KillAll@up@(rt)Nodes(bases[3]);
   return(nbases);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static ATL_@(rt)node_t *ATL_@up@(rt)LinkContexts
(
   ATL_@(rt)node_t *kp1, /* all out-of-cache kernels */
   ATL_@(rt)node_t *kp2, /* all in-L2 kernels */
   ATL_@(rt)node_t *kp3, /* all in-L1 kernels */
   ATL_@(rt)node_t *kp4  /* all SYR/SYR2 kernels */
)
/*
 *  Takes separate queue, and joins them into one long queue; if any
 *  is NULL, all remaining cases must also be NULL!
 *  Seperate queues are subsumed into returned queue
 */
{
   ATL_@(rt)node_t *kps[MAXBASES] = {kp1, kp2, kp3, kp4};
   ATL_@(rt)node_t *kp, *kprev;
   int i, j;

   for (i=0; i < MAXBASES-1; i++)
   {
      if (!kps[i])
      {
         for (j=i+1; j < MAXBASES; j++)
            assert(!kps[j]);
         return(kp1);
      }
      for (kp=kps[i]; kp->next; kp = kp->next);
      kp->next = kps[i+1];
   }
   return(kp1);
}
#undef MAXBASES

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static ATL_@(rt)node_t *FindFastest@up@(rt)Kernel
(  char pre,             /* precision prefix */
   ATL_@(rt)node_t *bp,  /* kernel queue */
   int imf,              /* which mflop entry to sort by */
   int RESTRICTOK        /* consider restricted kernel? */
)
/*
 * A RESTRICTed kernel is one that requires something that can't be fixed
 * by loop peeling or the like.  Examples include forcing lda to a given
 * multiple, or 16-byte alignment for double complex (can't peel 1/2 of
 * a complex number to make 8-byte aligned array 16).
 * RETURNS: pointer to node in bp that is fastest in context imf wt RESTRCT
 */
{
   double mf;
   ATL_@(rt)node_t *kp, *kmax=bp;
   int size, usize, RKERN;

   if (bp)
   {
      usize = (pre == 'c' || pre == 's') ? 4 : 8;
      if (pre == 'c' || pre == 'd') size = 8;
      else if (pre == 's') size = 4;
      else size = 16;
      mf = bp->mflop[imf];
      for (kp=bp->next; kp; kp = kp->next)
      {
         if (kp->mflop[imf] > mf)
         {
            RKERN = (pre == 'z' || pre == 'c') ? (kp->alignA > usize) : 0;
            RKERN = RKERN | (kp->ldamul > size);
            if (RESTRICTOK | !RKERN)
            {
               mf = kp->mflop[imf];
               kmax = kp;
            }
         }
      }
   }
   return(kmax);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static int @up@(rt)flag2size(int flag)
/*
 * RETURNS: size of type using precision/type bits in flag
 */
{
   int size;

   size = FLAG_IS_SET(flag, @up@(rt)F_SINGLE) ? 4 : 8;
   size *= FLAG_IS_SET(flag, @up@(rt)F_COMPLEX) ? 2 : 1;
   return(size);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static char @up@(rt)flag2pre(int flag)
/*
 * RETURNS: correct precision/type prefix based on flag
 */
{
   char pre = 'd';
   if (FLAG_IS_SET(flag, @up@(rt)F_SINGLE))
      return(FLAG_IS_SET(flag, @up@(rt)F_COMPLEX) ? 'c' : 's');
   return(FLAG_IS_SET(flag, @up@(rt)F_COMPLEX) ? 'z' : 'd');
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static int pre2@up@(rt)flag(char pre, int flag)
/*
 * RETURNS: flag modified to reflect type/precision indicated by pre
 */
{
   SET_FLAG(flag, @up@(rt)F_COMPLEX, (pre == 'c' || pre == 'z'));
   SET_FLAG(flag, @up@(rt)F_SINGLE, (pre == 'c' || pre == 's'));
   return(flag);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static void SetAll@up@(rt)TypeFlags(char pre, ATL_@(rt)node_t *bp)
{
   ATL_@(rt)node_t *p;
   for (p=bp; p; p = p->next)
      p->flag = pre2@up@(rt)flag(pre, p->flag);
}
@ROUT r1read

@iexp ip @(ip) 1 +
/* procedure @(ip) */
void PutKernNameInStr(ATL_@(rt)node_t *r1B)
/*
 * Fills in the proper name for all kernels in r1->str
 */
{
   char ln[32] = {"ATL_dgerk_L0_restrict"};
   char pre;
   const int ipre=4, iL=11, irest=12;

   pre = @up@(rt)flag2pre(r1B->flag);
   ln[ipre] = pre;
   r1B->str = DupString(ln);
   ln[irest] = '\0';
   r1B->next->str = DupString(ln);
   ln[irest] = '_';
   r1B = r1B->next->next;

   ln[iL] = '2';
   r1B->str = DupString(ln);
   ln[irest] = '\0';
   r1B->next->str = DupString(ln);
   ln[irest] = '_';
   r1B = r1B->next->next;

   ln[iL] = '1';
   r1B->str = DupString(ln);
   ln[irest] = '\0';
   r1B->next->str = DupString(ln);
   ln[irest] = '_';
   r1B = r1B->next->next;

   sprintf(ln, "ATL_%cgerk_L1b_restrict", pre);
   r1B->str = DupString(ln);
   ln[irest+1] = '\0';
   r1B->next->str = DupString(ln);
}

@beginskip
@iexp ip @(ip) 1 +
/* procedure @(ip) */
ATL_r1node_t *GetSortedUniqueR1Kerns
   (char pre, ATL_r1node_t *r1kerns, char **aliases)
/*
 * Takes the 8-length queue of rank-1 update kernels:
 *    First 2 are restricted and normal GER out-of-cache kernels
 *    next 2 are restricted & normal in-L2 GER kernels
 *    next 2 are restristed & normal in-L1 GERM kernels
 *    next 2 are restristed & normal out-of-cache, L1-blocked kernels
 *
 * ALIASES: a null-terminated list of string pointers, where pairs
 *          of strings give the correct aliasing: 1st entry is the
 *          routine to be aliased, 2nd is what it should be aliased to.
 *          Every kernel that uses the same actual routine as another
 *          in the 8-length queue is deleted, and a #define is used
 *          to call the appropriate kernel, to avoid unnecessary
 *          code size expansion.
 *          If ALIASES is NULL, then ALIASES is not accessed.
 *          ALIASES must be at least 15 pointers long.
 *
 * RETURNS: new queue with only the unique kernels left (unrestricted
 *          kernels appear first in list), and the p->str entry having
 *          the correct routine/file name.  
 * NOTE   : Leaves the original queue intact.
 */
{
   ATL_r1node_t *r1b, *r1p, *r1k, *r1prev;
   char *kern = "gerk";
   int i, ialias=0;
   char *suff[8] = {"_L0", "_L0_restrict", "_L2", "_L2_restrict",
                    "_L1", "_L1_restrict", "_L1b", "_L1b_restrict"};

@skip   kern = (pre == 'z' || pre == 'c') ? "geru" : "ger";
/*
 * Make sure all routines are present, and there are no extra
 */
  for (i=0, r1p = r1kerns; i < 8; i++, r1p=r1p->next)
     assert(r1p);
  assert(!r1p);
/* 
 * Build new queue with the "normal" kernels first
 */
   r1b = CloneR1Node(r1kerns->next);
   r1b->next = r1p = CloneR1Node(r1kerns);
   r1p->next = CloneR1Node(r1kerns->next->next->next);
   r1p->next->next =  CloneR1Node(r1kerns->next->next);
   r1p = r1p->next->next;
   r1p->next = CloneR1Node(r1kerns->next->next->next->next->next);
   r1p->next->next = CloneR1Node(r1kerns->next->next->next->next);
   r1p = r1p->next->next;
   r1p->next = CloneR1Node(r1kerns->next->next->next->next->next->next->next);
   r1p->next->next = CloneR1Node(r1kerns->next->next->next->next->next->next);
   r1p->next->next->next = NULL;
/*
 * Label queue entries with proper kernel names
 */
   for (i=0,r1p = r1b; i < 8; i++, r1p = r1p->next)
   {
       r1p->str = malloc(32*sizeof(char));
       assert(r1p->str);
       sprintf(r1p->str, "ATL_%c%s%s", pre, kern, suff[i]);
   }
/* 
 * Add duplicated kernels to alias array, and then get rid of them from Q
 */
   r1prev = r1b;
   r1p = r1b->next;
   while (r1p)
   {
      for (r1k=r1b; r1k != r1p; r1k = r1k->next)
         if (r1k->ID == r1p->ID) break;
      if (r1k != r1p)  /* got duplicate */
      {
         if (aliases)
         {
            aliases[ialias++] = r1p->str;
            r1p->str = NULL;
            aliases[ialias++] = DupString(r1k->str);
         }
         r1prev->next = r1p = KillR1Node(r1p);
      }
      else
      {
        r1prev = r1p;
        r1p = r1p->next;
      }
   }
   if (aliases)
      aliases[ialias] = NULL;
   return(r1b);
}
@endskip
@ROUT mvread
@iexp ip @(ip) 1 +
/* procedure @(ip) */
static void SortByTrans
(
   ATL_@(rt)node_t *bp,    /* original kernels wt mixture of trans cases */
   ATL_@(rt)node_t **bN0,  /* No trans cases */
   ATL_@(rt)node_t **bT0,  /* trans cases */
   ATL_@(rt)node_t **bNC0, /* ConjNotrans cases */
   ATL_@(rt)node_t **bTC0  /* Conjtrans cases */
) 
/*
 * Sorts bp into the separate transpose queues, destroying bp in the process.
 * If a bp entry has the CONJDEF property, then its entry is duplicated to
 * put it on both queues (it can be used for normal and conjugate cases).
 */
{
   ATL_@(rt)node_t *bN=NULL, *bT=NULL, *bNC=NULL, *bTC=NULL,
                   *p, *next, *new;

   for (p=bp; p; p = next)
   {
      next = p->next;
      if (p->TA == AtlasNoTrans)
      {
         p->next = bN;
         bN = p;
         #ifdef TCPLX
            if (p->flag & (1<<@up@(rt)F_CONJDEF))
            {
               new = Clone@up@(rt)Node(p);
               new->TA = AtlasConj;
               new->next = bNC;
               bNC = new;
            }
         #endif
      }
      else if (p->TA == AtlasTrans)
      {
         p->next = bT;
         bT = p;
         #ifdef TCPLX
            if (p->flag & (1<<@up@(rt)F_CONJDEF))
            {
               new = Clone@up@(rt)Node(p);
               new->TA = AtlasConjTrans;
               new->next = bTC;
               bTC = new;
            }
         #endif
      }
   #ifdef TCPLX
      else if (p->TA == AtlasConjTrans)
      {
         p->next = bTC;
         bTC = p;
      }
      else /* TA == AtlasConj */
      {
         p->next = bNC;
         bNC = p;
      }
   #endif
   }
   *bN0 = bN;
   *bT0 = bT;
   *bNC0 = bNC;
   *bTC0 = bTC;
}
@ROUT mmread

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static int MMKernsCompat(ATL_mmnode_t *p0, ATL_mmnode_t *p1)
/*
 * RETURNS: 1 if kernels have compatible storage for A,B & C, 0 otherwise
 */
{
   @whiledef tv stgA stgB stgC mu nu blask
   if (p0->@(tv) != p1->@(tv))
      return(0);
   @endwhile
   if ((p0->flag | p1->flag)&(1<<MMF_KVEC)) /* KVEC routs have additional req */
   {
      if (p0->flag&(1<<MMF_KVEC) != p1->flag&(1<<MMF_KVEC))
         return(0);
      if (p0->vlen != p1->vlen)
         return(0);
   }
   return(1);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static int MMKernCleansK(ATL_mmnode_t *p0, ATL_mmnode_t *p1)
/*
 * RETURNS: 1 if p1 can provide K-cleanup for p0, else 0
 * NOTE: upper 3 bits of p->flag must indicate whether KU=4,3,2 are legeal
 *       KU for cleanup (most sig to least).  If any kbB that kern p0 is used
 *       for is not a multiple of a given KU, then it is ruled out, and so has
 *       this bit unset.
 * To do K-cleanup in our scheme, MAX(ku, kbmin) <= 4, kbmax == 0, K must
 * by a runtime variable, and it must have the same storage for all matrices.  
 * We could avoid requiring same  A/B storage, but this would require using
 * different copy routs for KB0 blk, which would stress i-cache even worse, 
 * and might force us to bring in more copy funcs overall.  Since mu/nu 
 * present in C, this relaxation wouldn't help much anyway, so blow it off.
 * If we wanted to support this, could occasionally use an Mvec kernel to
 * clean a KVEC, or vice versa.
 */
{
   if (!p0 || !p1)
      return(0);
   if (p1->kbmax != 0)
      return(0);
   if (!FLAG_IS_SET(p1->flag, MMF_KRUNTIME))
      return(0);
   if (FLAG_IS_SET(p0->flag, MMF_KVEC)) /* K-vectorized ops on vlen muls */
   {
      if (p1->kbmin && p1->kbmin != p0->vlen)
         return(0);
      if (p1->ku != p0->vlen) /* remember, vlen's must be same p0/p1 */
         return(0);
   }
   else /* M/N vectorized */
   {
      const int KU=p1->ku;
      if (p1->kbmin > KU)  /* kernel must handle all K cases, incl KU! */
         return(0);
      if (KU > 1)
      {
         if (KU > 4)
            return(0);
         if (!(p0->flag & (1<<(31+KU-4))))
            return(0);
      }
   }
   return(MMKernsCompat(p0, p1));
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
ATL_mmnode_t *MMGetGenCaseKClean(ATL_mmnode_t *mp)
/*
 * RETURNS: generator-supported case for K-cleanup for p0
 * genstr & filename left unset so user can specialize further
 */
{
   ATL_mmnode_t *gp;
   if (mp->stgA || mp->stgB || mp->stgC)  /* can't generate for formats */
      return(NULL);                       /* gen doesn't understand */
   gp = GetMMNode();
   @whiledef vr mu nu mbB nbB kbB blask vlen
   gp->@(vr) = mp->@(vr);
   @endwhile
   gp->flag = mp->flag & (MMF_MVSET | (1<<MMF_KVEC));
   gp->flag |= 1<<MMF_KRUNTIME;
/*
 * May have problem if generator doesn't support VLEN!
 */
   if (FLAG_IS_SET(mp->flag, MMF_KVEC))
      gp->ku = mp->vlen;
   else
      gp->ku = 1;
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
ATL_mmnode_t *MMCompatKernPresent(ATL_mmnode_t *mb, ATL_mmnode_t *mt)
/*
 * RETURNS: ptr to mt-storage-compatible node in mb, else NULL
 */
{
   ATL_mmnode_t *mp;
   for (mp=mb; mp; mp = mp->next)
      if (MMKernsCompat(mt, mp))
         return(mp);
   return(NULL);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static int MMKernsSame(ATL_mmnode_t *p0, ATL_mmnode_t *p1)
/*
 * RETURNS: 1 if kernels are the same except for blocking, 0 otherwise
 */
{
   const int flg0=p0->flag&MMF_DIFFMSK, flg1=p1->flag&MMF_DIFFMSK;
/*
 * Two generated kernels are the same if mu,nu,ku,VLEN,flag are the same.
 * However, if KUISKB, generated kernels with differing KBs are not same!
 * NOTE: pref & pfLS do not affect output, and so are not checked!
 * NOTE: any extension of generator functionality should extend this check!
 */
   if (p0->ID == 0 && p1->ID == 0)
   {
      if (FLAG_IS_SET(p0->flag, MMF_KUISKB) && p0->kbB != p1->kbB)
         return(0);
      return(p0->mu == p1->mu && p0->nu == p1->nu && p0->ku == p1->ku &&
             p0->vlen == p1->vlen && flg0 == flg1);
   }
/*
 * If both are user kernels, then they may be repeats.  For user kernels,
 * they are the same if both ID and flag match, else they are not.
 */
   else if (p0->ID > 0 && p1->ID > 0)
      return(p0->ID == p1->ID && flg0 == flg1);
   return(0);  /* Can't be the same if above criteria fails */
}
@iexp ip @(ip) 1 +
/* procedure @(ip) */
static int MMKernsPerfSame(ATL_mmnode_t *p0, ATL_mmnode_t *p1)
/*
 * ignoring blocking params, are kernels the same?  This version does not
 * ignore setting that effect only performance (eg, prefetch settings).
 */
{
   if (p0->ID == 0 && p1->ID == 0 && 
       (p0->pref != p1->pref || p0->pfLS != p1->pfLS))
      return(0);
   return(MMKernsSame(p0, p1));
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static int MMKernCompsSame(ATL_mmnode_t *p0, ATL_mmnode_t *p1)
/*
 * RETURNS: 1 if kernels are the same including KB, else 0
 */
{
/*
 * Kernels are not the same if one has compile-time K and other runtime
 */
   if (FLAG_IS_SET(p0->flag, MMF_KRUNTIME) != 
       FLAG_IS_SET(p1->flag, MMF_KRUNTIME))
      return(0);
/*
 * Kernels not same if both compile-time K with differing KB
 */
   if (!FLAG_IS_SET(p0->flag, MMF_KRUNTIME) && p0->kbB != p1->kbB)
      return(0);
/*
 * Generated kernels aren't same if prefetch is different
 */
   if ((p0->ID | p1->ID) == 0 && (p0->pref != p1->pref || p0->pfLS != p1->pfLS))
      return(0);
   return(MMKernsSame(p0, p1));
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static ATL_mmnode_t *MMKernIsPresent(ATL_mmnode_t *mmb, ATL_mmnode_t *mmp)
/*
 * RETURNS: 1 if kernel compilation matching mmp is in list mmb, 0 otherwise
 */
{
   ATL_mmnode_t *mp;
   for (mp=mmb; mp; mp = mp->next)
      if (MMKernsSame(mmp, mp))
         return(mp);
   return(NULL);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
ATL_mmnode_t *MMGetKCleanQ(ATL_mmnode_t *db, ATL_mmnode_t *mb)
/*
 * RETURNS: new queue with cloned nodes from mb that can clean any kernel
 *          present in db
 */
{
   ATL_mmnode_t *dp, *kb=NULL;;
   for (dp=db; dp; dp = dp->next)
   {
      ATL_mmnode_t *mp;
      mp = mb;
      while ( (mp = MMCompatKernPresent(mp, dp)) )
      {
         if (!MMKernIsPresent(kb, mp))
         {
            ATL_mmnode_t *np;
            np = CloneMMNode(mp);
            np->next = kb;
            kb = np;
         }
         mp = mp->next;
      }
   }
   return(kb);
}


@iexp ip @(ip) 1 +
/* procedure @(ip) */
static ATL_mmnode_t *MMKernCompIsPresent(ATL_mmnode_t *mmb, ATL_mmnode_t *mmp)
/*
 * RETURNS: ptr to kernel compilation matching mmp is in list mmb, else NULL 
 */
{
   ATL_mmnode_t *mp;
   for (mp=mmb; mp; mp = mp->next)
      if (MMKernCompsSame(mmp, mp))
         return(mp);
   return(NULL);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static ATL_mmnode_t *MMPerfKernIsPresent(ATL_mmnode_t *mmb, ATL_mmnode_t *mmp)
/*
 * RETURNS: 1 if kernel compilation matching mmp is in list mmb, 0 otherwise
 */
{
   ATL_mmnode_t *mp;
   for (mp=mmb; mp; mp = mp->next)
      if (MMKernsPerfSame(mmp, mp))
         return(mp);
   return(NULL);
}

@define pp @@
@whiledef pp Perf
@iexp ip @(ip) 1 +
/* procedure @(ip) */
static ATL_mmnode_t *AddUnique@(pp)MMKernsToList
   (ATL_mmnode_t *mmb, ATL_mmnode_t *newb)
/*
 * RETURNS: mmb with any kernels present in newb that aren't in mmb added to it
 * (1) changes mmb, does not change newb
 * (2) new nodes are added to BEGINNING of mmb (leaving mmb unsorted)!
 */
{
   ATL_mmnode_t *mp;
      
   for (mp=newb; mp; mp = mp->next)
   {
      ATL_mmnode_t *p;
      p = MM@(pp)KernIsPresent(mmb, mp);
      if (p)
         p->flag |= mp->flag & MMF_STKBTS;
      else
      {
         p = CloneMMNode(mp);
         p->next = mmb;
         mmb = p;
      }
   }
   return(mmb);
}
@endwhile

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static ATL_mmnode_t *AddUniqueMMKernCompList
   (ATL_mmnode_t *mmb, ATL_mmnode_t *newb)
/*
 * RETURNS: mmb with any kerncomps present in newb that aren't in mmb added 
 *          to it
 * (1) changes mmb, does not change newb
 * (2) new nodes are added to BEGINNING of mmb (leaving mmb unsorted)!
 */
{
   ATL_mmnode_t *mp;
   for (mp=newb; mp; mp = mp->next)
   {
      ATL_mmnode_t *p;
      p = MMKernCompIsPresent(mmb, mp);
      if (p)
         p->flag |= mp->flag & MMF_STKBTS;
      else
      {
         p = CloneMMNode(mp);
         p->next = mmb;
         mmb = p;
      }
   }
   return(mmb);
}
@iexp ip @(ip) 1 +
/* procedure @(ip) */
int MMNamelen(char pre, char *nm, ATL_mmnode_t *mp, int kb)
{
   int len=5;                         /* ATL_<pre> */

   len = strlen(nm);
   if (len == 4)  /* may be non-gemm kernel (eg., syrk, trmm) */
   {              /* only one of these, so it gets fixed name */
      if (nm[0] == 's' && nm[1] == 'y' && nm[2] == 'r' && nm[3] == 'k')
         return(12); /* ATL_<pre>amsyrkK */
   }
   len += 5;  /* ATL_<pre> */

   len += NumDecDigits(mp->ID);       /* ATL_<pre><nm><ID> */
   len += 1 + NumDecDigits(kb);       /* ATL_<pre><nm><ID>_<kb> */
   len += 1 + NumDecDigits(mp->vlen); /* +[m,k]<vlen>, V=[m,k]*/
   len += 1 + NumHexDigits(mp->pref); /* +p<pref> */
   len += 1 + NumDecDigits(mp->pfLS); /* +x<LS> */
   len += 1 + NumHexDigits(mp->flag); /* +_<flg> */
   len += 1 + NumDecDigits(mp->mu);   /* +_mu */
   len += 1 + NumDecDigits(mp->nu);   /* +_nu */
   len += 1 + NumDecDigits(mp->ku);   /* +_ku */
   return(len);     /* string terminator/beta/file ext not included! */
} /* ATL_<pre><nm><ID>_<kb>[m,n]<vlen>p<pf>x<LS>_<flg>_MUxNUxKU */

/*
 * A kernel name is how a kernel is called from code, and is set by 
 * redefining ATL_USERMM, so we see that it can be unrelated to filename.
 * However, during install we will make all filenames the same as the
 * kernel name, with the following exceptions:
 * 1. _bX is done through recompilation, so is replaced by file ext (.c, etc.)
 * 2. KB will not match the kernel name in the (a,b) cases below:
 *    a. For ID != 0, KB is always 0 (same source file used regardless of
 *       compile flags, etc).
 *    b. For kerns that that need compile-time K, but can simply be recompiled
 *       for each differing KB, we will encode KB=1 (never a valid KB).
 *    c. For kerns taking a runtime KB, KB is 0
 *    d. For kerns that only supply an exact KB, KB is set to mp->kbB.
 * 
 * During installation, we can use mp->str to temporarily store the filename,
 * while we use mp->rout to store the kernel (call) name, w/o beta suffix.
 */
@iexp ip @(ip) 1 +
/* procedure @(ip) */
int SprintMMName(char *name, char pre, char *nm, ATL_mmnode_t *mp, int kb)
/*
 * kb >= 0 : print kb in name, else don't
 */
{
   int i, ku=mp->ku;
   unsigned int flag = mp->flag & MMF_DIFFMSK;

@skip   if (nm[0] == 's' && nm[1] == 'y' && nm[2] == 'r' && nm[3] == 'k')
   if (mp->blask == 1)
   {
      strcpy(name, "ATL_XamsyrkK");
      name[4] = pre;
      return(12);
   }
   if (FLAG_IS_SET(mp->flag, MMF_KUISKB))
      ku = mp->kbB;
   /* ATL_<pre><nm><ID>_kb[m,n]<vlen>p<pf>x<LS>_<flg>_MUxNUxKU */
   i = sprintf(name, "ATL_%c%s%d_%d%c%dp%xx%d_%x_%dx%dx%d", pre, nm, mp->ID, kb,
               FLAG_IS_SET(mp->flag, MMF_KVEC) ? 'k':'m', mp->vlen,
               mp->pref, mp->pfLS, flag, mp->mu, mp->nu, mp->ku);
   return(i);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static char *GetMMKernName(char pre, char *nm, ATL_mmnode_t *mp)
/*
 * Get a string of form ATL_<pre><nm>suff, where suff encodes all info
 * required to differentiate between amm kernels.  Name must be suffixed
 * later with _b[n,1,0] to be fully qualified, and there is room left in
 * string to add that.
 */
{
   int i, h, kb=0;
   char *name;

   if (FLAG_IS_SET(mp->flag,MMF_KUISKB) || !FLAG_IS_SET(mp->flag,MMF_KRUNTIME))
      kb = mp->kbB;
   i = MMNamelen(pre, nm, mp, kb);
   name = malloc(i+3+1);  /* 3 for beta name, +1 is for string terminator */
   assert(name);
   h = SprintMMName(name, pre, nm, mp, kb);
   assert(h <= i);
   return(name);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
char *GetMMLabelName(char pre, ATL_mmnode_t *mp)
/*
 * This func used to get a decent filename during search for printing.  A given search
 * doesn't have to worry about malloc/dealloc, can just call wt NULL when done
 */
{
   static char *nm=NULL;
   static int L=0;
   int nL;
   if (!mp)
   {
      free(nm);
      nm = NULL;
      L = 0;
      return(NULL);
   }
   if (mp->ID && mp->rout)
      return(mp->rout);
   nL = MMNamelen(pre, "amm", mp, mp->kbB);
   if (nL > L)
   {
      free(nm);
      nm = GetMMKernName(pre, "amm", mp);
   }
   else
   {
      nL = SprintMMName(nm, pre, "amm", mp, mp->kbB);
      assert(nL <= L);
   }
   return(nm);
}
@iexp ip @(ip) 1 +
/* procedure @(ip) */
static char *GetMMFilename(char pre, char *nm, ATL_mmnode_t *mp)
/*
 * Get a string of form ATL_<pre><nm>suff, where suff encodes all info
 * required to differentiate between amm kernels
 */
{
   int i, h, kb, flg, pf, pfLS;
   char *name;

   if (mp->ID)
#ifdef ATL_GENERATE  /* generators get real name */
      kb = 0;
#else  /* tuners get default name */
      return(DupString("ATL_tmp.c"));
#endif
   else if (FLAG_IS_SET(mp->flag, MMF_KUISKB))
      kb = mp->kbB;
   else if (FLAG_IS_SET(mp->flag, MMF_KRUNTIME))
      kb = 0;
   else
      kb = 1;
@skip   else if (!FLAG_IS_SET(mp->flag, MMF_KRUNTIME))
@skip      kb = (mp->kbmax != mp->kbB || mp->kbmin != mp->kbB) ? 1 : mp->kbB;
   flg = mp->flag;
   pf = mp->pref;
   pfLS = mp->pfLS;
   if (mp->ID)       /* pref & flag don't matter for non-genned filenames */
      mp->pref = mp->pfLS = mp->flag = 0;
   else  /* remove from flag all non-filename vals */
      mp->flag &= ~(MMF_MVSET|(1<<MMF_KCLN)|(MMF_ALLTRANS));
   i = MMNamelen(pre, nm, mp, kb); 
   name = malloc(i+2+1);           /* 2 file ext, 1 str term */
   assert(name);
   h = SprintMMName(name, pre, nm, mp, kb);
   mp->flag = flg;  /* restore flag/pref to correct vals */
   mp->pref= pf;
   mp->pfLS = pfLS;
   assert(h <= i);
   name[h] = '.';
   if (mp->ID == 0)
      name[h+1] = 'c';
   else if (FLAG_IS_SET(mp->flag, MMF_FKO))
      name[h+1] = 'B';
   else if (mp->rout) /* user supplied kern, get ext from orig name */
   {
      int k;
      k = strlen(mp->rout)-1;
      assert(mp->rout[k-1] == '.');
      name[h+1] = mp->rout[k];
   }
   else /* user-supplied w/o name, assume C */
      name[h+1] = 'c';
   name[h+2] = '\0';
   return(name);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static int MMSplitByFlagAny
(
   const int mask,      /* if any flags in mask are present, kern->KFLG */
   ATL_mmnode_t **MMB,  /* IN/OUT: original base ptr */
   ATL_mmnode_t **KFLG  /* IN/OUT: base ptr for all runtime-K kerns  */
)
/*
 * Splits original list MMB wt kerns wt any bit in mask set moved to KFLG,
 * while rest emain in MMB.  This possibly changes both lists, though no node
 * is lost.
 * RETURNS: number of nodes removed from MMB and added to KFLG
 */
{
   ATL_mmnode_t *mb=(*MMB), *kb=(*KFLG), *mp;
   int nk=0, nxtoff, bvoff;

   nxtoff = GetOffset(&mb->next, mb);
   bvoff =  GetOffset(&mb->flag, mb);
   while ( (mp = FindNodeWithMaskOR(mb, nxtoff, bvoff, mask)) )
   {
      mb = RemoveNodeFromList(mb, mp, nxtoff);
      mp->next = kb;
      kb = mp;
      nk++;
   }
   *MMB = mb;
   *KFLG = kb;
   return(nk);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static void MMApplyMoves2Flags
(
   ATL_mmnode_t *mmb,  /* kernel to set MMF_MV[A,B,C] flag bits */
   int mvBits          /* last 3 bits: MOVE_[CBA] */
)
{
   const unsigned int mvMSK = ~MMF_MVSET, mvSET = (mvBits&7)<<MMF_MVA;
   ATL_mmnode_t *mmp;
   for (mmp=mmb; mmp; mmp = mmp->next)
      mmp->flag = ((mmp->flag) & mvMSK) | mvSET;
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
void MMIvar2str(ATL_mmnode_t *mb)
/*
 * Sets str to point to the mmnode of the K cleaner; str is NULL if the routine
 * does not need K cleanup.  If it is self-cleaning, gets its own node address.
 * For any non-self-cleaning node needing cleanup, ivar is set to -1.
 */
{
   ATL_mmnode_t *mp;
   for (mp=mb; mp; mp = mp->next)
   {
      if (FLAG_IS_SET(mp->flag, MMF_KCLN))
      {
         if (mp->str)
            free(mp->str);
         if (mp->ivar == 0)
            mp->str = (char*) mp;   
         else
         {
            const int cnt = mp->ivar - 1;
            int i;
            ATL_mmnode_t *kp;
            for (i=0, kp=mb; i < cnt && kp; kp = kp->next, i++);
            assert(kp);
            mp->str = (char*) kp;
            mp->ivar = -1;
         }
      }
      else
         mp->str = NULL;
   }
}
@iexp ip @(ip) 1 +
/* procedure @(ip) */
void MMstr2Ivar(ATL_mmnode_t *mb)
/*
 * Sets ivar according to p->str: if p->str=NULL, or p = p->str, ivar=0, else
 * ivar equals the index in mb of the K cleanup routine.  Note ivar actually
 * stores idx+1, so 0 means no externel K clean required.
 */
{
   ATL_mmnode_t *mp;

   for (mp=mb; mp; mp = mp->next)
   {
      mp->ivar = 0;
      if (mp->str && mp != (void*)mp->str)
      {
         int cnt;
         ATL_mmnode_t *p, *fnd=(void*)mp->str;
         for (cnt=0, p=mb; p && p != fnd; cnt++, p = p->next);
         assert(p);
         mp->ivar = cnt + 1;
      }
      mp->str = NULL;
   }
}
@iexp ip @(ip) 1 +
/* procedure @(ip) */
ATL_mmnode_t *MMFindKCleanStr(ATL_mmnode_t *mb)
/*
 * RETURNS: first node with str that is not NULL or equal to node address.
 */
{
   ATL_mmnode_t *mp;
   for (mp=mb; mp; mp = mp->next)
   {
      if (mp->str && mp->str != (void*)mp)
         return(mp);
   }
   return(NULL);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
ATL_mmnode_t *MMFindStrMatch(ATL_mmnode_t *mb, void *st)
/*
 * RETURNS: first node with str equal to st
 */
{
   ATL_mmnode_t *mp;
   for (mp=mb; mp; mp = mp->next)
      if (mp->str == st)
         return(mp);
   return(NULL);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static void MMWinnowByOrder(ATL_mmnode_t *mb, int imf, double tol)
/*
 * Deletes any node from mb that isn't faster than the preceeding node
 */
{
   ATL_mmnode_t *mp;
   if (!mb)
      return;
   if (tol == 0.0)
      tol = 1.0;
   mp = mb;
   while (mp->next)
   {
      if (mp->mflop[imf] >= mp->next->mflop[imf]*tol)
         mp->next = KillMMNode(mp->next);
      else
         mp = mp->next;
   }
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static ATL_mmnode_t *MMWinnowByKU(ATL_mmnode_t *mb, int minKB, double tol)
/*
 * Successively does following:
 *  (1) Move highest performing kernel from mmb to retained list
 *  (2) Get rid of all kernels that don't provide speedup over retained KUs
 * ASSUMES: timings in mflop[0] correct for this range 
 */
{
   ATL_mmnode_t *rb=NULL;
   while (mb)
   {
      ATL_mmnode_t *mp;
      int KEEP=1;                  /* assume this kernel useful */
      mp = FindMaxMflopMMQ(mb, 0);
      if (rb)                      /* are there kerns that might do same job? */
      {
         ATL_mmnode_t *kp;
         const unsigned int ku=mb->ku;
/*
 *       See if this guy can handle a KU case better than existing kernels
 */
         for (kp=rb; kp; kp = kp->next)
         {
            const unsigned int rku=kp->ku;
            if (rku == ku)
            {
               KEEP = mp->mflop[0]*tol >= kp->mflop[0];
               if (!KEEP)
                  break;
            }
            else
            {
               const unsigned int gap = (rku > ku) ? rku-ku : ku-rku;
               if (gap <= 4) /* retained kern handles all cases */
               {
                  const unsigned int kb = ((minKB+ku-1)/ku) * ku;
                  double pen=(kb-3.0);
                  pen /= kb;
                  KEEP = mp->mflop[0]*tol >= pen*kp->mflop[0];
                  if (!KEEP)
                     break;
               }
            }
         }
      }
      mb = RemoveMMNodeFromQ(mb, mp);
      if (KEEP)
      {
         mp->next = rb;
         rb = mp;
      }
      else
         KillMMNode(mp);
   }
   return(rb);
}
@iexp ip @(ip) 1 +
/* procedure @(ip) */
void SetExtBFkoRout(char *rout)
{
   int len;
   len = strlen(rout);
   if (rout[len-1] != 'B' && rout[len-2] == '.' )
      rout[len-1] = 'B';
}
@ROUT cpread
@iexp ip @(ip) 1 +
/* procedure @(ip) */
static char CopyGetPre(int flag)
{
   char pre;
   if (flag & (1<<CPF_REAL))
      pre = (flag & (1<<CPF_SINGLE)) ? 's':'d';
   else
      pre = (flag & (1<<CPF_SINGLE)) ? 'c':'z';
   return(pre);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static char *CopyGetCompType(int flag)
{
   char *ctyp;
   if (flag & (1<<CPF_REAL))
      ctyp = (flag & (1<<CPF_SINGLE)) ? "SREAL":"DREAL";
   else
      ctyp = (flag & (1<<CPF_SINGLE)) ? "SCPLX":"DCPLX";
   return(ctyp);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static char CopyGetUpr(int flag)
{
   return((flag & (1<<CPF_SINGLE)) ? 's':'d');
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static char CopyGetTrans(int flag)
{
   if (flag & (1<<CPF_TRANS))
      return((flag & (1<<CPF_CONJ))?'H':'T');
   return((flag & (1<<CPF_CONJ))?'C':'N');
}

/* procedure @(ip) */
static char *CopyGetDirect(int flag)
/*
 * In names, direction is in reference to col-major, not block!
 */
{
   return((flag&(1<<CPF_TOBLK)) ? "From" : "Into");
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static int CopyEncodeScal
(
   unsigned int flag,  /* flag encoding at least matrix type */
   int ialp,           /* for mat='A', [1,-1,X], for mat='C': [0,1,-1,X] */
   int ibet            /* for mat='A', ignored, else [0,1,-1,X] */
)
{
   flag &= ~(CPF_ALLALP | CPF_ALLBET); /* clear alpha,beta bits */
   if (ialp == 1)
      flag |= (1L<<CPF_AL1);
   else if (ialp == -1)
      flag |= (1L<<CPF_ALN);
   else if (ialp != -2)
      flag |= (1L<<CPF_ALX);
   if (flag & (1L<<CPF_CBLK))
   {
      if (ibet == 1)
         flag |= (1L<<CPF_BE1);
      else if (ibet == 0)
         flag |= (1L<<CPF_BE0);
      else if (ibet == -1)
         flag |= (1L<<CPF_BEN);
      else if (ibet != -2)
         flag |= (1L<<CPF_BEX);
   }
   return(flag);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
void CopyEncodeAllScal
(
   ATL_cpnode_t *cb,
   unsigned int flag,  /* flag encoding at least matrix type */
   int ialp,           /* for mat='A', [0,1,-1,2,-2] */
   int ibet            /* for mat='A', ignored, else [0,1,-1,2,-2] */
)
{
   ATL_cpnode_t *cp;

   for (cp=cb; cp; cp = cp->next)
      cp->flag = CopyEncodeScal(cp->flag, ialp, ibet);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static int CopyEncode
(              /* all args take 0, which means don't set */
   char pre,  /* [s,d,c,z] */
   char dir,  /* 'I': copy Into block, 'F': copy From block */
   char mat,  /* [C,A] */
   char TA    /* [N,T,C,H] */
)
/* 
 * returns arginfo as ATL_cpnode_t flag
 */
{
   int flag;
   if (pre)
   {
      flag = (pre == 'd' || pre == 's') ? (1<<CPF_REAL) : 0;
      flag |= (pre == 's' || pre == 'c') ? (1<<CPF_SINGLE) : 0;
   }
   if (dir)
   {
      if ((dir == 'I' || dir == 'i'))
         flag |= (1<<CPF_TOBLK);
   }
   if (mat)
   {
      if (mat == 'C' || mat == 'c')
         flag |= (1<<CPF_CBLK);
      else /* A or B */
      {
         flag |= (mat == 'a' || mat == 'A') ? (1<<CPF_ABLK) : 0;
         if (TA)
         {
            if (TA == 't' || TA == 'T')
               flag |= (1<<CPF_TRANS);
            else if (TA == 'c' || TA == 'C')
               flag |= (1<<CPF_CONJ);
            else if (TA == 'H' || TA == 'h')
               flag |= (1<<CPF_TRANS) | (1<<CPF_CONJ);
         }
      }
   }
   return(flag);
}

@multidef pf AL BE
@whiledef sc Alpha Beta
@iexp ip @(ip) 1 +
/* procedure @(ip) */
static int CopyGet@(sc)I(int flag)
{
   int iret;
   if (flag&(1<<CPF_@(pf)1))
      iret = 1;
   else if (flag&(1<<CPF_@(pf)N))
      iret = -1;
   @mif pf = "BE
   else if (flag&(1<<CPF_@(pf)0))
      iret = 0;
   @endmif
   else
      iret = 2;
   return(iret);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static char CopyGet@(sc)C(int flag)
{
   char ch;
   if (flag&(1<<CPF_@(pf)1))
      ch = '1';
   else if (flag&(1<<CPF_@(pf)N))
      ch = 'N';
   @mif pf = "BE
   else if (flag&(1<<CPF_@(pf)0))
      ch = '0';
   @endmif
   else if (flag&(1<<CPF_@(pf)X))
      ch = 'X';
   else
      assert(0);
   return(ch);
}
   @undef pf
@endwhile

@iexp ip @(ip) 1 +
/* procedure @(ip) */
char *GetCopyGenStr(ATL_cpnode_t *p)
{
   char *gs=NULL, *vecd = p->kvec ? "kdim" : "no";
   const int flag=p->flag;
   int sz, ialp, ibet=0;
   char pre;

   pre = CopyGetPre(flag);
   ialp = CopyGetAlphaI(flag);
   if (flag & (1<<CPF_CBLK))
   {
      char *gen;
      ibet = CopyGetBetaI(flag);
      if (p->vlen > 1)
      {
         assert((flag&(1<<CPF_SYRK)) == 0);
         gen = (flag&(1<<CPF_TOBLK)) ? "C2blk":"blk2C";
         if (flag&(1<<CPF_SINGLE))
            vecd = (p->vlen == 8) ? "avx" : "sse";
         else
            vecd = (p->vlen == 4) ? "avx" : "sse";
         sz = 45 + NumDecDigits(p->mu);
         sz += NumDecDigits(p->nu);
         sz += NumDecDigits(ialp);
         sz += NumDecDigits(ibet);
         sz += strlen(p->rout);
         gs = malloc(sz);
         assert(gs);
         sprintf(gs, "make %s_%s mu=%d nu=%d alpha=%d beta=%d rt=%s",
                 gen, vecd, p->mu, p->nu, ialp, ibet, p->rout);
         return(gs);
      }
      if (flag & (1<<CPF_TOBLK))
         gen = (flag&(1<<CPF_SYRK)) ? "syC2blk":"C2blk";
      else
         gen = (flag&(1<<CPF_SYRK)) ? "syblk2C":"blk2C";
      sz = 74 + NumDecDigits(p->mu);
      sz += NumDecDigits(p->nu);
      sz += NumDecDigits(p->kvec);
      sz += strlen(p->rout);
      sz += strlen(gen) + strlen(vecd);
      gs = malloc(sz);
      assert(gs);
      sprintf(gs,
"make gen_%s pre=%c vlen=%d mu=%d nu=%d cpvlen=1 alpha=%d beta=%d vec=%s rt=%s",
              gen, pre, p->kvec, p->mu, p->nu, ialp, ibet, vecd, p->rout);
      return(gs);
   }
   else
   {
      int sz, i;
      const char *frm;
      sz = 17 + 24;
      sz += strlen(p->rout);
      sz += NumDecDigits(p->kvec);
      sz += NumDecDigits(p->nu);
      sz += NumDecDigits(p->mu);
      sz += NumDecDigits(ialp)+1;
      gs = malloc(sz*sizeof(char));
      assert(gs);
      if (flag&(1<<CPF_REAL))
         frm = (flag&(1<<CPF_TOBLK)) ? "make gen_A%c2blk":"make gen_blk2A%c";
      else /* complex */
         frm = (flag&(1<<CPF_TOBLK)) ? "make gen_cA%c2blk":"make gen_cblk2A%c";
      i = sprintf(gs, frm, (flag&(1<<CPF_TRANS))?'T':'N');
      i += sprintf(gs+i, " rt=%s kmaj=%u UR=%u ku=%u alpha=%d", p->rout, 
                   p->kvec, p->nu, p->mu, ialp);
      assert(i < sz);
   }
   return(gs);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
void SetAllUnsetCopyRout(ATL_cpnode_t *cb, char *rt)
{
   ATL_cpnode_t *cp;
   for (cp=cb; cp; cp = cp->next)
      if (!cp->rout)
         cp->rout = DupString(rt);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
void SetAllCopyGenStr(ATL_cpnode_t *cb)
/*
 * For ID=0, ", and genstr
 */
{
   ATL_cpnode_t *cp;
   for (cp=cb; cp; cp = cp->next)
   {
      if (!cp->ID)
      {
         assert(cp->rout);
         if (cp->genstr)
            free(cp->genstr);
         cp->genstr = GetCopyGenStr(cp);
      }
   }
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
char *CopyFlag2Str(unsigned int flag)
/*
 * Encodes TOBLK,CBLK,TRANS,CONJ,KERN,alp,bet into standard string
 */
{
   static char nm[16];
   if (flag&(1<<CPF_TOBLK))
   {
      nm[0] = 'F'; nm[1] = 'r'; nm[2] = 'o'; nm[3] = 'm';
   }
   else
   {
      nm[0] = 'I'; nm[1] = 'n'; nm[2] = 't'; nm[3] = 'o';
   }
   nm[4] = (flag&(1<<CPF_CBLK)) ? 'C' : 'A';
   if (flag&(1<<CPF_TRANS))
      nm[5] = (flag&(1<<CPF_CONJ)) ? 'H' : 'T';
   else
      nm[5] = (flag&(1<<CPF_CONJ)) ? 'C' : 'N';
   if (!(flag&CPF_ALLKERN))
      nm[6] = 'g';
   else if (flag&(1<<CPF_SYRK))
      nm[6] = 'r';
   else if (flag&(1<<CPF_SYMM))
      nm[6] = 'y';
   else if (flag&(1<<CPF_TRMM))
      nm[6] = 't';
   else if (flag&(1<<CPF_TRSM))
      nm[6] = 's';
   else
      assert(0);
      
   nm[7] = '_';
   nm[8] = 'a';
   if (flag & (1<<CPF_AL1))
      nm[9] = '1';
   else
      nm[9] = (flag & (1<<CPF_ALN)) ? 'N' : 'X';
   if (flag&(1<<CPF_CBLK))
   {
      nm[10] = 'b';
      if (flag & (1<<CPF_BEN))
         nm[11] = 'N';
      else if (flag & (1<<CPF_BEX))
         nm[11] = 'X';
      else
         nm[11] = (flag & (1<<CPF_BE1)) ? '1' : '0';
      nm[12] = '\0';
   }
   else
      nm[10] = '\0';
   return(nm);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
char *ConjCopyName(ATL_cpnode_t *cp)
{
   if (!(cp->flag&(1<<CPF_CBLK)))
   {
      char *sp = cp->rout + 12;
      char ch;
      assert(cp->rout);
      ch = *sp;
      assert(ch == 'T' || ch == 'N');
      *sp = (ch == 'T') ? 'H' : 'C';
   }
}

char *UnConjCopyName(ATL_cpnode_t *cp)
{
   if (!(cp->flag&(1<<CPF_CBLK)))
   {
      char *sp = cp->rout + 12;
      char ch;
      assert(cp->rout);
      ch = *sp;
      assert(ch == 'H' || ch == 'C');
      *sp = (ch == 'H') ? 'T' : 'N';
   }
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
char *GetCopyName(ATL_cpnode_t *p, int exlen)
{
   char *sp=NULL, *dir, *flgstr;
   const int ID=p->ID, flag=p->flag;
   int len, i=0;
   char pre, cal;

   pre = CopyGetPre(flag);
   dir = CopyGetDirect(flag);
   flgstr = CopyFlag2Str(flag);
   len = strlen(flgstr);
/*
 * For C format routine naming scheme is: 
 *    ATL_<pre>cp[Into,From]C[N,T][g,k,y,r,s]_aXbX_<mu>x<nu>x<blksz>
 */
   cal = CopyGetAlphaC(flag);
   if (flag & (1<<CPF_CBLK))
   {
      char ck='g', cbe;
      unsigned int blksz = p->mu * p->nu;
      if (p->kvec > 1)
         blksz = ((blksz+p->kvec-1)/p->kvec)*p->kvec;
      len += 12+NumDecDigits(p->mu)+NumDecDigits(p->nu)+NumDecDigits(blksz);
      sp = malloc(len+exlen);
      assert(sp);
      i = sprintf(sp, "ATL_%ccp%s_%ux%ux%u", pre, flgstr, p->mu, p->nu, blksz);
   }
/*
 * For A format routine naming scheme is:
 *    ATL_<pre>cp[Into,From]A[N,T][g,k,y,r,s]_aX_<ku>x<nu>_<kvec>
 */
   else
   {
      len += 12 + NumDecDigits(p->nu) + NumDecDigits(p->mu) + 
             NumDecDigits(p->kvec);
      sp = malloc(len+exlen);
      assert(sp);
      i = sprintf(sp, "ATL_%ccp%s_%ux%u_%u", pre, flgstr, p->mu, p->nu,p->kvec);
   }
   assert(i < len);
   return(sp);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static int CopyAreDiff(ATL_cpnode_t *c0, ATL_cpnode_t *c1)
/*
 * RETURNS: 1 if c0 & c1 have different functionality, 0 if equivalent
 */
{
   if (c0->STGID != c1->STGID)
      return(1);
   if (c0->STGID)  /* for now, each STGID matches with any other same ID */
      return(0);   /* this may change when we actually support */
   if (c0->nu != c1->nu)
      return(1);
   if (c0->mu != c1->mu)
      return(1);
   if (c0->flag & (1<<CPF_CBLK))
   {
      int msk = ~((1<<CPF_ASM)|(1<<CPF_TMP));
      if ((c0->flag&msk) != (c1->flag&msk))
         return(1);
      if (c0->kvec || c1->kvec)
      {
         int bsz0=c0->mu*c0->nu, bsz1=c1->mu*c1->nu;
         if (c0->kvec)
            bsz0 = ((bsz0+c0->kvec-1)/c0->kvec)*c0->kvec;
         if (c1->kvec)
            bsz1 = ((bsz1+c1->kvec-1)/c1->kvec)*c1->kvec;
         if (bsz0 != bsz1)
            return(1);
      }
   }
   else
   {
      int msk = ~((1<<CPF_ABLK)|(1<<CPF_ASM)|(1<<CPF_TMP)|CPF_ALLBET);
      if ((c0->flag&msk) != (c1->flag&msk))
         return(1);
      if (c0->kvec != c1->kvec)
         return(1);
   }
   return(0);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
ATL_cpnode_t *FindEquivCopy(ATL_cpnode_t *cb, ATL_cpnode_t *dup)
/*
 * RETURNS: NULL if no copy rout equivalent to dup is in cb, else ptr to dup
 */
{
   ATL_cpnode_t *cp;
   if (dup)
   {
      for (cp=cb; cp; cp = cp->next)
         if (!CopyAreDiff(cp, dup))
            return(cp);
   }
   return(NULL);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
ATL_cpnode_t *FindEquivUserCopy(ATL_cpnode_t *cb, ATL_cpnode_t *dup)
/*
 * Searches list of user-supplied kerns for one that matches dup.
 * dup is a fully-qualified case, where CBLK,ABLK,TRANS are set to the exact
 * case required, while cb is coming from a user cases index file.
 * Therefore cb TRANS setting in reference to B matrix. I.e., TRANS=1 
 * means NoTrans A, Trans B, while TRANS=0 means Trans A, NoTrans B.
 * RETURNS: NULL if no copy rout equivalent to dup is in cb, else ptr to dup
 */
{
   ATL_cpnode_t *cp;
   if (dup)
   {
      const int dflag=dup->flag, dalp=dflag&CPF_ALLALP, dbet=dflag&CPF_ALLBET;
      const int CBLK=dup->flag&(1<<CPF_CBLK), dab=dflag&(CPF_ALLBET|CPF_ALLALP);
      const int TRANS=(dflag>>CPF_TRANS)&1, ABLK=(dflag>>CPF_ABLK)&1;
      for (cp=cb; cp; cp = cp->next)
      {
         int flg0=cp->flag, ab;
         if (CBLK != (flg0&(1<<CPF_CBLK)))
             continue;
         if (!(flg0 & dalp))
            continue;
         if (CBLK && !(flg0 & dbet))
            continue;
         if (!CBLK)
         {
            const int TA0 = (flg0>>CPF_TRANS)&1;
            if (ABLK)
            {
               if (TA0 == TRANS)
                  continue;
            }
            else if (TA0 != TRANS)
               continue;
         }
         cp->flag = (cp->flag & (~(CPF_ALLBET|CPF_ALLALP))) | dab;
         if (!CopyAreDiff(cp, dup))
         {
            cp->flag = flg0;
            return(cp);
         }
         cp->flag = flg0;
      }
   }
   return(NULL);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static char *GetCpySumNam(int flag, char ch)
{
   char pre, calp;
   static char fnam[16];

   pre = CopyGetPre(flag);
   calp = CopyGetAlphaC(flag);
   if (flag & (1<<CPF_CBLK))
   {
      char c0='b', c1='C', cbet;
      cbet = CopyGetBetaC(flag);
      if (flag & (1<<CPF_TOBLK))
      { c0 = 'C'; c1 = 'b'; }
      sprintf(fnam, "%c%c%c2%c_a%cb%c.CPS", pre, ch, c0, c1, calp, cbet);
   }
   else
   {
      char c0='b', c1='A';
      if (flag & (1<<CPF_TOBLK))
      { c0 = 'A'; c1 = 'b'; }
      sprintf(fnam, "%c%c%c2%c_a%c.CPS", pre, ch, c0, c1, calp);
   }
   return(fnam);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
void CopyApplyBlasRules(ATL_cpnode_t *cb)
{
   ATL_cpnode_t *cp;
/*
 * SYRK A/B copies are same as GEMM A/B copies
 */
   for (cp=cb; cp; cp = cp->next)
   {
      if ((cp->flag & (1<<CPF_SYRK)) && !(cp->flag & (1<<CPF_CBLK)))
         cp->flag ^= 1<<CPF_SYRK;
   }
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
ATL_cpnode_t *GetCopyMatches(ATL_cpnode_t *cb, int flag)
/*
 * RETURNS: cloned queue of all nodes in cb that match flag on:
 *    ALLKERN,TOBLK,CBLK,TRANS,CONJ,ALx,BEx(only for C).
 * NOTE: cb is not changed.
 */
{
   ATL_cpnode_t *cp, *cn=NULL;
   const unsigned int exactmsk=CPF_ALLKERN|(1<<CPF_CBLK)|(1<<CPF_TOBLK)
      |(1<<CPF_TRANS)|(1<<CPF_CONJ);
   for (cp=cb; cp; cp = cp->next)
   {
      ATL_cpnode_t *tp;
      if ((flag&exactmsk) != (cp->flag&exactmsk))
         continue;
      if (!(flag & (cp->flag&CPF_ALLALP)))
         continue;
      if (flag&(1<<CPF_CBLK))
         if (!(flag & (cp->flag&CPF_ALLBET)))
            continue;
      tp = CloneCPNode(cp);
      tp->next = cn;
      cn = tp;
   }
   return(cn);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
ATL_cpnode_t *FindCopy_cohere(ATL_cpnode_t *cb, ATL_cpnode_t *dup)
/*
 * Searches cb for kern that match dup, except for flag, where the only
 * bits that matter are: CBLK,MVEC,NVEC,KERN
 * RETURNS: NULL if no copy rout equivalent to dup is in cb, else ptr to dup
 */
{
   const unsigned int flgD=dup->flag;
   const unsigned msk=((1<<CPF_CBLK)|(1<<CPF_MVEC)|(1<<CPF_NVEC)|CPF_ALLKERN);
   ATL_cpnode_t *cp;
   dup->flag &= msk;
   for (cp=cb; cp; cp = cp->next)
   {
      const unsigned int flg=cp->flag;
      cp->flag &= msk;
      if (!CopyAreDiff(cp, dup))
      {
         dup->flag = flgD;
         cp->flag = flg;
         return(cp);
      }
      cp->flag = flg;
   }
   dup->flag = flgD;
   return(NULL);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
void CopyMarkDup_cohere(ATL_cpnode_t *b0, ATL_cpnode_t *b1)
/* 
 * Set CPF_TMP for all kerns of b0 & b1 that appear in both
 */
{
   ATL_cpnode_t *p0;
   if (!b0 || !b1)
      return;
   for (p0=b0; p0; p0 = p0->next)
   {
      ATL_cpnode_t *p1;
      p1 = FindCopy_cohere(b1, p0);
      if (p1)
      {
         p0->flag |= (1<<CPF_TMP);
         p1->flag |= (1<<CPF_TMP);
      }
   }
}
@iexp ip @(ip) 1 +
/* procedure @(ip) */
ATL_cpnode_t *CopySortMarkedFirst(ATL_cpnode_t *cb)
/*
 * Ensures nodes with CPF_TMP set appear first in cb.
 */
{
   ATL_cpnode_t *cp=cb;
   while (cp)
   {
      ATL_cpnode_t *cs;
      while (cp && (cp->flag & (1<<CPF_TMP)))  /* skip set nodes */
         cp = cp->next;
/*
 *    If we find unset node, find next set node, and swap them
 */
      if (cp)
      {
         for (cs=cp->next; cs && !(cp->flag & (1<<CPF_TMP)); cs = cs->next);
         if (cs)
         {
            cb = SwapCPNodeInQ(cb, cp, cs);
            cp = cs->next;
         }
         else
            break;
      }
   }
   return(cb);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
ATL_cpnode_t *CopyDictateOrder(ATL_cpnode_t *b0, ATL_cpnode_t *b1)
/*
 * Queue b1 is reordered to match corresponding nodes in b0.  A node
 * corresponds as dictated by FindCopy_cohere.
 * ASSUMES: len(b0) <= len(b1); b0 & b1 are arrs of same type excpt for scalars.
 * RETURNS: possibly new base of b1
 */
{
   ATL_cpnode_t *p0;
   unsigned int cnt0=0;
   for (p0=b0; p0; p0 = p0->next, cnt0++)
   {
      ATL_cpnode_t *p1;
      p1 = FindCopy_cohere(b1, p0);
/*
 *    I must swap p1 with cnt0 in b1
 */
      if (p1)
      {
         ATL_cpnode_t *p;
         unsigned int cnt1=0, cnt2=0;
/*
 *       Find node presently at cnt0 in b1, and swap it with p1
 */
         for (p=b1; cnt1 != cnt0 && p; cnt1++, p = p->next);
         assert(p);
         if (p != p1)
            b1 = SwapCPNodeInQ(b1, p1, p);
      }
   }
   return(b1);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
ATL_cpnode_t *CopyNoRep(ATL_cpnode_t *cb, int minSz)
/*
 * Eliminates cpnodes with duplicate copy routines. In throwing away duplicates,
 * retain routine with mb*nb > minSz, if both > minSz, throw away biggest, 
 * if both < minSz throw away smallest.
 */
{
   ATL_cpnode_t *cp, *dup;
   for (cp=cb; cp && cp->next; cp = cp->next)
   {
      unsigned int sz0 = cp->mb * cp->nb;
      ATL_cpnode_t *dup;
      while ( (dup = FindEquivCopy(cp->next, cp)) )
      {
         unsigned int sz1 = dup->mb * dup->nb;;
         if (sz0 > minSz && sz1 > minSz) /* elim largest */
         {
            if (sz0 > sz1)
            {
               sz0 = sz1;
               cp->mb = dup->mb;
               cp->nb = dup->nb;
            }
         }
         else /* elim smallest */
         {
            if (sz0 < sz1)
            {
               sz0 = sz1;
               cp->mb = dup->mb;
               cp->nb = dup->nb;
            }
         }
         KillCPNodeFromQ(cb, dup);
      }
   }
   return(cb);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
void CopyFixTransByMtx(char mtx, char ta, ATL_cpnode_t *cb)
/*
 * This function takes a list of copy functions and applies the Tranpose
 * rules necessary for A or B storage.  In NoTrans the K dim is contiguous,
 * while in Transpose K is strided.  Therefore, A (naturally MxK) must always
 * swap the transpose setting, while B (KxN) keeps the input setting.
 * More explicitly, the rules are:
 *    AN:cpT, AC:cpH, AT:cpN, AH:cpC; 
 *    BN:cpN, BC:cpC, BT:cpyT, BH:cpyH
 */
{
   ATL_cpnode_t *cp;
   const int nmsk=~((1<<CPF_TRANS)|(1<<CPF_CONJ)|(1<<CPF_ABLK));
   int msk;
   if (mtx == 'A' || mtx == 'a')
   {
      msk = 1<<CPF_ABLK;
      if (ta == 'N')
         msk |= (1<<CPF_TRANS);
      else if (ta == 'C')
         msk |= (1<<CPF_TRANS) | (1<<CPF_CONJ);
      else if (ta == 'H')
         msk |= (1<<CPF_CONJ);
   }
   else
   {
      if (ta == 'T')
         msk = (1<<CPF_TRANS);
      else if (ta == 'C')
         msk = (1<<CPF_CONJ);
      else if (ta == 'H')
         msk = (1<<CPF_TRANS) | (1<<CPF_CONJ);
      else /* no-trans */
         msk = 0;
   }
   for (cp=cb; cp; cp = cp->next)
   {
      cp->flag = (cp->flag & nmsk) | msk;
      if (cp->rout)
         free(cp->rout);
      cp->rout = GetCopyName(cp, 0);
   }
}

@ROUT mvread r1read mmread cpread
#endif  /* end atlas_@(rt)parse.h guard */
@ROUT atlas_mvtesttime.h
   @define rt @mv@
   @define ru @mv@
   @define at @mvt@
@ROUT atlas_r1testtime.h
   @define rt @r1@
   @define ru @r1@
   @define at @r1@
@ROUT atlas_r2testtime.h
   @define rt @r2@
   @define ru @r1@
   @define at @r2@
@ROUT atlas_mmtesttime.h
   @define rt @mm@
   @define ru @mm@
   @define at @mm@
@ROUT atlas_cptesttime.h
   @define rt @cp@
   @define ru @cp@
   @define at @cpt@
@ROUT atlas_gentesttime.h
#ifndef ATLAS_GENTESTTIME_H
   #define ATLAS_GENTESTTIME_H

#include "atlas_fopen.h"

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static int GetL1CacheSize()
{
   FILE *L1f;
   int L1Size;

   L1f = fopen("res/L1CacheSize", "r");
   if (!L1f)
   {
      assert(system("make res/L1CacheSize\n") == 0);
      L1f = fopen("res/L1CacheSize", "r");
   }
   assert(L1f != NULL);
   assert(fscanf(L1f, "%d", &L1Size) == 1);
   fclose(L1f);
   fprintf(stderr, "\n      Read in L1 Cache size as = %dKB.\n",L1Size);
   return(L1Size);
}

@ROUT mvres mmres atlas_gentesttime.h
@iexp ip @(ip) 1 +
/* procedure @(ip) */
static int pre2size(char pre)
{
   int iret=8;
   if (pre == 's')
      iret = 4;
   else if (pre == 'z')
      iret = 16;
   return(iret);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static void SortDoubles(int N, double *d)
/* 
 * Sorts N-length array d from least to greatest using N^2 selection sort
 */
{
   double min;
   int imin, i, j;

   for (i=0; i < N-1; i++)
   {
      imin = i;
      min = d[i];
      for (j=i+1; j < N; j++)
      {
         if (d[j] < min)
         {
            imin = j;
            min = d[j];
         }
      }
      if (imin != i)
      {
         d[imin] = d[i];
         d[i] = min;
      }
   }
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static void *ReadResultsFile(int ACTION, int nsample, char *resfile)
/*
 * Reads an ATLAS results file, which has the following form:
 *    <N> <walltime>   -> walltime of 0 means CPU timing was used
 *    sample1
 *    ....
 *    sampleN
 * RETURNs NULL on error, otherwise it depends on ACTION:
 * ACTION    RETURNS
 * 0         ptr to max value for walltime, median for CPU (serial timing)
 * 1         entire list of results is returned in N+2 array, of form
 *              <N> <wall> <sample1> .... <sampleN>
 *           DRET[0] = N; DRET[1] = 1 if walltime else 0.
 * 2         ptr to the average (parallel timing)
@beginskip
 * RETURNS: NULL on error or if nsample > N, else if (FULL) it returns
 *          an array of form:  <N> <wall> <sample1> .... <sampleN>
 *          where samples have been sorted from least-to-greatest.
 *          where <N> is the number of samples.
 *          If (!FULL) then a pointer to the max value is returned for
 *          walltime, and a pointer to the median value is returned for
 *          for cputime.
@endskip
 */
{
   static double dret;
   double *dres;
   FILE *fpin;
   char ln[1024];
   int i, n, wall, ierr;

   fpin = fopen(resfile, "r");
   if (!fpin)
      return(NULL);
   ierr = (fgets(ln, 1024, fpin) == NULL);
   if (ierr || sscanf(ln, " %d %d", &n, &wall) != 2)
   {
      fclose(fpin);
      return(NULL);
   }
   if (n < nsample)
   {
      fclose(fpin);
      return(NULL);
   }
   dres = malloc((n+2)*sizeof(double));
   assert(dres);
   dres[0] = n;
   dres[1] = wall;
   dret = 0.0;
   for (i=0; i < n; i++)
   {
      ierr = (fgets(ln, 1024, fpin) == NULL);
      if (ierr || sscanf(ln, " %le", dres+i+2) != 1)
      {
         fclose(fpin);
         return(NULL);
      }
      dret += dres[i+2];
   }
   fclose(fpin);
   SortDoubles(n, dres+2);
   if (ACTION == 1)
      return(dres);
   else if (ACTION == 0)
      dret = (wall) ? dres[n+1] : dres[2+n/2];
   else /* if (ACTION == 2) */
      dret /=  dres[0];
   free(dres);
   return(&dret);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static double PrintResultsFromFile(FILE *fpout, double *darr)
{
   const int N=darr[0], wall=(darr[1] != 0.0);
   double *dres=darr+2;
   double dret;
   int i;

   assert(N > 0);
   for (i=0; i < N; i++)
      fprintf(fpout, "   %le\n", dres[i]);
   if (wall)
   {
      fprintf(fpout, "MAX = %.2f\n", dres[N-1]);
      return(dres[N-1]);
   }
   else 
      fprintf(fpout, "MED = %.2f\n", dres[N/2]);
   return(dres[N/2]);
}

@ROUT atlas_gentesttime.h
#endif  /* end guard around atlas_gentesttime.h */
@ROUT atlas_mmtesttime.h atlas_r1testtime.h atlas_r2testtime.h @\
      atlas_mvtesttime.h atlas_cptesttime.h
#ifndef ATLAS_@up@(rt)TESTTIME_H
   #define ATLAS_@up@(rt)TESTTIME_H

#include "atlas_@(ru)parse.h"
#include "atlas_gentesttime.h"

@ROUT atlas_cptesttime.h
@iexp ip 0
@iexp ip @(ip) 1 +
/* procedure @(ip) */
ATL_cpnode_t *CopyApplyTypeScal2Hand(ATL_cpnode_t *cb, unsigned int flag)
/*
 * Get rid of cb not matching flag.  For survivors, change their optional 
 * alpha/beta cases to only match the one in flag
 */
{
   ATL_cpnode_t *cp=cb;
   const unsigned int typ = flag & ((1<<CPF_SINGLE) | (1<<CPF_REAL));
   const unsigned int msk = (flag&(1<<CPF_CBLK)) ? 
                            (CPF_ALLBET|CPF_ALLALP) : CPF_ALLALP, nmsk=~msk;
   while (cp)
   {
      ATL_cpnode_t *nxt = cp->next;
      cp->flag |= typ;
      if (flag&msk&cp->flag)
         cp->flag = (cp->flag&(nmsk))|(flag&msk);
      else
         cb = KillCPNodeFromQ(cb, cp);
      cp = nxt;
   }
   return(cb);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static int DoGenString(int verb, char *genstr)
{
   int err=0;
   if (verb > 2)
      printf("genstr='%s'\n", genstr);
   if (!genstr)
      err=1;
   else if (verb < 3) /* want to redirect output */
   {
      char *ln;
      ln = NewMergedString(genstr, " > /dev/null 2>&1");
      err = system(ln);
      free(ln);
   }
   else
      err = system(genstr);
   if (err)
      fprintf(stderr, "UNABLE TO GENERATE WITH COMMAND: '%s'\n", 
              genstr ? genstr : "NULL");
   return(err);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
double TimeCPKernel
(
   int verb,                    /* 0: no output, 1 min output, 2: full output */
   int flg,                     /* 1: ignore any prior output file */
   ATL_cpnode_t *cp,            /* ptr to cpkern struct */
   int mb, int nb,              /* rows & cols to time */
   int alpha,                   /* alpha to time [1,-1,X] */
   int beta,                    /* beta to time [0,1,-1,X] */
   unsigned long nrep,          /* >0: # of repetitions to force */
   int cflush                   /* >=0: size of cache flush, else ignored */
)
{
   char *fnam, ln[4096];  /* security from 1991 */
   const unsigned int flag=cp->flag;
   unsigned int i;
   const int FORCETIME = flg&1;
   double *dp;
/*
 * Figure out the name of the output file
 */
   if (FORCETIME)
      fnam = DupString("res/tmpout.ktim");
   else
   {
      int k;
      k = NumDecDigits(mb) + NumDecDigits(nb) + NumDecDigits(cp->vlen) + 3 + 5;
      fnam = GetCopyName(cp, k);
      fnam[0] = 'r';
      fnam[1] = 'e';
      fnam[2] = 's';
      fnam[3] = '/';
      for (k=4; fnam[k]; k++);
      if (cp->ID)
         sprintf(fnam+k, "_%ux%u_%u.ktim", mb, nb, cp->ID);
      else
         sprintf(fnam+k, "_%ux%ux%u.ktim", mb, nb, cp->vlen);
      dp = ReadResultsFile(2, 0, fnam);
      if (dp)
      {
         free(fnam);
         return(*dp);
      }
   }
   if (cp->genstr)
   {
      sprintf(ln, "%s > /dev/null 2>&1", cp->genstr);
      if (system(ln))
      {
         fprintf(stderr, "UNABLE TO GENERATE WITH='%s'\n", ln);
         assert(0);
      }
   }
   else
      assert(cp->ID);
   if (flag & (1<<CPF_CBLK))
      i = sprintf(ln, "make %ccpytimeC vlen=%d mu=%d nu=%d", 
                  CopyGetPre(flag), cp->kvec?cp->kvec:1, cp->mu, cp->nu);
   else
      i = sprintf(ln, "make %ccpytime TA=%c MTDX='-D 8000 8000 8000 1'", 
                  CopyGetPre(flag), CopyGetTrans(flag));
   i += sprintf(ln+i, " kfnam=%s outF=\"-f %s\"", cp->rout, fnam);
   i += sprintf(ln+i, " mb=%d nb=%d TOBLK=%u", mb, nb, (flag>>CPF_TOBLK)&1);
   @whiledef sc alpha beta
   if (@(sc) == 0 || @(sc) == 1)
      i += sprintf(ln+i, " @(sc)=%d", @(sc));
   else if (@(sc) == -1)
      i += sprintf(ln+i, " @(sc)=-1 @(sc)n=\"N1\"");
   else
      i += sprintf(ln+i, " @(sc)=2 @(sc)n=X");
   @endwhile
   if (nrep)
      i += sprintf(ln+i, " FMFS=\"-r %lu\"", nrep);
   if (verb < 3)
      i += sprintf(ln+i, " > /dev/null 2>&1");
   if (system(ln))
   {
      fprintf(stderr, "ERROR IN COMMAND: '%s'\n", ln);
      if (cp->genstr)
         fprintf(stderr, "   GENSTR='%s'\n", cp->genstr);
      sprintf(ln, "rm -f %s\n", fnam);
      assert(!system(ln));
      exit(-1);
   }
   dp = ReadResultsFile(2, 0, fnam);
   free(fnam);
   return(*dp);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static int TimeNegCPKernels     /* RET: 0 if no retiming required */
(
   int imf,                     /* index of mflop array to check/set */
   int verb,                    /* 0: no output, 1 min output, 2: full output */
   int FRCTM,                   /* 1: ignore any prior output file */
   ATL_cpnode_t *cb             /* queue to time */
)
{
   ATL_cpnode_t *cp;
   int ntim=0;
   for (cp=cb; cp; cp = cp->next)
   {
      if (cp->mflop[imf] <= 0.0)
      {
         int ialp, ibet=0;
         ntim++;
         ialp = CopyGetAlphaI(cp->flag);
         if (cp->flag & (1<<CPF_CBLK))
            ibet = CopyGetBetaI(cp->flag);
         cp->mflop[imf] = TimeCPKernel(verb, FRCTM?1:0, cp, cp->mb, cp->nb, 
                                       ialp, ibet, 0, -1);
      }
   }
   return(ntim);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static ATL_cpnode_t *TimeCPFile
(
   char pre,
   char *file,
   int imf,
   int verb,
   int FRCTIM   /* 1: ignore prior output file */
)
{
   ATL_cpnode_t *cb;
   cb = ReadCPFile(file);
   if (!cb)
      return(cb);
   if (TimeNegCPKernels(imf, verb, FRCTIM, cb))
      WriteCPFile(file, cb);
   return(cb);
}

/* procedure @(ip) */
static ATL_cpnode_t *TimeCPFileWithPath
(
   char pre,
   char *path,
   char *file,
   int imf,
   int verb,
   int FRCTIM   /* 1: ignore prior output file */
)
{
   ATL_cpnode_t *cb;
   cb = ReadCPFileWithPath(pre, path, file);
   if (!cb)
      return(cb);
   if (TimeNegCPKernels(imf, verb, FRCTIM, cb))
      WriteCPFileWithPath(pre, path, file, cb);
   return(cb);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
int CPKernelFailsTestMM(char pre, int mb, int nb, int ialp, int ibet, 
                        ATL_cpnode_t *cp)
/*
 * This tester only works for some alpha/beta combos.
 * RETURNS: 0 on success, non-zero on failure
 */
{
   int i, sz, mu=cp->mu, nu=cp->nu, ku=(cp->kvec)?cp->kvec:1, kb;
   char *ln, *tst="ammmcpytst";

   kb = (mb >= nb) ? mb : nb;
   kb = ((kb+ku-1)/ku)*ku;
   if (!(cp->flag & (1<<CPF_AL1)))  /* this tester can only test alpha=1 */
      return(0);                    /* so say anything else passes for now */
   ialp = 1;
   if (cp->flag & (1<<CPF_SYRK))
   {
      tst = "syrkcpytst";
      if (cp->flag & (1<<CPF_CBLK))
         assert(cp->mu == cp->nu);
   }
   if (cp->flag & (1<<CPF_CBLK))
   {  /* can only test alpha=1, beta=0 for these guys */
      if (!(cp->flag & (1<<CPF_BE0)))  /* this tester can only test beta=0 */
         return(0);                    /* so say anything else passes for now */
      ibet=0;
   }
   else /* can only test alpha=1 & TOBLK for A/B */
   {
      ibet = 0;  /* not used for this test */
      mu = nu;   /* so that A & B are same */
      mb = ((mb+mu-1) / mu)*mu;
      if (!(cp->flag & (1<<CPF_TOBLK)))
         return(0);
   }
   if (cp->genstr)
      assert(!DoGenString(0, cp->genstr));
   sz = 10 + 62 + NumDecDigits(nb) + NumDecDigits(mb) + NumDecDigits(kb);
   sz += NumDecDigits(mu) + NumDecDigits(nu) + NumDecDigits(ku);
   if (cp->kvec > 1)
      sz += 21 + 2*NumDecDigits(cp->kvec);
   else
      sz += 14;
   sz += 7 + strlen(cp->rout);
   sz += 17;
   ln = malloc(sz);
   assert(ln);
   i = sprintf(ln, 
               "make %c%s alpha=%d beta=%d mu=%u nu=%u ku=%u mb=%u nb=%u kb=%u",
               pre, tst, ialp, ibet, mu, nu, ku, mb, nb, kb);
   if (cp->kvec > 1)
      i += sprintf(ln+i, " vec=kdim vlen=%u kmaj=%u", cp->kvec, cp->kvec);
   else
      i += sprintf(ln+i, " vec=no vlen=1");
   if (cp->flag & (1<<CPF_CBLK))
   {
      if (cp->flag & (1<<CPF_TOBLK))
         i += sprintf(ln+i, " C2blk=%s", cp->rout);
      else
         i += sprintf(ln+i, " blk2C=%s", cp->rout);
   }
   else
   {
      if (cp->flag & (1<<CPF_TRANS))
         i += sprintf(ln+i, " RM2blk=%s", cp->rout);
      else
         i += sprintf(ln+i, " CM2blk=%s", cp->rout);
   }
   i += sprintf(ln+i, " > /dev/null 2>&1");
   assert(i < sz);
   i = system(ln);
   if (i)
   {
      fprintf(stderr, "FAILED COMMAND: '%s'\n", ln);
      if (cp->genstr)
         fprintf(stderr, "   genstr= '%s'\n", cp->genstr);
   }
   free(ln);
   return(i);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static int CPKernelFailsTest
(
   char pre,    /* s,d,c,z */
   int TA,      /* 0: copy to/from col-major storage, else row-major */
   int mb,      /* if TA, # of cols, else # of rows */
   int nb,      /* if TA, # of rows, else # of cols */
   int ialp,    /* 0,1,-1,2 */
   int ibet,    /* 0,1,-1,2, unused if not C copy */
   ATL_cpnode_t *cp
)
/*
 * RETURNS: 0 on success, non-zero on failure
 */
{
   const unsigned int flag=cp->flag;
   int i, ierr, L, mu=cp->mu, nu=cp->nu, ku=(cp->kvec)?cp->kvec:1, kb, CPLX=0;
   unsigned int sz;
   char *ln;

   TA = (TA) ? 1 : 0;  /* make sure 0 or 1 only */
   L = NumDecDigits(mb)+NumDecDigits(nb)+NumDecDigits(cp->mu)+NumDecDigits(nu) 
       + NumDecDigits(mb*nb*2)+NumDecDigits(cp->kvec)+NumDecDigits(cp->vlen);
   if (pre == 'z' || pre == 'c')
   {
      CPLX = 0;
      L += 14; /* " CNJ='-DConj_'" */
   }
   L += 52 + 54 + 10 + 1 + strlen(cp->rout);
   ln = malloc(L);
   assert(ln);
   if (cp->genstr)
      assert(!DoGenString(0, cp->genstr));
   if (flag & (1<<CPF_CBLK))
   {
      assert(TA == 0);
      if (cp->kvec > 1)
      {
         int vl = cp->kvec;
         sz = ((mu*nu+vl-1)/vl)*vl;
      }
      else
         sz = mu*nu;
      sz *= ((mb+mu-1)/mu)*((nb+nu-1)/nu)*sz;
      i = sprintf(ln, "make %ccopytest CPM=C beta=%d alpha=%d UR=%u ku=%u "
                  "vlen=%u mb=%u nb=%u szb=%u TO_BLK=%u TRANS=0 kvec=%u "
                  "kfnam='%s'", 
                  pre, ibet, ialp, mu, nu, cp->vlen, mb, nb, sz, 
                  ((flag>>CPF_TOBLK)&1), (cp->kvec > 1)?cp->kvec:0, cp->rout);
   }
   else /* A or B matrix */
   {
      sz = ((mb+nu-1)/nu)*((nb+mu-1)/mu)*mu*nu;
      i = sprintf(ln, "make %ccopytest CPM=A beta=%d alpha=%d UR=%u ku=%u "
                  " vlen=%u mb=%u nb=%u szb=%u TO_BLK=%u TRANS=%u kvec=%u "
                  "kfnam='%s'", 
                  pre, ibet, ialp, nu, mu, cp->vlen, mb, nb, sz, 
                  ((flag>>CPF_TOBLK)&1), TA, (cp->kvec > 1)?cp->kvec:0, 
                  cp->rout);
   }
   assert(i < L);
   ierr = Sys2File(ln, "ATL_tmp.out");
   if (ierr)
   {
      #if 0
         fprintf(stderr, "\nOUTPUT OF FAILED COMMAND:\n"
         system("cat ATL_tmp.out");
      #endif
      fprintf(stderr, "\nFAILED (%d) COMMAND: '%s'\n", i, ln);
      if (cp->genstr)
         fprintf(stderr, "   genstr= '%s'\n", cp->genstr);
   }
   remove("ATL_tmp.out");
   if (!ierr && CPLX)
   {
      assert(i+14 < L);
      strcpy(ln+i, " CNJ='-DConj_'");
      ierr = Sys2File(ln, "ATL_tmp.out");
      if (ierr)
      {
         #if 0
            fprintf(stderr, "\nOUTPUT OF FAILED COMMAND:\n"
            system("cat ATL_tmp.out");
         #endif
         fprintf(stderr, "\nFAILED CNJ (%d) COMMAND: '%s'\n", i, ln);
         if (cp->genstr)
         fprintf(stderr, "   genstr= '%s'\n", cp->genstr);
      }
      remove("ATL_tmp.out");
   }
   free(ln);
   return(ierr);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
ATL_cpnode_t *KillFailingCPNodes(char pre, ATL_cpnode_t *cb)
{
   ATL_cpnode_t *cp;
   int i;
   int nerr=0;
   for (i=0,cp=cb; cp; i++)
   {
      ATL_cpnode_t *next = cp->next;
      int err, ibet=0, ialp, mb=cp->mb, nb=cp->nb;

      ialp = CopyGetAlphaI(cp->flag);
      if (cp->flag & (1<<CPF_CBLK))
         ibet = CopyGetBetaI(cp->flag);
      if (!mb)
         mb = 5*cp->mu;
      if (!nb)
         nb = 7*cp->nu;
      if (cp->flag&(1<<CPF_SYRK))
         nb = mb;
      err = CPKernelFailsTest(pre, ((cp->flag>>CPF_TRANS)&1), mb, nb, 
                              ialp, ibet, cp);
      if (cp->ID)
         printf("%3d. ID=%d (%s) : %s\n", i, cp->ID, cp->rout, 
                (err) ? "FAIL!":"PASS.");
      else
         printf("%3d. B=(%u,%u), U=(%u,%u), VL=(%d,%d) : %s\n", i, 
                cp->mb, cp->nb, cp->mu, cp->nu, cp->vlen, cp->kvec, 
                (err) ? "FAIL!":"PASS.");
      if (err)
      {
         cb = KillCPNodeFromQ(cb, cp);
         nerr++;
      }
      cp = next;
   }
   if (nerr)
      printf("FAILED %u of %u tests!\n\n", nerr, i);
   else
      printf("PASSED ALL %u tests.\n\n", i);
   return(cb);
}

#endif
@ROUT atlas_r1testtime.h atlas_r2testtime.h atlas_mvtesttime.h
static int SprintAlignStr
(
   char pre,            /* precision modifier */
   ATL_@(ru)node_t *kp, /* kernel pointer */
   char *str            /* (OUTPUT) string to print to */
)
/*
 * Prints alignment string to str, based on alignment setting.
 * This routine assumes to force the alignment to sizeof(TYPE) unless 
 * restrictions are enabled.
 * RETURNS: number of chars added to str
 */
{
   const int size = (pre == 'd' || pre == 's') ? pre2size(pre) 
                                                 : (pre2size(pre)>>1);
   int alignA, alignX, alignY, i;

   alignA = (kp->alignA) ? kp->alignA : size;
   alignX = (kp->alignX) ? kp->alignX : size;
   alignY = (kp->alignY) ? kp->alignY : size;
@ROUT atlas_r1testtime.h atlas_r2testtime.h
   if (FLAG_IS_SET(kp->flag, @up@(ru)F_ALIGNX2A))
      alignX = alignA;  /* ALIGNX2A overrides alignX */
@ROUT atlas_mvtesttime.h
@beginskip
   {
      if (kp->TA == AtlasNoTrans) /* ALIGNX2A affects Y for No-Trans */
         alignY = alignA; /* ALIGNX2A overrides alignY */
      else
         alignX = alignA; /* ALIGNX2A overrides alignX */
   }
@endskip
/*
 * If we are doing an AXPY-based No-Trans GEMV, it is Y, not X that must
 * be aligned to A.  Therefore, alignX/ALIGNX2A actually refer to Y, and
 * alignY refers to X.  Do this confusing transpose for the non-trans case.
 */
   if (kp->TA == AtlasNoTrans) /* ALIGNX* affects Y for No-Trans */
   {
      i = alignX;
      alignX = alignY;
      alignY = i;
      if (FLAG_IS_SET(kp->flag, @up@(ru)F_ALIGNX2A))
         alignY = alignA; /* ALIGNX2A overrides alignY */
   }
   else if (FLAG_IS_SET(kp->flag, @up@(ru)F_ALIGNX2A))
      alignX = alignA;
@ROUT atlas_r1testtime.h atlas_r2testtime.h atlas_mvtesttime.h
/*
 * If ALIGNX2A, we must force to vectors to have the same remainder when
 * divided by the vector length.  We do this by insisting they have the
 * the same modulo by ATL_Cachelen, which by definition is always a 
 * multiple of the vector length (eg, veclen=16/32 (SSE/AVX), ATL_cl=32). 
 */
   if (FLAG_IS_SET(kp->flag, @up@(ru)F_ALIGNX2A))
   {
      int myalign = ATL_Cachelen - size;
      if (alignA)
      {
         myalign = ((ATL_Cachelen-size)/alignA)*alignA;
         if (!myalign) 
            myalign = alignA;
      }
@ROUT atlas_r1testtime.h atlas_r2testtime.h
      if (myalign < ATL_Cachelen)
         i = sprintf(str, " align=\"-Fa %d -Fa -%d -Fx %d -Fx -%d",
                     myalign, ATL_Cachelen, myalign, ATL_Cachelen);
      else
         i = sprintf(str, " align=\"-Fa %d -Fx %d", myalign, myalign);
      if (2*alignY <= ATL_Cachelen)
         i += sprintf(str+i, " -Fy %d -Fy -%d\"", alignY, 2*alignY);
      else
         i += sprintf(str+i, " -Fy %d\"", alignY);
@ROUT atlas_mvtesttime.h
      if (kp->TA == AtlasNoTrans) /* ALIGNX* affects Y for No-Trans */
      {
         if (myalign < ATL_Cachelen)
            i = sprintf(str, " align=\"-Fa %d -Fa -%d -Fy %d -Fy -%d",
                        myalign, ATL_Cachelen, myalign, ATL_Cachelen);
         else
            i = sprintf(str, " align=\"-Fa %d -Fy %d", myalign, myalign);
         if (2*alignX <= ATL_Cachelen)
            i += sprintf(str+i, " -Fx %d -Fx -%d\"", alignX, 2*alignX);
         else
            i += sprintf(str+i, " -Fx %d\"", alignX);
      }
      else
      {
         if (myalign < ATL_Cachelen)
            i = sprintf(str, " align=\"-Fa %d -Fa -%d -Fx %d -Fx -%d",
                        myalign, ATL_Cachelen, myalign, ATL_Cachelen);
         else
            i = sprintf(str, " align=\"-Fa %d -Fx %d", myalign, myalign);

         if (2*alignY <= ATL_Cachelen)
            i += sprintf(str+i, " -Fy %d -Fy -%d\"", alignY, 2*alignY);
         else
            i += sprintf(str+i, " -Fy %d\"", alignY);
      }
@ROUT atlas_r1testtime.h atlas_r2testtime.h atlas_mvtesttime.h
   }
   else
   {
      if (2*alignA <= ATL_Cachelen)
         i = sprintf(str, " align=\"-Fa %d -Fa -%d", alignA, 2*alignA);
      else
         i = sprintf(str, " align=\"-Fa %d ", alignA);
      if (2*alignX <= ATL_Cachelen)
         i += sprintf(str+i, " -Fx %d -Fx -%d", alignX, 2*alignX);
      else
         i += sprintf(str+i, " -Fx %d", alignX);
      if (2*alignY <= ATL_Cachelen)
         i += sprintf(str+i, " -Fy %d -Fy -%d\"", alignY, 2*alignY);
      else
         i += sprintf(str+i, " -Fy %d\"", alignY);
   }
   return(i);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static int @up@(rt)KernelFailsTest
   (int verb, char pre, ATL_INT M, ATL_INT N, ATL_INT lda, ATL_@(ru)node_t *kn)
{
   char ln[4096];
   char *sp;
   int i, lda0;
   static char outnam[L_tmpnam];
   static int FirstTime=1;

   if (FirstTime)
   {
      
      FirstTime = 0;
      assert(tmpnam(outnam));
   }
/*
 * If the file is generated, call generator to create it
 */
   if (kn->genstr)
   {
      i = sprintf(ln, "%s", kn->genstr);
      if (verb < 3)
         i += sprintf(ln+i, " > %s 2>&1\n", outnam);
      if (system(ln))
      {
         fprintf(stderr, "ERROR, LINE %d of %s\n", __LINE__, __FILE__);
         fprintf(stderr, "UNABLE TO GENERATE WITH COMMAND: %s\n", kn->genstr);
         if (verb < 3)
         {
            fprintf(stderr, "\nOUTPUT OF system():\n");
            sprintf(ln, "cat %s 1>&2\n", outnam);
            i = system(ln);
         }
         remove(outnam);
         exit(-1);
      }
   }
   assert(kn->rout);
   assert (M >= kn->minM);
   assert (N >= kn->minN);
@ROUT atlas_mvtesttime.h
   sp = (kn->TA == AtlasNoTrans) ? "mvn" : "mvt";
   if (kn->TA == AtlasNoTrans)
      i = sprintf(ln, "make %cmvnktest mvnrout=%s", pre, kn->rout);
   else
      i = sprintf(ln, "make %cmvtktest mvtrout=%s", pre, kn->rout);
@ROUT atlas_r1testtime.h atlas_r2testtime.h
   i = sprintf(ln, "make %c@(rt)ktest @(at)rout=%s", pre, kn->rout);
@ROUT atlas_r1testtime.h atlas_r2testtime.h atlas_mvtesttime.h
   i += SprintAlignStr(pre, kn, ln+i);
   if (FLAG_IS_SET(kn->flag, @up@(ru)F_FNU))
       i += sprintf(ln+i, " Nt=%d ", (1008/kn->NU)*kn->NU);
   if (kn->exflags)
      i += sprintf(ln+i, " %s", kn->exflags);
   if (1)   /* NOTE: replace with test on restrict or not! */
      i += sprintf(ln+i, " incy=1");
   if (kn->comp)
      i += sprintf(ln+i, " %c@up@(rt)CC=\"%s\"", pre, kn->comp);
   if (kn->cflags)
@ROUT atlas_mvtesttime.h
      i += sprintf(ln+i, " %c@up@(rt)FLAGS=\"%s\"", pre, kn->cflags);
@ROUT atlas_r1testtime.h atlas_r2testtime.h
      i += sprintf(ln+i, " %c@up@(rt)CFLAGS=\"%s\"", pre, kn->cflags);
@ROUT atlas_r1testtime.h atlas_r2testtime.h atlas_mvtesttime.h
   i += sprintf(ln+i, " Mt=%d Nt=%d ldat=%d", M, N, lda);
   if (verb < 3)
      i += sprintf(ln+i, " > %s 2>&1\n", outnam);
   else 
      i += sprintf(ln+i, "\n");
   if (verb > 1)
      fprintf(stdout, "system call:%s\n", ln);
   i = system(ln);
   if (verb)
   {
      if (i)
      {
         fprintf(stderr, "\n%s(ID=%d) FAILS TESTER!!\n", kn->rout,kn->ID);
         fprintf(stderr, "FAILING CALL: '%s'\n", ln);
         if (verb < 3 && verb > 0)
         {
            int itmp;
            fprintf(stderr, "\nOUTPUT OF system():\n");
            sprintf(ln, "cat %s 1>&2\n", outnam);
            itmp = system(ln);
         }
      }
      else
         fprintf(stderr, "%s(ID=%d) *PASSES* TESTER!!\n", kn->rout,kn->ID);
   }
   if (verb < 3)
      remove(outnam);
   return(i);
}


@iexp ip @(ip) 1 +
/* procedure @(ip) */
static char *GetResIdStr(ATL_@(ru)node_t *r1p, ATL_INT M, ATL_INT N,
                         ATL_INT lda, ATL_INT percL1, int mflop)
{
/* 
 * Return filename suffix that disambiguates most kernels:
 * <ID><TA>_<M>x<N>_<lda>-<ldamul>_<MU>x<NU>_<percL1>_a<alignA>x<aX>x<aY>_<flag>
 */
   static char ln[512];
@ROUT atlas_mvtesttime.h
   sprintf(ln, "%d%c_%dx%d_%d-%d_%dx%d_%d_a%dx%dx%d_%d", r1p->ID, 
           (r1p->TA == AtlasNoTrans) ? 'N' : 'T', M, N, lda, r1p->ldamul,
            r1p->MU, r1p->NU, percL1, r1p->alignA, r1p->alignX, r1p->alignY, 
            r1p->flag);
@ROUT atlas_r1testtime.h atlas_r2testtime.h
   sprintf(ln, "%d_%dx%d_%d-%d_%dx%d_%d_a%dx%dx%d_%d", r1p->ID, 
           M, N, lda, r1p->ldamul, r1p->MU, r1p->NU, percL1, 
           r1p->alignA, r1p->alignX, r1p->alignY, r1p->flag);
@ROUT atlas_r1testtime.h atlas_r2testtime.h atlas_mvtesttime.h
   return(ln);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static double Time@up@(rt)Kernel
(int verb,              /* 0: no output, 1 min ouput, 2: full output */
 int FORCETIME,         /* if nonzero, ignore existing timing file */
                        /* if negative, don't retain timing file */
 ATL_@(ru)node_t *r1p,     /* ptr to kernel structure */
 char pre,              /* precision prefix */
 ATL_INT M, ATL_INT N,  /* dimensions to time */
 ATL_INT lda,           /* stride between row elements */
 ATL_INT percL1,        /* if 0, time kernel directly wt no blocking */
                        /* if non-zero, block for that % of L1 cache size */
 int nrep,              /* if >=1, # of trials, else use default (3) */
 int mflop,             /* force mflop flops in each timing interval */
 int cflush             /* if >= 0, size of cache flush area, else ignored */
)
{
   char ln[2048], resf[256], *sp;
   double *dp, mf;
   int i, align = pre2size(pre);
   static char outnam[L_tmpnam];
   static int FirstTime=1;

   if (FirstTime)
   {
      
      FirstTime = 0;
      assert(tmpnam(outnam));
   }
/*
 * If the file is generated, call generator to create it
 */
   if (r1p->genstr)
   {
      i = sprintf(ln, "%s", r1p->genstr);
      if (verb < 3)
         i += sprintf(ln+i, " > %s 2>&1\n", outnam);
      if (system(ln))
      {
         fprintf(stderr, "ERROR, LINE %d of %s\n", __LINE__, __FILE__);
         fprintf(stderr, "UNABLE TO GENERATE WITH COMMAND: %s\n", r1p->genstr);
         if (verb < 3)
         {
            int itmp;
            fprintf(stderr, "\nOUTPUT OF system():\n");
            sprintf(ln, "cat %s 1>&2\n", outnam);
            itmp = system(ln);
         }
         exit(-1);
      }
   }

   if (r1p->minN)
      N = Mmax(N, r1p->minN);
   if (r1p->minM)
   {
      M = Mmax(M, r1p->minM);
      if (lda < M) 
         lda = M;
   }
   if (FLAG_IS_SET(r1p->flag, @up@(ru)F_FNU))
      N = Mmax(r1p->NU, (N/r1p->NU)*r1p->NU);
   i = r1p->ldamul / pre2size(pre);
   lda = (i) ? ((lda+i-1)/i)*i : lda;

   if (FORCETIME < 0)
      sprintf(resf, "res/%c@(rt)tmp", pre);
   else
      sprintf(resf, "res/%c@(rt)%s", pre, 
              GetResIdStr(r1p, M, N, lda, percL1, mflop));
   if (FORCETIME)
      remove(resf);
   dp = FORCETIME ? NULL : ReadResultsFile(0, nrep, resf);
   if (dp)
   {
      if (verb > 0)
         fprintf(stdout, "   %d:%s (M=%d, N=%d, lda=%d) gets %.2f MFLOPS\n", 
                 r1p->ID, r1p->rout, M, N, lda, *dp);
      return(*dp);
   }

@ROUT atlas_mvtesttime.h
   sp = (r1p->TA == AtlasNoTrans || r1p->TA == AtlasConj) ? "mvn" : "mvt";
   if (percL1)
      i = sprintf(ln, "make %c%stime M=%d N=%d lda=%d l1mul=%d %srout=\"%s\"",
                  pre, sp, M, N, lda, percL1, sp, r1p->rout);
   else
      i = sprintf(ln, "make %c%sktime M=%d N=%d lda=%d %srout=\"%s\"",
                  pre, sp, M, N, lda, sp, r1p->rout);
@ROUT atlas_r1testtime.h atlas_r2testtime.h
   if (percL1)
      i = sprintf(ln, "make %c@(rt)time M=%d N=%d lda=%d l1mul=%d @(rt)rout=\"%s\"",
                  pre, M, N, lda, percL1, r1p->rout);
   else
      i = sprintf(ln, "make %c@(rt)ktime M=%d N=%d lda=%d @(rt)rout=\"%s\"",
                  pre, M, N, lda, r1p->rout);
@ROUT atlas_r1testtime.h atlas_r2testtime.h atlas_mvtesttime.h
   if (r1p->flag)
      i += sprintf(ln+i, " iflag=%d", r1p->flag);
   if (r1p->exflags)
      i += sprintf(ln+i, " %s", r1p->exflags);
   if (r1p->comp)
      i += sprintf(ln+i, " %c@up@(rt)CC=\"%s\"", pre, r1p->comp);
   if (r1p->cflags)
@ROUT atlas_mvtesttime.h
      i += sprintf(ln+i, " %c@up@(rt)FLAGS=\"%s\"", pre, r1p->cflags);
@ROUT atlas_r1testtime.h atlas_r2testtime.h
      i += sprintf(ln+i, " %c@up@(rt)CFLAGS=\"%s\"", pre, r1p->cflags);
@ROUT atlas_r1testtime.h atlas_r2testtime.h atlas_mvtesttime.h
   i += SprintAlignStr(pre, r1p, ln+i);
   if (cflush >=0)
      i += sprintf(ln+i, " flushKB=%d", cflush);
   i += sprintf(ln+i, " tflags=\"-f %s", resf);
   if (nrep > 0)
      i += sprintf(ln+i, " -# %d", nrep);

   if (mflop >= 0)
      i += sprintf(ln+i, " -F %d", mflop);
   i += sprintf(ln+i, "\"");
   i += sprintf(ln+i, " mu=%d nu=%d", r1p->MU, r1p->NU);
   if (verb < 3)
      i += sprintf(ln+i, " > %s 2>&1\n", outnam);
   else
      i += sprintf(ln+i, "\n");
   i = system(ln);
   if (i)
   {
      fprintf(stderr, "\nERROR %d, LINE %d OF %s\n", i, __LINE__, __FILE__);
      fprintf(stderr, "SYSTEM CALL FAILED: %s\n", ln);
      if (verb < 3)
      {
         int itmp;
         fprintf(stderr, "\nOUTPUT OF system():\n");
         sprintf(ln, "cat %s 1>&2\n", outnam);
         itmp = system(ln);
         remove(outnam);
      }
      exit(-1);
   }
   if (verb < 3)
      remove(outnam);
   if (verb > 1)
   {
      dp = ReadResultsFile(1, nrep, resf);
      mf = PrintResultsFromFile(stdout, dp);
      free(dp);
      dp = &mf;
   }
   else
      dp = ReadResultsFile(0, nrep, resf);
   assert(dp);
   if (verb == 1)
      fprintf(stdout, "   %d:%s (M=%d, N=%d, lda=%d) gets %.2f MFLOPS\n", 
              r1p->ID, r1p->rout, M, N, lda, *dp);
   return(*dp);
}
@ROUT atlas_mvtesttime.h atlas_r1testtime.h atlas_r2testtime.h

static void FillIn@up@(rt)ExtractGenStrings(char pre, ATL_@(ru)node_t *kb)
/*
 * Creates generator strings to match kb settings
 */
{
   char ln[4096], *suff;
   int i, CL=8, mu;
   if (pre != 'd' && pre != 'c')
      CL = (pre == 'z') ? 4 : 16;
   while(kb)
   {
      if (kb->ID < 900000 || kb->ID >= 1000000) 
      {
         kb = kb->next;
         continue;
      }
      if (kb->asmbits == asmNames2bitfield("GAS_x8664"))
      {
         assert(kb->MU%CL == 0);
         suff = "sse";
         mu = kb->MU/CL;
      }
      else
      {
         mu = kb->MU;
         if (kb->SSE)
            suff = "Csse";
         else
            suff = "C";
      }
@ROUT atlas_mvtesttime.h
      if (kb->TA == AtlasNoTrans)
         i = sprintf(ln, "make %cmvnext_%s order=clmajor mu=%d nu=%d", pre, 
                     suff, mu, kb->NU);
      else
         i = sprintf(ln, "make %cmvtext_%s order=clmajor mu=%d nu=%d", pre, 
                     suff, mu, kb->NU);
@ROUT atlas_r1testtime.h atlas_r2testtime.h
      i = sprintf(ln, "make %c@(rt)ext_%s order=clmajor mu=%d nu=%d", pre, 
                  suff, mu, kb->NU);
@ROUT atlas_mvtesttime.h atlas_r1testtime.h atlas_r2testtime.h
      if (kb->alignA && kb->alignA%16==0 && kb->ldamul && kb->ldamul%16==0)
         i += sprintf(ln+i, " genflags=\"-def ALIGNED 1\"");
         
      if (kb->genstr)
         free(kb->genstr);
      kb->genstr = DupString(ln);
      kb = kb->next;
   }
}
@ROUT atlas_r1testtime.h atlas_r2testtime.h atlas_mvtesttime.h
#endif  /* end guard around atlas_@(rt)testtime.h */
@ROUT atlas_mmtesttime.h
#define ATL_WANT_ILCM 1
#include "atlas_iopt.h"
#ifndef Mmax
   #define Mmax(x_, y_) ( ((x_) >= (y_)) ? (x_):(y_) )
#endif
@iexp ip @(ip) 1 +
/* procedure @(ip) */
double MMMflop2Time(char pre, int M, int N, int K, double mf)
/*
 * Translates mf back into time, assuming gemm timing of M,N,K
 */
{
   return((((2.0*M)*N)*K) / (1000000.0*mf));
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
double MMTime2Mflop(char pre, int M, int N, int K, double time)
/*
 * Translates mf back into time, assuming gemm timing of M,N,K
 */
{
   return((((2.0*M)*N)*K) / (1000000.0*time));
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static double CopyMflop2Time(char pre, int M, int N, double mf)
/*
 * Translates mflop rate mf into time, assuming M*N flops
 */
{
   return(((2.0*M)*N) / (1e6*mf));
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
char *MMGetGenName(char pre, int kb, ATL_mmnode_t *mp)
{
#ifdef ATL_GENERATE  /* generating funcs get unique name */
   char *nm;
   switch(mp->blask)
   {
   case ATL_KSYRK:
      nm = "syrk";
      break;
   case ATL_KSYMM:
      nm = "symm";
      break;
   case ATL_KTRMM:
      nm = "trmm";
      break;
   case ATL_KTRSM:
      nm = "trsm";
      break;
   case ATL_KGECP2A:
      nm = "cp2A";
      break;
   case ATL_KGECPFA:
      nm = "cpFA";
      break;
   case ATL_KGECP2C:
      nm = "cp2C";
      break;
   case ATL_KGECPFC:
      nm = "cpFC";
      break;
   case ATL_KSKCP2C:
      nm = "cp2SK";
      break;
   case ATL_KSKCPFC:
      nm = "cpFSK";
      break;
   case ATL_KGEMM:
   default:
      nm = "amm";
   }
   return(GetMMFilename(pre, nm, mp));
#else                       /* tuning gets default name that is overwritten */
   return(DupString("ATL_tmp.c")); /* avoids cluttering dir wt unused files */
#endif
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
char *MMGetCpGenString
(
   char pre,                    /* precision/type prefix */
   ATL_mmnode_t *mp,            /* mmkern ptr */
   int ialp,                    /* 0,-1,1,2 */
   int ibet                     /* 0,-1,1,2 */
)
{
   char *sp, *gen, *vec;
   size_t sz;

   if (mp->vlen < 2)
      vec = "no";
   else if (FLAG_IS_SET(mp->flag, MMF_KVEC))
      vec = "kdim";
   else
      vec = "mdim";

   if (mp->blask == ATL_KGECPFC || mp->blask == ATL_KGECP2C || 
       mp->blask == ATL_KSKCPFC || mp->blask == ATL_KSKCP2C)
   {
      switch (mp->blask)
      {
      case ATL_KGECPFC:
         gen = "C2blk";
         break;
      case ATL_KGECP2C:
         gen = "blk2C";
         break;
      case ATL_KSKCPFC:
         gen = "syC2blk";
         break;
      case ATL_KSKCP2C:
         gen = "syblk2C";
         break;
      }
      sz = 72 + NumDecDigits(mp->mu);
      sz += NumDecDigits(mp->nu);
      sz += NumDecDigits(mp->vlen);
      sz += strlen(mp->rout);
      sp = malloc(sz);
      assert(sp);
      sprintf(sp, 
"make gen_%s pre=%c vl=%d mu=%d nu=%d cpvl=1 alpha=%d beta=%d vec=%s rt=%s",
              gen, pre, mp->vlen, mp->mu, mp->nu, ialp, ibet, vec, mp->rout);
      return(sp);
   }
   sz = 53 + NumDecDigits(Mmax(mp->mu, mp->nu));
   sz += strlen(mp->rout);
   sp = malloc(sz);
   assert(sp);
   sprintf(sp, "make gen_A%c2blk UR=%d alpha=1 kmaj=%d vec=%s rt=%s", 
           mp->TA==AtlasTrans?'T':'N', Mmax(mp->mu, mp->nu), 
           FLAG_IS_SET(mp->flag,MMF_KVEC), vec, mp->rout);
   return(sp);
}
@beginskip

@iexp ip @(ip) 1 +
/* procedure @(ip) */
char *MMGetCpGenString_vec
(
   char pre,                    /* precision/type prefix */
   ATL_mmnode_t *mp,            /* mmkern ptr */
   int ialp,                    /* 0,-1,1,2 */
   int ibet,                    /* 0,-1,1,2 */
   char *vec                    /* sse or avx */
)
{
   char *sp, *gen=NULL;
   size_t sz;

   if (mp->blask == ATL_KGECPFC)
      gen = "C2blk";
   else if (mp->blask == ATL_KGECP2C)
      gen = "blk2C";
   else                 /* using old generator for auto-vectorization */
      return(NULL);     /* & it only supports vec for copy to/from C */

   sz = 45 + NumDecDigits(mp->mu);
   sz += NumDecDigits(mp->nu);
   sz += NumDecDigits(ialp);
   sz += NumDecDigits(ibet);
   sz += strlen(mp->rout);
   sp = malloc(sz);
   assert(sp);
   sprintf(sp, "make %s_%s mu=%d nu=%d alpha=%d beta=%d rt=%s",
           gen, vec, mp->mu, mp->nu, ialp, ibet, mp->rout);
   return(sp);
}
@endskip

@iexp ip @(ip) 1 +
/* procedure @(ip) */
char *MMGetFkoGenString
(
   char pre,                    /* precision/type prefix */
   ATL_mmnode_t *mp             /* mmkern ptr */
)
{
   char *frm="make gen_%s_fko pre=%c rt=%s vec=%s vlen=%d mu=%d nu=%d ku=%d"
             " KB=%d bcast=%d pf=%d pfLS=%d";
   char *vec="mdim";
   char *gs, *sp;
   int len;
   int ku=mp->ku;
   int kb, bc;

   if (mp->blask >= ATL_KGECPFA && mp->blask <= ATL_KSKCP2C)
      return(MMGetCpGenString(pre, mp, 1, 1));
   if (FLAG_IS_SET(mp->flag, MMF_KUISKB))
   {
      if (FLAG_IS_SET(mp->flag, MMF_KVEC))
         ku = ((mp->kbB+mp->vlen-1)/mp->vlen)*mp->vlen;
      else
         ku = mp->kbB;
   }
   len = strlen(frm) + strlen(mp->rout) + 4;
   gs = malloc(len);
   assert(gs);
   if (mp->vlen < 2)
      vec = "no";
   else if (FLAG_IS_SET(mp->flag, MMF_KVEC))
   {
      vec = "kdim";
      if (!FLAG_IS_SET(mp->flag, MMF_KUISKB))
         assert(mp->ku % mp->vlen == 0);
   }
   else
      assert(mp->mu % mp->vlen == 0);
   switch(mp->blask)
   {/* 0:ammm, 1:syrk, 2:symm, 3:trmm */
   case ATL_KSYRK:
      sp = "amsyrk";
      break;
   case ATL_KSYMM:
      sp = "amsymm";
      break;
   case ATL_KTRMM:
      sp = "amtrmm";
      break;
   case ATL_KTRSM:
      sp = "amtrsm";
      break;
   case ATL_KGECPFA:
   case ATL_KGECP2A:
   case ATL_KGECPFC:
   case ATL_KGECP2C:
   case ATL_KSKCPFC:
   case ATL_KSKCP2C:
      fprintf(stderr, "Copy routines not supported by FKO gen, kernel type=%d\n",
              mp->blask);
      exit(1);
   default:
      sp = "amm";
   }
   if (FLAG_IS_SET(mp->flag, MMF_NOBCAST))
      bc = 0;
   else
      bc = FLAG_IS_SET(mp->flag, MMF_BREG1) ? 3 : 1;

   if (FLAG_IS_SET(mp->flag, MMF_KRUNTIME))
      kb = 0;
   else if (FLAG_IS_SET(mp->flag, MMF_KVEC))
      kb = ((mp->kbB+mp->vlen-1)/mp->vlen)*mp->vlen;
   else
      kb = mp->kbB;
   
   if (FLAG_IS_SET(mp->flag , MMF_FKO))
     SetExtBFkoRout(mp->rout);
   sprintf(gs, frm, sp, pre, mp->rout, vec, mp->vlen, mp->mu, mp->nu, ku, kb,
           bc, mp->pref, mp->pfLS);
   return(gs);
}

char *GetFKOComp(int i)
{
   return("../../../iFKO/fkoc");
}
char *GetFKOFlags(int i)
{
   return("-vec");
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
char *MMGetGenString
(
   char pre,                    /* precision/type prefix */
   ATL_mmnode_t *mp             /* mmkern ptr */
)
{
   char *frm="make gen_%s pre=%c rt=%s vec=%s vlen=%d mu=%d nu=%d ku=%d"
             " KB=%d bcast=%d pf=%d pfLS=%d";
   char *vec="mdim";
   char *gs, *sp;
   int len;
   int ku=mp->ku;
   int kb, bc;

   if (FLAG_IS_SET(mp->flag, MMF_FKO))
      return(MMGetFkoGenString(pre, mp));
   if (mp->blask >= ATL_KGECPFA && mp->blask <= ATL_KSKCP2C)
      return(MMGetCpGenString(pre, mp, 1, 1));
   if (FLAG_IS_SET(mp->flag, MMF_KUISKB))
   {
      if (FLAG_IS_SET(mp->flag, MMF_KVEC))
         ku = ((mp->kbB+mp->vlen-1)/mp->vlen)*mp->vlen;
      else
         ku = mp->kbB;
   }
   len = strlen(frm) + strlen(mp->rout) + 4;
   gs = malloc(len);
   assert(gs);
   if (mp->vlen < 2)
      vec = "no";
   else if (FLAG_IS_SET(mp->flag, MMF_KVEC))
   {
      vec = "kdim";
      if (!FLAG_IS_SET(mp->flag, MMF_KUISKB))
         assert(mp->ku % mp->vlen == 0);
   }
   else 
      assert(mp->mu % mp->vlen == 0);
   switch(mp->blask)
   {/* 0:ammm, 1:syrk, 2:symm, 3:trmm */
   case ATL_KSYRK:
      sp = "amsyrk";
      break;
   case ATL_KSYMM:
      sp = "amsymm";
      break;
   case ATL_KTRMM:
      sp = "amtrmm";
      break;
   case ATL_KTRSM:
      sp = "amtrsm";
      break;
   case ATL_KGECPFA:
      if (mp->TA == AtlasTrans)
         sp = "AT2blk";
      else if (mp->TA == AtlasConjTrans)
         sp = "cAT2blk";
      else if (mp->TA == AtlasConj)
         sp = "cAN2blk";
      else
         sp = "AN2blk";
      break;
   case ATL_KGECP2A:
      if (mp->TA == AtlasTrans)
         sp = "blk2AT";
      else if (mp->TA == AtlasConjTrans)
         sp = "cblk2AT";
      else if (mp->TA == AtlasConj)
         sp = "cblk2AN";
      else
         sp = "blk2AN";
      break;
   case ATL_KGECPFC:
      sp = "blk2C";
      break;
   case ATL_KGECP2C:
      sp = "C2blk";
      break;
   case ATL_KSKCPFC:
      sp = "SYC2blk";
      break;
   case ATL_KSKCP2C:
      sp = "SYblk2C";
      break;
   default:
      sp = "amm";
   }
   if (FLAG_IS_SET(mp->flag, MMF_NOBCAST))
      bc = 0;
   else
      bc = FLAG_IS_SET(mp->flag, MMF_BREG1) ? 3 : 1;

   if (FLAG_IS_SET(mp->flag, MMF_KRUNTIME))
      kb = 0;
   else if (FLAG_IS_SET(mp->flag, MMF_KVEC))
      kb = ((mp->kbB+mp->vlen-1)/mp->vlen)*mp->vlen;
   else
      kb = mp->kbB;
   sprintf(gs, frm, sp, pre, mp->rout, vec, mp->vlen, mp->mu, mp->nu, ku, kb,
           bc, mp->pref, mp->pfLS);
   return(gs);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
void MMFillInGenStrings(char pre, ATL_mmnode_t *mmb)
{
   ATL_mmnode_t *mp;

   if (pre == 'z')
      pre = 'd';
   else if (pre == 'c')
      pre = 's';

   for (mp=mmb; mp; mp = mp->next)
   {
      if (mp->ID == 0 && !mp->genstr)
         mp->genstr = MMGetGenString(pre, mp);
   }
}

@iexp ip @(ip) 1 +
/* procedure @(ip) : assumed kbB for routname */
void MMFillInGenNames(char pre, ATL_mmnode_t *mmb)
{
   ATL_mmnode_t *mp;
   if (pre == 'z')
      pre = 'd';
   else if (pre == 'c')
      pre = 's';

   for (mp=mmb; mp; mp = mp->next)
   {
      if (mp->ID == 0 && !mp->rout)
         mp->rout = MMGetGenName(pre, mp->kbB, mp);
   }
}

@iexp ip @(ip) 1 +
/* procedure @(ip) : fix genstrs and routs that may have gone stale */
void MMRefreshGenNodes(char pre, ATL_mmnode_t *mmb)
{
   ATL_mmnode_t *mp;
   const char upr=(pre == 'c' || pre == 's') ? 's' : 'z';

   for (mp=mmb; mp; mp = mp->next)
   {
      if (!mp->ID)
      {
         if (mp->rout)
            free(mp->rout);
         if (mp->genstr)
            free(mp->genstr);
         if (FLAG_IS_SET(mp->flag, MMF_KUISKB))
         {
            if (FLAG_IS_SET(mp->flag, MMF_KVEC))
            {
               mp->ku = mp->kbmax = ((mp->kbB+mp->vlen-1)/mp->vlen)*mp->vlen;
               mp->kbmin = mp->kbmax - mp->vlen + 1;
            }
            else
               mp->kbmin = mp->kbmax = mp->kbB;
         }
         else if (mp->ku > 1)
            mp->kbmin = mp->ku;
         mp->rout = MMGetGenName(pre, mp->kbB, mp);
         mp->genstr = MMGetGenString(pre, mp);
      }
   }
}
@iexp ip @(ip) 1 +
/* procedure @(ip) : fix genstrs and routs that may have gone stale */
void WriteRefreshedMMFileWithPath
   (char pre, char *path, char *file, ATL_mmnode_t *nq)
{
   MMRefreshGenNodes(pre, nq);
   WriteMMFileWithPath(pre, path, file, nq);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
ATL_mmnode_t *MMGetNodeGEN(char pre, int flag, int kb, int mu, int nu, int ku, 
                           int vlen, int KVEC, int pf, int pfLS, char *rt)
{
   ATL_mmnode_t *mp;

   mp = GetMMNode();
   mp->mu = mu;
   mp->nu = nu;
   mp->ku = ku;
   mp->vlen = vlen;
   mp->pref = pf;
   mp->pfLS = pfLS;
@beginskip
// checked flag to set FKO and cleared it so that remaining codes work fine
@endskip
   if (flag&4)
   {
      mp->flag |= (1<<MMF_FKO);
      flag ^=4; /* clear fko bit */
   }
   if (flag&1)
      mp->flag |= (1<<MMF_NOBCAST);
   else if (flag&2)
      mp->flag |= (1<<MMF_BREG1);
@beginskip
// These guys presently unused, and setting them here causes flags not to 
// match when nodes are read in from file (type info not presently saved!)
   if (pre == 's' || pre == 'c' || pre == 'S' || pre == 'C')
      mp->flag |= (1<<MMF_SINGLE);
   if (pre == 'c' || pre == 'C' || pre == 'z' || pre == 'Z')
      mp->flag |= (1<<MMF_COMPLEX);
@endskip
   if (!kb)
      mp->flag |= (1<<MMF_KRUNTIME);
   else
      mp->kbB = kb;
   mp->vlen = vlen;
   if (KVEC && vlen > 1)
      mp->flag |= (1<<MMF_KVEC);
   else if (vlen < 2)
      KVEC=1;
   if (!rt)
      rt = MMGetGenName(pre, kb, mp);
   mp->rout = rt;
   mp->genstr = MMGetGenString(pre, mp);
   return(mp);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
int MMDoGenString(int verb, char *genstr)
{
   int err=0;
   if (verb > 2)
      printf("genstr='%s'\n", genstr);
   if (!genstr)
      err=1;
   else if (verb < 3) /* want to redirect output */
   {
      char *ln;
      ln = NewMergedString(genstr, " > /dev/null 2>&1");
      err = system(ln);
      free(ln);
   }
   else
      err = system(genstr);
   if (err)
      fprintf(stderr, "UNABLE TO GENERATE WITH COMMAND: '%s'\n", 
              genstr ? genstr : "NULL");
   return(err);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
char *MMGetTestString
(
   char pre,                    /* precision/type prefix */
   int mb, int nb, int kb,      /* dimensions to test */
   int beta,                    /* beta case to test */
   ATL_mmnode_t *mp            /* mmkern ptr */
)
{
   int i, k, Dd, Ud, Vd;
   int len;
   char *ln, *nm;

   if (FLAG_IS_SET(mp->flag,MMF_FKO))
   {
      if (!mp->comp)
         mp->comp = DupString(GetFKOComp(1));
      if (!mp->cflags)
         mp->cflags = DupString(GetFKOFlags(1));
   }
/*
 * Horrific code so we don't have to rely on snprintf, which some ancient
 * compiler may lack.  The len adjustments should be >= the following
 * sprintf calls (in same order, so they can be adjusted together)
 */
   switch(mp->blask)
   {
   case ATL_KSYRK:
      nm = "syrk";
      break;
   case ATL_KSYMM:
      nm = "symm";
      break;
   case ATL_KTRMM:
      nm = "trmm";
      break;
   default:   /* need to add copy kerns later */
      nm = "ammm";
   }
   len = 22 + 21;                              /* begin & end */
   len += strlen(mp->rout);
   if (mp->ID > 0)
      len += 9;                                /* "AMMCASES/" */
   len += 38 + NumDecDigits(mb) + NumDecDigits(nb) + NumDecDigits(kb);
   len += 16 + NumDecDigits(mp->mu)+NumDecDigits(mp->nu)+NumDecDigits(mp->ku);
   @whiledef iv szA szB szC szExtra vlen
      len += @len@(iv) + 2 + NumDecDigits(mp->@(iv));
   @endwhile
   if (FLAG_IS_SET(mp->flag, MMF_KVEC))
      len += 5 + NumDecDigits(mp->vlen);
   if (beta != 1)
      len += (beta == -1) ? 21 : 6;
   if (mp->comp)
      len += 28 + strlen(mp->comp) + strlen(mp->cflags);

   ln = malloc(len);
   assert(ln);

   i = sprintf(ln, "make %c%stst mmrout=", pre, nm);
   if (mp->ID > 0)
      i += sprintf(ln+i, "AMMCASES/%s ", mp->rout);
   else
      i += sprintf(ln+i, "%s ", mp->rout);
   i += sprintf(ln+i, "pre=%c M=%d N=%d K=%d mb=0 nb=0 kb=%d ",
                pre, mb, nb, kb, FLAG_IS_SET(mp->flag, MMF_KRUNTIME)?0:kb);
   i += sprintf(ln+i, "mu=%d nu=%d ku=%d ", mp->mu, mp->nu, mp->ku);
   @whiledef iv szA szB szC szExtra vlen
    if (mp->@(iv))
       i += sprintf(ln+i, "@(iv)=%d ", mp->@(iv));
   @endwhile
   if (FLAG_IS_SET(mp->flag, MMF_KVEC))
      i += sprintf(ln+i, "kmaj=%d ", mp->vlen);
   if (beta != 1)
   {
      if (beta == -1)
         i += sprintf(ln+i, "beta=-1 betan=\"N1\" ");
      else if (beta == 0)
         i += sprintf(ln+i, "beta=%d ", beta);
      else
         assert(0);
   }
   if (mp->comp)
   {
      char ch = (pre == 'c' || pre == 's') ? 'S' : 'D';
      i += sprintf(ln+i, "%cMC=\"%s\" %cMCFLAGS=\"%s\" ",
                   ch, mp->comp, ch, mp->cflags);
   }
   i += sprintf(ln+i, " > /dev/null 2>&1\n");
   assert(i < len);
   return(ln);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
int MMKernelFailsTest
(
   char pre,                    /* precision/type prefix */
   int mb, int nb, int kb,      /* dimensions to test */
   int beta,                    /* beta case to test */
   ATL_mmnode_t *umm            /* mmkern ptr */
)
/*
 * RETURNS: 0 on success, non-zero on failure
 */
{
   char *ln;
   int i;
   char ch;

/*
 * If the file is generated, call generator to create it
 */
   if (umm->ID == 0 && !umm->genstr)
      umm->genstr = MMGetGenString(pre, umm);
   if (umm->genstr)
      assert(!MMDoGenString(0, umm->genstr));
   ln = MMGetTestString(pre, mb, nb, kb, beta, umm);
   i = system(ln);
   if (i)
   {
      fprintf(stderr, "%d of %s: FAILED COMMAND : %s\n",__LINE__,__FILE__,ln);
      if (umm->genstr)
         fprintf(stderr, "   genstr was = '%s'\n", umm->genstr);
   }
   free(ln);
   return(i);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
int MMKernelFailsAnyBeta
(
   char pre,                    /* precision/type prefix */
   int mb, int nb, int kb,      /* dimensions to test */
   ATL_mmnode_t *umm            /* mmkern ptr */
)
/*
 * RETURNS: 0 on success, non-zero on failure
 */
{
   int i;

   for (i=-1; i < 2; i++)
      if (MMKernelFailsTest(pre, mb, nb, kb, i, umm))
        return(1);
   return(0);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static ATL_mmnode_t *DelBadMMKernels(char pre, int verb, ATL_mmnode_t *bp)
/*
 * Deletes all kernels that can't pass basic usage test
 * RETURNS: modifed bp queue wt failing kernels removed
 */
{
   ATL_mmnode_t *p, *prev;
   int die;

   if (verb > 0)
       printf("\nBEGIN BASIC MATMUL KERNEL TESTS:\n");

   prev = p = bp;
   while (p)
   {
      if (MMKernelFailsTest(pre, p->mbB, p->nbB, p->kbB, 0, p) ||
          MMKernelFailsTest(pre, p->mbB, p->nbB, p->kbB, 1, p) ||
          MMKernelFailsTest(pre, p->mbB, p->nbB, p->kbB, -1, p))
      {
         if (verb > 0)
            printf("   NUKING bad kernel %s(%d)\n", p->rout, p->ID);
         if (p == bp)
            bp = p = KillMMNode(p);
         else
            prev->next = p = KillMMNode(p);
      }
      else
      {
         if (verb > 0)
            printf("   Kernel %s(%d) passes basic tests\n", p->rout, p->ID);
         prev = p;
         p = p->next;
      }
   }
   printf("DONE BASIC KERNEL TESTS.\n\n");
   return(bp);
}
ATL_mmnode_t *GetWorkingUserCases(int verb, char pre)
/*
 * Reads/writes <pre>WORKING.sum, list of kernels that work on this machine.
 * RETURNS: all kernels that pass sanity check on this architecture
 */
{
   ATL_mmnode_t *mmb, *mmp;
   if (pre == 'z')
      pre = 'd';
   else if (pre == 'c')
      pre = 's';
   mmb = ReadMMFileWithPath(pre, "res", "WORKING.sum");
   if (mmb)
      return(mmb);
   mmb = ReadMMFileWithPath(pre, "AMMCASES", "amcases.idx");
   if (!mmb)
      return(mmb);
/*
 * Eliminate those kernels that can't work for any block size
 */
   for (mmp=mmb; mmp; mmp = mmp->next)
   {
      if (FLAG_IS_SET(mmp->flag, MMF_KUISKB))
         mmp->kbmin = mmp->kbmax = mmp->mbB = mmp->nbB = mmp->kbB = mmp->ku;
      else
      {
         int m;
         m = ATL_iLCM(mmp->mu, mmp->nu);
         m = ((60+m-1)/m)*m;
         mmp->mbB = mmp->nbB = mmp->kbB = m;
         if (mmp->kbmin)
            mmp->kbB = Mmax(mmp->kbB, mmp->kbmin);
         if (mmp->kbmax)
            mmp->kbB = Mmin(mmp->kbB, mmp->kbmax);
      }
   }
   mmb = DelBadMMKernels(pre, verb, mmb);
   WriteMMFileWithPath(pre, "res", "WORKING.sum", mmb);
   return(mmb);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
/* 1st 2 bits have verb, next 4 have mov */
#define MMR_NOKFULL 6 /* 1st two bits have verb */
#define MMR_NOKCOMP 7
#define MMR_NOKVEC  8
#define MMR_NOMVEC  9
#define MMR_MKCOMP 10
ATL_mmnode_t *MMApplyRules(ATL_mmnode_t *ob, int flag, int maxKU, int reqVL)
/*
 * Eliminates mmkerns that don't abide by rules given in flag bits >= 6,
 * and sets 4 MMF move bits using bits 2-5.
 * flag: 1st two bits is verb, next 4 is MVS, rest selection rules (MMR_).
 */
{
   ATL_mmnode_t *nb=NULL;
   const unsigned int MVS = (((flag>>2)<<MMF_MVA) & MMF_MVSET);
   if ((flag & (1<<MMR_MKCOMP)) && (flag & (1<<MMR_NOKCOMP)))
         flag ^= 1<<MMR_MKCOMP; /* no MKCOMP, if KCOMP disallowed! */
   while(ob)
   {
      int KILL=0, REGEN=0, KILLFIX=0;
      if (reqVL)
         KILL = (ob->vlen != reqVL);

      if (!KILL&&(flag&(1<<MMR_NOKFULL))&&FLAG_IS_SET(ob->flag, MMF_KUISKB))
      {
         REGEN = KILL = 1;
         if (!ob->ID) /* genned codes poss changed to runtime */
         {
            KILL = 0;
            ob->kbmin = ob->ku = FLAG_IS_SET(ob->flag, MMF_KVEC) ? ob->vlen : 4;
            ob->kbmax = 0;
            ob->flag ^= 1<<MMF_KUISKB;
            ob->flag |= 1<<MMF_KRUNTIME;
         }
      }
      if (!KILL && maxKU && ob->ku > maxKU)
      {
         REGEN = KILL = 1;
         if (!ob->ID) /* for genned codes, see if we can reset KU */
         {
            if (FLAG_IS_SET(ob->flag, MMF_KVEC))
            {
               if (maxKU >= ob->vlen)
               {
                  KILL = 0;
                  ob->kbmin = ob->ku = (maxKU/ob->vlen)*ob->vlen;
               }
            }
            else
            {
               KILL = 0;
               ob->kbmin = ob->ku = Mmin(maxKU, 4);
               @BEGINSKIP
               if (ob->ku > ob->vlen && ob->vlen <= maxKU)
                  ob->ku = (maxKU/ob->vlen)*ob->vlen;
               else
                  ob->ku = 1;
               @ENDSKIP
            }
         }
      }
      if (!KILL&&(flag&(1<<MMR_NOKCOMP))&&!FLAG_IS_SET(ob->flag, MMF_KRUNTIME))
      {
         REGEN = KILL = 1;
         if (!ob->ID) /* genned codes poss changed to runtime */
         {
            KILL = 0;
            if (FLAG_IS_SET(ob->flag, MMF_KVEC))
            {
               if (ob->ku < ob->vlen)
                  ob->ku = ob->vlen;
               else
                  while (ob->ku % ob->vlen)
                     ob->ku--;
            }
            ob->kbmax = 0;
            ob->kbmin = ob->ku;
            ob->flag |= 1<<MMF_KRUNTIME;
         }
      }
      if ((flag&(1<<MMR_NOKVEC)) && FLAG_IS_SET(ob->flag, MMF_KVEC))
         KILL = 1;
      else if ((flag&(1<<MMR_NOMVEC)) && !FLAG_IS_SET(ob->flag, MMF_KVEC))
         KILL = 1;
      if (KILL)
         ob = KillMMNode(ob);
      else /* add to queue, and set it to use selected search type */
      {
         ATL_mmnode_t *nxt=ob->next;
         if (!ob->ID)
         {
            if (ob->genstr)
            {
               free(ob->genstr);
               ob->genstr = NULL;
            }
            if (ob->rout)
               free(ob->rout);
            ob->rout = DupString("ATL_tmp.c");
            ob->flag &= ~MMF_MVSET;
            ob->flag |= MVS;
            if (flag&(1<<MMR_MKCOMP) && !FLAG_IS_SET(ob->flag, MMF_KUISKB)
                && !ob->ID)
            { /* want to try run- & compile-time K */
               ATL_mmnode_t *np=NULL;
               if (FLAG_IS_SET(ob->flag, MMF_KVEC))
               {
                  if (ob->ku == ob->vlen)
                     np = CloneMMNode(ob);
               }
               else if (ob->ku == 1)
                  np = CloneMMNode(ob);
               if (np)
               {
                  if (FLAG_IS_SET(ob->flag, MMF_KRUNTIME))
                     np->flag ^= 1<<MMF_KRUNTIME;
                  else
                  {
                     np->kbmax = 0;
                     np->kbmin = np->ku;
                     np->flag |= 1<<MMF_KRUNTIME;
                  }
                  np->next = nb;
                  nb = np;
               }
            }
         }     /* end if this is generated kern */
         ob->next = nb;
         nb = ob;
         ob = nxt;
      }     /* end else for keeper case */
   }        /* end while(ob); */
   return(nb);
}

@beginskip
@iexp ip @(ip) 1 +
/* procedure @(ip) */
char *GetGmmGenString
(
   int verb,                    /* verbosity */
   char pre,                    /* precision */
   int MACC,                    /* 0 : separate mult&add, else MACC */
   int lat,                     /* multiply latency */
   int beta,                    /* 0,1 beta, else beta=X */
   int nb,                      /* blocking factor */
   int mu, int nu, int ku,      /* unrolling factors */
   int Fftch,                   /* do bogus fetch of C at top of loop? */
   int iftch,                   /* # of initial fetches to do */
   int nftch,                   /* # of fetches to do thereafter */
   int LDTOP,                   /* 1: load C at top, 0: at bottom */
   int pf                       /* prefetch strategy */
)
/*
 * returns a string that will result in generating a user-style kernel
 * specialized for non-cleanup cases by invoking a make target that
 * in turn invokes the scalar generator routine, emit_mm.c
 * Because it is specialized for kernel cases, we don't specify leading
 * dimensions, transpose cases, etc, but just take the defaults.
 */
{
   char ln[4096];
   int i;

   if (!LDTOP)
      pf |= 512;
   i = sprintf(ln, "make mmgencase pre=%c muladd=%d lat=%d beta=%d mb=%d nb=%d kb=%d mu=%d nu=%d ku=%d if=%d nf=%d ff=%d, pfA=%d, csC=%d",
               pre, MACC, lat, beta, nb, nb, nb, mu, nu, ku, iftch, nftch, 
               Fftch, pf, (pre == 'c' || pre == 'z') ? 2 : 1);
   if (verb < 3)
      i += sprintf(ln+i, " > /dev/null 2>&1");
   else
      i += sprintf(ln+i, "\n");
   if (verb > 2)
      printf("genstr='%s'\n", ln);
   return(DupString(ln));
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
void FillInGMMNode(int verb, ATL_mmnode_t *mmp, char pre, int MACC, int lat, 
                   int beta, int nb, int mu, int nu, int ku, 
                   int fftch, int iftch, int nftch, int LDTOP, int pf)
/*
 * Take emit_mm's flags and fill in the standard ATL_mmnode_t struct mmp
 * making all the correct assumptions for the standard copy code
 */
{
   int i;

   if (ku > (nb>>1))
      ku = nb;
   mmp->mbB = mmp->nbB = mmp->kbB = nb;
   mmp->mu = mu;
   mmp->nu = nu;
   mmp->ku = ku;
   mmp->muladd = MACC;
   mmp->lat = lat;
   mmp->fftch = fftch;
   mmp->iftch = iftch;
   mmp->nftch = nftch;
   mmp->pref = pf;
   mmp->SSE = 0;
   mmp->TA = AtlasTrans;
   mmp->TB = AtlasNoTrans;
   mmp->asmbits = 0;
   if (mmp->auth)
      free(mmp->auth);
   if (mmp->rout)
      free(mmp->rout);
   if (mmp->comp)
      free(mmp->comp);
   if (mmp->cflags)
      free(mmp->cflags);
   if (mmp->str)
      free(mmp->str);
   if (mmp->genstr)
      free(mmp->genstr);
   mmp->comp = mmp->cflags = mmp->str = NULL;
   mmp->rout = DupString("dgmm.c");
   mmp->rout[0] = pre;
   mmp->genstr = GetGmmGenString(verb, pre, MACC, lat, beta, nb, mu, nu, ku, 
                                 fftch, iftch, nftch, LDTOP, pf);
   mmp->auth = DupString("Whaley/emit_mm");
   i = 0;
   if (pre == 's' || pre == 'c')
      SET_FLAG(i, MMF_SINGLE, 1);
   if (pre == 'c' || pre == 'z')
      SET_FLAG(i, MMF_COMPLEX, 1);
   mmp->flag = i;
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
double TimeGMMKernel            /* times kernels generated by emit_mm */
(
   int verb,                    /* verbosity */
   int FORCETIME,               /* 1: ignore any prior output file */
   char pre,                    /* precision */
   int MACC,                    /* 0 : separate mult&add, else MACC */
   int lat,                     /* multiply latency */
   int beta,                    /* 0,1 beta, else beta=X */
   int nb,                      /* blocking factor */
   int mu, int nu, int ku,      /* unrolling factors */
   int Fftch,                   /* do bogus fetch of C at top of loop? */
   int iftch,                   /* # of initial fetches to do */
   int nftch,                   /* # of fetches to do thereafter */
   int LDTOP,                   /* 1: load C at top, 0: at bottom */
   int pf,                      /* prefetch strategy */
   int mflop,                   /* >0: force mflop MFLOPs in each time interv */
   int cflush                   /* >0: size of cache flush, else ignored */
)
{
   int i;
   char *bet;
   FILE *fp;
   double *dp;
   char fnam[256];
   char ln[4096];

   if (beta == 1)
      bet = "_b1";
   else if (beta == 0)
      bet = "_b0";
   else if (beta == -1)
      bet = "_bn1";
   else
      bet = "_bX";
   if (!LDTOP)
      pf |= 512;
   if (ku > nb/2)
      ku = nb;
   else if (ku == -1)
      ku = nb;
   sprintf(fnam,
           "res/%c%smm%c%c%d_%dx%dx%d_%dx%dx%d_%dx%dx%d%s%s_%dx%d_%d_pf%d_cf%d",
            pre, "JIK", 'T', 'N', nb, nb, nb, nb, nb, nb, 0, mu, nu, ku,
            "_a1", bet, MACC, lat, 1, pf, cflush);
   dp = (FORCETIME) ? NULL : ReadResultsFile(0, 0, fnam);
   if (!dp)
   {
      i = sprintf(ln, "make mmcase pre=%c loopO=JIK ta=T tb=N mb=%d nb=%d kb=%d lda=%d ldb=%d ldc=%d mu=%d nu=%d ku=%d alpha=1 beta=%d muladd=%d lat=%d cleanup=1 pfA=%d casnam=\"%s\"",
                  pre, nb, nb, nb, nb, nb, 0, mu, nu, ku, beta, MACC, lat, pf,
                  fnam);
      if (pre == 'c' || pre == 'z')
         i += sprintf(ln+i, " csA=1 csB=1 csC=2");
       
      if (verb < 3)
         i += sprintf(ln+i, " > /dev/null 2>&1\n");
      else
         i += sprintf(ln+i, "\n");
      if (verb > 1)
         fprintf(stdout, "SYSTEM: %s", ln);
      if (system(ln))
      {
         fprintf(stderr, "ERROR IN COMMAND: %s", ln);
         fprintf(stderr, "   PROPOSED FILENAME: %s\n", fnam);
         sprintf(ln, "rm -f %s\n", fnam);
         assert(!system(ln));
         exit(-1);
      }
      dp = ReadResultsFile(0, 0, fnam);
   }
   if (dp == NULL)
   {
      fprintf(stderr, "Failed ReadResultsFile, ln='%s'\n", ln); 
      fprintf(stderr, "fnam=%s\n", fnam); 
   }
   assert(dp);
   return(*dp);
}
@endskip

@iexp ip @(ip) 1 +
/* procedure @(ip) */
void MMFixGenK(char pre, ATL_mmnode_t *mb, int K)
{
   ATL_mmnode_t *mp;

   for (mp=mb; mp; mp = mp->next)
   {
      if (!mp->ID && FLAG_IS_SET(mp->flag, MMF_KUISKB) && mp->kbB != K)
      {
         mp->kbmax = mp->kbmin = mp->ku = mp->kbB = K;
         if (!mp->rout)
            mp->rout = DupString("ATL_tmp.c");
         if (mp->genstr)
            free(mp->genstr);
         mp->genstr = MMGetGenString(pre, mp);
      }
   }
}
@iexp ip @(ip) 1 +
/* procedure @(ip) */
double TimeMMKernel3F
(
   int verb,                    /* 0: no output, 1 min output, 2: full output */
   int flag,                   /* 1: ignore any prior output file */
   ATL_mmnode_t *mmp,           /* ptr to mmkern struct */
   char pre,                    /* type/prec prefix: z,c,d,s */
   int mb, int nb, int kb,      /* dimensions to time */
   int beta,                    /* beta to time */
   int mflop,                   /* >0: force mflop MFLOPs in each time interv */
   int cflush,                  /* >=0: size of cache flush, else ignored */
   int aFL,                     /* >=0: size of cache flush, else ignored */
   int bFL,                     /* >=0: size of cache flush, else ignored */
   int cFL                      /* >=0: size of cache flush, else ignored */
)
/*
 * flag - take actions the following actions if bit location is set:
 *    0 : ignore any prior output file on output
 *    1 : time in serial rather than parallel
 * NOTE: this kernel not updated to time copy codes.  AFAIK, doesn't need to
 */
{
   char fnam[128], ln[4096];  /* security from 1991 */
   const char *LO = FLAG_IS_SET(mmp->flag, MMF_AOUTER) ? "IJK": "JIK";
   const int vl=mmp->vlen;
   const int ku=mmp->ku;
   const int KB = (!FLAG_IS_SET(mmp->flag,MMF_KVEC)) ? kb : ((kb+vl-1)/vl)*vl;
   const int FORCETIME = flag&1, SERIAL=flag&2;
   int KU=mmp->ku;
   int DOTIME=1;
   int MV=3;  /* bit pattern on move CBA (C=4, B=2, A=1) */
   char *be, *gs0=mmp->genstr;
   int i, j;
   char ch;
   double *dp;
   MV = ((mmp->flag) >> MMF_MVA)&7;
/*
 * If it's a emit_mm generated file with a missing or bad genstring, make it
 */

   if (FLAG_IS_SET(mmp->flag, MMF_KUISKB))
      KU = KB;
   else if (ku > KB)
      KU = KB;
   if (mmp->ID == 0 && (KB != mmp->kbB || KU != mmp->ku || !mmp->genstr))
   {
      int kb0=mmp->kbB, ku0=mmp->ku;
      mmp->kbB = KB;
      mmp->ku = KU;
      mmp->genstr = MMGetGenString(pre, mmp);
      mmp->kbB = kb0;
      mmp->ku = ku0;
   }
/*
 * If the file is generated, call generator to create it
 */
   if (mmp->genstr)
      assert(!MMDoGenString(verb, mmp->genstr));
   else if (verb > 2)
      printf("NO genstr\n");
/*
 * Figure out the name of the output file
 */
   if (FORCETIME)
      strcpy(fnam, "res/tmpout.ktim");
/*
 * PREammID_MBxNBxKB_MUxNUxKU_FLAG_v[M,K]VLENbBETA_CFLUSH
 */
   else
   {
      if (mmp->vlen < 2)
         ch = 'S';
      else
         ch = (FLAG_IS_SET(mmp->flag,MMF_KVEC)) ? 'K' : 'M';

      sprintf(fnam,
      "res/%cammm%d_%dx%dx%d_%dx%dx%d_%x_v%c%db%d_pf%xx%d_%d.ktim",
              pre, mmp->ID, mb, nb, KB, mmp->mu, mmp->nu, KU,
              mmp->flag, ch, mmp->vlen, beta, mmp->pref, mmp->pfLS, cflush);
      if (mmp->blask == ATL_KSYRK)
      {
         fnam[5] = 's';
         fnam[6] = 'y';
         fnam[7] = 'r';
         fnam[8] = 'k';
      }
      else if (mmp->blask == ATL_KSYMM)
      {
         fnam[5] = 's';
         fnam[6] = 'y';
         fnam[7] = 'm';
         fnam[8] = 'm';
      }
      else if (mmp->blask == ATL_KSYRK)
      {
         fnam[5] = 's';
         fnam[6] = 'y';
         fnam[7] = 'r';
         fnam[8] = 'k';
      }
      else if (mmp->blask == ATL_KTRMM)
      {
         fnam[5] = 't';
         fnam[6] = 'r';
         fnam[7] = 'm';
         fnam[8] = 'm';
      }
   }
/*
 * If we actually need to do timing, must also construct timer call
 */
   if (!FORCETIME)
      DOTIME = !FileExists(fnam);
   #define RESACT 2   /* want average frm ReadResultsFile for parallel */
   if (DOTIME)
   {
      char *nm="amm";
      if (mmp->blask == ATL_KSYRK)
         nm = "syk";
      else if (mmp->blask == ATL_KSYMM)
         nm = "sym";
      else if (mmp->blask == ATL_KTRSM)
         nm = "trm";
      i = sprintf(ln, "make x%c%stime_pt3f mb=%d nb=%d kb=%d",
                  pre, nm, mb, nb, KB);
      if (mflop)
         i += sprintf(ln+i, " FMFS=\"-Rf %d\"", mflop);
      if (SERIAL)
         i += sprintf(ln+i, " NPROC=1");
      if (mmp->genstr)
         i += sprintf(ln+i, " mmrout=%s", mmp->rout);
      else
         i += sprintf(ln+i, " mmrout=AMMCASES/%s", mmp->rout);
      i += sprintf(ln+i, " mu=%d nu=%d ku=%d", mmp->mu, mmp->nu, KU);
    if (mmp->vlen)
       i += sprintf(ln+i, " vlen=%d", mmp->vlen);
    if (mmp->szExtra)
       i += sprintf(ln+i, " szExtra=%d", mmp->szExtra);
    if (mmp->szC)
       i += sprintf(ln+i, " szC=%d", mmp->szC);
    if (mmp->szB)
       i += sprintf(ln+i, " szB=%d", mmp->szB);
    if (mmp->szA)
       i += sprintf(ln+i, " szA=%d", mmp->szA);
      i += sprintf(ln+i, " mvA=%d mvB=%d mvC=%d", ((mmp->flag >> MMF_MVA)&1),
                   ((mmp->flag >> MMF_MVB)&1), ((mmp->flag >> MMF_MVC)&1));
      i += sprintf(ln+i, " kmoves=\"");
      if (FLAG_IS_SET(mmp->flag, MMF_MVA))
         i += sprintf(ln+i, " -DATL_MOVEA");
      if (FLAG_IS_SET(mmp->flag, MMF_MVB))
         i += sprintf(ln+i, " -DATL_MOVEB");
      if (FLAG_IS_SET(mmp->flag, MMF_MVC))
      i += sprintf(ln+i, " -DATL_MOVEC");
      i += sprintf(ln+i, "\"");
      //if (cflush > 0 || aFL > 0 || bFL > 0 || cFL > 0)
      {
         if (cflush > 0)
               i+= sprintf(ln+i, " CFLUSH=\"%d ", cflush);
            else
               i+= sprintf(ln+i, " CFLUSH=\"%d", -1);
            if (aFL > 0)
               i+= sprintf(ln+i, " -Fa %d ", aFL);
            if (bFL > 0)
               i+= sprintf(ln+i, " -Fb %d ", bFL);
            if (cFL > 0)
               i+= sprintf(ln+i, " -Fc %d ", cFL);
            i+= sprintf(ln+i, " \"");
      }
      if (mmp->pref)
      {
         if (mmp->pfLS)
            i += sprintf(ln+i, " pf=%d pfLS=%d", mmp->pref, mmp->pfLS);
         else
            i += sprintf(ln+i, " pf=%d", mmp->pref);
      }
      if (beta == 1 || beta == 0)
         i += sprintf(ln+i, " beta=%d", beta);
      else
         i += sprintf(ln+i, " beta=-1 betan=\"N1\"");
      ch = (pre == 'c' || pre == 's') ? 'S' : 'D';
      if (mmp->comp)
         i += sprintf(ln+i, " %cMC=\"%s\"", ch, mmp->comp);
      if (mmp->cflags)
         i += sprintf(ln+i, " %cMCFLAGS=\"%s\"", ch, mmp->cflags);
      i += sprintf(ln+i, " outF=\"-f %s\"", fnam);
   }
   if (FORCETIME || !FileExists(fnam))
   {
      if (verb < 3)
         i += sprintf(ln+i, " > /dev/null 2>&1\n");
      else
         i += sprintf(ln+i, "\n");
      if (verb > 1)
         fprintf(stdout, "SYSTEM: %s", ln);
      if (i=system(ln))
      {
         fprintf(stderr, "ERROR %d IN COMMAND: %s", i, ln);
         fprintf(stderr, "   PROPOSED FILENAME: %s\n", fnam);
         if (mmp->genstr)
            fprintf(stderr, "   GENSTR='%s'\n", mmp->genstr);
         sprintf(ln, "rm -f %s\n", fnam);
         assert(!system(ln));
         exit(-1);
      }
   }
   if (mmp->genstr != gs0)  /* put genstr back to original value */
   {
      free(mmp->genstr);
      mmp->genstr = gs0;
   }
   dp = ReadResultsFile(RESACT, 0, fnam);
   if (!dp)
   {
      fprintf(stderr, "\nEmpty file '%s'!\n", fnam);
      fprintf(stderr, "From command: '%s'\n", ln);
      fprintf(stderr, "DOTIME=%d, genstr='%s'\n", DOTIME,
              (mmp->genstr) ? mmp->genstr : "");
      exit(-1);
   }
   if (mmp->genstr && DOTIME)
   {
      sprintf(ln, "rm %s\n", mmp->rout);
      i = system(ln);  /* return value unused, just to shut gcc up */
   }
   if (kb != KB)
   {
      double mf;
      mf = *((double*)ReadResultsFile(RESACT, 0, fnam));
      mf = (mf / KB)*kb;
      return(mf);
   }
   return(*((double*)ReadResultsFile(RESACT, 0, fnam)));
   #undef RESACT
}  /* end TimeMMKernel3F */

@iexp ip @(ip) 1 +
/* procedure @(ip) */
double TimeMMKernel
(
   int verb,                    /* 0: no output, 1 min output, 2: full output */
   int flag,                    /* 1: ignore any prior output file */
   ATL_mmnode_t *mmp,           /* ptr to mmkern struct */
   char pre,                    /* type/prec prefix: z,c,d,s */
   int mb, int nb, int kb,      /* dimensions to time */
   int beta,                    /* beta to time */
   int mflop,                   /* >0: force mflop MFLOPs in each time interv */
   int cflush                   /* >=0: size of cache flush, else ignored */
)
/*
 * flag - take actions the following actions if specified bit position is set:
 *    0 : ignore any prior output file on output
 *    1 : time in serial rather than parallel
 */
{
   char fnam[128], ln[4096];  /* security from 1991 */
   const char *LO = FLAG_IS_SET(mmp->flag, MMF_AOUTER) ? "IJK": "JIK";
   const int vl=mmp->vlen;
   const int mu=mmp->mu, nu=mmp->nu, ku=mmp->ku;
   int MB, NB, KB = (!FLAG_IS_SET(mmp->flag,MMF_KVEC)) ? kb : ((kb+vl-1)/vl)*vl;
   const int FORCETIME = flag&1, SERIAL=flag&2; 
   const int PUTC=FLAG_IS_SET(mmp->flag, MMF_CPC);
   int KU=mmp->ku;
   int DOTIME=1;
   char *be, *gs0=mmp->genstr;
   int i, j;
   char ch;
   double *dp;
   double mfmul;
/*
 * This routine can time any kernel legal from usage rules, so mb,nb,kb may
 * not be multiples of the unrolling factors, so choose nearest MB,NB,KB,
 * and then compute the percent of useless flops. mfmul can just be multiplied
 * by the return value to compute the useful flop rate.
 */
   MB = ((mb+mu-1)/mu)*mu;
   NB = ((nb+nu-1)/nu)*nu;
   KB = ((kb+ku-1)/ku)*ku;
   if (FLAG_IS_SET(mmp->flag,MMF_KVEC) && vl > ku)
      KB = ((kb+vl-1)/vl)*vl;
   mfmul = kb;
   mfmul = mfmul / KB;  /* ratio of useful to useless flops in K loop */
   mfmul *= ((double)mb)*nb / (((double)MB)*NB);
   if (mmp->blask >= ATL_KGECPFA && mmp->blask <= ATL_KSKCP2C)
      mfmul = 1.0;  /* don't use mfmul for copy routines */
/*
 * If it's a emit_mm generated file with a missing or bad genstring, make it
 */
   
   if (FLAG_IS_SET(mmp->flag,MMF_FKO))
   {
      if (!mmp->comp)
         mmp->comp = DupString(GetFKOComp(1));
      if (!mmp->cflags)
         mmp->cflags = DupString(GetFKOFlags(1));
   }
   if (FLAG_IS_SET(mmp->flag, MMF_KUISKB))
      KU = KB;
   else if (ku > KB)
      KU = KB;
   if (mmp->blask < ATL_KGECPFA && mmp->ID == 0 && 
       (KB != mmp->kbB || KU != mmp->ku || !mmp->genstr))
   {
      int kb0=mmp->kbB, ku0=mmp->ku;
      mmp->kbB = KB;
      mmp->ku = KU;
      mmp->genstr = MMGetGenString(pre, mmp);
      mmp->kbB = kb0;
      mmp->ku = ku0;
   }
/*
 * If the file is generated, call generator to create it
 */
   if (mmp->genstr)
      assert(!MMDoGenString(verb, mmp->genstr));
   else if (verb > 2)
      printf("NO genstr\n");
/*
 * Figure out the name of the output file
 */
   if (FORCETIME)
      strcpy(fnam, "res/tmpout.ktim");
/*
 * PREammID_MBxNBxKB_MUxNUxKU_FLAG_v[M,K]VLENbBETA_CFLUSH
 */
   else
   {
      if (mmp->vlen < 2)
         ch = 'S';
      else
         ch = (FLAG_IS_SET(mmp->flag,MMF_KVEC)) ? 'K' : 'M';

      sprintf(fnam, 
      "res/%cammm%d_%dx%dx%d_%dx%dx%d_%x_v%c%db%d_pf%xx%d_%d.ktim",
              pre, mmp->ID, MB, NB, KB, mmp->mu, mmp->nu, KU, 
              mmp->flag, ch, mmp->vlen, beta, mmp->pref, mmp->pfLS, cflush);
      switch(mmp->blask)
      {
      case ATL_KSYRK:
         fnam[5] = 's';
         fnam[6] = 'y';
         fnam[7] = 'r';
         fnam[8] = 'k';
         break;
      case ATL_KSYMM:
         fnam[5] = 's';
         fnam[6] = 'y';
         fnam[7] = 'm';
         fnam[8] = 'm';
         break;
      case ATL_KTRSM:
         fnam[5] = 't';
         fnam[6] = 's';
         fnam[7] = 'm';
         fnam[8] = 'm';
         break;
      case ATL_KTRMM:
         fnam[5] = 't';
         fnam[6] = 'm';
         fnam[7] = 'm';
         fnam[8] = 'm';
         break;
      case ATL_KGECPFA:
         fnam[5] = 'c';
         fnam[6] = 'p';
         fnam[7] = 'F';
         fnam[8] = 'A';
         break;
      case ATL_KGECP2A:
         fnam[5] = 'c';
         fnam[6] = 'p';
         fnam[7] = '2';
         fnam[8] = 'A';
         break;
      case ATL_KGECPFC:
         fnam[5] = 'c';
         fnam[6] = 'p';
         fnam[7] = '2';
         fnam[8] = 'C';
         break;
      case ATL_KGECP2C:
         fnam[5] = 'c';
         fnam[6] = 'p';
         fnam[7] = 'F';
         fnam[8] = 'C';
         break;
      default:; 
      }
      if (PUTC)  /* need a diff name if we incl cost of copy */
      {
         if (fnam[5] != 'c' || fnam[6] != 'p')
         {
            fnam[7]='c';
            fnam[8]='p';
         }
      }
   }
/* 
 * If we actually need to do timing, must also construct timer call
 */
   if (!FORCETIME)
      DOTIME = !FileExists(fnam);
   #define RESACT 2   /* want average frm ReadResultsFile for parallel */
   if (DOTIME)
   {
      char *nm="amm";
      if (mmp->blask == ATL_KSYRK)
         nm = "syk";
      else if (mmp->blask == ATL_KSYMM)
         nm = "sym";
      else if (mmp->blask == ATL_KTRSM)
         nm = "trs";
      else if (mmp->blask == ATL_KTRMM)
         nm = "trm";
      ch = (pre == 'c' || pre == 's') ? 'S' : 'D';
      if (mmp->blask >= ATL_KGECPFA && mmp->blask <= ATL_KSKCP2C)
      {
         if (mmp->blask < ATL_KGECPFC)
            i = sprintf(ln, "make %ccpytime mb=%d nb=%d TA=%c", pre, mb, nb, 
                        mmp->TA == AtlasTrans ? 'T' : 'N');
         else
            i = sprintf(ln, "make %ccpytimeC mb=%d nb=%d TA=N", pre, mb, nb);
         if (mmp->TB == AtlasTrans) /* time row-wise access */
            i += sprintf(ln+i, " MTDX='-D 8000 8000 8000 1'");
         i += sprintf(ln+i, " kfnam=%s", mmp->rout);
         if (mmp->comp)
            i += sprintf(ln+i, " %cKC=\"%s\"", ch, mmp->comp);
         if (mmp->cflags)
            i += sprintf(ln+i, " %cKCFLAGS=\"%s\"", ch, mmp->cflags);
         if (beta == 1 || beta == 0)
            i += sprintf(ln+i, " beta=%d", beta);
         else if (beta == -1)
            i += sprintf(ln+i, " beta=-1 betan=\"N1\"");
         else
            i += sprintf(ln+i, " beta=2 betan=X");
/*
 *       These routines take alpha from kb, if it is: 0,1,-1,2
 */
         if (kb == 0 || kb == 1)
            i += sprintf(ln+i, " alpha=%d", kb);
         else if (kb == -1)
            i += sprintf(ln+i, " alpha=-1 alphan=\"N1\"");
         else if (kb == 2)
            i += sprintf(ln+i, " alpha=2 alphan=X");
      }
      else
      {
         i = sprintf(ln, "make x%c%stime_pt mb=%d nb=%d kb=%d",
                     pre, nm, MB, NB, KB);
         if (mmp->genstr)
            i += sprintf(ln+i, " mmrout=%s", mmp->rout);
         else
            i += sprintf(ln+i, " mmrout=AMMCASES/%s", mmp->rout);
         if (PUTC)
         {
            if (FLAG_IS_SET(mmp->flag,MMF_ALLTRANS))
               i += sprintf(ln+i, " extdefs=\"-DALLTRANS_=1 -DPUTC=1\"");
            else
               i += sprintf(ln+i, " extdefs=\"-DPUTC=1\"");
         }
         else if (FLAG_IS_SET(mmp->flag,MMF_ALLTRANS))
         {
            i += sprintf(ln+i, " extdefs=\"-DALLTRANS_=1\"");
         }
         if (mmp->comp)
            i += sprintf(ln+i, " %cMC=\"%s\"", ch, mmp->comp);
         if (mmp->cflags)
            i += sprintf(ln+i, " %cMCFLAGS=\"%s\"", ch, mmp->cflags);
         if (beta == 1 || beta == 0)
            i += sprintf(ln+i, " beta=%d", beta);
         else
            i += sprintf(ln+i, " beta=-1 betan=\"N1\"");
      }
      if (mflop)
         i += sprintf(ln+i, " FMFS=\"-Rf %d\"", mflop);
      if (SERIAL)
         i += sprintf(ln+i, " NPROC=1");
      i += sprintf(ln+i, " mu=%d nu=%d ku=%d", mmp->mu, mmp->nu, KU);
   @whiledef iv szA szB szC szExtra vlen
    if (mmp->@(iv))
       i += sprintf(ln+i, " @(iv)=%d", mmp->@(iv));
   @endwhile
      i += sprintf(ln+i, " mvA=%d mvB=%d mvC=%d", ((mmp->flag >> MMF_MVA)&1), 
                   ((mmp->flag >> MMF_MVB)&1), ((mmp->flag >> MMF_MVC)&1));
      i += sprintf(ln+i, " kmoves=\"");
      if (FLAG_IS_SET(mmp->flag, MMF_MVA))
         i += sprintf(ln+i, " -DATL_MOVEA");
      if (FLAG_IS_SET(mmp->flag, MMF_MVB))
         i += sprintf(ln+i, " -DATL_MOVEB");
      if (FLAG_IS_SET(mmp->flag, MMF_MVC))
      i += sprintf(ln+i, " -DATL_MOVEC");
      i += sprintf(ln+i, "\"");
      if (mmp->pref)
      {
         if (mmp->pfLS)
            i += sprintf(ln+i, " pf=%d pfLS=%d", mmp->pref, mmp->pfLS);
         else
            i += sprintf(ln+i, " pf=%d", mmp->pref);
      }
      i += sprintf(ln+i, " outF=\"-f %s\"", fnam);
   }
   if (FORCETIME || !FileExists(fnam))
   {
      if (verb < 3)
         i += sprintf(ln+i, " > /dev/null 2>&1\n");
      else
         i += sprintf(ln+i, "\n");
      if (verb > 1)
         fprintf(stdout, "SYSTEM: %s", ln);
      if (system(ln))
      {
         fprintf(stderr, "ERROR IN COMMAND: %s", ln);
         fprintf(stderr, "   PROPOSED FILENAME: %s\n", fnam);
         if (mmp->genstr)
            fprintf(stderr, "   GENSTR='%s'\n", mmp->genstr);
         sprintf(ln, "rm -f %s\n", fnam);
         assert(!system(ln));
         exit(-1);
      }
   }
   if (mmp->genstr != gs0)  /* put genstr back to original value */
   {
      free(mmp->genstr);
      mmp->genstr = gs0;
   }
   dp = ReadResultsFile(RESACT, 0, fnam);
   if (!dp)
   {
      fprintf(stderr, "\nEmpty file '%s'!\n", fnam);
      fprintf(stderr, "From command: '%s'\n", ln);
      fprintf(stderr, "DOTIME=%d, genstr='%s'\n", DOTIME, 
              (mmp->genstr) ? mmp->genstr : "");
      exit(-1);
   }
   if (mmp->genstr && DOTIME)
   {
      sprintf(ln, "rm %s\n", mmp->rout);
      i = system(ln);  /* return value unused, just to shut gcc up */
   }
   return(mfmul*(*((double*)ReadResultsFile(RESACT, 0, fnam))));
   #undef RESACT
}  /* end TimeMMKernel */

@iexp ip @(ip) 1 +
/* procedure @(ip), times all 3 vectorization schemes */
double MMTimeRangeK
(
   int verb,                    /* 0: no output, 1 min output, 2: full output */
   int flag,                    /* 1: ignore any prior output file */
   ATL_mmnode_t *mmp,           /* ptr to mmkern struct */
   char pre,                    /* type/prec prefix: z,c,d,s */
   int mb, int nb,              /* dimensions to time */
   int K0, int KN, int incK,    /* inclusive range of K's to average */
   int beta,                    /* beta to time */
   int mflop,                   /* >0: force mflop MFLOPs in each time interv */
   int cflush                   /* >=0: size of cache flush, else ignored */
)
{
   double mfA=0.0;
   int k, n=0;
   assert(KN >= K0);
   for (k=K0; k <= KN; k += incK, n++)
   {
      mfA += TimeMMKernel(verb, flag, mmp, pre, mb, nb, k, beta, mflop, cflush);
   }
   return(mfA/n);
}

@iexp ip @(ip) 1 +
/* procedure @(ip), times all 3 vectorization schemes */
ATL_mmnode_t *MMTimeWithGenKB
(
   int verb,                    /* 0: no output, 1 min output, 2: full output */
   int imf,                     /* which mflop array to write to */
   int flag,                    
   ATL_mmnode_t *mmp,           /* ptr to mmkern struct */
   char pre,                    /* type/prec prefix: z,c,d,s */
   int mb, int nb, int kb,      /* dimensions to time */
   int beta,                    /* beta to time */
   int mflop,                   /* >0: force mflop MFLOPs in each time interv */
   int cflush                   /* >=0: size of cache flush, else ignored */
)
/*
 * RETURNS: NULL if kernel cannot support this case, else newly allocated
 *          fully-qualified mmnode describing exact case
 */
{
   int kbOK;
   char *sp;
   ATL_mmnode_t *mp;
   if (!mmp->ID) /* genned: kvec OK wt any mul of vlen, mvec OK wt any K */
      kbOK = FLAG_IS_SET(mmp->flag, MMF_KVEC) ? (kb%mmp->vlen == 0):1;
   else
   {
      kbOK = (mmp->kbmin) ? (nb >= mmp->kbmin) : 1;
      if (kbOK && mmp->kbmax)
         kbOK = nb <= mmp->kbmax;
   }
   kbOK = kbOK && (kb%mmp->ku == 0);
   if (!kbOK || ((mb/mmp->mu)*mmp->mu != mb) || ((nb/mmp->nu)*mmp->nu != nb))
      return(NULL);
   sp = mmp->genstr;
   mmp->genstr=NULL;
   mp = CloneMMNode(mmp);  /* get local copy so we can change */
   mmp->genstr = sp;
   mmp = mp;
   mmp->mbB = mb; mmp->nbB = nb; mmp->kbB = kb;
/*
 * Generated files may need to get genstr and related info corrected
 */
   if (mmp->ID == 0)
   {
      if (FLAG_IS_SET(mmp->flag, MMF_KUISKB))
          mmp->kbmax = mmp->kbmin = mmp->ku = kb;
      if (!FLAG_IS_SET(mmp->flag, MMF_KRUNTIME))
          mmp->kbB = kb;
      mmp->genstr = MMGetGenString(pre, mmp);
   }
   mmp->mflop[imf] = TimeMMKernel(verb, flag, mmp, pre, mb, nb, kb, 
                                  beta, mflop, cflush);
   return(mmp);
}

@iexp ip @(ip) 1 +
/* procedure @(ip), times all 3 vectorization schemes */
void MMPruneMflopTol
(
   ATL_mmnode_t *mmb,           /* ptr to mmkern struct queue */
   int imf,                     /* which mflop array to write to */
   float tol                    /* >1 allow slow kerns, < 1 penalize later */
)
/*
 * First entry always retained.  Later entries must be better than
 * prior best when scaled by tol.  So, tol > 1 will retain slower kernels,
 * while tol < 1 will penalize later kernels.
 */
{
   ATL_mmnode_t *mp;
   double mfB;

   if (tol <= 0.0 || !mmb)
      return;
   mfB = mmb->mflop[imf];

   mp = mmb->next;
   while (mp)
   {
      ATL_mmnode_t *next = mp->next;
      double mf = mp->mflop[imf];
      if (mf*tol < mfB)
      {
         mmb = RemoveMMNodeFromQ(mmb, mp);
         KillMMNode(mp);
      }
      else if (mf > mfB)
         mfB = mf;
      mp = next;
   }
}

@iexp ip @(ip) 1 +
/* procedure @(ip), times all 3 vectorization schemes */
ATL_mmnode_t *MMBestWithGenKB
(
   int verb,                    /* 0: no output, 1 min output, 2: full output */
   int imf,                     /* which mflop array to write to */
   int flag,                    
   ATL_mmnode_t *mmb,           /* ptr to mmkern struct queue */
   char pre,                    /* type/prec prefix: z,c,d,s */
   int mb, int nb, int kb,      /* dimensions to time */
   int beta,                    /* beta to time */
   int mflop,                   /* >0: force mflop MFLOPs in each time interv */
   int cflush                   /* >=0: size of cache flush, else ignored */
)
/*
 * RETURNS: cloned mmnode of best-performing kern from mmB queue, or
 *          NULL if none works for this size
 */
{
   ATL_mmnode_t *mmB=NULL, *mmp;
/*
 * find first kernel that works, declare it best so far
 */
   for (mmp=mmb; mmp && !mmB; mmp = mmp->next)
      mmB = MMTimeWithGenKB(verb, imf, flag, mmp, pre, mb, nb, kb, beta, 
                            mflop, cflush);
   if (verb && mmB)
      printf("      B=(%d,%d,%d): %d,%s, mf=%.2f\n", mb, nb, kb, mmB->ID, 
             mmB->rout, mmB->mflop[imf]);
   if (!mmp)        /* if no other cases to consider */
      return(mmB);  /* return best found (may be NULL) */
/*
 * Now try remaining kerns, and always keep best-performing
 */
   for (mmp=mmp->next; mmp; mmp = mmp->next)
   {
      ATL_mmnode_t *mp;
      mp = MMTimeWithGenKB(verb, imf, flag, mmp, pre, mb, nb, kb, beta, 
                           mflop, cflush);
      if (mp)
      {
         if (verb)
            printf("      B=(%d,%d,%d): %d,%s, mf=%.2f\n", mb, nb, kb, mmB->ID, 
                   mmB->rout, mmB->mflop[imf]);
         if (mp->mflop[imf] > mmB->mflop[imf])
         {
            KillMMNode(mmB);
            mmB = mp;
         }
         else
            KillMMNode(mp);
      }
   }
   return(mmB);
}

@iexp ip @(ip) 1 +
/* procedure @(ip), times all 3 vectorization schemes */
int MMTimeAllVecGen
(
   int verb,                    /* 0: no output, 1 min output, 2: full output */
   int flag,                    /* 1: ignore any prior output file */
   ATL_mmnode_t *mp,            /* ptr to mmkern struct */
   char pre,                    /* type/prec prefix: z,c,d,s */
   int mb, int nb, int kb,      /* dimensions to time */
   int beta,                    /* beta to time */
   int mflop,                   /* >0: force mflop MFLOPs in each time interv */
   int cflush                   /* >=0: size of cache flush, else ignored */
)
/*
 * Times all 3 generator-provided vectorization schemes.
 * RETURNS: index of best-performing variant (0-2)
 *
 * OVERWRITES:
 *   ->mflop[0] : time for M-vec wt bcast
 *   ->mflop[1] : 0 if nu not a multiple of vlen, else time for M-vec wt splat
 *   ->mflop[2] : time for K-vec
 *
 * NOTE: mu & nu should be the number of vec regs to use (eg., for M-vec, 
 *       actual M unrolling will be mp->mu * mp->vlen).
 */
{
   char *gs0=mp->genstr, *rt0=mp->rout;
   int flg0=mp->flag, mb0=mp->mbB, nb0=mp->nbB, mu0=mp->mu;
   int kb0=mp->kbB, ku0=mp->ku, kbmax0=mp->kbmax, kbmin0=mp->kbmin;
   int iB=0;
   double mfB;

   if (!rt0)
      mp->rout = DupString("ATL_tmp.c");
   if (FLAG_IS_SET(mp->flag, MMF_KUISKB))
      mp->kbmax = mp->kbmin = mp->ku = mp->kbB = kb;
   mp->kbB = kb;  mp->nbB = nb;  mp->mbB = mb;  /* override blking factor */
/*
 * Try M-vectorized using broadcast
 */
   mp->flag &= ~(1<<MMF_KVEC);    /* ask for M-vectorized kernel */
   mp->flag &= ~(1<<MMF_NOBCAST); /* clear bcast bit */
   mp->mu = mu0 * mp->vlen; 
   mp->genstr = MMGetGenString(pre, mp);
   mfB = TimeMMKernel(verb, flag, mp, pre, mb, nb, kb, beta, mflop, cflush);
   mp->mflop[0] = mfB;
   free(mp->genstr);
/*
 * If legal, try M-vec with splat
 */
   if ((mp->nu % mp->vlen == 0) && !FLAG_IS_SET(mp->flag, MMF_FKO))
   {
      mp->flag |= (1<<MMF_NOBCAST);
      mp->genstr = MMGetGenString(pre, mp);
      mp->mflop[1] = TimeMMKernel(verb, flag, mp, pre, mb, nb, kb, beta, mflop, 
                                  cflush);
      free(mp->genstr);
      if (mp->mflop[1] > mfB)
      {
         iB = 1;
         mfB = mp->mflop[1];
      }
      mp->flag &= ~(1<<MMF_NOBCAST); /* clear bcast bit */
   }
   else
      mp->mflop[1] = 0;
/*
 * Try K-vectorized
 */
   mp->mu = mu0;
   mp->flag |= (1<<MMF_KVEC);    /* ask for K-vectorized kernel */
   mp->ku = ((mp->ku+mp->vlen-1)/mp->vlen)*mp->vlen;
   mp->genstr = MMGetGenString(pre, mp);
   mp->mflop[2] = TimeMMKernel(verb, flag, mp, pre, mb, nb, kb, beta, mflop, 
                               cflush);
   free(mp->genstr);
   if (mp->mflop[2] > mfB)
      iB = 2;
/*
 * Restore changed mp-> values & return
 */
   if (!rt0)
   {
      free(mp->rout);
      mp->rout = NULL;
   }
   mp->genstr = gs0;
   mp->mbB = mb0; mp->nbB = nb0; mp->kbB = kb0;
   mp->kbmin = kbmin0; mp->kbmax = kbmax0; mp->ku = ku0;
   return(iB);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
int kernWorksThisCaseK(ATL_mmnode_t *mp, int kb)
/*
 * RETURNS: KB if mp can be used according to standard rules, else 0.
 */
{
   const unsigned int mu=mp->mu, nu=mp->nu, ku=mp->ku, vlen=mp->vlen;
   unsigned int KB;

   if (mp->kbmin && kb < mp->kbmin)
      return(0);
   if (mp->kbmax && kb > mp->kbmax )
      return(0);
   KB = ((kb+ku-1)/ku)*ku;
   if (FLAG_IS_SET(mp->flag, MMF_KVEC))
   {
      if (KB-kb > mp->vlen)
         return(0);
   }
   else if (mp->ku > 4 && KB != kb)
      return(0);
   return(KB);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
ATL_mmnode_t *bestNearMNK(char pre, int verb, ATL_mmnode_t *tb, 
                          int mb, int nb, int kb, int tmflag, int beta, 
                          double runbon)
/*
 * Tries all mm in tb (try base), at sizes near mb,nb,kb.
 * OVERWRITES: mbB,nbB,kbB,mflop[0] for all kerns!
 * RETURNS: clone of best kernel's MMNODE
 */
{
   ATL_mmnode_t *mp, *mpB=NULL;
   int KRUNB=0;
   const double cmppen=1.0 / runbon;
   double mfB=0.0;

   for (mp=tb; mp; mp = mp->next)
   {
      double mf, mfmul;
      const unsigned int mu=mp->mu, nu=mp->nu, ku=mp->ku;
      int MB, NB, KB;
      char *nm;

      if (!kernWorksThisCaseK(mp, kb))  /* don't try illegal kerns */
         continue;
      if (FLAG_IS_SET(mp->flag, MMF_KRUNTIME)) /* get runtime bonus */
         mfmul = (KRUNB) ? 1.0 : runbon;
      else
         mfmul = (KRUNB) ? cmppen : 1.0;
      mp->mbB = MB = (mb > mu) ? (mb/mu)*mu : mu;
      mp->nbB = NB = (nb > nu) ? (nb/nu)*nu : nu;
      mp->kbB = KB = ((kb+ku-1)/ku)*ku;
      mf = TimeMMKernel(verb, tmflag, mp, pre, MB, NB, KB, beta, 0, -1);
      mp->mflop[0] = mf;
      printf("      ID=%d '%s': B=(%d,%d,%d) mf=%.2f\n", mp->ID, 
             GetMMLabelName(pre, mp), MB, NB, KB, mf);
      if (mf*mfmul > mfB)
      {
         KRUNB = FLAG_IS_SET(mp->flag, MMF_KRUNTIME);
         mfB = mf;
         mpB = mp;
      }
   }
   if (mpB)
   {
      const unsigned int mu=mpB->mu, nu=mpB->nu, ku=mpB->ku;
      mpB = CloneMMNode(mpB);
      mpB->kbB = kb;
      mpB->mbB = (mb > mu) ? ((mb/mu)*mu) : mu;
      mpB->nbB = (nb > nu) ? ((nb/nu)*nu) : nu;
      mpB->mflop[0] = mfB;
   }
   GetMMLabelName(pre, NULL);
   return(mpB);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
ATL_mmnode_t *ElimSlowKern(char pre, int verb, ATL_mmnode_t *tb, 
                           int mb, int nb, int kb, int tmflag, int beta, 
                           double tol)
/*
 * Times all kernels at size close to mb,nb,kb, the eliminates all kernels
 * not within tolerance of best
 */
{
   ATL_mmnode_t *mp;
   double mfB;

   mp = bestNearMNK(pre, verb, tb, mb, nb, kb, tmflag, beta, 1.0);
   mfB = mp->mflop[0];
   KillMMNode(mp);
   mp = tb;
   while (mp)
   {
      ATL_mmnode_t *nxt = mp->next;
      if (mp->mflop[0] < mfB*tol)
      {
         tb = RemoveMMNodeFromQ(tb, mp);
         KillMMNode(mp);
      }
      mp = nxt;
   }
   return(tb);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
ATL_mmnode_t *bestNearSquare(char pre, int verb, ATL_mmnode_t *tb, 
                             int kb, int tmflag, int beta, double runbon)
/*
 * Tries all mm in tb (try base), at near-square sizes around kb.
 * RETURNS: clone of best kernel's MMNODE
 */
{
   ATL_mmnode_t *mp, *mpB=NULL;
   const double cmppen=1.0 / runbon;
   double mfB=0.0;
   int MU=kb, NU=kb, KRUNB=0;
/*
 * Despite name, will use M/N B at least the size of largest unrolling, 
 * otherwise large unrollings get huge MFLOP advantage in head-to-head 
 * timings for small problems.
 */
   for (mp=tb; mp; mp = mp->next)
   {
      MU = Mmax(mp->mu, MU);
      NU = Mmax(mp->nu, NU);
   }
   for (mp=tb; mp; mp = mp->next)
   {
      double mf, mfmul;
      const unsigned int mu=mp->mu, nu=mp->nu, ku=mp->ku;
      int MB, NB, KB;
      char *nm;

      if (!kernWorksThisCaseK(mp, kb))  /* don't try illegal kerns */
         continue;
      if (FLAG_IS_SET(mp->flag, MMF_KRUNTIME)) /* get runtime bonus */
         mfmul = (KRUNB) ? 1.0 : runbon;
      else
         mfmul = (KRUNB) ? cmppen : 1.0;
      MB = ((MU+mu-1)/mu)*mu;
      NB = ((NU+nu-1)/nu)*nu;
      KB = ((kb+ku-1)/ku)*ku;
      mf = TimeMMKernel(verb, tmflag, mp, pre, MB, NB, kb, beta, 0, -1);
      printf("      ID=%d '%s': B=(%d,%d,%d) mf=%.2f\n", mp->ID, 
             GetMMLabelName(pre, mp), MB, NB, KB, mf);
      if (mf*mfmul > mfB)
      {
         KRUNB = FLAG_IS_SET(mp->flag, MMF_KRUNTIME);
         mfB = mf;
         mpB = mp;
      }
   }
   if (mpB)
   {
      const unsigned int mu=mpB->mu, nu=mpB->nu, ku=mpB->ku;
      mpB = CloneMMNode(mpB);
      mpB->kbB = kb;
      mpB->mbB = ((MU+mu-1)/mu)*mu;
      mpB->nbB = ((NU+nu-1)/nu)*nu;
      mpB->mflop[0] = mfB;
   }
   GetMMLabelName(pre, NULL);
   return(mpB);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
int MMVaryDim(int verb, char pre, int tflag, int MDIM, int MD, int beta, 
                ATL_mmnode_t *mp)
/*
 * Tries improving performance by increasing a M or N dimension up to MD.
 * UPDATES: mflop[0] with time ([0] not overwritten in case needed).
 * RETURNS: best blocking for dimension.
 */
{
   int mb = mp->mbB, nb=mp->nbB, kb=mp->kbB;
   int U=(MDIM)?mp->mu:mp->nu, dB, d;
   double mfB=0.0;
   if (U == 3)
      U = 6;
   else if (U < 4)
      U = 4;
   dB = U;
   for (d=U; d <= MD; d += U)
   {
      double mf;
      if (MDIM)
         mb = d;
      else
         nb = d;
      mf = TimeMMKernel(verb, tflag, mp, pre, mb, nb, kb, beta, 0, -1);
      printf("      ID=%d '%s': B=(%d,%d,%d) mf=%.2f\n", mp->ID, 
             GetMMLabelName(pre, mp), mb, nb, kb, mf);
      if (mf > mfB)
      {
         mfB = mf;
         dB = d;
      }
   }
   mp->mflop[1] = mfB;
   return(dB);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
#define NFUT  24   /* max # of futile expansion tries */
#define BLK1  60
#define B1PEN 1.0  /* no penalty for D <= BLK1 */
#define BLK2  120
#define B2PEN 0.998 /* 0.2% penalty for BLK1 < D <= BLK2 */
#define BLK3  240 
#define B3PEN 0.995 /* 0.5% penalty for BLK2 < D <= BLK3 */
#define BLK4  480 
#define B4PEN 0.990 /* 1.0% penalty for BLK3 < D <= BLK4 */
#define B5PEN 0.970 /* 3.0% penalty for D > BLK4 */
@beginproc setFast d_ kb_
   @mif d_ = "M
         maxD = Mmax(nbB, @(kb_));
   @endmif
   @mif d_ = "N
         maxD = Mmax(mbB, @(kb_));
   @endmif
   @mif d_ = "K
         maxD = Mmax(mbB, nbB);
   @endmif
         maxD = Mmax(maxD, @low@(d_)bN);
         if (maxD <= BLK1)
            pen@(d_) = B1PEN;
         else
         {
            if (maxD <= BLK2)
               pen@(d_) = B2PEN;
            else if (maxD <= BLK3)
               pen@(d_) = B3PEN;
            else if (maxD <= BLK4)
               pen@(d_) = B4PEN;
            else
               pen@(d_) = B5PEN;
            if (pen@(d_) == penB)
               pen@(d_) = 0.998; /* 0.2% penalty for any expansion */
            else
               pen@(d_) /= penB;
         }
@endproc

@whiledef nm MNK MN_K
double MMExpand@(nm)
   (int verb, char pre, int tflag, int beta, unsigned long sz,
    int (*wrkSetOK)(unsigned long, ATL_mmnode_t*,int,int,int), 
    const int maxB, ATL_mmnode_t *mp)
/*
 * Assume U=LCM(MU,NU), this search startes at MB=NB=U,KB=KU and then tries
 * increasing M,N,K and picks whichever provides the greatest speedup.  
 * Continues expanding MB,NB,KB in this way until perf drops by around 3%.
@mif nm = "MNK
 * If maxB is non-zero, then it sets inclusive limit on growth of MB,NB,KB.
@endmif
@mif nm = "MN_K
 * maxB must be > 0, and it sets inclusive limit on growth of MB,NB.
@endmif
 * Once we have stopped expanding each by U, consider all MU,NU,KU < U as well.
 * RETURNS: mflop for best MB,NB,KB which is given in mp->(mbB,nbB,kbB).
 */
{
   const unsigned int mu=mp->mu, nu=mp->nu;
   unsigned int MU, NU, KU, ku;
@mif nm = "MN_K
   unsigned int maxKB = Mmax(240,maxB+maxB);
@endmif
@mif nm = "MNK
   unsigned int maxKB = maxB;
@endmif
   int mbB, nbB, kbB, mb, nb, kb, maxDB, maxD;
   int FASTER=0, nfut;
   double mfB, penB=B1PEN;

   if (mp->ID && mp->kbmax && mp->kbmax < maxKB)
      maxKB = mp->kbmax;
   NU = ATL_iLCM(mu, nu);
   ku = mp->ku;      
   if (!FLAG_IS_SET(mp->flag, MMF_KUISKB) || !mp->ID) /* gen can adapt KB */
   {  /* genned KUISKB or non-KUISKB can always adapt KU as needed */
      KU = ATL_iLCM(NU, ku);
      if (KU > 16 || KU > maxKB) /* too big, make smaller if possible */
      {
         if (ku <= 8)
         {
            for (KU=ku; KU < 8; KU += ku);
         }
         else
            KU = NU;
         kbB = kb = KU;
      }
      else
         NU = kbB = kb = KU;
   }
   else if (mp->kbmin > 1)
   {                               /* reach here --> user KUISKB kern */
      if (mp->kbmax == mp->kbmin)
         kbB = kb = KU = mp->kbmax;
      else
      {
         unsigned const int inc=NU;
         KU = ATL_iLCM(NU, ku);
         if (KU > 16 || KU > maxKB) /* too big, make smaller if possible */
         {
            for (KU=ku; KU < Mmax(8, mp->kbmin); KU += ku);
            kbB = kb = KU; /* NOT IN LOOP! */
         }
         else
            NU = kbB = kb = KU;
      }
   }
   else
   {
      ku = 1;
      kbB = kb = KU = NU;
   }
   maxDB = mb = nb = mbB = nbB = MU = NU;

   mfB = TimeMMKernel(verb, tflag, mp, pre, mbB, nbB, kb, beta, 0, -1);
   printf("      ID=%d : B=(%u,%u,%u) maxB=%d mf=%.2f\n", mp->ID, 
          mbB, nbB, kbB, maxB, mfB);

   AGAIN:
      nfut = 0;
      do   /* loop to check that best of M/N expansion improved performance */
      {
         double mfM, mfN, mfK, mf;
         int mbN=mb+MU, nbN=nb+NU, kbN=kb+KU;
         int MOK, NOK, KOK;
         int ku0=mp->ku, kbmin0=mp->kbmin, kbmax0=mp->kbmax;
         double penM, penN, penK;

         @callproc setFast M kbB
         @callproc setFast N kbB
         @callproc setFast K kbB
         mfM = mfN = mfK = mf = 0.0;
         if (sz && wrkSetOK)
         {
            MOK = wrkSetOK(sz, mp, mbN, nb, kb);
            NOK = wrkSetOK(sz, mp, mb, nbN, kb);
            KOK = wrkSetOK(sz, mp, mb, nb, kbN);
            if (!(MOK|NOK|KOK))
               break;
         }
         else 
            MOK = NOK = KOK = 1;
         if (maxKB && kbN > maxKB)
         {
            if (mbN > maxB && nbN > maxB)
               break;
            mfK = 0.0;
         }
         else if (!NOK)
            mfK = 0.0;
         else
         {
            mfK = TimeMMKernel(verb, tflag, mp, pre, mb, nb, kbN, beta, 0, -1);
            printf("      ID=%d : B=(%d,%d,%d) mf=%.2f",mp->ID,mb,nb,kbN,mfK);
            if (!maxB || mbN <= maxB || nbN <= maxB)
               printf("\n");
         }
         if (maxB && nbN > maxB)
            mfN = 0.0;
         else
         {
            mfN = TimeMMKernel(verb, tflag, mp, pre, mb, nbN, kb, beta, 0, -1);
            printf("      ID=%d : B=(%d,%d,%d) mf=%.2f",mp->ID,mb,nbN,kb,mfN);
            if (!maxB || mbN <= maxB)
               printf("\n");
         }
         if (maxB && mbN > maxB)
            mfM = 0.0;
         else
         {
            mfM = TimeMMKernel(verb, tflag, mp, pre, mbN, nb, kb, beta, 0, -1);
            printf("      ID=%d : B=(%d,%d,%d) mf=%.2f",  mp->ID,mbN,nb,kb,mfM);
         }

         FASTER = 0;
         if (mfK*penK-mfB >= mfM*penM-mfB && 
             mfK*penK-mfB >= mfN*penN-mfB)
         {
            mf = mfK;
            kb = kbN;
            if (penK*mfK >= mfB)
            {
               printf(" --> INC KB TO %u!\n", kbN);
               kbB = kbN;
               mfB = mfK;
               penB = penK;
               maxDB = Mmax(maxDB, kbB);
               FASTER = 1;
               nfut = 0;
            }
         }
         else if (mfN*penN-mfB >= mfM*penM-mfB)
         {
            mf = mfN;
            nb = nbN;
            if (penN*mfN >= mfB)
            {
               printf(" --> INC NB TO %u!\n", nbN);
               nbB = nbN;
               mfB = mfN;
               penB = penN;
               maxDB = Mmax(maxDB, nbB);
               FASTER = 1;
               nfut = 0;
            }
         }
         else
         {
            mf = mfM;
            mb = mbN;
            if (penM*mfM >= mfB)
            {
               printf(" --> INC MB TO %u!\n", mbN);
               mbB = mbN;
               mfB = mfM;
               penB = penM;
               maxDB = Mmax(maxDB, mbB);
               FASTER = 1;
               nfut = 0;
            }
         }
         if (FLAG_IS_SET(mp->flag, MMF_KUISKB) && mp->kbmin != kbB)
         {
            if (!mp->ID && mp->ku != 1)
               mp->ku = kbB;
            mp->kbmin = mp->kbmax = kbB;
            if (mp->genstr)
            {
               free(mp->genstr);
               mp->genstr = MMGetGenString(pre, mp);
            }
         }
         if (!FASTER)
         {
            mf = Mmax(mfM, mfN);
            mf = Mmax(mf, mfK);
            FASTER = (nfut < NFUT);
            printf(" --> SLOWDOWN of %.4f\n", mf/mfB);
            nfut++;
         }
      }
      while (FASTER);
   if (MU != mu || NU != nu || KU != ku)
   {
      printf("\n   REFINEMENT SEARCH B=(%d,%d,%d), mf=%.2f\n", mbB, nbB, kbB, 
             mfB);
      mb = mbB;
      nb = nbB;
      kb = kbB;
      MU = mu;
      NU = nu;
      KU = ku;
      goto AGAIN;
   }

   mp->mbB = mbB;
   mp->nbB = nbB;
   mp->kbB = kbB;
   mp->mflop[0] = mfB;
   if (FLAG_IS_SET(mp->flag, MMF_KUISKB) && !mp->ID)
   {
      mp->ku = kbB;
      if (mp->genstr)
      {
         free(mp->genstr);
         mp->genstr = NULL;
      }
   }
   assert(!MMKernelFailsTest(pre, mbB, nbB, kbB, beta, mp));
   return(mfB);
}
@endwhile

@BEGINSKIP
double MMExpandMN_K(int verb, char pre, int tflag, int beta, unsigned long sz,
                    int (*wrkSetOK)(unsigned long, ATL_mmnode_t*,int,int,int),
                    const int maxB, ATL_mmnode_t *mp)
/*
 * Assume U=LCM(MU,NU,KU), this search startes at KB=MB=NB=U, and then tries
 * increasing M,N,K and picks whichever provides the greatest speedup.  
 * Continues expanding MB,NB,KB in this way until perf drops by around 3%.
 * maxB must be > 0, and it sets inclusive limit on growth of MB,NB.
 * maxKB will be set to MAX(2*maxB,240).
 * Once we have stopped expanding each by U, consider all MU,NU,KU < U as well.
 * RETURNS: mflop for best MB,NB,KB which is given in mp->(mbB,nbB,kbB).
 */
{
   const unsigned int mu=mp->mu, nu=mp->nu, ku=mp->ku;
   unsigned int MU, NU, KU, maxKB;
   int mbB, nbB, kbB, mb, nb, kb;
   int FASTER=0, nfut;
   double mfB;

   maxKB = maxB + maxB;
   maxKB = Mmax(240,maxKB);
   NU = ATL_iLCM(mu, nu);
   NU = ATL_iLCM(NU, ku);
   kb = mb = nb = kbB = mbB = nbB = MU = KU = NU;
   mfB = TimeMMKernel(verb, tflag, mp, pre, mbB, nbB, kb, beta, 0, -1);
   printf("      ID=%d : B=(%u,%u,%u) maxB=%d mf=%.2f\n", mp->ID, 
          mbB, nbB, kbB, maxB, mfB);

   AGAIN:
      nfut = 0;
      do   /* loop to check that best of M/N expansion improved performance */
      {
         double mfM, mfN, mfK, mf;
         int mbN=mb+MU, nbN=nb+NU, kbN=kb+KU;
         int MOK, NOK, KOK;
         double fstrK0, fstrN0, fstrM0, fstrK, fstrN, fstrM;

         @callproc setFast M
         @callproc setFast N
         @callproc setFast K
         if (sz && wrkSetOK)
         {
            MOK = wrkSetOK(sz, mp, mbN, nb, kb);
            NOK = wrkSetOK(sz, mp, mb, nbN, kb);
            KOK = wrkSetOK(sz, mp, mb, nb, kbN);
            if (!(MOK|NOK|KOK))
               break;
         }
         else 
            MOK = NOK = KOK = 1;

         if (kbN > maxKB)
         {
            if (mbN > maxB && nbN > maxB)
               break;
            mfK = 0.0;
         }
         else if (!NOK)
            mfK = 0.0;
         else
         {
            mfK = TimeMMKernel(verb, tflag, mp, pre, mb, nb, kbN, beta, 0, -1);
            printf("      ID=%d : B=(%d,%d,%d) mf=%.2f",mp->ID,mb,nb,kbN,mfK);
            if (!maxB || mbN <= maxB || nbN <= maxB)
               printf("\n");
         }
         if (maxB && nbN > maxB)
            mfN = 0.0;
         else
         {
            mfN = TimeMMKernel(verb, tflag, mp, pre, mb, nbN, kb, beta, 0, -1);
            printf("      ID=%d : B=(%d,%d,%d) mf=%.2f",mp->ID,mb,nbN,kb,mfN);
            if (!maxB || mbN <= maxB)
               printf("\n");
         }
         if (maxB && mbN > maxB)
            mfM = 0.0;
         else
         {
            mfM = TimeMMKernel(verb, tflag, mp, pre, mbN, nb, kb, beta, 0, -1);
            printf("      ID=%d : B=(%d,%d,%d) mf=%.2f",  mp->ID,mbN,nb,kb,mfM);
         }

         FASTER = 0;
         if (mfK*fstrK0-mfB*fstrK >= mfM*fstrM0-mfB*fstrM && 
             mfK*fstrK0-mfB*fstrK >= mfN*fstrN0-mfB*fstrN)
         {
            mf = mfK;
            kb = kbN;
            if (fstrK0*mfK >= fstrK*mfB)
            {
               printf(" --> INC KB TO %u!\n", kbN);
               kbB = kbN;
               mfB = mfK;
               FASTER = 1;
               nfut = 0;
            }
         }
         else if (mfN*fstrN0-mfB*fstrN >= mfM*fstrM0-mfB*fstrM)
         {
            mf = mfN;
            nb = nbN;
            if (mfN*fstrN0 >= fstrN*mfB)
            {
               printf(" --> INC NB TO %u!\n", nbN);
               nbB = nbN;
               mfB = mfN;
               FASTER = 1;
               nfut = 0;
            }
         }
         else
         {
            mf = mfM;
            mb = mbN;
            if (fstrM0*mfM >= fstrM*mfB)
            {
               printf(" --> INC MB TO %u!\n", mbN);
               mbB = mbN;
               mfB = mfM;
               FASTER = 1;
               nfut = 0;
            }
         }
         if (!FASTER)
         {
            FASTER = (nfut < NFUT);
            printf(" --> SLOWDOWN of %.4f\n", mf/mfB);
            nfut++;
         }
      }
      while (FASTER);
   if (MU != mu || NU != nu || KU != ku)
   {
      printf("\n   REFINEMENT SEARCH B=(%d,%d,%d), mf=%.2f\n", mbB, nbB, kbB, 
             mfB);
      mb = mbB;
      nb = nbB;
      kb = kbB;
      MU = mu;
      NU = nu;
      KU = ku;
      goto AGAIN;
   }

   mp->mbB = mbB;
   mp->nbB = nbB;
   mp->kbB = kbB;
   mp->mflop[0] = mfB;
   return(mfB);
}
@ENDSKIP

@iexp ip @(ip) 1 +
/* procedure @(ip) */
void MMExpandMorN(int verb, char pre, int tflag, int beta, ATL_mmnode_t *mp, 
                  int EXN, unsigned int maxD)
{
   const unsigned int mu=EXN?0:mp->mu, nu=EXN?mp->nu:0, kb=mp->kbB;
   unsigned int mb=mp->mbB, nb=mp->nbB, nbB, U, i;
   double mfB;

   U = (EXN) ? mp->nu : mp->mu;
   U = (U==1 || U == 2) ? 4 : U;
   mb = (EXN) ? mb : U;
   nb = (EXN) ? U : nb;
   nbB = (EXN) ? nb : mb;
   mfB = TimeMMKernel(verb, tflag, mp, pre, mb, nb, kb, beta, 0, -1);
   printf("      ID=%d : B=(%d,%d,%d) mf=%.2f\n", mp->ID,mb, nb, kb, mfB);
   for (i=U+U; i <= maxD; i += U)
   {
      double mf;
      if (EXN)
         nb = i;
      else
         mb = i;
      mf = TimeMMKernel(verb, tflag, mp, pre, mb, nb, kb, beta, 0, -1);
      printf("      ID=%d : B=(%d,%d,%d) mf=%.2f", mp->ID,mb, nb, kb, mf);
      if (mf > mfB)
      {
         printf(" --> %.5f faster\n", mf/mfB);
         mfB = mf;
         if (EXN)
	    nbB = nb;
         else
	    nbB = mb;
      }
      else
         printf(" --> %.5f slower\n", mf/mfB);
   }
   mp->mflop[0] = mfB;
   if (EXN)
      mp->nbB = nbB;
   else
      mp->mbB = nbB;
}
/*
@iexp ip @(ip) 1 +
/* procedure @(ip) */
int MMExpandK(int verb, char pre, int tflag, int beta, ATL_mmnode_t *mp, 
              unsigned int maxK)
/*
 * Times expanding K until perf drops off by around 2%.  If maxK != 0, also
 * stops expanding once K is reached.
 */
{
   double mfB, mf;
   const unsigned int ku = mp->ku, mb=mp->mbB, nb=mp->nbB;
   unsigned int kbB, k, U;
   if (!maxK)
      maxK = 1024;
/*
 * In initial search, recursive doubling
 */
   printf("   %d %s: FINDING KB FOR B=(%d,%d):\n", mp->ID, 
          GetMMLabelName(pre, mp), mb, nb);
   mfB = TimeMMKernel(verb, tflag, mp, pre, mb, nb, ku, beta, 0, -1);
   printf("      KB=%u, mf=%.2f\n", ku, mfB);
   k = kbB = ku;
   do
   {
      k += k;
      mf = TimeMMKernel(verb, tflag, mp, pre, mb, nb, k, beta, 0, -1);
      printf("      KB=%u, mf=%.2f\n", k, mf);
      if (mf > mfB)
      {
         mfB = mf;
         kbB = k;
      }
   }
   while (k <= maxK && mf*1.02 > mfB);
   if (ku < 4)
   {
      U = ATL_iLCM(mp->nu, ku);
      if (U > 8)
         U = ATL_iLCM(mp->mu, ku);
      if (U > 8)
         U = ku+ku;
   }
   else
      U = ku;
   maxK++;
   k = kbB+kbB;
   maxK = Mmin(maxK, k);
   printf("\n   INITIAL KB=%u, refine [%u,%u) steps of %u:\n", kbB, kbB>>1,
          maxK, U);
   for (k=(kbB>>1)+U; k < maxK; k += U)
   {
      mf = TimeMMKernel(verb, tflag, mp, pre, mb, nb, k, beta, 0, -1);
      printf("      KB=%u, mf=%.2f\n", k, mf);
      if (mf > mfB)
      {
         mfB = mf;
         kbB = k;
      }
   }
   mp->mflop[0] = mfB;
   mp->kbB = kbB;
   printf("   %d %s, B=(%d,%d,%d), mf=%.2f\n", mp->ID, GetMMLabelName(pre, mp),
          mb, nb, kbB, mfB);
   GetMMLabelName(pre, NULL);
   return(kbB);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
double MMExpandMN(int verb, char pre, int tflag, int beta, int maxB, 
                  ATL_mmnode_t *mp)
/*
 * Assume U=LCM(MU,NU), this search startes at MB=NB=U, and then tries
 * increasing M and N, and picks whichever provides the greatest speedup.  
 * Continues expanding MB,NB in this way until performance drops by around 3%.
 * Once we have stopped expanding each by U, consider all MU,NU < U as well.
 * KB is not tuned: all timings use KB=mp->kbB.
 * RETURNS: mflop for best MB,NB, which is given in mp->mbB, mp->nbB.
 */
{
   const unsigned int mu=mp->mu, nu=mp->nu, MB0=mp->mbB, NB0=mp->nbB;
   unsigned int MU, NU;
   int kb=mp->kbB, mbB, nbB, mb, nb, maxD, maxDB;
   int FASTER=0, nfut;
   double mfB, penB=B1PEN;

   maxDB = mb = nb = mbB = nbB = MU = NU = ATL_iLCM(mu, nu);
   mfB = TimeMMKernel(verb, tflag, mp, pre, mbB, nbB, kb, beta, 0, -1);
   printf("      ID=%d : B=(%d,%d,%d) mf=%.2f\n", mp->ID, mbB, nbB, kb, mfB);

   AGAIN:
      nfut = 0;
      do   /* loop to check that best of M/N expansion improved performance */
      {
         double mfM, mfN, mf=0.0, penM, penN;
         int mbN=mb+MU, nbN=nb+NU;

         @callproc setFast M kb
         @callproc setFast N kb

         if (maxB && nbN > maxB && mbN > maxB)
            break;
         if (maxB && nbN > maxB)
            mfN = 0.0;
         else
         {
            mfN = TimeMMKernel(verb, tflag, mp, pre, mb, nbN, kb, beta, 0, -1);
            printf("      ID=%d : B=(%d,%d,%d) mf=%.2f", mp->ID,mb, nbN,
                   kb, mfN);
            if (!maxB || mbN <= maxB)
               printf("\n");
         }
         if (maxB && mbN > maxB)
            mfM = 0.0;
         else
         {
            mfM = TimeMMKernel(verb, tflag, mp, pre, mbN, nb, kb, beta, 0, -1);
            printf("      ID=%d ': B=(%d,%d,%d) mf=%.2f",  mp->ID,mbN,nb, 
                   kb, mfM);
         }

         FASTER = 0;
         if (mfN*penN-mfB >= mfM*penN-mfB)
         {
            mf = mfN;
            nb = nbN;
            if (mfN*penN > mfB)
            {
               printf(" --> INC NB TO %u!\n", nbN);
               nbB = nbN;
               mfB = mfN;
               penB = penN;
               maxDB = Mmax(maxDB, nbB);
               FASTER = 1;
               nfut = 0;
            }
         }
         else
         {
            mf = mfM;
            mb = mbN;
            if (mfM*penM >= mfB)
            {
               printf(" --> INC MB TO %u!\n", mbN);
               mbB = mbN;
               mfB = mfM;
               penB = penM;
               maxDB = Mmax(maxDB, mbB);
               FASTER = 1;
               nfut = 0;
            }
         }
         if (!FASTER)
         {
            nfut++;
            FASTER = (nfut < 5);
            printf(" --> SLOWDOWN of %.4f\n", mf/mfB);
         }
      }
      while (FASTER);
   if (MU != mu || NU != nu)
   {
      printf("\n");
      mb = mbB;
      nb = nbB;
      MU = mu;
      NU = nu;
      goto AGAIN;
   }
/*
 * Now retime original MB/NB if they make sense
 */
   if ((MB0/mu)*mu == MB0 && (NB0/nu)*nu == NB0)
   {
      double mf;
      mf = TimeMMKernel(verb, tflag|1, mp, pre, MB0, NB0, kb, beta, 0, -1);
      printf("      ID=%d : B=(%d,%d,%d) mf=%.2f\n", mp->ID,MB0,NB0,kb,mf);
      if (mf > mfB)
      {
         mfB = mf;
         mbB = MB0;
         nbB = NB0;
      }
   }
   mp->mbB = mbB;
   mp->nbB = nbB;
   mp->mflop[0] = mfB;
   return(mfB);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
double MMExpandNK(int verb, char pre, int tflag, int beta, ATL_mmnode_t *mp)
/*
 * Expand either N=K or M=K, with other dims unrestrained until max perf
 * is reached.  If most sig bit in tflag is set, expand N=K, else M=K.
 * RETURNS: mflop for best MB,NB, which is given in mp->mbB, mp->nbB.
 */
{
   const unsigned int mu=mp->mu, nu=mp->nu, ku=mp->ku; 
   unsigned int MB0=mp->mbB, NB0=mp->nbB, KB0=mp->kbB;
   unsigned int MU, NU;
   const int NK=(tflag>>31)&1;
   int kb=mp->kbB, mbB, nbB, kbB, mb, nb, maxD, maxDB;
   int FASTER=0, nfut=0;
   double mfB, penB=B1PEN;

   if (NK)
   {
      NU = nb = kb = ATL_iLCM(nu, ku);
      MU = mb = mu;
      if (NB0 != KB0)
         MB0 = NB0 = KB0 = 0;
   }
   else
   {
      MU = mb = kb = ATL_iLCM(mu, ku);
      NU = nb = nu;
      if (MB0 != KB0)
         MB0 = NB0 = KB0 = 0;
   }
   mbB = mb;
   nbB = nb;
   kbB = kb;
   maxDB = Mmax(mbB, nbB);
   maxDB = Mmax(maxD, kbB);
   
   mfB = TimeMMKernel(verb, tflag, mp, pre, mb, nb, kb, beta, 0, -1);
   printf("      ID=%d : B=(%d,%d,%d) mf=%.2f\n", mp->ID, mbB, nbB, kb, mfB);

   AGAIN:
      do   /* loop to check that best of M/N expansion improved performance */
      {
         double mfM, mfN, mf=0.0, penM, penN;
         int mbN=mb+MU, nbN=nb+NU;
         const unsigned int kbm = (NK) ? nb : mbN, kbn = (NK) ? nbN : mb;

         @callproc setFast M kbm
         @callproc setFast N kbn
         mfN = TimeMMKernel(verb, tflag, mp, pre, mb, nbN, kbn, beta, 0, -1);
         printf("      ID=%d : B=(%d,%d,%d) mf=%.2f\n", mp->ID,mb, nbN,kbn,mfN);
         mfM = TimeMMKernel(verb, tflag, mp, pre, mbN, nb, kbm, beta, 0, -1);
         printf("      ID=%d ': B=(%d,%d,%d) mf=%.2f",  mp->ID,mbN,nb, kbm,mfM);

         FASTER = 0;
         if (mfN*penM-mfB >= mfM*penM-mfB)
         {
            mf = mfN;
            nb = nbN;
            if (mfN*penN >= mfB)
            {
               printf(" --> INC NB TO %u!\n", nbN);
               mbB = mb;
               nbB = nbN;
               mfB = mfN;
               kbB = kbn;
               penB = penN;
               maxDB = Mmax(maxDB, nbB);
               FASTER = 1;
               nfut = 0;
            }
         }
         else
         {
            mf = mfM;
            mb = mbN;
            if (mfM*penM >= mfB)
            {
               printf(" --> INC MB TO %u!\n", mbN);
               mbB = mbN;
               nbB = nb;
               mfB = mfM;
               kbB = kbm;
               penB = penM;
               maxDB = Mmax(maxDB, mbB);
               FASTER = 1;
               nfut = 0;
            }
         }
         if (!FASTER)
         {
            nfut++;
            FASTER = (mf*1.03 > mfB) && (nfut < NFUT);
            printf(" --> SLOWDOWN of %.4f\n", mf/mfB);
         }
      }
      while (FASTER);
/*
 * Now retime original MB/NB/KB if they make sense
 */
   if (MB0 && NB0 && KB0 && (MB0/mu)*mu == MB0 && (NB0/nu)*nu == NB0 && 
       (KB0/ku)*ku == KB0)
   {
      double mf;
      mf = TimeMMKernel(verb, tflag|1, mp, pre, MB0, NB0, KB0, beta, 0, -1);
      printf("      ID=%d : B=(%d,%d,%d) mf=%.2f\n", mp->ID,MB0,NB0,KB0,mf);
      if (mf > mfB)
      {
         mfB = mf;
         mbB = MB0;
         nbB = NB0;
         kbB = KB0;
      }
   }
   mp->mbB = mbB;
   mp->nbB = nbB;
   mp->kbB = kbB;
   mp->mflop[0] = mfB;
   return(mfB);
}

#undef NFUT
#undef BLK1
#undef BLK2
#undef BLK3
#undef FSTR0
#undef FSTR1
#undef FSTR2
#undef FSTR3
#undef FSTR4
@iexp ip @(ip) 1 +
/* procedure @(ip) */
int MMKernCanHandleCase(ATL_mmnode_t *mp, int mb, int nb, int kb)
/* 
 * RETURNS: 0 if mp cannot handle GEMM of size mbxnbxkb
 *          1 if it can handle w/o extra computation
 *          2 if handling it requires extra comptutation (KVEC only: on kb)
 */
{
   if (mb%mp->mu == 0 && nb%mp->nu == 0)
   {
      const int KRUN=FLAG_IS_SET(mp->flag, MMF_KRUNTIME), ku=mp->ku;
      if (mp->kbB == kb)
         return(1);
      if (KRUN && kb%ku == 0)
         return(1);
      if (FLAG_IS_SET(mp->flag, MMF_KVEC))
      {
         const int vl = mp->vlen, kbB=mp->kbB;
         if (KRUN && kb%ku < vl)
            return(2);
         if (kbB > kb && (kbB-kb < vl))
            return(2);
         if (kbB < kb && (kb-kbB < vl))
            return(2);
      }
   }
   return(0);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
ATL_mmnode_t *MMTimeKernWithAlt
(
   int verb,                    /* 0: no output, 1 min output, 2: full output */
   int imf,                     /* which mflop entry to store res in */
   int flag,                    /* 1: ignore any prior output file */
   ATL_mmnode_t *mp0,           /* ptr to mmkern struct */
   ATL_mmnode_t *mp1,           /* ptr to mmkern struct */
   char pre,                    /* type/prec prefix: z,c,d,s */
   int mb, int nb, int kb,      /* dimensions to time */
   int beta,                    /* beta to time */
   int mflop,                   /* >0: force mflop MFLOPs in each time interv */
   int cflush                   /* >=0: size of cache flush, else ignored */
)
{
   int i;
   double mf0=0.0, mf1=0.0;
   i = MMKernCanHandleCase(mp0, mb, nb, kb);
   if (i)
   {
      mf0 = TimeMMKernel(verb, flag, mp0, pre, mb, nb, kb, beta, mflop, cflush);
      if (i == 2)
      {
         int k = mp0->vlen;
         k = ((kb+k-1)/k)*k;
         mf0 *= kb;
         mf0 /= k;
      }
      mp0->mflop[imf] = mf0;
   }
/*
 * If we couldn't use first kernel, or if first kernel needed extra flops
 */
   if (!i || i == 2)
   {
      int j;
      j = MMKernCanHandleCase(mp1, mb, nb, kb);
      if (j)
      {
         mf1 = TimeMMKernel(verb, flag, mp1, pre, mb, nb, kb,beta,mflop,cflush);
         if (j == 2)
         {
            int k = mp1->vlen;
            k = ((kb+k-1)/k)*k;
            mf1 *= kb;
            mf1 /= k;
         }
         mp1->mflop[imf] = mf1;
      }
      else if (!i)
         return(NULL);
   }
   if (mf1 > mf0)
      return(mp1);
   return(mp0);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
ATL_mmnode_t *MMTimeAllKernsWithAlt
(
   int verb,                    /* 0: no output, 1 min output, 2: full output */
   int imf,
   int flag,                   /* 1: ignore any prior output file */
   ATL_mmnode_t *mmb,           /* ptr to mmkern struct */
   ATL_mmnode_t *mmA,           /* ptr to mmkern struct */
   char pre,                    /* type/prec prefix: z,c,d,s */
   int mb, int nb, int kb,      /* dimensions to time */
   int beta,                    /* beta to time */
   int mflop,                   /* >0: force mflop MFLOPs in each time interv */
   int cflush                   /* >=0: size of cache flush, else ignored */
)
/*
 * For given problem size, times all kernels in mmb.  If any entry in mmb
 * cannot handle this exact problem (eg., unrolling mismatch), or requires
 * extra flops to handle the problem, the corresponding
 * entry in the alternate list mmA will be tried.
 * RETURNS: ptr to fastest timed kernel, or NULL if none worked.
 * NOTE: neither list is changed by this function (mflop is overwritten!), 
 *       but ptr into original listis returned.
 */
{
   ATL_mmnode_t *mpB=NULL, *mp0, *mp1;
   double mfB=0.0;
   for (mp0=mmb, mp1=mmA; mp0; mp0 = mp0->next, mp1 = mp1->next)
   {
      ATL_mmnode_t *mp;
      mp = MMTimeKernWithAlt(verb, imf, flag, mp0, mp1, pre, mb, nb, kb, 
                             beta, mflop, cflush);
      if (mp)
      {
         double mf;
         mf = mp->mflop[imf];
         if (mf > mfB)
         {
            mfB = mf;
            mpB = mp;
         }
      }
   }
   return(mpB);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
int TimeNegMMKernels            /* RET: 0 if no retiming required */
(
   int imf,                     /* index of mflop array to check/set */
   int verb,                    /* 0: no output, 1 min output, 2: full output */
   int flag,                    /* 1: ignore any prior output file */
   ATL_mmnode_t *mmb,           /* ptr to mmkern struct queue */
   char pre,                    /* type/prec prefix: z,c,d,s */
   int beta,                    /* beta to time */
   int mflop,                   /* >0: force mflop MFLOPs in each time interv */
   int cflush                   /* >0: size of cache flush, else ignored */
)
{
   ATL_mmnode_t *mp;
   int RETIME=0;
   for (mp=mmb; mp; mp = mp->next)
   {
      if (mp->mflop[imf] <= 0.0)
      {
         RETIME++;
         mp->mflop[imf] = TimeMMKernel(verb, flag, mp, pre, 
                                       mp->mbB, mp->nbB, mp->kbB,
                                       beta, mflop, cflush);
      }
   }
   return(RETIME);
}

@beginskip
@iexp ip @(ip) 1 +
/* procedure @(ip) */
static char *GetVecStrMM(char pre, int vlen)
{
   if (vlen == 1)
      return("scalar");
   #ifdef ATL_AVX
      if (pre == 'd' || pre == 'z')
      {
         if (vlen == 4)
            return("avx");
         else if (vlen == 2)
            return("sse");
      }
      else if (pre == 's' || pre == 'c')
      {
         if (vlen == 8)
            return("avx");
         else if (vlen == 4)
            return("sse");
      }
   #elif defined(ATL_SSE1)
      #ifdef ATL_SSE2
         if ((pre == 'd' || pre == 'z') && vlen == 2)
               return("sse");
      #endif
      if ((pre == 's' || pre == 'c') && vlen == 4)
         return("sse");
   #endif
/*
 * Any vector length > 1 that isn't one of our known cases uses gnuvec
 */
   return("gvec");
}
@endskip

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static ATL_mmnode_t *TimeMMFile
(
   char pre, 
   char *file, 
   int imf,                    /* index of mflop array to check/set */
   int verb,                   /* 0: no output, 1 min output, 2: full output */
   int flag,                   /* flag for TimeMMKernel */
   int beta,                   /* beta to time */
   int mflop,                  /* >0: force mflop MFLOPs in each time interv */
   int cflush                  /* >0: size of cache flush, else ignored */
)
{
   ATL_mmnode_t *mmb;
   mmb = ReadMMFile(file);
   if (!mmb)
      return(NULL);
   MMFillInGenStrings(pre, mmb);
   if (TimeNegMMKernels(imf, verb, flag, mmb, pre, beta, mflop, cflush))
      WriteMMFile(file, mmb);
   return(mmb);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static ATL_mmnode_t *TimeMMFileWithPath
(
   char pre, 
   char *path, 
   char *file, 
   int imf,                    /* index of mflop array to check/set */
   int verb,                   /* 0: no output, 1 min output, 2: full output */
   int flag,                  
   int beta,                   /* beta to time */
   int mflop,                  /* >0: force mflop MFLOPs in each time interv */
   int cflush                  /* >0: size of cache flush, else ignored */
)
{
   ATL_mmnode_t *mb;
   int CHNG=0;

   mb = ReadMMFileWithPath(pre, path, file);
   if (!mb)
      return(NULL);
   MMFillInGenStrings(pre, mb);
   if (TimeNegMMKernels(imf, verb, flag, mb, pre, beta, mflop, cflush))
      WriteMMFileWithPath(pre, path, file, mb);
   return(mb);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
void TimeAllMMKernels
(
   int itime,                   /* index of mflop array to set */
   int verb,                    /* 0: no output, 1 min output, 2: full output */
   int FORCETIME,               /* 1: ignore any prior output file */
   ATL_mmnode_t *mmb,           /* ptr to mmkern struct queue */
   char pre,                    /* type/prec prefix: z,c,d,s */
   int beta,                    /* beta to time */
   int mflop,                   /* >0: force mflop MFLOPs in each time interv */
   int cflush                   /* >0: size of cache flush, else ignored */
)
{
   ATL_mmnode_t *mmp;
   for (mmp=mmb; mmp; mmp = mmp->next)
      mmp->mflop[itime] = TimeMMKernel(verb, FORCETIME?1:0, mmp, pre, 
                                       mmp->mbB, mmp->nbB, mmp->kbB,
                                       beta, mflop, cflush);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
double TimeTSKernel
(
   int verb,                    /* 0: no output, 1 min output, 2: full output */
   int FORCETIME,               /* 1: ignore any prior output file */
   char pre,                    /* type/prec prefix: z,c,d,s */
   int mb,                      /* triangle is mbxmb (kb=mb) */
   int nb,                      /* NRHS */
   int mflop                    /* >0: force mflop MFLOPs in each time interv */
)
{
   int i, DOTIME=1;
   char ln[2048], resf[256];

   if (FORCETIME)
      strcpy(resf, "res/tmpout.ktim");
   else
   {
      sprintf(resf, "res/%ctrsm%dx%d_F%d.ktim", pre, mb, nb, mflop);
      DOTIME = !FileExists(resf);
   }

   if (DOTIME)
   {
      i = sprintf(ln, "make %ctrsmKtime mb=%d nb=%d outF=\" -f %s \"", 
                  pre, mb, nb, resf);
      if (mflop)
         i += sprintf(ln+i, " FMF=%d", mflop);

      sprintf(ln+i, "\n");
      if (verb > 1)
         printf("SYSTEM: %s", ln);
      if (system(ln))
      {
         fprintf(stderr, "ERROR IN COMMAND: %s", ln);
         fprintf(stderr, "   PROPOSED FILENAME: %s\n", resf);
         sprintf(ln, "rm -f %s\n", resf);
         assert(!system(ln));
         exit(-1);
      }
   }
   return(*((double*)ReadResultsFile(0, 0, resf)));
}

#endif  /* end guard around atlas_@(rt)testtime.h */
@ROUT atlas_mmgen.h
   @iexp ip 0
#ifndef ATLAS_MMGEN_H
   #define ATLAS_MMGEN_H
/*
 * This file contains helper functions for code generation
 */
#define ATL_GENERATE 1
#include "atlas_cpparse.h"
#include "atlas_mmparse.h"
#include "atlas_mmtesttime.h"

#define CPV_C2BLK  0
#define CPV_BLK2C  1
#define CPV_A2BLK  2
#define CPV_BLK2A  3
#define CPV_BE1C   4
#define CPV_BENC   5
#define CPV_BEXC   6
#define CPV_BE0C   7
#define CPV_AL1C   8
#define CPV_ALNC   9
#define CPV_ALXC  10
#define CPV_AL1A  11
#define CPV_ALNA  12
#define CPV_ALXA  13
#define CPV_NOACP 14
#define CPV_NOCCP 15
#define CPV_NOMMI 16
#define CPV_NOUNR 17
#define CPV_SELFK 18  /* only called with kbB, self-clean if not mul ku */

#define CPV_ALLDIRA ( (1<<CPV_BLK2A)|(1<<CPV_A2BLK) )
#define CPV_ALLDIRC ( (1<<CPV_BLK2C)|(1<<CPV_C2BLK) )
#define CPV_ALLALA ( (1<<CPV_AL1A)|(1<<CPV_ALNA)|(1<<CPV_ALXA) )
#define CPV_ALLALC ( (1<<CPV_AL1C)|(1<<CPV_ALNC)|(1<<CPV_ALXC) )
#define CPV_ALLBEC ( (1<<CPV_BE1C)|(1<<CPV_BENC)|(1<<CPV_BEXC)|(1<<CPV_BE0C) )
#define CPV_ALLSUP ((1<<CPV_NOACP)|(1<<CPV_NOCCP)|(1<<CPV_NOMMI)|(1<<CPV_NOUNR))

typedef struct ViewNode ATL_view_t;
struct ViewNode
{
   char *fnam;
   char *nam;
   int flag;
   ATL_view_t *next;
};

static ATL_view_t *ATL_NewView(int flag, char *nam, char *fnam)
{
   ATL_view_t *p;
   p = malloc(sizeof(ATL_view_t));
   assert(p);
   p->flag = flag;
   p->nam  = nam;
   p->fnam = fnam;
   p->next = NULL;
   return(p);
}

static ATL_view_t *KillView(ATL_view_t *p)
{
   ATL_view_t *next=NULL;
   if (p)
   {
      next = p->next;
      if (p->fnam)
         free(p->fnam);
      if (p->nam)
         free(p->nam);
      free(p);
   }
   return(next);
}

static void KillAllViews(ATL_view_t *p)
{
   while (p)
      p = KillView(p);
}

static char *View2Args(ATL_view_t *p)
{
   const unsigned int flag=p->flag;
   unsigned int i, k;
   char *Ca, *Aa, *Ad, *Cd, *sp, *SUP;
   char scl[4]={'1', 'N', 'X', '0'};
   char Cb[12]={'C', 'b', '=', '\0'};
   char ks[4]={'K','=','1', '\0'};
   
   ks[2] = (flag&(1<<CPV_SELFK)) ? '0' : '1';
   i = (flag>>CPV_C2BLK)&3;
   if (i == 3)
      Cd ="Cd=I,F";
   else if (i == 0)
      Cd = "";
   else 
      Cd = (i == 1) ? "Cd=F" : "Cd=I";

   i = (flag>>CPV_A2BLK)&3;
   if (i == 3)
      Ad ="Ad=I,F";
   else if (i == 0)
      Ad = "";
   else 
      Ad = (i == 1) ? "Ad=F" : "Ad=I";

   if (Cd[0] != '\0')
   {
      i = (flag>>CPV_BE1C)&0xF;
      if (i == 0xF || !i)
         strcat(Cb, "0,1,N,X");
      else if (i)
      {
         for (k=0; (i&1) == 0 && k <= 4; k++, i>>=1);
         Cb[3] = scl[k];
         sp = Cb+4;
         for (i>>=1; i; k++, i>>=1)
         {
            if (i&1)
            {
               *sp = ',';
               sp[1] = scl[k];
               sp += 2;
            }
         }
         *sp = '\0';
      }
   }
   else
      Cb[0] = '\0';
   @whiledef mt C A 
   if (@(mt)d[0] != '\0')
   {
      i = (flag>>CPV_AL1@(mt))&7;
      switch(i)
      {
      case 0:
         @(mt)a = "";
         break;
      @multidef st  N,X 1,X  X  1,N  N   1
      @whiledef ct   6   5   4   3   2   1 
      case @(ct):
         @(mt)a = "@(mt)a=@(st)";
         break;
         @undef st
      @endwhile
      default:
         @(mt)a = "@(mt)a=1,N,X";
      }
   }
   else
      @(mt)a = "";
   @endwhile
   i = (flag&CPV_ALLSUP)>>CPV_NOACP;
   switch(i)
   {
   case 0x0: /* 0b0000 */
      SUP = "";
      break;
   case 0x1: /* 0b0001 */
      SUP = " S=A";
      break;
   case 0x2: /* 0b0010 */
      SUP = " S=C";
      break;
   case 0x3: /* 0b0011 */
      SUP = " S=C,A";
      break;
   case 0x4: /* 0b0100 */
      SUP = " S=M";
      break;
   case 0x5: /* 0b0101 */
      SUP = " S=M,A";
      break;
   case 0x6: /* 0b0110 */
      SUP = " S=M,C";
      break; 
   case 0x7: /* 0b0111 */
      SUP = " S=M,C,A";
      break;
   case 0x8: /* 0b1000 */
      SUP = " S=U";
      break;
   case 0x9: /* 0b1001 */
      SUP = " S=U,A";
      break;
   case 0xA: /* 0b1010 */
      SUP = " S=U,C";
      break;
   case 0xB: /* 0b1011 */
      SUP = " S=U,C,A";
      break;
   case 0xC: /* 0b1100 */
      SUP = " S=U,M";
      break;
   case 0xD: /* 0b1101 */
      SUP = " S=U,M,A";
      break;
   case 0xE: /* 0b1110 */
      SUP = " S=U,M,C";
      break;
   case 0xF: /* 0b1111 */
      SUP = " S=U,C,M,U";
      break;
   default:
      assert(i == 0);
   }

   i = strlen(p->nam) + strlen(p->fnam) + strlen(Cb) + 26 + 2*5 + 2*4
     + strlen(SUP) + strlen(ks);
   sp = malloc(i);
   assert(sp);
   k = sprintf(sp, "-V %s %s %s %s %s %s %s %s %s", Ca, Aa, Cb, Ad, Cd,
               ks, SUP, p->nam, p->fnam);
   assert(k < i);
   return(sp);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
int CPV_ScalStr2bits(char *st, int ibit)
{
   int flag=0;
   GET_SCAL:
   {
      switch(*st)
      {
      case '1':
         flag |= (1L<<ibit);
         break;
      case 'N':
         flag |= (1L<<(ibit+1));
         break;
      case 'X':
         flag |= (1L<<(ibit+2));
         break;
      case '0':
         flag |= (1L<<(ibit+3));
         break;
      default:
         assert(0);
      }
   }
   if (*(++st) == ',')
   {
      st++;
      goto GET_SCAL;
   }
   return(flag);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
int CPV_DirStr2bits(char *st, int ibit)
{
   int flag;
   char ch = *st++;
   flag = (ch == 'F' || ch == 'f') ? (1<<ibit) : (1<<(ibit+1));
   if (*st++ == ',')
   {
      char ch = *st;
      flag |= (ch == 'F' || ch == 'f') ? (1<<ibit) : (1<<(ibit+1));
   }
   return(flag);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
void PrintBegIfdef(FILE *fpout, char *nm)
{
   int i, k;
   assert(nm && fpout);
   for (k=0; k < 2; k++)
   {
      if (!k)
         fprintf(fpout, "#ifndef ");
      else
         fprintf(fpout, "   #define ");
      for (i=0; nm[i]; i++)
      {
         char ch = nm[i];
         ch = toupper(ch);
         ch = (ch == '.') ? '_' : ch;
         fputc(ch, fpout);
      }
      if (!k)
         fprintf(fpout, "\n");
      else
         fprintf(fpout, " 1\n");
   }
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
ATL_cpnode_t *GetCopyNodeFromMM(int flag, ATL_mmnode_t *mp, ATL_mmnode_t *ML)
/*
 * ML NULL means rout only called with K=kbB, so self-clean if kbB%ku != 0. Else
 * ML is master list of mm kernels, where ivar is set to the entry #+1 of the
 * K-clean node (ivar=0 means self-cleaning or no K-clean needed).
 */
{
   ATL_cpnode_t *cp;

   cp = GetCPNode();
   cp->flag = flag;
   if (FLAG_IS_SET(mp->flag, MMF_KVEC))
      cp->kvec = (mp->vlen > 1) ? mp->vlen : 0;
   if (mp->blask == ATL_KSYRK && (flag&(1<<CPF_CBLK)))
      cp->flag |= (1<<CPF_SYRK);
   @whiledef rt SYMM TRMM TRSM
   else if (mp->blask == ATL_K@(rt))
      cp->flag |= (1<<CPF_@(rt));
   @endwhile
   if (flag&(1<<CPF_CBLK))
   {
      cp->STGID = mp->stgC;
      cp->mb = mp->mbB;
      cp->nb = mp->nbB;
      cp->mu = mp->mu;
      cp->nu = mp->nu;
   }
   else /* A or B */
   {
      if (flag&(1<<CPF_ABLK))  /* A */
      {
         cp->STGID = mp->stgA ;
         cp->mb = mp->mbB;
         cp->nb = mp->kbB;
         cp->nu = mp->mu;
      }
      else                      /* B */
      {
         cp->STGID = mp->stgB;
         cp->mb = mp->kbB;
         cp->nb = mp->nbB;
         cp->nu = mp->nu;
      }
      cp->mu = 1;
      if (FLAG_IS_SET(mp->flag, MMF_KVEC))  /* KVEC only cleans to vlen */
         cp->mu = mp->vlen;
      else if (mp->blask) /* non-gemm kernels always pad to ku */
         cp->mu = mp->ku; /* so can handle all K in face of unrolling */
      else if (ML)/* to find copy padding, must examine cleaning node in ML */
      {
         ATL_mmnode_t *ml;
         ml = MMKernCompIsPresent(ML, mp);
         assert(ml);
         if (ml->ivar)
         {
            const int n=ml->ivar-1;
            int i;
            for(i=0, ml=ML; i < n && ml; i++, ml = ml->next);
            assert(ml);
            assert(MMKernsCompat(mp, ml));
         }
         else ml = mp;
         cp->mu = ml->ku;
      }
      else if (mp->kbB % mp->ku)  /* self-cleaning with non-mult kbB */
         cp->mu = mp->ku;
      else /* no cleanup needed because kbB is multiple of ku */
         cp->mu = 1;
@skip      else if (mp->ku <= 4)  /* any kern wt ku <= 4 can be padded and */
@skip         cp->mu = mp->ku;    /* used for K-clean */
   }
   return(cp);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
ATL_cpnode_t *GetAllCopyNodesFromMM(int flag, ATL_mmnode_t *mb, 
                                    ATL_mmnode_t *ML)
{
   ATL_cpnode_t *cb=NULL, *cp;
   ATL_mmnode_t *mp;

   for (mp=mb; mp; mp = mp->next)
   {
      cp = GetCopyNodeFromMM(flag, mp, ML);
      cp->next = cb;
      cb = cp;
   }
   return(ReverseCPQ(cb));
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
int *MMGetCopyIdxsFromList(int flag, ATL_mmnode_t *mb, ATL_cpnode_t *cb,
                           ATL_mmnode_t *ML)
/*
 * RETURNS: integer array of indices (starting from 0) in cb, 1st elt is len
 */
{
   ATL_mmnode_t *mp;
   int i, N, *idxs;
   if (!mb)
      return(NULL);
   N = ATL_CountNumberOfMMNodes(mb);
   idxs = malloc((N+1)*sizeof(int));
   assert(idxs);
   idxs[0] = N;
   for (i=0,mp=mb; mp; i++, mp = mp->next)
   {
      ATL_cpnode_t *cm, *cp;
      int id;

      cm = GetCopyNodeFromMM(flag, mp, ML);
      assert(cm);
      for (id=0,cp=cb; cp; cp = cp->next, id++)
         if (!CopyAreDiff(cp, cm))
            break;
      if (!cp)
      {
         fprintf(stderr, "CANNOT FIND COPY FOR:\n");
         PrintCPLine(stderr, cm);
         PrintMMLine(stderr, mp);
         fprintf(stderr, "\nFAILING LIST: %p\n", cb);
         PrintCPNodes(stderr, cb);
         assert(cp);
      }
      KillCPNode(cm);
      idxs[i+1] = id;
   }
   return(idxs);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
ATL_cpnode_t *MMGetCopiesFromList(int flag, ATL_mmnode_t *mb, ATL_cpnode_t *cb,
                                  ATL_mmnode_t *ML)
{
   ATL_cpnode_t *mcb=NULL;
   ATL_mmnode_t *mp;
   for (mp=mb; mp; mp = mp->next)
   {
      ATL_cpnode_t *cm, *cp;
      cm = GetCopyNodeFromMM(flag, mp, ML);
      cp = FindEquivCopy(cb, cm);
      if (!cp)
      {
         fprintf(stderr, "NO COPY: ID=%d '%s', mu=%d, nu=%d, flg=%x\n",
                 cm->ID, cm->rout?cm->rout:"gen", cm->mu, cm->nu, cm->flag);
         PrintCPLine(stderr, cm);
      }
      assert(cp);
      KillCPNode(cm);
      cm = CloneCPNode(cp);
      cm->next = mcb;
      mcb = cm;
   }
   return(ReverseCPQ(mcb));
}


@iexp ip @(ip) 1 +
/* procedure @(ip) */
static int MMCopyGetKernID(int flag)
{
   int kernID;
   if (flag&(1<<CPF_TOBLK)) /* col-maj to block */
   {
      if (flag&(1<<CPF_CBLK)) /* copy C matrix */
      {
         if (flag&(1<<CPF_SYRK))
            kernID = ATL_KSKCPFC;
         else
            kernID = ATL_KGECPFC;
      }
      else /* involves A or B matrix */
         kernID = ATL_KGECPFA;
   }
   else  /* block to col-maj */
   {
      if (flag&(1<<CPF_CBLK)) /* copy C matrix */
      {
         if (flag&(1<<CPF_SYRK))
            kernID = ATL_KSKCP2C;
         else
            kernID = ATL_KGECP2C;
      }
      else /* involves A or B matrix */
         kernID = ATL_KGECP2A;
   }
   return(kernID);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
void MMCopyTimePrep1(char pre, int kernID, int ialp, int ibet, ATL_mmnode_t *mp)
{
   mp->flag = (mp->flag & (~MMF_MVSET))|(1<<MMF_MVC);
   mp->blask = kernID;
   mp->ID = 0;
   mp->TB = mp->TA = AtlasTrans; /* generally, worst case perf-wise */
   if (mp->rout)
     free(mp->rout);
   mp->rout = DupString("ATL_tmp.c");
   if (mp->comp)
      free(mp->comp);
   if (mp->cflags)
      free(mp->cflags);
   if (mp->auth)
      free(mp->auth);
   mp->auth = mp->comp = mp->cflags = NULL;
   if (mp->genstr)
     free(mp->genstr);
   mp->genstr = MMGetCpGenString(pre, mp, ialp, ibet);
   mp->ivar = 1;  /* effective VLEN for copy kern (not amm) */
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
void MMCopyTimePrep(char pre, int flag, ATL_mmnode_t *mb)
{
   ATL_mmnode_t *mp;
   int ialp, ibet=0;
   int kernID;

   kernID = MMCopyGetKernID(flag);
   ialp = CopyGetAlphaI(flag);
   if (flag&(1<<CPF_CBLK))
      ibet = CopyGetBetaI(flag);
   for (mp=mb; mp; mp = mp->next)
     MMCopyTimePrep1(pre, kernID, ialp, ibet, mp);
}

@BEGINSKIP
@iexp ip @(ip) 1 +
/* procedure @(ip) */
static char *GetMMCopyName(ATL_cpnode_t *p, int *LEN)
/*
 * RETURNS : Unique name for copy file, with at least 6 extra bytes alloc
 *           so that you can suffix it with _aX_bX or .c
 */
{
   char *sp=NULL, *dir;
   const int ID=p->ID, flag=p->flag;
   int len, i=0;
   char pre;

   pre = CopyGetPre(flag);
   dir = CopyGetDirect(flag);
   if (ID)
      len = 9 + NumDecDigits(p->ID);
   else
      len = 9+NumDecDigits(p->mu)+NumDecDigits(p->nu)+NumDecDigits(p->kvec);
/*
 * For C format routine naming scheme is:
 * ID=0 : ATL_<pre>cp[Into,From]BlkC_<mu>x<nu>_<kvec>
 * ID>0 : ATL_<pre><ID>cp[Into,From]BlkC
 */
   if (flag & (1<<CPF_CBLK))
   {
      if (p->ID) /* user-supplied */
      {
         len += 17 - 2*2;
         i = sprintf(sp, "ATL_%c%dcp%sBlkC", pre, ID, dir);
      }
      else if (p->flag & (1<<CPF_SYRK)) /* ATL_<pre>syblk2cmat */
      {
         i = len = 15;          /* 16:ATL_Xsyblk2cmat */
         sp = malloc(len+1);
         assert(sp);
         strcpy(sp, "ATL_Xsyblk2cmat");
         sp[4] = pre;
      }
      else /* ATL_<pre>cpy[To,From]C_<mu>x<nu>_<kvec> */
      {
         len += 24 - 4*2;
         sp = malloc(len+1);
         assert(sp);
         i = sprintf(sp, "ATL_%ccp%sBlkC_%dx%d_%d", pre, dir, 
                     p->mu, p->nu, p->kvec);
      }
   }
/*
 * For A/B format, routine name scheme is:
 * ID=0 : ATL_<pre>cp[To,From]BlkA_<u>_<kvec>
 * ID>0 : ATL_<pre><ID>cp[To,From]BlkA
 */
   else
   {
@skip      char TA;
@skip      TA  = CopyGetTrans(flag);

      if (ID)  /* ATL_<pre><ID>cp[To,From]BlkA */
      {
         len += 18 - 3*2;
         sp = malloc(len+1);
         assert(sp);
         i = sprintf(sp, "ATL_%c%dcp%sBlkA", pre, ID, dir);
      }
      else     /* ATL_<pre>cp[To,From]BlkA[N,T]_<u>_<kvec> */
      {
         len += 24 - 4*2;
         sp = malloc(len+1);
         assert(sp);
         i=sprintf(sp, "ATL_%ccp%sBlkA_%d_%d", pre, dir, p->nu, p->kvec);
      }
   }
   assert(i <= len);
   if (LEN)
      *LEN = i;
   return(sp);
}
@ENDSKIP

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static ATL_cpnode_t *GetMMCopyNode(int ID, int mu, int nu, int kvec, int flag)
{
   ATL_cpnode_t *cp;
   cp = calloc(1, sizeof(ATL_cpnode_t));
   cp->ID = ID;
   cp->mu = mu;
   cp->nu = nu;
   cp->kvec = kvec > 1 ? kvec : 0;
   cp->flag = flag;
   assert(cp);
   return(cp);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static ATL_cpnode_t *CloneCopyNode(ATL_cpnode_t *b)
{
   ATL_cpnode_t *p;
   p = malloc(sizeof(ATL_cpnode_t));
   memcpy(p, b, sizeof(ATL_cpnode_t));
   p->next = NULL;
/*
 * Now get our own copies of strings
 */
   @whiledef st rout genstr
   if (p->@(st))
      p->@(st) = DupString(p->@(st));
   @endwhile
   return(p);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static ATL_cpnode_t *KillCopyNode(ATL_cpnode_t *cp)
{
   ATL_cpnode_t *next=NULL;
   if (cp)
   {
      @whiledef st rout genstr
      if (cp->@(st))
         free(cp->@(st));
      @endwhile
      next = cp->next;
      free(cp);
   }
   return(next);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static ATL_cpnode_t *KillAllCopyNodes(ATL_cpnode_t *cp)
{
   while (cp)
      cp = KillCopyNode(cp);
   return(NULL);
}

@iexp ip @(ip) 1 +
/* procedure @(ip): RETURNS ptr to entry in b if n already there, else NULL */
ATL_cpnode_t *FindCopy(ATL_cpnode_t *b, ATL_cpnode_t *n)
{
   ATL_cpnode_t *p;
   for (p=b; p; p = p->next)
      if (!CopyAreDiff(p, n))
         return(p);
   return(NULL);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
ATL_cpnode_t *FindLastCopyNode(ATL_cpnode_t *b)
{
   if (b)
   {
      while(b->next)
         b = b->next;
   }
   return(b);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static ATL_cpnode_t *AddUniqueCopyNode(ATL_cpnode_t *cb, ATL_cpnode_t *cnb)
/*
 * Adds all copy entries in cnb to cb, if cb doesn't already have a 
 * functionally equivalent entry. cnb is unchanged.
 */
{
   ATL_cpnode_t *p;
   for (p=cnb; p; p = p->next)
   {
      if (!FindCopy(cb, p))
      {
         ATL_cpnode_t *np;
         np = CloneCopyNode(p);
         np->next = cb;
         cb = np;
      }
   }
   return(cb);
}

@beginskip
@iexp ip @(ip) 1 +
/* procedure @(ip) */
void GetMMCopyRefresh(int flag, ATL_mmnode_t *mb)
/*
 * Resets all mb's ->flags to flag, and recomputes all ->rout
 */
{
   ATL_mmnode_t *mp;
   for (mp=mb; mp; mp = mp->next)
   {
      mp->flag = flag;
      if (mp->rout)
         free(mp->rout);
      mp->rout = GetMMCopyName(mp, &mp->rtlen);
   }
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
ATL_cpnode_t *GetMMCopyFromMMNodes
(
   int flag,          /* set with call to CopyEncode */
   ATL_mmnode_t *mb   /* list of amm kerns */
)
{
   ATL_cpnode_t *cb, *cp;
   ATL_mmnode_t *mp;
   const int CP_C = (flag&(1<<CPF_CBLK)), CP_A = (flag&(1<<CPF_ABLK));
/*
 * Setup copy list matching the MM kerns in mb 
 */
   cp = cb = GetMMCopyNode(0, 0, 0, 0, 0);
   for (mp=mb; mp; mp = mp->next)
   {
      int ID=0, mu=0, nu=0, kvec=0;
      if (CP_C)
      {
         ID = mp->stgC;
         if (!ID)
         {
            mu = mp->mu;
            nu = mp->nu;
         }
      }
      else if (CP_A)
      {
         ID = mp->stgA;
         if (!ID)
            nu = mp->mu;  /* A/B storage always uses nu, only C uses mu */
      }
      else
      {
         ID = mp->stgB;
         if (!ID)
            nu = mp->nu;
      }
      if (FLAG_IS_SET(mp->flag, MMF_KVEC))
         kvec = mp->vlen;
      cp->next = GetMMCopyNode(ID, mu, nu, kvec, flag);
      cp = cp->next;
      cp->rout = GetMMCopyName(cp, &cp->rtlen);
   }
   return(KillCopyNode(cb));
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
void GetMMAllUniqueCopyFromMMNodes
(
   char pre,  /* '[s,d,c,z]' */
   char dirC,  /* '[T,F]' */
   char dirA,  /* '[T,F]' */
   ATL_mmnode_t *mb,  /* list of amm kerns */
   ATL_cpnode_t **AB,  /* cpy func where A & B can use same routine */
   ATL_cpnode_t **CB    /* copy routines for C */
)
/*
 * Creates seperate lists for copy funcs for A&B, and C.  For types where
 * A & B format are the same other than tranposition (includes both access-
 * and block-major ATLAS formats), each mb node will generate four ab nodes,
 * one for mu/nu/N/T.  For user types that can only be applied to A or B,
 * will need a way to find both Trans and NoTrans versions; right now we
 * have only one stgID!
 */
{
   ATL_cpnode_t *ab=(*AB), *cb = (*CB), *np;
   ATL_mmnode_t *mp;
   int flgA, flgC;

   flgC = (pre == 's' || pre == 'd') ? (1<<CPF_REAL) : 0;
   if (pre == 's' || pre == 'c')
      flgC |= (1<<CPF_SINGLE);
   flgA = flgC;
   if (dirA == 'T')
      flgA |= (1<<CPF_TOBLK);
   if (dirC == 'T')
      flgC |= (1<<CPF_TOBLK);
   flgC |= (1<<CPF_CBLK);

   np = GetMMCopyNode(0, 0, 0, 0, 0);

/*
 * Setup copy list matching the MM kerns in mb 
 */
   for (mp=mb; mp; mp = mp->next)
   {
      ATL_cpnode_t *p;
      int kvec = 0;

      np->kvec = FLAG_IS_SET(mp->flag, MMF_KVEC) ? mp->vlen : 0;
      np->ID = mp->stgC; np->mu = mp->mu; np->nu = mp->nu;
      np->flag = flgC;
      if (!FindCopy(cb, np))  /* not already in list, so add it */
      {
         p = CloneCopyNode(np);
         p->rout = GetMMCopyName(p, &p->rtlen);
         p->next = cb;
         cb = p;
      }
/*
 *    Add to A/B lists as necessary
 */
      np->ID = mp->stgA;
      np->mu = 0;
      np->flag = flgA;
      if (np->ID) /* user-generated kerns may not go to both cases */
      {
         assert(0); // should not happen yet
      }
      else /* Add two nodes to ab, using [A(mu),B(nu)] */
      {    /* don't set CPF_ABLK, since A or B is same for us */
         np->nu = mp->mu;
         if (!FindCopy(ab, np))
         {
            p = CloneCopyNode(np);
            p->rout = GetMMCopyName(p, &p->rtlen);
            p->next = ab;
            ab = p;
         }

         if (mp->mu != mp->nu)
         {
            np->flag = flgA;
            np->nu = mp->nu;
            if (!FindCopy(ab, np))
            {
               p = CloneCopyNode(np);
               p->rout = GetMMCopyName(p, &p->rtlen);
               p->next = ab;
               ab = p;
            }
         }
      }
   }

   KillCopyNode(np);
   *AB = ab;
   *CB = cb;
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
ATL_cpnode_t *AddMMCKernCopyFromMMNodes
(
   char pre,  /* '[s,d,c,z]' */
   char dir,  /* '[T,F]' */
   int KERN,          /* one of CPF_[SYRK,SYMM,TRMM], or 0 (GEMM) */
   ATL_mmnode_t *mb,  /* list of amm kerns */
   ATL_cpnode_t *ab     /* cpy func where A & B can use same routine */
)
{
   int flag = KERN ? (1<<KERN) : 0;
   ATL_mmnode_t *mp;
   if (!mb)
      return(ab);
   assert(KERN == CPF_SYRK);        /* true for now */
   flag |= CopyEncode(pre, dir, 'C', 'N');
   for (mp=mb; mp; mp = mp->next)
   {
      ATL_cpnode_t *np;
      np = GetMMCopyNode(0, mp->mu, mp->nu, FLAG_IS_SET(mp->flag, MMF_KVEC) ? 
                         mp->vlen : 0, flag);
      np->rout = GetMMCopyName(np, &np->rtlen);
      np->next = ab;
      ab = np;
   }
   return(ab);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
ATL_cpnode_t *AddMMUniqueACopyFromMMNodes
(
   char pre,  /* '[s,d,c,z]' */
   char dirA,  /* '[T,F]' */
   ATL_mmnode_t *mb,  /* list of amm kerns */
   ATL_cpnode_t *ab     /* cpy func where A & B can use same routine */
)
{
   ATL_cpnode_t *np;
   ATL_mmnode_t *mp;
   for (mp=mb; mp; mp = mp->next)
   {
      np = GetMMCopyNode(0, 0, mp->mu, 
                         FLAG_IS_SET(mp->flag, MMF_KVEC)?mp->vlen:0, 
                         CopyEncode(pre, dirA, 'B', 'N'));
      if (!FindCopy(ab, np))
      {
         np->rout = GetMMCopyName(np, &np->rtlen);
         np->next = ab;
         ab = np;
      }
      else
         KillCopyNode(np);
      if (mp->mu != mp->nu)
      {
         np = GetMMCopyNode(0, 0, mp->nu, 
                            FLAG_IS_SET(mp->flag, MMF_KVEC)?mp->vlen:0, 
                            CopyEncode(pre, dirA, 'B', 'N'));
         if (!FindCopy(ab, np))
         {
            np->rout = GetMMCopyName(np, &np->rtlen);
            np->next = ab;
            ab = np;
         }
      }
   }
   return(ab);
}
@endskip
@iexp ip @(ip) 1 +
/* procedure @(ip) */
static void PrepMMForGen(char pre, char *outd, char *nm, ATL_mmnode_t *mb)
/*
 * Prep mb for generation.  Free present values, and replace with:
 * ->auth  : kernel name without _b[1,n,0] suffix
 * ->genstr: for ID=0: genstr, else user kernel name (came in ->rout)
 * ->rout  : correct present filename (used in generation & compilation)
 */
{
   ATL_mmnode_t *mp;
   char suff[3]={'.', 'c', '\0'};
   char *od;

   od = NewMergedString(outd, "/");
   for (mp=mb; mp; mp = mp->next)
   {
      char cpr = pre;
      if (mp->flag & (1<<MMF_COMPLEX))
         cpr = (pre == 's') ? 'c' : 'z';
      if (mp->flag & (1<<MMF_KUISKB))
         assert((mp->flag & (1<<MMF_KRUNTIME)) == 0);
      if (mp->auth)
         free(mp->auth);
      mp->auth = GetMMKernName(cpr, nm, mp);
      if (mp->ID) /* user-supplied kernel */
      {
         int h;
         char ch = 'c', och;

         assert(!mp->genstr);
         assert(mp->rout);
         h = strlen(mp->rout);
         mp->genstr = mp->rout;
         mp->rout = GetMMFilename(pre, nm, mp);
      }
      else  /* generated kernel */
      {
         char *sp, *sp1;
         if (mp->rout)
            free(mp->rout);
         if (mp->genstr)
            free(mp->genstr);
         sp = GetMMFilename(cpr, nm, mp);
@skip         sp = NewMergedString(mp->auth, suff);
         mp->rout = NewMergedString(od, sp);  /* want to gen in outd/ */
         sp1 = MMGetGenString(cpr, mp);
         mp->genstr = NewMergedString(sp1, " > /dev/null 2>&1");
         free(sp1);
         free(mp->rout);
         mp->rout = sp; /* want filename w/o path for GenMake */
      }
   }
   free(od);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static FILE *OpenMMGenHeader
(
   char *outd,/* directory to write to must be non-NULL */
   int UID,   /* 0 for ATLAS files, >0 for uammsearch */
   char pre,  /* [d,s,z,c] */
   char *ip,  /* "[ip,op] */
   char *cn,  /* "[ge,sq,mn,dm,dn,nk,mk]" */
   char *nm,  /* "[blk,kern,flag,perf,sum,]" */
   ATL_mmnode_t *mb 
)
{
   char *fn, bs[6];
   int len, i;
   FILE *fp;

   /* NAME WILL BE: <outd>/atlas_<pre><ip><cn>[ID]_<nm>.h */
   assert(nm && outd);
   len = strlen(outd) + 1; /* outd+/ */
   len += 6 + 1 + 1 + 2;  /* atlas+pre+_+.h */
   if (ip)
      len += strlen(ip);
   else
      ip = "";
   if (cn)
      len += strlen(cn);
   else
      cn = "";
   if (UID)
      len += NumDecDigits(UID);
   len += strlen(nm);
   bs[0] = 0;

   fn = malloc(len+1);
   assert(fn);
   if (UID)
      i = sprintf(fn, "%s/atlas_%c%s%s%u_%s.h", outd, pre, ip, cn, UID, nm);
   else
      i = sprintf(fn, "%s/atlas_%c%s%s_%s.h", outd, pre, ip, cn, nm);
   assert(i <= len);
   fp = fopen(fn, "w");
   assert(fp);
/*
 * Now change file part of string to guard text: uppercase & ".h" -> "_H";
 */
   fn[i-1] = 'H';
   fn[i-2] = '_';
   for (i -= 3; fn[i] != '/'; i--)
      fn[i] = toupper(fn[i]);
   i++;
   fprintf(fp, "#ifndef %s\n", fn+i);
   fprintf(fp, "   #define %s 1\n", fn+i);
@skip   fprintf(fp, "   /* Genned by ATLAS/src/blas/gemm/ammgen.c */\n\n");
   fprintf(fp, "#include \"atlas_amm.h\"\n");
   if (mb && strcmp(nm, "perf"))
   {
      i = CountListEntries(mb, GetOffset(&mb->next, mb));
      if (cn[0] == 'g' && cn[1] == 'e')
      {
         fprintf(fp, "#ifdef ATL_AMM_NCASES\n   #if ATL_AMM_NCASES != %d\n", i);
         fprintf(fp, "      #error \"NCASES MISMATCH!\"\n   #endif\n");
         fprintf(fp, "#else\n   #define ATL_AMM_NCASES %d\n#endif\n", i);
      }
      else
      {
         fprintf(fp, "#ifdef ATL_%sAMM_NCASES\n   #if ATL_%sAMM_NCASES != %d\n",
                 cn, cn, i);
         fprintf(fp, "      #error \"NCASES MISMATCH!\"\n   #endif\n");
         fprintf(fp, "#else\n   #define ATL_%sAMM_NCASES %d\n#endif\n", cn, i);
      }
   }

   free(fn);
   return(fp);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static void CloseGenHeader(FILE *fp)
{
   fprintf(fp, "\n#endif\n");
   fclose(fp);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static char *GetSafeIntType(void *vb, int nxtoff, int off, int *CNT)
{
   int max, min, n;
   *CNT = GetIntMaxMinAtOff(vb, nxtoff, off, &max, &min);
   if (min < 0)
   {
      if (max < (1<<7))
         return("char");
      else if (max < (1<<15))
         return("short");
      return("int");
   }
   else if (max < (1<<8))
      return("unsigned char");
   else if (max < (1<<16))
      return("unsigned short");
   return("unsigned int");
}

@beginskip
@iexp ip @(ip) 1 +
/* procedure @(ip) */
void PrintMMIntOffArr(FILE *fp, char pre, char *nm, ATL_mmnode_t *mb, int off)
/*
 * Dumps integer stored at byte offset off mb's MMNodes to file fp using name nm
 */
{
   ATL_mmnode_t *mp;
   char *type;
   int i, n;

   type = GetSafeIntType(mb, GetOffset(&mb->next, mb), off, &n);
   fprintf(fp, "#ifndef NO%s\n", nm);
   fprintf(fp, "static const %s ATL_AMM_%s[%d] =\n{\n", type, nm, n);
   for (i=0,mp=mb; mp; i++,mp = mp->next)
      fprintf(fp, "%8d%c  /* IDX=%d */\n", *((int*)(((char*)mp)+off)),
              mp->next ? ',':' ', i);
   fprintf(fp, "};\n#endif\n\n");
}
@endskip

char *FillInMMScalarSuff(char ta, char alp, char bet)
{
   static char ab[8];
   if (!(alp|bet))
      ab[0] = '\0';
   else
   {
      int i;
      i = 1;
      ab[0] = '_';
      if (!bet)
      {
         ab[1] = ta;
         ab[2] = 'a';
         ab[3] = alp;
         ab[4] = '\0';
      }
      else if (!alp)
      {
         ab[1] = 'b';
         ab[2] = bet;
         ab[3] = '\0';
      }
      else
      {
         ab[1] = 'a';
         ab[2] = alp;
         ab[3] = '_';
         ab[4] = 'b';
         ab[5] = bet;
         ab[6] = '\0';
      }
   }
   return(ab);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
void PrintMMProtos(FILE *fp, char pre, char *nm, ATL_mmnode_t *mb, int off,
                   char bet)
{
   ATL_mmnode_t *mp;

   if (bet == '0')
      fprintf(fp, "#if !defined(NO%s_b%c) && !defined(NO%s_K1)\n", nm,bet, nm);
   else
      fprintf(fp, "#if !defined(NO%s_b%c) && !defined(NO%s_K1_b%c)\n", 
              nm,bet, nm,bet);
   for (mp=mb; mp; mp = mp->next)
      fprintf(fp, "void %s_b%c\n%s\n%s\n", GetStrAtOff(mp, off), bet,
              "   (ATL_CSZT,ATL_CSZT,ATL_CSZT,const TYPE*,const TYPE*,TYPE*,",
              "    const TYPE*,const TYPE*,const TYPE*);");
   fprintf(fp, "#endif\n\n");
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
void PrintMMCpProtosA(FILE *fp, char *nm, ATL_cpnode_t *cb, char dir, char alp)
{
   ATL_cpnode_t *cp;
   char *pro;
   char pre;

   pre = CopyGetPre(cb->flag);
   if (pre == 'd' || pre == 's')
   {
      pro = (dir == 'F') ? 
           "(ATL_CSZT,ATL_CSZT,const SCALAR,TYPE*,ATL_CSZT,const TYPE*)"
         : "(ATL_CSZT,ATL_CSZT,const SCALAR,const TYPE*,ATL_CSZT,TYPE*)";
   }
   else
   {
      pro = (dir == 'F') ? 
      "(ATL_CSZT,ATL_CSZT,const SCALAR,TYPE*,ATL_CSZT,const TYPE*,const TYPE*);"
      : "(ATL_CSZT,ATL_CSZT,const SCALAR,const TYPE*,ATL_CSZT,TYPE*,TYPE*);";
   }
   fprintf(fp, "#ifndef NO%s_a%c\n", nm, alp);
   for (cp=cb; cp; cp = cp->next)
   {
      char ta;
      ta = CopyGetTrans(cp->flag);
      fprintf(fp, "void %s_%ca%c\n   %s;\n", cp->rout, ta, alp, pro);
   }
   fprintf(fp, "#endif\n\n");
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
void PrintMMCpProtosC(FILE *fp, char *nm, ATL_cpnode_t *cb, 
                      char dir, char alp, char bet)
{
   ATL_cpnode_t *cp;
   char *ab;
   char *pro;
   char pre;

   pre = CopyGetPre(cb->flag);
   ab = FillInMMScalarSuff(0, alp, bet);
   if (pre == 'd' || pre == 's')
   {
      pro = (dir == 'F') ?
"(ATL_CSZT,ATL_CSZT,const SCALAR,const TYPE*,const SCALAR,TYPE*,ATL_CSZT);"
:
"(ATL_CSZT,ATL_CSZT,const SCALAR,const TYPE*,ATL_CSZT,const SCALAR,TYPE*);";
   }
   else
   {
      pro = (dir == 'F') ?
"(ATL_CSZT,ATL_CSZT,const SCALAR,const TYPE*,const TYPE*,const SCALAR,\n     TYPE *,ATL_CSZT);"
            :
"   (ATL_CSZT,ATL_CSZT,const SCALAR,const TYPE*,ATL_CSZT,const SCALAR,\n     TYPE*,TYPE*);";
   }
   fprintf(fp, "#ifndef NO%s%s\n", nm,ab);
   for (cp=cb; cp; cp = cp->next)
      fprintf(fp, "void %s%s\n   %s\n", cp->rout, ab, pro);
   fprintf(fp, "#endif\n\n");
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
void PrintIntArrAtOff
(
   FILE *fp,
   char pre,   /* [d,s,c,z] */
   char *nm,   /* name of the array, optionally decorated by _aX_bX */
   void *sb,
   int nxtoff, /* offset (bytes) in struct to next pointer */
   int ioff,   /* offset in struct to integer val we are printing */
   char alp,
   char bet
)
/*
 * Dumps integer stored at ioff in sb's struct to file fp using name nm.

 */
{
   char *cp = sb;
   char *type;
   char *ab;
   int i, n;

   ab = FillInMMScalarSuff(0, alp, bet);

   type = GetSafeIntType(sb, nxtoff, ioff, &n);
   fprintf(fp, "#ifndef NO%s\n", nm);
   fprintf(fp, "static const %s ATL_AMM_%s%s[%d] =\n{\n", type, nm, ab, n);
   for (i=0; cp; i++)
   {
      char *nxt;
      nxt = GetStrAtOff(cp, nxtoff);
      fprintf(fp, "%8d%c  /* CNT=%d */\n", *((int*)(cp+ioff)), nxt?',':' ', i);
      cp = nxt;
   }
   fprintf(fp, "};\n#endif\n\n");
}
@iexp ip @(ip) 1 +
/* procedure @(ip) */
void PrintStrArrAtOff(FILE *fp, char pre, char *nm, void *vb,
                      int nxtoff, int off, char *type, 
                      char ta, char alp, char bet)
/*
 * Dumps integer stored at byte offset off mb's MMNodes to file fp using name nm
 */
{
   char *cp;
   int i, n;
   char *ab;

   n = CountListEntries(vb, nxtoff);
   ab = FillInMMScalarSuff(ta, alp, bet);
@skip   if (bet == '0' && !strcmp(nm, "KERN_K1"))
@skip      fprintf(fp, "#ifndef NOKERN_K1\n");
@skip   else
   fprintf(fp, "#ifndef NO%s%s\n", nm,ab);
   if (!bet) /* A/B copy funcs */
      fprintf(fp, "static const %s ATL_AMM_%s_a%c[%d] =\n{\n",type,nm,alp,n);
   else
      fprintf(fp, "static const %s ATL_AMM_%s%s[%d] =\n{\n", type, nm, ab, n);
   for (i=0,cp=vb; cp; i++)
   {
      char *next;
      next = GetStrAtOff(cp, nxtoff);
      fprintf(fp, "/* IDX=%3d */ %s%s%c\n", 
              i, GetStrAtOff(cp, off), ab, next ? ',':' ');
      cp = next;
   }
   fprintf(fp, "};\n#endif\n\n");
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
char *GetMMKernComp(ATL_mmnode_t *mmp, char *dcomp, char *dflags, char **flgs)
{
   char *comp = dcomp;
   if (mmp->comp)
   {
      comp = (mmp->comp[0] == 'g' && mmp->comp[1] == 'c' &&
              mmp->comp[2] == 'c' &&
             (mmp->comp[3] == '\0' || mmp->comp[3] == ' '))
             ? "$(GOODGCC)" : mmp->comp;
      *flgs = mmp->cflags;
   }
   else
      *flgs = dflags;
   return(comp);
}

@beginskip
@iexp ip @(ip) 1 +
/* procedure @(ip) */
void PrintKernComp
(
   FILE *fp,            /* file to print to */
   char pre,
   ATL_mmnode_t *mp,   /* kernel compile rule is for */
   char *comp,          /* compiler to use */
   char *cflags,        /* compiler flags to use */
   char *styp,          /* string defining type (eg. "-DSREAL") */
   char cbet,           /* character with beta name ('1', '0', 'n') */
   char *sbet           /* string wt full beta name ("1", "N1", "0") */
)
{
   const int kb = FLAG_IS_SET(mp->flag, MMF_KRUNTIME)?0:mp->kbB;
   fprintf(fp, "%s_b%c : %s\n", mp->auth, cbet
   fprintf(fp, "\t%s $(CDEFS2) %s -DBETA%s=1", comp, styp, sbet);
   if (!FLAG_IS_SET(mp->flag, MMF_KRUNTIME))
      fprintf(fp, " -DMB=%d -DNB=%d, -DKB=%d", mp->mbB, mp->nbB, mp->kbB);
   if (FLAG_IS_SET(mp->flag, MMF_MVA))
      fprintf(fp, " -DATL_MOVEA");
   if (FLAG_IS_SET(mp->flag, MMF_MVB))
      fprintf(fp, " -DATL_MOVEB");
   if (FLAG_IS_SET(mp->flag, MMF_MVC))
      fprintf(fp, " -DATL_MOVEC");
         fprintf(fp, " -DATL_USERMM=ATL_%c%s_%d_%d_%x_%dx%dx%d_b%c", pre, nam,
                 mp->ID, kb, flg, mp->mu, mp->nu, mp->ku, cbet);
         fprintf(fp, " %s -o ATL_%c%s_%d_%d_%x_%dx%dx%d_b%c.o -c %s\n",
                 cflags, pre, nam, mp->ID, kb, flg, mp->mu, mp->nu, mp->ku,
                 cbet, mp->rout);
}
@endskip
void PrintMakeTargs(FILE *fp, char pre)
{
/*
 * library make targets
 */
   fprintf(fp, "\n\nlib : %clib.grd\nall : %clib.grd\n%clib : %clib.grd\n",
           pre, pre, pre, pre);
   fprintf(fp, "%clib.grd : $(objs)\n", pre);
   fprintf(fp, "\t$(ARCHIVER) $(ARFLAGS) $(ATLASlib) $(objs)\n");
   fprintf(fp, "\t $(RANLIB) $(ATLASlib)\n");
   fprintf(fp, "\t touch %clib.grd\n", pre);
   fprintf(fp, "clean : %cclean\n", pre);
   fprintf(fp, "%cclean:\n\t- rm -f $(objs)\n", pre);
   fprintf(fp, "killall : %ckillall\n", pre);
   fprintf(fp, "%ckillall : %cclean\n", pre, pre);
   fprintf(fp, "\t- $(ARCHIVER) d $(ATLASlib) $(objs)\n");
   fprintf(fp, "\t $(RANLIB) $(ATLASlib)\n");
   fprintf(fp, "\t- rm -f ATL_%c*.[S,c]\n\n", pre);
}
#endif  /* end guard around atlas_mmgen.h */
@ROUT getflagarrs

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static int *GetIntList1(int ival)
/*
 * returns integer array with iarr[0] = 1, iarr[1] = ival
 */
{
   int *iarr;
   iarr = malloc(2*sizeof(int));
   assert(iarr);
   iarr[0] = 1;
   iarr[1] = ival;
   return(iarr);
}

#ifdef TYPE
@iexp ip @(ip) 1 +
/* procedure @(ip) */
static TYPE *GetTypeList1(const SCALAR val)
/*
 * Returns a TYPE array with arr[0] = 1.0, arr[1] = val
 */
{
   TYPE *arr;
   arr = malloc(ATL_MulBySize(2));
   assert(arr);
   arr[0] = 1;
   #ifdef TCPLX
      arr[2] = *val;
      arr[3] = val[1];
   #else
      arr[1] = val;
   #endif
   return(arr);
}
#endif

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static int *GetIntList2(int ival1, int ival2)
/*
 * returns integer array with iarr[0] = 1, iarr[1] = ival1, ival[2] = ival2
 */
{
   int *iarr;
   iarr = malloc(3*sizeof(int));
   assert(iarr);
   iarr[0] = 1;
   iarr[1] = ival1;
   iarr[2] = ival2;
   return(iarr);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static int *DupIntList(int *list)
/*
 * Duplicates list of integers, list[0] holds the length, not including 0
 */
{
   int i, n, *ip;

   assert(list);
   n = list[0] + 1;
   ip = malloc(sizeof(int)*n);
   assert(ip);
   for (i=0; i < n; i++)
      ip[i] = list[i];
   return(ip);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static int *GetIntList(int nargs, char **args, int i, int nmul)
/*
 * Gets a list of integers, whose length is given by atoi(args[i])*nmul
 * list is this length+1, since 0'th location gets atoi(args[i])
 */
{
   int n, *iarr, k;

   if (++i >= nargs)
      PrintUsage(args[0], i, NULL);
   n = atoi(args[i]) * nmul;
   assert(n > 0);
   iarr = malloc(sizeof(int)*(n+1));
   assert(iarr);
   
   iarr[0] = n / nmul;
   for (k=0; k < n; k++)
   {
      if (++i >= nargs)
         PrintUsage(args[0], i, NULL);
      iarr[k+1] = atoi(args[i]);
   }
   return(iarr);
}

#ifdef TYPE
@iexp ip @(ip) 1 +
/* procedure @(ip) */
static TYPE *GetTypeList(int nargs, char **args, int i, int nmul)
/*
 * Gets a list of TYPEs, whose length is given by atoi(args[i])*nmul
 * list is this length+1, since 0'th location gets atof(args[i])
 */
{
   int n, k;
   TYPE *arr;

   if (++i >= nargs)
      PrintUsage(args[0], i, NULL);
   n = atoi(args[i]) * nmul;
   assert(n > 0);
   arr = malloc(ATL_MulBySize(n+1));
   assert(arr);
   
   arr[0] = n / nmul;
   for (k=0; k < n; k++)
   {
      if (++i >= nargs)
         PrintUsage(args[0], i, NULL);
      arr[k+(1 SHIFT)] = atof(args[i]);
   }
   return(arr);
}
#endif

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static int *IntRange2IntList(int N0, int NN, int incN)
{
   int i, n;
   int *iarr;

   for (i=N0, n=0; i <= NN; i += incN) n++;
   iarr = malloc(sizeof(int)*(n+1));
   assert(iarr);
   iarr[0] = n;
   for (i=N0, n=1 ; i <= NN; i += incN, n++)
      iarr[n] = i;
   return(iarr);
}
@ROUT atlas_service.h
#ifndef ATLAS_SERVICE_H
   #define ATLAS_SERVICE_H

#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#ifdef __GNUC__
/*
 * This routine overrides system tmpnam when compiling with GNU, which
 * issues an unkillable warning whenever you use this standard ANSI C
 * routine, telling you to use a non-standard routine instead.  If we
 * are being compiled by gnu gcc, use the non-standard routine in order to shut
 * the warnings up.  Here we hope they won't stop supporting a routine
 * that they force you to use.
 */
#ifdef L_tmpnam
  #undef L_tmpnam
#endif
#define L_tmpnam 16
static char *ATL_tmpnam(char *s)
/*
 * Works like ISO standard C's tmpnam: returns a ptr to a safe temporary
 * filename.  If s is NULL, the return pointer points at a static string
 * that is overwritten on the next call.  If s is non-NULL, return it,
 * and write string to user-controlled buffer s.
 * NOTE: this routine is not thread safe if you pass NULL.
 */
{
   static char *buff=NULL;
   char *sp;
   int n, i;
   
   sp = tempnam(NULL, "attmp");
   assert(sp);
   if (s)
   {
      strcpy(s, sp);
      free(sp);
      return(s);
   }
   if (buff)
      free(buff);
   n = strlen(sp) + 1;
   buff = malloc(sizeof(char)*i);
   strcpy(buff, sp);
   free(sp);
   return(buff);
}
   #define tmpnam ATL_tmpnam
#else
   #define ATL_tmpnam tmpnam
#endif

#endif
@ROUT atlas_Tvec.h
@iexp ip 0 0 +
#ifndef ATL_Tvec_H
   #define ATL_Tvec_H

#include "atlas_genparse.h"


typedef struct ATL_Tvec ATL_tvec_t;
struct ATL_Tvec
{
   void *vp;            /* pointer to vector, type in pre */
   char *name;          /* name of vector (eg, "MFLOP" or "N") */
   ATL_tvec_t *next;
   int  N;              /* # of elements in vector (inclucing reps) */
   int nrep;            /* # of repititions in timings */
   char pre;            /* double (d), string (s), char (c), integer (i) */
};

typedef struct ATL_tvstrq ATL_tvstrq_t;
struct ATL_tvstrq
{
   char *sp;
   ATL_tvstrq_t *next;
   int len;
};

@iexp ip @(ip) 1 +
/* procedure @(ip) */
@define tvr @ATL_tvstrq_t *ATL_GetStrNode(char *name)@
@define tve @Allocates node & new string dup, returns node ptr@
ATL_tvstrq_t *ATL_GetStrNode(char *name)
{
   ATL_tvstrq_t *np;
   np = malloc(sizeof(ATL_tvstrq_t));
   assert(np);
   np->sp = DupString(name);
   assert(np->sp);
   np->len = strlen(name);
   strncpy(np->sp, name, np->len+1);
   np->next = NULL;
   return(np);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
@define tvr @ATL_tvstrq_t *ATL_KillStrNode(ATL_tvstrq_t *kp)@
@define tve @Deallocates node & string, returns next@
ATL_tvstrq_t *ATL_KillStrNode(ATL_tvstrq_t *kp)
{
   ATL_tvstrq_t *kn=NULL;
   if (kp)
   {
      kn = kp->next;
      if (kp->sp)
         free(kp->sp);
      free(kp);
   }
   return(kn);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
@define tvr @void ATL_KillStrQ(ATL_tvstrq_t *kb)@
@define tve @Deallocates entire string queue@
void ATL_KillStrQ(ATL_tvstrq_t *kb)
{
   while (kb)
      kb = ATL_KillStrNode(kb);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
@define tvr @ATL_tvstrq_t *RemoveStrNodeFromQ(ATL_tvstrq_t *b, ATL_tvstrq_t *p)@
@define tve @removes p from Q b, sets p->next=NULL, returns new b@
ATL_tvstrq_t *RemoveStrNodeFromQ(ATL_tvstrq_t *b, ATL_tvstrq_t *p)
/*
 * Safely removes p from queue b, returns possibly changed b
 */
{
   if (!b)
      return(NULL);
   if (!p)
      return(b);
   if (p == b)
      b = b->next;
   else
   {
      ATL_tvstrq_t *prev=b, *qp;
      for (qp=b->next; qp; qp = qp->next)
         prev=qp;
      prev->next = p->next;
   }
   p->next = NULL;
   return(b);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
@define tvr @char **ATL_StrQ2Arr(ATL_tvstrq_t *qb, int *N)@
@define tve @Kills qb to make N+1-length NULL-term array of strings instead@
char **ATL_StrQ2Arr(ATL_tvstrq_t *qb, int *N)
/*
 * translates qb to a NULL-term array of strings, destroying qb in process
 */
{
   int n, i;
   char **sarr;
   ATL_tvstrq_t *qp;

   n = *N = ATL_CountStrNodes(qb);
   sarr = malloc((n+1)*sizeof(char*));
   assert(sarr);

   sarr[n] = NULL;
   for (i=0,qp=qb; qp; i++,qp = qp->next)
   {
      sarr[i] = qp->sp;
      qp->sp = NULL;
   }
   ATL_KillStrQ(qb);
   return(sarr);
}


@iexp ip @(ip) 1 +
/* procedure @(ip) */
@define tvr @int ATL_CountStrNodes(ATL_tvstrq_t *qb)@
@define tve @Returns number of nodes in qb@
int ATL_CountStrNodes(ATL_tvstrq_t *qb)
{
   int i;
   ATL_tvstrq_t *qp;
   for (i=0,qp=qb; qp; i++, qp=qp->next);
   return(i);
}
@iexp ip @(ip) 1 +
/* procedure @(ip) */
@define tvr @ATL_tvstrq_t *ATL_ReverseStrQ(ATL_tvstrq_t *oq)@
@define tve @Returns oq in reverse order@
ATL_tvstrq_t *ATL_ReverseStrQ(ATL_tvstrq_t *oq)
/*
 * RETURNS: Reversed order queue of strings (original is reordered)
 */
{
   ATL_tvstrq_t *nq=NULL, *qp;
   while (oq)
   {
      qp = oq;
      oq = oq->next;
      qp->next = nq;
      nq = qp;
   }
   return(nq);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
@define tvr @ATL_tvec_t *ATL_GetTvec(char *name, int N, int nrep, char pre)@
@define tve @Returns allocated Tvec struct, next is NULL, vp alloc, but not init@
ATL_tvec_t *ATL_GetTvec(char *name, int N, int nrep, char pre)
{
   ATL_tvec_t *tp;
   int i;

   tp = malloc(sizeof(ATL_tvec_t));
   i = strlen(name);

   tp->name = malloc(sizeof(char)*(strlen(name)+1));
   strcpy(tp->name, name);
   tp->N = N;
   tp->nrep = nrep;
   tp->next = NULL;
   tp->pre = pre;
   i = N;
   if (pre == 's')
      i *= sizeof(char*);
   else if (pre == 'd')
      i *= sizeof(double);
   else 
      i *= (pre == 'i') ? sizeof(int) : sizeof(char);
   tp->vp = malloc(N*sizeof(double));
   assert(tp->vp);
   return(tp);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
@define tvr @ATL_tvec_t *ATL_KillThisTvec(ATL_tvec_t *tp)@
@define tve @Frees all internal ptrs, frees arg tvec (tp), returns tp->next@
ATL_tvec_t *ATL_KillThisTvec(ATL_tvec_t *tp)
{
   ATL_tvec_t *retp=NULL;

   if (tp)
   {
      if (tp->pre == 's')
      {
         char **sp = tp->vp;
         int i;

         for (i=0; i < tp->N; i++)
            free(sp[i]);
         free(sp);
      }
      else
         free(tp->vp);
      free(tp->name);
      retp = tp->next;
      free(tp);
   }
   return(retp);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
@define tvr @void ATL_KillAllTvecs(ATL_tvec_t *tq)@
@define tve @Frees all Tvecs (and internals) in list@
void ATL_KillAllTvecs(ATL_tvec_t *tq)
{
   while (tq)
      tq = ATL_KillThisTvec(tq);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
@define tvr @void ATL_ReadDoubleTvec(FILE *fpin, int N, double *dp)@
@define tve @Reads in N doubles from fpin into dp@
void ATL_ReadDoubleTvec(FILE *fpin, int N, double *dp)
{
   int i;

   for (i=0; i < N; i++)
      assert(fscanf(fpin, "%lf\n", dp+i) == 1);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
@define tvr @void ATL_ReadIntTvec(FILE *fpin, int N, int *ip)@
@define tve @Reads in N int from fpin into ip@
void ATL_ReadIntTvec(FILE *fpin, int N, int *ip)
{
   int i;

   for (i=0; i < N; i++)
      assert(fscanf(fpin, "%d\n", ip+i) == 1);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
@define tvr @ATL_ReadCharTvec(FILE *fpin, int N, char *cp)@
@define tve @Reads in N chars from fpin into cp@
void ATL_ReadCharTvec(FILE *fpin, int N, char *cp)
{
   int i;

   for (i=0; i < N; i++)
      assert(fscanf(fpin, "%c\n", cp+i) == 1);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
@define tvr @ATL_ReadStringTvec(FILE *fpin, int N, char **sa)@
@define tve @Reads in N strings from fpin into sa@
void ATL_ReadStringTvec(FILE *fpin, int N, char **sa)
{
   int i;

   for (i=0; i < N; i++)
   {
      char *sp;
      int n, j;
      char ln[512];

      assert(fgets(ln, 512, fpin));
      n = strlen(ln) + 1;
      sa[i] = sp = malloc(sizeof(char)*n);
      assert(sp);
      for (j=0; j < n; j++)
         sp[j] = ln[j];
   }
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
@define tvr @ATL_tvec_t *ATL_ReadTvec(FILE *fpin)@
@define tve @Returns one tvec read in from fpin@
ATL_tvec_t *ATL_ReadTvec(FILE *fpin)
{
   int N, nrep;
   char nm[64], pre;
   ATL_tvec_t *tp;

   assert(fscanf(fpin, "%s\n", nm) == 1);
   assert(fscanf(fpin, "%d %d %c", &N, &nrep, &pre) == 3);
   tp = ATL_GetTvec(nm, N, nrep, pre);
   if (pre == 'd')
     ATL_ReadDoubleTvec(fpin, N, tp->vp);
   else if (pre == 'i')
     ATL_ReadIntTvec(fpin, N, tp->vp);
   else if (pre == 'c')
     ATL_ReadCharTvec(fpin, N, tp->vp);
   else /* if (pre == 's') */
     ATL_ReadStringTvec(fpin, N, tp->vp);
   return(tp);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
@define tvr @ATL_tvec_t *ATL_ReadTvecFile(FILE *fpin, char **cmnt, int *nvec)@
@define tve @Return all tvecs from file fpin (fpin at beginning of file!)@
ATL_tvec_t *ATL_ReadTvecFile(FILE *fpin, char **cmnt, int *nvec)
/*
 * Reads an entire timing vector file.
 * RETURNS: linked list of timing vectors
 */
{
   int i, n;
   char ln[512];
   ATL_tvec_t *tb, *tp;

   if (!fgets(ln, 512, fpin))
      return(NULL);
   n = strlen(ln);
   while (n > 0 && isspace(ln[n-1]))
      ln[--n] = '\0';;
   *cmnt = malloc(sizeof(char)*n);
   assert(*cmnt);
   strcpy(*cmnt, ln+1);
   assert(fscanf(fpin, " %d\n", nvec) == 1);

   n = *nvec;
   if (n < 1)
      return(NULL);

   tb = tp = ATL_ReadTvec(fpin);
   for (i=1; i < n; i++)
   {
      tp->next = ATL_ReadTvec(fpin);
      tp = tp->next;
   }
   return(tb);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
@define tvr @void ATL_WriteTvec(FILE *fpout, ATL_tvec_t *tp)@
@define tve @Write a single timing vector to the stream fpout@
void ATL_WriteTvec(FILE *fpout, ATL_tvec_t *tp)
/*
 * Write a single timing vector to the stream fpout
 */
{
   fprintf(fpout, "%s\n", tp->name);
   fprintf(fpout, "%d %d %c\n", tp->N, tp->nrep, tp->pre);
   if (tp->pre == 'd')
   {
      double *dp = tp->vp;
      const int n = tp->N;
      int i;
      for (i=0; i < n; i++)
         fprintf(fpout, "%le\n", dp[i]);
   }
   else if (tp->pre == 'i')
   {
      int *ip = tp->vp;
      const int n = tp->N;
      int i;
      for (i=0; i < n; i++)
         fprintf(fpout, "%d\n", ip[i]);
   }
   else if (tp->pre == 'c')
   {
      char *cp = tp->vp;
      const int n = tp->N;
      int i;
      for (i=0; i < n; i++)
         fprintf(fpout, "%c\n", cp[i]);
   }
   else /* if (tp->pre == 's') */
   {
      char **sp = tp->vp;
      const int n = tp->N;
      int i;
      for (i=0; i < n; i++)
         fprintf(fpout, "%s\n", sp[i]);
   }
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
@define tvr @void ATL_WriteTvecs(FILE *fpout, ATL_tvec_t *tp)@
@define tve @Writes list of tvecs assuming stream already has preamble in it@
void ATL_WriteTvecs(FILE *fpout, ATL_tvec_t *tp)
/*
 * Writes out a queue of output vectors to a stream that has already had
 * the preample (name, nvec, nrep) written to it
 */
{
   while (tp)
   {
      ATL_WriteTvec(fpout, tp);
      tp = tp->next;
   }
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
@define tvr @void ATL_WriteTvecFile(FILE *fpout, char *cmnt, int nvec, ATL_tvec_t *tp)@
@define tve @Writes the entire output file given a queue of timing vectors@
void ATL_WriteTvecFile(FILE *fpout, char *cmnt, int nvec, ATL_tvec_t *tp)
/*
 * Writes the entire output file given a queue of timing vectors 
 */
{
   int i;
   fprintf(fpout, "#%s\n", cmnt);
   fprintf(fpout, "%d\n", nvec);
   ATL_WriteTvecs(fpout, tp);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
@define tvr @ATL_tvec_t *ATL_FindTvecByName(ATL_tvec_t *tb, char *name)@
@define tve @Returns first tvec with name name (NULL if not found)@
ATL_tvec_t *ATL_FindTvecByName(ATL_tvec_t *tb, char *name)
{
   ATL_tvec_t *tp;
   for (tp=tb; tp && strcmp(tp->name, name); tp = tp->next);
   return(tp);
}

@whiledef typ double int char
@iexp ip @(ip) 1 +
/* procedure @(ip) */
@define tvr @void ATL_FillComb@up@(typ)VecUsingInts@
@define tve @Merges two tvecs, go read the function@
void ATL_FillComb@up@(typ)VecUsingInts
(
   ATL_tvec_t *np,    /* combined vector */
   ATL_tvec_t *ip1,   /* 1st index array (we sort cp1 & cp2 on these ivecs) */
   ATL_tvec_t *ip2,   /* 2nd index array (we sort cp1 & cp2 on these ivecs) */
   ATL_tvec_t *cp1,   /* 1st array to be combined */
   ATL_tvec_t *cp2    /* 2st array to be combined */
)
{
   @(typ) *dn = np->vp;
   const @(typ) *d1 = cp1->vp, *d2 = cp2->vp;
   const int *s1 = ip1->vp, *s2 = ip2->vp;
   const int n = np->N, n1 = cp1->N, n2 = cp2->N;
   int ic, i1, i2;

   for (ic=i1=i2=0; ic < n; ic++)
   {
      if (i1 < n1)
      {
         if (i2 < n2)  /* both are available for comparison */
         {
            if (s1[i1] <= s2[i2])
               dn[ic] = d1[i1++];
            else
               dn[ic] = d2[i2++];
         }
         else
         {
            assert(i1 < n1);
            dn[ic] = d1[i1++];
         }
      }
      else
      {
         assert(i2 < n2);
         dn[ic] = d2[i2++];
      }
   }
}
@endwhile

@iexp ip @(ip) 1 +
/* procedure @(ip) */
@define tvr @ATL_tvec_t *ATL_CombineTheseVecsUsingInts@
@define tve @Merges two tvecs, go read the function@
ATL_tvec_t *ATL_CombineTheseVecsUsingInts
(
   ATL_tvec_t *sp1,      /* 1st vector's index array to sort on */
   ATL_tvec_t *sp2,      /* 2nd vector's index array to sort on */
   ATL_tvec_t *cp1,      /* vector to be combined */
   ATL_tvec_t *cp2       /* vector to be combined */
)
{
   ATL_tvec_t *np;
   const pre = cp1->pre;

   assert(sp1->N == cp1->N && sp2->N == cp2->N);
   assert(sp1->pre == sp2->pre && sp1->pre == 'i');
   assert(pre == cp2->pre);
   assert(sp1->nrep == sp2->nrep && sp1->nrep == cp1->nrep && 
          sp1->nrep == cp2->nrep);
   np = ATL_GetTvec(cp1->name, cp1->N+cp2->N, cp1->nrep, pre);
   if (pre == 'i')
      ATL_FillCombINTVecUsingInts(np, sp1, sp2, cp1, cp2);
   else if (pre == 'd')
      ATL_FillCombDOUBLEVecUsingInts(np, sp1, sp2, cp1, cp2);
   else if (pre == 'c')
      ATL_FillCombCHARVecUsingInts(np, sp1, sp2, cp1, cp2);
   return(np);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
@define tvr @void ATL_SuffixTvecNames(ATL_tvec_t *tb, char *suff)@
@define tve @suffix all names in tb with suff@
void ATL_SuffixTvecNames
(
   ATL_tvec_t *tb,   /* list whose names should be suffixed */
   char *suff 
)
{
   ATL_tvec_t *tp;
   int isu;

   isu = strlen(suff) + 1;
   for (tp=tb; tp; tp = tp->next)
   {
      int i, inm, n;
      char *sp;

      inm = strlen(tp->name);
      sp = malloc((inm+isu)*sizeof(char));
      for (i=0; i < inm; i++)
         sp[i] = tp->name[i];
      for (n=inm+isu; i < n; i++)
         sp[i] = suff[i-inm];
      free(tp->name);
      tp->name = sp;
   }
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
@define tvr @ATL_tvec_t *ATL_DupTvec(ATL_tvec_t *t0)@
@define tve @Return newly allocated tvec identical to t0, except ->next is NULL@
ATL_tvec_t *ATL_DupTvec(ATL_tvec_t *t0)
{
   ATL_tvec_t *tp;
   const int N = t0->N;
   int i;

   tp = ATL_GetTvec(t0->name, N, t0->nrep, t0->pre);
   tp->next = NULL;
   if (t0->pre == 'd')
   {
      double *d0 = t0->vp, *d=tp->vp;
      for (i=0; i < N; i++)
         d[i] = d0[i];
   }
   else if (t0->pre == 'i')
   {
      int *d0 = t0->vp, *d=tp->vp;
      for (i=0; i < N; i++)
         d[i] = d0[i];
   }
   else /* pre == 'c' */
   {
      char *d0 = t0->vp, *d=tp->vp;
      assert(t0->pre == 'c');
      for (i=0; i < N; i++)
         d[i] = d0[i];
   }
   return(tp);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
@define tvr @void ATL_AdhereTvec(ATL_tvec_t *dp, ATL_tvec_t *sp)@
@define tve @Stick data in sp->vp to end of dp->vp, sp not changed@
void ATL_AdhereTvec
/*
 * Concatonates sp's Tvec entries to the end of dp's.
 */
(
   ATL_tvec_t *dp,      /* destination Tvec */
   ATL_tvec_t *sp       /* source Tvec */
)
{
   ATL_tvec_t *tp;

   if (!sp)
      return;
   assert(dp);
   assert(dp->pre == sp->pre);
   assert(dp->nrep == sp->nrep);
   if (dp->pre == 's')
   {
      const int Nd = dp->N, Ns = sp->N, Nt = Nd+Ns;
      char **sd, **ss;
      int i;
      sd = malloc(Nt * sizeof(char *));
      for (ss=dp->vp, i=0; i < Nd; i++)
         sd[i] = ss[i];
      free(dp->vp);
      dp->vp = sd;
      dp->N = Nt;
      for (ss=sp->vp, i=0; i < Ns; i++)
         sd[i+Nd] = DupString(ss[i]);
   }
   else
   {
      const int Nd = dp->N, Ns = sp->N, Nt = Nd+Ns;
      int sz;
      char *cp;
      if (dp->pre == 'd')
         sz = sizeof(double);
      else
         sz = (dp->pre == 'i') ? sizeof(int) : sizeof(char);
      cp = malloc(Nt*sz);
      assert(cp);
      memcpy(cp, dp->vp, Nd*sz);
      free(dp->vp);
      dp->vp = cp;
      dp->N = Nt;
      memcpy(cp+Nd*sz, sp->vp, Ns*sz);
   }
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
@define tvr @ATL_tvec_t *ATL_ReverseTvecList(ATL_tvec_t *tb)@
@define tve @Reverse order in list tb@
ATL_tvec_t *ATL_ReverseTvecList  /* RETURNS: reversed list base */
(
   ATL_tvec_t *tb0              /* base of list to reverse */
)
{
   ATL_tvec_t *tb=NULL;
   while (tb0)
   {
      ATL_tvec_t *tp;
      tp = tb0;
      tb0 = tb0->next;
      tp->next = tb;
      tb = tp;
   }
   return(tb);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
@define tvr @ATL_tvec_t *ATL_DupNamedVecsFromList(int N, char** nm, tvec_t *tb, int order)@
@define tve @Returns dups of named vectors from tb; repeat names not duped!@
ATL_tvec_t *ATL_DupNamedVecsFromList  /* returns list of duped vecs */
(
   int N,               /* # of vectors to dup from list to */
   char **names,        /* names of vectors to duplicate */
   ATL_tvec_t *tb0,     /* original list unchanged */
   int order            /* 0: unordered, else: keep in same order as names */
)
{
   ATL_tvec_t *tb=NULL, *tp;
   int i;

   if (!tb0 || N < 1)
      return(NULL);

   for (i=0; i < N; i++)
   {
      tp = ATL_FindTvecByName(tb0, names[i]);
      assert(tp);
      tp = ATL_DupTvec(tp);
      tp->next = tb;
      tb = tp;
   }
   if (order)
      tb = ATL_ReverseTvecList(tb);
   return(tb);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
@define tvr @ATL_tvec_t *ATL_RemoveTvecFromList(ATL_tvec_t *bp, ATL_tvec_t *rp)@
@define tve @Returns new bp after removing rp from bp@
ATL_tvec_t *ATL_RemoveTvecFromList   /* RETURNS: possibly changed base */
(
   ATL_tvec_t *bp, 
   ATL_tvec_t *rp
)
{
   ATL_tvec_t *tp = bp, *prev;
   if (!bp)
      return(NULL);
   if (bp == rp)
      return(bp->next);

   prev=tp;
   for (tp=tp->next; tp; tp = tp->next)
   {
      if (tp == rp)
      {
         prev->next = tp->next;
         break;
      }
      prev = tp;
   }
   return(bp);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
@define tvr @ATL_tvec_t *ATL_PullNamedVecsFromListWithDups(int N, char **names, tvec_t bp)@
@define tve @Returns new list of all named tvecs, which are removed from bp@
ATL_tvec_t *ATL_PullNamedVecsFromListWithDups  /* returns list of pulled vecs */
(
   int N,               /* # of vectors to remove from list to */
   char **names,        /* names of vectors to grab */
   ATL_tvec_t **orig    /* original list has names removed */
)
/*
 * Note that the names will be returned in the provided order, with all
 * repeats of a given name contiguous in the list (so in name order, then
 * file order only within names).
 */
{
   ATL_tvec_t *ob=(*orig), *nb=NULL, *tp;
   int i;
   if (!ob || N < 1)
      return(NULL);
   for (i=0; i < N; i++)
   {
/*
 *    Remove all mentions of selected name, add to new list in reverse order
 */
      while ( (tp = ATL_FindTvecByName(ob, names[i])) )
      {
         ob = ATL_RemoveTvecFromList(ob, tp);
         tp->next = nb;
         nb = tp;
      }
   }
   *orig = ob;
   return(ATL_ReverseTvecList(nb));
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
@define tvr @ATL_tvec_t *ATL_PullNamedVecsFromList(int N, char **names, ATL_tvec_t bp)@
@define tve @Returns list of first instance of named tvecs, which are removed from bp@
ATL_tvec_t *ATL_PullNamedVecsFromList  /* returns list of pulled vecs */
(
   int N,               /* # of vectors to remove from list to */
   char **names,        /* names of vectors to grab */
   ATL_tvec_t **orig    /* original list has names removed */
)
/*
 * Note that the names will be returned in the provided order, and that
 * we assume a name only appears once in orig.
 */
{
   ATL_tvec_t *prev, *old=(*orig), *po, *pn, *nb=NULL;
   int i;
   if (!old || N < 1)
      return(NULL);
   for (i=0; i < N; i++)
   {
      prev = NULL;
      po = old;
      while (po)
      {
         if (!strcmp(names[i], po->name))
         {
            if (po == old)
               old = old->next;
            if (nb)
            {
               pn->next = po;
               pn = po;
            }
            else
               pn = nb = po;
            if (prev)
               prev->next = po->next;
            pn->next = NULL;
            break;
         }
         prev = po;
         po = po->next;
      }
   }
   *orig = old;
   return(nb);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
@define tvr @int ATL_CountTvecsInList(ATL_tvec_t *tb)@
@define tve @Returns number of tvecs in tb@
int ATL_CountTvecsInList
(
   ATL_tvec_t *tb      /* list to count */
)
{
   int i;
   for (i=0; tb; i++, tb = tb->next);
   return(i);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
@define tvr @ATL_tvec_t *ATL_FindLastTvecInList(ATL_tvec_t *tb)@
@define tve @Returns last tvec in list@
ATL_tvec_t *ATL_FindLastTvecInList  /* RETURNS: last Tvec in list */
(
   ATL_tvec_t *tb      /* list to look through */
)
{
   if (tb)
   {
      while (tb->next)
         tb = tb->next;
   }
   return(tb);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
@define tvr @ATL_tvec_t *ATL_AlphabetizeVecList(int N, ATL_tvec_t *tb)@
@define tve @Alphabatizes N-len tb, and returns new ordered list (old destroyed)@
ATL_tvec_t *ATL_AlphabetizeVecList  /* returns alphabatized list */
(
   int N,              /* # of vectors in list */
   ATL_tvec_t *tb      /* list to alphabetize */
)
/*
 * Alphabatizes N-len tb, and returns new ordered list (old is destroyed).
 */
{
   char **names;
   ATL_tvec_t *tp;
   int i, j;

   names = malloc(sizeof(char*)*N);
   assert(names);
   for (i=0; tp && i < N; i++, tp = tp->next)
      names[i] = tp->name;
   assert(i == N);
/*
 * Sort names using selection sort
 */
   for (j=0; j < N-1; j++)
   {
      for (i=j+1; i < N; i++)
      {
         if (strcmp(names[i], names[j]) < 0)
         {
            char *sp = names[j];
            names[j] = names[i];
            names[i] = sp;
         }
      }
   }
/*
 * Use sorted names to make new alphabetical list, free names and return list
 */
   tb = ATL_PullNamedVecsFromList(N, names, &tb);
   free(names);
   return(tb);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
@define tvr @void ATL_CopyStridedVec(char pre, int n, int inc, void *vin, void *vout)@
@define tve @copies every inc elts of vin to vout@
void ATL_CopyStridedVec(char pre, int n, int inc, void *vin, void *vout)
{
   if (pre == 'd')
   {
      int i, j;
      double *in = vin, *out = vout;
      for (j=i=0; i < n; i++, j += inc)
         out[i] = in[j];
   }
   else if (pre == 'i')
   {
      int i, j;
      int *in = vin, *out = vout;
      for (j=i=0; i < n; i++, j += inc)
         out[i] = in[j];
   }
   else if (pre == 'c')
   {
      int i, j;
      char *in = vin, *out = vout;
      for (j=i=0; i < n; i++, j += inc)
         out[i] = in[j];
   }
   else if (pre == 's')
   {
      int i, j;
      char **in = vin, **out = vout;
      for (j=i=0; i < n; i++, j += inc)
      {
         int n;
         n = strlen(in[i]) + 1;
         out[i] = malloc(n*sizeof(char));
         strcpy(out[i], in[j]);
      }
   }
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
@define tvr @void ATL_PrintTvecElt(FILE *fpout, ATL_tvec_t *tp, int idx)@
@define tve @Print element idx of tp->vp@
void ATL_PrintTvecElt
(
   FILE *fpout,         /* stream to print to */
   ATL_tvec_t *tp,      /* vector to print from */
   int idx              /* index in vector to print */
)
{
   if (tp->pre == 'd')
   {
      double *p = tp->vp;
      fprintf(fpout, "%e", p[idx]);
   }
   else if (tp->pre == 'i')
   {
      int *p = tp->vp;
      fprintf(fpout, "%12d", p[idx]);
   }
   else if (tp->pre == 'c')
   {
      char *p = tp->vp;
      fprintf(fpout, "%c", p[idx]);
   }
   else if (tp->pre == 's')
   {
      char **p = tp->vp;
      fprintf(fpout, "%s", p[idx]);
   }
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
@define tvr @void ATL_PrintTvecsInRow(FILE *fpout, ATL_tvec_t *tb, char *sep, int head)@
@define tve @Prints tb, 1 elt per line tvec cols seperated by sep@
void ATL_PrintTvecsInRow
(
   FILE *fpout,         /* stream to print to */
   ATL_tvec_t *tb,      /* list of vectors to print (rowwise) */
   char *sep,           /* string to print between elements */
   int head             /* should we print headers? */
)
{
   ATL_tvec_t *tp;
   const int N = tb->N;
   int i;

   if (!tb)
      return;
   for (tp=tb->next; tp; tp = tp->next)
      assert(tp->N >= N);

   if (head)
      for (tp=tb; tp; tp = tp->next)      /* loop over columns  */
         fprintf(fpout, "%12.12s%s", tp->name, sep);
   fprintf(fpout, "%s\n", sep);
   for (i=0; i < N; i++)                        /* loop over rows of vectors */
   {
      for (tp=tb; tp->next; tp = tp->next)      /* loop over columns  */
      {
         ATL_PrintTvecElt(fpout, tp, i);
         fprintf(fpout, "%s", sep);
      }
      ATL_PrintTvecElt(fpout, tp, i);
      fprintf(fpout, "%s\n", sep);
   }
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
@define tvr @ATL_tvec_t *ATL_GetRep1Tvec(ATL_tvec_t *tin, int istart)@
@define tve @Return new nrep=1 tvec wt only repitition istart represented@
ATL_tvec_t *ATL_GetRep1Tvec
(
   ATL_tvec_t *tin,    /* vector to split */
   int istart          /* which repetition to grab */
)
{
   char *name;
   ATL_tvec_t *t1=NULL;
   int n;
   const int Nr = tin->N / tin->nrep;
   const char pre = tin->pre;

   assert(tin->nrep < 10000000);
   n = strlen(tin->name) + 9;
   name = malloc(n*sizeof(char));
   assert(name);
   sprintf(name, "%s_%d", tin->name, istart);
   t1 = ATL_GetTvec(name, Nr, 1, pre);
   free(name);
   if (pre == 'd')
      ATL_CopyStridedVec(pre, Nr, tin->nrep,((double*)(tin->vp))+istart,t1->vp);
   else if (pre == 'i')
      ATL_CopyStridedVec(pre, Nr, tin->nrep, ((int*)(tin->vp))+istart, t1->vp);
   else if (pre == 'c')
      ATL_CopyStridedVec(pre, Nr, tin->nrep, ((char*)(tin->vp))+istart, t1->vp);
   else if (pre == 's')
      ATL_CopyStridedVec(pre, Nr, tin->nrep, ((char**)(tin->vp))+istart,t1->vp);

   return(t1);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
@define tvr @ATL_tvec_t *ATL_SplitRepsTvec(ATL_tvec_t *tin)@
@define tve @Returns list of seperate vecs for each rep (tin unchanged)@
ATL_tvec_t *ATL_SplitRepsTvec  /* returns Q of sep vecs for each rep */
(
   ATL_tvec_t *tin     /* vector to split */
)
{
   int i;
   const int nrep = tin->nrep;
   ATL_tvec_t *tb, *tp;

   tp = tb = ATL_GetRep1Tvec(tin, 0);
   for (i=1; i < nrep; i++)
   {
      tp->next = ATL_GetRep1Tvec(tin, i);
      tp = tp->next;
   }
   return(tb);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
@define tvr @ATL_tvec_t *ATL_GetStatTvecsDOUBLE(ATL_tvec_t *tin)@
@define tve @returns list of stat vectors: <,+,>@
ATL_tvec_t *ATL_GetStatTvecsDOUBLE  /* returns Q of stat vectors: <,+,> */
(
   ATL_tvec_t *tin     /* vector to get stats for */
)
{
   char *name;
   int i, j, n, N;
   ATL_tvec_t *tavg, *tmin, *tmax;
   double *dmin, *dmax, *davg;

   n = strlen(tin->name) + 5;
   name = malloc(sizeof(char)*n);
   assert(name);
   N = tin->N / tin->nrep;

   sprintf(name, "%s_min", tin->name);
   tmin = ATL_GetTvec(name, N, 1, tin->pre);
   sprintf(name, "%s_avg", tin->name);
   tavg = ATL_GetTvec(name, N, 1, tin->pre);
   sprintf(name, "%s_max", tin->name);
   tmax = ATL_GetTvec(name, N, 1, tin->pre);
   free(name);
   dmin = tmin->vp;
   dmax = tmax->vp;
   davg = tavg->vp;

   n = tin->nrep;
   for (j=0; j < N; j++)
   {
      double min, max, sum, *din;

      din = ((double*)(tin->vp)) + j*n;
      min = max = sum = *din;
      for (i=1; i < n; i++)
      {
         if (din[i] < min)
            min = din[i];
         if (din[i] > max)
            max = din[i];
         sum += din[i];
      }
      dmin[j] = min;
      dmax[j] = max;
      davg[j] = sum / n;
   }
   tmin->next = tavg;
   tavg->next = tmax;
   return(tmin);
}
/*
*******************************************************************************
*                   OVERVIEW OF FUNCTIONS IN THIS FILE                        *
*******************************************************************************
@whiledef tvr
* @(tvr)
*    @(tve)
   @undef tve
@endwhile
*******************************************************************************
*******************************************************************************
*/

#endif  /* end ifdef multi-inclusion guard */
