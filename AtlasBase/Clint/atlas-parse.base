@define ip @0@
@ROUT smvcases.idx dmvcases.idx cmvcases.idx zmvcases.idx
#
# In this file, any line beginning with a '#' is ignored, but the # must be in
# column 0.  All multiple whitespace is reduced to one space (i.e. used only
# to distinguish where words begin/end).  Lines may be extended by putting '\'
# as the *last* character of line.
#
# The file has the following format:
# ROUT='routine name' AUTH='author names' COMP='compiler name' FLAGS='flags'
# ID=<id> NU=<nu> MU=<mu> minN=<#> minM=<#> alignX=<#> alignY=<#> alignA=<#>,
# TA='[t,n,c]' TB='[t,n,c]' SSE=[0,1,2,3] X87=[0,1] 
# LDTOP=[0,1] ALLALIGNXY=[0,1] AXPYBASED=[0,1] GEMMBASED=[0,1] CONJDEF=[0,1]
# ASM=[asmlist], eg., asmlist is "GAS_x8664,GAS_x8632" or "GAS_SPARC"
# ASM defaults to no assembly dialect required.
# If NU/MU is negative, then the routine can only handle multiples of NU/MU.
#
# Assuming N is the length of X, and M is the length of Y, all routines
# are assumed to handle any runtime value of M >= minN, N >= minM.
# They must respect the compile-time macros BETA0, BETA1, & BETAX.
# Some less-obvious keywords:
# LDTOP     : set to 1 if load Y at top of MV loop (more error)
# CONJDEF   : Defining Conj_ will cause A to be conjugated before use
#             if 0, then can only be used for TA setting
# ALLALIGNXY: Create k copies of X and Y, where k is the number of times
#             the native alignment goes into the required alignment.  So,
#             if ALIGNX=16, and we are doing single precision, X will be
#             passed as float *X[4], and X[0] will be 16-byte aligned,
#             X[1]: 4-byte aligned, X[2]: 8-byte aligned, X[3]: 12 byte aligned
#             if ALIGN[X/Y] == native length, then this flag has no effect on
#             that vector.
# AXPYBASED : Routine employs the outer-product matvec (mainly for NoTrans)
# GEMMBASED : Kernel calls GEMM to do matvec
# PFTUNEx   : Kernel uses pref_x(mem) macro for each op=x (A,y,x).  prefetch
#             inst can be varied wt this macro, as can fetch distance.
#
@ROUT mmread
#ifndef ATLAS_MMPARSE_H
   #define ATLAS_MMPARSE_H

#include "atlas_genparse.h"
#include "atlas_enum.h"

#define MMF_LDCTOP      0  /* 1: load C before K-loop, 0: ld after */
#define MMF_X87         1  /* 1: requires the Intel x87 unit */
#define MMF_MRUNTIME    2  /* 1: M dim is run-time variable */
#define MMF_NRUNTIME    3  /* 1: M dim is run-time variable */
#define MMF_KRUNTIME    4  /* 1: M dim is run-time variable */
#define MMF_KUISKB      5  /* 1: KU == KB */
#define MMF_LDISKB      6  /* 1: lda=ldb=KB */
#define MMF_BETAN1      7  /* 1: kernel has special support for BETA = -1 */
#define MMF_LDAB        8  /* 1: lda = ldb */
#define MMF_AOUTER      9  /* 1: MNK loop order, 0: NMK loop order */
#define MMF_LDFLOAT    10  /* 1: use single prec load for double */
#define MMF_STFLOAT    11  /* 1: use single prec load for double */
#define MMF_PFACOLS    12  /* 1: prefetch next mu cols of A */
#define MMF_PFABLK     13  /* 1: prefetch next KBxNB block of A */
#define MMF_PFBCOLS    14  /* 1: prefetch next nu cols of B */
#define MMF_PFCELTS    15  /* 1: pf elts of C at top of loop, load at bottom */
#define MMF_SINGLE     16  /* 1: single precision, else double */
#define MMF_COMPLEX    17  /* 1: complex type, else real */
#define MMF_L14NB      18  /* 1: need to fit all 3 matrices+nextA in L1 */
#define MMF_JKMABC     19  /* 1: Jam-K major all arrays (access major) */
#define MMF_JKMAB      20  /* 1: Jam-K major A/B, column-major C */
#define MMF_BMAB       21  /* 1: block major A/B, col-maj C */
#define MMF_BMABC      22  /* 1: block major A/B/C */
#define MMF_MVA        23  /* 1: A expected to change between calls */
#define MMF_MVB        24  /* 1: B expected to change between calls */
#define MMF_MVC        25  /* 1: C expected to change between calls */
@skip #define MMF_KVECAM     23  /* 1: A/B are k-vlen-access-major, C access major */

#define MMF_MVSET  ( (1<<MMF_MVA) | (1<<MMF_MVB) | (1<<MMF_MVC) )
#define MMF_MVDEF  ( (1<<MMF_MVA) | (1<<MMF_MVB) )
#ifdef ATL_JKMDEF
   #define MMF_DEFAULT ( (1<<MMF_LDCTOP) | (1<<MMF_JKMABC) | (1<<MMF_AOUTER) | \
                         (1<<MMF_NRUNTIME) | (1<<MMF_MRUNTIME) | MMF_MVDEF )
#else
   #define MMF_DEFAULT ( (1<<MMF_LDISKB) | (1<<MMF_LDAB) | MMF_MVDEF )
#endif
#ifndef  FLAG_IS_SET
   #define FLAG_IS_SET(field_, bit_) ( ((field_) & (1<<(bit_))) != 0 )
#endif
#define ATL_MMF_MVGET(field_) (((field_) >> MMF_MVA) & 7)
#define ATL_MMF_MVPUT(field_, v_) \
   (field_) = ( ((field_) & ~MMF_MVSET) | (((v_) & 7) << MMF_MVA) )

typedef struct MMNode ATL_mmnode_t;
struct MMNode
{
   double mflop[8];     /* 1st entry perf using mbB, nbB, kbB */
   int ID, mu, nu, ku;  /* ID, and unrolling on each loop */
   int kbmin, kbmax;    /* min/max KB this kernel can handle */
   int SSE;             /* 0: no SSE, 1: SSE1 req, 2: SSE2 req, etc */
   int lat, muladd, pref, clean, fftch, iftch, nftch; /* used for gened codes */
   int vlen;            /* vector length, 0 or 1 if scalar code */
   int kmaj;            /* k-major access storage? */
   int mbB, nbB, kbB;  /* best blocking dims found by search */
   enum ATLAS_TRANS TA, TB;
   int asmbits;   /* bitfield indicating which assembly(ies) is required */
   char *rout, *auth, *comp, *cflags;
   char *str;                   /* tmp string used in generation */
   char *genstr;                /* system(genstr) will generate gened kernel */
   char *exflags;               /* extra flags to pass test/time call */
   char *moves;                 /* -DMove[A,B,C] to use, NULL default */
   int *tids;                   /* -tl <nt> <t1> <t2> ... <tn>, NULL default */
   unsigned int flag;
   ATL_mmnode_t *next;
};

@ROUT r1read
#ifndef ATLAS_R1PARSE_H
   #define ATLAS_R1PARSE_H

#include "atlas_genparse.h"


#define R1F_INCACHE     0  /* consider kernel for in-cache gemv */
#define R1F_OUTCACHE    1  /* consider kernel for out-of-cache gemv */
#define R1F_ALLALIGNXY  2  /* X&Y are copied into all legal alignments */
#define R1F_ALIGNX2A    3  /* X forced to same alignment as A */
#define R1F_SINGLE      4  /* single precision */
#define R1F_COMPLEX     5  /* complex arithmetic */
#define R1F_APTRS       6  /* use ptrs rather than lda for column indexing */
#define R1F_X87         7  /* requires the Intel x87 unit */
#define R1F_FNU         8  /* N must be a multiple of NU */
#define R1F_ADDCFLAGS   9  /* don't replace: append cflags to default flags */
#define R1F_INCYISONE  10
#define R1F_NFLAGS     11
#define R1F_PFTUNABLE  14  /* Can tune PFDIST & INST? */
char *R1F_exp[R1F_NFLAGS] = 
{
"Consider kernel for in-cache use only",
"Consider kernel for out-of-cache use only",
"X&Y are copied into all legal alignments",
"X forced to have same alignment as A",
"Data uses single precision",
"Data is of complex type",
"use ptrs rather than lda for column indexing",
"Kernel requires the x87 unit for correct operation",
"N must be a multiple of NU"
};

#define R1F_DEFAULT ((1<<R1F_INCACHE) | (1<<R1F_OUTCACHE))
typedef struct R1NODE ATL_r1node_t;
struct R1NODE
{
   double mflop[8];
   ATL_r1node_t *next;
   char *rout;                  /* filename/path for kernel */
   char *auth;                  /* author of kernel */
   char *comp;                  /* particular compiler required for kernel */
   char *cflags;                /* compiler flags required for kernel */
   char *kname;                 /* The name kernel should be compiled to */
   char *str;                   /* tmp string used in generation */
   char *exflags;               /* extra flags to pass test/time call */
   char *genstr;                /* system(genstr) will generate gened kernel */
   int alignA, alignX, alignY;  /* required alignments */
   int ldamul;                  /* lda must be a multiple of ldamul */
   int ID, NU, MU;              /* unrolling for Y & X vectors */
   int NMU;                     /* # of repetitions of MU */
   int minN, minM;              /* min veclen to call the rout with */
   int SSE;                     /* 0: no SSE, 1: SSE1 req, 2: SSE2 req, etc */
   int asmbits;                 /* valid assemblies in this file */
   int CacheElts;               /* # of cache elts to assume for blocking */
   int rankR;                   /* restriction rank, higher faster kern */
   int flag;                    /* bit vector of R1F_* */
};

@ROUT mvread
#ifndef ATLAS_MVPARSE_H
   #define ATLAS_MVPARSE_H

#include "atlas_genparse.h"
#include "atlas_enum.h"

#define MVF_INCACHE     0  /* consider kernel for in-cache gemv */
#define MVF_OUTCACHE    1  /* consider kernel for out-of-cache gemv */
#define MVF_ALLALIGNXY  2  /* X&Y are copied into all legal alignments */
#define MVF_AXPYBASED   3  /* 0:ddot based, 1: axpy-based */
#define MVF_GEMMBASED   4  /* gemm-based */
#define MVF_LDYTOP      5  /* 0: load Y value after dot product */
#define MVF_CONJDEF     6  /* 1: conj(A) if Conj_ is defined */
#define MVF_X87         7  /* requires the Intel x87 unit */
#define MVF_FNU         8  /* Length of Y must be a multiple of NU */
#define MVF_SINGLE      9  /* 1: single precision, else double */
#define MVF_COMPLEX    10  /* 1: complex type, else real */
#define MVF_ADDCFLAGS  11  /* don't replace: append cflags to default flags */
#define MVF_ALIGNX2A   12  /* X (Y if AXPYBASED) forced to same alignmnt as A */
#define MVF_INCYISONE  13
#define MVF_PFTUNABLE  14  /* Can tune PFDIST & INST? */

#define MVF_DEFAULT ((1<<MVF_INCACHE) | (1<<MVF_OUTCACHE))
typedef struct MVNODE ATL_mvnode_t;
struct MVNODE
{
   double mflop[8];
   ATL_mvnode_t *next;
   char *rout, *auth, *comp, *cflags;
   char *kname;                 /* The name kernel should be compiled to */
   char *str;                   /* tmp string used in generation */
   char *genstr;                /* system(genstr) will generate gened kernel */
   char *exflags;               /* extra flags to pass test/time call */
   int alignA, alignX, alignY;  /* required alignments */
   int ldamul;                  /* lda must be a multiple of ldamul */
   int ID, NU, MU;              /* unrolling for Y & X vectors */
   int minN, minM;              /* min veclen to call the rout with */
   int CacheElts;               /* # of cache elts to assume for blocking */
   int SSE;                     /* 0: no SSE, 1: SSE1 req, 2: SSE2 req, etc */
   int asmbits;                 /* valid assemblies in this file */
   int rankR;                   /* restriction rank, higher faster kern */
   int ntlb;                    /* for dot-based alg, col blocking for TLB */
   enum ATLAS_TRANS TA;         /* transpose setting */
   int flag;                    /* bit vector of MVF_* */
};

@ROUT genparse
#ifndef ATLAS_GENPARSE_H
   #define ATLAS_GENPARSE_H

#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <string.h>
#include <ctype.h>
@extract -b @(basd)/atlconf.base rout=asmconf.h
/*
 * Basic data structure for forming queues with some minimal info
 */
typedef struct SIDNode ATL_sidnode_t;
struct SIDNode  /* holds string, integer, and double */
{
   double d;
   char *str;
   int i;
   ATL_sidnode_t *next;
};

#define SET_FLAG(bits_, flg_, val_) \
{\
   if (val_) (bits_) |= (1<<(flg_)); \
   else (bits_) &= ~(1<<(flg_)); \
}
#define FLAG_IS_SET(field_, bit_) ( ((field_) & (1<<(bit_))) != 0 )

@iexp ip @(ip) 1 +
/* procedure @(ip) : allocates ATL_sidnode_t */
static ATL_sidnode_t *ATL_NewSIDNode(void)
{
   ATL_sidnode_t *sp;
   sp = calloc(1, sizeof(ATL_sidnode_t));
   assert(sp);
   return(sp);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) : allocates ATL_sidnode_t */
static ATL_sidnode_t *ATL_FreeSIDNode(ATL_sidnode_t *die)
{
   ATL_sidnode_t *sp=NULL;
   if (die)
   {
      sp = die->next;
      if (die->str)
         free(die->str);
      free(die);
   }
   return(sp);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static int GetL1CacheElts(char pre)
{
   FILE *L1f;
   int L1Size, i;

   L1f = fopen("res/L1CacheSize", "r");
   if (!L1f)
   {
      assert(system("make res/L1CacheSize\n") == 0);
      L1f = fopen("res/L1CacheSize", "r");
   }
   assert(L1f);
   assert(fscanf(L1f, "%d", &L1Size) == 1);
   fclose(L1f);
   assert(L1Size > 0);
   if (pre == 'c' || pre == 'd')
      i = 1024/8;
   else if (pre == 's')
      i = 1024/4;
   else if (pre == 'z')
      i = 1024/16;
   else
      assert(0);
   return(i*L1Size);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static char *ExtendString(char *str, int len)
/*
 * Given already-allocated str, allocate a new string of total length len,
 * copy str to it (strlen(str)<= len)
 */
{
   char *sp;
   sp = realloc(str, len);
   assert(sp);
   return(sp);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static char *GetStrForSprintf
(
   char *form,  /* format string that will be passed to printf */
   int extra,   /* extra chars over format length to allocate */
   char *old    /* original ptr to pass to realloc */
)
{
   old = realloc(old, strlen(form)+extra);
   assert(old);
   return(old);
}
@iexp ip @(ip) 1 +
/* procedure @(ip) */
static int NumDecDigits(int num)
/*
 * RETURNS: number of decimal digits required to hold num, wt sign of neg #s
 *          counted as a digit
 */
{
   int bound, nd;
   if (num < 0)
   {
      nd = 2;
      num = -num;
   }
   else
      nd = 1;
   for (bound=9; num > bound; nd++)
      bound = bound*10 + 9;
   return(nd);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static char *DupString(char *str)
{
   int i,n;
   char *s;

   if (!str)
      return(NULL);
   n = strlen(str)+1;
   s = malloc(sizeof(char)*n);
   assert(s);
   for (i=0; i < n; i++)
      s[i] = str[i];
   return(s);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static char *NewMergedString(char *st0, char *st1)
/*
 * RETURNS: new string with st1 concatonated to st0
 */
{
   int i, n0, n1;
   char *s;

   if (!st0)
   {
      if (!st1)
         return(NULL);
      else 
         return(DupString(st1));
   }
   n0 = strlen(st0);
   n1 = strlen(st1) + 1;
   s = malloc(sizeof(char)*(n0+n1));
   assert(s);
   for (i=0; i < n0; i++)
      s[i] = st0[i];
   s += n0;
   for (i=0; i < n1; i++)
      s[i] = st1[i];
   return(s-n0);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static char *GetSingleQuoteString(char *str)
{
   char *sp;
   int i, n;

   assert(str[0] == '\'');
   for (i=1; str[i] && str[i] != '\''; i++);
   assert(str[i]);
   sp = malloc(i*sizeof(char));
   for (n=i,i=1; i < n; i++)
      sp[i-1] = str[i];
   sp[n-1] = '\0';
   return(sp);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static int asmNames2bitfield(char *str)
/*
 * Takes str containing an assembly name list.  The list is ended by the first
 * white space or end of string.  List items are seperated by ',', and there
 * can be no whitespace in list.
 * RETURNS: bitfield with bits set corresponding to assemblies, 0 on error.
 */
{
   char asmname[64];
   int i, KeepOn, bits=0;

   do
   {
      for (i=0; !isspace(str[i]) && str[i] != ',' && str[i] && i < 64; i++)
         asmname[i] = str[i];
      asmname[i] = '\0';
      KeepOn = str[i] == ',';
      str += i+1;
      if (i >= 64)
         return(0);  /* no asm name > 63 in length */
      for (i=0; i < NASMD; i++)
      {
         if (!strcmp(ASMNAM[i], asmname))
         {
            bits |= (1<<i);
            break;
         }
      }
   }
   while(KeepOn);
   return(bits);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static int GetDoubleArr(char *str, int N, double *d)
/*
 * Reads in a list with form "%le,%le...,%le"; N-length d recieves doubles.
 * RETURNS: the number of doubles found, or N, whichever is less
 */
{
   int i=1;
   assert(sscanf(str, "%le", d) == 1);
   while (i < N)
   {
      str = strstr(str, ",");
      if (!str)
         break;
      str++;
      assert(sscanf(str, "%le", d+i) == 1);
      i++;
   }
   return(i);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static char *GetLongerString(char *shrt, int newlen)
/*
 * Allocates new string of size newlen, copies shrt into it, and frees shrt.
 */
{
   char *sp;

   sp = malloc(sizeof(char)*newlen);
   assert(sp);
   if (shrt)
   {
      strcpy(sp, shrt);
      free(shrt);
   }
   else if (newlen >= 0)
      sp[0] = '\0';
   return(sp);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static char *GetOneLine(FILE *fpin)
/*
 * RETURNS: string of one line from stream fpin,  NULL if stream exhausted.
 */
{
   const int inc=256;
   static int len=0;
   static char *ln, *sp;
   int i, j, KeepOn;

   if (!len)
   {
      ln = malloc(inc*sizeof(char));
      assert(ln);
      len = inc;
   }
   if (!fgets(ln, len, fpin))
      return(NULL);

   for (i=0; ln[i]; i++);  /* find end of string */
   if (!i) return(ln);
   while (ln[i-1] != '\n')    /* if last char not \n, read rest of line */
   {
      len += inc;
      ln = GetLongerString(ln, len);
      if (!fgets(ln+i, inc, fpin))
         return(ln);
       for (; ln[i]; i++);  /* find end of string */
   }
   return(ln);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static char *GetJoinedLines(FILE *fpin)
/*
 * Gets lines from file fpin; if last non-whitespace char is '\', joins lines
 * RETURNS: line from file including joining, NULL if fpin exhausted
 */
{
   char *ln, *sp;
   static char *join=NULL;
   static int jlen=0;
   int i, j, k;

   sp = ln = GetOneLine(fpin);
   if (!sp)
      return(NULL);
   j = 0;   /* current length of join string */
   if (ln)
   {
      for (i=0; ln[i]; i++);  /* find end of string */
      if (!i) return(NULL);
      for (i--; isspace(ln[i]) && i > 0; i--);  /* find last non-wspace char */
      while (ln[i] == '\\')
      {
         if (jlen < j+i+3)
         {
            jlen = j+i+i+3;
            join = GetLongerString(join, jlen);
         }
         for (k=0; k < i; k++)
            join[j+k] = ln[k];
         j += k;
         join[j++] = ' ';
         join[j] = '\0';
         ln = GetOneLine(fpin);   /* get new line that should be joined */
         assert(ln);              /* can't end file with continue */
         for (i=0; ln[i]; i++);   /* find end of new line */
         for (i--; isspace(ln[i]) && i > 0; i--); /* find last non-wspc char */
         sp = join;
      }
      if (sp == join)
      {
         if (jlen < j+i+3)
         {
            jlen = j+i+i+3;
            join = GetLongerString(join, jlen);
         }
         for (k=0; k <= i; k++)
            join[j+k] = ln[k];
         j += k;
         join[j] = '\n';
         join[j+1] = '\0';
         sp = join;
      }
   }
   return(sp);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static char *GetGoodGcc()
/*
 * Gets gcc path and name along with mandatory flags (-g/-m64/-pg,etc) by
 * querying Make.inc setting
 */
{
   static char gcc[2048];
   static int INIT=0;
   if (!INIT)
   {
      FILE *fpin;
      assert(system("make res/goodgcc.txt > /dev/null 2>&1") == 0);
      fpin = fopen("res/goodgcc.txt", "r");
      assert(fpin);
      assert(fscanf(fpin, "'%[^\']", gcc) == 1);
      fclose(fpin);
   }
   return(gcc);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static char *GetKCFlags(char pre)
/*
 * Gets flags being used for <pre>KCFLAGS
 */
{
   char ln[4096];
   FILE *fpin;
   int i;

   if (pre == 'z')
      pre = 'd';
   else if (pre == 'c')
      pre = 's';
   i = system("rm -f res/kcflags.txt");
   sprintf(ln, "grep \"%cKCFLAGS = \" Make.inc | sed s/%cKCFLAGS\\ =\\ // > res/kcflags.txt", toupper(pre), toupper(pre));
   assert(system(ln) == 0);
   fpin = fopen("res/kcflags.txt", "r");
   assert(fpin);
   assert(fgets(ln, 4096, fpin) != NULL);
   fclose(fpin);
/*
 * Get rid of trailing and leading whitespaces
 */
   for (i=0; ln[i]; i++);
   for (i--; isspace(ln[i]); i--);
   ln[i+1] = '\0';
   for (i=0; isspace(ln[i]); i++);
   return(DupString(ln+i));
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static int *GF_GetIntList1(int ival)
/*
 * returns integer array with iarr[0] = 1, iarr[1] = ival
 */
{
   int *iarr;
   iarr = malloc(2*sizeof(int));
   assert(iarr);
   iarr[0] = 1;
   iarr[1] = ival;
   return(iarr);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static int *GF_GetIntList2(int ival1, int ival2)
/*
 * returns integer array with iarr[0] = 1, iarr[1] = ival1, ival[2] = ival2
 */
{
   int *iarr;
   iarr = malloc(3*sizeof(int));
   assert(iarr);
   iarr[0] = 2;
   iarr[1] = ival1;
   iarr[2] = ival2;
   return(iarr);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static int *GF_DupIntList(int *L)
/*
 * dups a list of integers L, whose data length is given by L[0];
 * list is this length+1, since 0'th location gets data length.
 */
{
   int *ip, n;
   if (!L)
      return(NULL);
   n = L[0] + 1;
   ip = malloc(n*sizeof(int));
   assert(ip);
   memcpy(ip, L, n*sizeof(int));
   return(ip);
}
#ifdef ATL_GETFLAGS
@iexp ip @(ip) 1 +
/* procedure @(ip) */
static double *GF_GetNDoubleArgs(int nargs, char **args, int i, int n)
/*
 * Reads in n doubles from commandline args to produce n-len double array.
 */
{
   int k;
   double *darr;
   void PrintUsage(char*, int, char*);

   if (n < 1)
      return(NULL);
   darr = malloc(sizeof(double)*n);
   assert(darr);

   for (k=0; k < n; k++)
   {
      if (++i >= nargs)
         PrintUsage(args[0], i, NULL);
      darr[k] = atof(args[i]);
   }
   return(darr);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static double *GF_GetDoubleList(int nargs, char **args, int i, int nmul)
/*
 * Gets a list of doubles, whose length is given by atoi(args[i])*nmul
 * list is this length+1, since 0'th location gets atoi(args[i])
 */
{
   int n, k;
   double *darr;
   void PrintUsage(char*, int, char*);

   if (++i >= nargs)
      PrintUsage(args[0], i, NULL);
   n = atoi(args[i]) * nmul;
   assert(n > 0);
   darr = malloc(sizeof(double)*(n+1));
   assert(darr);

   darr[0] = n / nmul;
   for (k=0; k < n; k++)
   {
      if (++i >= nargs)
         PrintUsage(args[0], i, NULL);
      darr[k+1] = atof(args[i]);
   }
   return(darr);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static int *GF_GetIntList(int nargs, char **args, int i, int nmul)
/*
 * Gets a list of integers, whose length is given by atoi(args[i])*nmul
 * list is this length+1, since 0'th location gets atoi(args[i])
 */
{
   int n, *iarr, k;
   void PrintUsage(char*, int, char*);

   if (++i >= nargs)
      PrintUsage(args[0], i, NULL);
   n = atoi(args[i]) * nmul;
   assert(n > 0);
   iarr = malloc(sizeof(int)*(n+1));
   assert(iarr);

   iarr[0] = n / nmul;
   for (k=0; k < n; k++)
   {
      if (++i >= nargs)
         PrintUsage(args[0], i, NULL);
      iarr[k+1] = atoi(args[i]);
   }
   return(iarr);
}
#endif

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static int *GF_IntRange2IntList(int N0, int NN, int incN)
{
   int i, n;
   int *iarr;

   for (i=N0, n=0; i <= NN; i += incN) n++;
   iarr = malloc(sizeof(int)*(n+1));
   assert(iarr);
   iarr[0] = n;
   for (i=N0, n=1 ; i <= NN; i += incN, n++)
      iarr[n] = i;
   return(iarr);
}
#endif /* end atlas_genparse.h guard */
@ROUT mmread
#ifndef ATL_DEF_MMFLAG
   #define ATL_DEF_MMFLAG @up@(rt)F_DEFAULT
#endif
   @define rt @mm@
@ROUT mvread
   @define rt @mv@
@ROUT r1read
   @define rt @r1@
@ROUT r1read mvread mmread
@iexp ip @(ip) 1 +
/* procedure @(ip) */
static ATL_@(rt)node_t *Get@up@(rt)Node(void)
{
   ATL_@(rt)node_t *p;
   p = calloc(1, sizeof(ATL_@(rt)node_t));
   assert(p);
@ROUT mvread `   p->TA = AtlasNoTrans;`
@ROUT mmread `   p->TA = AtlasTrans; p->TB = AtlasNoTrans;`
   p->flag = @up@(rt)F_DEFAULT;
   return(p);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static ATL_@(rt)node_t *Clone@up@(rt)Node(ATL_@(rt)node_t *dup)
{
   ATL_@(rt)node_t *p;
   p = malloc(sizeof(ATL_@(rt)node_t));
   assert(p);
   memcpy(p, dup, sizeof(ATL_@(rt)node_t));
   if (dup->rout)
      p->rout = DupString(dup->rout);
   if (dup->auth)
      p->auth = DupString(dup->auth);
   if (dup->comp)
      p->comp = DupString(dup->comp);
   if (dup->cflags)
      p->cflags = DupString(dup->cflags);
   if (dup->str)
      p->str = DupString(dup->str);
   if (dup->genstr)
      p->genstr = DupString(dup->genstr);
   if (dup->exflags)
      p->exflags = DupString(dup->exflags);
@ROUT mmread
   if (dup->moves)
      p->moves = DupString(dup->moves);
@ROUT r1read mvread
   if (dup->kname)
      p->kname = DupString(dup->kname);
@ROUT r1read mvread mmread
   p->next = NULL;
   return(p);
}

@iexp ip @(ip) 1 +
/* procedure @(ip): clones a queue of @up@(rt) structs */
static ATL_@(rt)node_t *Clone@up@(rt)Queue(ATL_@(rt)node_t *dupb)
{
   ATL_@(rt)node_t *p, *pd, *nb;
   if (!dupb)
      return(NULL);
   p = nb = Clone@up@(rt)Node(dupb);
   for (pd=dupb->next; pd; pd = pd->next)
   {
      p->next = Clone@up@(rt)Node(pd);
      p = p->next;
   }
   return(nb);
}

@iexp ip @(ip) 1 +
/* procedure @(ip): clones a queue of strided @up@(rt) structs */
static ATL_@(rt)node_t *CloneStrided@up@(rt)Queue
(
   ATL_@(rt)node_t *dupb,   /* queue of nodes to clone */
   int stride               /* increment between nodes to take */
)
/*
 * Creates a queue of cloned nodes from dupb; move stride each time
 * (stride must be >= 1); i.e. skip stride-1 structs in original queue
 */
{
   ATL_@(rt)node_t *p, *pd, *nb;
   int i;

   if (!dupb)
      return(NULL);
   if (stride == 1)
      return(Clone@up@(rt)Queue(dupb));
   assert(stride > 1);
   p = nb = Clone@up@(rt)Node(dupb);
   pd = nb;
   while(pd)
   {
      for (i=0; i < stride && pd; i++, pd = pd->next);
      if (pd)
      {
         p->next = Clone@up@(rt)Node(pd);
         p = p->next;
      }
      else
         p->next = NULL;
   }
   return(nb);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static ATL_@(rt)node_t *Kill@up@(rt)Node(ATL_@(rt)node_t *die)
{
   ATL_@(rt)node_t *p=NULL;
   if (die)
   {
      p = die->next;
      if (die->rout)
         free(die->rout);
      if (die->auth)
         free(die->auth);
      if (die->comp)
         free(die->comp);
      if (die->cflags)
         free(die->cflags);
      if (die->str)
         free(die->str);
      if (die->genstr)
         free(die->genstr);
      if (die->exflags)
         free(die->exflags);
@ROUT mmread
      if (die->moves)
         free(die->moves);
@ROUT r1read mvread
      if (die->kname)
         free(die->kname);
@ROUT r1read mvread mmread
      free(die);
   }
   return(p);
}

@iexp ip @(ip) 1 +
/* procedure @(ip): safely remove nukeme from Q, reseting all links */
static ATL_@(rt)node_t *Remove@up@(rt)NodeFromQ
(
   ATL_@(rt)node_t *Q,     /* queue of nodes */
   ATL_@(rt)node_t *nukeme /* node to remove from queue */
)
/*
 * Removes nukeme from Q, sets nukeme->next=NULL, and returns updated Q
 */
{
   ATL_@(rt)node_t *p, *prev;

   if (!nukeme)
      return(Q);
   assert(Q);
   if (Q == nukeme)
   {
      Q = Q->next;
      nukeme->next = NULL;
      return(Q);
   }
   prev = Q;
   for (p=Q->next; p && p != nukeme; p = p->next)
      prev = p;
   assert(p);
   prev->next = nukeme->next;
   nukeme->next = NULL;
   return(Q);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static ATL_@(rt)node_t *Kill@up@(rt)NodeFromQ
(
   ATL_@(rt)node_t *Q,     /* queue of nodes */
   ATL_@(rt)node_t *nukeme /* node to remove from queue */
)
{
   Q = Remove@up@(rt)NodeFromQ(Q, nukeme);
   Kill@up@(rt)Node(nukeme);
   return(Q);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static void KillAll@up@(rt)Nodes(ATL_@(rt)node_t *die)
{
   while (die)
      die = Kill@up@(rt)Node(die);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static void ATL_SubGoodGccIn@up@(rt)Nodes
(
   ATL_@(rt)node_t *bp   /* queue to make sub in */
)
/*
 *  Gets GOODGCC (from Make.inc), and substitutes it for all comp == "gcc"
 *  in the queue.  This gets us mandatory flags like -pg,-m64,etc.
 */
{
   ATL_@(rt)node_t *kp;  /* queue to make sub in */
   char *gcc;
   gcc = GetGoodGcc();
   for (kp=bp; kp; kp = kp->next)
   {
      if (kp->comp && !strcmp(kp->comp, "gcc"))
      {
         free(kp->comp);
	 kp->comp = DupString(gcc);
      }
   }
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static void ATL_UnsubGoodGccIn@up@(rt)Nodes
(
   ATL_@(rt)node_t *bp   /* queue to make reverse sub in */
)
/*
 *  Gets GOODGCC (from Make.inc); Any comp string matching that is switched
 *  back to "gcc".  This is usually necessary so that output files don't
 *  use an old GOODGCC that lacks something like -pg.
 */
{
   ATL_@(rt)node_t *kp;  /* queue to make sub in */
   char *gcc;
   gcc = GetGoodGcc();
   for (kp=bp; kp; kp = kp->next)
   {
      if (kp->comp && !strcmp(kp->comp, gcc))
      {
         free(kp->comp);
	 kp->comp = DupString("gcc");
      }
   }
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static void ResubGoodGccIn@up@(rt)Nodes
(
   ATL_@(rt)node_t *bp   /* queue to make sub in */
)
/*
 * Takes gcc compiler that use GOODGCC, and replaces them with "gcc"
 * to help portability
 */
{
   ATL_@(rt)node_t *kp;  /* queue to make sub in */
   char *gcc;
   gcc = GetGoodGcc();
   for (kp=bp; kp; kp = kp->next)
   {
      if (kp->comp && !strcmp(kp->comp, gcc))
      {
         free(kp->comp);
	 kp->comp = DupString("gcc");
      }
   }
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static int ATL_CountNumberOf@up@(rt)Nodes
(
    ATL_@(rt)node_t *bp   /* queue to count */
)
{
   int i;
   for (i=0; bp; i++, bp = bp->next);
   return(i);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static ATL_@(rt)node_t *ATL_Last@up@(rt)Node(ATL_@(rt)node_t *bp)
/*
 * RETURNS: pointer to last node in queue
 */
{
   ATL_@(rt)node_t *p;
   if (!bp)
      return(NULL);
   for (p=bp; p->next; p = p->next);
   return(p);
}

/* procedure @(ip): finds node with max mflop[imf]  */
static ATL_@(rt)node_t *FindMaxMflop@up@(rt)Q
(
   ATL_@(rt)node_t *bp,   /* queue to be searched */
   int imf
)
/*
 * RETURNS: ptr to structure containing max value in mflop[imf]
 */
{
   ATL_@(rt)node_t *mp, *p;
   double mfm;
   if (!bp)
      return(NULL);
   mp = bp;
   mfm = mp->mflop[imf];
   for (p=bp->next; p; p = p->next)
   {
      const double mf=p->mflop[0];
      if (mf > mfm)
      {
         mfm = mf;
         mp = p;
      }
   }
   return(mp);
}
@multidef cmp < >
@whiledef op Min Max
   @iexp ip @(ip) 1 +
/* procedure @(ip): finds @low@(op) integer at ip0 in struct */
static ATL_@(rt)node_t *Find@(op)IntIn@up@(rt)Q
(
   ATL_@(rt)node_t *bp,   /* queue to be searched */
   void *ip0           /* ptr to integer withinin node bp */
)
/*
 * RETURNS: ptr to structure containing @low@(op) int value at byte offset 
 *          offset in struct
 */
{
   ATL_@(rt)node_t *mp=NULL, *p;
   int *ip;
   int val;
   const int offset = (int)((char*)((char*) ip0) - ((char*)bp));

   if (!bp)
      return(NULL);
   
   mp = bp;
   ip = (int*)(((char*)bp) + offset);
   val = *ip;
   for (p=bp->next; p; p = p->next)
   {
      ip = (int*)(((char*)p) + offset);
      if (*ip @(cmp) val)
      {
         mp = p;
         val = *ip;
      }
   }
   return(mp);
}
   @undef cmp
@endwhile

@iexp ip @(ip) 1 +
/* procedure @(ip): finds first integer equal to val at ip0 in struct */
static ATL_@(rt)node_t *FindIntValIn@up@(rt)Q
(
   ATL_@(rt)node_t *bp,   /* queue to be searched */
   void *ip0,          /* ptr to integer withinin node bp */
   int val             /* value being searched for */
)
/*
 * RETURNS: ptr to first structure containing value val at byte offset 
 *          offset in struct, or NULL if no such value found
 */
{
   ATL_@(rt)node_t *mp=NULL, *p;
   int *ip;
   const int offset = (int)((char*)((char*) ip0) - ((char*)bp));

   if (!bp)
      return(NULL);
   
   for (p=bp; p; p = p->next)
   {
      ip = (int*)(((char*)p) + offset);
      if (*ip == val)
         return(p);
   }
   return(NULL);
}

@iexp ip @(ip) 1 +
/* procedure @(ip): sorts Q from least-to-greatest on int val at ip0 in struc */
static ATL_@(rt)node_t *Sort@up@(rt)QByIntVal
(
   ATL_@(rt)node_t *bp,   /* queue to be sorted */
   void *ip0           /* ptr to integer withinin node bp to sort on*/
)
/*
 * RETURNS: possibly new queue base, sorted from least-to-greatest on int at ip0
 */
{
   ATL_@(rt)node_t *sb=NULL, *p;
   int *ip;
   const int offset = (int)((char*)((char*) ip0) - ((char*)bp));

   if (!bp)
      return(NULL);
   
   while(bp)
   {
      ip = (int*)(((char*)bp) + offset);
      p = FindMaxIntIn@up@(rt)Q(bp, ip);
      bp = Remove@up@(rt)NodeFromQ(bp, p);
      p->next = sb;
      sb = p;
   }
   return(sb);
}

@iexp ip @(ip) 1 +
/* procedure @(ip): reverses order in Q */
static ATL_@(rt)node_t *Reverse@up@(rt)Q(ATL_@(rt)node_t *bp)
/*
 * RETURNS: new base ptr of reversed queue
 */
{
   ATL_@(rt)node_t *nb=NULL, *p;
   while(bp)
   {
      p = bp;
      bp = bp->next;
      p->next = nb;
      nb = p;
   }
   return(nb);
}

@iexp ip @(ip) 1 +
/* procedure @(ip): places all nodes wt int value val at ip0 in new queue */
static ATL_@(rt)node_t *Yank@up@(rt)NodesByIntVal
(
   ATL_@(rt)node_t **bp0,  /* queue to be searched */
   void *ip0,          /* ptr to integer withinin node *bp */
   int val             /* value to be yanked out of original Q */
)
/*
 * Finds all nodes that have the integeral value val stored in position
 * ip0-bp0 in nodes.  These nodes are removed from bp0, and placed in
 * their own queue, which is returned.  bp0 is modified in the process.
 * RETURNS: ptr to queue of nodes wt integer value val
 */
{
   ATL_@(rt)node_t *bp=(*bp0), *p, *valb=NULL, *vp;
   int *ip;
   const int offset = (int)((char*)((char*) ip0) - ((char*)bp));

   while(bp)
   {
      p = FindIntValIn@up@(rt)Q(bp, (((char*)bp)+offset), val);  /* find node */
      if (!p)       /* if there are no more in bp, we are done */
         break;
      bp = Remove@up@(rt)NodeFromQ(bp, p);   /* remove it from original queue */
/*
 *    Add node at front of new value-only queue 
 */
      if (valb)
      {
         vp->next = p;
         vp = p;
      }
      else
         vp = valb = p;
   }
   *bp0 = bp;
   return(valb);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static ATL_@(rt)node_t *ATL_Sort@up@(rt)NodesByMflop
(
   int imf,            /* which mflop entry to sort on */
   ATL_@(rt)node_t *bp    /* queue to be sorted */
)
/* 
 * kills original queue, and returns a greatest-to-least sorted queue
 * on p->mflop[imf].  Does it with O(N^2) alg, but if this is a bottleneck,
 * we never get here because timing takes an eternity.
 */
{
   ATL_@(rt)node_t *p, *prev, *sb=NULL;   /* ptr, prev, sorted base */
   ATL_@(rt)node_t *minp, *minprev;
   double mf;

/*
 * Sort from greatest-to-least by always adding smallest entry in old
 * list to head of greatest-to-least list
 */
   while (bp)
   {
/*
 *    Find slowest remaining kernel
 */
      mf = bp->mflop[imf];
      for (minp=prev=bp, p=bp->next; p; p = p->next)
      {
         if (p->mflop[imf] < mf)
         {
            minp = p;
            mf = p->mflop[imf];
            minprev = prev;
         }
         prev = p;
      }
/*
 *    Remove it from unsorted queue, and add as new head of sorted
 */
      if (minp == bp)
      {
         bp = bp->next;
         minp->next = sb;
      }
      else   /* in the middle of unsorted queue */
      {
         minprev->next = minp->next;
         minp->next = sb;
      }
      sb = minp;
   }
   return(sb);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static ATL_@(rt)node_t *Parse@up@(rt)Line(char *ln)
/*
 * Given a line from a @(rt) index file (with multiple lines pasted together
 * into one line (ln), return a structure describing that line.
 */
{
   ATL_@(rt)node_t *p;
   char *sp;
   int itmp;
   char ch;

   p = Get@up@(rt)Node();

@ROUT r1read mvread
@whiledef kk ldamul
   sp = strstr(ln, "@up@(kk)=");
   if (sp)
      p->@(kk) = atoi(sp+@len@(kk)+1);
   else
      p->@(kk) = 0;

@endwhile
@ROUT mmread 
@whiledef jj mu nu ku kbmin kbmax fftch iftch nftch lat pref muladd vlen kmaj
   sp = strstr(ln, "@up@(jj)=");
   if (sp)
      p->@(jj) = atoi(sp+@len@(jj)+1);
   else
      p->@(jj) = 0;
@endwhile
@whiledef jj kb nb mb
   sp = strstr(ln, "@up@(jj)=");
   if (sp)
      p->@(jj)B = atoi(sp+@len@(jj)+1);
   else
      p->@(jj)B = 0;
@endwhile
   @multidef jj ID SSE
@ROUT mvread r1read 
   @multidef jj ID MU NU minN minM alignX alignY alignA SSE CacheElts rankR
@ROUT r1read mvread mmread
@whiledef jj
   sp = strstr(ln, "@(jj)=");
   if (sp)
      p->@(jj) = atoi(sp+@len@(jj)+1);
   else
      p->@(jj) = 0;

@endwhile
@ROUT mmread
   sp = strstr(ln, "OPMV=");
   if (sp)
   {
      int imv;
      imv = atoi(sp+5);
      ATL_MMF_MVPUT(p->flag, imv);
   }
@multidef fl 
   X87 LDCTOP MRUNTIME NRUNTIME KRUNTIME KUISKB LDISKB BETAN1 LDAB AOUTER
   LDFLOAT STFLOAT PFACOLS PFABLK PFBCOLS PFCELTS L14NB JKMABC JKMAB BMAB BMABC
@endmultidef

@ROUT mvread
@multidef fl X87 LDYTOP ALLALIGNXY AXPYBASED GEMMBASED CONJDEF FNU ALIGNX2A ADDCFLAGS PFTUNABLE
@ROUT r1read
@multidef fl X87 ALLALIGNXY FNU INCYISONE ALIGNX2A ADDCFLAGS PFTUNABLE
@ROUT r1read mvread mmread
@whiledef fl
   sp = strstr(ln, "@(fl)=");
   if (sp)
   {
      if (atoi(sp+@len@(fl)+1))
         p->flag |= (1<<@up@(rt)F_@(fl));
      else
         p->flag &= ~(1<<@up@(rt)F_@(fl));
   }
@endwhile

   sp = strstr(ln, "MFLOP=");
   if (sp)
      GetDoubleArr(sp+6, 8, p->mflop);

   sp = strstr(ln, "ASM=");
   if (sp)
      p->asmbits = asmNames2bitfield(sp+4);


@ROUT mmread
@multidef TA TA TB
@ROUT mvread
@multidef TA TA 
@ROUT mvread mmread
@whiledef TA
   sp = strstr(ln, "@(TA)='");
   if (sp)
   {
      ch = tolower(sp[4]);
      if (ch == 'n')
         p->@(TA) = AtlasNoTrans;
      else if (ch == 'c')
         p->@(TA) = AtlasConjTrans;
      else if (ch == 't')
         p->@(TA) = AtlasTrans;
      else
         assert(0);
   }
@endwhile
@ROUT mvread r1read mmread
@skip   sp = strstr(ln, "MFLOP=");
@skip   if (sp) p->mflop = atof(sp+6);

@ROUT mvread r1read `@define kw @kname@`
@whiledef kw rout auth comp cflags
   sp = strstr(ln, "@up@(kw)='");
   if (sp)
      p->@(kw) = GetSingleQuoteString(sp+@len@(kw)+1);
   else
      p->@(kw) = NULL;

@endwhile
   return(p);
}

/* procedure 18 */
static void Print@up@(rt)Line(FILE *fpout, ATL_@(rt)node_t *np)
{
   int i, j, k;
   char ta, tb;

   if (!np)
      return;
   if (!np->rout)
      np->ID = 0;
@ROUT r1read
   fprintf(fpout, "ID=%d ROUT='%s' AUTH='%s'",
           np->ID, np->rout ? np->rout : "generated", 
           np->auth ? np->auth : "R. Clint Whaley");
@ROUT mvread mmread
   if (np->TA == AtlasConjTrans) ta = 'C';
   else if (np->TA == AtlasTrans) ta = 'T';
   else ta = 'N';
@ROUT mvread
   fprintf(fpout, "ID=%d ROUT='%s' AUTH='%s' TA='%c'",
           np->ID, np->rout ? np->rout : "generated", 
           np->auth ? np->auth : "R. Clint Whaley", ta);
@ROUT mvread r1read
   if (np->kname)
      fprintf(fpout, " KNAME='%s' \\\n", np->kname);
   else
      fprintf(fpout, " \\\n");
@ROUT mmread
   if (np->TB == AtlasConjTrans) tb = 'C';
   else if (np->TB == AtlasTrans) tb = 'T';
   else tb = 'N';
   fprintf(fpout, "ID=%d ROUT='%s' AUTH='%s' TA='%c' TB='%c' \\\n",
           np->ID, np->rout ? np->rout : "generated", 
           np->auth ? np->auth : "R. Clint Whaley", ta, tb);

@ROUT mvread r1read mmread
   fprintf(fpout, "   ");
   i = 3;
@ROUT mvread r1read
@whiledef kw MU NU minN minM alignX alignY alignA SSE CacheElts rankR
   if (i > 70) { fprintf(fpout, " \\\n   "); i = 3; }
   i += fprintf(fpout, "@(kw)=%d ", np->@(kw));
@endwhile
@whiledef kw ldamul
   if (i > 70) { fprintf(fpout, " \\\n   "); i = 3; }
   i += fprintf(fpout, "@up@(kw)=%d ", np->@(kw));
@endwhile

@ROUT mmread 
   if (i > 70) { fprintf(fpout, " \\\n   "); i = 3; }
   i += fprintf(fpout, "OPMV=%d ", ATL_MMF_MVGET(np->flag));
@whiledef kw mu nu ku kbmin kbmax fftch iftch nftch lat pref muladd vlen kmaj
   if (i > 70) { fprintf(fpout, " \\\n   "); i = 3; }
   i += fprintf(fpout, "@up@(kw)=%d ", np->@(kw));
@endwhile

   @define kwd @@
   @multidef kw
      X87 LDCTOP MRUNTIME NRUNTIME KRUNTIME KUISKB LDISKB BETAN1 LDAB AOUTER
      LDFLOAT STFLOAT PFACOLS PFABLK PFBCOLS L14NB JKMABC JKMAB BMAB BMABC
   @endmultidef
@ROUT r1read 
   @define kwd @X87 INCYISONE FNU ADDCFLAGS ALIGNX2A PFTUNABLE@
@ROUT mvread 
   @define kwd @X87 FNU LDYTOP ALLALIGNXY AXPYBASED GEMMBASED ADDCFLAGS ALIGNX2A PFTUNABLE@
@ROUT mmread
@whiledef jj kb nb mb
   if (i > 70) { fprintf(fpout, " \\\n   "); i = 3; }
   if (np->@(jj)B != 0)
      i += fprintf(fpout, "@up@(jj)=%d ", np->@(jj)B);
@endwhile
@ROUT mvread r1read mmread
@whiledef kw @(kwd)
   if (i > 70) { fprintf(fpout, " \\\n   "); i = 3; }
   i += fprintf(fpout, "@(kw)=%d ", FLAG_IS_SET(np->flag, @up@(rt)F_@(kw)));
@endwhile

   if (np->mflop[0]+np->mflop[1]+np->mflop[2]+np->mflop[3]+np->mflop[4]+
       np->mflop[5]+np->mflop[6] != 0.0)
   {
      if (i > 3) { fprintf(fpout, " \\\n   "); i = 3; }
      i += fprintf(fpout, "MFLOP=%le", np->mflop[0]);
      for (j=7; j && np->mflop[j] == 0.0; j--);
      for (k=1; k <= j; k++)
         i += fprintf(fpout, ",%le", np->mflop[k]);
   }
   if (np->asmbits)
   {
      if (i > 40) { fprintf(fpout, " \\\n   "); i = 3; }
      for (j=0; !(np->asmbits & (1<<j)); j++);
      assert(j < NASMD);
      i += fprintf(fpout, "  ASM=%s", ASMNAM[j]);
      for (j++; j < NASMD; j++)
         if (np->asmbits & (1<<i))
            i += fprintf(fpout, ",%s", ASMNAM[j]);
   }
@whiledef kw comp cflags
   if (np->@(kw))
   {
      if (i+strlen(np->@(kw)) > 70) { fprintf(fpout, " \\\n   "); i = 3; }
      i += fprintf(fpout, "  @up@(kw)='%s'", np->@(kw));
   }
@endwhile
   if (i)
      fprintf(fpout, "\n");
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static void Print@up@(rt)Nodes(FILE *fpout, ATL_@(rt)node_t *bp)
{
   while (bp)
   {
      Print@up@(rt)Line(fpout, bp);
      bp = bp->next;
   }
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static void Write@up@(rt)File(char *file, ATL_@(rt)node_t *nq)
{
   FILE *fpout;

   if (!file || !strcmp(file, "stdout"))
      fpout = stdout;
   else if (!strcmp(file, "stderr"))
      fpout = stderr;
   else
   {
      fpout = fopen(file, "w");
      assert(fpout);
   }
   Print@up@(rt)Nodes(fpout, nq);
   if (fpout != stdout && fpout != stderr)
      fclose(fpout);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static void Write@up@(rt)FileWithPath
   (char pre, char *path, char *file, ATL_@(rt)node_t *nq)
{
   char ln[2048];
   sprintf(ln, "%s/%c%s", path, pre, file);
   Write@up@(rt)File(ln, nq);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static ATL_@(rt)node_t *Read@up@(rt)File(char *file)
/*
 * Reads in a standard ATLAS parsable @up@(rt) index file, and returns a
 * list of all the kernels defined there.
 */
{
   ATL_@(rt)node_t *nq=NULL, *p;
   FILE *fpin;
   char *ln, *sp;
   int i, j, KeepOn, len;

   if (!file || !strcmp(file, "stdin"))
      fpin = stdin;
   else
      fpin = fopen(file, "r");
   if (!fpin)
      return(NULL);
   nq = p = Get@up@(rt)Node();
   while (ln = GetJoinedLines(fpin))
   {
      if (ln[0] != '#' && ln[0] != '\0')
      {
         p->next = Parse@up@(rt)Line(ln);
         p = p->next;
      }
   }
   fclose(fpin);
   return(Kill@up@(rt)Node(nq));
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static ATL_@(rt)node_t *Read@up@(rt)FileWithPath
   (char pre, char *path, char *file)
{
   char ln[2048];
   sprintf(ln, "%s/%c%s", path, pre, file);
   return(Read@up@(rt)File(ln));
}


@iexp ip @(ip) 1 +
/* procedure @(ip) */
static ATL_@(rt)node_t *DelRepeated@up@(rt)Kernels(ATL_@(rt)node_t *bp)
/*
 * Deletes any repeated IDs
 */
{
   ATL_@(rt)node_t *prev, *p, *np;
   int ID;

   for (p=bp; p; p = p->next)
   {
      ID = p->ID;
      prev = p;
      do
      {
         for (np=p->next; np && np->ID != ID; np = np->next)
            prev = np;
         if (np)  /* found duplicate */
            prev->next = Kill@up@(rt)Node(np);
      }
      while (np);
   }
   return(bp);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static ATL_@(rt)node_t *DelBadArch@up@(rt)Kernels(ATL_@(rt)node_t *bp)
/*
 * Weeds out kernels that require SSE/assembly that we haven't got
 */
{
   int asmb=0, die;
   ATL_@(rt)node_t *p, *prev;
@multidef sh          1         2        3        4          5        6       7         8
@whiledef asm GAS_x8632 GAS_x8664 GAS_SPARC GAS_PPC GAS_PARISC GAS_MIPS GAS_ARM GAS_ARM64
   #ifdef ATL_@(asm)
      asmb |= (1<<@(sh));
   #endif
   @undef sh
@endwhile

   prev = p = bp;
   while (p)
   {
      die = (p->asmbits) ? !(asmb & p->asmbits) : 0;
      #ifndef ATL_SSE3
         if (p->SSE)
         {
            die |= (p->SSE >= 3);
            #ifndef ATL_SSE2
               die |= (p->SSE >= 2);
            #endif
            #ifndef ATL_SSE1
               die |= (p->SSE >= 1);
            #endif
         }
      #endif
      if (die) 
      {
         if (p == bp) 
            bp = p = Kill@up@(rt)Node(p);
         else 
            prev->next = p = Kill@up@(rt)Node(p);
      }
      else
      {
         prev = p;
         p = p->next;
      }
   }
   return(bp);
}

@ROUT mvread r1read
#define MAXBASES 4
@iexp ip @(ip) 1 +
/* procedure @(ip) */
static int ATL_@up@(rt)SplitContexts
(
   ATL_@(rt)node_t *kb,   /* pointer to all read in kernels */
   ATL_@(rt)node_t **ocb, /* set to all out-of-cache kernels */
   ATL_@(rt)node_t **i2b, /* set to all in-L2 kernels */
   ATL_@(rt)node_t **i1b, /* set to all in-L1 kernels */
   ATL_@(rt)node_t **syb  /* NULL, or all SYR/SYR2 kernels (may not exist) */
)
/*
 *  Takes unified bp, and splits it into separate pieces.  bp is invalidated
 *  in the process (is split into child queues)
 *  RETURNS: number of children found
 */
{
   ATL_@(rt)node_t *kp, *kn;
   ATL_@(rt)node_t *bases[MAXBASES] = {NULL, NULL, NULL, NULL};
   int nbases;

/*
 * Kernels come as a series of kernels that are ranked by efficiency from
 * high to low based on the integer rankR.  All series must end with a
 * general kernel with no restrictions with a rankR of 0 (all non-zero
 * kernels have restrictions).  This loop splits these kernels into 
 * their seperate series (series indicates calling context).
 */
   kn = kb;
   nbases = 0;
   while (kn)
   {
      bases[nbases++] = kn;
      for (kp=kn; kp && kp->rankR; kp = kp->next);  /* find end of series */
      if (!kp)
         break;
      kn = kp->next;
      kp->next = NULL;
   }
   if (ocb)
      *ocb = bases[0];
   else
      KillAll@up@(rt)Nodes(bases[0]);
   if (i2b)
      *i2b = bases[1];
   else
      KillAll@up@(rt)Nodes(bases[1]);
   if (i1b)
      *i1b = bases[2];
   else
      KillAll@up@(rt)Nodes(bases[2]);
   if (syb)
      *syb = bases[3];
   else
      KillAll@up@(rt)Nodes(bases[3]);
   return(nbases);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static ATL_@(rt)node_t *ATL_@up@(rt)LinkContexts
(
   ATL_@(rt)node_t *kp1, /* all out-of-cache kernels */
   ATL_@(rt)node_t *kp2, /* all in-L2 kernels */
   ATL_@(rt)node_t *kp3, /* all in-L1 kernels */
   ATL_@(rt)node_t *kp4  /* all SYR/SYR2 kernels */
)
/*
 *  Takes separate queue, and joins them into one long queue; if any
 *  is NULL, all remaining cases must also be NULL!
 *  Seperate queues are subsumed into returned queue
 */
{
   ATL_@(rt)node_t *kps[MAXBASES] = {kp1, kp2, kp3, kp4};
   ATL_@(rt)node_t *kp, *kprev;
   int i, j;

   for (i=0; i < MAXBASES-1; i++)
   {
      if (!kps[i])
      {
         for (j=i+1; j < MAXBASES; j++)
            assert(!kps[j]);
         return(kp1);
      }
      for (kp=kps[i]; kp->next; kp = kp->next);
      kp->next = kps[i+1];
   }
   return(kp1);
}
#undef MAXBASES

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static ATL_@(rt)node_t *FindFastest@up@(rt)Kernel
(  char pre,             /* precision prefix */
   ATL_@(rt)node_t *bp,  /* kernel queue */
   int imf,              /* which mflop entry to sort by */
   int RESTRICTOK        /* consider restricted kernel? */
)
/*
 * A RESTRICTed kernel is one that requires something that can't be fixed
 * by loop peeling or the like.  Examples include forcing lda to a given
 * multiple, or 16-byte alignment for double complex (can't peel 1/2 of
 * a complex number to make 8-byte aligned array 16).
 * RETURNS: pointer to node in bp that is fastest in context imf wt RESTRCT
 */
{
   double mf;
   ATL_@(rt)node_t *kp, *kmax=bp;
   int size, usize, RKERN;

   if (bp)
   {
      usize = (pre == 'c' || pre == 's') ? 4 : 8;
      if (pre == 'c' || pre == 'd') size = 8;
      else if (pre == 's') size = 4;
      else size = 16;
      mf = bp->mflop[imf];
      for (kp=bp->next; kp; kp = kp->next)
      {
         if (kp->mflop[imf] > mf)
         {
            RKERN = (pre == 'z' || pre == 'c') ? (kp->alignA > usize) : 0;
            RKERN = RKERN | (kp->ldamul > size);
            if (RESTRICTOK | !RKERN)
            {
               mf = kp->mflop[imf];
               kmax = kp;
            }
         }
      }
   }
   return(kmax);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static int @up@(rt)flag2size(int flag)
/*
 * RETURNS: size of type using precision/type bits in flag
 */
{
   int size;

   size = FLAG_IS_SET(flag, @up@(rt)F_SINGLE) ? 4 : 8;
   size *= FLAG_IS_SET(flag, @up@(rt)F_COMPLEX) ? 2 : 1;
   return(size);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static char @up@(rt)flag2pre(int flag)
/*
 * RETURNS: correct precision/type prefix based on flag
 */
{
   char pre = 'd';
   if (FLAG_IS_SET(flag, @up@(rt)F_SINGLE))
      return(FLAG_IS_SET(flag, @up@(rt)F_COMPLEX) ? 'c' : 's');
   return(FLAG_IS_SET(flag, @up@(rt)F_COMPLEX) ? 'z' : 'd');
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static int pre2@up@(rt)flag(char pre, int flag)
/*
 * RETURNS: flag modified to reflect type/precision indicated by pre
 */
{
   SET_FLAG(flag, @up@(rt)F_COMPLEX, (pre == 'c' || pre == 'z'));
   SET_FLAG(flag, @up@(rt)F_SINGLE, (pre == 'c' || pre == 's'));
   return(flag);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static void SetAll@up@(rt)TypeFlags(char pre, ATL_@(rt)node_t *bp)
{
   ATL_@(rt)node_t *p;
   for (p=bp; p; p = p->next)
      p->flag = pre2@up@(rt)flag(pre, p->flag);
}
@ROUT r1read

@iexp ip @(ip) 1 +
/* procedure @(ip) */
void PutKernNameInStr(ATL_@(rt)node_t *r1B)
/*
 * Fills in the proper name for all kernels in r1->str
 */
{
   char ln[32] = {"ATL_dgerk_L0_restrict"};
   char pre;
   const int ipre=4, iL=11, irest=12;

   pre = @up@(rt)flag2pre(r1B->flag);
   ln[ipre] = pre;
   r1B->str = DupString(ln);
   ln[irest] = '\0';
   r1B->next->str = DupString(ln);
   ln[irest] = '_';
   r1B = r1B->next->next;

   ln[iL] = '2';
   r1B->str = DupString(ln);
   ln[irest] = '\0';
   r1B->next->str = DupString(ln);
   ln[irest] = '_';
   r1B = r1B->next->next;

   ln[iL] = '1';
   r1B->str = DupString(ln);
   ln[irest] = '\0';
   r1B->next->str = DupString(ln);
   ln[irest] = '_';
   r1B = r1B->next->next;

   sprintf(ln, "ATL_%cgerk_L1b_restrict", pre);
   r1B->str = DupString(ln);
   ln[irest+1] = '\0';
   r1B->next->str = DupString(ln);
}

@beginskip
@iexp ip @(ip) 1 +
/* procedure @(ip) */
ATL_r1node_t *GetSortedUniqueR1Kerns
   (char pre, ATL_r1node_t *r1kerns, char **aliases)
/*
 * Takes the 8-length queue of rank-1 update kernels:
 *    First 2 are restricted and normal GER out-of-cache kernels
 *    next 2 are restricted & normal in-L2 GER kernels
 *    next 2 are restristed & normal in-L1 GERM kernels
 *    next 2 are restristed & normal out-of-cache, L1-blocked kernels
 *
 * ALIASES: a null-terminated list of string pointers, where pairs
 *          of strings give the correct aliasing: 1st entry is the
 *          routine to be aliased, 2nd is what it should be aliased to.
 *          Every kernel that uses the same actual routine as another
 *          in the 8-length queue is deleted, and a #define is used
 *          to call the appropriate kernel, to avoid unnecessary
 *          code size expansion.
 *          If ALIASES is NULL, then ALIASES is not accessed.
 *          ALIASES must be at least 15 pointers long.
 *
 * RETURNS: new queue with only the unique kernels left (unrestricted
 *          kernels appear first in list), and the p->str entry having
 *          the correct routine/file name.  
 * NOTE   : Leaves the original queue intact.
 */
{
   ATL_r1node_t *r1b, *r1p, *r1k, *r1prev;
   char *kern = "gerk";
   int i, ialias=0;
   char *suff[8] = {"_L0", "_L0_restrict", "_L2", "_L2_restrict",
                    "_L1", "_L1_restrict", "_L1b", "_L1b_restrict"};

@skip   kern = (pre == 'z' || pre == 'c') ? "geru" : "ger";
/*
 * Make sure all routines are present, and there are no extra
 */
  for (i=0, r1p = r1kerns; i < 8; i++, r1p=r1p->next)
     assert(r1p);
  assert(!r1p);
/* 
 * Build new queue with the "normal" kernels first
 */
   r1b = CloneR1Node(r1kerns->next);
   r1b->next = r1p = CloneR1Node(r1kerns);
   r1p->next = CloneR1Node(r1kerns->next->next->next);
   r1p->next->next =  CloneR1Node(r1kerns->next->next);
   r1p = r1p->next->next;
   r1p->next = CloneR1Node(r1kerns->next->next->next->next->next);
   r1p->next->next = CloneR1Node(r1kerns->next->next->next->next);
   r1p = r1p->next->next;
   r1p->next = CloneR1Node(r1kerns->next->next->next->next->next->next->next);
   r1p->next->next = CloneR1Node(r1kerns->next->next->next->next->next->next);
   r1p->next->next->next = NULL;
/*
 * Label queue entries with proper kernel names
 */
   for (i=0,r1p = r1b; i < 8; i++, r1p = r1p->next)
   {
       r1p->str = malloc(32*sizeof(char));
       assert(r1p->str);
       sprintf(r1p->str, "ATL_%c%s%s", pre, kern, suff[i]);
   }
/* 
 * Add duplicated kernels to alias array, and then get rid of them from Q
 */
   r1prev = r1b;
   r1p = r1b->next;
   while (r1p)
   {
      for (r1k=r1b; r1k != r1p; r1k = r1k->next)
         if (r1k->ID == r1p->ID) break;
      if (r1k != r1p)  /* got duplicate */
      {
         if (aliases)
         {
            aliases[ialias++] = r1p->str;
            r1p->str = NULL;
            aliases[ialias++] = DupString(r1k->str);
         }
         r1prev->next = r1p = KillR1Node(r1p);
      }
      else
      {
        r1prev = r1p;
        r1p = r1p->next;
      }
   }
   if (aliases)
      aliases[ialias] = NULL;
   return(r1b);
}
@endskip
@ROUT mvread
@iexp ip @(ip) 1 +
/* procedure @(ip) */
static void SortByTrans
(
   ATL_@(rt)node_t *bp,    /* original kernels wt mixture of trans cases */
   ATL_@(rt)node_t **bN0,  /* No trans cases */
   ATL_@(rt)node_t **bT0,  /* trans cases */
   ATL_@(rt)node_t **bNC0, /* ConjNotrans cases */
   ATL_@(rt)node_t **bTC0  /* Conjtrans cases */
) 
/*
 * Sorts bp into the separate transpose queues, destroying bp in the process.
 * If a bp entry has the CONJDEF property, then its entry is duplicated to
 * put it on both queues (it can be used for normal and conjugate cases).
 */
{
   ATL_@(rt)node_t *bN=NULL, *bT=NULL, *bNC=NULL, *bTC=NULL,
                   *p, *next, *new;

   for (p=bp; p; p = next)
   {
      next = p->next;
      if (p->TA == AtlasNoTrans)
      {
         p->next = bN;
         bN = p;
         #ifdef TCPLX
            if (p->flag & (1<<@up@(rt)F_CONJDEF))
            {
               new = Clone@up@(rt)Node(p);
               new->TA = AtlasConj;
               new->next = bNC;
               bNC = new;
            }
         #endif
      }
      else if (p->TA == AtlasTrans)
      {
         p->next = bT;
         bT = p;
         #ifdef TCPLX
            if (p->flag & (1<<@up@(rt)F_CONJDEF))
            {
               new = Clone@up@(rt)Node(p);
               new->TA = AtlasConjTrans;
               new->next = bTC;
               bTC = new;
            }
         #endif
      }
   #ifdef TCPLX
      else if (p->TA == AtlasConjTrans)
      {
         p->next = bTC;
         bTC = p;
      }
      else /* TA == AtlasConj */
      {
         p->next = bNC;
         bNC = p;
      }
   #endif
   }
   *bN0 = bN;
   *bT0 = bT;
   *bNC0 = bNC;
   *bTC0 = bTC;
}
@ROUT mmread

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static int MMKernsSame(ATL_mmnode_t *p0, ATL_mmnode_t *p1)
/*
 * RETURNS: 1 if kernels are the same except for blocking, 0 otherwise
 */
{
/*
 * Two generated kernels are the same if mu,nu,ku,VLEN,flag are the same.
 * NOTE: if we make generator handle muladd, etc, MUST UPDATE HERE!!!
 */
   if (p0->ID == 0 && p1->ID == 0)
      return(p0->mu == p1->mu && p0->nu == p1->nu && p0->ku == p1->ku &&
             p0->vlen == p1->vlen && p0->flag == p1->flag &&
             p0->kmaj == p1->kmaj);
/*
 * If both are user kernels, then they may be repeats.  For user kernels,
 * they are the same if both ID and flag match, else they are not.
 */
   else if (p0->ID > 0 && p1->ID > 0)
      return(p0->ID == p1->ID && p0->flag == p1->flag);
   return(0);  /* Can't be the same if above criteria fails */
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static int MMKernCompsSame(ATL_mmnode_t *p0, ATL_mmnode_t *p1)
/*
 * RETURNS: 1 if kernels are the same including KB, else 0
 */
{
/*
 * Kernels are not the same if one has compile-time K and other runtime
 */
   if (FLAG_IS_SET(p0->flag, MMF_KRUNTIME) != 
       FLAG_IS_SET(p1->flag, MMF_KRUNTIME))
      return(0);
/*
 * Kernels not same if both compile-time K with differing KB
 */
   if (!FLAG_IS_SET(p0->flag, MMF_KRUNTIME) && p0->kbB != p1->kbB)
      return(0);
   return(MMKernsSame(p0, p1));
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static int MMKernIsPresent(ATL_mmnode_t *mmb, ATL_mmnode_t *mmp)
/*
 * RETURNS: 1 if kernel compilation matching mmp is in list mmb, 0 otherwise
 */
{
   ATL_mmnode_t *mp;
   for (mp=mmb; mp; mp = mp->next)
      if (MMKernsSame(mmp, mp))
         return(1);
   return(0);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static int MMKernCompIsPresent(ATL_mmnode_t *mmb, ATL_mmnode_t *mmp)
/*
 * RETURNS: 1 if kernel compilation matching mmp is in list mmb, 0 otherwise
 */
{
   ATL_mmnode_t *mp;
   for (mp=mmb; mp; mp = mp->next)
      if (MMKernCompsSame(mmp, mp))
         return(1);
   return(0);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static ATL_mmnode_t *AddUniqueMMKernsToList
   (ATL_mmnode_t *mmb, ATL_mmnode_t *newb)
/*
 * RETURNS: mmb with any kernels present in newb that aren't in mmb added to it
 * (1) changes mmb, does not change newb
 * (2) new nodes are added to BEGINNING of mmb (leaving mmb unsorted)!
 */
{
   ATL_mmnode_t *mp;
      
   for (mp=newb; mp; mp = mp->next)
   {
      if (!MMKernIsPresent(mmb, mp))
      {
         ATL_mmnode_t *p;
         p = CloneMMNode(mp);
         p->next = mmb;
         mmb = p;
      }
   }
   return(mmb);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static ATL_mmnode_t *AddUniqueMMKernCompList
   (ATL_mmnode_t *mmb, ATL_mmnode_t *newb)
/*
 * RETURNS: mmb with any kerncomps present in newb that aren't in mmb added 
 *          to it
 * (1) changes mmb, does not change newb
 * (2) new nodes are added to BEGINNING of mmb (leaving mmb unsorted)!
 */
{
   ATL_mmnode_t *mp;
   for (mp=newb; mp; mp = mp->next)
   {
      if (!MMKernCompIsPresent(mmb, mp))
      {
         ATL_mmnode_t *p;
         p = CloneMMNode(mp);
         p->next = mmb;
         mmb = p;
      }
   }
   return(mmb);
}

@ROUT mvread r1read mmread
#endif  /* end atlas_@(rt)parse.h guard */
@ROUT atlas_mvtesttime.h
   @define rt @mv@
   @define ru @mv@
   @define at @mvt@
@ROUT atlas_r1testtime.h
   @define rt @r1@
   @define ru @r1@
   @define at @r1@
@ROUT atlas_r2testtime.h
   @define rt @r2@
   @define ru @r1@
   @define at @r2@
@ROUT atlas_mmtesttime.h
   @define rt @mm@
   @define ru @mm@
   @define at @mm@
@ROUT atlas_gentesttime.h
#ifndef ATLAS_GENTESTTIME_H
   #define ATLAS_GENTESTTIME_H

#include "atlas_fopen.h"

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static int GetL1CacheSize()
{
   FILE *L1f;
   int L1Size;

   L1f = fopen("res/L1CacheSize", "r");
   if (!L1f)
   {
      assert(system("make res/L1CacheSize\n") == 0);
      L1f = fopen("res/L1CacheSize", "r");
   }
   assert(L1f != NULL);
   assert(fscanf(L1f, "%d", &L1Size) == 1);
   fclose(L1f);
   fprintf(stderr, "\n      Read in L1 Cache size as = %dKB.\n",L1Size);
   return(L1Size);
}

@ROUT mvres mmres atlas_gentesttime.h
@iexp ip @(ip) 1 +
/* procedure @(ip) */
static int pre2size(char pre)
{
   int iret=8;
   if (pre == 's')
      iret = 4;
   else if (pre == 'z')
      iret = 16;
   return(iret);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static void SortDoubles(int N, double *d)
/* 
 * Sorts N-length array d from least to greatest using N^2 selection sort
 */
{
   double min;
   int imin, i, j;

   for (i=0; i < N-1; i++)
   {
      imin = i;
      min = d[i];
      for (j=i+1; j < N; j++)
      {
         if (d[j] < min)
         {
            imin = j;
            min = d[j];
         }
      }
      if (imin != i)
      {
         d[imin] = d[i];
         d[i] = min;
      }
   }
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static void *ReadResultsFile(int ACTION, int nsample, char *resfile)
/*
 * Reads an ATLAS results file, which has the following form:
 *    <N> <walltime>   -> walltime of 0 means CPU timing was used
 *    sample1
 *    ....
 *    sampleN
 * RETURNs NULL on error, otherwise it depends on ACTION:
 * ACTION    RETURNS
 * 0         ptr to max value for walltime, median for CPU (serial timing)
 * 1         entire list of results is returned in N+2 array, of form
 *              <N> <wall> <sample1> .... <sampleN>
 *           DRET[0] = N; DRET[1] = 1 if walltime else 0.
 * 2         ptr to the average (parallel timing)
@beginskip
 * RETURNS: NULL on error or if nsample > N, else if (FULL) it returns
 *          an array of form:  <N> <wall> <sample1> .... <sampleN>
 *          where samples have been sorted from least-to-greatest.
 *          where <N> is the number of samples.
 *          If (!FULL) then a pointer to the max value is returned for
 *          walltime, and a pointer to the median value is returned for
 *          for cputime.
@endskip
 */
{
   static double dret;
   double *dres;
   FILE *fpin;
   char ln[1024];
   int i, n, wall, ierr;

   fpin = fopen(resfile, "r");
   if (!fpin)
      return(NULL);
   ierr = (fgets(ln, 1024, fpin) == NULL);
   if (ierr || sscanf(ln, " %d %d", &n, &wall) != 2)
   {
      fclose(fpin);
      return(NULL);
   }
   if (n < nsample)
   {
      fclose(fpin);
      return(NULL);
   }
   dres = malloc((n+2)*sizeof(double));
   assert(dres);
   dres[0] = n;
   dres[1] = wall;
   dret = 0.0;
   for (i=0; i < n; i++)
   {
      ierr = (fgets(ln, 1024, fpin) == NULL);
      if (ierr || sscanf(ln, " %le", dres+i+2) != 1)
      {
         fclose(fpin);
         return(NULL);
      }
      dret += dres[i+2];
   }
   fclose(fpin);
   SortDoubles(n, dres+2);
   if (ACTION == 1)
      return(dres);
   else if (ACTION == 0)
      dret = (wall) ? dres[n+1] : dres[2+n/2];
   else /* if (ACTION == 2) */
      dret /=  dres[0];
   free(dres);
   return(&dret);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static double PrintResultsFromFile(FILE *fpout, double *darr)
{
   const int N=darr[0], wall=(darr[1] != 0.0);
   double *dres=darr+2;
   double dret;
   int i;

   assert(N > 0);
   for (i=0; i < N; i++)
      fprintf(fpout, "   %le\n", dres[i]);
   if (wall)
   {
      fprintf(fpout, "MAX = %.2f\n", dres[N-1]);
      return(dres[N-1]);
   }
   else 
      fprintf(fpout, "MED = %.2f\n", dres[N/2]);
   return(dres[N/2]);
}

@ROUT atlas_gentesttime.h
#endif  /* end guard around atlas_gentesttime.h */
@ROUT atlas_mmtesttime.h atlas_r1testtime.h atlas_r2testtime.h @\
      atlas_mvtesttime.h
#ifndef ATLAS_@up@(rt)TESTTIME_H
   #define ATLAS_@up@(rt)TESTTIME_H

#include "atlas_@(ru)parse.h"
#include "atlas_gentesttime.h"

@ROUT atlas_r1testtime.h atlas_r2testtime.h atlas_mvtesttime.h
static int SprintAlignStr
(
   char pre,            /* precision modifier */
   ATL_@(ru)node_t *kp, /* kernel pointer */
   char *str            /* (OUTPUT) string to print to */
)
/*
 * Prints alignment string to str, based on alignment setting.
 * This routine assumes to force the alignment to sizeof(TYPE) unless 
 * restrictions are enabled.
 * RETURNS: number of chars added to str
 */
{
   const int size = (pre == 'd' || pre == 's') ? pre2size(pre) 
                                                 : (pre2size(pre)>>1);
   int alignA, alignX, alignY, i;

   alignA = (kp->alignA) ? kp->alignA : size;
   alignX = (kp->alignX) ? kp->alignX : size;
   alignY = (kp->alignY) ? kp->alignY : size;
@ROUT atlas_r1testtime.h atlas_r2testtime.h
   if (FLAG_IS_SET(kp->flag, @up@(ru)F_ALIGNX2A))
      alignX = alignA;  /* ALIGNX2A overrides alignX */
@ROUT atlas_mvtesttime.h
@beginskip
   {
      if (kp->TA == AtlasNoTrans) /* ALIGNX2A affects Y for No-Trans */
         alignY = alignA; /* ALIGNX2A overrides alignY */
      else
         alignX = alignA; /* ALIGNX2A overrides alignX */
   }
@endskip
/*
 * If we are doing an AXPY-based No-Trans GEMV, it is Y, not X that must
 * be aligned to A.  Therefore, alignX/ALIGNX2A actually refer to Y, and
 * alignY refers to X.  Do this confusing transpose for the non-trans case.
 */
   if (kp->TA == AtlasNoTrans) /* ALIGNX* affects Y for No-Trans */
   {
      i = alignX;
      alignX = alignY;
      alignY = i;
      if (FLAG_IS_SET(kp->flag, @up@(ru)F_ALIGNX2A))
         alignY = alignA; /* ALIGNX2A overrides alignY */
   }
   else if (FLAG_IS_SET(kp->flag, @up@(ru)F_ALIGNX2A))
      alignX = alignA;
@ROUT atlas_r1testtime.h atlas_r2testtime.h atlas_mvtesttime.h
/*
 * If ALIGNX2A, we must force to vectors to have the same remainder when
 * divided by the vector length.  We do this by insisting they have the
 * the same modulo by ATL_Cachelen, which by definition is always a 
 * multiple of the vector length (eg, veclen=16/32 (SSE/AVX), ATL_cl=32). 
 */
   if (FLAG_IS_SET(kp->flag, @up@(ru)F_ALIGNX2A))
   {
      int myalign = ATL_Cachelen - size;
      if (alignA)
      {
         myalign = ((ATL_Cachelen-size)/alignA)*alignA;
         if (!myalign) 
            myalign = alignA;
      }
@ROUT atlas_r1testtime.h atlas_r2testtime.h
      if (myalign < ATL_Cachelen)
         i = sprintf(str, " align=\"-Fa %d -Fa -%d -Fx %d -Fx -%d",
                     myalign, ATL_Cachelen, myalign, ATL_Cachelen);
      else
         i = sprintf(str, " align=\"-Fa %d -Fx %d", myalign, myalign);
      if (2*alignY <= ATL_Cachelen)
         i += sprintf(str+i, " -Fy %d -Fy -%d\"", alignY, 2*alignY);
      else
         i += sprintf(str+i, " -Fy %d\"", alignY);
@ROUT atlas_mvtesttime.h
      if (kp->TA == AtlasNoTrans) /* ALIGNX* affects Y for No-Trans */
      {
         if (myalign < ATL_Cachelen)
            i = sprintf(str, " align=\"-Fa %d -Fa -%d -Fy %d -Fy -%d",
                        myalign, ATL_Cachelen, myalign, ATL_Cachelen);
         else
            i = sprintf(str, " align=\"-Fa %d -Fy %d", myalign, myalign);
         if (2*alignX <= ATL_Cachelen)
            i += sprintf(str+i, " -Fx %d -Fx -%d\"", alignX, 2*alignX);
         else
            i += sprintf(str+i, " -Fx %d\"", alignX);
      }
      else
      {
         if (myalign < ATL_Cachelen)
            i = sprintf(str, " align=\"-Fa %d -Fa -%d -Fx %d -Fx -%d",
                        myalign, ATL_Cachelen, myalign, ATL_Cachelen);
         else
            i = sprintf(str, " align=\"-Fa %d -Fx %d", myalign, myalign);

         if (2*alignY <= ATL_Cachelen)
            i += sprintf(str+i, " -Fy %d -Fy -%d\"", alignY, 2*alignY);
         else
            i += sprintf(str+i, " -Fy %d\"", alignY);
      }
@ROUT atlas_r1testtime.h atlas_r2testtime.h atlas_mvtesttime.h
   }
   else
   {
      if (2*alignA <= ATL_Cachelen)
         i = sprintf(str, " align=\"-Fa %d -Fa -%d", alignA, 2*alignA);
      else
         i = sprintf(str, " align=\"-Fa %d ", alignA);
      if (2*alignX <= ATL_Cachelen)
         i += sprintf(str+i, " -Fx %d -Fx -%d", alignX, 2*alignX);
      else
         i += sprintf(str+i, " -Fx %d", alignX);
      if (2*alignY <= ATL_Cachelen)
         i += sprintf(str+i, " -Fy %d -Fy -%d\"", alignY, 2*alignY);
      else
         i += sprintf(str+i, " -Fy %d\"", alignY);
   }
   return(i);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static int @up@(rt)KernelFailsTest
   (int verb, char pre, ATL_INT M, ATL_INT N, ATL_INT lda, ATL_@(ru)node_t *kn)
{
   char ln[4096];
   char *sp;
   int i, lda0;
   static char outnam[L_tmpnam];
   static int FirstTime=1;

   if (FirstTime)
   {
      
      FirstTime = 0;
      assert(tmpnam(outnam));
   }
/*
 * If the file is generated, call generator to create it
 */
   if (kn->genstr)
   {
      i = sprintf(ln, "%s", kn->genstr);
      if (verb < 3)
         i += sprintf(ln+i, " > %s 2>&1\n", outnam);
      if (system(ln))
      {
         fprintf(stderr, "ERROR, LINE %d of %s\n", __LINE__, __FILE__);
         fprintf(stderr, "UNABLE TO GENERATE WITH COMMAND: %s\n", kn->genstr);
         if (verb < 3)
         {
            fprintf(stderr, "\nOUTPUT OF system():\n");
            sprintf(ln, "cat %s 1>&2\n", outnam);
            i = system(ln);
         }
         remove(outnam);
         exit(-1);
      }
   }
   assert(kn->rout);
   assert (M >= kn->minM);
   assert (N >= kn->minN);
@ROUT atlas_mvtesttime.h
   sp = (kn->TA == AtlasNoTrans) ? "mvn" : "mvt";
   if (kn->TA == AtlasNoTrans)
      i = sprintf(ln, "make %cmvnktest mvnrout=%s", pre, kn->rout);
   else
      i = sprintf(ln, "make %cmvtktest mvtrout=%s", pre, kn->rout);
@ROUT atlas_r1testtime.h atlas_r2testtime.h
   i = sprintf(ln, "make %c@(rt)ktest @(at)rout=%s", pre, kn->rout);
@ROUT atlas_r1testtime.h atlas_r2testtime.h atlas_mvtesttime.h
   i += SprintAlignStr(pre, kn, ln+i);
   if (FLAG_IS_SET(kn->flag, @up@(ru)F_FNU))
       i += sprintf(ln+i, " Nt=%d ", (1008/kn->NU)*kn->NU);
   if (kn->exflags)
      i += sprintf(ln+i, " %s", kn->exflags);
   if (1)   /* NOTE: replace with test on restrict or not! */
      i += sprintf(ln+i, " incy=1");
   if (kn->comp)
      i += sprintf(ln+i, " %c@up@(rt)CC=\"%s\"", pre, kn->comp);
   if (kn->cflags)
@ROUT atlas_mvtesttime.h
      i += sprintf(ln+i, " %c@up@(rt)FLAGS=\"%s\"", pre, kn->cflags);
@ROUT atlas_r1testtime.h atlas_r2testtime.h
      i += sprintf(ln+i, " %c@up@(rt)CFLAGS=\"%s\"", pre, kn->cflags);
@ROUT atlas_r1testtime.h atlas_r2testtime.h atlas_mvtesttime.h
   i += sprintf(ln+i, " Mt=%d Nt=%d ldat=%d", M, N, lda);
   if (verb < 3)
      i += sprintf(ln+i, " > %s 2>&1\n", outnam);
   else 
      i += sprintf(ln+i, "\n");
   if (verb > 1)
      fprintf(stdout, "system call:%s\n", ln);
   i = system(ln);
   if (verb)
   {
      if (i)
      {
         fprintf(stderr, "\n%s(ID=%d) FAILS TESTER!!\n", kn->rout,kn->ID);
         fprintf(stderr, "FAILING CALL: '%s'\n", ln);
         if (verb < 3 && verb > 0)
         {
            int itmp;
            fprintf(stderr, "\nOUTPUT OF system():\n");
            sprintf(ln, "cat %s 1>&2\n", outnam);
            itmp = system(ln);
         }
      }
      else
         fprintf(stderr, "%s(ID=%d) *PASSES* TESTER!!\n", kn->rout,kn->ID);
   }
   if (verb < 3)
      remove(outnam);
   return(i);
}


@iexp ip @(ip) 1 +
/* procedure @(ip) */
static char *GetResIdStr(ATL_@(ru)node_t *r1p, ATL_INT M, ATL_INT N,
                         ATL_INT lda, ATL_INT percL1, int mflop)
{
/* 
 * Return filename suffix that disambiguates most kernels:
 * <ID><TA>_<M>x<N>_<lda>-<ldamul>_<MU>x<NU>_<percL1>_a<alignA>x<aX>x<aY>_<flag>
 */
   static char ln[512];
@ROUT atlas_mvtesttime.h
   sprintf(ln, "%d%c_%dx%d_%d-%d_%dx%d_%d_a%dx%dx%d_%d", r1p->ID, 
           (r1p->TA == AtlasNoTrans) ? 'N' : 'T', M, N, lda, r1p->ldamul,
            r1p->MU, r1p->NU, percL1, r1p->alignA, r1p->alignX, r1p->alignY, 
            r1p->flag);
@ROUT atlas_r1testtime.h atlas_r2testtime.h
   sprintf(ln, "%d_%dx%d_%d-%d_%dx%d_%d_a%dx%dx%d_%d", r1p->ID, 
           M, N, lda, r1p->ldamul, r1p->MU, r1p->NU, percL1, 
           r1p->alignA, r1p->alignX, r1p->alignY, r1p->flag);
@ROUT atlas_r1testtime.h atlas_r2testtime.h atlas_mvtesttime.h
   return(ln);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static double Time@up@(rt)Kernel
(int verb,              /* 0: no output, 1 min ouput, 2: full output */
 int FORCETIME,         /* if nonzero, ignore existing timing file */
                        /* if negative, don't retain timing file */
 ATL_@(ru)node_t *r1p,     /* ptr to kernel structure */
 char pre,              /* precision prefix */
 ATL_INT M, ATL_INT N,  /* dimensions to time */
 ATL_INT lda,           /* stride between row elements */
 ATL_INT percL1,        /* if 0, time kernel directly wt no blocking */
                        /* if non-zero, block for that % of L1 cache size */
 int nrep,              /* if >=1, # of trials, else use default (3) */
 int mflop,             /* force mflop flops in each timing interval */
 int cflush             /* if >= 0, size of cache flush area, else ignored */
)
{
   char ln[2048], resf[256], *sp;
   double *dp, mf;
   int i, align = pre2size(pre);
   static char outnam[L_tmpnam];
   static int FirstTime=1;

   if (FirstTime)
   {
      
      FirstTime = 0;
      assert(tmpnam(outnam));
   }
/*
 * If the file is generated, call generator to create it
 */
   if (r1p->genstr)
   {
      i = sprintf(ln, "%s", r1p->genstr);
      if (verb < 3)
         i += sprintf(ln+i, " > %s 2>&1\n", outnam);
      if (system(ln))
      {
         fprintf(stderr, "ERROR, LINE %d of %s\n", __LINE__, __FILE__);
         fprintf(stderr, "UNABLE TO GENERATE WITH COMMAND: %s\n", r1p->genstr);
         if (verb < 3)
         {
            int itmp;
            fprintf(stderr, "\nOUTPUT OF system():\n");
            sprintf(ln, "cat %s 1>&2\n", outnam);
            itmp = system(ln);
         }
         exit(-1);
      }
   }

   if (r1p->minN)
      N = Mmax(N, r1p->minN);
   if (r1p->minM)
   {
      M = Mmax(M, r1p->minM);
      if (lda < M) 
         lda = M;
   }
   if (FLAG_IS_SET(r1p->flag, @up@(ru)F_FNU))
      N = Mmax(r1p->NU, (N/r1p->NU)*r1p->NU);
   i = r1p->ldamul / pre2size(pre);
   lda = (i) ? ((lda+i-1)/i)*i : lda;

   if (FORCETIME < 0)
      sprintf(resf, "res/%c@(rt)tmp", pre);
   else
      sprintf(resf, "res/%c@(rt)%s", pre, 
              GetResIdStr(r1p, M, N, lda, percL1, mflop));
   if (FORCETIME)
      remove(resf);
   dp = FORCETIME ? NULL : ReadResultsFile(0, nrep, resf);
   if (dp)
   {
      if (verb > 0)
         fprintf(stdout, "   %d:%s (M=%d, N=%d, lda=%d) gets %.2f MFLOPS\n", 
                 r1p->ID, r1p->rout, M, N, lda, *dp);
      return(*dp);
   }

@ROUT atlas_mvtesttime.h
   sp = (r1p->TA == AtlasNoTrans || r1p->TA == AtlasConj) ? "mvn" : "mvt";
   if (percL1)
      i = sprintf(ln, "make %c%stime M=%d N=%d lda=%d l1mul=%d %srout=\"%s\"",
                  pre, sp, M, N, lda, percL1, sp, r1p->rout);
   else
      i = sprintf(ln, "make %c%sktime M=%d N=%d lda=%d %srout=\"%s\"",
                  pre, sp, M, N, lda, sp, r1p->rout);
@ROUT atlas_r1testtime.h atlas_r2testtime.h
   if (percL1)
      i = sprintf(ln, "make %c@(rt)time M=%d N=%d lda=%d l1mul=%d @(rt)rout=\"%s\"",
                  pre, M, N, lda, percL1, r1p->rout);
   else
      i = sprintf(ln, "make %c@(rt)ktime M=%d N=%d lda=%d @(rt)rout=\"%s\"",
                  pre, M, N, lda, r1p->rout);
@ROUT atlas_r1testtime.h atlas_r2testtime.h atlas_mvtesttime.h
   if (r1p->flag)
      i += sprintf(ln+i, " iflag=%d", r1p->flag);
   if (r1p->exflags)
      i += sprintf(ln+i, " %s", r1p->exflags);
   if (r1p->comp)
      i += sprintf(ln+i, " %c@up@(rt)CC=\"%s\"", pre, r1p->comp);
   if (r1p->cflags)
@ROUT atlas_mvtesttime.h
      i += sprintf(ln+i, " %c@up@(rt)FLAGS=\"%s\"", pre, r1p->cflags);
@ROUT atlas_r1testtime.h atlas_r2testtime.h
      i += sprintf(ln+i, " %c@up@(rt)CFLAGS=\"%s\"", pre, r1p->cflags);
@ROUT atlas_r1testtime.h atlas_r2testtime.h atlas_mvtesttime.h
   i += SprintAlignStr(pre, r1p, ln+i);
   if (cflush >=0)
      i += sprintf(ln+i, " flushKB=%d", cflush);
   i += sprintf(ln+i, " tflags=\"-f %s", resf);
   if (nrep > 0)
      i += sprintf(ln+i, " -# %d", nrep);

   if (mflop >= 0)
      i += sprintf(ln+i, " -F %d", mflop);
   i += sprintf(ln+i, "\"");
   i += sprintf(ln+i, " mu=%d nu=%d", r1p->MU, r1p->NU);
   if (verb < 3)
      i += sprintf(ln+i, " > %s 2>&1\n", outnam);
   else
      i += sprintf(ln+i, "\n");
   i = system(ln);
   if (i)
   {
      fprintf(stderr, "\nERROR %d, LINE %d OF %s\n", i, __LINE__, __FILE__);
      fprintf(stderr, "SYSTEM CALL FAILED: %s\n", ln);
      if (verb < 3)
      {
         int itmp;
         fprintf(stderr, "\nOUTPUT OF system():\n");
         sprintf(ln, "cat %s 1>&2\n", outnam);
         itmp = system(ln);
         remove(outnam);
      }
      exit(-1);
   }
   if (verb < 3)
      remove(outnam);
   if (verb > 1)
   {
      dp = ReadResultsFile(1, nrep, resf);
      mf = PrintResultsFromFile(stdout, dp);
      free(dp);
      dp = &mf;
   }
   else
      dp = ReadResultsFile(0, nrep, resf);
   assert(dp);
   if (verb == 1)
      fprintf(stdout, "   %d:%s (M=%d, N=%d, lda=%d) gets %.2f MFLOPS\n", 
              r1p->ID, r1p->rout, M, N, lda, *dp);
   return(*dp);
}
@ROUT atlas_mvtesttime.h atlas_r1testtime.h atlas_r2testtime.h

static void FillIn@up@(rt)ExtractGenStrings(char pre, ATL_@(ru)node_t *kb)
/*
 * Creates generator strings to match kb settings
 */
{
   char ln[4096], *suff;
   int i, CL=8, mu;
   if (pre != 'd' && pre != 'c')
      CL = (pre == 'z') ? 4 : 16;
   while(kb)
   {
      if (kb->ID < 900000 || kb->ID >= 1000000) 
      {
         kb = kb->next;
         continue;
      }
      if (kb->asmbits == asmNames2bitfield("GAS_x8664"))
      {
         assert(kb->MU%CL == 0);
         suff = "sse";
         mu = kb->MU/CL;
      }
      else
      {
         mu = kb->MU;
         if (kb->SSE)
            suff = "Csse";
         else
            suff = "C";
      }
@ROUT atlas_mvtesttime.h
      if (kb->TA == AtlasNoTrans)
         i = sprintf(ln, "make %cmvnext_%s order=clmajor mu=%d nu=%d", pre, 
                     suff, mu, kb->NU);
      else
         i = sprintf(ln, "make %cmvtext_%s order=clmajor mu=%d nu=%d", pre, 
                     suff, mu, kb->NU);
@ROUT atlas_r1testtime.h atlas_r2testtime.h
      i = sprintf(ln, "make %c@(rt)ext_%s order=clmajor mu=%d nu=%d", pre, 
                  suff, mu, kb->NU);
@ROUT atlas_mvtesttime.h atlas_r1testtime.h atlas_r2testtime.h
      if (kb->alignA && kb->alignA%16==0 && kb->ldamul && kb->ldamul%16==0)
         i += sprintf(ln+i, " genflags=\"-def ALIGNED 1\"");
         
      if (kb->genstr)
         free(kb->genstr);
      kb->genstr = DupString(ln);
      kb = kb->next;
   }
}
@ROUT atlas_r1testtime.h atlas_r2testtime.h atlas_mvtesttime.h
#endif  /* end guard around atlas_@(rt)testtime.h */
@ROUT atlas_mmtesttime.h
@iexp ip @(ip) 1 +
/* procedure @(ip) */
int MMKernelFailsTest
(
   char pre,                    /* precision/type prefix */
   int mb, int nb, int kb,      /* dimensions to test */
   int beta,                    /* beta case to test */
   ATL_mmnode_t *umm            /* mmkern ptr */
)
/*
 * RETURNS: 0 on success, non-zero on failure
 */
{
   char ln[4096];
   int i, lda, ldb, ldc;
   char ch;

/*
 * If the file is generated, call generator to create it
 */
   if (umm->genstr)
   {
      assert(strlen(umm->genstr) < 4032);
      sprintf(ln, "%s > /dev/null 2>&1", umm->genstr);
      if (system(ln))
      {
         fprintf(stderr, "ERROR, LINE %d of %s\n", __LINE__, __FILE__);
         fprintf(stderr, "UNABLE TO GENERATE WITH COMMAND: %s\n", umm->genstr);
         exit(-1);
      }
   }
   ldc = mb*2+4;
   if (FLAG_IS_SET(umm->flag, MMF_LDISKB))
      lda = ldb = kb;
   else if (FLAG_IS_SET(umm->flag, MMF_LDAB))
      lda = ldb = kb+8;
   else
   {
      lda = kb+8;
      ldb = kb+16;
   }
   if (FLAG_IS_SET(umm->flag, MMF_JKMABC))
   {
      if (umm->ID > 0)
         i = sprintf(ln, "make %cammmtst mmrout=AMMCASES/%s mu=%d nu=%d ku=%d ",
                     pre, umm->rout, umm->mu, umm->nu, umm->ku);
      else
         i = sprintf(ln, "make %cammmtst mmrout=%s mu=%d nu=%d ku=%d ",
                     pre, umm->rout, umm->mu, umm->nu, umm->ku);
      if (umm->kmaj > 1)
         i += sprintf(ln+i, "kmaj=%d ", umm->kmaj);
   }
   else if (pre == 'c' || pre == 'z')
      i = sprintf(ln, "make cmmutstcase mmrout=%s csC=2 ", umm->rout);
   else
      i = sprintf(ln, "make mmutstcase mmrout=%s ", umm->rout);
   if (beta != 1)
   {
      if (beta == -1)
      {
         if ((FLAG_IS_SET(umm->flag, MMF_JKMABC)))
            i += sprintf(ln+i, "beta=-1 betan=\"N1\" ");
         else
            i += sprintf(ln+i, "beta=2 betan=\"X\" ");
      }
      else if (beta == 0)
         i += sprintf(ln+i, "beta=%d ", beta);
      else
         i += sprintf(ln+i, "beta=%d betan=\"X\" ", beta);
   }
   if (umm->kmaj > 1)
         i += sprintf(ln+i, "kmaj=%d ", umm->kmaj);
   if (umm->comp)
   {
      ch = (pre == 'c' || pre == 's') ? 'S' : 'D';
      i += sprintf(ln+i, "%cMC=\"%s\" %cMCFLAGS=\"%s\" ",
                   ch, umm->comp, ch, umm->cflags);
   }
   i += sprintf(ln+i, "pre=%c M=%d N=%d K=%d mb=%d nb=%d kb=%d ",
                pre, mb, nb, kb, 
                FLAG_IS_SET(umm->flag, MMF_MRUNTIME) ? 0 : mb, 
                FLAG_IS_SET(umm->flag, MMF_NRUNTIME) ? 0 : nb, 
                FLAG_IS_SET(umm->flag, MMF_KRUNTIME) ? 0 : kb);
   i += sprintf(ln+i, "lda=%d ldb=%d ldc=%d", lda, ldb, ldc);
   i += sprintf(ln+i, " > /dev/null 2>&1\n");
   i = system(ln);
   if (i)
   {
      fprintf(stderr, "%d of %s: FAILED COMMAND : %s\n",__LINE__,__FILE__,ln);
      if (umm->genstr)
         fprintf(stderr, "   genstr was = '%s'\n", umm->genstr);
   }
   return(i);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static ATL_mmnode_t *DelBadMMKernels(char pre, int verb, ATL_mmnode_t *bp)
/*
 * Deletes all kernels that can't pass basic usage test
 * RETURNS: modifed bp queue wt failing kernels removed
 */
{
   ATL_mmnode_t *p, *prev;
   int die;

   if (verb > 0)
       printf("\nBEGIN BASIC MATMUL KERNEL TESTS:\n");

   prev = p = bp;
   while (p)
   {
      if (MMKernelFailsTest(pre, p->mbB, p->nbB, p->kbB, 0, p) ||
          MMKernelFailsTest(pre, p->mbB, p->nbB, p->kbB, 1, p) ||
          MMKernelFailsTest(pre, p->mbB, p->nbB, p->kbB, -1, p))
      {
         if (verb > 0)
            printf("   NUKING bad kernel %s(%d)\n", p->rout, p->ID);
         if (p == bp)
            bp = p = KillMMNode(p);
         else
            prev->next = p = KillMMNode(p);
      }
      else
      {
         if (verb > 0)
            printf("   Kernel %s(%d) passes basic tests\n", p->rout, p->ID);
         prev = p;
         p = p->next;
      }
   }
   printf("DONE BASIC KERNEL TESTS.\n\n");
   return(bp);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
char *GetGmmGenString
(
   int verb,                    /* verbosity */
   char pre,                    /* precision */
   int MACC,                    /* 0 : separate mult&add, else MACC */
   int lat,                     /* multiply latency */
   int beta,                    /* 0,1 beta, else beta=X */
   int nb,                      /* blocking factor */
   int mu, int nu, int ku,      /* unrolling factors */
   int Fftch,                   /* do bogus fetch of C at top of loop? */
   int iftch,                   /* # of initial fetches to do */
   int nftch,                   /* # of fetches to do thereafter */
   int LDTOP,                   /* 1: load C at top, 0: at bottom */
   int pf                       /* prefetch strategy */
)
/*
 * returns a string that will result in generating a user-style kernel
 * specialized for non-cleanup cases by invoking a make target that
 * in turn invokes the scalar generator routine, emit_mm.c
 * Because it is specialized for kernel cases, we don't specify leading
 * dimensions, transpose cases, etc, but just take the defaults.
 */
{
   char ln[4096];
   int i;

   if (!LDTOP)
      pf |= 512;
   i = sprintf(ln, "make mmgencase pre=%c muladd=%d lat=%d beta=%d mb=%d nb=%d kb=%d mu=%d nu=%d ku=%d if=%d nf=%d ff=%d, pfA=%d, csC=%d",
               pre, MACC, lat, beta, nb, nb, nb, mu, nu, ku, iftch, nftch, 
               Fftch, pf, (pre == 'c' || pre == 'z') ? 2 : 1);
   if (verb < 3)
      i += sprintf(ln+i, " > /dev/null 2>&1");
   else
      i += sprintf(ln+i, "\n");
   if (verb > 2)
      printf("genstr='%s'\n", ln);
   return(DupString(ln));
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
void FillInGMMNode(int verb, ATL_mmnode_t *mmp, char pre, int MACC, int lat, 
                   int beta, int nb, int mu, int nu, int ku, 
                   int fftch, int iftch, int nftch, int LDTOP, int pf)
/*
 * Take emit_mm's flags and fill in the standard ATL_mmnode_t struct mmp
 * making all the correct assumptions for the standard copy code
 */
{
   int i;

   if (ku > (nb>>1))
      ku = nb;
   mmp->mbB = mmp->nbB = mmp->kbB = nb;
   mmp->mu = mu;
   mmp->nu = nu;
   mmp->ku = ku;
   mmp->muladd = MACC;
   mmp->lat = lat;
   mmp->fftch = fftch;
   mmp->iftch = iftch;
   mmp->nftch = nftch;
   mmp->pref = pf;
   mmp->SSE = 0;
   mmp->TA = AtlasTrans;
   mmp->TB = AtlasNoTrans;
   mmp->asmbits = 0;
   if (mmp->auth)
      free(mmp->auth);
   if (mmp->rout)
      free(mmp->rout);
   if (mmp->comp)
      free(mmp->comp);
   if (mmp->cflags)
      free(mmp->cflags);
   if (mmp->str)
      free(mmp->str);
   if (mmp->genstr)
      free(mmp->genstr);
   mmp->comp = mmp->cflags = mmp->str = NULL;
   mmp->rout = DupString("dgmm.c");
   mmp->rout[0] = pre;
   mmp->genstr = GetGmmGenString(verb, pre, MACC, lat, beta, nb, mu, nu, ku, 
                                 fftch, iftch, nftch, LDTOP, pf);
   mmp->auth = DupString("Whaley/emit_mm");
   i = 0;
   SET_FLAG(i, MMF_KUISKB, (ku == nb));
   SET_FLAG(i, MMF_LDISKB, 1);
   SET_FLAG(i, MMF_LDAB, 1);
   if (pre == 's' || pre == 'c')
      SET_FLAG(i, MMF_SINGLE, 1);
   if (pre == 'c' || pre == 'z')
      SET_FLAG(i, MMF_COMPLEX, 1);
   mmp->flag = i;
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
double TimeGMMKernel            /* times kernels generated by emit_mm */
(
   int verb,                    /* verbosity */
   int FORCETIME,               /* 1: ignore any prior output file */
   char pre,                    /* precision */
   int MACC,                    /* 0 : separate mult&add, else MACC */
   int lat,                     /* multiply latency */
   int beta,                    /* 0,1 beta, else beta=X */
   int nb,                      /* blocking factor */
   int mu, int nu, int ku,      /* unrolling factors */
   int Fftch,                   /* do bogus fetch of C at top of loop? */
   int iftch,                   /* # of initial fetches to do */
   int nftch,                   /* # of fetches to do thereafter */
   int LDTOP,                   /* 1: load C at top, 0: at bottom */
   int pf,                      /* prefetch strategy */
   int mflop,                   /* >0: force mflop MFLOPs in each time interv */
   int cflush                   /* >0: size of cache flush, else ignored */
)
{
   int i;
   char *bet;
   FILE *fp;
   double *dp;
   char fnam[256];
   char ln[4096];

   if (beta == 1)
      bet = "_b1";
   else if (beta == 0)
      bet = "_b0";
   else if (beta == -1)
      bet = "_bn1";
   else
      bet = "_bX";
   if (!LDTOP)
      pf |= 512;
   if (ku > nb/2)
      ku = nb;
   else if (ku == -1)
      ku = nb;
   sprintf(fnam,
           "res/%c%smm%c%c%d_%dx%dx%d_%dx%dx%d_%dx%dx%d%s%s_%dx%d_%d_pf%d_cf%d",
            pre, "JIK", 'T', 'N', nb, nb, nb, nb, nb, nb, 0, mu, nu, ku,
            "_a1", bet, MACC, lat, 1, pf, cflush);
   dp = (FORCETIME) ? NULL : ReadResultsFile(0, 0, fnam);
   if (!dp)
   {
      i = sprintf(ln, "make mmcase pre=%c loopO=JIK ta=T tb=N mb=%d nb=%d kb=%d lda=%d ldb=%d ldc=%d mu=%d nu=%d ku=%d alpha=1 beta=%d muladd=%d lat=%d cleanup=1 pfA=%d casnam=\"%s\"",
                  pre, nb, nb, nb, nb, nb, 0, mu, nu, ku, beta, MACC, lat, pf,
                  fnam);
      if (pre == 'c' || pre == 'z')
         i += sprintf(ln+i, " csA=1 csB=1 csC=2");
       
      if (verb < 3)
         i += sprintf(ln+i, " > /dev/null 2>&1\n");
      else
         i += sprintf(ln+i, "\n");
      if (verb > 1)
         fprintf(stdout, "SYSTEM: %s", ln);
      if (system(ln))
      {
         fprintf(stderr, "ERROR IN COMMAND: %s", ln);
         fprintf(stderr, "   PROPOSED FILENAME: %s\n", fnam);
         sprintf(ln, "rm -f %s\n", fnam);
         assert(!system(ln));
         exit(-1);
      }
      dp = ReadResultsFile(0, 0, fnam);
   }
   if (dp == NULL)
   {
      fprintf(stderr, "Failed ReadResultsFile, ln='%s'\n", ln); 
      fprintf(stderr, "fnam=%s\n", fnam); 
   }
   assert(dp);
   return(*dp);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
double TimeMMKernel
(
   int verb,                    /* 0: no output, 1 min output, 2: full output */
   int FORCETIME,               /* 1: ignore any prior output file */
   ATL_mmnode_t *mmp,           /* ptr to mmkern struct */
   char pre,                    /* type/prec prefix: z,c,d,s */
   int mb, int nb, int kb,      /* dimensions to time */
   int lda,                     /* >0: lda to use, else kb */
   int ldb,                     /* >0: ldb to use, else kb */
   int ldc,                     /* >0: ldc to use, else mb+8 */
   int beta,                    /* beta to time */
   int mflop,                   /* >0: force mflop MFLOPs in each time interv */
   int cflush                   /* >=0: size of cache flush, else ignored */
)
{
   char fnam[128], ln[2048];
   char tidnam[1024], tidflg[1024];
   const char *LO = FLAG_IS_SET(mmp->flag, MMF_AOUTER) ? "IJK": "JIK";
   const int JKMAJOR = FLAG_IS_SET(mmp->flag, MMF_JKMABC), ku=mmp->ku;
   const int KB = (mmp->kmaj < 2) ? kb : ((kb+ku-1)/ku)*ku;
   int DOTIME=1;
   int MV=3;  /* bit pattern on move CBA (C=4, B=2, A=1) */
   char *be;
   int i, j;
   char ch;
   double *dp;
   MV = ((mmp->flag) >> MMF_MVA)&7;
/*
 * If it's a emit_mm generated file w/o the genstring, create the genstring
 * assuming it is a mmK
 */
   if (mmp->ID == 0 && !mmp->genstr && mmp->iftch > 0)
      mmp->genstr = GetGmmGenString(verb, pre, mmp->muladd, mmp->lat, beta, nb,
                                    mmp->mu, mmp->nu, mmp->ku,
                                    mmp->fftch, mmp->iftch, mmp->nftch, 
                                    FLAG_IS_SET(mmp->flag, MMF_LDCTOP), 
                                    mmp->pref);
/*
 * If the file is generated, call generator to create it
 */
   if (mmp->genstr)
   {
      i = sprintf(ln, "%s", mmp->genstr);
      if (verb < 3)
         i += sprintf(ln+i, " > /dev/null 2>&1\n");
      if (system(ln))
      {
         fprintf(stderr, "ERROR, LINE %d of %s\n", __LINE__, __FILE__);
         fprintf(stderr, "UNABLE TO GENERATE WITH COMMAND: %s\n", mmp->genstr);
         exit(-1);
      }
   }
   #ifndef ATL_SERIAL_INSTALL
      #define RESACT 2   /* want average frm ReadResultsFile for parallel */
/*
 *    If tids is specified, build the name and forwarding flags.
 *    Examples of tidnam and tidflg: T2_4_5 and -tl 2 4 5 .
 */
      if (mmp->tids)
      {
         int lnam, lflg;
         j = mmp->tids[0];
         lnam = sprintf(tidnam, "T%d", j);
         lflg = sprintf(tidflg, "-tl %d", j);
         for (i=1; i<=j; i++)
         {
            lnam += sprintf(tidnam+lnam, "_%d", mmp->tids[i]);
            lflg += sprintf(tidflg+lflg, " %d", mmp->tids[i]);
         }
      }
/*
 *    Figure out the name of the output file
 */
      if (FORCETIME)
         strcpy(fnam, "res/tmpout.ktim");
/*
 *    PREammID_MBxNBxKB_MUxNUxKU_FLAG_v[M,K]VLENbBETA_CFLUSH[_tNCPU_CPULIST]
 */
      else
      {
         if (mmp->vlen < 2)
            ch = 'S';
         else
            ch = (mmp->kmaj > 1) ? 'K' : 'M';

         if (mmp->tids)
         sprintf(fnam, "res/%cammm%d_%dx%dx%d_%dx%dx%d_%d_v%c%db%d_%d_%s.ktim",
                 pre, mmp->ID, mb, nb, KB, mmp->mu, mmp->nu, mmp->ku, mmp->flag,
                 ch, mmp->vlen, beta, cflush, tidnam);
         else
         sprintf(fnam, "res/%cammm%d_%dx%dx%d_%dx%dx%d_%d_v%c%db%d_%d.ktim",
                 pre, mmp->ID, mb, nb, KB, mmp->mu, mmp->nu, mmp->ku, mmp->flag,
                 ch, mmp->vlen, beta, cflush);
      }
/* 
 *    If we actually need to do timing, must also construct timer call
 */
      if (!FORCETIME)
         DOTIME = !FileExists(fnam);
      if (DOTIME)
      {
         i = sprintf(ln, "make x%cammtime_pt mb=%d nb=%d kb=%d",
                     pre, mb, nb, KB);
         if (mmp->genstr)
            i += sprintf(ln+i, " mmrout=%s", mmp->rout);
         else
            i += sprintf(ln+i, " mmrout=AMMCASES/%s", mmp->rout);
         i += sprintf(ln+i, " mu=%d nu=%d ku=%d", mmp->mu, mmp->nu, mmp->ku);
         i += sprintf(ln+i, " mvA=%d mvB=%d mvC=%d", ((mmp->flag >> MMF_MVA)&1), 
                      ((mmp->flag >> MMF_MVB)&1), ((mmp->flag >> MMF_MVC)&1));
         i += sprintf(ln+i, " kmoves=\"");
         if (FLAG_IS_SET(mmp->flag, MMF_MVA))
            i += sprintf(ln+i, " -DATL_MOVEA");
         if (FLAG_IS_SET(mmp->flag, MMF_MVB))
            i += sprintf(ln+i, " -DATL_MOVEB");
         if (FLAG_IS_SET(mmp->flag, MMF_MVC))
            i += sprintf(ln+i, " -DATL_MOVEC");
         i += sprintf(ln+i, "\"");
         if (beta == 1 || beta == 0)
            i += sprintf(ln+i, " beta=%d", beta);
         else
            i += sprintf(ln+i, " beta=-1 betan=\"N1\"");
         ch = (pre == 'c' || pre == 's') ? 'S' : 'D';
         if (mmp->comp)
            i += sprintf(ln+i, " %cMC=\"%s\"", ch, mmp->comp);
         if (mmp->cflags)
            i += sprintf(ln+i, " %cMCFLAGS=\"%s\"", ch, mmp->cflags);
         if (mmp->tids)
            i += sprintf(ln+i, " TIDLIST=\"%s\"", tidflg);
         i += sprintf(ln+i, " outF=\"-f %s\"", fnam);
      }
   #else
      #define RESACT 0   /* ReadResultsFile uses ACTION=0 */
      if (FLAG_IS_SET(mmp->flag, MMF_LDISKB))
         lda = ldb = kb;
      else
      {
         if (lda < 1)
            lda = kb;
         if (ldb < 1)
            ldb = kb;
         if (ldc < 1)
            ldc = mb + 8;
      }
      if (FLAG_IS_SET(mmp->flag, MMF_LDAB))
         ldb = lda;
   
      if (beta == 0)
         be = "b0";
      else if (beta == 1)
         be = "b1";
      else if (beta == -1)
         be = "bn1";
      else 
         be = "bX";
      if (FORCETIME)
         sprintf(fnam, "res/tmpout");
      else if (JKMAJOR) 
      /*   dmmMNK%d_JMMBxNBxKB_muxnuk#xku_rtK_LDTOP_vlen_pf_a1_bX_MV_flushKB */
         sprintf(fnam, 
         "res/%cmm%s%d_%dx%dd%dx%d_%dx%dx%d_rtK%d__v%d_%d_%d_a1_%s_%d_%d.ktim",
                 pre, FLAG_IS_SET(mmp->flag, MMF_AOUTER) ? "MNK" : "NMK",
                 mmp->ID, mb, nb, mmp->kmaj, kb, mmp->mu, mmp->nu, mmp->ku, 
                 FLAG_IS_SET(mmp->flag, MMF_KRUNTIME), 
                 FLAG_IS_SET(mmp->flag, MMF_LDCTOP), 
                 mmp->vlen, mmp->pref, be, MV, cflush);
   
      else /*dmm%d_TNMBxNBxKB_muxnuxku_ldc_rtMxrtNxrtK_LDTOP_pf_a1_bX_MV_flushKB */
         sprintf(fnam, 
        "res/%cmm%s%d_%c%c%dx%dx%d_%dx%dx%d_%d_%dx%dx%d_%d_%d_a1_%s_%d_%d.ktim",
                 pre, FLAG_IS_SET(mmp->flag, MMF_AOUTER) ? "MNK" : "NMK",
                 mmp->ID, 'T', 'N', mb, nb, kb, mmp->mu, mmp->nu, mmp->ku, ldc, 
                 FLAG_IS_SET(mmp->flag, MMF_MRUNTIME), 
                 FLAG_IS_SET(mmp->flag, MMF_NRUNTIME), 
                 FLAG_IS_SET(mmp->flag, MMF_KRUNTIME), 
                 FLAG_IS_SET(mmp->flag, MMF_LDCTOP), mmp->pref, be, MV, cflush);
   
      if (!FORCETIME)
         DOTIME = !FileExists(fnam);
      if (DOTIME)
      {
         if (pre == 'c' || pre == 'z')
            i = sprintf(ln, "make cmmucase mmrout=%s csC=2 ", mmp->rout);
         else if (JKMAJOR) 
         {
            if (mmp->ID > 0)
               i = sprintf(ln, "make mmucaseN mmrout=AMMCASES/%s ", mmp->rout);
            else
               i = sprintf(ln, "make mmucaseN mmrout=%s ", mmp->rout);
            if (mmp->kmaj > 1)
               i += sprintf(ln+i, "kmaj=%d ", mmp->kmaj);
         }
         else
            i = sprintf(ln, "make mmucase mmrout=%s ", mmp->rout);
         if (mmp->cflags)
         {
            ch = (pre == 'c' || pre == 's') ? 'S' : 'D';
            i += sprintf(ln+i, "%cMCFLAGS=\"%s\" ", ch, mmp->cflags);
         }
         if (mmp->comp)
         {
            ch = (pre == 'c' || pre == 's') ? 'S' : 'D';
            i += sprintf(ln+i, "%cMC=\"%s\" ", ch, mmp->comp);
         }
         if (mmp->moves)
            i += sprintf(ln+i, " moves=\"%s\" ", mmp->moves);
         if (mmp->exflags)
            i += sprintf(ln+i, " %s ", mmp->exflags);
         
         if (!cflush)
            i += sprintf(ln+i, "moves=\"\" ");
               
   @skip      i += sprintf(ln+i, "moves=\"-DMoveA -DMoveC\" ");
         i += sprintf(ln+i, "casnam=%s ", fnam);
         i += sprintf(ln+i, "pre=%c M=%d N=%d K=%d mb=%d nb=%d kb=%d ",
                      pre, mb, nb, KB, 
                      FLAG_IS_SET(mmp->flag, MMF_MRUNTIME) ? 0:mb,
                      FLAG_IS_SET(mmp->flag, MMF_NRUNTIME) ? 0:nb,
                      FLAG_IS_SET(mmp->flag, MMF_KRUNTIME) ? 0:KB);
         i += sprintf(ln+i, "mu=%d nu=%d ku=%d lda=%d ldb=%d ldc=%d beta=%d",
                      mmp->mu, mmp->nu, mmp->ku, lda, ldb, ldc, beta);
      }
   }
   #endif
   if (FORCETIME || !FileExists(fnam))
   {
      if (verb < 3)
         i += sprintf(ln+i, " > /dev/null 2>&1\n");
      else
         i += sprintf(ln+i, "\n");
      if (verb > 1)
         fprintf(stdout, "SYSTEM: %s", ln);
      if (system(ln))
      {
         fprintf(stderr, "ERROR IN COMMAND: %s", ln);
         fprintf(stderr, "   PROPOSED FILENAME: %s\n", fnam);
         if (mmp->genstr)
            fprintf(stderr, "   GENSTR='%s'\n", mmp->genstr);
         sprintf(ln, "rm -f %s\n", fnam);
         assert(!system(ln));
         exit(-1);
      }
   }
   dp = ReadResultsFile(RESACT, 0, fnam);
   if (!dp)
   {
      fprintf(stderr, "\nEmpty file '%s'!\n", fnam);
      fprintf(stderr, "From command: '%s'\n", ln);
      fprintf(stderr, "DOTIME=%d, genstr='%s'\n", DOTIME, 
              (mmp->genstr) ? mmp->genstr : "");
      exit(-1);
   }
   if (mmp->genstr && DOTIME)
   {
      sprintf(ln, "rm %s\n", mmp->rout);
      i = system(ln);  /* return value unused, just to shut gcc up */
   }
   if (kb != KB)
   {
      double mf;
      mf = *((double*)ReadResultsFile(RESACT, 0, fnam));
      mf = (mf / KB)*kb;
      return(mf);
   }

   return(*((double*)ReadResultsFile(RESACT, 0, fnam)));
   #undef RESACT
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
int TimeNegMMKernels            /* RET: 0 if no retiming required */
(
   int imf,                     /* index of mflop array to check/set */
   int verb,                    /* 0: no output, 1 min output, 2: full output */
   int FORCETIME,               /* 1: ignore any prior output file */
   ATL_mmnode_t *mmb,           /* ptr to mmkern struct queue */
   char pre,                    /* type/prec prefix: z,c,d,s */
   int beta,                    /* beta to time */
   int mflop,                   /* >0: force mflop MFLOPs in each time interv */
   int cflush                   /* >0: size of cache flush, else ignored */
)
{
   ATL_mmnode_t *mp;
   int RETIME=0;
   for (mp=mmb; mp; mp = mp->next)
   {
      if (mp->mflop[imf] <= 0.0)
      {
         RETIME++;
         mp->mflop[imf] = TimeMMKernel(verb, FORCETIME, mp, pre, 
                                       mp->mbB, mp->nbB, mp->kbB,
                                       mp->kbB, mp->kbB, mp->mbB, 
                                       beta, mflop, cflush);
      }
   }
   return(RETIME);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static char *GetVecStrMM(pre, vlen)
{
   if (vlen == 1)
      return("scalar");
   #ifdef ATL_AVX
      if (pre == 'd' || pre == 'z')
      {
         if (vlen == 4)
            return("avx");
         else if (vlen == 2)
            return("sse");
      }
      else if (pre == 's' || pre == 'c')
      {
         if (vlen == 8)
            return("avx");
         else if (vlen == 4)
            return("sse");
      }
   #elif defined(ATL_SSE1)
      #ifdef ATL_SSE2
         if ((pre == 'd' || pre == 'z') && vlen == 2)
               return("sse");
      #endif
      if ((pre == 's' || pre == 'c') && vlen == 4)
         return("sse");
   #endif
/*
 * Any vector length > 1 that isn't one of our known cases uses gnuvec
 */
   return("gvec");
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static void FillInMMGenStrings
(
   char pre,
   ATL_mmnode_t *mmb,  /* queue to look through */
   char *dir           /* output directory to generate into */
)
/*
 * Creates GenString for any ID=0 in mmb
 */
{
   ATL_mmnode_t *mp;
   char *frm="make gen_amm_%s lat=%d mu=%d nu=%d ku=%d kb=%d vlen=%d rt=%s/%s kmaj=%d";
   int frml;

   frml = strlen(frm);
   for (mp=mmb; mp; mp = mp->next)
   {
      if (mp->ID == 0)  /* is generated file */
      {
         int ll;
         char *sp, *vec;
         int vlen = mp->vlen;

         assert(mp->rout);  /* should have been filled in by search */
         ll = frml + strlen(dir) + strlen(mp->rout) + 8;
         sp = malloc(ll*sizeof(char));
         assert(sp);

         vec = GetVecStrMM(pre, mp->vlen);

         sprintf(sp, frm, vec, mp->lat, mp->mu, mp->nu,
                 mp->ku, FLAG_IS_SET(mp->flag, MMF_KRUNTIME) ? 0 : mp->kbB,
                 vlen, dir, mp->rout, mp->kmaj);
         mp->genstr = sp;
      }
   }
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static ATL_mmnode_t *TimeMMFileWithPath
(
   char pre, 
   char *path, 
   char *file, 
   int imf,                     /* index of mflop array to check/set */
   int verb,                    /* 0: no output, 1 min output, 2: full output */
   int FORCETIME,               /* 1: ignore any prior output file */
   int beta,                    /* beta to time */
   int mflop,                   /* >0: force mflop MFLOPs in each time interv */
   int cflush                   /* >0: size of cache flush, else ignored */
)
{
   ATL_mmnode_t *mmb;
   mmb = ReadMMFileWithPath(pre, path, file);
   FillInMMGenStrings(pre, mmb, "");
   if (TimeNegMMKernels(imf, verb, FORCETIME, mmb, pre, beta, mflop, cflush))
      WriteMMFileWithPath(pre, path, file, mmb);
   return(mmb);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
void TimeAllMMKernels
(
   int itime,                   /* index of mflop array to set */
   int verb,                    /* 0: no output, 1 min output, 2: full output */
   int FORCETIME,               /* 1: ignore any prior output file */
   ATL_mmnode_t *mmb,           /* ptr to mmkern struct queue */
   char pre,                    /* type/prec prefix: z,c,d,s */
   int lda,                     /* >0: lda to use, else kb */
   int ldb,                     /* >0: ldb to use, else kb */
   int ldc,                     /* >0: ldc to use, else mb+8 */
   int beta,                    /* beta to time */
   int mflop,                   /* >0: force mflop MFLOPs in each time interv */
   int cflush                   /* >0: size of cache flush, else ignored */
)
{
   ATL_mmnode_t *mmp;
   for (mmp=mmb; mmp; mmp = mmp->next)
      mmp->mflop[itime] = TimeMMKernel(verb, FORCETIME, mmp, pre, 
                                       mmp->mbB, mmp->nbB, mmp->kbB,
                                       (lda >= 0) ? lda : mmp->kbB, 
                                       (ldb >= 0) ? ldb : mmp->kbB, 
                                       (ldc >= 0) ? ldc : mmp->mbB+8, 
                                       beta, mflop, cflush);
}

double TimeTSKernel
(
   int verb,                    /* 0: no output, 1 min output, 2: full output */
   int FORCETIME,               /* 1: ignore any prior output file */
   char pre,                    /* type/prec prefix: z,c,d,s */
   int mb,                      /* triangle is mbxmb (kb=mb) */
   int nb,                      /* NRHS */
   int mflop                    /* >0: force mflop MFLOPs in each time interv */
)
{
   int i, DOTIME=1;
   char ln[2048], resf[256];

   if (FORCETIME)
      strcpy(resf, "res/tmpout.ktim");
   else
   {
      sprintf(resf, "res/%ctrsm%dx%d_F%d.ktim", pre, mb, nb, mflop);
      DOTIME = !FileExists(resf);
   }

   if (DOTIME)
   {
      i = sprintf(ln, "make %ctrsmKtime mb=%d nb=%d outF=\" -f %s \"", 
                  pre, mb, nb, resf);
      if (mflop)
         i += sprintf(ln+i, " FMF=%d", mflop);

      sprintf(ln+i, "\n");
      if (verb > 1)
         printf("SYSTEM: %s", ln);
      if (system(ln))
      {
         fprintf(stderr, "ERROR IN COMMAND: %s", ln);
         fprintf(stderr, "   PROPOSED FILENAME: %s\n", resf);
         sprintf(ln, "rm -f %s\n", resf);
         assert(!system(ln));
         exit(-1);
      }
   }
   return(*((double*)ReadResultsFile(0, 0, resf)));
}

#endif  /* end guard around atlas_@(rt)testtime.h */
@ROUT getflagarrs

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static int *GetIntList1(int ival)
/*
 * returns integer array with iarr[0] = 1, iarr[1] = ival
 */
{
   int *iarr;
   iarr = malloc(2*sizeof(int));
   assert(iarr);
   iarr[0] = 1;
   iarr[1] = ival;
   return(iarr);
}

#ifdef TYPE
@iexp ip @(ip) 1 +
/* procedure @(ip) */
static TYPE *GetTypeList1(const SCALAR val)
/*
 * Returns a TYPE array with arr[0] = 1.0, arr[1] = val
 */
{
   TYPE *arr;
   arr = malloc(ATL_MulBySize(2));
   assert(arr);
   arr[0] = 1;
   #ifdef TCPLX
      arr[2] = *val;
      arr[3] = val[1];
   #else
      arr[1] = val;
   #endif
   return(arr);
}
#endif

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static int *GetIntList2(int ival1, int ival2)
/*
 * returns integer array with iarr[0] = 1, iarr[1] = ival1, ival[2] = ival2
 */
{
   int *iarr;
   iarr = malloc(3*sizeof(int));
   assert(iarr);
   iarr[0] = 1;
   iarr[1] = ival1;
   iarr[2] = ival2;
   return(iarr);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static int *DupIntList(int *list)
/*
 * Duplicates list of integers, list[0] holds the length, not including 0
 */
{
   int i, n, *ip;

   assert(list);
   n = list[0] + 1;
   ip = malloc(sizeof(int)*n);
   assert(ip);
   for (i=0; i < n; i++)
      ip[i] = list[i];
   return(ip);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static int *GetIntList(int nargs, char **args, int i, int nmul)
/*
 * Gets a list of integers, whose length is given by atoi(args[i])*nmul
 * list is this length+1, since 0'th location gets atoi(args[i])
 */
{
   int n, *iarr, k;

   if (++i >= nargs)
      PrintUsage(args[0], i, NULL);
   n = atoi(args[i]) * nmul;
   assert(n > 0);
   iarr = malloc(sizeof(int)*(n+1));
   assert(iarr);
   
   iarr[0] = n / nmul;
   for (k=0; k < n; k++)
   {
      if (++i >= nargs)
         PrintUsage(args[0], i, NULL);
      iarr[k+1] = atoi(args[i]);
   }
   return(iarr);
}

#ifdef TYPE
@iexp ip @(ip) 1 +
/* procedure @(ip) */
static TYPE *GetTypeList(int nargs, char **args, int i, int nmul)
/*
 * Gets a list of TYPEs, whose length is given by atoi(args[i])*nmul
 * list is this length+1, since 0'th location gets atof(args[i])
 */
{
   int n, k;
   TYPE *arr;

   if (++i >= nargs)
      PrintUsage(args[0], i, NULL);
   n = atoi(args[i]) * nmul;
   assert(n > 0);
   arr = malloc(ATL_MulBySize(n+1));
   assert(arr);
   
   arr[0] = n / nmul;
   for (k=0; k < n; k++)
   {
      if (++i >= nargs)
         PrintUsage(args[0], i, NULL);
      arr[k+(1 SHIFT)] = atof(args[i]);
   }
   return(arr);
}
#endif

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static int *IntRange2IntList(int N0, int NN, int incN)
{
   int i, n;
   int *iarr;

   for (i=N0, n=0; i <= NN; i += incN) n++;
   iarr = malloc(sizeof(int)*(n+1));
   assert(iarr);
   iarr[0] = n;
   for (i=N0, n=1 ; i <= NN; i += incN, n++)
      iarr[n] = i;
   return(iarr);
}
@ROUT atlas_service.h
#ifndef ATLAS_SERVICE_H
   #define ATLAS_SERVICE_H

#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#ifdef __GNUC__
/*
 * This routine overrides system tmpnam when compiling with GNU, which
 * issues an unkillable warning whenever you use this standard ANSI C
 * routine, telling you to use a non-standard routine instead.  If we
 * are being compiled by gnu gcc, use the non-standard routine in order to shut
 * the warnings up.  Here we hope they won't stop supporting a routine
 * that they force you to use.
 */
#ifdef L_tmpnam
  #undef L_tmpnam
#endif
#define L_tmpnam 16
static char *ATL_tmpnam(char *s)
/*
 * Works like ISO standard C's tmpnam: returns a ptr to a safe temporary
 * filename.  If s is NULL, the return pointer points at a static string
 * that is overwritten on the next call.  If s is non-NULL, return it,
 * and write string to user-controlled buffer s.
 * NOTE: this routine is not thread safe if you pass NULL.
 */
{
   static char *buff=NULL;
   char *sp;
   int n, i;
   
   sp = tempnam(NULL, "attmp");
   assert(sp);
   if (s)
   {
      strcpy(s, sp);
      free(sp);
      return(s);
   }
   if (buff)
      free(buff);
   n = strlen(sp) + 1;
   buff = malloc(sizeof(char)*i);
   strcpy(buff, sp);
   free(sp);
   return(buff);
}
   #define tmpnam ATL_tmpnam
#else
   #define ATL_tmpnam tmpnam
#endif

#endif
@ROUT atlas_Tvec.h
@iexp ip 0 0 +
#ifndef ATL_Tvec_H
   #define ATL_Tvec_H

#include "atlas_genparse.h"


typedef struct ATL_Tvec ATL_tvec_t;
struct ATL_Tvec
{
   void *vp;            /* pointer to vector, type in pre */
   char *name;          /* name of vector (eg, "MFLOP" or "N") */
   ATL_tvec_t *next;
   int  N;              /* # of elements in vector (inclucing reps) */
   int nrep;            /* # of repititions in timings */
   char pre;            /* double (d), string (s), char (c), integer (i) */
};

typedef struct ATL_tvstrq ATL_tvstrq_t;
struct ATL_tvstrq
{
   char *sp;
   ATL_tvstrq_t *next;
   int len;
};

@iexp ip @(ip) 1 +
/* procedure @(ip) */
@define tvr @ATL_tvstrq_t *ATL_GetStrNode(char *name)@
@define tve @Allocates node & new string dup, returns node ptr@
ATL_tvstrq_t *ATL_GetStrNode(char *name)
{
   ATL_tvstrq_t *np;
   np = malloc(sizeof(ATL_tvstrq_t));
   assert(np);
   np->sp = DupString(name);
   assert(np->sp);
   np->len = strlen(name);
   strncpy(np->sp, name, np->len+1);
   np->next = NULL;
   return(np);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
@define tvr @ATL_tvstrq_t *ATL_KillStrNode(ATL_tvstrq_t *kp)@
@define tve @Deallocates node & string, returns next@
ATL_tvstrq_t *ATL_KillStrNode(ATL_tvstrq_t *kp)
{
   ATL_tvstrq_t *kn=NULL;
   if (kp)
   {
      kn = kp->next;
      if (kp->sp)
         free(kp->sp);
      free(kp);
   }
   return(kn);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
@define tvr @void ATL_KillStrQ(ATL_tvstrq_t *kb)@
@define tve @Deallocates entire string queue@
void ATL_KillStrQ(ATL_tvstrq_t *kb)
{
   while (kb)
      kb = ATL_KillStrNode(kb);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
@define tvr @ATL_tvstrq_t *RemoveStrNodeFromQ(ATL_tvstrq_t *b, ATL_tvstrq_t *p)@
@define tve @removes p from Q b, sets p->next=NULL, returns new b@
ATL_tvstrq_t *RemoveStrNodeFromQ(ATL_tvstrq_t *b, ATL_tvstrq_t *p)
/*
 * Safely removes p from queue b, returns possibly changed b
 */
{
   if (!b)
      return(NULL);
   if (!p)
      return(b);
   if (p == b)
      b = b->next;
   else
   {
      ATL_tvstrq_t *prev=b, *qp;
      for (qp=b->next; qp; qp = qp->next)
         prev=qp;
      prev->next = p->next;
   }
   p->next = NULL;
   return(b);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
@define tvr @char **ATL_StrQ2Arr(ATL_tvstrq_t *qb, int *N)@
@define tve @Kills qb to make N+1-length NULL-term array of strings instead@
char **ATL_StrQ2Arr(ATL_tvstrq_t *qb, int *N)
/*
 * translates qb to a NULL-term array of strings, destroying qb in process
 */
{
   int n, i;
   char **sarr;
   ATL_tvstrq_t *qp;

   n = *N = ATL_CountStrNodes(qb);
   sarr = malloc((n+1)*sizeof(char*));
   assert(sarr);

   sarr[n] = NULL;
   for (i=0,qp=qb; qp; i++,qp = qp->next)
   {
      sarr[i] = qp->sp;
      qp->sp = NULL;
   }
   ATL_KillStrQ(qb);
   return(sarr);
}


@iexp ip @(ip) 1 +
/* procedure @(ip) */
@define tvr @int ATL_CountStrNodes(ATL_tvstrq_t *qb)@
@define tve @Returns number of nodes in qb@
int ATL_CountStrNodes(ATL_tvstrq_t *qb)
{
   int i;
   ATL_tvstrq_t *qp;
   for (i=0,qp=qb; qp; i++, qp=qp->next);
   return(i);
}
@iexp ip @(ip) 1 +
/* procedure @(ip) */
@define tvr @ATL_tvstrq_t *ATL_ReverseStrQ(ATL_tvstrq_t *oq)@
@define tve @Returns oq in reverse order@
ATL_tvstrq_t *ATL_ReverseStrQ(ATL_tvstrq_t *oq)
/*
 * RETURNS: Reversed order queue of strings (original is reordered)
 */
{
   ATL_tvstrq_t *nq=NULL, *qp;
   while (oq)
   {
      qp = oq;
      oq = oq->next;
      qp->next = nq;
      nq = qp;
   }
   return(nq);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
@define tvr @ATL_tvec_t *ATL_GetTvec(char *name, int N, int nrep, char pre)@
@define tve @Returns allocated Tvec struct, next is NULL, vp alloc, but not init@
ATL_tvec_t *ATL_GetTvec(char *name, int N, int nrep, char pre)
{
   ATL_tvec_t *tp;
   int i;

   tp = malloc(sizeof(ATL_tvec_t));
   i = strlen(name);

   tp->name = malloc(sizeof(char)*(strlen(name)+1));
   strcpy(tp->name, name);
   tp->N = N;
   tp->nrep = nrep;
   tp->next = NULL;
   tp->pre = pre;
   i = N;
   if (pre == 's')
      i *= sizeof(char*);
   else if (pre == 'd')
      i *= sizeof(double);
   else 
      i *= (pre == 'i') ? sizeof(int) : sizeof(char);
   tp->vp = malloc(N*sizeof(double));
   assert(tp->vp);
   return(tp);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
@define tvr @ATL_tvec_t *ATL_KillThisTvec(ATL_tvec_t *tp)@
@define tve @Frees all internal ptrs, frees arg tvec (tp), returns tp->next@
ATL_tvec_t *ATL_KillThisTvec(ATL_tvec_t *tp)
{
   ATL_tvec_t *retp=NULL;

   if (tp)
   {
      if (tp->pre == 's')
      {
         char **sp = tp->vp;
         int i;

         for (i=0; i < tp->N; i++)
            free(sp[i]);
         free(sp);
      }
      else
         free(tp->vp);
      free(tp->name);
      retp = tp->next;
      free(tp);
   }
   return(retp);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
@define tvr @void ATL_KillAllTvecs(ATL_tvec_t *tq)@
@define tve @Frees all Tvecs (and internals) in list@
void ATL_KillAllTvecs(ATL_tvec_t *tq)
{
   while (tq)
      tq = ATL_KillThisTvec(tq);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
@define tvr @void ATL_ReadDoubleTvec(FILE *fpin, int N, double *dp)@
@define tve @Reads in N doubles from fpin into dp@
void ATL_ReadDoubleTvec(FILE *fpin, int N, double *dp)
{
   int i;

   for (i=0; i < N; i++)
      assert(fscanf(fpin, "%lf\n", dp+i) == 1);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
@define tvr @void ATL_ReadIntTvec(FILE *fpin, int N, int *ip)@
@define tve @Reads in N int from fpin into ip@
void ATL_ReadIntTvec(FILE *fpin, int N, int *ip)
{
   int i;

   for (i=0; i < N; i++)
      assert(fscanf(fpin, "%d\n", ip+i) == 1);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
@define tvr @ATL_ReadCharTvec(FILE *fpin, int N, char *cp)@
@define tve @Reads in N chars from fpin into cp@
void ATL_ReadCharTvec(FILE *fpin, int N, char *cp)
{
   int i;

   for (i=0; i < N; i++)
      assert(fscanf(fpin, "%c\n", cp+i) == 1);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
@define tvr @ATL_ReadStringTvec(FILE *fpin, int N, char **sa)@
@define tve @Reads in N strings from fpin into sa@
void ATL_ReadStringTvec(FILE *fpin, int N, char **sa)
{
   int i;

   for (i=0; i < N; i++)
   {
      char *sp;
      int n, j;
      char ln[512];

      assert(fgets(ln, 512, fpin));
      n = strlen(ln) + 1;
      sa[i] = sp = malloc(sizeof(char)*n);
      assert(sp);
      for (j=0; j < n; j++)
         sp[j] = ln[j];
   }
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
@define tvr @ATL_tvec_t *ATL_ReadTvec(FILE *fpin)@
@define tve @Returns one tvec read in from fpin@
ATL_tvec_t *ATL_ReadTvec(FILE *fpin)
{
   int N, nrep;
   char nm[64], pre;
   ATL_tvec_t *tp;

   assert(fscanf(fpin, "%s\n", nm) == 1);
   assert(fscanf(fpin, "%d %d %c", &N, &nrep, &pre) == 3);
   tp = ATL_GetTvec(nm, N, nrep, pre);
   if (pre == 'd')
     ATL_ReadDoubleTvec(fpin, N, tp->vp);
   else if (pre == 'i')
     ATL_ReadIntTvec(fpin, N, tp->vp);
   else if (pre == 'c')
     ATL_ReadCharTvec(fpin, N, tp->vp);
   else /* if (pre == 's') */
     ATL_ReadStringTvec(fpin, N, tp->vp);
   return(tp);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
@define tvr @ATL_tvec_t *ATL_ReadTvecFile(FILE *fpin, char **cmnt, int *nvec)@
@define tve @Return all tvecs from file fpin (fpin at beginning of file!)@
ATL_tvec_t *ATL_ReadTvecFile(FILE *fpin, char **cmnt, int *nvec)
/*
 * Reads an entire timing vector file.
 * RETURNS: linked list of timing vectors
 */
{
   int i, n;
   char ln[512];
   ATL_tvec_t *tb, *tp;

   if (!fgets(ln, 512, fpin))
      return(NULL);
   n = strlen(ln);
   while (n > 0 && isspace(ln[n-1]))
      ln[--n] = '\0';;
   *cmnt = malloc(sizeof(char)*n);
   assert(*cmnt);
   strcpy(*cmnt, ln+1);
   assert(fscanf(fpin, " %d\n", nvec) == 1);

   n = *nvec;
   if (n < 1)
      return(NULL);

   tb = tp = ATL_ReadTvec(fpin);
   for (i=1; i < n; i++)
   {
      tp->next = ATL_ReadTvec(fpin);
      tp = tp->next;
   }
   return(tb);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
@define tvr @void ATL_WriteTvec(FILE *fpout, ATL_tvec_t *tp)@
@define tve @Write a single timing vector to the stream fpout@
void ATL_WriteTvec(FILE *fpout, ATL_tvec_t *tp)
/*
 * Write a single timing vector to the stream fpout
 */
{
   fprintf(fpout, "%s\n", tp->name);
   fprintf(fpout, "%d %d %c\n", tp->N, tp->nrep, tp->pre);
   if (tp->pre == 'd')
   {
      double *dp = tp->vp;
      const int n = tp->N;
      int i;
      for (i=0; i < n; i++)
         fprintf(fpout, "%le\n", dp[i]);
   }
   else if (tp->pre == 'i')
   {
      int *ip = tp->vp;
      const int n = tp->N;
      int i;
      for (i=0; i < n; i++)
         fprintf(fpout, "%d\n", ip[i]);
   }
   else if (tp->pre == 'c')
   {
      char *cp = tp->vp;
      const int n = tp->N;
      int i;
      for (i=0; i < n; i++)
         fprintf(fpout, "%c\n", cp[i]);
   }
   else /* if (tp->pre == 's') */
   {
      char **sp = tp->vp;
      const int n = tp->N;
      int i;
      for (i=0; i < n; i++)
         fprintf(fpout, "%s\n", sp[i]);
   }
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
@define tvr @void ATL_WriteTvecs(FILE *fpout, ATL_tvec_t *tp)@
@define tve @Writes list of tvecs assuming stream already has preamble in it@
void ATL_WriteTvecs(FILE *fpout, ATL_tvec_t *tp)
/*
 * Writes out a queue of output vectors to a stream that has already had
 * the preample (name, nvec, nrep) written to it
 */
{
   while (tp)
   {
      ATL_WriteTvec(fpout, tp);
      tp = tp->next;
   }
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
@define tvr @void ATL_WriteTvecFile(FILE *fpout, char *cmnt, int nvec, ATL_tvec_t *tp)@
@define tve @Writes the entire output file given a queue of timing vectors@
void ATL_WriteTvecFile(FILE *fpout, char *cmnt, int nvec, ATL_tvec_t *tp)
/*
 * Writes the entire output file given a queue of timing vectors 
 */
{
   int i;
   fprintf(fpout, "#%s\n", cmnt);
   fprintf(fpout, "%d\n", nvec);
   ATL_WriteTvecs(fpout, tp);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
@define tvr @ATL_tvec_t *ATL_FindTvecByName(ATL_tvec_t *tb, char *name)@
@define tve @Returns first tvec with name name (NULL if not found)@
ATL_tvec_t *ATL_FindTvecByName(ATL_tvec_t *tb, char *name)
{
   ATL_tvec_t *tp;
   for (tp=tb; tp && strcmp(tp->name, name); tp = tp->next);
   return(tp);
}

@whiledef typ double int char
@iexp ip @(ip) 1 +
/* procedure @(ip) */
@define tvr @void ATL_FillComb@up@(typ)VecUsingInts@
@define tve @Merges two tvecs, go read the function@
void ATL_FillComb@up@(typ)VecUsingInts
(
   ATL_tvec_t *np,    /* combined vector */
   ATL_tvec_t *ip1,   /* 1st index array (we sort cp1 & cp2 on these ivecs) */
   ATL_tvec_t *ip2,   /* 2nd index array (we sort cp1 & cp2 on these ivecs) */
   ATL_tvec_t *cp1,   /* 1st array to be combined */
   ATL_tvec_t *cp2    /* 2st array to be combined */
)
{
   @(typ) *dn = np->vp;
   const @(typ) *d1 = cp1->vp, *d2 = cp2->vp;
   const int *s1 = ip1->vp, *s2 = ip2->vp;
   const int n = np->N, n1 = cp1->N, n2 = cp2->N;
   int ic, i1, i2;

   for (ic=i1=i2=0; ic < n; ic++)
   {
      if (i1 < n1)
      {
         if (i2 < n2)  /* both are available for comparison */
         {
            if (s1[i1] <= s2[i2])
               dn[ic] = d1[i1++];
            else
               dn[ic] = d2[i2++];
         }
         else
         {
            assert(i1 < n1);
            dn[ic] = d1[i1++];
         }
      }
      else
      {
         assert(i2 < n2);
         dn[ic] = d2[i2++];
      }
   }
}
@endwhile

@iexp ip @(ip) 1 +
/* procedure @(ip) */
@define tvr @ATL_tvec_t *ATL_CombineTheseVecsUsingInts@
@define tve @Merges two tvecs, go read the function@
ATL_tvec_t *ATL_CombineTheseVecsUsingInts
(
   ATL_tvec_t *sp1,      /* 1st vector's index array to sort on */
   ATL_tvec_t *sp2,      /* 2nd vector's index array to sort on */
   ATL_tvec_t *cp1,      /* vector to be combined */
   ATL_tvec_t *cp2       /* vector to be combined */
)
{
   ATL_tvec_t *np;
   const pre = cp1->pre;

   assert(sp1->N == cp1->N && sp2->N == cp2->N);
   assert(sp1->pre == sp2->pre && sp1->pre == 'i');
   assert(pre == cp2->pre);
   assert(sp1->nrep == sp2->nrep && sp1->nrep == cp1->nrep && 
          sp1->nrep == cp2->nrep);
   np = ATL_GetTvec(cp1->name, cp1->N+cp2->N, cp1->nrep, pre);
   if (pre == 'i')
      ATL_FillCombINTVecUsingInts(np, sp1, sp2, cp1, cp2);
   else if (pre == 'd')
      ATL_FillCombDOUBLEVecUsingInts(np, sp1, sp2, cp1, cp2);
   else if (pre == 'c')
      ATL_FillCombCHARVecUsingInts(np, sp1, sp2, cp1, cp2);
   return(np);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
@define tvr @void ATL_SuffixTvecNames(ATL_tvec_t *tb, char *suff)@
@define tve @suffix all names in tb with suff@
void ATL_SuffixTvecNames
(
   ATL_tvec_t *tb,   /* list whose names should be suffixed */
   char *suff 
)
{
   ATL_tvec_t *tp;
   int isu;

   isu = strlen(suff) + 1;
   for (tp=tb; tp; tp = tp->next)
   {
      int i, inm, n;
      char *sp;

      inm = strlen(tp->name);
      sp = malloc((inm+isu)*sizeof(char));
      for (i=0; i < inm; i++)
         sp[i] = tp->name[i];
      for (n=inm+isu; i < n; i++)
         sp[i] = suff[i-inm];
      free(tp->name);
      tp->name = sp;
   }
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
@define tvr @ATL_tvec_t *ATL_DupTvec(ATL_tvec_t *t0)@
@define tve @Return newly allocated tvec identical to t0, except ->next is NULL@
ATL_tvec_t *ATL_DupTvec(ATL_tvec_t *t0)
{
   ATL_tvec_t *tp;
   const int N = t0->N;
   int i;

   tp = ATL_GetTvec(t0->name, N, t0->nrep, t0->pre);
   tp->next = NULL;
   if (t0->pre == 'd')
   {
      double *d0 = t0->vp, *d=tp->vp;
      for (i=0; i < N; i++)
         d[i] = d0[i];
   }
   else if (t0->pre == 'i')
   {
      int *d0 = t0->vp, *d=tp->vp;
      for (i=0; i < N; i++)
         d[i] = d0[i];
   }
   else /* pre == 'c' */
   {
      char *d0 = t0->vp, *d=tp->vp;
      assert(t0->pre == 'c');
      for (i=0; i < N; i++)
         d[i] = d0[i];
   }
   return(tp);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
@define tvr @void ATL_AdhereTvec(ATL_tvec_t *dp, ATL_tvec_t *sp)@
@define tve @Stick data in sp->vp to end of dp->vp, sp not changed@
void ATL_AdhereTvec
/*
 * Concatonates sp's Tvec entries to the end of dp's.
 */
(
   ATL_tvec_t *dp,      /* destination Tvec */
   ATL_tvec_t *sp       /* source Tvec */
)
{
   ATL_tvec_t *tp;

   if (!sp)
      return;
   assert(dp);
   assert(dp->pre == sp->pre);
   assert(dp->nrep == sp->nrep);
   if (dp->pre == 's')
   {
      const int Nd = dp->N, Ns = sp->N, Nt = Nd+Ns;
      char **sd, **ss;
      int i;
      sd = malloc(Nt * sizeof(char *));
      for (ss=dp->vp, i=0; i < Nd; i++)
         sd[i] = ss[i];
      free(dp->vp);
      dp->vp = sd;
      dp->N = Nt;
      for (ss=sp->vp, i=0; i < Ns; i++)
         sd[i+Nd] = DupString(ss[i]);
   }
   else
   {
      const int Nd = dp->N, Ns = sp->N, Nt = Nd+Ns;
      int sz;
      char *cp;
      if (dp->pre == 'd')
         sz = sizeof(double);
      else
         sz = (dp->pre == 'i') ? sizeof(int) : sizeof(char);
      cp = malloc(Nt*sz);
      assert(cp);
      memcpy(cp, dp->vp, Nd*sz);
      free(dp->vp);
      dp->vp = cp;
      dp->N = Nt;
      memcpy(cp+Nd*sz, sp->vp, Ns*sz);
   }
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
@define tvr @ATL_tvec_t *ATL_ReverseTvecList(ATL_tvec_t *tb)@
@define tve @Reverse order in list tb@
ATL_tvec_t *ATL_ReverseTvecList  /* RETURNS: reversed list base */
(
   ATL_tvec_t *tb0              /* base of list to reverse */
)
{
   ATL_tvec_t *tb=NULL;
   while (tb0)
   {
      ATL_tvec_t *tp;
      tp = tb0;
      tb0 = tb0->next;
      tp->next = tb;
      tb = tp;
   }
   return(tb);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
@define tvr @ATL_tvec_t *ATL_DupNamedVecsFromList(int N, char** nm, tvec_t *tb, int order)@
@define tve @Returns dups of named vectors from tb; repeat names not duped!@
ATL_tvec_t *ATL_DupNamedVecsFromList  /* returns list of duped vecs */
(
   int N,               /* # of vectors to dup from list to */
   char **names,        /* names of vectors to duplicate */
   ATL_tvec_t *tb0,     /* original list unchanged */
   int order            /* 0: unordered, else: keep in same order as names */
)
{
   ATL_tvec_t *tb=NULL, *tp;
   int i;

   if (!tb0 || N < 1)
      return(NULL);

   for (i=0; i < N; i++)
   {
      tp = ATL_FindTvecByName(tb0, names[i]);
      assert(tp);
      tp = ATL_DupTvec(tp);
      tp->next = tb;
      tb = tp;
   }
   if (order)
      tb = ATL_ReverseTvecList(tb);
   return(tb);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
@define tvr @ATL_tvec_t *ATL_RemoveTvecFromList(ATL_tvec_t *bp, ATL_tvec_t *rp)@
@define tve @Returns new bp after removing rp from bp@
ATL_tvec_t *ATL_RemoveTvecFromList   /* RETURNS: possibly changed base */
(
   ATL_tvec_t *bp, 
   ATL_tvec_t *rp
)
{
   ATL_tvec_t *tp = bp, *prev;
   if (!bp)
      return(NULL);
   if (bp == rp)
      return(bp->next);

   prev=tp;
   for (tp=tp->next; tp; tp = tp->next)
   {
      if (tp == rp)
      {
         prev->next = tp->next;
         break;
      }
      prev = tp;
   }
   return(bp);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
@define tvr @ATL_tvec_t *ATL_PullNamedVecsFromListWithDups(int N, char **names, tvec_t bp)@
@define tve @Returns new list of all named tvecs, which are removed from bp@
ATL_tvec_t *ATL_PullNamedVecsFromListWithDups  /* returns list of pulled vecs */
(
   int N,               /* # of vectors to remove from list to */
   char **names,        /* names of vectors to grab */
   ATL_tvec_t **orig    /* original list has names removed */
)
/*
 * Note that the names will be returned in the provided order, with all
 * repeats of a given name contiguous in the list (so in name order, then
 * file order only within names).
 */
{
   ATL_tvec_t *ob=(*orig), *nb=NULL, *tp;
   int i;
   if (!ob || N < 1)
      return(NULL);
   for (i=0; i < N; i++)
   {
/*
 *    Remove all mentions of selected name, add to new list in reverse order
 */
      while ( (tp = ATL_FindTvecByName(ob, names[i])) )
      {
         ob = ATL_RemoveTvecFromList(ob, tp);
         tp->next = nb;
         nb = tp;
      }
   }
   *orig = ob;
   return(ATL_ReverseTvecList(nb));
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
@define tvr @ATL_tvec_t *ATL_PullNamedVecsFromList(int N, char **names, ATL_tvec_t bp)@
@define tve @Returns list of first instance of named tvecs, which are removed from bp@
ATL_tvec_t *ATL_PullNamedVecsFromList  /* returns list of pulled vecs */
(
   int N,               /* # of vectors to remove from list to */
   char **names,        /* names of vectors to grab */
   ATL_tvec_t **orig    /* original list has names removed */
)
/*
 * Note that the names will be returned in the provided order, and that
 * we assume a name only appears once in orig.
 */
{
   ATL_tvec_t *prev, *old=(*orig), *po, *pn, *nb=NULL;
   int i;
   if (!old || N < 1)
      return(NULL);
   for (i=0; i < N; i++)
   {
      prev = NULL;
      po = old;
      while (po)
      {
         if (!strcmp(names[i], po->name))
         {
            if (po == old)
               old = old->next;
            if (nb)
            {
               pn->next = po;
               pn = po;
            }
            else
               pn = nb = po;
            if (prev)
               prev->next = po->next;
            pn->next = NULL;
            break;
         }
         prev = po;
         po = po->next;
      }
   }
   *orig = old;
   return(nb);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
@define tvr @int ATL_CountTvecsInList(ATL_tvec_t *tb)@
@define tve @Returns number of tvecs in tb@
int ATL_CountTvecsInList
(
   ATL_tvec_t *tb      /* list to count */
)
{
   int i;
   for (i=0; tb; i++, tb = tb->next);
   return(i);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
@define tvr @ATL_tvec_t *ATL_FindLastTvecInList(ATL_tvec_t *tb)@
@define tve @Returns last tvec in list@
ATL_tvec_t *ATL_FindLastTvecInList  /* RETURNS: last Tvec in list */
(
   ATL_tvec_t *tb      /* list to look through */
)
{
   if (tb)
   {
      while (tb->next)
         tb = tb->next;
   }
   return(tb);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
@define tvr @ATL_tvec_t *ATL_AlphabetizeVecList(int N, ATL_tvec_t *tb)@
@define tve @Alphabatizes N-len tb, and returns new ordered list (old destroyed)@
ATL_tvec_t *ATL_AlphabetizeVecList  /* returns alphabatized list */
(
   int N,              /* # of vectors in list */
   ATL_tvec_t *tb      /* list to alphabetize */
)
/*
 * Alphabatizes N-len tb, and returns new ordered list (old is destroyed).
 */
{
   char **names;
   ATL_tvec_t *tp;
   int i, j;

   names = malloc(sizeof(char*)*N);
   assert(names);
   for (i=0; tp && i < N; i++, tp = tp->next)
      names[i] = tp->name;
   assert(i == N);
/*
 * Sort names using selection sort
 */
   for (j=0; j < N-1; j++)
   {
      for (i=j+1; i < N; i++)
      {
         if (strcmp(names[i], names[j]) < 0)
         {
            char *sp = names[j];
            names[j] = names[i];
            names[i] = sp;
         }
      }
   }
/*
 * Use sorted names to make new alphabetical list, free names and return list
 */
   tb = ATL_PullNamedVecsFromList(N, names, &tb);
   free(names);
   return(tb);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
@define tvr @void ATL_CopyStridedVec(char pre, int n, int inc, void *vin, void *vout)@
@define tve @copies every inc elts of vin to vout@
void ATL_CopyStridedVec(char pre, int n, int inc, void *vin, void *vout)
{
   if (pre == 'd')
   {
      int i, j;
      double *in = vin, *out = vout;
      for (j=i=0; i < n; i++, j += inc)
         out[i] = in[j];
   }
   else if (pre == 'i')
   {
      int i, j;
      int *in = vin, *out = vout;
      for (j=i=0; i < n; i++, j += inc)
         out[i] = in[j];
   }
   else if (pre == 'c')
   {
      int i, j;
      char *in = vin, *out = vout;
      for (j=i=0; i < n; i++, j += inc)
         out[i] = in[j];
   }
   else if (pre == 's')
   {
      int i, j;
      char **in = vin, **out = vout;
      for (j=i=0; i < n; i++, j += inc)
      {
         int n;
         n = strlen(in[i]) + 1;
         out[i] = malloc(n*sizeof(char));
         strcpy(out[i], in[j]);
      }
   }
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
@define tvr @void ATL_PrintTvecElt(FILE *fpout, ATL_tvec_t *tp, int idx)@
@define tve @Print element idx of tp->vp@
void ATL_PrintTvecElt
(
   FILE *fpout,         /* stream to print to */
   ATL_tvec_t *tp,      /* vector to print from */
   int idx              /* index in vector to print */
)
{
   if (tp->pre == 'd')
   {
      double *p = tp->vp;
      fprintf(fpout, "%e", p[idx]);
   }
   else if (tp->pre == 'i')
   {
      int *p = tp->vp;
      fprintf(fpout, "%12d", p[idx]);
   }
   else if (tp->pre == 'c')
   {
      char *p = tp->vp;
      fprintf(fpout, "%c", p[idx]);
   }
   else if (tp->pre == 's')
   {
      char **p = tp->vp;
      fprintf(fpout, "%s", p[idx]);
   }
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
@define tvr @void ATL_PrintTvecsInRow(FILE *fpout, ATL_tvec_t *tb, char *sep, int head)@
@define tve @Prints tb, 1 elt per line tvec cols seperated by sep@
void ATL_PrintTvecsInRow
(
   FILE *fpout,         /* stream to print to */
   ATL_tvec_t *tb,      /* list of vectors to print (rowwise) */
   char *sep,           /* string to print between elements */
   int head             /* should we print headers? */
)
{
   ATL_tvec_t *tp;
   const int N = tb->N;
   int i;

   if (!tb)
      return;
   for (tp=tb->next; tp; tp = tp->next)
      assert(tp->N >= N);

   if (head)
      for (tp=tb; tp; tp = tp->next)      /* loop over columns  */
         fprintf(fpout, "%12.12s%s", tp->name, sep);
   fprintf(fpout, "%s\n", sep);
   for (i=0; i < N; i++)                        /* loop over rows of vectors */
   {
      for (tp=tb; tp->next; tp = tp->next)      /* loop over columns  */
      {
         ATL_PrintTvecElt(fpout, tp, i);
         fprintf(fpout, "%s", sep);
      }
      ATL_PrintTvecElt(fpout, tp, i);
      fprintf(fpout, "%s\n", sep);
   }
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
@define tvr @ATL_tvec_t *ATL_GetRep1Tvec(ATL_tvec_t *tin, int istart)@
@define tve @Return new nrep=1 tvec wt only repitition istart represented@
ATL_tvec_t *ATL_GetRep1Tvec
(
   ATL_tvec_t *tin,    /* vector to split */
   int istart          /* which repetition to grab */
)
{
   char *name;
   ATL_tvec_t *t1=NULL;
   int n;
   const int Nr = tin->N / tin->nrep;
   const char pre = tin->pre;

   assert(tin->nrep < 10000000);
   n = strlen(tin->name) + 9;
   name = malloc(n*sizeof(char));
   assert(name);
   sprintf(name, "%s_%d", tin->name, istart);
   t1 = ATL_GetTvec(name, Nr, 1, pre);
   free(name);
   if (pre == 'd')
      ATL_CopyStridedVec(pre, Nr, tin->nrep,((double*)(tin->vp))+istart,t1->vp);
   else if (pre == 'i')
      ATL_CopyStridedVec(pre, Nr, tin->nrep, ((int*)(tin->vp))+istart, t1->vp);
   else if (pre == 'c')
      ATL_CopyStridedVec(pre, Nr, tin->nrep, ((char*)(tin->vp))+istart, t1->vp);
   else if (pre == 's')
      ATL_CopyStridedVec(pre, Nr, tin->nrep, ((char**)(tin->vp))+istart,t1->vp);

   return(t1);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
@define tvr @ATL_tvec_t *ATL_SplitRepsTvec(ATL_tvec_t *tin)@
@define tve @Returns list of seperate vecs for each rep (tin unchanged)@
ATL_tvec_t *ATL_SplitRepsTvec  /* returns Q of sep vecs for each rep */
(
   ATL_tvec_t *tin     /* vector to split */
)
{
   int i;
   const int nrep = tin->nrep;
   ATL_tvec_t *tb, *tp;

   tp = tb = ATL_GetRep1Tvec(tin, 0);
   for (i=1; i < nrep; i++)
   {
      tp->next = ATL_GetRep1Tvec(tin, i);
      tp = tp->next;
   }
   return(tb);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
@define tvr @ATL_tvec_t *ATL_GetStatTvecsDOUBLE(ATL_tvec_t *tin)@
@define tve @returns list of stat vectors: <,+,>@
ATL_tvec_t *ATL_GetStatTvecsDOUBLE  /* returns Q of stat vectors: <,+,> */
(
   ATL_tvec_t *tin     /* vector to get stats for */
)
{
   char *name;
   int i, j, n, N;
   ATL_tvec_t *tavg, *tmin, *tmax;
   double *dmin, *dmax, *davg;

   n = strlen(tin->name) + 5;
   name = malloc(sizeof(char)*n);
   assert(name);
   N = tin->N / tin->nrep;

   sprintf(name, "%s_min", tin->name);
   tmin = ATL_GetTvec(name, N, 1, tin->pre);
   sprintf(name, "%s_avg", tin->name);
   tavg = ATL_GetTvec(name, N, 1, tin->pre);
   sprintf(name, "%s_max", tin->name);
   tmax = ATL_GetTvec(name, N, 1, tin->pre);
   free(name);
   dmin = tmin->vp;
   dmax = tmax->vp;
   davg = tavg->vp;

   n = tin->nrep;
   for (j=0; j < N; j++)
   {
      double min, max, sum, *din;

      din = ((double*)(tin->vp)) + j*n;
      min = max = sum = *din;
      for (i=1; i < n; i++)
      {
         if (din[i] < min)
            min = din[i];
         if (din[i] > max)
            max = din[i];
         sum += din[i];
      }
      dmin[j] = min;
      dmax[j] = max;
      davg[j] = sum / n;
   }
   tmin->next = tavg;
   tavg->next = tmax;
   return(tmin);
}
/*
*******************************************************************************
*                   OVERVIEW OF FUNCTIONS IN THIS FILE                        *
*******************************************************************************
@whiledef tvr
* @(tvr)
*    @(tve)
   @undef tve
@endwhile
*******************************************************************************
*******************************************************************************
*/

#endif  /* end ifdef multi-inclusion guard */
