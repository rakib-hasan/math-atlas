@define ip @0@
@ROUT smvcases.idx dmvcases.idx cmvcases.idx zmvcases.idx
#
# In this file, any line beginning with a '#' is ignored, but the # must be in
# column 0.  All multiple whitespace is reduced to one space (i.e. used only
# to distinguish where words begin/end).  Lines may be extended by putting '\'
# as the *last* character of line.
#
# The file has the following format:
# ROUT='routine name' AUTH='author names' COMP='compiler name' FLAGS='flags'
# ID=<id> NU=<nu> MU=<mu> minN=<#> minM=<#> alignX=<#> alignY=<#> alignA=<#>,
# TA='[t,n,c]' TB='[t,n,c]' SSE=[0,1,2,3] X87=[0,1] 
# LDTOP=[0,1] ALLALIGNXY=[0,1] AXPYBASED=[0,1] GEMMBASED=[0,1] CONJDEF=[0,1]
# ASM=[asmlist], eg., asmlist is "GAS_x8664,GAS_x8632" or "GAS_SPARC"
# ASM defaults to no assembly dialect required.
# If NU/MU is negative, then the routine can only handle multiples of NU/MU.
#
# Assuming N is the length of X, and M is the length of Y, all routines
# are assumed to handle any runtime value of M >= minN, N >= minM.
# They must respect the compile-time macros BETA0, BETA1, & BETAX.
# Some less-obvious keywords:
# LDTOP     : set to 1 if load Y at top of MV loop (more error)
# CONJDEF   : Defining Conj_ will cause A to be conjugated before use
#             if 0, then can only be used for TA setting
# ALLALIGNXY: Create k copies of X and Y, where k is the number of times
#             the native alignment goes into the required alignment.  So,
#             if ALIGNX=16, and we are doing single precision, X will be
#             passed as float *X[4], and X[0] will be 16-byte aligned,
#             X[1]: 4-byte aligned, X[2]: 8-byte aligned, X[3]: 12 byte aligned
#             if ALIGN[X/Y] == native length, then this flag has no effect on
#             that vector.
# AXPYBASED : Routine employs the outer-product matvec (mainly for NoTrans)
# GEMMBASED : Kernel calls GEMM to do matvec
# PFTUNEx   : Kernel uses pref_x(mem) macro for each op=x (A,y,x).  prefetch
#             inst can be varied wt this macro, as can fetch distance.
#
@ROUT mmread
#ifndef ATLAS_MMPARSE_H
   #define ATLAS_MMPARSE_H

#include "atlas_genparse.h"
#include "atlas_enum.h"

#define MMF_SINGLE      0  /* 1: single precision, else double */
#define MMF_COMPLEX     1  /* 1: complex type, else real */
#define MMF_LDCTOP      2  /* 1: load C before K-loop, 0: ld after */
#define MMF_KRUNTIME    3  /* 1: M dim is run-time variable */
#define MMF_X87         4  /* 1: requires the Intel x87 unit */
#define MMF_AOUTER      5  /* 1: MNK loop order, 0: NMK loop order */
#define MMF_PFACOLS     6  /* 1: prefetch next mu cols of A */
#define MMF_PFABLK      7  /* 1: prefetch next KBxNB block of A */
#define MMF_PFBCOLS     8  /* 1: prefetch next nu cols of B */
#define MMF_PFCELTS     9  /* 1: pf elts of C at top of loop, load at bottom */
#define MMF_L14NB      10  /* 1: need to fit all 3 matrices+nextA in L1 */
#define MMF_MVA        11  /* 1: A expected to change between calls */
#define MMF_MVB        12  /* 1: B expected to change between calls */
#define MMF_MVC        13  /* 1: C expected to change between calls */
#define MMF_KVEC       14  /* 1: vectorize on K-dim. 0: do not vec on K dim */
#define MMF_KUISKB     15  /* 1: only works for fully unrolled, constant K */
#define MMF_NOBCAST    16  /* 1: use ld/splat to get B, rather than bcast */
#define MMF_FKO        17  /* 1: compile using FKO, else [d,s]MC */

#define MMF_MVSET  ( (1<<MMF_MVA) | (1<<MMF_MVB) | (1<<MMF_MVC) )
#define MMF_MVDEF  ( (1<<MMF_MVA) | (1<<MMF_MVB) )
#define MMF_DEFAULT ( (1<<MMF_LDCTOP) | (1<<MMF_AOUTER) | MMF_MVDEF )
#ifndef  FLAG_IS_SET
   #define FLAG_IS_SET(field_, bit_) ( ((field_) & (1<<(bit_))) != 0 )
#endif
#define ATL_MMF_MVGET(field_) (((field_) >> MMF_MVA) & 7)
#define ATL_MMF_MVPUT(field_, v_) \
   (field_) = ( ((field_) & ~MMF_MVSET) | (((v_) & 7) << MMF_MVA) )

typedef struct MMStg ATL_mmstg_t;
struct MMstg
{
   int extelts;
   short ID, flag;
   char *szfunc;
};

#define uchar unsigned char
#define uint  unsigned int
typedef struct MMNode ATL_mmnode_t;
struct MMNode
{
   ATL_mmnode_t *next;
   double mflop[8];             /* 1st entry perf using mbB, nbB, kbB */
   char *rout, *auth, *comp, *cflags;
   char *str;                   /* tmp string used in generation */
   char *genstr;                /* system(genstr) will generate gened kernel */
   char *exflags;               /* extra flags to pass test/time call */
   char *moves;                 /* -DMove[A,B,C] to use, NULL default */
   int ID, mu, nu, ku;          /* ID, and unrolling on each loop */
   int kbmin, kbmax;            /* min/max KB this kernel can handle */
   int SSE;                     /* 0: no SSE, 1: SSE1 req, 2: SSE2 req, etc */
   int vlen;                    /* vector length, 0 or 1 if scalar code */
@skip   int kmaj;                  /* k-major access storage? */
   int pref;                    /* pref strategy used */
   int pfLS;                    /* pref line size */
   int ivar;                    /* int param used for various purposes */
   int mbB, nbB, kbB;           /* best blocking dims found by search */
   int szA, szB, szC;           /* size in elts for block; 0: use normal */
   int szExtra;                 /* extra elts needed at end of alloc */
   int stgA, stgB, stgC;        /* storage ID, 0: access major */
   enum ATLAS_TRANS TA, TB;
   int asmbits;   /* bitfield indicating which assembly(ies) is required */
   uint flag;
   uchar blask;   /* 0:ammm, 1:syrk, 2:symm, 3:trmm */
};
#undef uchar
#undef uint

@ROUT r1read
#ifndef ATLAS_R1PARSE_H
   #define ATLAS_R1PARSE_H

#include "atlas_genparse.h"


#define R1F_INCACHE     0  /* consider kernel for in-cache gemv */
#define R1F_OUTCACHE    1  /* consider kernel for out-of-cache gemv */
#define R1F_ALLALIGNXY  2  /* X&Y are copied into all legal alignments */
#define R1F_ALIGNX2A    3  /* X forced to same alignment as A */
#define R1F_SINGLE      4  /* single precision */
#define R1F_COMPLEX     5  /* complex arithmetic */
#define R1F_APTRS       6  /* use ptrs rather than lda for column indexing */
#define R1F_X87         7  /* requires the Intel x87 unit */
#define R1F_FNU         8  /* N must be a multiple of NU */
#define R1F_ADDCFLAGS   9  /* don't replace: append cflags to default flags */
#define R1F_INCYISONE  10
#define R1F_NFLAGS     11
#define R1F_PFTUNABLE  14  /* Can tune PFDIST & INST? */
char *R1F_exp[R1F_NFLAGS] = 
{
"Consider kernel for in-cache use only",
"Consider kernel for out-of-cache use only",
"X&Y are copied into all legal alignments",
"X forced to have same alignment as A",
"Data uses single precision",
"Data is of complex type",
"use ptrs rather than lda for column indexing",
"Kernel requires the x87 unit for correct operation",
"N must be a multiple of NU"
};

#define R1F_DEFAULT ((1<<R1F_INCACHE) | (1<<R1F_OUTCACHE))
typedef struct R1NODE ATL_r1node_t;
struct R1NODE
{
   double mflop[8];
   ATL_r1node_t *next;
   char *rout;                  /* filename/path for kernel */
   char *auth;                  /* author of kernel */
   char *comp;                  /* particular compiler required for kernel */
   char *cflags;                /* compiler flags required for kernel */
   char *kname;                 /* The name kernel should be compiled to */
   char *str;                   /* tmp string used in generation */
   char *exflags;               /* extra flags to pass test/time call */
   char *genstr;                /* system(genstr) will generate gened kernel */
   int alignA, alignX, alignY;  /* required alignments */
   int ldamul;                  /* lda must be a multiple of ldamul */
   int ID, NU, MU;              /* unrolling for Y & X vectors */
   int NMU;                     /* # of repetitions of MU */
   int minN, minM;              /* min veclen to call the rout with */
   int SSE;                     /* 0: no SSE, 1: SSE1 req, 2: SSE2 req, etc */
   int asmbits;                 /* valid assemblies in this file */
   int CacheElts;               /* # of cache elts to assume for blocking */
   int rankR;                   /* restriction rank, higher faster kern */
   int flag;                    /* bit vector of R1F_* */
};

@ROUT mvread
#ifndef ATLAS_MVPARSE_H
   #define ATLAS_MVPARSE_H

#include "atlas_genparse.h"
#include "atlas_enum.h"

#define MVF_INCACHE     0  /* consider kernel for in-cache gemv */
#define MVF_OUTCACHE    1  /* consider kernel for out-of-cache gemv */
#define MVF_ALLALIGNXY  2  /* X&Y are copied into all legal alignments */
#define MVF_AXPYBASED   3  /* 0:ddot based, 1: axpy-based */
#define MVF_GEMMBASED   4  /* gemm-based */
#define MVF_LDYTOP      5  /* 0: load Y value after dot product */
#define MVF_CONJDEF     6  /* 1: conj(A) if Conj_ is defined */
#define MVF_X87         7  /* requires the Intel x87 unit */
#define MVF_FNU         8  /* Length of Y must be a multiple of NU */
#define MVF_SINGLE      9  /* 1: single precision, else double */
#define MVF_COMPLEX    10  /* 1: complex type, else real */
#define MVF_ADDCFLAGS  11  /* don't replace: append cflags to default flags */
#define MVF_ALIGNX2A   12  /* X (Y if AXPYBASED) forced to same alignmnt as A */
#define MVF_INCYISONE  13
#define MVF_PFTUNABLE  14  /* Can tune PFDIST & INST? */

#define MVF_DEFAULT ((1<<MVF_INCACHE) | (1<<MVF_OUTCACHE))
typedef struct MVNODE ATL_mvnode_t;
struct MVNODE
{
   double mflop[8];
   ATL_mvnode_t *next;
   char *rout, *auth, *comp, *cflags;
   char *kname;                 /* The name kernel should be compiled to */
   char *str;                   /* tmp string used in generation */
   char *genstr;                /* system(genstr) will generate gened kernel */
   char *exflags;               /* extra flags to pass test/time call */
   int alignA, alignX, alignY;  /* required alignments */
   int ldamul;                  /* lda must be a multiple of ldamul */
   int ID, NU, MU;              /* unrolling for Y & X vectors */
   int minN, minM;              /* min veclen to call the rout with */
   int CacheElts;               /* # of cache elts to assume for blocking */
   int SSE;                     /* 0: no SSE, 1: SSE1 req, 2: SSE2 req, etc */
   int asmbits;                 /* valid assemblies in this file */
   int rankR;                   /* restriction rank, higher faster kern */
   int ntlb;                    /* for dot-based alg, col blocking for TLB */
   enum ATLAS_TRANS TA;         /* transpose setting */
   int flag;                    /* bit vector of MVF_* */
};

@ROUT genparse
#ifndef ATLAS_GENPARSE_H
   #define ATLAS_GENPARSE_H

#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <string.h>
#include <ctype.h>
@extract -b @(basd)/atlconf.base rout=asmconf.h
/*
 * Basic data structure for forming queues with some minimal info
 */
typedef struct SIDNode ATL_sidnode_t;
struct SIDNode  /* holds string, integer, and double */
{
   double d;
   char *str;
   int i;
   ATL_sidnode_t *next;
};

#define SET_FLAG(bits_, flg_, val_) \
{\
   if (val_) (bits_) |= (1<<(flg_)); \
   else (bits_) &= ~(1<<(flg_)); \
}
#define FLAG_IS_SET(field_, bit_) ( ((field_) & (1<<(bit_))) != 0 )

@iexp ip @(ip) 1 +
/* procedure @(ip) : allocates ATL_sidnode_t */
static ATL_sidnode_t *ATL_NewSIDNode(void)
{
   ATL_sidnode_t *sp;
   sp = calloc(1, sizeof(ATL_sidnode_t));
   assert(sp);
   return(sp);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) : allocates ATL_sidnode_t */
static ATL_sidnode_t *ATL_FreeSIDNode(ATL_sidnode_t *die)
{
   ATL_sidnode_t *sp=NULL;
   if (die)
   {
      sp = die->next;
      if (die->str)
         free(die->str);
      free(die);
   }
   return(sp);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static int GetL1CacheElts(char pre)
{
   FILE *L1f;
   int L1Size, i;

   L1f = fopen("res/L1CacheSize", "r");
   if (!L1f)
   {
      assert(system("make res/L1CacheSize\n") == 0);
      L1f = fopen("res/L1CacheSize", "r");
   }
   assert(L1f);
   assert(fscanf(L1f, "%d", &L1Size) == 1);
   fclose(L1f);
   assert(L1Size > 0);
   if (pre == 'c' || pre == 'd')
      i = 1024/8;
   else if (pre == 's')
      i = 1024/4;
   else if (pre == 'z')
      i = 1024/16;
   else
      assert(0);
   return(i*L1Size);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static char *ExtendString(char *str, int len)
/*
 * Given already-allocated str, allocate a new string of total length len,
 * copy str to it (strlen(str)<= len)
 */
{
   char *sp;
   sp = realloc(str, len);
   assert(sp);
   return(sp);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static char *GetStrForSprintf
(
   char *form,  /* format string that will be passed to printf */
   int extra,   /* extra chars over format length to allocate */
   char *old    /* original ptr to pass to realloc */
)
{
   old = realloc(old, strlen(form)+extra);
   assert(old);
   return(old);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static int NumDecDigits(int num)
/*
 * RETURNS: number of decimal digits required to hold num, wt sign of neg #s
 *          counted as a digit
 */
{
   int bound, nd;
   if (num < 0)
   {
      nd = 2;
      num = -num;
   }
   else
      nd = 1;
   for (bound=9; num > bound; nd++)
      bound = bound*10 + 9;
   return(nd);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static int NumHexDigits(unsigned int num)
{
   int dig;

   for (dig=1; num; num >>= 4) 
      dig++;
   return(dig);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static char *DupString(char *str)
{
   int i,n;
   char *s;

   if (!str)
      return(NULL);
   n = strlen(str)+1;
   s = malloc(sizeof(char)*n);
   assert(s);
   for (i=0; i < n; i++)
      s[i] = str[i];
   return(s);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static char *NewMergedString(char *st0, char *st1)
/*
 * RETURNS: new string with st1 concatonated to st0
 */
{
   int i, n0, n1;
   char *s;

   if (!st0)
   {
      if (!st1)
         return(NULL);
      else 
         return(DupString(st1));
   }
   n0 = strlen(st0);
   n1 = strlen(st1) + 1;
   s = malloc(sizeof(char)*(n0+n1));
   assert(s);
   for (i=0; i < n0; i++)
      s[i] = st0[i];
   s += n0;
   for (i=0; i < n1; i++)
      s[i] = st1[i];
   return(s-n0);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static char *GetSingleQuoteString(char *str)
{
   char *sp;
   int i, n;

   assert(str[0] == '\'');
   for (i=1; str[i] && str[i] != '\''; i++);
   assert(str[i]);
   sp = malloc(i*sizeof(char));
   for (n=i,i=1; i < n; i++)
      sp[i-1] = str[i];
   sp[n-1] = '\0';
   return(sp);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static int asmNames2bitfield(char *str)
/*
 * Takes str containing an assembly name list.  The list is ended by the first
 * white space or end of string.  List items are seperated by ',', and there
 * can be no whitespace in list.
 * RETURNS: bitfield with bits set corresponding to assemblies, 0 on error.
 */
{
   char asmname[64];
   int i, KeepOn, bits=0;

   do
   {
      for (i=0; !isspace(str[i]) && str[i] != ',' && str[i] && i < 64; i++)
         asmname[i] = str[i];
      asmname[i] = '\0';
      KeepOn = str[i] == ',';
      str += i+1;
      if (i >= 64)
         return(0);  /* no asm name > 63 in length */
      for (i=0; i < NASMD; i++)
      {
         if (!strcmp(ASMNAM[i], asmname))
         {
            bits |= (1<<i);
            break;
         }
      }
   }
   while(KeepOn);
   return(bits);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static int GetDoubleArr(char *str, int N, double *d)
/*
 * Reads in a list with form "%le,%le...,%le"; N-length d recieves doubles.
 * RETURNS: the number of doubles found, or N, whichever is less
 */
{
   int i=1;
   assert(sscanf(str, "%le", d) == 1);
   while (i < N)
   {
      str = strstr(str, ",");
      if (!str)
         break;
      str++;
      assert(sscanf(str, "%le", d+i) == 1);
      i++;
   }
   return(i);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static char *GetLongerString(char *shrt, int newlen)
/*
 * Allocates new string of size newlen, copies shrt into it, and frees shrt.
 */
{
   char *sp;

   sp = malloc(sizeof(char)*newlen);
   assert(sp);
   if (shrt)
   {
      strcpy(sp, shrt);
      free(shrt);
   }
   else if (newlen >= 0)
      sp[0] = '\0';
   return(sp);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static char *GetOneLine(FILE *fpin)
/*
 * RETURNS: string of one line from stream fpin,  NULL if stream exhausted.
 */
{
   const int inc=256;
   static int len=0;
   static char *ln, *sp;
   int i, j, KeepOn;

   if (!len)
   {
      ln = malloc(inc*sizeof(char));
      assert(ln);
      len = inc;
   }
   if (!fgets(ln, len, fpin))
      return(NULL);

   for (i=0; ln[i]; i++);  /* find end of string */
   if (!i) return(ln);
   while (ln[i-1] != '\n')    /* if last char not \n, read rest of line */
   {
      len += inc;
      ln = GetLongerString(ln, len);
      if (!fgets(ln+i, inc, fpin))
         return(ln);
       for (; ln[i]; i++);  /* find end of string */
   }
   return(ln);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static char *GetJoinedLines(FILE *fpin)
/*
 * Gets lines from file fpin; if last non-whitespace char is '\', joins lines
 * RETURNS: line from file including joining, NULL if fpin exhausted
 */
{
   char *ln, *sp;
   static char *join=NULL;
   static int jlen=0;
   int i, j, k;

   sp = ln = GetOneLine(fpin);
   if (!sp)
      return(NULL);
   j = 0;   /* current length of join string */
   if (ln)
   {
      for (i=0; ln[i]; i++);  /* find end of string */
      if (!i) return(NULL);
      for (i--; isspace(ln[i]) && i > 0; i--);  /* find last non-wspace char */
      while (ln[i] == '\\')
      {
         if (jlen < j+i+3)
         {
            jlen = j+i+i+3;
            join = GetLongerString(join, jlen);
         }
         for (k=0; k < i; k++)
            join[j+k] = ln[k];
         j += k;
         join[j++] = ' ';
         join[j] = '\0';
         ln = GetOneLine(fpin);   /* get new line that should be joined */
         assert(ln);              /* can't end file with continue */
         for (i=0; ln[i]; i++);   /* find end of new line */
         for (i--; isspace(ln[i]) && i > 0; i--); /* find last non-wspc char */
         sp = join;
      }
      if (sp == join)
      {
         if (jlen < j+i+3)
         {
            jlen = j+i+i+3;
            join = GetLongerString(join, jlen);
         }
         for (k=0; k <= i; k++)
            join[j+k] = ln[k];
         j += k;
         join[j] = '\n';
         join[j+1] = '\0';
         sp = join;
      }
   }
   return(sp);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static char *GetGoodGcc()
/*
 * Gets gcc path and name along with mandatory flags (-g/-m64/-pg,etc) by
 * querying Make.inc setting
 */
{
   static char gcc[2048];
   static int INIT=0;
   if (!INIT)
   {
      FILE *fpin;
      assert(system("make res/goodgcc.txt > /dev/null 2>&1") == 0);
      fpin = fopen("res/goodgcc.txt", "r");
      assert(fpin);
      assert(fscanf(fpin, "'%[^\']", gcc) == 1);
      fclose(fpin);
   }
   return(gcc);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static char *GetKCFlags(char pre)
/*
 * Gets flags being used for <pre>KCFLAGS
 */
{
   char ln[4096];
   FILE *fpin;
   int i;

   if (pre == 'z')
      pre = 'd';
   else if (pre == 'c')
      pre = 's';
   i = system("rm -f res/kcflags.txt");
   sprintf(ln, "grep \"%cKCFLAGS = \" Make.inc | sed s/%cKCFLAGS\\ =\\ // > res/kcflags.txt", toupper(pre), toupper(pre));
   assert(system(ln) == 0);
   fpin = fopen("res/kcflags.txt", "r");
   assert(fpin);
   assert(fgets(ln, 4096, fpin) != NULL);
   fclose(fpin);
/*
 * Get rid of trailing and leading whitespaces
 */
   for (i=0; ln[i]; i++);
   for (i--; isspace(ln[i]); i--);
   ln[i+1] = '\0';
   for (i=0; isspace(ln[i]); i++);
   return(DupString(ln+i));
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static int *GF_GetIntList1(int ival)
/*
 * returns integer array with iarr[0] = 1, iarr[1] = ival
 */
{
   int *iarr;
   iarr = malloc(2*sizeof(int));
   assert(iarr);
   iarr[0] = 1;
   iarr[1] = ival;
   return(iarr);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static int *GF_GetIntList2(int ival1, int ival2)
/*
 * returns integer array with iarr[0] = 1, iarr[1] = ival1, ival[2] = ival2
 */
{
   int *iarr;
   iarr = malloc(3*sizeof(int));
   assert(iarr);
   iarr[0] = 2;
   iarr[1] = ival1;
   iarr[2] = ival2;
   return(iarr);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static int *GF_DupIntList(int *L)
/*
 * dups a list of integers L, whose data length is given by L[0];
 * list is this length+1, since 0'th location gets data length.
 */
{
   int *ip, n;
   if (!L)
      return(NULL);
   n = L[0] + 1;
   ip = malloc(n*sizeof(int));
   assert(ip);
   memcpy(ip, L, n*sizeof(int));
   return(ip);
}
#ifdef ATL_GETFLAGS
@iexp ip @(ip) 1 +
/* procedure @(ip) */
static double *GF_GetNDoubleArgs(int nargs, char **args, int i, int n)
/*
 * Reads in n doubles from commandline args to produce n-len double array.
 */
{
   int k;
   double *darr;
   void PrintUsage(char*, int, char*);

   if (n < 1)
      return(NULL);
   darr = malloc(sizeof(double)*n);
   assert(darr);

   for (k=0; k < n; k++)
   {
      if (++i >= nargs)
         PrintUsage(args[0], i, NULL);
      darr[k] = atof(args[i]);
   }
   return(darr);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static double *GF_GetDoubleList(int nargs, char **args, int i, int nmul)
/*
 * Gets a list of doubles, whose length is given by atoi(args[i])*nmul
 * list is this length+1, since 0'th location gets atoi(args[i])
 */
{
   int n, k;
   double *darr;
   void PrintUsage(char*, int, char*);

   if (++i >= nargs)
      PrintUsage(args[0], i, NULL);
   n = atoi(args[i]) * nmul;
   assert(n > 0);
   darr = malloc(sizeof(double)*(n+1));
   assert(darr);

   darr[0] = n / nmul;
   for (k=0; k < n; k++)
   {
      if (++i >= nargs)
         PrintUsage(args[0], i, NULL);
      darr[k+1] = atof(args[i]);
   }
   return(darr);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static int *GF_GetIntList(int nargs, char **args, int i, int nmul)
/*
 * Gets a list of integers, whose length is given by atoi(args[i])*nmul
 * list is this length+1, since 0'th location gets atoi(args[i])
 */
{
   int n, *iarr, k;
   void PrintUsage(char*, int, char*);

   if (++i >= nargs)
      PrintUsage(args[0], i, NULL);
   n = atoi(args[i]) * nmul;
   assert(n > 0);
   iarr = malloc(sizeof(int)*(n+1));
   assert(iarr);

   iarr[0] = n / nmul;
   for (k=0; k < n; k++)
   {
      if (++i >= nargs)
         PrintUsage(args[0], i, NULL);
      iarr[k+1] = atoi(args[i]);
   }
   return(iarr);
}
#endif

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static int *GF_IntRange2IntList(int N0, int NN, int incN)
{
   int i, n;
   int *iarr;

   for (i=N0, n=0; i <= NN; i += incN) n++;
   iarr = malloc(sizeof(int)*(n+1));
   assert(iarr);
   iarr[0] = n;
   for (i=N0, n=1 ; i <= NN; i += incN, n++)
      iarr[n] = i;
   return(iarr);
}
@iexp ip @(ip) 1 +
/* procedure @(ip) */
static int GetNativeVLEN(char pre)
{
#if defined(ATL_AVX) || defined(ATL_AVXMAC)
   if (pre == 's' || pre == 'c' || pre == 'S' || pre == 'C')
      return(8);
   return(4);
#elif defined(ATL_GAS_ARM64)
      if (pre == 's' || pre == 'c' || pre == 'S' || pre == 'C')
         return(4);
      return(2);
#elif defined(ATL_GAS_ARM)
   #ifndef ATL_NONIEEE
      return(1);
   #else
      if (pre == 's' || pre == 'c' || pre == 'S' || pre == 'C')
         return(4);
      return(1);
   #endif
#elif defined(ATL_SSE2) || defined(ATL_VECARM1) || defined(ATL_VSX)
   if (pre == 's' || pre == 'c' || pre == 'S' || pre == 'C')
      return(4);
   return(2);
#elif defined(ATL_SSE1)
   if (pre == 's' || pre == 'c' || pre == 'S' || pre == 'C')
      return(4);
   return(1);
#else
   return(0);   /* 0 means: I don't know */
#endif
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static int GetNumVecRegs(char pre)
{
#ifdef ATL_SSE1
   #ifdef ATL_USE64BITS
      return(16);
   #else
      return(8);
   #endif
#elif defined(ATL_VECARM1) || defined(ATL_FPV3D32MAC)
   return(32);
#elif defined(ATL_FPV3D16MAC)
   if (pre == 's' || pre == 'c' || pre == 'S' || pre == 'C')
      return(32);
    return(16);
#elif defined(ATL_VSX)
   return(64);
#else
   return(0);   /* 0 means: I don't know */
#endif
}

/*
 * The following are functions that allow us to operate on generic lists
 * of any structure.  The idea is that you pass the byte offset where
 * the next pointer is found, as well as the data item you want to access.
 * Since we are loading raw memory, note that your type must match precisely.
 * Eg., GetIntAtOff is only used with int (signed or unsigned), not any 
 * intergral (it will fail for short or char).  Assuming you have a pointer
 * to the structure in question:
 *    GetOffset(&p->next, p);
 * can be used to calculate the offnxt these funcs require.
 */
@iexp ip @(ip) 1 +
/* procedure @(ip) */
static int GetOffset(void *v0, void *v1)
/*
 * Find (postive) gap between addresses.  Used inside structs, where dist
 * is short enough that size_t not required.
 */
{
   size_t i0=(size_t)v0, i1=(size_t)v1;
   if (v1 > v0)
      return(v1-v0);
   return(v0-v1);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static int GetIntAtOff(void *p, int off)
/*
 * RETURNS: derefence *(p+off) interpeted an integer address.
 */
{
   return(*((int*)(((char*)p)+off)));
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static void *GetPtrAtOff(void *p, int off)
{
   return( *((void**)(((char*)p)+off)) );
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static char *GetStrAtOff(void *p, int off)
{
   return( *((char**)(((char*)p)+off)) );
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static double GetDoubleAtOff(void *mp, int off)
{
   return(*((double*)(((char*)mp)+off)));
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static void SetPtrAtOff(void *vb, int off, void *p)
{
   *((void**)(((char*)vb)+off)) = p;
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static int CountListEntries(void *vb, int nxtoff)
{
   int i=0;
   char *cp = vb;
   while (cp)
   {
      cp = GetStrAtOff(cp, nxtoff);
      i++;
   }
   return(i);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static int GetIntMaxMinAtOff(void *vb, int nxtoff, int off, int *MAX, int *MIN)
/*
 * Find the max and min of any integer in vb+off in list, next ptr at nxtoff;
 * Works for any list with a next ptr, and any int stored as int native
 * (will not work for short/char/etc).
 * RETURNS: number of nodes searched.
 */
{
   char *cp=vb;
   register int max=0, min=0, n=0;

   if (vb)
   {
      min = max = GetIntAtOff(cp, off);
      n = 1;
      while( (cp = GetStrAtOff(cp, nxtoff)) )
      {
         register int i;
         i = GetIntAtOff(cp, off);
         max = (max >= i) ? max : i;
         min = (min <= i) ? min : i;
         n++;
      }
   }
   *MAX = max;
   *MIN = min;
   return(n);
}

void *ATL_FindLastNode(void *vp, int nxtoff)
{
   if (vp)
   {
      char *nxt;
      while ( (nxt = GetStrAtOff(vp, nxtoff)) )
         vp = nxt;
   }
   return(vp);
}

void *FindNodeWithMaskOR(void *p, int nxtoff, int bvoff, int mask)
/*
 * Assuming list with next ptr at nxtoff, and bitvec at bvoff, search
 * for any node with any bits present int mask set.
 * RETURNS: ptr to first node with bits matching any bit in mask, if none, NULL
 * NOTE: this function does a logical OR (any mask bit set) operation, not AND!
 */
{
   while (p)
   {
      int bv;
      bv = GetIntAtOff(p, bvoff);
      if (bv & mask)
         return(p);
      p = GetStrAtOff(p, nxtoff);
   }
   return(NULL);
}

void *FindNodeWithIval(void *p, int nxtoff, int ivoff, int val)
{
   while (p)
   {
      int iv;
      iv = GetIntAtOff(p, ivoff);
      if (iv == val)
         return(p);
      p = GetStrAtOff(p, nxtoff);
   }
   return(NULL);
}

void *RemoveNodeFromList(void *vb, void *vp, int nxtoff)
/*
 * Finds struct ptr vp in vb, and removes it from singly-linked list
 * RETURNS: possibly changed vb (only in case vb == vp)
 */
{
   if (vb)
   {
      char *nxt, *prv=vb, *cur;
      nxt = GetStrAtOff(vb, nxtoff);
      if (vb == vp)
      {
         SetPtrAtOff(vb, nxtoff, NULL);
         return((void*)nxt);
      }
      cur = nxt;

      while (cur)
      {
         nxt = GetStrAtOff(vb, nxtoff);
         if (cur == vp)
         {
            SetPtrAtOff(prv, nxtoff, nxt);
            SetPtrAtOff(cur, nxtoff, NULL);
            return(vb);
         }
         cur = nxt;
      }
   }
   if (vb)
   {
      fprintf(stderr, "ERROR: cannot find %p in basefile %p!\n", vp, vb);
      exit(1);
   }
   return(NULL);
}

#endif /* end atlas_genparse.h guard */
@ROUT mmread
#ifndef ATL_DEF_MMFLAG
   #define ATL_DEF_MMFLAG @up@(rt)F_DEFAULT
#endif
   @define rt @mm@
@ROUT mvread
   @define rt @mv@
@ROUT r1read
   @define rt @r1@
@ROUT r1read mvread mmread
@iexp ip @(ip) 1 +
/* procedure @(ip) */
static ATL_@(rt)node_t *Get@up@(rt)Node(void)
{
   ATL_@(rt)node_t *p;
   p = calloc(1, sizeof(ATL_@(rt)node_t));
   assert(p);
@ROUT mvread `   p->TA = AtlasNoTrans;`
@ROUT mmread `   p->TA = AtlasTrans; p->TB = AtlasNoTrans;`
   p->flag = @up@(rt)F_DEFAULT;
   return(p);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static ATL_@(rt)node_t *Clone@up@(rt)Node(ATL_@(rt)node_t *dup)
{
   ATL_@(rt)node_t *p;
   p = malloc(sizeof(ATL_@(rt)node_t));
   assert(p);
   memcpy(p, dup, sizeof(ATL_@(rt)node_t));
   if (dup->rout)
      p->rout = DupString(dup->rout);
   if (dup->auth)
      p->auth = DupString(dup->auth);
   if (dup->comp)
      p->comp = DupString(dup->comp);
   if (dup->cflags)
      p->cflags = DupString(dup->cflags);
   if (dup->str)
      p->str = DupString(dup->str);
   if (dup->genstr)
      p->genstr = DupString(dup->genstr);
   if (dup->exflags)
      p->exflags = DupString(dup->exflags);
@ROUT mmread
   if (dup->moves)
      p->moves = DupString(dup->moves);
@ROUT r1read mvread
   if (dup->kname)
      p->kname = DupString(dup->kname);
@ROUT r1read mvread mmread
   p->next = NULL;
   return(p);
}

@iexp ip @(ip) 1 +
/* procedure @(ip): clones a queue of @up@(rt) structs */
static ATL_@(rt)node_t *Clone@up@(rt)Queue(ATL_@(rt)node_t *dupb)
{
   ATL_@(rt)node_t *p, *pd, *nb;
   if (!dupb)
      return(NULL);
   p = nb = Clone@up@(rt)Node(dupb);
   for (pd=dupb->next; pd; pd = pd->next)
   {
      p->next = Clone@up@(rt)Node(pd);
      p = p->next;
   }
   return(nb);
}

@iexp ip @(ip) 1 +
/* procedure @(ip): clones a queue of strided @up@(rt) structs */
static ATL_@(rt)node_t *CloneStrided@up@(rt)Queue
(
   ATL_@(rt)node_t *dupb,   /* queue of nodes to clone */
   int stride               /* increment between nodes to take */
)
/*
 * Creates a queue of cloned nodes from dupb; move stride each time
 * (stride must be >= 1); i.e. skip stride-1 structs in original queue
 */
{
   ATL_@(rt)node_t *p, *pd, *nb;
   int i;

   if (!dupb)
      return(NULL);
   if (stride == 1)
      return(Clone@up@(rt)Queue(dupb));
   assert(stride > 1);
   p = nb = Clone@up@(rt)Node(dupb);
   pd = nb;
   while(pd)
   {
      for (i=0; i < stride && pd; i++, pd = pd->next);
      if (pd)
      {
         p->next = Clone@up@(rt)Node(pd);
         p = p->next;
      }
      else
         p->next = NULL;
   }
   return(nb);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static ATL_@(rt)node_t *Kill@up@(rt)Node(ATL_@(rt)node_t *die)
{
   ATL_@(rt)node_t *p=NULL;
   if (die)
   {
      p = die->next;
      if (die->rout)
         free(die->rout);
      if (die->auth)
         free(die->auth);
      if (die->comp)
         free(die->comp);
      if (die->cflags)
         free(die->cflags);
      if (die->str)
         free(die->str);
      if (die->genstr)
         free(die->genstr);
      if (die->exflags)
         free(die->exflags);
@ROUT mmread
      if (die->moves)
         free(die->moves);
@ROUT r1read mvread
      if (die->kname)
         free(die->kname);
@ROUT r1read mvread mmread
      free(die);
   }
   return(p);
}

@iexp ip @(ip) 1 +
/* procedure @(ip): safely remove nukeme from Q, reseting all links */
static ATL_@(rt)node_t *Remove@up@(rt)NodeFromQ
(
   ATL_@(rt)node_t *Q,     /* queue of nodes */
   ATL_@(rt)node_t *nukeme /* node to remove from queue */
)
/*
 * Removes nukeme from Q, sets nukeme->next=NULL, and returns updated Q
 */
{
   ATL_@(rt)node_t *p, *prev;

   if (!nukeme)
      return(Q);
   assert(Q);
   if (Q == nukeme)
   {
      Q = Q->next;
      nukeme->next = NULL;
      return(Q);
   }
   prev = Q;
   for (p=Q->next; p && p != nukeme; p = p->next)
      prev = p;
   assert(p);
   prev->next = nukeme->next;
   nukeme->next = NULL;
   return(Q);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static ATL_@(rt)node_t *Kill@up@(rt)NodeFromQ
(
   ATL_@(rt)node_t *Q,     /* queue of nodes */
   ATL_@(rt)node_t *nukeme /* node to remove from queue */
)
{
   Q = Remove@up@(rt)NodeFromQ(Q, nukeme);
   Kill@up@(rt)Node(nukeme);
   return(Q);
}

@iexp ip @(ip) 1 +
/* procedure @(ip): frees all ->rout entries in queue b */
static void KillAll@up@(rt)Routs(ATL_@(rt)node_t *b)
{
   while (b)
   {
      if (b->rout)
      {
         free(b->rout);
         b->rout = NULL;
      }
      b = b->next;
   }
}

@ROUT mmread
/* procedure @(ip) */
void *KillAllMMStrings(ATL_mmnode_t *mb)
{
   ATL_mmnode_t *mp;

   for (mp=mb; mp; mp = mp->next)
   {
      @whiledef sv rout auth comp cflags str genstr exflags moves
      if (mp->@(sv))
         free(mp->@(sv));
      mp->@(sv) = NULL;
      @endwhile
   }
}

@ROUT r1read mvread mmread
@iexp ip @(ip) 1 +
/* procedure @(ip): frees all ->genstr entries in queue b */
static void KillAll@up@(rt)Genstr(ATL_@(rt)node_t *b)
{
   while (b)
   {
      if (b->genstr)
      {
         free(b->genstr);
         b->genstr = NULL;
      }
      b = b->next;
   }
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static void KillAll@up@(rt)Nodes(ATL_@(rt)node_t *die)
{
   while (die)
      die = Kill@up@(rt)Node(die);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static void ATL_SubGoodGccIn@up@(rt)Nodes
(
   ATL_@(rt)node_t *bp   /* queue to make sub in */
)
/*
 *  Gets GOODGCC (from Make.inc), and substitutes it for all comp == "gcc"
 *  in the queue.  This gets us mandatory flags like -pg,-m64,etc.
 */
{
   ATL_@(rt)node_t *kp;  /* queue to make sub in */
   char *gcc;
   gcc = GetGoodGcc();
   for (kp=bp; kp; kp = kp->next)
   {
      if (kp->comp && !strcmp(kp->comp, "gcc"))
      {
         free(kp->comp);
	 kp->comp = DupString(gcc);
      }
   }
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static void ATL_UnsubGoodGccIn@up@(rt)Nodes
(
   ATL_@(rt)node_t *bp   /* queue to make reverse sub in */
)
/*
 *  Gets GOODGCC (from Make.inc); Any comp string matching that is switched
 *  back to "gcc".  This is usually necessary so that output files don't
 *  use an old GOODGCC that lacks something like -pg.
 */
{
   ATL_@(rt)node_t *kp;  /* queue to make sub in */
   char *gcc;
   gcc = GetGoodGcc();
   for (kp=bp; kp; kp = kp->next)
   {
      if (kp->comp && !strcmp(kp->comp, gcc))
      {
         free(kp->comp);
	 kp->comp = DupString("gcc");
      }
   }
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static void ResubGoodGccIn@up@(rt)Nodes
(
   ATL_@(rt)node_t *bp   /* queue to make sub in */
)
/*
 * Takes gcc compiler that use GOODGCC, and replaces them with "gcc"
 * to help portability
 */
{
   ATL_@(rt)node_t *kp;  /* queue to make sub in */
   char *gcc;
   gcc = GetGoodGcc();
   for (kp=bp; kp; kp = kp->next)
   {
      if (kp->comp && !strcmp(kp->comp, gcc))
      {
         free(kp->comp);
	 kp->comp = DupString("gcc");
      }
   }
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static int ATL_CountNumberOf@up@(rt)Nodes
(
    ATL_@(rt)node_t *bp   /* queue to count */
)
{
   int i;
   for (i=0; bp; i++, bp = bp->next);
   return(i);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static ATL_@(rt)node_t *ATL_Last@up@(rt)Node(ATL_@(rt)node_t *bp)
/*
 * RETURNS: pointer to last node in queue
 */
{
   ATL_@(rt)node_t *p;
   if (!bp)
      return(NULL);
   for (p=bp; p->next; p = p->next);
   return(p);
}

/* procedure @(ip): finds node with max mflop[imf]  */
static ATL_@(rt)node_t *FindMaxMflop@up@(rt)Q
(
   ATL_@(rt)node_t *bp,   /* queue to be searched */
   int imf
)
/*
 * RETURNS: ptr to structure containing max value in mflop[imf]
 */
{
   ATL_@(rt)node_t *mp, *p;
   double mfm;
   if (!bp)
      return(NULL);
   mp = bp;
   mfm = mp->mflop[imf];
   for (p=bp->next; p; p = p->next)
   {
      const double mf=p->mflop[0];
      if (mf > mfm)
      {
         mfm = mf;
         mp = p;
      }
   }
   return(mp);
}
@multidef cmp < >
@whiledef op Min Max
   @iexp ip @(ip) 1 +
/* procedure @(ip): finds @low@(op) integer at ip0 in struct */
static ATL_@(rt)node_t *Find@(op)IntIn@up@(rt)Q
(
   ATL_@(rt)node_t *bp,   /* queue to be searched */
   void *ip0           /* ptr to integer withinin node bp */
)
/*
 * RETURNS: ptr to structure containing @low@(op) int value at byte offset 
 *          offset in struct
 */
{
   ATL_@(rt)node_t *mp=NULL, *p;
   int *ip;
   int val;
   const int offset = (int)((char*)((char*) ip0) - ((char*)bp));

   if (!bp)
      return(NULL);
   
   mp = bp;
   ip = (int*)(((char*)bp) + offset);
   val = *ip;
   for (p=bp->next; p; p = p->next)
   {
      ip = (int*)(((char*)p) + offset);
      if (*ip @(cmp) val)
      {
         mp = p;
         val = *ip;
      }
   }
   return(mp);
}
   @undef cmp
@endwhile

@iexp ip @(ip) 1 +
/* procedure @(ip): finds first integer equal to val at ip0 in struct */
static ATL_@(rt)node_t *FindIntValIn@up@(rt)Q
(
   ATL_@(rt)node_t *bp,   /* queue to be searched */
   void *ip0,          /* ptr to integer withinin node bp */
   int val             /* value being searched for */
)
/*
 * RETURNS: ptr to first structure containing value val at byte offset 
 *          offset in struct, or NULL if no such value found
 */
{
   ATL_@(rt)node_t *mp=NULL, *p;
   int *ip;
   const int offset = (int)((char*)((char*) ip0) - ((char*)bp));

   if (!bp)
      return(NULL);
   
   for (p=bp; p; p = p->next)
   {
      ip = (int*)(((char*)p) + offset);
      if (*ip == val)
         return(p);
   }
   return(NULL);
}

@iexp ip @(ip) 1 +
/* procedure @(ip): sorts Q from least-to-greatest on int val at ip0 in struc */
static ATL_@(rt)node_t *Sort@up@(rt)QByIntVal
(
   ATL_@(rt)node_t *bp,   /* queue to be sorted */
   void *ip0           /* ptr to integer withinin node bp to sort on*/
)
/*
 * RETURNS: possibly new queue base, sorted from least-to-greatest on int at ip0
 */
{
   ATL_@(rt)node_t *sb=NULL, *p;
   int *ip;
   const int offset = (int)((char*)((char*) ip0) - ((char*)bp));

   if (!bp)
      return(NULL);
   
   while(bp)
   {
      ip = (int*)(((char*)bp) + offset);
      p = FindMaxIntIn@up@(rt)Q(bp, ip);
      bp = Remove@up@(rt)NodeFromQ(bp, p);
      p->next = sb;
      sb = p;
   }
   return(sb);
}

@iexp ip @(ip) 1 +
/* procedure @(ip): reverses order in Q */
static ATL_@(rt)node_t *Reverse@up@(rt)Q(ATL_@(rt)node_t *bp)
/*
 * RETURNS: new base ptr of reversed queue
 */
{
   ATL_@(rt)node_t *nb=NULL, *p;
   while(bp)
   {
      p = bp;
      bp = bp->next;
      p->next = nb;
      nb = p;
   }
   return(nb);
}

@iexp ip @(ip) 1 +
/* procedure @(ip): places all nodes wt int value val at ip0 in new queue */
static ATL_@(rt)node_t *Yank@up@(rt)NodesByIntVal
(
   ATL_@(rt)node_t **bp0,  /* queue to be searched */
   void *ip0,          /* ptr to integer withinin node *bp */
   int val             /* value to be yanked out of original Q */
)
/*
 * Finds all nodes that have the integeral value val stored in position
 * ip0-bp0 in nodes.  These nodes are removed from bp0, and placed in
 * their own queue, which is returned.  bp0 is modified in the process.
 * RETURNS: ptr to queue of nodes wt integer value val
 */
{
   ATL_@(rt)node_t *bp=(*bp0), *p, *valb=NULL, *vp;
   int *ip;
   const int offset = (int)((char*)((char*) ip0) - ((char*)bp));

   while(bp)
   {
      p = FindIntValIn@up@(rt)Q(bp, (((char*)bp)+offset), val);  /* find node */
      if (!p)       /* if there are no more in bp, we are done */
         break;
      bp = Remove@up@(rt)NodeFromQ(bp, p);   /* remove it from original queue */
/*
 *    Add node at front of new value-only queue 
 */
      if (valb)
      {
         vp->next = p;
         vp = p;
      }
      else
         vp = valb = p;
   }
   *bp0 = bp;
   return(valb);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static ATL_@(rt)node_t *ATL_Sort@up@(rt)NodesByMflop
(
   int imf,            /* which mflop entry to sort on */
   ATL_@(rt)node_t *bp    /* queue to be sorted */
)
/* 
 * kills original queue, and returns a greatest-to-least sorted queue
 * on p->mflop[imf].  Does it with O(N^2) alg, but if this is a bottleneck,
 * we never get here because timing takes an eternity.
 */
{
   ATL_@(rt)node_t *p, *prev, *sb=NULL;   /* ptr, prev, sorted base */
   ATL_@(rt)node_t *minp, *minprev;
   double mf;

/*
 * Sort from greatest-to-least by always adding smallest entry in old
 * list to head of greatest-to-least list
 */
   while (bp)
   {
/*
 *    Find slowest remaining kernel
 */
      mf = bp->mflop[imf];
      for (minp=prev=bp, p=bp->next; p; p = p->next)
      {
         if (p->mflop[imf] < mf)
         {
            minp = p;
            mf = p->mflop[imf];
            minprev = prev;
         }
         prev = p;
      }
/*
 *    Remove it from unsorted queue, and add as new head of sorted
 */
      if (minp == bp)
      {
         bp = bp->next;
         minp->next = sb;
      }
      else   /* in the middle of unsorted queue */
      {
         minprev->next = minp->next;
         minp->next = sb;
      }
      sb = minp;
   }
   return(sb);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static ATL_@(rt)node_t *Parse@up@(rt)Line(char *ln)
/*
 * Given a line from a @(rt) index file (with multiple lines pasted together
 * into one line (ln), return a structure describing that line.
 */
{
   ATL_@(rt)node_t *p;
   char *sp;
   int itmp;
   char ch;

   p = Get@up@(rt)Node();

@ROUT r1read mvread
@whiledef kk ldamul
   sp = strstr(ln, "@up@(kk)=");
   if (sp)
      p->@(kk) = atoi(sp+@len@(kk)+1);
   else
      p->@(kk) = 0;

@endwhile
@ROUT mmread 
@whiledef jj vlen
   sp = strstr(ln, "@up@(jj)=");
   if (sp)
      p->@(jj) = atoi(sp+@len@(jj)+1);
   else
      p->@(jj) = 1;
@endwhile
@whiledef jj mu nu ku kbmin kbmax pref ivar pfLS szExtra stgA stgB stgC blask
   sp = strstr(ln, "@up@(jj)=");
   if (sp)
      p->@(jj) = atoi(sp+@len@(jj)+1);
   else
      p->@(jj) = 0;
@endwhile
@whiledef jj kb nb mb
   sp = strstr(ln, "@up@(jj)=");
   if (sp)
      p->@(jj)B = atoi(sp+@len@(jj)+1);
   else
      p->@(jj)B = 0;
@endwhile
   @multidef jj ID SSE
@ROUT mvread r1read 
   @multidef jj ID MU NU minN minM alignX alignY alignA SSE CacheElts rankR
@ROUT r1read mvread mmread
@whiledef jj
   sp = strstr(ln, "@(jj)=");
   if (sp)
      p->@(jj) = atoi(sp+@len@(jj)+1);
   else
      p->@(jj) = 0;

@endwhile
@ROUT mmread
   sp = strstr(ln, "OPMV=");
   if (sp)
   {
      int imv;
      imv = atoi(sp+5);
      ATL_MMF_MVPUT(p->flag, imv);
   }
@multidef fl 
   X87 LDCTOP KRUNTIME AOUTER PFACOLS PFABLK PFBCOLS PFCELTS L14NB KVEC
   KUISKB NOBCAST
@endmultidef

@ROUT mvread
@multidef fl X87 LDYTOP ALLALIGNXY AXPYBASED GEMMBASED CONJDEF FNU ALIGNX2A ADDCFLAGS PFTUNABLE
@ROUT r1read
@multidef fl X87 ALLALIGNXY FNU INCYISONE ALIGNX2A ADDCFLAGS PFTUNABLE
@ROUT r1read mvread mmread
@whiledef fl
   sp = strstr(ln, "@(fl)=");
   if (sp)
   {
      if (atoi(sp+@len@(fl)+1))
         p->flag |= (1<<@up@(rt)F_@(fl));
      else
         p->flag &= ~(1<<@up@(rt)F_@(fl));
   }
@endwhile

   sp = strstr(ln, "MFLOP=");
   if (sp)
      GetDoubleArr(sp+6, 8, p->mflop);

   sp = strstr(ln, "ASM=");
   if (sp)
      p->asmbits = asmNames2bitfield(sp+4);


@ROUT mmread
@multidef TA TA TB
@ROUT mvread
@multidef TA TA 
@ROUT mvread mmread
@whiledef TA
   sp = strstr(ln, "@(TA)='");
   if (sp)
   {
      ch = tolower(sp[4]);
      if (ch == 'n')
         p->@(TA) = AtlasNoTrans;
      else if (ch == 'c')
         p->@(TA) = AtlasConjTrans;
      else if (ch == 't')
         p->@(TA) = AtlasTrans;
      else
         assert(0);
   }
@endwhile
@ROUT mvread r1read mmread
@skip   sp = strstr(ln, "MFLOP=");
@skip   if (sp) p->mflop = atof(sp+6);

@ROUT mvread r1read `@define kw @kname@`
@whiledef kw rout auth comp cflags
   sp = strstr(ln, "@up@(kw)='");
   if (sp)
      p->@(kw) = GetSingleQuoteString(sp+@len@(kw)+1);
   else
      p->@(kw) = NULL;

@endwhile
   return(p);
}

/* procedure 18 */
static void Print@up@(rt)Line(FILE *fpout, ATL_@(rt)node_t *np)
{
   int i, j, k;
   char ta, tb;

   if (!np)
      return;
   if (!np->rout)
      np->ID = 0;
@ROUT r1read
   fprintf(fpout, "ID=%d ROUT='%s' AUTH='%s'",
           np->ID, np->rout ? np->rout : "generated", 
           np->auth ? np->auth : "R. Clint Whaley");
@ROUT mvread mmread
   if (np->TA == AtlasConjTrans) ta = 'C';
   else if (np->TA == AtlasTrans) ta = 'T';
   else ta = 'N';
@ROUT mvread
   fprintf(fpout, "ID=%d ROUT='%s' AUTH='%s' TA='%c'",
           np->ID, np->rout ? np->rout : "generated", 
           np->auth ? np->auth : "R. Clint Whaley", ta);
@ROUT mvread r1read
   if (np->kname)
      fprintf(fpout, " KNAME='%s' \\\n", np->kname);
   else
      fprintf(fpout, " \\\n");
@ROUT mmread
   if (np->TB == AtlasConjTrans) tb = 'C';
   else if (np->TB == AtlasTrans) tb = 'T';
   else tb = 'N';
   fprintf(fpout, "ID=%d ROUT='%s' AUTH='%s' TA='%c' TB='%c' \\\n",
           np->ID, np->rout ? np->rout : "generated", 
           np->auth ? np->auth : "R. Clint Whaley", ta, tb);

@ROUT mvread r1read mmread
   fprintf(fpout, "   ");
   i = 3;
@ROUT mvread r1read
@whiledef kw MU NU minN minM alignX alignY alignA SSE CacheElts rankR
   if (i > 70) { fprintf(fpout, " \\\n   "); i = 3; }
   i += fprintf(fpout, "@(kw)=%d ", np->@(kw));
@endwhile
@whiledef kw ldamul
   if (i > 70) { fprintf(fpout, " \\\n   "); i = 3; }
   i += fprintf(fpout, "@up@(kw)=%d ", np->@(kw));
@endwhile

@ROUT mmread 
   if (i > 70) { fprintf(fpout, " \\\n   "); i = 3; }
   i += fprintf(fpout, "OPMV=%d ", ATL_MMF_MVGET(np->flag));
@whiledef kw ivar kbmin kbmax pref pfLS vlen blask
   if (np->@(kw))
   {
      if (i > 70) { fprintf(fpout, " \\\n   "); i = 3; }
      i += fprintf(fpout, "@up@(kw)=%d ", np->@(kw));
   }
@endwhile
@whiledef kw mu nu ku
   if (i > 70) { fprintf(fpout, " \\\n   "); i = 3; }
   i += fprintf(fpout, "@up@(kw)=%d ", np->@(kw));
@endwhile

   @define kwd @@
   @multidef kw
      X87 LDCTOP KRUNTIME AOUTER PFACOLS PFABLK PFBCOLS PFCELTS L14NB KVEC
      KUISKB NOBCAST
   @endmultidef
@ROUT r1read 
   @define kwd @X87 INCYISONE FNU ADDCFLAGS ALIGNX2A PFTUNABLE@
@ROUT mvread 
   @define kwd @X87 FNU LDYTOP ALLALIGNXY AXPYBASED GEMMBASED ADDCFLAGS ALIGNX2A PFTUNABLE@
@ROUT mmread
@whiledef jj kb nb mb
   if (i > 70) { fprintf(fpout, " \\\n   "); i = 3; }
   if (np->@(jj)B != 0)
      i += fprintf(fpout, "@up@(jj)=%d ", np->@(jj)B);
@endwhile
@ROUT mvread r1read mmread
@whiledef kw @(kwd)
   if (i+@len@(kw) > 72) { fprintf(fpout, " \\\n   "); i = 3; }
   i += fprintf(fpout, "@(kw)=%d ", FLAG_IS_SET(np->flag, @up@(rt)F_@(kw)));
@endwhile

   if (np->mflop[0]+np->mflop[1]+np->mflop[2]+np->mflop[3]+np->mflop[4]+
       np->mflop[5]+np->mflop[6] != 0.0)
   {
      if (i > 3) { fprintf(fpout, " \\\n   "); i = 3; }
      i += fprintf(fpout, "MFLOP=%le", np->mflop[0]);
      for (j=7; j && np->mflop[j] == 0.0; j--);
      for (k=1; k <= j; k++)
         i += fprintf(fpout, ",%le", np->mflop[k]);
   }
   if (np->asmbits)
   {
      if (i > 40) { fprintf(fpout, " \\\n   "); i = 3; }
      for (j=0; !(np->asmbits & (1<<j)); j++);
      assert(j < NASMD);
      i += fprintf(fpout, "  ASM=%s", ASMNAM[j]);
      for (j++; j < NASMD; j++)
         if (np->asmbits & (1<<i))
            i += fprintf(fpout, ",%s", ASMNAM[j]);
   }
@whiledef kw comp cflags
   if (np->@(kw))
   {
      if (i+strlen(np->@(kw)) > 70) { fprintf(fpout, " \\\n   "); i = 3; }
      i += fprintf(fpout, "  @up@(kw)='%s'", np->@(kw));
   }
@endwhile
   if (i)
      fprintf(fpout, "\n");
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static void Print@up@(rt)Nodes(FILE *fpout, ATL_@(rt)node_t *bp)
{
   while (bp)
   {
      Print@up@(rt)Line(fpout, bp);
      bp = bp->next;
   }
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static void Write@up@(rt)File(char *file, ATL_@(rt)node_t *nq)
{
   FILE *fpout;

   if (!file || !strcmp(file, "stdout"))
      fpout = stdout;
   else if (!strcmp(file, "stderr"))
      fpout = stderr;
   else
   {
      fpout = fopen(file, "w");
      assert(fpout);
   }
   Print@up@(rt)Nodes(fpout, nq);
   if (fpout != stdout && fpout != stderr)
      fclose(fpout);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static void Write@up@(rt)FileWithPath
   (char pre, char *path, char *file, ATL_@(rt)node_t *nq)
{
   char ln[2048];
   sprintf(ln, "%s/%c%s", path, pre, file);
   Write@up@(rt)File(ln, nq);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static ATL_@(rt)node_t *Read@up@(rt)File(char *file)
/*
 * Reads in a standard ATLAS parsable @up@(rt) index file, and returns a
 * list of all the kernels defined there.
 */
{
   ATL_@(rt)node_t *nq=NULL, *p;
   FILE *fpin;
   char *ln, *sp;
   int i, j, KeepOn, len;

   if (!file || !strcmp(file, "stdin"))
      fpin = stdin;
   else
      fpin = fopen(file, "r");
   if (!fpin)
      return(NULL);
   nq = p = Get@up@(rt)Node();
   while (ln = GetJoinedLines(fpin))
   {
      if (ln[0] != '#' && ln[0] != '\0')
      {
         p->next = Parse@up@(rt)Line(ln);
         p = p->next;
      }
   }
   fclose(fpin);
   return(Kill@up@(rt)Node(nq));
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static ATL_@(rt)node_t *Read@up@(rt)FileWithPath
   (char pre, char *path, char *file)
{
   char ln[2048];
   sprintf(ln, "%s/%c%s", path, pre, file);
   return(Read@up@(rt)File(ln));
}


@iexp ip @(ip) 1 +
/* procedure @(ip) */
static ATL_@(rt)node_t *DelRepeated@up@(rt)Kernels(ATL_@(rt)node_t *bp)
/*
 * Deletes any repeated IDs
 */
{
   ATL_@(rt)node_t *prev, *p, *np;
   int ID;

   for (p=bp; p; p = p->next)
   {
      ID = p->ID;
      prev = p;
      do
      {
         for (np=p->next; np && np->ID != ID; np = np->next)
            prev = np;
         if (np)  /* found duplicate */
            prev->next = Kill@up@(rt)Node(np);
      }
      while (np);
   }
   return(bp);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static ATL_@(rt)node_t *DelBadArch@up@(rt)Kernels(ATL_@(rt)node_t *bp)
/*
 * Weeds out kernels that require SSE/assembly that we haven't got
 */
{
   int asmb=0, die;
   ATL_@(rt)node_t *p, *prev;
@multidef sh          1         2        3        4          5        6       7         8
@whiledef asm GAS_x8632 GAS_x8664 GAS_SPARC GAS_PPC GAS_PARISC GAS_MIPS GAS_ARM GAS_ARM64
   #ifdef ATL_@(asm)
      asmb |= (1<<@(sh));
   #endif
   @undef sh
@endwhile

   prev = p = bp;
   while (p)
   {
      die = (p->asmbits) ? !(asmb & p->asmbits) : 0;
      #ifndef ATL_SSE3
         if (p->SSE)
         {
            die |= (p->SSE >= 3);
            #ifndef ATL_SSE2
               die |= (p->SSE >= 2);
            #endif
            #ifndef ATL_SSE1
               die |= (p->SSE >= 1);
            #endif
         }
      #endif
      if (die) 
      {
         if (p == bp) 
            bp = p = Kill@up@(rt)Node(p);
         else 
            prev->next = p = Kill@up@(rt)Node(p);
      }
      else
      {
         prev = p;
         p = p->next;
      }
   }
   return(bp);
}

@ROUT mvread r1read
#define MAXBASES 4
@iexp ip @(ip) 1 +
/* procedure @(ip) */
static int ATL_@up@(rt)SplitContexts
(
   ATL_@(rt)node_t *kb,   /* pointer to all read in kernels */
   ATL_@(rt)node_t **ocb, /* set to all out-of-cache kernels */
   ATL_@(rt)node_t **i2b, /* set to all in-L2 kernels */
   ATL_@(rt)node_t **i1b, /* set to all in-L1 kernels */
   ATL_@(rt)node_t **syb  /* NULL, or all SYR/SYR2 kernels (may not exist) */
)
/*
 *  Takes unified bp, and splits it into separate pieces.  bp is invalidated
 *  in the process (is split into child queues)
 *  RETURNS: number of children found
 */
{
   ATL_@(rt)node_t *kp, *kn;
   ATL_@(rt)node_t *bases[MAXBASES] = {NULL, NULL, NULL, NULL};
   int nbases;

/*
 * Kernels come as a series of kernels that are ranked by efficiency from
 * high to low based on the integer rankR.  All series must end with a
 * general kernel with no restrictions with a rankR of 0 (all non-zero
 * kernels have restrictions).  This loop splits these kernels into 
 * their seperate series (series indicates calling context).
 */
   kn = kb;
   nbases = 0;
   while (kn)
   {
      bases[nbases++] = kn;
      for (kp=kn; kp && kp->rankR; kp = kp->next);  /* find end of series */
      if (!kp)
         break;
      kn = kp->next;
      kp->next = NULL;
   }
   if (ocb)
      *ocb = bases[0];
   else
      KillAll@up@(rt)Nodes(bases[0]);
   if (i2b)
      *i2b = bases[1];
   else
      KillAll@up@(rt)Nodes(bases[1]);
   if (i1b)
      *i1b = bases[2];
   else
      KillAll@up@(rt)Nodes(bases[2]);
   if (syb)
      *syb = bases[3];
   else
      KillAll@up@(rt)Nodes(bases[3]);
   return(nbases);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static ATL_@(rt)node_t *ATL_@up@(rt)LinkContexts
(
   ATL_@(rt)node_t *kp1, /* all out-of-cache kernels */
   ATL_@(rt)node_t *kp2, /* all in-L2 kernels */
   ATL_@(rt)node_t *kp3, /* all in-L1 kernels */
   ATL_@(rt)node_t *kp4  /* all SYR/SYR2 kernels */
)
/*
 *  Takes separate queue, and joins them into one long queue; if any
 *  is NULL, all remaining cases must also be NULL!
 *  Seperate queues are subsumed into returned queue
 */
{
   ATL_@(rt)node_t *kps[MAXBASES] = {kp1, kp2, kp3, kp4};
   ATL_@(rt)node_t *kp, *kprev;
   int i, j;

   for (i=0; i < MAXBASES-1; i++)
   {
      if (!kps[i])
      {
         for (j=i+1; j < MAXBASES; j++)
            assert(!kps[j]);
         return(kp1);
      }
      for (kp=kps[i]; kp->next; kp = kp->next);
      kp->next = kps[i+1];
   }
   return(kp1);
}
#undef MAXBASES

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static ATL_@(rt)node_t *FindFastest@up@(rt)Kernel
(  char pre,             /* precision prefix */
   ATL_@(rt)node_t *bp,  /* kernel queue */
   int imf,              /* which mflop entry to sort by */
   int RESTRICTOK        /* consider restricted kernel? */
)
/*
 * A RESTRICTed kernel is one that requires something that can't be fixed
 * by loop peeling or the like.  Examples include forcing lda to a given
 * multiple, or 16-byte alignment for double complex (can't peel 1/2 of
 * a complex number to make 8-byte aligned array 16).
 * RETURNS: pointer to node in bp that is fastest in context imf wt RESTRCT
 */
{
   double mf;
   ATL_@(rt)node_t *kp, *kmax=bp;
   int size, usize, RKERN;

   if (bp)
   {
      usize = (pre == 'c' || pre == 's') ? 4 : 8;
      if (pre == 'c' || pre == 'd') size = 8;
      else if (pre == 's') size = 4;
      else size = 16;
      mf = bp->mflop[imf];
      for (kp=bp->next; kp; kp = kp->next)
      {
         if (kp->mflop[imf] > mf)
         {
            RKERN = (pre == 'z' || pre == 'c') ? (kp->alignA > usize) : 0;
            RKERN = RKERN | (kp->ldamul > size);
            if (RESTRICTOK | !RKERN)
            {
               mf = kp->mflop[imf];
               kmax = kp;
            }
         }
      }
   }
   return(kmax);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static int @up@(rt)flag2size(int flag)
/*
 * RETURNS: size of type using precision/type bits in flag
 */
{
   int size;

   size = FLAG_IS_SET(flag, @up@(rt)F_SINGLE) ? 4 : 8;
   size *= FLAG_IS_SET(flag, @up@(rt)F_COMPLEX) ? 2 : 1;
   return(size);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static char @up@(rt)flag2pre(int flag)
/*
 * RETURNS: correct precision/type prefix based on flag
 */
{
   char pre = 'd';
   if (FLAG_IS_SET(flag, @up@(rt)F_SINGLE))
      return(FLAG_IS_SET(flag, @up@(rt)F_COMPLEX) ? 'c' : 's');
   return(FLAG_IS_SET(flag, @up@(rt)F_COMPLEX) ? 'z' : 'd');
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static int pre2@up@(rt)flag(char pre, int flag)
/*
 * RETURNS: flag modified to reflect type/precision indicated by pre
 */
{
   SET_FLAG(flag, @up@(rt)F_COMPLEX, (pre == 'c' || pre == 'z'));
   SET_FLAG(flag, @up@(rt)F_SINGLE, (pre == 'c' || pre == 's'));
   return(flag);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static void SetAll@up@(rt)TypeFlags(char pre, ATL_@(rt)node_t *bp)
{
   ATL_@(rt)node_t *p;
   for (p=bp; p; p = p->next)
      p->flag = pre2@up@(rt)flag(pre, p->flag);
}
@ROUT r1read

@iexp ip @(ip) 1 +
/* procedure @(ip) */
void PutKernNameInStr(ATL_@(rt)node_t *r1B)
/*
 * Fills in the proper name for all kernels in r1->str
 */
{
   char ln[32] = {"ATL_dgerk_L0_restrict"};
   char pre;
   const int ipre=4, iL=11, irest=12;

   pre = @up@(rt)flag2pre(r1B->flag);
   ln[ipre] = pre;
   r1B->str = DupString(ln);
   ln[irest] = '\0';
   r1B->next->str = DupString(ln);
   ln[irest] = '_';
   r1B = r1B->next->next;

   ln[iL] = '2';
   r1B->str = DupString(ln);
   ln[irest] = '\0';
   r1B->next->str = DupString(ln);
   ln[irest] = '_';
   r1B = r1B->next->next;

   ln[iL] = '1';
   r1B->str = DupString(ln);
   ln[irest] = '\0';
   r1B->next->str = DupString(ln);
   ln[irest] = '_';
   r1B = r1B->next->next;

   sprintf(ln, "ATL_%cgerk_L1b_restrict", pre);
   r1B->str = DupString(ln);
   ln[irest+1] = '\0';
   r1B->next->str = DupString(ln);
}

@beginskip
@iexp ip @(ip) 1 +
/* procedure @(ip) */
ATL_r1node_t *GetSortedUniqueR1Kerns
   (char pre, ATL_r1node_t *r1kerns, char **aliases)
/*
 * Takes the 8-length queue of rank-1 update kernels:
 *    First 2 are restricted and normal GER out-of-cache kernels
 *    next 2 are restricted & normal in-L2 GER kernels
 *    next 2 are restristed & normal in-L1 GERM kernels
 *    next 2 are restristed & normal out-of-cache, L1-blocked kernels
 *
 * ALIASES: a null-terminated list of string pointers, where pairs
 *          of strings give the correct aliasing: 1st entry is the
 *          routine to be aliased, 2nd is what it should be aliased to.
 *          Every kernel that uses the same actual routine as another
 *          in the 8-length queue is deleted, and a #define is used
 *          to call the appropriate kernel, to avoid unnecessary
 *          code size expansion.
 *          If ALIASES is NULL, then ALIASES is not accessed.
 *          ALIASES must be at least 15 pointers long.
 *
 * RETURNS: new queue with only the unique kernels left (unrestricted
 *          kernels appear first in list), and the p->str entry having
 *          the correct routine/file name.  
 * NOTE   : Leaves the original queue intact.
 */
{
   ATL_r1node_t *r1b, *r1p, *r1k, *r1prev;
   char *kern = "gerk";
   int i, ialias=0;
   char *suff[8] = {"_L0", "_L0_restrict", "_L2", "_L2_restrict",
                    "_L1", "_L1_restrict", "_L1b", "_L1b_restrict"};

@skip   kern = (pre == 'z' || pre == 'c') ? "geru" : "ger";
/*
 * Make sure all routines are present, and there are no extra
 */
  for (i=0, r1p = r1kerns; i < 8; i++, r1p=r1p->next)
     assert(r1p);
  assert(!r1p);
/* 
 * Build new queue with the "normal" kernels first
 */
   r1b = CloneR1Node(r1kerns->next);
   r1b->next = r1p = CloneR1Node(r1kerns);
   r1p->next = CloneR1Node(r1kerns->next->next->next);
   r1p->next->next =  CloneR1Node(r1kerns->next->next);
   r1p = r1p->next->next;
   r1p->next = CloneR1Node(r1kerns->next->next->next->next->next);
   r1p->next->next = CloneR1Node(r1kerns->next->next->next->next);
   r1p = r1p->next->next;
   r1p->next = CloneR1Node(r1kerns->next->next->next->next->next->next->next);
   r1p->next->next = CloneR1Node(r1kerns->next->next->next->next->next->next);
   r1p->next->next->next = NULL;
/*
 * Label queue entries with proper kernel names
 */
   for (i=0,r1p = r1b; i < 8; i++, r1p = r1p->next)
   {
       r1p->str = malloc(32*sizeof(char));
       assert(r1p->str);
       sprintf(r1p->str, "ATL_%c%s%s", pre, kern, suff[i]);
   }
/* 
 * Add duplicated kernels to alias array, and then get rid of them from Q
 */
   r1prev = r1b;
   r1p = r1b->next;
   while (r1p)
   {
      for (r1k=r1b; r1k != r1p; r1k = r1k->next)
         if (r1k->ID == r1p->ID) break;
      if (r1k != r1p)  /* got duplicate */
      {
         if (aliases)
         {
            aliases[ialias++] = r1p->str;
            r1p->str = NULL;
            aliases[ialias++] = DupString(r1k->str);
         }
         r1prev->next = r1p = KillR1Node(r1p);
      }
      else
      {
        r1prev = r1p;
        r1p = r1p->next;
      }
   }
   if (aliases)
      aliases[ialias] = NULL;
   return(r1b);
}
@endskip
@ROUT mvread
@iexp ip @(ip) 1 +
/* procedure @(ip) */
static void SortByTrans
(
   ATL_@(rt)node_t *bp,    /* original kernels wt mixture of trans cases */
   ATL_@(rt)node_t **bN0,  /* No trans cases */
   ATL_@(rt)node_t **bT0,  /* trans cases */
   ATL_@(rt)node_t **bNC0, /* ConjNotrans cases */
   ATL_@(rt)node_t **bTC0  /* Conjtrans cases */
) 
/*
 * Sorts bp into the separate transpose queues, destroying bp in the process.
 * If a bp entry has the CONJDEF property, then its entry is duplicated to
 * put it on both queues (it can be used for normal and conjugate cases).
 */
{
   ATL_@(rt)node_t *bN=NULL, *bT=NULL, *bNC=NULL, *bTC=NULL,
                   *p, *next, *new;

   for (p=bp; p; p = next)
   {
      next = p->next;
      if (p->TA == AtlasNoTrans)
      {
         p->next = bN;
         bN = p;
         #ifdef TCPLX
            if (p->flag & (1<<@up@(rt)F_CONJDEF))
            {
               new = Clone@up@(rt)Node(p);
               new->TA = AtlasConj;
               new->next = bNC;
               bNC = new;
            }
         #endif
      }
      else if (p->TA == AtlasTrans)
      {
         p->next = bT;
         bT = p;
         #ifdef TCPLX
            if (p->flag & (1<<@up@(rt)F_CONJDEF))
            {
               new = Clone@up@(rt)Node(p);
               new->TA = AtlasConjTrans;
               new->next = bTC;
               bTC = new;
            }
         #endif
      }
   #ifdef TCPLX
      else if (p->TA == AtlasConjTrans)
      {
         p->next = bTC;
         bTC = p;
      }
      else /* TA == AtlasConj */
      {
         p->next = bNC;
         bNC = p;
      }
   #endif
   }
   *bN0 = bN;
   *bT0 = bT;
   *bNC0 = bNC;
   *bTC0 = bTC;
}
@ROUT mmread

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static int MMKernsSame(ATL_mmnode_t *p0, ATL_mmnode_t *p1)
/*
 * RETURNS: 1 if kernels are the same except for blocking, 0 otherwise
 */
{
/*
 * Two generated kernels are the same if mu,nu,ku,VLEN,flag are the same.
 * NOTE: pref & pfLS do not affect output, and so are not checked!
 * NOTE: any extension of generator functionality should extend this check!
 */
   if (p0->ID == 0 && p1->ID == 0)
      return(p0->mu == p1->mu && p0->nu == p1->nu && p0->ku == p1->ku &&
             p0->vlen == p1->vlen && p0->flag == p1->flag);
/*
 * If both are user kernels, then they may be repeats.  For user kernels,
 * they are the same if both ID and flag match, else they are not.
 */
   else if (p0->ID > 0 && p1->ID > 0)
      return(p0->ID == p1->ID && p0->flag == p1->flag);
   return(0);  /* Can't be the same if above criteria fails */
}
@iexp ip @(ip) 1 +
/* procedure @(ip) */
static int MMKernsPerfSame(ATL_mmnode_t *p0, ATL_mmnode_t *p1)
/*
 * ignoring blocking params, are kernels the same?  This version does not
 * ignore setting that effect only performance (eg, prefetch settings).
 */
{
   if (p0->ID == 0 && p1->ID == 0 && 
       (p0->pref != p1->pref || p0->pfLS != p1->pfLS))
      return(0);
   return(MMKernsSame(p0, p1));
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static int MMKernCompsSame(ATL_mmnode_t *p0, ATL_mmnode_t *p1)
/*
 * RETURNS: 1 if kernels are the same including KB, else 0
 */
{
/*
 * Kernels are not the same if one has compile-time K and other runtime
 */
   if (FLAG_IS_SET(p0->flag, MMF_KRUNTIME) != 
       FLAG_IS_SET(p1->flag, MMF_KRUNTIME))
      return(0);
/*
 * Kernels not same if both compile-time K with differing KB
 */
   if (!FLAG_IS_SET(p0->flag, MMF_KRUNTIME) && p0->kbB != p1->kbB)
      return(0);
/*
 * Generated kernels aren't same if prefetch is different
 */
   if ((p0->ID | p1->ID) == 0 && (p0->pref != p1->pref || p0->pfLS != p1->pfLS))
      return(0);
   return(MMKernsSame(p0, p1));
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static int MMKernIsPresent(ATL_mmnode_t *mmb, ATL_mmnode_t *mmp)
/*
 * RETURNS: 1 if kernel compilation matching mmp is in list mmb, 0 otherwise
 */
{
   ATL_mmnode_t *mp;
   for (mp=mmb; mp; mp = mp->next)
      if (MMKernsSame(mmp, mp))
         return(1);
   return(0);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static int MMKernCompIsPresent(ATL_mmnode_t *mmb, ATL_mmnode_t *mmp)
/*
 * RETURNS: 1 if kernel compilation matching mmp is in list mmb, 0 otherwise
 */
{
   ATL_mmnode_t *mp;
   for (mp=mmb; mp; mp = mp->next)
      if (MMKernCompsSame(mmp, mp))
         return(1);
   return(0);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static ATL_mmnode_t *AddUniqueMMKernsToList
   (ATL_mmnode_t *mmb, ATL_mmnode_t *newb)
/*
 * RETURNS: mmb with any kernels present in newb that aren't in mmb added to it
 * (1) changes mmb, does not change newb
 * (2) new nodes are added to BEGINNING of mmb (leaving mmb unsorted)!
 */
{
   ATL_mmnode_t *mp;
      
   for (mp=newb; mp; mp = mp->next)
   {
      if (!MMKernIsPresent(mmb, mp))
      {
         ATL_mmnode_t *p;
         p = CloneMMNode(mp);
         p->next = mmb;
         mmb = p;
      }
   }
   return(mmb);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static ATL_mmnode_t *AddUniqueMMKernCompList
   (ATL_mmnode_t *mmb, ATL_mmnode_t *newb)
/*
 * RETURNS: mmb with any kerncomps present in newb that aren't in mmb added 
 *          to it
 * (1) changes mmb, does not change newb
 * (2) new nodes are added to BEGINNING of mmb (leaving mmb unsorted)!
 */
{
   ATL_mmnode_t *mp;
   for (mp=newb; mp; mp = mp->next)
   {
      if (!MMKernCompIsPresent(mmb, mp))
      {
         ATL_mmnode_t *p;
         p = CloneMMNode(mp);
         p->next = mmb;
         mmb = p;
      }
   }
   return(mmb);
}
@iexp ip @(ip) 1 +
/* procedure @(ip) */
int MMNamelen(char pre, char *nm, ATL_mmnode_t *mp, int kb)
{
   int len=5;                         /* ATL_<pre> */

   len = strlen(nm);
   if (len == 4)  /* may be non-gemm kernel (eg., syrk, trmm) */
   {              /* only one of these, so it gets fixed name */
      if (nm[0] == 's' && nm[1] == 'y' && nm[2] == 'r' && nm[3] == 'k')
         return(12); /* ATL_<pre>amsyrkK */
   }
   len += 5;  /* ATL_<pre> */

   len += NumDecDigits(mp->ID);       /* ATL_<pre><nm><ID> */
   len += 1 + NumDecDigits(kb);       /* ATL_<pre><nm><ID>_<kb> */
   len += 1 + NumDecDigits(mp->vlen); /* +[m,k]<vlen>, V=[m,k]*/
   len += 1 + NumHexDigits(mp->pref); /* +p<pref> */
   len += 1 + NumDecDigits(mp->pfLS); /* +x<LS> */
   len += 1 + NumHexDigits(mp->flag); /* +_<flg> */
   len += 1 + NumDecDigits(mp->mu);   /* +_mu */
   len += 1 + NumDecDigits(mp->nu);   /* +_nu */
   len += 1 + NumDecDigits(mp->ku);   /* +_ku */
   return(len);     /* string terminator/beta/file ext not included! */
} /* ATL_<pre><nm><ID>_<kb>[m,n]<vlen>p<pf>x<LS>_<flg>_MUxNUxKU */

/*
 * A kernel name is how a kernel is called from code, and is set by 
 * redefining ATL_USERMM, so we see that it can be unrelated to filename.
 * However, during install we will make all filenames the same as the
 * kernel name, with the following exceptions:
 * 1. _bX is done through recompilation, so is replaced by file ext (.c, etc.)
 * 2. KB will not match the kernel name in the (a,b) cases below:
 *    a. For ID != 0, KB is always 0 (same source file used regardless of
 *       compile flags, etc).
 *    b. For kerns that that need compile-time K, but can simply be recompiled
 *       for each differing KB, we will encode KB=1 (never a valid KB).
 *    c. For kerns taking a runtime KB, KB is 0
 *    d. For kerns that only supply an exact KB, KB is set to mp->kbB.
 * 
 * During installation, we can use mp->str to temporarily store the filename,
 * while we use mp->rout to store the kernel (call) name, w/o beta suffix.
 */
@iexp ip @(ip) 1 +
/* procedure @(ip) */
int SprintMMName(char *name, char pre, char *nm, ATL_mmnode_t *mp, int kb)
/*
 * kb >= 0 : print kb in name, else don't
 */
{
   int i, ku=mp->ku;

   if (nm[0] == 's' && nm[1] == 'y' && nm[2] == 'r' && nm[3] == 'k')
   {
      strcpy(name, "ATL_XamsyrkK");
      name[4] = pre;
      return(12);
   }
   if (FLAG_IS_SET(mp->flag, MMF_KUISKB))
      ku = mp->kbB;
   /* ATL_<pre><nm><ID>_kb[m,n]<vlen>p<pf>x<LS>_<flg>_MUxNUxKU */
   i = sprintf(name, "ATL_%c%s%d_%d%c%dp%xx%d_%x_%dx%dx%d", pre, nm, mp->ID, kb,
               FLAG_IS_SET(mp->flag, MMF_KVEC) ? 'k':'m', mp->vlen,
               mp->pref, mp->pfLS, mp->flag, mp->mu, mp->nu, mp->ku);
   return(i);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static char *GetMMKernName(char pre, char *nm, ATL_mmnode_t *mp)
/*
 * Get a string of form ATL_<pre><nm>suff, where suff encodes all info
 * required to differentiate between amm kernels.  Name must be suffixed
 * later with _b[n,1,0] to be fully qualified, and there is room left in
 * string to add that.
 */
{
   int i, h, kb=0;
   char *name;

   if (FLAG_IS_SET(mp->flag,MMF_KUISKB) || !FLAG_IS_SET(mp->flag,MMF_KRUNTIME))
      kb = mp->kbB;
   i = MMNamelen(pre, nm, mp, kb);
   name = malloc(i+3+1);  /* 3 for beta name, +1 is for string terminator */
   assert(name);
   h = SprintMMName(name, pre, nm, mp, kb);
   assert(h <= i);
   return(name);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static char *GetMMFilename(char pre, char *nm, ATL_mmnode_t *mp)
/*
 * Get a string of form ATL_<pre><nm>suff, where suff encodes all info
 * required to differentiate between amm kernels
 */
{
   int i, h, kb, flg, pf, pfLS;
   char *name;

   if (mp->ID)
#ifdef ATL_GENERATE  /* generators get real name */
      kb = 0;
#else  /* tuners get default name */
      return(DupString("ATL_tmp.c"));
#endif
   else if (FLAG_IS_SET(mp->flag, MMF_KUISKB))
      kb = mp->kbB;
   else if (!FLAG_IS_SET(mp->flag, MMF_KRUNTIME))
      kb = (mp->kbmax != mp->kbB || mp->kbmin != mp->kbB) ? 1 : mp->kbB;
   else 
      kb = 0;
   flg = mp->flag;
   pf = mp->pref;
   pfLS = mp->pfLS;
   if (mp->ID)       /* pref & flag don't matter for non-genned filenames */
      mp->pref = mp->pfLS = mp->flag = 0;
   i = MMNamelen(pre, nm, mp, kb); 
   name = malloc(i+2+1);           /* 2 file ext, 1 str term */
   assert(name);
   h = SprintMMName(name, pre, nm, mp, kb);
   mp->flag = flg;  /* restore flag/pref to correct vals */
   mp->pref= pf;
   mp->pfLS = pfLS;
   assert(h <= i);
   name[h] = '.';
   if (mp->ID == 0)
      name[h+1] = 'c';
   else if (FLAG_IS_SET(mp->flag, MMF_FKO))
      name[h+1] = 'B';
   else if (mp->rout) /* user supplied kern, get ext from orig name */
   {
      int k;
      k = strlen(mp->rout)-1;
      assert(mp->rout[k-1] == '.');
      name[h+1] = mp->rout[k];
   }
   else /* user-supplied w/o name, assume C */
      name[h+1] = 'c';
   name[h+2] = '\0';
   return(name);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static int RemoveMMRuntimeK
(
   ATL_mmnode_t **MMB,  /* IN/OUT: original base ptr */
   ATL_mmnode_t **KRUN  /* IN/OUT: base ptr for all runtime-K kerns  */
)
/*
 * Splits original list MMB into runtime-K kerns, which are added to KRUN,
 * and compile-time fixed K loops, which remain in MMB.  This possibly
 * changes both lists, though no node is lost.
 * RETURNS: number of runtime constant nodes removed from MMB added to KRUN
 */
{
   ATL_mmnode_t *mb=(*MMB), *kb=(*KRUN), *mp;
   int nk=0, nxtoff, bvoff;
   const int mask = (1<<MMF_KRUNTIME);

   nxtoff = GetOffset(&mb->next, mb);
   bvoff =  GetOffset(&mb->flag, mb);
   while ( (mp = FindNodeWithMaskOR(mb, nxtoff, bvoff, mask)) )
   {
      mb = RemoveNodeFromList(mb, mp, nxtoff);
      mp->next = kb;
      kb = mp;
      nk++;
   }
   *MMB = mb;
   *KRUN = kb;
   return(nk);
}
@iexp ip @(ip) 1 +
/* procedure @(ip) */
static void MMApplyMoves2Flags
(
   ATL_mmnode_t *mmb,  /* kernel to set MMF_MV[A,B,C] flag bits */
   int mvBits          /* last 3 bits: MOVE_[CBA] */
)
{
   const unsigned int mvMSK = ~MMF_MVSET, mvSET = (mvBits&7)<<MMF_MVA;
   ATL_mmnode_t *mmp;
   for (mmp=mmb; mmp; mmp = mmp->next)
      mmp->flag = ((mmp->flag) & mvMSK) | mvSET;
}

@ROUT mvread r1read mmread
#endif  /* end atlas_@(rt)parse.h guard */
@ROUT atlas_mvtesttime.h
   @define rt @mv@
   @define ru @mv@
   @define at @mvt@
@ROUT atlas_r1testtime.h
   @define rt @r1@
   @define ru @r1@
   @define at @r1@
@ROUT atlas_r2testtime.h
   @define rt @r2@
   @define ru @r1@
   @define at @r2@
@ROUT atlas_mmtesttime.h
   @define rt @mm@
   @define ru @mm@
   @define at @mm@
@ROUT atlas_gentesttime.h
#ifndef ATLAS_GENTESTTIME_H
   #define ATLAS_GENTESTTIME_H

#include "atlas_fopen.h"

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static int GetL1CacheSize()
{
   FILE *L1f;
   int L1Size;

   L1f = fopen("res/L1CacheSize", "r");
   if (!L1f)
   {
      assert(system("make res/L1CacheSize\n") == 0);
      L1f = fopen("res/L1CacheSize", "r");
   }
   assert(L1f != NULL);
   assert(fscanf(L1f, "%d", &L1Size) == 1);
   fclose(L1f);
   fprintf(stderr, "\n      Read in L1 Cache size as = %dKB.\n",L1Size);
   return(L1Size);
}

@ROUT mvres mmres atlas_gentesttime.h
@iexp ip @(ip) 1 +
/* procedure @(ip) */
static int pre2size(char pre)
{
   int iret=8;
   if (pre == 's')
      iret = 4;
   else if (pre == 'z')
      iret = 16;
   return(iret);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static void SortDoubles(int N, double *d)
/* 
 * Sorts N-length array d from least to greatest using N^2 selection sort
 */
{
   double min;
   int imin, i, j;

   for (i=0; i < N-1; i++)
   {
      imin = i;
      min = d[i];
      for (j=i+1; j < N; j++)
      {
         if (d[j] < min)
         {
            imin = j;
            min = d[j];
         }
      }
      if (imin != i)
      {
         d[imin] = d[i];
         d[i] = min;
      }
   }
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static void *ReadResultsFile(int ACTION, int nsample, char *resfile)
/*
 * Reads an ATLAS results file, which has the following form:
 *    <N> <walltime>   -> walltime of 0 means CPU timing was used
 *    sample1
 *    ....
 *    sampleN
 * RETURNs NULL on error, otherwise it depends on ACTION:
 * ACTION    RETURNS
 * 0         ptr to max value for walltime, median for CPU (serial timing)
 * 1         entire list of results is returned in N+2 array, of form
 *              <N> <wall> <sample1> .... <sampleN>
 *           DRET[0] = N; DRET[1] = 1 if walltime else 0.
 * 2         ptr to the average (parallel timing)
@beginskip
 * RETURNS: NULL on error or if nsample > N, else if (FULL) it returns
 *          an array of form:  <N> <wall> <sample1> .... <sampleN>
 *          where samples have been sorted from least-to-greatest.
 *          where <N> is the number of samples.
 *          If (!FULL) then a pointer to the max value is returned for
 *          walltime, and a pointer to the median value is returned for
 *          for cputime.
@endskip
 */
{
   static double dret;
   double *dres;
   FILE *fpin;
   char ln[1024];
   int i, n, wall, ierr;

   fpin = fopen(resfile, "r");
   if (!fpin)
      return(NULL);
   ierr = (fgets(ln, 1024, fpin) == NULL);
   if (ierr || sscanf(ln, " %d %d", &n, &wall) != 2)
   {
      fclose(fpin);
      return(NULL);
   }
   if (n < nsample)
   {
      fclose(fpin);
      return(NULL);
   }
   dres = malloc((n+2)*sizeof(double));
   assert(dres);
   dres[0] = n;
   dres[1] = wall;
   dret = 0.0;
   for (i=0; i < n; i++)
   {
      ierr = (fgets(ln, 1024, fpin) == NULL);
      if (ierr || sscanf(ln, " %le", dres+i+2) != 1)
      {
         fclose(fpin);
         return(NULL);
      }
      dret += dres[i+2];
   }
   fclose(fpin);
   SortDoubles(n, dres+2);
   if (ACTION == 1)
      return(dres);
   else if (ACTION == 0)
      dret = (wall) ? dres[n+1] : dres[2+n/2];
   else /* if (ACTION == 2) */
      dret /=  dres[0];
   free(dres);
   return(&dret);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static double PrintResultsFromFile(FILE *fpout, double *darr)
{
   const int N=darr[0], wall=(darr[1] != 0.0);
   double *dres=darr+2;
   double dret;
   int i;

   assert(N > 0);
   for (i=0; i < N; i++)
      fprintf(fpout, "   %le\n", dres[i]);
   if (wall)
   {
      fprintf(fpout, "MAX = %.2f\n", dres[N-1]);
      return(dres[N-1]);
   }
   else 
      fprintf(fpout, "MED = %.2f\n", dres[N/2]);
   return(dres[N/2]);
}

@ROUT atlas_gentesttime.h
#endif  /* end guard around atlas_gentesttime.h */
@ROUT atlas_mmtesttime.h atlas_r1testtime.h atlas_r2testtime.h @\
      atlas_mvtesttime.h
#ifndef ATLAS_@up@(rt)TESTTIME_H
   #define ATLAS_@up@(rt)TESTTIME_H

#include "atlas_@(ru)parse.h"
#include "atlas_gentesttime.h"

@ROUT atlas_r1testtime.h atlas_r2testtime.h atlas_mvtesttime.h
static int SprintAlignStr
(
   char pre,            /* precision modifier */
   ATL_@(ru)node_t *kp, /* kernel pointer */
   char *str            /* (OUTPUT) string to print to */
)
/*
 * Prints alignment string to str, based on alignment setting.
 * This routine assumes to force the alignment to sizeof(TYPE) unless 
 * restrictions are enabled.
 * RETURNS: number of chars added to str
 */
{
   const int size = (pre == 'd' || pre == 's') ? pre2size(pre) 
                                                 : (pre2size(pre)>>1);
   int alignA, alignX, alignY, i;

   alignA = (kp->alignA) ? kp->alignA : size;
   alignX = (kp->alignX) ? kp->alignX : size;
   alignY = (kp->alignY) ? kp->alignY : size;
@ROUT atlas_r1testtime.h atlas_r2testtime.h
   if (FLAG_IS_SET(kp->flag, @up@(ru)F_ALIGNX2A))
      alignX = alignA;  /* ALIGNX2A overrides alignX */
@ROUT atlas_mvtesttime.h
@beginskip
   {
      if (kp->TA == AtlasNoTrans) /* ALIGNX2A affects Y for No-Trans */
         alignY = alignA; /* ALIGNX2A overrides alignY */
      else
         alignX = alignA; /* ALIGNX2A overrides alignX */
   }
@endskip
/*
 * If we are doing an AXPY-based No-Trans GEMV, it is Y, not X that must
 * be aligned to A.  Therefore, alignX/ALIGNX2A actually refer to Y, and
 * alignY refers to X.  Do this confusing transpose for the non-trans case.
 */
   if (kp->TA == AtlasNoTrans) /* ALIGNX* affects Y for No-Trans */
   {
      i = alignX;
      alignX = alignY;
      alignY = i;
      if (FLAG_IS_SET(kp->flag, @up@(ru)F_ALIGNX2A))
         alignY = alignA; /* ALIGNX2A overrides alignY */
   }
   else if (FLAG_IS_SET(kp->flag, @up@(ru)F_ALIGNX2A))
      alignX = alignA;
@ROUT atlas_r1testtime.h atlas_r2testtime.h atlas_mvtesttime.h
/*
 * If ALIGNX2A, we must force to vectors to have the same remainder when
 * divided by the vector length.  We do this by insisting they have the
 * the same modulo by ATL_Cachelen, which by definition is always a 
 * multiple of the vector length (eg, veclen=16/32 (SSE/AVX), ATL_cl=32). 
 */
   if (FLAG_IS_SET(kp->flag, @up@(ru)F_ALIGNX2A))
   {
      int myalign = ATL_Cachelen - size;
      if (alignA)
      {
         myalign = ((ATL_Cachelen-size)/alignA)*alignA;
         if (!myalign) 
            myalign = alignA;
      }
@ROUT atlas_r1testtime.h atlas_r2testtime.h
      if (myalign < ATL_Cachelen)
         i = sprintf(str, " align=\"-Fa %d -Fa -%d -Fx %d -Fx -%d",
                     myalign, ATL_Cachelen, myalign, ATL_Cachelen);
      else
         i = sprintf(str, " align=\"-Fa %d -Fx %d", myalign, myalign);
      if (2*alignY <= ATL_Cachelen)
         i += sprintf(str+i, " -Fy %d -Fy -%d\"", alignY, 2*alignY);
      else
         i += sprintf(str+i, " -Fy %d\"", alignY);
@ROUT atlas_mvtesttime.h
      if (kp->TA == AtlasNoTrans) /* ALIGNX* affects Y for No-Trans */
      {
         if (myalign < ATL_Cachelen)
            i = sprintf(str, " align=\"-Fa %d -Fa -%d -Fy %d -Fy -%d",
                        myalign, ATL_Cachelen, myalign, ATL_Cachelen);
         else
            i = sprintf(str, " align=\"-Fa %d -Fy %d", myalign, myalign);
         if (2*alignX <= ATL_Cachelen)
            i += sprintf(str+i, " -Fx %d -Fx -%d\"", alignX, 2*alignX);
         else
            i += sprintf(str+i, " -Fx %d\"", alignX);
      }
      else
      {
         if (myalign < ATL_Cachelen)
            i = sprintf(str, " align=\"-Fa %d -Fa -%d -Fx %d -Fx -%d",
                        myalign, ATL_Cachelen, myalign, ATL_Cachelen);
         else
            i = sprintf(str, " align=\"-Fa %d -Fx %d", myalign, myalign);

         if (2*alignY <= ATL_Cachelen)
            i += sprintf(str+i, " -Fy %d -Fy -%d\"", alignY, 2*alignY);
         else
            i += sprintf(str+i, " -Fy %d\"", alignY);
      }
@ROUT atlas_r1testtime.h atlas_r2testtime.h atlas_mvtesttime.h
   }
   else
   {
      if (2*alignA <= ATL_Cachelen)
         i = sprintf(str, " align=\"-Fa %d -Fa -%d", alignA, 2*alignA);
      else
         i = sprintf(str, " align=\"-Fa %d ", alignA);
      if (2*alignX <= ATL_Cachelen)
         i += sprintf(str+i, " -Fx %d -Fx -%d", alignX, 2*alignX);
      else
         i += sprintf(str+i, " -Fx %d", alignX);
      if (2*alignY <= ATL_Cachelen)
         i += sprintf(str+i, " -Fy %d -Fy -%d\"", alignY, 2*alignY);
      else
         i += sprintf(str+i, " -Fy %d\"", alignY);
   }
   return(i);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static int @up@(rt)KernelFailsTest
   (int verb, char pre, ATL_INT M, ATL_INT N, ATL_INT lda, ATL_@(ru)node_t *kn)
{
   char ln[4096];
   char *sp;
   int i, lda0;
   static char outnam[L_tmpnam];
   static int FirstTime=1;

   if (FirstTime)
   {
      
      FirstTime = 0;
      assert(tmpnam(outnam));
   }
/*
 * If the file is generated, call generator to create it
 */
   if (kn->genstr)
   {
      i = sprintf(ln, "%s", kn->genstr);
      if (verb < 3)
         i += sprintf(ln+i, " > %s 2>&1\n", outnam);
      if (system(ln))
      {
         fprintf(stderr, "ERROR, LINE %d of %s\n", __LINE__, __FILE__);
         fprintf(stderr, "UNABLE TO GENERATE WITH COMMAND: %s\n", kn->genstr);
         if (verb < 3)
         {
            fprintf(stderr, "\nOUTPUT OF system():\n");
            sprintf(ln, "cat %s 1>&2\n", outnam);
            i = system(ln);
         }
         remove(outnam);
         exit(-1);
      }
   }
   assert(kn->rout);
   assert (M >= kn->minM);
   assert (N >= kn->minN);
@ROUT atlas_mvtesttime.h
   sp = (kn->TA == AtlasNoTrans) ? "mvn" : "mvt";
   if (kn->TA == AtlasNoTrans)
      i = sprintf(ln, "make %cmvnktest mvnrout=%s", pre, kn->rout);
   else
      i = sprintf(ln, "make %cmvtktest mvtrout=%s", pre, kn->rout);
@ROUT atlas_r1testtime.h atlas_r2testtime.h
   i = sprintf(ln, "make %c@(rt)ktest @(at)rout=%s", pre, kn->rout);
@ROUT atlas_r1testtime.h atlas_r2testtime.h atlas_mvtesttime.h
   i += SprintAlignStr(pre, kn, ln+i);
   if (FLAG_IS_SET(kn->flag, @up@(ru)F_FNU))
       i += sprintf(ln+i, " Nt=%d ", (1008/kn->NU)*kn->NU);
   if (kn->exflags)
      i += sprintf(ln+i, " %s", kn->exflags);
   if (1)   /* NOTE: replace with test on restrict or not! */
      i += sprintf(ln+i, " incy=1");
   if (kn->comp)
      i += sprintf(ln+i, " %c@up@(rt)CC=\"%s\"", pre, kn->comp);
   if (kn->cflags)
@ROUT atlas_mvtesttime.h
      i += sprintf(ln+i, " %c@up@(rt)FLAGS=\"%s\"", pre, kn->cflags);
@ROUT atlas_r1testtime.h atlas_r2testtime.h
      i += sprintf(ln+i, " %c@up@(rt)CFLAGS=\"%s\"", pre, kn->cflags);
@ROUT atlas_r1testtime.h atlas_r2testtime.h atlas_mvtesttime.h
   i += sprintf(ln+i, " Mt=%d Nt=%d ldat=%d", M, N, lda);
   if (verb < 3)
      i += sprintf(ln+i, " > %s 2>&1\n", outnam);
   else 
      i += sprintf(ln+i, "\n");
   if (verb > 1)
      fprintf(stdout, "system call:%s\n", ln);
   i = system(ln);
   if (verb)
   {
      if (i)
      {
         fprintf(stderr, "\n%s(ID=%d) FAILS TESTER!!\n", kn->rout,kn->ID);
         fprintf(stderr, "FAILING CALL: '%s'\n", ln);
         if (verb < 3 && verb > 0)
         {
            int itmp;
            fprintf(stderr, "\nOUTPUT OF system():\n");
            sprintf(ln, "cat %s 1>&2\n", outnam);
            itmp = system(ln);
         }
      }
      else
         fprintf(stderr, "%s(ID=%d) *PASSES* TESTER!!\n", kn->rout,kn->ID);
   }
   if (verb < 3)
      remove(outnam);
   return(i);
}


@iexp ip @(ip) 1 +
/* procedure @(ip) */
static char *GetResIdStr(ATL_@(ru)node_t *r1p, ATL_INT M, ATL_INT N,
                         ATL_INT lda, ATL_INT percL1, int mflop)
{
/* 
 * Return filename suffix that disambiguates most kernels:
 * <ID><TA>_<M>x<N>_<lda>-<ldamul>_<MU>x<NU>_<percL1>_a<alignA>x<aX>x<aY>_<flag>
 */
   static char ln[512];
@ROUT atlas_mvtesttime.h
   sprintf(ln, "%d%c_%dx%d_%d-%d_%dx%d_%d_a%dx%dx%d_%d", r1p->ID, 
           (r1p->TA == AtlasNoTrans) ? 'N' : 'T', M, N, lda, r1p->ldamul,
            r1p->MU, r1p->NU, percL1, r1p->alignA, r1p->alignX, r1p->alignY, 
            r1p->flag);
@ROUT atlas_r1testtime.h atlas_r2testtime.h
   sprintf(ln, "%d_%dx%d_%d-%d_%dx%d_%d_a%dx%dx%d_%d", r1p->ID, 
           M, N, lda, r1p->ldamul, r1p->MU, r1p->NU, percL1, 
           r1p->alignA, r1p->alignX, r1p->alignY, r1p->flag);
@ROUT atlas_r1testtime.h atlas_r2testtime.h atlas_mvtesttime.h
   return(ln);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static double Time@up@(rt)Kernel
(int verb,              /* 0: no output, 1 min ouput, 2: full output */
 int FORCETIME,         /* if nonzero, ignore existing timing file */
                        /* if negative, don't retain timing file */
 ATL_@(ru)node_t *r1p,     /* ptr to kernel structure */
 char pre,              /* precision prefix */
 ATL_INT M, ATL_INT N,  /* dimensions to time */
 ATL_INT lda,           /* stride between row elements */
 ATL_INT percL1,        /* if 0, time kernel directly wt no blocking */
                        /* if non-zero, block for that % of L1 cache size */
 int nrep,              /* if >=1, # of trials, else use default (3) */
 int mflop,             /* force mflop flops in each timing interval */
 int cflush             /* if >= 0, size of cache flush area, else ignored */
)
{
   char ln[2048], resf[256], *sp;
   double *dp, mf;
   int i, align = pre2size(pre);
   static char outnam[L_tmpnam];
   static int FirstTime=1;

   if (FirstTime)
   {
      
      FirstTime = 0;
      assert(tmpnam(outnam));
   }
/*
 * If the file is generated, call generator to create it
 */
   if (r1p->genstr)
   {
      i = sprintf(ln, "%s", r1p->genstr);
      if (verb < 3)
         i += sprintf(ln+i, " > %s 2>&1\n", outnam);
      if (system(ln))
      {
         fprintf(stderr, "ERROR, LINE %d of %s\n", __LINE__, __FILE__);
         fprintf(stderr, "UNABLE TO GENERATE WITH COMMAND: %s\n", r1p->genstr);
         if (verb < 3)
         {
            int itmp;
            fprintf(stderr, "\nOUTPUT OF system():\n");
            sprintf(ln, "cat %s 1>&2\n", outnam);
            itmp = system(ln);
         }
         exit(-1);
      }
   }

   if (r1p->minN)
      N = Mmax(N, r1p->minN);
   if (r1p->minM)
   {
      M = Mmax(M, r1p->minM);
      if (lda < M) 
         lda = M;
   }
   if (FLAG_IS_SET(r1p->flag, @up@(ru)F_FNU))
      N = Mmax(r1p->NU, (N/r1p->NU)*r1p->NU);
   i = r1p->ldamul / pre2size(pre);
   lda = (i) ? ((lda+i-1)/i)*i : lda;

   if (FORCETIME < 0)
      sprintf(resf, "res/%c@(rt)tmp", pre);
   else
      sprintf(resf, "res/%c@(rt)%s", pre, 
              GetResIdStr(r1p, M, N, lda, percL1, mflop));
   if (FORCETIME)
      remove(resf);
   dp = FORCETIME ? NULL : ReadResultsFile(0, nrep, resf);
   if (dp)
   {
      if (verb > 0)
         fprintf(stdout, "   %d:%s (M=%d, N=%d, lda=%d) gets %.2f MFLOPS\n", 
                 r1p->ID, r1p->rout, M, N, lda, *dp);
      return(*dp);
   }

@ROUT atlas_mvtesttime.h
   sp = (r1p->TA == AtlasNoTrans || r1p->TA == AtlasConj) ? "mvn" : "mvt";
   if (percL1)
      i = sprintf(ln, "make %c%stime M=%d N=%d lda=%d l1mul=%d %srout=\"%s\"",
                  pre, sp, M, N, lda, percL1, sp, r1p->rout);
   else
      i = sprintf(ln, "make %c%sktime M=%d N=%d lda=%d %srout=\"%s\"",
                  pre, sp, M, N, lda, sp, r1p->rout);
@ROUT atlas_r1testtime.h atlas_r2testtime.h
   if (percL1)
      i = sprintf(ln, "make %c@(rt)time M=%d N=%d lda=%d l1mul=%d @(rt)rout=\"%s\"",
                  pre, M, N, lda, percL1, r1p->rout);
   else
      i = sprintf(ln, "make %c@(rt)ktime M=%d N=%d lda=%d @(rt)rout=\"%s\"",
                  pre, M, N, lda, r1p->rout);
@ROUT atlas_r1testtime.h atlas_r2testtime.h atlas_mvtesttime.h
   if (r1p->flag)
      i += sprintf(ln+i, " iflag=%d", r1p->flag);
   if (r1p->exflags)
      i += sprintf(ln+i, " %s", r1p->exflags);
   if (r1p->comp)
      i += sprintf(ln+i, " %c@up@(rt)CC=\"%s\"", pre, r1p->comp);
   if (r1p->cflags)
@ROUT atlas_mvtesttime.h
      i += sprintf(ln+i, " %c@up@(rt)FLAGS=\"%s\"", pre, r1p->cflags);
@ROUT atlas_r1testtime.h atlas_r2testtime.h
      i += sprintf(ln+i, " %c@up@(rt)CFLAGS=\"%s\"", pre, r1p->cflags);
@ROUT atlas_r1testtime.h atlas_r2testtime.h atlas_mvtesttime.h
   i += SprintAlignStr(pre, r1p, ln+i);
   if (cflush >=0)
      i += sprintf(ln+i, " flushKB=%d", cflush);
   i += sprintf(ln+i, " tflags=\"-f %s", resf);
   if (nrep > 0)
      i += sprintf(ln+i, " -# %d", nrep);

   if (mflop >= 0)
      i += sprintf(ln+i, " -F %d", mflop);
   i += sprintf(ln+i, "\"");
   i += sprintf(ln+i, " mu=%d nu=%d", r1p->MU, r1p->NU);
   if (verb < 3)
      i += sprintf(ln+i, " > %s 2>&1\n", outnam);
   else
      i += sprintf(ln+i, "\n");
   i = system(ln);
   if (i)
   {
      fprintf(stderr, "\nERROR %d, LINE %d OF %s\n", i, __LINE__, __FILE__);
      fprintf(stderr, "SYSTEM CALL FAILED: %s\n", ln);
      if (verb < 3)
      {
         int itmp;
         fprintf(stderr, "\nOUTPUT OF system():\n");
         sprintf(ln, "cat %s 1>&2\n", outnam);
         itmp = system(ln);
         remove(outnam);
      }
      exit(-1);
   }
   if (verb < 3)
      remove(outnam);
   if (verb > 1)
   {
      dp = ReadResultsFile(1, nrep, resf);
      mf = PrintResultsFromFile(stdout, dp);
      free(dp);
      dp = &mf;
   }
   else
      dp = ReadResultsFile(0, nrep, resf);
   assert(dp);
   if (verb == 1)
      fprintf(stdout, "   %d:%s (M=%d, N=%d, lda=%d) gets %.2f MFLOPS\n", 
              r1p->ID, r1p->rout, M, N, lda, *dp);
   return(*dp);
}
@ROUT atlas_mvtesttime.h atlas_r1testtime.h atlas_r2testtime.h

static void FillIn@up@(rt)ExtractGenStrings(char pre, ATL_@(ru)node_t *kb)
/*
 * Creates generator strings to match kb settings
 */
{
   char ln[4096], *suff;
   int i, CL=8, mu;
   if (pre != 'd' && pre != 'c')
      CL = (pre == 'z') ? 4 : 16;
   while(kb)
   {
      if (kb->ID < 900000 || kb->ID >= 1000000) 
      {
         kb = kb->next;
         continue;
      }
      if (kb->asmbits == asmNames2bitfield("GAS_x8664"))
      {
         assert(kb->MU%CL == 0);
         suff = "sse";
         mu = kb->MU/CL;
      }
      else
      {
         mu = kb->MU;
         if (kb->SSE)
            suff = "Csse";
         else
            suff = "C";
      }
@ROUT atlas_mvtesttime.h
      if (kb->TA == AtlasNoTrans)
         i = sprintf(ln, "make %cmvnext_%s order=clmajor mu=%d nu=%d", pre, 
                     suff, mu, kb->NU);
      else
         i = sprintf(ln, "make %cmvtext_%s order=clmajor mu=%d nu=%d", pre, 
                     suff, mu, kb->NU);
@ROUT atlas_r1testtime.h atlas_r2testtime.h
      i = sprintf(ln, "make %c@(rt)ext_%s order=clmajor mu=%d nu=%d", pre, 
                  suff, mu, kb->NU);
@ROUT atlas_mvtesttime.h atlas_r1testtime.h atlas_r2testtime.h
      if (kb->alignA && kb->alignA%16==0 && kb->ldamul && kb->ldamul%16==0)
         i += sprintf(ln+i, " genflags=\"-def ALIGNED 1\"");
         
      if (kb->genstr)
         free(kb->genstr);
      kb->genstr = DupString(ln);
      kb = kb->next;
   }
}
@ROUT atlas_r1testtime.h atlas_r2testtime.h atlas_mvtesttime.h
#endif  /* end guard around atlas_@(rt)testtime.h */
@ROUT atlas_mmtesttime.h
@iexp ip @(ip) 1 +
/* procedure @(ip) */
double MMMflop2Time(char pre, int M, int N, int K, double mf)
/*
 * Translates mf back into time, assuming gemm timing of M,N,K
 */
{
   return((((2.0*M)*N)*K) / (1000000.0*mf));
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
double MMTime2Mflop(char pre, int M, int N, int K, double time)
/*
 * Translates mf back into time, assuming gemm timing of M,N,K
 */
{
   return((((2.0*M)*N)*K) / (1000000.0*time));
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
char *MMGetGenName(char pre, int kb, ATL_mmnode_t *mp)
{
#ifdef ATL_GENERATE  /* generating funcs get unique name */
   char *nm="amm";
   if (mp->blask == 1)
      nm = "syrk";
   else if (mp->blask == 2)
      nm = "symm";
   else if (mp->blask == 2)
      nm = "symm";
   else if (mp->blask == 3)
      nm = "trmm";
   return(GetMMFilename(pre, nm, mp));
#else                       /* tuning gets default name that is overwritten */
   return(DupString("ATL_tmp.c")); /* avoids cluttering dir wt unused files */
#endif
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
char *MMGetGenString
(
   char pre,                    /* precision/type prefix */
   ATL_mmnode_t *mp             /* mmkern ptr */
)
{
   char *frm="make gen_%s pre=%c rt=%s vec=%s vlen=%d mu=%d nu=%d ku=%d"
             " KB=%d bcast=%d pf=%d pfLS=%d";
   char *vec="mdim";
   char *gs, *sp;
   int len;
   int ku=mp->ku;
   int kb;

   if (FLAG_IS_SET(mp->flag, MMF_KUISKB))
   {
      if (FLAG_IS_SET(mp->flag, MMF_KVEC))
         ku = ((mp->kbB+mp->vlen-1)/mp->vlen)*mp->vlen;
      else
         ku = mp->kbB;
   }
   len = strlen(frm) + strlen(mp->rout) + 4;
   gs = malloc(len);
   assert(gs);
   if (mp->vlen < 2)
      vec = "no";
   else if (FLAG_IS_SET(mp->flag, MMF_KVEC))
   {
      vec = "kdim";
      if (!FLAG_IS_SET(mp->flag, MMF_KUISKB))
         assert(mp->ku % mp->vlen == 0);
   }
   else 
      assert(mp->mu % mp->vlen == 0);
   if (mp->blask == 1) /* 0:ammm, 1:syrk, 2:symm, 3:trmm */
      sp = "amsyrk";
   else if (mp->blask == 2)
      sp = "amsymm";
   else if (mp->blask == 3)
      sp = "amtrmm";
   else
      sp = "amm";

   if (FLAG_IS_SET(mp->flag, MMF_KRUNTIME))
      kb = 0;
   else if (FLAG_IS_SET(mp->flag, MMF_KVEC))
      kb = ((mp->kbB+mp->vlen-1)/mp->vlen)*mp->vlen;
   else
      kb = mp->kbB;
   sprintf(gs, frm, sp, pre, mp->rout, vec, mp->vlen, mp->mu, mp->nu, ku, kb,
           !FLAG_IS_SET(mp->flag, MMF_NOBCAST), mp->pref, mp->pfLS);
   return(gs);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
void MMFillInGenStrings(char pre, ATL_mmnode_t *mmb)
{
   ATL_mmnode_t *mp;

   if (pre == 'z')
      pre = 'd';
   else if (pre == 'c')
      pre = 's';

   for (mp=mmb; mp; mp = mp->next)
   {
      if (mp->ID == 0 && !mp->genstr)
         mp->genstr = MMGetGenString(pre, mp);
   }
}

@iexp ip @(ip) 1 +
/* procedure @(ip) : assumed kbB for routname */
void MMFillInGenNames(char pre, ATL_mmnode_t *mmb)
{
   ATL_mmnode_t *mp;
   if (pre == 'z')
      pre = 'd';
   else if (pre == 'c')
      pre = 's';

   for (mp=mmb; mp; mp = mp->next)
   {
      if (mp->ID == 0 && !mp->rout)
         mp->rout = MMGetGenName(pre, mp->kbB, mp);
   }
}

@iexp ip @(ip) 1 +
/* procedure @(ip) : fix genstrs and routs that may have gone stale */
void MMRefreshGenNodes(char pre, ATL_mmnode_t *mmb)
{
   ATL_mmnode_t *mp;
   const char upr=(pre == 'c' || pre == 's') ? 's' : 'z';

   for (mp=mmb; mp; mp = mp->next)
   {
      if (!mp->ID)
      {
         if (mp->rout)
            free(mp->rout);
         if (mp->genstr)
            free(mp->genstr);
         if (FLAG_IS_SET(mp->flag, MMF_KUISKB))
         {
            if (FLAG_IS_SET(mp->flag, MMF_KVEC))
            {
               mp->ku = mp->kbmax = ((mp->kbB+mp->vlen-1)/mp->vlen)*mp->vlen;
               mp->kbmin = mp->kbmax - mp->vlen + 1;
            }
            else
               mp->kbmin = mp->kbmax = mp->kbB;
         }
         else if (mp->ku > 1)
            mp->kbmin = mp->ku;
         mp->rout = MMGetGenName(pre, mp->kbB, mp);
         mp->genstr = MMGetGenString(pre, mp);
      }
   }
}
@iexp ip @(ip) 1 +
/* procedure @(ip) : fix genstrs and routs that may have gone stale */
void WriteRefreshedMMFileWithPath
   (char pre, char *path, char *file, ATL_mmnode_t *nq)
{
   MMRefreshGenNodes(pre, nq);
   WriteMMFileWithPath(pre, path, file, nq);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
ATL_mmnode_t *MMGetNodeGEN(char pre, int flag, int kb, int mu, int nu, int ku, 
                           int vlen, int KVEC, int pf, int pfLS, char *rt)
{
   ATL_mmnode_t *mp;

   mp = GetMMNode();
   mp->mu = mu;
   mp->nu = nu;
   mp->ku = ku;
   mp->vlen = vlen;
   mp->pref = pf;
   mp->pfLS = pfLS;
   if (flag&1)
      mp->flag |= (1<<MMF_NOBCAST);
@beginskip
// These guys presently unused, and setting them here causes flags not to 
// match when nodes are read in from file (type info not presently saved!)
   if (pre == 's' || pre == 'c' || pre == 'S' || pre == 'C')
      mp->flag |= (1<<MMF_SINGLE);
   if (pre == 'c' || pre == 'C' || pre == 'z' || pre == 'Z')
      mp->flag |= (1<<MMF_COMPLEX);
@endskip
   if (!kb)
      mp->flag |= (1<<MMF_KRUNTIME);
   else
      mp->kbB = kb;
   mp->vlen = vlen;
   if (KVEC && vlen > 1)
      mp->flag |= (1<<MMF_KVEC);
   else if (vlen < 2)
      KVEC=1;
   if (!rt)
      rt = MMGetGenName(pre, kb, mp);
   mp->rout = rt;
   mp->genstr = MMGetGenString(pre, mp);
   return(mp);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
int MMDoGenString(int verb, char *genstr)
{
   int err=0;
   if (!genstr)
      err=1;
   else if (verb < 3) /* want to redirect output */
   {
      char *ln;
      ln = NewMergedString(genstr, " > /dev/null 2>&1");
      err = system(ln);
      free(ln);
   }
   else
      err = system(genstr);
   if (err)
      fprintf(stderr, "UNABLE TO GENERATE WITH COMMAND: '%s'\n", 
              genstr ? genstr : "NULL");
   return(err);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
char *MMGetTestString
(
   char pre,                    /* precision/type prefix */
   int mb, int nb, int kb,      /* dimensions to test */
   int beta,                    /* beta case to test */
   ATL_mmnode_t *mp            /* mmkern ptr */
)
{
   int i, k, Dd, Ud, Vd;
   int len;
   char *ln, *nm;
/*
 * Horrific code so we don't have to rely on snprintf, which some ancient
 * compiler may lack.  The len adjustments should be >= the following
 * sprintf calls (in same order, so they can be adjusted together)
 */
   switch(mp->blask)
   {
   case 1:
      nm = "syrk";
      break;
   case 2:
      nm = "symm";
      break;
   case 3:
      nm = "trmm";
      break;
   default:
      nm = "ammm";
   }
   len = 22 + 21;                              /* begin & end */
   len += strlen(mp->rout);
   if (mp->ID > 0)
      len += 9;                                /* "AMMCASES/" */
   len += 38 + NumDecDigits(mb) + NumDecDigits(nb) + NumDecDigits(kb);
   len += 16 + NumDecDigits(mp->mu)+NumDecDigits(mp->nu)+NumDecDigits(mp->ku);
   @whiledef iv szA szB szC szExtra vlen
      len += @len@(iv) + 2 + NumDecDigits(mp->@(iv));
   @endwhile
   if (FLAG_IS_SET(mp->flag, MMF_KVEC))
      len += 5 + NumDecDigits(mp->vlen);
   if (beta != 1)
      len += (beta == -1) ? 21 : 6;
   if (mp->comp)
      len += 28 + strlen(mp->comp) + strlen(mp->cflags);

   ln = malloc(len);
   assert(ln);

   i = sprintf(ln, "make %c%stst mmrout=", pre, nm);
   if (mp->ID > 0)
      i += sprintf(ln+i, "AMMCASES/%s ", mp->rout);
   else
      i += sprintf(ln+i, "%s ", mp->rout);
   i += sprintf(ln+i, "pre=%c M=%d N=%d K=%d mb=0 nb=0 kb=%d ",
                pre, mb, nb, kb, FLAG_IS_SET(mp->flag, MMF_KRUNTIME)?0:kb);
   i += sprintf(ln+i, "mu=%d nu=%d ku=%d ", mp->mu, mp->nu, mp->ku);
   @whiledef iv szA szB szC szExtra vlen
    if (mp->@(iv))
       i += sprintf(ln+i, "@(iv)=%d ", mp->@(iv));
   @endwhile
   if (FLAG_IS_SET(mp->flag, MMF_KVEC))
      i += sprintf(ln+i, "kmaj=%d ", mp->vlen);
   if (beta != 1)
   {
      if (beta == -1)
         i += sprintf(ln+i, "beta=-1 betan=\"N1\" ");
      else if (beta == 0)
         i += sprintf(ln+i, "beta=%d ", beta);
      else
         assert(0);
   }
   if (mp->comp)
   {
      char ch = (pre == 'c' || pre == 's') ? 'S' : 'D';
      i += sprintf(ln+i, "%cMC=\"%s\" %cMCFLAGS=\"%s\" ",
                   ch, mp->comp, ch, mp->cflags);
   }
   i += sprintf(ln+i, " > /dev/null 2>&1\n");
   assert(i < len);
   return(ln);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
int MMKernelFailsTest
(
   char pre,                    /* precision/type prefix */
   int mb, int nb, int kb,      /* dimensions to test */
   int beta,                    /* beta case to test */
   ATL_mmnode_t *umm            /* mmkern ptr */
)
/*
 * RETURNS: 0 on success, non-zero on failure
 */
{
   char *ln;
   int i;
   char ch;

/*
 * If the file is generated, call generator to create it
 */
   if (umm->ID == 0 && !umm->genstr)
      umm->genstr = MMGetGenString(pre, umm);
   if (umm->genstr)
      assert(!MMDoGenString(0, umm->genstr));
   ln = MMGetTestString(pre, mb, nb, kb, beta, umm);
   i = system(ln);
   if (i)
   {
      fprintf(stderr, "%d of %s: FAILED COMMAND : %s\n",__LINE__,__FILE__,ln);
      if (umm->genstr)
         fprintf(stderr, "   genstr was = '%s'\n", umm->genstr);
   }
   free(ln);
   return(i);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
int MMKernelFailsAnyBeta
(
   char pre,                    /* precision/type prefix */
   int mb, int nb, int kb,      /* dimensions to test */
   ATL_mmnode_t *umm            /* mmkern ptr */
)
/*
 * RETURNS: 0 on success, non-zero on failure
 */
{
   int i;

   for (i=-1; i < 2; i++)
      if (MMKernelFailsTest(pre, mb, nb, kb, i, umm))
        return(1);
   return(0);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static ATL_mmnode_t *DelBadMMKernels(char pre, int verb, ATL_mmnode_t *bp)
/*
 * Deletes all kernels that can't pass basic usage test
 * RETURNS: modifed bp queue wt failing kernels removed
 */
{
   ATL_mmnode_t *p, *prev;
   int die;

   if (verb > 0)
       printf("\nBEGIN BASIC MATMUL KERNEL TESTS:\n");

   prev = p = bp;
   while (p)
   {
      if (MMKernelFailsTest(pre, p->mbB, p->nbB, p->kbB, 0, p) ||
          MMKernelFailsTest(pre, p->mbB, p->nbB, p->kbB, 1, p) ||
          MMKernelFailsTest(pre, p->mbB, p->nbB, p->kbB, -1, p))
      {
         if (verb > 0)
            printf("   NUKING bad kernel %s(%d)\n", p->rout, p->ID);
         if (p == bp)
            bp = p = KillMMNode(p);
         else
            prev->next = p = KillMMNode(p);
      }
      else
      {
         if (verb > 0)
            printf("   Kernel %s(%d) passes basic tests\n", p->rout, p->ID);
         prev = p;
         p = p->next;
      }
   }
   printf("DONE BASIC KERNEL TESTS.\n\n");
   return(bp);
}

@beginskip
@iexp ip @(ip) 1 +
/* procedure @(ip) */
char *GetGmmGenString
(
   int verb,                    /* verbosity */
   char pre,                    /* precision */
   int MACC,                    /* 0 : separate mult&add, else MACC */
   int lat,                     /* multiply latency */
   int beta,                    /* 0,1 beta, else beta=X */
   int nb,                      /* blocking factor */
   int mu, int nu, int ku,      /* unrolling factors */
   int Fftch,                   /* do bogus fetch of C at top of loop? */
   int iftch,                   /* # of initial fetches to do */
   int nftch,                   /* # of fetches to do thereafter */
   int LDTOP,                   /* 1: load C at top, 0: at bottom */
   int pf                       /* prefetch strategy */
)
/*
 * returns a string that will result in generating a user-style kernel
 * specialized for non-cleanup cases by invoking a make target that
 * in turn invokes the scalar generator routine, emit_mm.c
 * Because it is specialized for kernel cases, we don't specify leading
 * dimensions, transpose cases, etc, but just take the defaults.
 */
{
   char ln[4096];
   int i;

   if (!LDTOP)
      pf |= 512;
   i = sprintf(ln, "make mmgencase pre=%c muladd=%d lat=%d beta=%d mb=%d nb=%d kb=%d mu=%d nu=%d ku=%d if=%d nf=%d ff=%d, pfA=%d, csC=%d",
               pre, MACC, lat, beta, nb, nb, nb, mu, nu, ku, iftch, nftch, 
               Fftch, pf, (pre == 'c' || pre == 'z') ? 2 : 1);
   if (verb < 3)
      i += sprintf(ln+i, " > /dev/null 2>&1");
   else
      i += sprintf(ln+i, "\n");
   if (verb > 2)
      printf("genstr='%s'\n", ln);
   return(DupString(ln));
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
void FillInGMMNode(int verb, ATL_mmnode_t *mmp, char pre, int MACC, int lat, 
                   int beta, int nb, int mu, int nu, int ku, 
                   int fftch, int iftch, int nftch, int LDTOP, int pf)
/*
 * Take emit_mm's flags and fill in the standard ATL_mmnode_t struct mmp
 * making all the correct assumptions for the standard copy code
 */
{
   int i;

   if (ku > (nb>>1))
      ku = nb;
   mmp->mbB = mmp->nbB = mmp->kbB = nb;
   mmp->mu = mu;
   mmp->nu = nu;
   mmp->ku = ku;
   mmp->muladd = MACC;
   mmp->lat = lat;
   mmp->fftch = fftch;
   mmp->iftch = iftch;
   mmp->nftch = nftch;
   mmp->pref = pf;
   mmp->SSE = 0;
   mmp->TA = AtlasTrans;
   mmp->TB = AtlasNoTrans;
   mmp->asmbits = 0;
   if (mmp->auth)
      free(mmp->auth);
   if (mmp->rout)
      free(mmp->rout);
   if (mmp->comp)
      free(mmp->comp);
   if (mmp->cflags)
      free(mmp->cflags);
   if (mmp->str)
      free(mmp->str);
   if (mmp->genstr)
      free(mmp->genstr);
   mmp->comp = mmp->cflags = mmp->str = NULL;
   mmp->rout = DupString("dgmm.c");
   mmp->rout[0] = pre;
   mmp->genstr = GetGmmGenString(verb, pre, MACC, lat, beta, nb, mu, nu, ku, 
                                 fftch, iftch, nftch, LDTOP, pf);
   mmp->auth = DupString("Whaley/emit_mm");
   i = 0;
   if (pre == 's' || pre == 'c')
      SET_FLAG(i, MMF_SINGLE, 1);
   if (pre == 'c' || pre == 'z')
      SET_FLAG(i, MMF_COMPLEX, 1);
   mmp->flag = i;
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
double TimeGMMKernel            /* times kernels generated by emit_mm */
(
   int verb,                    /* verbosity */
   int FORCETIME,               /* 1: ignore any prior output file */
   char pre,                    /* precision */
   int MACC,                    /* 0 : separate mult&add, else MACC */
   int lat,                     /* multiply latency */
   int beta,                    /* 0,1 beta, else beta=X */
   int nb,                      /* blocking factor */
   int mu, int nu, int ku,      /* unrolling factors */
   int Fftch,                   /* do bogus fetch of C at top of loop? */
   int iftch,                   /* # of initial fetches to do */
   int nftch,                   /* # of fetches to do thereafter */
   int LDTOP,                   /* 1: load C at top, 0: at bottom */
   int pf,                      /* prefetch strategy */
   int mflop,                   /* >0: force mflop MFLOPs in each time interv */
   int cflush                   /* >0: size of cache flush, else ignored */
)
{
   int i;
   char *bet;
   FILE *fp;
   double *dp;
   char fnam[256];
   char ln[4096];

   if (beta == 1)
      bet = "_b1";
   else if (beta == 0)
      bet = "_b0";
   else if (beta == -1)
      bet = "_bn1";
   else
      bet = "_bX";
   if (!LDTOP)
      pf |= 512;
   if (ku > nb/2)
      ku = nb;
   else if (ku == -1)
      ku = nb;
   sprintf(fnam,
           "res/%c%smm%c%c%d_%dx%dx%d_%dx%dx%d_%dx%dx%d%s%s_%dx%d_%d_pf%d_cf%d",
            pre, "JIK", 'T', 'N', nb, nb, nb, nb, nb, nb, 0, mu, nu, ku,
            "_a1", bet, MACC, lat, 1, pf, cflush);
   dp = (FORCETIME) ? NULL : ReadResultsFile(0, 0, fnam);
   if (!dp)
   {
      i = sprintf(ln, "make mmcase pre=%c loopO=JIK ta=T tb=N mb=%d nb=%d kb=%d lda=%d ldb=%d ldc=%d mu=%d nu=%d ku=%d alpha=1 beta=%d muladd=%d lat=%d cleanup=1 pfA=%d casnam=\"%s\"",
                  pre, nb, nb, nb, nb, nb, 0, mu, nu, ku, beta, MACC, lat, pf,
                  fnam);
      if (pre == 'c' || pre == 'z')
         i += sprintf(ln+i, " csA=1 csB=1 csC=2");
       
      if (verb < 3)
         i += sprintf(ln+i, " > /dev/null 2>&1\n");
      else
         i += sprintf(ln+i, "\n");
      if (verb > 1)
         fprintf(stdout, "SYSTEM: %s", ln);
      if (system(ln))
      {
         fprintf(stderr, "ERROR IN COMMAND: %s", ln);
         fprintf(stderr, "   PROPOSED FILENAME: %s\n", fnam);
         sprintf(ln, "rm -f %s\n", fnam);
         assert(!system(ln));
         exit(-1);
      }
      dp = ReadResultsFile(0, 0, fnam);
   }
   if (dp == NULL)
   {
      fprintf(stderr, "Failed ReadResultsFile, ln='%s'\n", ln); 
      fprintf(stderr, "fnam=%s\n", fnam); 
   }
   assert(dp);
   return(*dp);
}
@endskip

@iexp ip @(ip) 1 +
/* procedure @(ip) */
void MMFixGenK(char pre, ATL_mmnode_t *mb, int K)
{
   ATL_mmnode_t *mp;

   for (mp=mb; mp; mp = mp->next)
   {
      if (!mp->ID && FLAG_IS_SET(mp->flag, MMF_KUISKB) && mp->kbB != K)
      {
         mp->kbmax = mp->kbmin = mp->ku = mp->kbB = K;
         if (!mp->rout)
            mp->rout = DupString("ATL_tmp.c");
         if (mp->genstr)
            free(mp->genstr);
         mp->genstr = MMGetGenString(pre, mp);
      }
   }
}
@iexp ip @(ip) 1 +
/* procedure @(ip) */
double TimeMMKernel3F
(
   int verb,                    /* 0: no output, 1 min output, 2: full output */
   int flag,                   /* 1: ignore any prior output file */
   ATL_mmnode_t *mmp,           /* ptr to mmkern struct */
   char pre,                    /* type/prec prefix: z,c,d,s */
   int mb, int nb, int kb,      /* dimensions to time */
   int beta,                    /* beta to time */
   int mflop,                   /* >0: force mflop MFLOPs in each time interv */
   int cflush,                  /* >=0: size of cache flush, else ignored */
   int aFL,                     /* >=0: size of cache flush, else ignored */
   int bFL,                     /* >=0: size of cache flush, else ignored */
   int cFL                      /* >=0: size of cache flush, else ignored */
)
/*
 * flag - take actions the following actions if bit location is set:
 *    0 : ignore any prior output file on output
 *    1 : time in serial rather than parallel
 */
{
   char fnam[128], ln[4096];  /* security from 1991 */
   const char *LO = FLAG_IS_SET(mmp->flag, MMF_AOUTER) ? "IJK": "JIK";
   const int vl=mmp->vlen;
   const int ku=mmp->ku;
   const int KB = (!FLAG_IS_SET(mmp->flag,MMF_KVEC)) ? kb : ((kb+vl-1)/vl)*vl;
   const int FORCETIME = flag&1, SERIAL=flag&2;
   int KU=mmp->ku;
   int DOTIME=1;
   int MV=3;  /* bit pattern on move CBA (C=4, B=2, A=1) */
   char *be, *gs0=mmp->genstr;
   int i, j;
   char ch;
   double *dp;
   MV = ((mmp->flag) >> MMF_MVA)&7;
/*
 * If it's a emit_mm generated file with a missing or bad genstring, make it
 */

   if (FLAG_IS_SET(mmp->flag, MMF_KUISKB))
      KU = KB;
   else if (ku > KB)
      KU = KB;
   if (mmp->ID == 0 && (KB != mmp->kbB || KU != mmp->ku || !mmp->genstr))
   {
      int kb0=mmp->kbB, ku0=mmp->ku;
      mmp->kbB = KB;
      mmp->ku = KU;
      mmp->genstr = MMGetGenString(pre, mmp);
      mmp->kbB = kb0;
      mmp->ku = ku0;
   }
/*
 * If the file is generated, call generator to create it
 */
   if (mmp->genstr)
      assert(!MMDoGenString(verb, mmp->genstr));
   else if (verb > 2)
      printf("NO genstr\n");
/*
 * Figure out the name of the output file
 */
   if (FORCETIME)
      strcpy(fnam, "res/tmpout.ktim");
/*
 * PREammID_MBxNBxKB_MUxNUxKU_FLAG_v[M,K]VLENbBETA_CFLUSH
 */
   else
   {
      if (mmp->vlen < 2)
         ch = 'S';
      else
         ch = (FLAG_IS_SET(mmp->flag,MMF_KVEC)) ? 'K' : 'M';

      sprintf(fnam,
      "res/%cammm%d_%dx%dx%d_%dx%dx%d_%x_v%c%db%d_pf%xx%d_%d.ktim",
              pre, mmp->ID, mb, nb, KB, mmp->mu, mmp->nu, KU,
              mmp->flag, ch, mmp->vlen, beta, mmp->pref, mmp->pfLS, cflush);
      if (mmp->blask == 1)
      {
         fnam[5] = 's';
         fnam[6] = 'y';
         fnam[7] = 'r';
         fnam[8] = 'k';
      }
      else if (mmp->blask == 2)
      {
         fnam[5] = 's';
         fnam[6] = 'y';
         fnam[7] = 'm';
         fnam[8] = 'm';
      }
      else if (mmp->blask == 3)
      {
         fnam[5] = 't';
         fnam[6] = 'r';
         fnam[7] = 'm';
         fnam[8] = 'm';
      }
   }
/*
 * If we actually need to do timing, must also construct timer call
 */
   if (!FORCETIME)
      DOTIME = !FileExists(fnam);
   #define RESACT 2   /* want average frm ReadResultsFile for parallel */
   if (DOTIME)
   {
      char *nm="amm";
      if (mmp->blask == 1)
         nm = "syk";
      else if (mmp->blask == 2)
         nm = "sym";
      else if (mmp->blask == 3)
         nm = "trm";
      i = sprintf(ln, "make x%c%stime_pt3f mb=%d nb=%d kb=%d",
                  pre, nm, mb, nb, KB);
      if (mflop)
         i += sprintf(ln+i, " FMFS=\"-Rf %d\"", mflop);
      if (SERIAL)
         i += sprintf(ln+i, " NPROC=1");
      if (mmp->genstr)
         i += sprintf(ln+i, " mmrout=%s", mmp->rout);
      else
         i += sprintf(ln+i, " mmrout=AMMCASES/%s", mmp->rout);
      i += sprintf(ln+i, " mu=%d nu=%d ku=%d", mmp->mu, mmp->nu, KU);
    if (mmp->vlen)
       i += sprintf(ln+i, " vlen=%d", mmp->vlen);
    if (mmp->szExtra)
       i += sprintf(ln+i, " szExtra=%d", mmp->szExtra);
    if (mmp->szC)
       i += sprintf(ln+i, " szC=%d", mmp->szC);
    if (mmp->szB)
       i += sprintf(ln+i, " szB=%d", mmp->szB);
    if (mmp->szA)
       i += sprintf(ln+i, " szA=%d", mmp->szA);
      i += sprintf(ln+i, " mvA=%d mvB=%d mvC=%d", ((mmp->flag >> MMF_MVA)&1),
                   ((mmp->flag >> MMF_MVB)&1), ((mmp->flag >> MMF_MVC)&1));
      i += sprintf(ln+i, " kmoves=\"");
      if (FLAG_IS_SET(mmp->flag, MMF_MVA))
         i += sprintf(ln+i, " -DATL_MOVEA");
      if (FLAG_IS_SET(mmp->flag, MMF_MVB))
         i += sprintf(ln+i, " -DATL_MOVEB");
      if (FLAG_IS_SET(mmp->flag, MMF_MVC))
      i += sprintf(ln+i, " -DATL_MOVEC");
      i += sprintf(ln+i, "\"");
      //if (cflush > 0 || aFL > 0 || bFL > 0 || cFL > 0)
      {
         if (cflush > 0)
               i+= sprintf(ln+i, " CFLUSH=\"%d ", cflush);
            else
               i+= sprintf(ln+i, " CFLUSH=\"%d", -1);
            if (aFL > 0)
               i+= sprintf(ln+i, " -Fa %d ", aFL);
            if (bFL > 0)
               i+= sprintf(ln+i, " -Fb %d ", bFL);
            if (cFL > 0)
               i+= sprintf(ln+i, " -Fc %d ", cFL);
            i+= sprintf(ln+i, " \"");
      }
      if (mmp->pref)
      {
         if (mmp->pfLS)
            i += sprintf(ln+i, " pf=%d pfLS=%d", mmp->pref, mmp->pfLS);
         else
            i += sprintf(ln+i, " pf=%d", mmp->pref);
      }
      if (beta == 1 || beta == 0)
         i += sprintf(ln+i, " beta=%d", beta);
      else
         i += sprintf(ln+i, " beta=-1 betan=\"N1\"");
      ch = (pre == 'c' || pre == 's') ? 'S' : 'D';
      if (mmp->comp)
         i += sprintf(ln+i, " %cMC=\"%s\"", ch, mmp->comp);
      if (mmp->cflags)
         i += sprintf(ln+i, " %cMCFLAGS=\"%s\"", ch, mmp->cflags);
      i += sprintf(ln+i, " outF=\"-f %s\"", fnam);
   }
   if (FORCETIME || !FileExists(fnam))
   {
      if (verb < 3)
         i += sprintf(ln+i, " > /dev/null 2>&1\n");
      else
         i += sprintf(ln+i, "\n");
      if (verb > 1)
         fprintf(stdout, "SYSTEM: %s", ln);
      if (i=system(ln))
      {
         fprintf(stderr, "ERROR %d IN COMMAND: %s", i, ln);
         fprintf(stderr, "   PROPOSED FILENAME: %s\n", fnam);
         if (mmp->genstr)
            fprintf(stderr, "   GENSTR='%s'\n", mmp->genstr);
         sprintf(ln, "rm -f %s\n", fnam);
         assert(!system(ln));
         exit(-1);
      }
   }
   if (mmp->genstr != gs0)  /* put genstr back to original value */
   {
      free(mmp->genstr);
      mmp->genstr = gs0;
   }
   dp = ReadResultsFile(RESACT, 0, fnam);
   if (!dp)
   {
      fprintf(stderr, "\nEmpty file '%s'!\n", fnam);
      fprintf(stderr, "From command: '%s'\n", ln);
      fprintf(stderr, "DOTIME=%d, genstr='%s'\n", DOTIME,
              (mmp->genstr) ? mmp->genstr : "");
      exit(-1);
   }
   if (mmp->genstr && DOTIME)
   {
      sprintf(ln, "rm %s\n", mmp->rout);
      i = system(ln);  /* return value unused, just to shut gcc up */
   }
   if (kb != KB)
   {
      double mf;
      mf = *((double*)ReadResultsFile(RESACT, 0, fnam));
      mf = (mf / KB)*kb;
      return(mf);
   }
   return(*((double*)ReadResultsFile(RESACT, 0, fnam)));
   #undef RESACT
}  /* end TimeMMKernel3F */

@iexp ip @(ip) 1 +
/* procedure @(ip) */
double TimeMMKernel
(
   int verb,                    /* 0: no output, 1 min output, 2: full output */
   int flag,                   /* 1: ignore any prior output file */
   ATL_mmnode_t *mmp,           /* ptr to mmkern struct */
   char pre,                    /* type/prec prefix: z,c,d,s */
   int mb, int nb, int kb,      /* dimensions to time */
   int beta,                    /* beta to time */
   int mflop,                   /* >0: force mflop MFLOPs in each time interv */
   int cflush                   /* >=0: size of cache flush, else ignored */
)
/*
 * flag - take actions the following actions if bit location is set:
 *    0 : ignore any prior output file on output
 *    1 : time in serial rather than parallel
 */
{
   char fnam[128], ln[4096];  /* security from 1991 */
   const char *LO = FLAG_IS_SET(mmp->flag, MMF_AOUTER) ? "IJK": "JIK";
   const int vl=mmp->vlen;
   const int ku=mmp->ku;
   const int KB = (!FLAG_IS_SET(mmp->flag,MMF_KVEC)) ? kb : ((kb+vl-1)/vl)*vl;
   const int FORCETIME = flag&1, SERIAL=flag&2;
   int KU=mmp->ku;
   int DOTIME=1;
   int MV=3;  /* bit pattern on move CBA (C=4, B=2, A=1) */
   char *be, *gs0=mmp->genstr;
   int i, j;
   char ch;
   double *dp;
   MV = ((mmp->flag) >> MMF_MVA)&7;
/*
 * If it's a emit_mm generated file with a missing or bad genstring, make it
 */
   
   if (FLAG_IS_SET(mmp->flag, MMF_KUISKB))
      KU = KB;
   else if (ku > KB)
      KU = KB;
   if (mmp->ID == 0 && (KB != mmp->kbB || KU != mmp->ku || !mmp->genstr))
   {
      int kb0=mmp->kbB, ku0=mmp->ku;
      mmp->kbB = KB;
      mmp->ku = KU;
      mmp->genstr = MMGetGenString(pre, mmp);
      mmp->kbB = kb0;
      mmp->ku = ku0;
   }
/*
 * If the file is generated, call generator to create it
 */
   if (mmp->genstr)
      assert(!MMDoGenString(verb, mmp->genstr));
   else if (verb > 2)
      printf("NO genstr\n");
/*
 * Figure out the name of the output file
 */
   if (FORCETIME)
      strcpy(fnam, "res/tmpout.ktim");
/*
 * PREammID_MBxNBxKB_MUxNUxKU_FLAG_v[M,K]VLENbBETA_CFLUSH
 */
   else
   {
      if (mmp->vlen < 2)
         ch = 'S';
      else
         ch = (FLAG_IS_SET(mmp->flag,MMF_KVEC)) ? 'K' : 'M';

      sprintf(fnam, 
      "res/%cammm%d_%dx%dx%d_%dx%dx%d_%x_v%c%db%d_pf%xx%d_%d.ktim",
              pre, mmp->ID, mb, nb, KB, mmp->mu, mmp->nu, KU, 
              mmp->flag, ch, mmp->vlen, beta, mmp->pref, mmp->pfLS, cflush);
      if (mmp->blask == 1)
      {
         fnam[5] = 's';
         fnam[6] = 'y';
         fnam[7] = 'r';
         fnam[8] = 'k';
      }
      else if (mmp->blask == 2)
      {
         fnam[5] = 's';
         fnam[6] = 'y';
         fnam[7] = 'm';
         fnam[8] = 'm';
      }
      else if (mmp->blask == 3)
      {
         fnam[5] = 't';
         fnam[6] = 'r';
         fnam[7] = 'm';
         fnam[8] = 'm';
      }
   }
/* 
 * If we actually need to do timing, must also construct timer call
 */
   if (!FORCETIME)
      DOTIME = !FileExists(fnam);
   #define RESACT 2   /* want average frm ReadResultsFile for parallel */
   if (DOTIME)
   {
      char *nm="amm";
      if (mmp->blask == 1)
         nm = "syk";
      else if (mmp->blask == 2)
         nm = "sym";
      else if (mmp->blask == 3)
         nm = "trm";
      i = sprintf(ln, "make x%c%stime_pt mb=%d nb=%d kb=%d",
                  pre, nm, mb, nb, KB);
      if (mflop)
         i += sprintf(ln+i, " FMFS=\"-Rf %d\"", mflop);
      if (SERIAL)
         i += sprintf(ln+i, " NPROC=1");
      if (mmp->genstr)
         i += sprintf(ln+i, " mmrout=%s", mmp->rout);
      else
         i += sprintf(ln+i, " mmrout=AMMCASES/%s", mmp->rout);
      i += sprintf(ln+i, " mu=%d nu=%d ku=%d", mmp->mu, mmp->nu, KU);
   @whiledef iv szA szB szC szExtra vlen
    if (mmp->@(iv))
       i += sprintf(ln+i, " @(iv)=%d", mmp->@(iv));
   @endwhile
      i += sprintf(ln+i, " mvA=%d mvB=%d mvC=%d", ((mmp->flag >> MMF_MVA)&1), 
                   ((mmp->flag >> MMF_MVB)&1), ((mmp->flag >> MMF_MVC)&1));
      i += sprintf(ln+i, " kmoves=\"");
      if (FLAG_IS_SET(mmp->flag, MMF_MVA))
         i += sprintf(ln+i, " -DATL_MOVEA");
      if (FLAG_IS_SET(mmp->flag, MMF_MVB))
         i += sprintf(ln+i, " -DATL_MOVEB");
      if (FLAG_IS_SET(mmp->flag, MMF_MVC))
      i += sprintf(ln+i, " -DATL_MOVEC");
      i += sprintf(ln+i, "\"");
      if (mmp->pref)
      {
         if (mmp->pfLS)
            i += sprintf(ln+i, " pf=%d pfLS=%d", mmp->pref, mmp->pfLS);
         else
            i += sprintf(ln+i, " pf=%d", mmp->pref);
      }
      if (beta == 1 || beta == 0)
         i += sprintf(ln+i, " beta=%d", beta);
      else
         i += sprintf(ln+i, " beta=-1 betan=\"N1\"");
      ch = (pre == 'c' || pre == 's') ? 'S' : 'D';
      if (mmp->comp)
         i += sprintf(ln+i, " %cMC=\"%s\"", ch, mmp->comp);
      if (mmp->cflags)
         i += sprintf(ln+i, " %cMCFLAGS=\"%s\"", ch, mmp->cflags);
      i += sprintf(ln+i, " outF=\"-f %s\"", fnam);
   }
   if (FORCETIME || !FileExists(fnam))
   {
      if (verb < 3)
         i += sprintf(ln+i, " > /dev/null 2>&1\n");
      else
         i += sprintf(ln+i, "\n");
      if (verb > 1)
         fprintf(stdout, "SYSTEM: %s", ln);
      if (system(ln))
      {
         fprintf(stderr, "ERROR IN COMMAND: %s", ln);
         fprintf(stderr, "   PROPOSED FILENAME: %s\n", fnam);
         if (mmp->genstr)
            fprintf(stderr, "   GENSTR='%s'\n", mmp->genstr);
         sprintf(ln, "rm -f %s\n", fnam);
         assert(!system(ln));
         exit(-1);
      }
   }
   if (mmp->genstr != gs0)  /* put genstr back to original value */
   {
      free(mmp->genstr);
      mmp->genstr = gs0;
   }
   dp = ReadResultsFile(RESACT, 0, fnam);
   if (!dp)
   {
      fprintf(stderr, "\nEmpty file '%s'!\n", fnam);
      fprintf(stderr, "From command: '%s'\n", ln);
      fprintf(stderr, "DOTIME=%d, genstr='%s'\n", DOTIME, 
              (mmp->genstr) ? mmp->genstr : "");
      exit(-1);
   }
   if (mmp->genstr && DOTIME)
   {
      sprintf(ln, "rm %s\n", mmp->rout);
      i = system(ln);  /* return value unused, just to shut gcc up */
   }
   if (kb != KB)
   {
      double mf;
      mf = *((double*)ReadResultsFile(RESACT, 0, fnam));
      mf = (mf / KB)*kb;
      return(mf);
   }
   return(*((double*)ReadResultsFile(RESACT, 0, fnam)));
   #undef RESACT
}  /* end TimeMMKernel */

@iexp ip @(ip) 1 +
/* procedure @(ip), times all 3 vectorization schemes */
ATL_mmnode_t *MMTimeWithGenKB
(
   int verb,                    /* 0: no output, 1 min output, 2: full output */
   int imf,                     /* which mflop array to write to */
   int flag,                    
   ATL_mmnode_t *mmp,           /* ptr to mmkern struct */
   char pre,                    /* type/prec prefix: z,c,d,s */
   int mb, int nb, int kb,      /* dimensions to time */
   int beta,                    /* beta to time */
   int mflop,                   /* >0: force mflop MFLOPs in each time interv */
   int cflush                   /* >=0: size of cache flush, else ignored */
)
/*
 * RETURNS: NULL if kernel cannot support this case, else newly allocated
 *          fully-qualified mmnode describing exact case
 */
{
   int kbOK;
   char *sp;
   ATL_mmnode_t *mp;
   if (!mmp->ID) /* genned: kvec OK wt any mul of vlen, mvec OK wt any K */
      kbOK = FLAG_IS_SET(mmp->flag, MMF_KVEC) ? (kb%mmp->vlen == 0):1;
   else
   {
      kbOK = (mmp->kbmin) ? (nb >= mmp->kbmin) : 1;
      if (kbOK && mmp->kbmax)
         kbOK = nb <= mmp->kbmax;
   }
   kbOK = kbOK && (kb%mmp->ku == 0);
   if (!kbOK || ((mb/mmp->mu)*mmp->mu != mb) || ((nb/mmp->nu)*mmp->nu != nb))
      return(NULL);
   sp = mmp->genstr;
   mmp->genstr=NULL;
   mp = CloneMMNode(mmp);  /* get local copy so we can change */
   mmp->genstr = sp;
   mmp = mp;
   mmp->mbB = mb; mmp->nbB = nb; mmp->kbB = kb;
/*
 * Generated files may need to get genstr and related info corrected
 */
   if (mmp->ID == 0)
   {
      if (FLAG_IS_SET(mmp->flag, MMF_KUISKB))
          mmp->kbmax = mmp->kbmin = mmp->ku = kb;
      if (!FLAG_IS_SET(mmp->flag, MMF_KRUNTIME))
          mmp->kbB = kb;
      mmp->genstr = MMGetGenString(pre, mmp);
   }
   mmp->mflop[imf] = TimeMMKernel(verb, flag, mmp, pre, mb, nb, kb, 
                                  beta, mflop, cflush);
   return(mmp);
}

@iexp ip @(ip) 1 +
/* procedure @(ip), times all 3 vectorization schemes */
void MMPruneMflopTol
(
   ATL_mmnode_t *mmb,           /* ptr to mmkern struct queue */
   int imf,                     /* which mflop array to write to */
   float tol                    /* >1 allow slow kerns, < 1 penalize later */
)
/*
 * First entry always retained.  Later entries must be better than
 * prior best when scaled by tol.  So, tol > 1 will retain slower kernels,
 * while tol < 1 will penalize later kernels.
 */
{
   ATL_mmnode_t *mp;
   double mfB;

   if (tol <= 0.0 || !mmb)
      return;
   mfB = mmb->mflop[imf];

   mp = mmb->next;
   while (mp)
   {
      ATL_mmnode_t *next = mp->next;
      double mf = mp->mflop[imf];
      if (mf*tol < mfB)
      {
         mmb = RemoveMMNodeFromQ(mmb, mp);
         KillMMNode(mp);
      }
      else if (mf > mfB)
         mfB = mf;
      mp = next;
   }
}

@iexp ip @(ip) 1 +
/* procedure @(ip), times all 3 vectorization schemes */
ATL_mmnode_t *MMBestWithGenKB
(
   int verb,                    /* 0: no output, 1 min output, 2: full output */
   int imf,                     /* which mflop array to write to */
   int flag,                    
   ATL_mmnode_t *mmb,           /* ptr to mmkern struct queue */
   char pre,                    /* type/prec prefix: z,c,d,s */
   int mb, int nb, int kb,      /* dimensions to time */
   int beta,                    /* beta to time */
   int mflop,                   /* >0: force mflop MFLOPs in each time interv */
   int cflush                   /* >=0: size of cache flush, else ignored */
)
/*
 * RETURNS: cloned mmnode of best-performing kern from mmB queue, or
 *          NULL if none works for this size
 */
{
   ATL_mmnode_t *mmB=NULL, *mmp;
/*
 * find first kernel that works, declare it best so far
 */
   for (mmp=mmb; mmp && !mmB; mmp = mmp->next)
      mmB = MMTimeWithGenKB(verb, imf, flag, mmp, pre, mb, nb, kb, beta, 
                            mflop, cflush);
   if (verb && mmB)
      printf("      B=(%d,%d,%d): %d,%s, mf=%.2f\n", mb, nb, kb, mmB->ID, 
             mmB->rout, mmB->mflop[imf]);
   if (!mmp)        /* if no other cases to consider */
      return(mmB);  /* return best found (may be NULL) */
/*
 * Now try remaining kerns, and always keep best-performing
 */
   for (mmp=mmp->next; mmp; mmp = mmp->next)
   {
      ATL_mmnode_t *mp;
      mp = MMTimeWithGenKB(verb, imf, flag, mmp, pre, mb, nb, kb, beta, 
                           mflop, cflush);
      if (mp)
      {
         if (verb)
            printf("      B=(%d,%d,%d): %d,%s, mf=%.2f\n", mb, nb, kb, mmB->ID, 
                   mmB->rout, mmB->mflop[imf]);
         if (mp->mflop[imf] > mmB->mflop[imf])
         {
            KillMMNode(mmB);
            mmB = mp;
         }
         else
            KillMMNode(mp);
      }
   }
   return(mmB);
}

@iexp ip @(ip) 1 +
/* procedure @(ip), times all 3 vectorization schemes */
int MMTimeAllVecGen
(
   int verb,                    /* 0: no output, 1 min output, 2: full output */
   int flag,                    /* 1: ignore any prior output file */
   ATL_mmnode_t *mp,            /* ptr to mmkern struct */
   char pre,                    /* type/prec prefix: z,c,d,s */
   int mb, int nb, int kb,      /* dimensions to time */
   int beta,                    /* beta to time */
   int mflop,                   /* >0: force mflop MFLOPs in each time interv */
   int cflush                   /* >=0: size of cache flush, else ignored */
)
/*
 * Times all 3 generator-provided vectorization schemes.
 * RETURNS: index of best-performing variant (0-2)
 *
 * OVERWRITES:
 *   ->mflop[0] : time for M-vec wt bcast
 *   ->mflop[1] : 0 if nu not a multiple of vlen, else time for M-vec wt splat
 *   ->mflop[2] : time for K-vec
 *
 * NOTE: mu & nu should be the number of vec regs to use (eg., for M-vec, 
 *       actual M unrolling will be mp->mu * mp->vlen).
 */
{
   char *gs0=mp->genstr, *rt0=mp->rout;
   int flg0=mp->flag, mb0=mp->mbB, nb0=mp->nbB, mu0=mp->mu;
   int kb0=mp->kbB, ku0=mp->ku, kbmax0=mp->kbmax, kbmin0=mp->kbmin;
   int iB=0;
   double mfB;

   if (!rt0)
      mp->rout = DupString("ATL_tmp.c");
   if (FLAG_IS_SET(mp->flag, MMF_KUISKB))
      mp->kbmax = mp->kbmin = mp->ku = mp->kbB = kb;
   mp->kbB = kb;  mp->nbB = nb;  mp->mbB = mb;  /* override blking factor */
/*
 * Try M-vectorized using broadcast
 */
   mp->flag &= ~(1<<MMF_KVEC);    /* ask for M-vectorized kernel */
   mp->flag &= ~(1<<MMF_NOBCAST); /* clear bcast bit */
   mp->mu = mu0 * mp->vlen; 
   mp->genstr = MMGetGenString(pre, mp);
   mfB = TimeMMKernel(verb, flag, mp, pre, mb, nb, kb, beta, mflop, cflush);
   mp->mflop[0] = mfB;
   free(mp->genstr);
/*
 * If legal, try M-vec with splat
 */
   if (mp->nu % mp->vlen == 0)
   {
      mp->flag |= (1<<MMF_NOBCAST);
      mp->genstr = MMGetGenString(pre, mp);
      mp->mflop[1] = TimeMMKernel(verb, flag, mp, pre, mb, nb, kb, beta, mflop, 
                                  cflush);
      free(mp->genstr);
      if (mp->mflop[1] > mfB)
      {
         iB = 1;
         mfB = mp->mflop[1];
      }
      mp->flag &= ~(1<<MMF_NOBCAST); /* clear bcast bit */
   }
   else
      mp->mflop[1] = 0;
/*
 * Try K-vectorized
 */
   mp->mu = mu0;
   mp->flag |= (1<<MMF_KVEC);    /* ask for K-vectorized kernel */
   mp->ku = ((mp->ku+mp->vlen-1)/mp->vlen)*mp->vlen;
   mp->genstr = MMGetGenString(pre, mp);
   mp->mflop[2] = TimeMMKernel(verb, flag, mp, pre, mb, nb, kb, beta, mflop, 
                               cflush);
   free(mp->genstr);
   if (mp->mflop[2] > mfB)
      iB = 2;
/*
 * Restore changed mp-> values & return
 */
   if (!rt0)
   {
      free(mp->rout);
      mp->rout = NULL;
   }
   mp->genstr = gs0;
   mp->mbB = mb0; mp->nbB = nb0; mp->kbB = kb0;
   mp->kbmin = kbmin0; mp->kbmax = kbmax0; mp->ku = ku0;
   return(iB);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
int MMKernCanHandleCase(ATL_mmnode_t *mp, int mb, int nb, int kb)
/* 
 * RETURNS: 0 if mp cannot handle GEMM of size mbxnbxkb
 *          1 if it can handle w/o extra computation
 *          2 if handling it requires extra comptutation (KVEC only: on kb)
 */
{
   if (mb%mp->mu == 0 && nb%mp->nu == 0)
   {
      const int KRUN=FLAG_IS_SET(mp->flag, MMF_KRUNTIME), ku=mp->ku;
      if (mp->kbB == kb)
         return(1);
      if (KRUN && kb%ku == 0)
         return(1);
      if (FLAG_IS_SET(mp->flag, MMF_KVEC))
      {
         const int vl = mp->vlen, kbB=mp->kbB;
         if (KRUN && kb%ku < vl)
            return(2);
         if (kbB > kb && (kbB-kb < vl))
            return(2);
         if (kbB < kb && (kb-kbB < vl))
            return(2);
      }
   }
   return(0);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
ATL_mmnode_t *MMTimeKernWithAlt
(
   int verb,                    /* 0: no output, 1 min output, 2: full output */
   int imf,                     /* which mflop entry to store res in */
   int flag,                    /* 1: ignore any prior output file */
   ATL_mmnode_t *mp0,           /* ptr to mmkern struct */
   ATL_mmnode_t *mp1,           /* ptr to mmkern struct */
   char pre,                    /* type/prec prefix: z,c,d,s */
   int mb, int nb, int kb,      /* dimensions to time */
   int beta,                    /* beta to time */
   int mflop,                   /* >0: force mflop MFLOPs in each time interv */
   int cflush                   /* >=0: size of cache flush, else ignored */
)
{
   int i;
   double mf0=0.0, mf1=0.0;
   i = MMKernCanHandleCase(mp0, mb, nb, kb);
   if (i)
   {
      mf0 = TimeMMKernel(verb, flag, mp0, pre, mb, nb, kb, beta, mflop, cflush);
      if (i == 2)
      {
         int k = mp0->vlen;
         k = ((kb+k-1)/k)*k;
         mf0 *= kb;
         mf0 /= k;
      }
      mp0->mflop[imf] = mf0;
   }
/*
 * If we couldn't use first kernel, or if first kernel needed extra flops
 */
   if (!i || i == 2)
   {
      int j;
      j = MMKernCanHandleCase(mp1, mb, nb, kb);
      if (j)
      {
         mf1 = TimeMMKernel(verb, flag, mp1, pre, mb, nb, kb,beta,mflop,cflush);
         if (j == 2)
         {
            int k = mp1->vlen;
            k = ((kb+k-1)/k)*k;
            mf1 *= kb;
            mf1 /= k;
         }
         mp1->mflop[imf] = mf1;
      }
      else if (!i)
         return(NULL);
   }
   if (mf1 > mf0)
      return(mp1);
   return(mp0);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
ATL_mmnode_t *MMTimeAllKernsWithAlt
(
   int verb,                    /* 0: no output, 1 min output, 2: full output */
   int imf,
   int flag,                   /* 1: ignore any prior output file */
   ATL_mmnode_t *mmb,           /* ptr to mmkern struct */
   ATL_mmnode_t *mmA,           /* ptr to mmkern struct */
   char pre,                    /* type/prec prefix: z,c,d,s */
   int mb, int nb, int kb,      /* dimensions to time */
   int beta,                    /* beta to time */
   int mflop,                   /* >0: force mflop MFLOPs in each time interv */
   int cflush                   /* >=0: size of cache flush, else ignored */
)
/*
 * For given problem size, times all kernels in mmb.  If any entry in mmb
 * cannot handle this exact problem (eg., unrolling mismatch), or requires
 * extra flops to handle the problem, the corresponding
 * entry in the alternate list mmA will be tried.
 * RETURNS: ptr to fastest timed kernel, or NULL if none worked.
 * NOTE: neither list is changed by this function (mflop is overwritten!), 
 *       but ptr into original listis returned.
 */
{
   ATL_mmnode_t *mpB=NULL, *mp0, *mp1;
   double mfB=0.0;
   for (mp0=mmb, mp1=mmA; mp0; mp0 = mp0->next, mp1 = mp1->next)
   {
      ATL_mmnode_t *mp;
      mp = MMTimeKernWithAlt(verb, imf, flag, mp0, mp1, pre, mb, nb, kb, 
                             beta, mflop, cflush);
      if (mp)
      {
         double mf;
         mf = mp->mflop[imf];
         if (mf > mfB)
         {
            mfB = mf;
            mpB = mp;
         }
      }
   }
   return(mpB);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
int TimeNegMMKernels            /* RET: 0 if no retiming required */
(
   int imf,                     /* index of mflop array to check/set */
   int verb,                    /* 0: no output, 1 min output, 2: full output */
   int FORCETIME,               /* 1: ignore any prior output file */
   ATL_mmnode_t *mmb,           /* ptr to mmkern struct queue */
   char pre,                    /* type/prec prefix: z,c,d,s */
   int beta,                    /* beta to time */
   int mflop,                   /* >0: force mflop MFLOPs in each time interv */
   int cflush                   /* >0: size of cache flush, else ignored */
)
{
   ATL_mmnode_t *mp;
   int RETIME=0;
   for (mp=mmb; mp; mp = mp->next)
   {
      if (mp->mflop[imf] <= 0.0)
      {
         RETIME++;
         mp->mflop[imf] = TimeMMKernel(verb, FORCETIME ? 1:0, mp, pre, 
                                       mp->mbB, mp->nbB, mp->kbB,
                                       beta, mflop, cflush);
      }
   }
   return(RETIME);
}

@beginskip
@iexp ip @(ip) 1 +
/* procedure @(ip) */
static char *GetVecStrMM(char pre, int vlen)
{
   if (vlen == 1)
      return("scalar");
   #ifdef ATL_AVX
      if (pre == 'd' || pre == 'z')
      {
         if (vlen == 4)
            return("avx");
         else if (vlen == 2)
            return("sse");
      }
      else if (pre == 's' || pre == 'c')
      {
         if (vlen == 8)
            return("avx");
         else if (vlen == 4)
            return("sse");
      }
   #elif defined(ATL_SSE1)
      #ifdef ATL_SSE2
         if ((pre == 'd' || pre == 'z') && vlen == 2)
               return("sse");
      #endif
      if ((pre == 's' || pre == 'c') && vlen == 4)
         return("sse");
   #endif
/*
 * Any vector length > 1 that isn't one of our known cases uses gnuvec
 */
   return("gvec");
}
@endskip

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static ATL_mmnode_t *TimeMMFileWithPath
(
   char pre, 
   char *path, 
   char *file, 
   int imf,                    /* index of mflop array to check/set */
   int verb,                   /* 0: no output, 1 min output, 2: full output */
   int FORCETIME,              /* 1: ignore any prior output file */
   int beta,                   /* beta to time */
   int mflop,                  /* >0: force mflop MFLOPs in each time interv */
   int cflush                  /* >0: size of cache flush, else ignored */
)
{
   ATL_mmnode_t *mmb;
   mmb = ReadMMFileWithPath(pre, path, file);
   if (!mmb)
      return(NULL);
   MMFillInGenStrings(pre, mmb);
   if (TimeNegMMKernels(imf, verb, FORCETIME, mmb, pre, beta, mflop, cflush))
      WriteMMFileWithPath(pre, path, file, mmb);
   return(mmb);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
void TimeAllMMKernels
(
   int itime,                   /* index of mflop array to set */
   int verb,                    /* 0: no output, 1 min output, 2: full output */
   int FORCETIME,               /* 1: ignore any prior output file */
   ATL_mmnode_t *mmb,           /* ptr to mmkern struct queue */
   char pre,                    /* type/prec prefix: z,c,d,s */
   int beta,                    /* beta to time */
   int mflop,                   /* >0: force mflop MFLOPs in each time interv */
   int cflush                   /* >0: size of cache flush, else ignored */
)
{
   ATL_mmnode_t *mmp;
   for (mmp=mmb; mmp; mmp = mmp->next)
      mmp->mflop[itime] = TimeMMKernel(verb, FORCETIME?1:0, mmp, pre, 
                                       mmp->mbB, mmp->nbB, mmp->kbB,
                                       beta, mflop, cflush);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
double TimeTSKernel
(
   int verb,                    /* 0: no output, 1 min output, 2: full output */
   int FORCETIME,               /* 1: ignore any prior output file */
   char pre,                    /* type/prec prefix: z,c,d,s */
   int mb,                      /* triangle is mbxmb (kb=mb) */
   int nb,                      /* NRHS */
   int mflop                    /* >0: force mflop MFLOPs in each time interv */
)
{
   int i, DOTIME=1;
   char ln[2048], resf[256];

   if (FORCETIME)
      strcpy(resf, "res/tmpout.ktim");
   else
   {
      sprintf(resf, "res/%ctrsm%dx%d_F%d.ktim", pre, mb, nb, mflop);
      DOTIME = !FileExists(resf);
   }

   if (DOTIME)
   {
      i = sprintf(ln, "make %ctrsmKtime mb=%d nb=%d outF=\" -f %s \"", 
                  pre, mb, nb, resf);
      if (mflop)
         i += sprintf(ln+i, " FMF=%d", mflop);

      sprintf(ln+i, "\n");
      if (verb > 1)
         printf("SYSTEM: %s", ln);
      if (system(ln))
      {
         fprintf(stderr, "ERROR IN COMMAND: %s", ln);
         fprintf(stderr, "   PROPOSED FILENAME: %s\n", resf);
         sprintf(ln, "rm -f %s\n", resf);
         assert(!system(ln));
         exit(-1);
      }
   }
   return(*((double*)ReadResultsFile(0, 0, resf)));
}

#endif  /* end guard around atlas_@(rt)testtime.h */
@ROUT atlas_mmgen.h
   @iexp ip 0
#ifndef ATLAS_MMGEN_H
   #define ATLAS_MMGEN_H
/*
 * This file contains helper functions for code generation
 */
#define ATL_GENERATE 1
#include "atlas_mmparse.h"
#include "atlas_mmtesttime.h"

#define MMCP_TOBLK    0  /* set: copy to blk format;  unset: opposite direc */
#define MMCP_CBLK     1  /* set: C format;  unset:A/B */
#define MMCP_ABLK     2  /* set: scope mu;  unset: scope nu */
#define MMCP_TRANS    3
#define MMCP_CONJ     4
#define MMCP_SINGLE   5
#define MMCP_REAL     6
#define MMCP_SYRK     7
#define MMCP_SYMM     8
#define MMCP_TRMM     9
/*
 * C copy routines choose: direction, a[1,n,X], b[0,1,n,X]
 * AB copy routines choose: direction, TA=[N,T,C,H], a[1,n,X]
 * -> C comes from N with Conj_ set, H comes from T with Conj_ set
 */
typedef struct MMCopyFunc ATL_mmcp_t;
struct MMCopyFunc
{                     /* user defined IDs always unique */
   int ID;            /* 0: access-maj, >0: user defined */
   int mu, nu;        /* unrollings: A/B copies use only nu */
   int kvec;          /* vlen for k-vec storage, else 0 */
   int flag;          /* bits: vals are MMCP_* */
@skip   char *file;        /* filename */
   int rtlen;         /* # of chars/bytes in rout */
   char *rout;        /* callable routine name w/o alpha/beta suffix */
   char *genstr;      /* string that will generate ID=0 kerns */
   ATL_mmcp_t *next;
};

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static int CopyAreDiff(ATL_mmcp_t *c0, ATL_mmcp_t *c1)
/*
 * RETURNS: 1 if c0 & c1 have different functionality, 0 if equivalent
 */
{
   int iret;
   iret = (c0->ID == c1->ID);
   if (!c0->ID)
   {
      iret &= (c0->nu == c1->nu) & (c0->mu == c1->mu);
      iret &= (c0->kvec == c1->kvec);
      iret &= (c0->flag == c1->flag);
   }
   return(!iret);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static char MMCopyGetPre(int flag)
{
   char pre;
   if (flag & (1<<MMCP_REAL))
      pre = (flag & (1<<MMCP_SINGLE)) ? 's':'d';
   else
      pre = (flag & (1<<MMCP_SINGLE)) ? 'c':'z';
   return(pre);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static char *MMCopyGetCompType(int flag)
{
   char *ctyp;
   if (flag & (1<<MMCP_REAL))
      ctyp = (flag & (1<<MMCP_SINGLE)) ? "SREAL":"DREAL";
   else
      ctyp = (flag & (1<<MMCP_SINGLE)) ? "SCPLX":"DCPLX";
   return(ctyp);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static char MMCopyGetUpr(int flag)
{
   return((flag & (1<<MMCP_SINGLE)) ? 's':'d');
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static char MMCopyGetTrans(int flag)
{
   if (flag & (1<<MMCP_TRANS))
      return((flag & (1<<MMCP_CONJ))?'H':'T');
   return((flag & (1<<MMCP_CONJ))?'C':'N');
}

/* procedure @(ip) */
static char *MMCopyGetDirect(int flag)
{
   return((flag&(1<<MMCP_TOBLK)) ? "Into" : "From");
}


@iexp ip @(ip) 1 +
/* procedure @(ip) */
static int MMCopyEncode
(              /* all args take 0, which means don't set */
   char pre,  /* [s,d,c,z] */
   char dir,  /* 'I': copy Into block storage, 'F': copy From block */
   char mat,  /* [C,A] */
   char TA    /* [N,T,C,H] */
)
/* 
 * returns arginfo as ATL_mmcp_t flag
 */
{
   int flag;
   if (pre)
   {
      flag = (pre == 'd' || pre == 's') ? (1<<MMCP_REAL) : 0;
      flag |= (pre == 's' || pre == 'c') ? (1<<MMCP_SINGLE) : 0;
   }
   if (dir)
   {
      if (!(dir == 'F' || dir == 'f'))
         flag |= (1<<MMCP_TOBLK);
   }
   if (mat)
   {
      if (mat == 'C' || mat == 'c')
         flag |= (1<<MMCP_CBLK);
      else /* A or B */
      {
         flag |= (mat == 'a' || mat == 'A') ? (1<<MMCP_ABLK) : 0;
         if (TA)
         {
            if (TA == 't' || TA == 'T')
               flag |= (1<<MMCP_TRANS);
            else if (TA == 'c' || TA == 'C')
               flag |= (1<<MMCP_CONJ);
            else if (TA == 'H' || TA == 'h')
               flag |= (1<<MMCP_TRANS) | (1<<MMCP_CONJ);
         }
      }
   }
   return(flag);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static char *GetMMCopyName(ATL_mmcp_t *p, int *LEN)
/*
 * RETURNS : Unique name for copy file, with at least 6 extra bytes alloc
 *           so that you can suffix it with _aX_bX or .c
 */
{
   char *sp=NULL, *dir;
   const int ID=p->ID, flag=p->flag;
   int len, i=0;
   char pre;

   pre = MMCopyGetPre(flag);
   dir = MMCopyGetDirect(flag);
   if (ID)
      len = 9 + NumDecDigits(p->ID);
   else
      len = 9+NumDecDigits(p->mu)+NumDecDigits(p->nu)+NumDecDigits(p->kvec);
/*
 * For C format routine naming scheme is:
 * ID=0 : ATL_<pre>cp[Into,From]BlkC_<mu>x<nu>_<kvec>
 * ID>0 : ATL_<pre><ID>cp[Into,From]BlkC
 */
   if (flag & (1<<MMCP_CBLK))
   {
      if (p->ID) /* user-supplied */
      {
         len += 17 - 2*2;
         i = sprintf(sp, "ATL_%c%dcp%sBlkC", pre, ID, dir);
      }
      else if (p->flag & (1<<MMCP_SYRK)) /* ATL_<pre>syblk2cmat */
      {
         i = len = 15;          /* 16:ATL_Xsyblk2cmat */
         sp = malloc(len+1);
         assert(sp);
         strcpy(sp, "ATL_Xsyblk2cmat");
         sp[4] = pre;
      }
      else /* ATL_<pre>cpy[To,From]C_<mu>x<nu>_<kvec> */
      {
         len += 24 - 4*2;
         sp = malloc(len+1);
         assert(sp);
         i = sprintf(sp, "ATL_%ccp%sBlkC_%dx%d_%d", pre, dir, 
                     p->mu, p->nu, p->kvec);
      }
   }
/*
 * For A/B format, routine name scheme is:
 * ID=0 : ATL_<pre>cp[To,From]BlkA_<u>_<kvec>
 * ID>0 : ATL_<pre><ID>cp[To,From]BlkA
 */
   else
   {
@skip      char TA;
@skip      TA  = MMCopyGetTrans(flag);

      if (ID)  /* ATL_<pre><ID>cp[To,From]BlkA */
      {
         len += 18 - 3*2;
         sp = malloc(len+1);
         assert(sp);
         i = sprintf(sp, "ATL_%c%dcp%sBlkA", pre, ID, dir);
      }
      else     /* ATL_<pre>cp[To,From]BlkA[N,T]_<u>_<kvec> */
      {
         len += 24 - 4*2;
         sp = malloc(len+1);
         assert(sp);
         i=sprintf(sp, "ATL_%ccp%sBlkA_%d_%d", pre, dir, p->nu, p->kvec);
      }
   }
   assert(i <= len);
   if (LEN)
      *LEN = i;
   return(sp);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static ATL_mmcp_t *GetMMCopyNode(int ID, int mu, int nu, int kvec, int flag)
{
   ATL_mmcp_t *cp;
   cp = calloc(1, sizeof(ATL_mmcp_t));
   cp->ID = ID;
   cp->mu = mu;
   cp->nu = nu;
   cp->kvec = kvec;
   cp->flag = flag;
   assert(cp);
   return(cp);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static ATL_mmcp_t *CloneCopyNode(ATL_mmcp_t *b)
{
   ATL_mmcp_t *p;
   p = malloc(sizeof(ATL_mmcp_t));
   memcpy(p, b, sizeof(ATL_mmcp_t));
   p->next = NULL;
/*
 * Now get our own copies of strings
 */
   @whiledef st rout genstr
   if (p->@(st))
      p->@(st) = DupString(p->@(st));
   @endwhile
   return(p);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static ATL_mmcp_t *KillCopyNode(ATL_mmcp_t *cp)
{
   ATL_mmcp_t *next=NULL;
   if (cp)
   {
      @whiledef st rout genstr
      if (cp->@(st))
         free(cp->@(st));
      @endwhile
      next = cp->next;
      free(cp);
   }
   return(next);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static ATL_mmcp_t *KillAllCopyNodes(ATL_mmcp_t *cp)
{
   while (cp)
      cp = KillCopyNode(cp);
   return(NULL);
}

@iexp ip @(ip) 1 +
/* procedure @(ip): RETURNS ptr to entry in b if n already there, else NULL */
ATL_mmcp_t *FindCopy(ATL_mmcp_t *b, ATL_mmcp_t *n)
{
   ATL_mmcp_t *p;
   for (p=b; p; p = p->next)
      if (!CopyAreDiff(p, n))
         return(p);
   return(NULL);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
ATL_mmcp_t *FindLastCopyNode(ATL_mmcp_t *b)
{
   if (b)
   {
      while(b->next)
         b = b->next;
   }
   return(b);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static ATL_mmcp_t *AddUniqueCopyNode(ATL_mmcp_t *cb, ATL_mmcp_t *cnb)
/*
 * Adds all copy entries in cnb to cb, if cb doesn't already have a 
 * functionally equivalent entry. cnb is unchanged.
 */
{
   ATL_mmcp_t *p;
   for (p=cnb; p; p = p->next)
   {
      if (!FindCopy(cb, p))
      {
         ATL_mmcp_t *np;
         np = CloneCopyNode(p);
         np->next = cb;
         cb = np;
      }
   }
   return(cb);
}

@beginskip
@iexp ip @(ip) 1 +
/* procedure @(ip) */
void GetMMCopyRefresh(int flag, ATL_mmnode_t *mb)
/*
 * Resets all mb's ->flags to flag, and recomputes all ->rout
 */
{
   ATL_mmnode_t *mp;
   for (mp=mb; mp; mp = mp->next)
   {
      mp->flag = flag;
      if (mp->rout)
         free(mp->rout);
      mp->rout = GetMMCopyName(mp, &mp->rtlen);
   }
}

@endskip
@iexp ip @(ip) 1 +
/* procedure @(ip) */
ATL_mmcp_t *GetMMCopyFromMMNodes
(
   int flag,          /* set with call to MMCopyEncode */
   ATL_mmnode_t *mb   /* list of amm kerns */
)
{
   ATL_mmcp_t *cb, *cp;
   ATL_mmnode_t *mp;
   const int CP_C = (flag&(1<<MMCP_CBLK)), CP_A = (flag&(1<<MMCP_ABLK));
/*
 * Setup copy list matching the MM kerns in mb 
 */
   cp = cb = GetMMCopyNode(0, 0, 0, 0, 0);
   for (mp=mb; mp; mp = mp->next)
   {
      int ID=0, mu=0, nu=0, kvec=0;
      if (CP_C)
      {
         ID = mp->stgC;
         if (!ID)
         {
            mu = mp->mu;
            nu = mp->nu;
         }
      }
      else if (CP_A)
      {
         ID = mp->stgA;
         if (!ID)
            nu = mp->mu;  /* A/B storage always uses nu, only C uses mu */
      }
      else
      {
         ID = mp->stgB;
         if (!ID)
            nu = mp->nu;
      }
      if (!ID & FLAG_IS_SET(mp->flag, MMF_KVEC))
         kvec = mp->vlen;
      cp->next = GetMMCopyNode(ID, mu, nu, kvec, flag);
      cp = cp->next;
      cp->rout = GetMMCopyName(cp, &cp->rtlen);
   }
   return(KillCopyNode(cb));
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
void GetMMAllUniqueCopyFromMMNodes
(
   char pre,  /* '[s,d,c,z]' */
   char dirC,  /* '[T,F]' */
   char dirA,  /* '[T,F]' */
   ATL_mmnode_t *mb,  /* list of amm kerns */
   ATL_mmcp_t **AB,  /* cpy func where A & B can use same routine */
   ATL_mmcp_t **CB    /* copy routines for C */
)
/*
 * Creates seperate lists for copy funcs for A&B, and C.  For types where
 * A & B format are the same other than tranposition (includes both access-
 * and block-major ATLAS formats), each mb node will generate four ab nodes,
 * one for mu/nu/N/T.  For user types that can only be applied to A or B,
 * will need a way to find both Trans and NoTrans versions; right now we
 * have only one stgID!
 */
{
   ATL_mmcp_t *ab=(*AB), *cb = (*CB), *np;
   ATL_mmnode_t *mp;
   int flgA, flgC;

   flgC = (pre == 's' || pre == 'd') ? (1<<MMCP_REAL) : 0;
   if (pre == 's' || pre == 'c')
      flgC |= (1<<MMCP_SINGLE);
   flgA = flgC;
   if (dirA == 'T')
      flgA |= (1<<MMCP_TOBLK);
   if (dirC == 'T')
      flgC |= (1<<MMCP_TOBLK);
   flgC |= (1<<MMCP_CBLK);

   np = GetMMCopyNode(0, 0, 0, 0, 0);

/*
 * Setup copy list matching the MM kerns in mb 
 */
   for (mp=mb; mp; mp = mp->next)
   {
      ATL_mmcp_t *p;
      int kvec = 0;

      np->kvec = FLAG_IS_SET(mp->flag, MMF_KVEC) ? mp->vlen : 0;
      np->ID = mp->stgC; np->mu = mp->mu; np->nu = mp->nu;
      np->flag = flgC;
      if (!FindCopy(cb, np))  /* not already in list, so add it */
      {
         p = CloneCopyNode(np);
         p->rout = GetMMCopyName(p, &p->rtlen);
         p->next = cb;
         cb = p;
      }
/*
 *    Add to A/B lists as necessary
 */
      np->ID = mp->stgA;
      np->mu = 0;
      np->flag = flgA;
      if (np->ID) /* user-generated kerns may not go to both cases */
      {
         assert(0); // should not happen yet
      }
      else /* Add two nodes to ab, using [A(mu),B(nu)] */
      {    /* don't set MMCP_ABLK, since A or B is same for us */
         np->nu = mp->mu;
         if (!FindCopy(ab, np))
         {
            p = CloneCopyNode(np);
            p->rout = GetMMCopyName(p, &p->rtlen);
            p->next = ab;
            ab = p;
         }

         if (mp->mu != mp->nu)
         {
            np->flag = flgA;
            np->nu = mp->nu;
            if (!FindCopy(ab, np))
            {
               p = CloneCopyNode(np);
               p->rout = GetMMCopyName(p, &p->rtlen);
               p->next = ab;
               ab = p;
            }
         }
      }
   }

   KillCopyNode(np);
   *AB = ab;
   *CB = cb;
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
ATL_mmcp_t *AddMMCKernCopyFromMMNodes
(
   char pre,  /* '[s,d,c,z]' */
   char dir,  /* '[T,F]' */
   int KERN,          /* one of MMCP_[SYRK,SYMM,TRMM], or 0 (GEMM) */
   ATL_mmnode_t *mb,  /* list of amm kerns */
   ATL_mmcp_t *ab     /* cpy func where A & B can use same routine */
)
{
   int flag = KERN ? (1<<KERN) : 0;
   ATL_mmnode_t *mp;
   if (!mb)
      return(ab);
   assert(KERN == MMCP_SYRK);        /* true for now */
   flag |= MMCopyEncode(pre, dir, 'C', 'N');
   for (mp=mb; mp; mp = mp->next)
   {
      ATL_mmcp_t *np;
      np = GetMMCopyNode(0, mp->mu, mp->nu, FLAG_IS_SET(mp->flag, MMF_KVEC) ? 
                         mp->vlen : 0, flag);
      np->rout = GetMMCopyName(np, &np->rtlen);
      np->next = ab;
      ab = np;
   }
   return(ab);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
ATL_mmcp_t *AddMMUniqueACopyFromMMNodes
(
   char pre,  /* '[s,d,c,z]' */
   char dirA,  /* '[T,F]' */
   ATL_mmnode_t *mb,  /* list of amm kerns */
   ATL_mmcp_t *ab     /* cpy func where A & B can use same routine */
)
{
   ATL_mmcp_t *np;
   ATL_mmnode_t *mp;
   for (mp=mb; mp; mp = mp->next)
   {
      np = GetMMCopyNode(0, 0, mp->mu, 
                         FLAG_IS_SET(mp->flag, MMF_KVEC)?mp->vlen:0, 
                         MMCopyEncode(pre, dirA, 'B', 'N'));
      if (!FindCopy(ab, np))
      {
         np->rout = GetMMCopyName(np, &np->rtlen);
         np->next = ab;
         ab = np;
      }
      else
         KillCopyNode(np);
      if (mp->mu != mp->nu)
      {
         np = GetMMCopyNode(0, 0, mp->nu, 
                            FLAG_IS_SET(mp->flag, MMF_KVEC)?mp->vlen:0, 
                            MMCopyEncode(pre, dirA, 'B', 'N'));
         if (!FindCopy(ab, np))
         {
            np->rout = GetMMCopyName(np, &np->rtlen);
            np->next = ab;
            ab = np;
         }
      }
   }
   return(ab);
}
@iexp ip @(ip) 1 +
/* procedure @(ip) */
static void PrepMMForGen(char pre, char *outd, char *nm, ATL_mmnode_t *mb)
/*
 * Prep mb for generation.  Free present values, and replace with:
 * ->auth  : kernel name without _b[1,n,0] suffix
 * ->genstr: for ID=0: genstr, else user kernel name (came in ->rout)
 * ->rout  : correct present filename (used in generation & compilation)
 */
{
   ATL_mmnode_t *mp;
   char suff[3]={'.', 'c', '\0'};
   char *od;

   od = NewMergedString(outd, "/");
   for (mp=mb; mp; mp = mp->next)
   {
      if (mp->flag & (1<<MMF_KUISKB))
         assert((mp->flag & (1<<MMF_KRUNTIME)) == 0);
      if (mp->auth)
         free(mp->auth);
      mp->auth = GetMMKernName(pre, nm, mp);
      if (mp->ID) /* user-supplied kernel */
      {
         int h;
         char ch = 'c', och;

         assert(!mp->genstr);
         assert(mp->rout);
         h = strlen(mp->rout);
         mp->genstr = mp->rout;
         mp->rout = GetMMFilename(pre, nm, mp);
      }
      else  /* generated kernel */
      {
         char *sp, *sp1;
         if (mp->rout)
            free(mp->rout);
         if (mp->genstr)
            free(mp->genstr);
         sp = NewMergedString(mp->auth, suff);
         mp->rout = NewMergedString(od, sp);  /* want to gen in outd/ */
         sp1 = MMGetGenString(pre, mp);
         mp->genstr = NewMergedString(sp1, " > /dev/null 2>&1");
         free(sp1);
         free(mp->rout);
         mp->rout = sp; /* want filename w/o path for GenMake */
      }
   }
   free(od);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static FILE *OpenMMGenHeader
(
   char *outd,/* directory to write to must be non-NULL */
   int UID,   /* 0 for ATLAS files, >0 for uammsearch */
   char pre,  /* [d,s,z,c] */
   char *cn,  /* "[ge,sq,rk,u]" */
   char alp,  /* [1,n,X]; if 0 -> not doing copy file */
   char bet,  /* [0,1,n,X] if 0 -> not doing cblk file */
   char *nm,  /* "[blk,kern,flag,perf,sum,ablk2cmat,cmat2ablk,cm2am,am2cm]" */
   ATL_mmnode_t *mb 
)
{
   char *fn, bs[6];
   int len, i;
   FILE *fp;

   /* NAME WILL BE: <outd>/atlas_<pre><cn>[ID]amm_<nm>.h */
   assert(nm && outd);
   len = strlen(outd) + 1; /* outd+/*/
   len += 6 + 1 + 4 + 2;  /* atlas+pre+amm_+.h */
   if (cn)
      len += strlen(cn);
   else
      cn = "";
   if (UID)
      len += NumDecDigits(UID);
   len += strlen(nm);
   if (alp | bet)  /* doing copy header */
   {
      len += 3;
      bs[0] = '_'; bs[1] = 'a'; bs[2] = alp; bs[3] = 0;

      if (bet)   /* doing Cblock, need beta too */
      {
         len += 2;
         bs[3] = 'b';
         bs[4] = bet;
         bs[5] = 0;
      }
   }
   else
      bs[0] = 0;

   fn = malloc(len+1);
   assert(fn);
   if (UID)
      i = sprintf(fn, "%s/atlas_%c%s%damm_%s%s.h", outd, pre, cn, UID, nm, bs);
   else
      i = sprintf(fn, "%s/atlas_%c%samm_%s%s.h", outd, pre, cn, nm, bs);
   assert(i <= len);
   fp = fopen(fn, "w");
   assert(fp);
/*
 * Now change file part of string to guard text: uppercase & ".h" -> "_H";
 */
   fn[i-1] = 'H';
   fn[i-2] = '_';
   for (i -= 3; fn[i] != '/'; i--)
      fn[i] = toupper(fn[i]);
   i++;
   fprintf(fp, "#ifndef %s\n", fn+i);
   fprintf(fp, "   #define %s 1\n", fn+i);
   fprintf(fp, "   /* Genned by ATLAS/src/blas/gemm/ammgen.c */\n\n");
   fprintf(fp, "#include \"atlas_amm.h\"\n");
   if (mb && strcmp(nm, "perf"))
   {
      i = CountListEntries(mb, GetOffset(&mb->next, mb));
      if (cn[0] == 'g' && cn[1] == 'e')
      {
         fprintf(fp, "#ifdef ATL_AMM_NCASES\n   #if ATL_AMM_NCASES != %d\n", i);
         fprintf(fp, "      #error \"NCASES MISMATCH!\"\n   #endif\n");
         fprintf(fp, "#else\n   #define ATL_AMM_NCASES %d\n#endif\n", i);
      }
      else
      {
         fprintf(fp, "#ifdef ATL_%sAMM_NCASES\n   #if ATL_%sAMM_NCASES != %d\n",
                 cn, cn, i);
         fprintf(fp, "      #error \"NCASES MISMATCH!\"\n   #endif\n");
         fprintf(fp, "#else\n   #define ATL_%sAMM_NCASES %d\n#endif\n", cn, i);
      }
   }

   free(fn);
   return(fp);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static void CloseGenHeader(FILE *fp)
{
   fprintf(fp, "\n#endif\n");
   fclose(fp);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static char *GetSafeIntType(void *vb, int nxtoff, int off, int *CNT)
{
   int max, min, n;
   *CNT = GetIntMaxMinAtOff(vb, nxtoff, off, &max, &min);
   if (min < 0)
   {
      if (max < (1<<7))
         return("char");
      else if (max < (1<<15))
         return("short");
      return("int");
   }
   else if (max < (1<<8))
      return("unsigned char");
   else if (max < (1<<16))
      return("unsigned short");
   return("unsigned int");
}

@beginskip
@iexp ip @(ip) 1 +
/* procedure @(ip) */
void PrintMMIntOffArr(FILE *fp, char pre, char *nm, ATL_mmnode_t *mb, int off)
/*
 * Dumps integer stored at byte offset off mb's MMNodes to file fp using name nm
 */
{
   ATL_mmnode_t *mp;
   char *type;
   int i, n;

   type = GetSafeIntType(mb, GetOffset(&mb->next, mb), off, &n);
   fprintf(fp, "#ifndef NO%s\n", nm);
   fprintf(fp, "static const %s ATL_AMM_%s[%d] =\n{\n", type, nm, n);
   for (i=0,mp=mb; mp; i++,mp = mp->next)
      fprintf(fp, "%8d%c  /* IDX=%d */\n", *((int*)(((char*)mp)+off)),
              mp->next ? ',':' ', i);
   fprintf(fp, "};\n#endif\n\n");
}
@endskip

char *FillInMMScalarSuff(char ta, char alp, char bet)
{
   static char ab[8];
   if (!(alp|bet))
      ab[0] = '\0';
   else
   {
      int i;
      i = 1;
      ab[0] = '_';
      if (!bet)
      {
         ab[1] = ta;
         ab[2] = 'a';
         ab[3] = alp;
         ab[4] = '\0';
      }
      else if (!alp)
      {
         ab[1] = 'b';
         ab[2] = bet;
         ab[3] = '\0';
      }
      else
      {
         ab[1] = 'a';
         ab[2] = alp;
         ab[3] = '_';
         ab[4] = 'b';
         ab[5] = bet;
         ab[6] = '\0';
      }
   }
   return(ab);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
void PrintMMProtos(FILE *fp, char pre, char *nm, ATL_mmnode_t *mb, int off,
                   char bet)
{
   ATL_mmnode_t *mp;

   if (bet == '0')
      fprintf(fp, "#if !defined(NO%s_b%c) && !defined(NO%s_K1)\n", nm,bet, nm);
   else
      fprintf(fp, "#if !defined(NO%s_b%c) && !defined(NO%s_K1_b%c)\n", 
              nm,bet, nm,bet);
   for (mp=mb; mp; mp = mp->next)
      fprintf(fp, "void %s_b%c\n%s\n%s\n", GetStrAtOff(mp, off), bet,
              "   (ATL_CSZT,ATL_CSZT,ATL_CSZT,const TYPE*,const TYPE*,TYPE*,",
              "    const TYPE*,const TYPE*,const TYPE*);");
   fprintf(fp, "#endif\n\n");
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
void PrintMMCpProtosA(FILE *fp, char *nm, ATL_mmcp_t *cb, char dir, char alp)
{
   ATL_mmcp_t *cp;
   char *pro;
   char pre;

   pre = MMCopyGetPre(cb->flag);
   if (pre == 'd' || pre == 's')
   {
      pro = (dir == 'F') ? 
           "(ATL_CSZT,ATL_CSZT,const SCALAR,TYPE*,ATL_CSZT,const TYPE*)"
         : "(ATL_CSZT,ATL_CSZT,const SCALAR,const TYPE*,ATL_CSZT,TYPE*)";
   }
   else
   {
      pro = (dir == 'F') ? 
      "(ATL_CSZT,ATL_CSZT,const SCALAR,TYPE*,ATL_CSZT,const TYPE*,const TYPE*);"
      : "(ATL_CSZT,ATL_CSZT,const SCALAR,const TYPE*,ATL_CSZT,TYPE*,TYPE*);";
   }
   fprintf(fp, "#ifndef NO%s_a%c\n", nm, alp);
   for (cp=cb; cp; cp = cp->next)
   {
      char ta;
      ta = MMCopyGetTrans(cp->flag);
      fprintf(fp, "void %s_%ca%c\n   %s;\n", cp->rout, ta, alp, pro);
   }
   fprintf(fp, "#endif\n\n");
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
void PrintMMCpProtosC(FILE *fp, char *nm, ATL_mmcp_t *cb, 
                      char dir, char alp, char bet)
{
   ATL_mmcp_t *cp;
   char *ab;
   char *pro;
   char pre;

   pre = MMCopyGetPre(cb->flag);
   ab = FillInMMScalarSuff(0, alp, bet);
   if (pre == 'd' || pre == 's')
   {
      pro = (dir == 'F') ?
"(ATL_CSZT,ATL_CSZT,const SCALAR,const TYPE*,const SCALAR,TYPE*,ATL_CSZT);"
:
"(ATL_CSZT,ATL_CSZT,const SCALAR,const TYPE*,ATL_CSZT,const SCALAR,TYPE*);";
   }
   else
   {
      pro = (dir == 'F') ?
"(ATL_CSZT,ATL_CSZT,const SCALAR,const TYPE*,const TYPE*,const SCALAR,\n     TYPE *,ATL_CSZT);"
            :
"   (ATL_CSZT,ATL_CSZT,const SCALAR,const TYPE*,ATL_CSZT,const SCALAR,\n     TYPE*,TYPE*);";
   }
   fprintf(fp, "#ifndef NO%s%s\n", nm,ab);
   for (cp=cb; cp; cp = cp->next)
      fprintf(fp, "void %s%s\n   %s\n", cp->rout, ab, pro);
   fprintf(fp, "#endif\n\n");
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
void PrintIntArrAtOff
(
   FILE *fp,
   char pre,   /* [d,s,c,z] */
   char *nm,   /* name of the array, optionally decorated by _aX_bX */
   void *sb,
   int nxtoff, /* offset (bytes) in struct to next pointer */
   int ioff,   /* offset in struct to integer val we are printing */
   char alp,
   char bet
)
/*
 * Dumps integer stored at ioff in sb's struct to file fp using name nm.

 */
{
   char *cp = sb;
   char *type;
   char *ab;
   int i, n;

   ab = FillInMMScalarSuff(0, alp, bet);

   type = GetSafeIntType(sb, nxtoff, ioff, &n);
   fprintf(fp, "#ifndef NO%s\n", nm);
   fprintf(fp, "static const %s ATL_AMM_%s%s[%d] =\n{\n", type, nm, ab, n);
   for (i=0; cp; i++)
   {
      char *nxt;
      nxt = GetStrAtOff(cp, nxtoff);
      fprintf(fp, "%8d%c  /* IDX=%d */\n", *((int*)(cp+ioff)), nxt?',':' ', i);
      cp = nxt;
   }
   fprintf(fp, "};\n#endif\n\n");
}
@iexp ip @(ip) 1 +
/* procedure @(ip) */
void PrintStrArrAtOff(FILE *fp, char pre, char *nm, void *vb,
                      int nxtoff, int off, char *type, 
                      char ta, char alp, char bet)
/*
 * Dumps integer stored at byte offset off mb's MMNodes to file fp using name nm
 */
{
   char *cp;
   int i, n;
   char *ab;

   n = CountListEntries(vb, nxtoff);
   ab = FillInMMScalarSuff(ta, alp, bet);
@skip   if (bet == '0' && !strcmp(nm, "KERN_K1"))
@skip      fprintf(fp, "#ifndef NOKERN_K1\n");
@skip   else
   fprintf(fp, "#ifndef NO%s%s\n", nm,ab);
   if (!bet) /* A/B copy funcs */
      fprintf(fp, "static const %s ATL_AMM_%s_a%c[%d] =\n{\n",type,nm,alp,n);
   else
      fprintf(fp, "static const %s ATL_AMM_%s%s[%d] =\n{\n", type, nm, ab, n);
   for (i=0,cp=vb; cp; i++)
   {
      char *next;
      next = GetStrAtOff(cp, nxtoff);
      fprintf(fp, "/* IDX=%3d */ %s%s%c\n", 
              i, GetStrAtOff(cp, off), ab, next ? ',':' ');
      cp = next;
   }
   fprintf(fp, "};\n#endif\n\n");
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
char *GetMMKernComp(ATL_mmnode_t *mmp, char *dcomp, char *dflags, char **flgs)
{
   char *comp = dcomp;
   if (mmp->comp)
   {
      comp = (mmp->comp[0] == 'g' && mmp->comp[1] == 'c' &&
              mmp->comp[2] == 'c' &&
             (mmp->comp[3] == '\0' || mmp->comp[3] == ' '))
             ? "$(GOODGCC)" : mmp->comp;
      *flgs = mmp->cflags;
   }
   else
      *flgs = dflags;
   return(comp);
}

@beginskip
@iexp ip @(ip) 1 +
/* procedure @(ip) */
void PrintKernComp
(
   FILE *fp,            /* file to print to */
   char pre,
   ATL_mmnode_t *mp,   /* kernel compile rule is for */
   char *comp,          /* compiler to use */
   char *cflags,        /* compiler flags to use */
   char *styp,          /* string defining type (eg. "-DSREAL") */
   char cbet,           /* character with beta name ('1', '0', 'n') */
   char *sbet           /* string wt full beta name ("1", "N1", "0") */
)
{
   const int kb = FLAG_IS_SET(mp->flag, MMF_KRUNTIME)?0:mp->kbB;
   fprintf(fp, "%s_b%c : %s\n", mp->auth, cbet
   fprintf(fp, "\t%s $(CDEFS2) %s -DBETA%s=1", comp, styp, sbet);
   if (!FLAG_IS_SET(mp->flag, MMF_KRUNTIME))
      fprintf(fp, " -DMB=%d -DNB=%d, -DKB=%d", mp->mbB, mp->nbB, mp->kbB);
   if (FLAG_IS_SET(mp->flag, MMF_MVA))
      fprintf(fp, " -DATL_MOVEA");
   if (FLAG_IS_SET(mp->flag, MMF_MVB))
      fprintf(fp, " -DATL_MOVEB");
   if (FLAG_IS_SET(mp->flag, MMF_MVC))
      fprintf(fp, " -DATL_MOVEC");
         fprintf(fp, " -DATL_USERMM=ATL_%c%s_%d_%d_%x_%dx%dx%d_b%c", pre, nam,
                 mp->ID, kb, flg, mp->mu, mp->nu, mp->ku, cbet);
         fprintf(fp, " %s -o ATL_%c%s_%d_%d_%x_%dx%dx%d_b%c.o -c %s\n",
                 cflags, pre, nam, mp->ID, kb, flg, mp->mu, mp->nu, mp->ku,
                 cbet, mp->rout);
}
@endskip
#endif  /* end guard around atlas_@(rt)mmgen.h */
@ROUT getflagarrs

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static int *GetIntList1(int ival)
/*
 * returns integer array with iarr[0] = 1, iarr[1] = ival
 */
{
   int *iarr;
   iarr = malloc(2*sizeof(int));
   assert(iarr);
   iarr[0] = 1;
   iarr[1] = ival;
   return(iarr);
}

#ifdef TYPE
@iexp ip @(ip) 1 +
/* procedure @(ip) */
static TYPE *GetTypeList1(const SCALAR val)
/*
 * Returns a TYPE array with arr[0] = 1.0, arr[1] = val
 */
{
   TYPE *arr;
   arr = malloc(ATL_MulBySize(2));
   assert(arr);
   arr[0] = 1;
   #ifdef TCPLX
      arr[2] = *val;
      arr[3] = val[1];
   #else
      arr[1] = val;
   #endif
   return(arr);
}
#endif

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static int *GetIntList2(int ival1, int ival2)
/*
 * returns integer array with iarr[0] = 1, iarr[1] = ival1, ival[2] = ival2
 */
{
   int *iarr;
   iarr = malloc(3*sizeof(int));
   assert(iarr);
   iarr[0] = 1;
   iarr[1] = ival1;
   iarr[2] = ival2;
   return(iarr);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static int *DupIntList(int *list)
/*
 * Duplicates list of integers, list[0] holds the length, not including 0
 */
{
   int i, n, *ip;

   assert(list);
   n = list[0] + 1;
   ip = malloc(sizeof(int)*n);
   assert(ip);
   for (i=0; i < n; i++)
      ip[i] = list[i];
   return(ip);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static int *GetIntList(int nargs, char **args, int i, int nmul)
/*
 * Gets a list of integers, whose length is given by atoi(args[i])*nmul
 * list is this length+1, since 0'th location gets atoi(args[i])
 */
{
   int n, *iarr, k;

   if (++i >= nargs)
      PrintUsage(args[0], i, NULL);
   n = atoi(args[i]) * nmul;
   assert(n > 0);
   iarr = malloc(sizeof(int)*(n+1));
   assert(iarr);
   
   iarr[0] = n / nmul;
   for (k=0; k < n; k++)
   {
      if (++i >= nargs)
         PrintUsage(args[0], i, NULL);
      iarr[k+1] = atoi(args[i]);
   }
   return(iarr);
}

#ifdef TYPE
@iexp ip @(ip) 1 +
/* procedure @(ip) */
static TYPE *GetTypeList(int nargs, char **args, int i, int nmul)
/*
 * Gets a list of TYPEs, whose length is given by atoi(args[i])*nmul
 * list is this length+1, since 0'th location gets atof(args[i])
 */
{
   int n, k;
   TYPE *arr;

   if (++i >= nargs)
      PrintUsage(args[0], i, NULL);
   n = atoi(args[i]) * nmul;
   assert(n > 0);
   arr = malloc(ATL_MulBySize(n+1));
   assert(arr);
   
   arr[0] = n / nmul;
   for (k=0; k < n; k++)
   {
      if (++i >= nargs)
         PrintUsage(args[0], i, NULL);
      arr[k+(1 SHIFT)] = atof(args[i]);
   }
   return(arr);
}
#endif

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static int *IntRange2IntList(int N0, int NN, int incN)
{
   int i, n;
   int *iarr;

   for (i=N0, n=0; i <= NN; i += incN) n++;
   iarr = malloc(sizeof(int)*(n+1));
   assert(iarr);
   iarr[0] = n;
   for (i=N0, n=1 ; i <= NN; i += incN, n++)
      iarr[n] = i;
   return(iarr);
}
@ROUT atlas_service.h
#ifndef ATLAS_SERVICE_H
   #define ATLAS_SERVICE_H

#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#ifdef __GNUC__
/*
 * This routine overrides system tmpnam when compiling with GNU, which
 * issues an unkillable warning whenever you use this standard ANSI C
 * routine, telling you to use a non-standard routine instead.  If we
 * are being compiled by gnu gcc, use the non-standard routine in order to shut
 * the warnings up.  Here we hope they won't stop supporting a routine
 * that they force you to use.
 */
#ifdef L_tmpnam
  #undef L_tmpnam
#endif
#define L_tmpnam 16
static char *ATL_tmpnam(char *s)
/*
 * Works like ISO standard C's tmpnam: returns a ptr to a safe temporary
 * filename.  If s is NULL, the return pointer points at a static string
 * that is overwritten on the next call.  If s is non-NULL, return it,
 * and write string to user-controlled buffer s.
 * NOTE: this routine is not thread safe if you pass NULL.
 */
{
   static char *buff=NULL;
   char *sp;
   int n, i;
   
   sp = tempnam(NULL, "attmp");
   assert(sp);
   if (s)
   {
      strcpy(s, sp);
      free(sp);
      return(s);
   }
   if (buff)
      free(buff);
   n = strlen(sp) + 1;
   buff = malloc(sizeof(char)*i);
   strcpy(buff, sp);
   free(sp);
   return(buff);
}
   #define tmpnam ATL_tmpnam
#else
   #define ATL_tmpnam tmpnam
#endif

#endif
@ROUT atlas_Tvec.h
@iexp ip 0 0 +
#ifndef ATL_Tvec_H
   #define ATL_Tvec_H

#include "atlas_genparse.h"


typedef struct ATL_Tvec ATL_tvec_t;
struct ATL_Tvec
{
   void *vp;            /* pointer to vector, type in pre */
   char *name;          /* name of vector (eg, "MFLOP" or "N") */
   ATL_tvec_t *next;
   int  N;              /* # of elements in vector (inclucing reps) */
   int nrep;            /* # of repititions in timings */
   char pre;            /* double (d), string (s), char (c), integer (i) */
};

typedef struct ATL_tvstrq ATL_tvstrq_t;
struct ATL_tvstrq
{
   char *sp;
   ATL_tvstrq_t *next;
   int len;
};

@iexp ip @(ip) 1 +
/* procedure @(ip) */
@define tvr @ATL_tvstrq_t *ATL_GetStrNode(char *name)@
@define tve @Allocates node & new string dup, returns node ptr@
ATL_tvstrq_t *ATL_GetStrNode(char *name)
{
   ATL_tvstrq_t *np;
   np = malloc(sizeof(ATL_tvstrq_t));
   assert(np);
   np->sp = DupString(name);
   assert(np->sp);
   np->len = strlen(name);
   strncpy(np->sp, name, np->len+1);
   np->next = NULL;
   return(np);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
@define tvr @ATL_tvstrq_t *ATL_KillStrNode(ATL_tvstrq_t *kp)@
@define tve @Deallocates node & string, returns next@
ATL_tvstrq_t *ATL_KillStrNode(ATL_tvstrq_t *kp)
{
   ATL_tvstrq_t *kn=NULL;
   if (kp)
   {
      kn = kp->next;
      if (kp->sp)
         free(kp->sp);
      free(kp);
   }
   return(kn);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
@define tvr @void ATL_KillStrQ(ATL_tvstrq_t *kb)@
@define tve @Deallocates entire string queue@
void ATL_KillStrQ(ATL_tvstrq_t *kb)
{
   while (kb)
      kb = ATL_KillStrNode(kb);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
@define tvr @ATL_tvstrq_t *RemoveStrNodeFromQ(ATL_tvstrq_t *b, ATL_tvstrq_t *p)@
@define tve @removes p from Q b, sets p->next=NULL, returns new b@
ATL_tvstrq_t *RemoveStrNodeFromQ(ATL_tvstrq_t *b, ATL_tvstrq_t *p)
/*
 * Safely removes p from queue b, returns possibly changed b
 */
{
   if (!b)
      return(NULL);
   if (!p)
      return(b);
   if (p == b)
      b = b->next;
   else
   {
      ATL_tvstrq_t *prev=b, *qp;
      for (qp=b->next; qp; qp = qp->next)
         prev=qp;
      prev->next = p->next;
   }
   p->next = NULL;
   return(b);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
@define tvr @char **ATL_StrQ2Arr(ATL_tvstrq_t *qb, int *N)@
@define tve @Kills qb to make N+1-length NULL-term array of strings instead@
char **ATL_StrQ2Arr(ATL_tvstrq_t *qb, int *N)
/*
 * translates qb to a NULL-term array of strings, destroying qb in process
 */
{
   int n, i;
   char **sarr;
   ATL_tvstrq_t *qp;

   n = *N = ATL_CountStrNodes(qb);
   sarr = malloc((n+1)*sizeof(char*));
   assert(sarr);

   sarr[n] = NULL;
   for (i=0,qp=qb; qp; i++,qp = qp->next)
   {
      sarr[i] = qp->sp;
      qp->sp = NULL;
   }
   ATL_KillStrQ(qb);
   return(sarr);
}


@iexp ip @(ip) 1 +
/* procedure @(ip) */
@define tvr @int ATL_CountStrNodes(ATL_tvstrq_t *qb)@
@define tve @Returns number of nodes in qb@
int ATL_CountStrNodes(ATL_tvstrq_t *qb)
{
   int i;
   ATL_tvstrq_t *qp;
   for (i=0,qp=qb; qp; i++, qp=qp->next);
   return(i);
}
@iexp ip @(ip) 1 +
/* procedure @(ip) */
@define tvr @ATL_tvstrq_t *ATL_ReverseStrQ(ATL_tvstrq_t *oq)@
@define tve @Returns oq in reverse order@
ATL_tvstrq_t *ATL_ReverseStrQ(ATL_tvstrq_t *oq)
/*
 * RETURNS: Reversed order queue of strings (original is reordered)
 */
{
   ATL_tvstrq_t *nq=NULL, *qp;
   while (oq)
   {
      qp = oq;
      oq = oq->next;
      qp->next = nq;
      nq = qp;
   }
   return(nq);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
@define tvr @ATL_tvec_t *ATL_GetTvec(char *name, int N, int nrep, char pre)@
@define tve @Returns allocated Tvec struct, next is NULL, vp alloc, but not init@
ATL_tvec_t *ATL_GetTvec(char *name, int N, int nrep, char pre)
{
   ATL_tvec_t *tp;
   int i;

   tp = malloc(sizeof(ATL_tvec_t));
   i = strlen(name);

   tp->name = malloc(sizeof(char)*(strlen(name)+1));
   strcpy(tp->name, name);
   tp->N = N;
   tp->nrep = nrep;
   tp->next = NULL;
   tp->pre = pre;
   i = N;
   if (pre == 's')
      i *= sizeof(char*);
   else if (pre == 'd')
      i *= sizeof(double);
   else 
      i *= (pre == 'i') ? sizeof(int) : sizeof(char);
   tp->vp = malloc(N*sizeof(double));
   assert(tp->vp);
   return(tp);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
@define tvr @ATL_tvec_t *ATL_KillThisTvec(ATL_tvec_t *tp)@
@define tve @Frees all internal ptrs, frees arg tvec (tp), returns tp->next@
ATL_tvec_t *ATL_KillThisTvec(ATL_tvec_t *tp)
{
   ATL_tvec_t *retp=NULL;

   if (tp)
   {
      if (tp->pre == 's')
      {
         char **sp = tp->vp;
         int i;

         for (i=0; i < tp->N; i++)
            free(sp[i]);
         free(sp);
      }
      else
         free(tp->vp);
      free(tp->name);
      retp = tp->next;
      free(tp);
   }
   return(retp);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
@define tvr @void ATL_KillAllTvecs(ATL_tvec_t *tq)@
@define tve @Frees all Tvecs (and internals) in list@
void ATL_KillAllTvecs(ATL_tvec_t *tq)
{
   while (tq)
      tq = ATL_KillThisTvec(tq);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
@define tvr @void ATL_ReadDoubleTvec(FILE *fpin, int N, double *dp)@
@define tve @Reads in N doubles from fpin into dp@
void ATL_ReadDoubleTvec(FILE *fpin, int N, double *dp)
{
   int i;

   for (i=0; i < N; i++)
      assert(fscanf(fpin, "%lf\n", dp+i) == 1);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
@define tvr @void ATL_ReadIntTvec(FILE *fpin, int N, int *ip)@
@define tve @Reads in N int from fpin into ip@
void ATL_ReadIntTvec(FILE *fpin, int N, int *ip)
{
   int i;

   for (i=0; i < N; i++)
      assert(fscanf(fpin, "%d\n", ip+i) == 1);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
@define tvr @ATL_ReadCharTvec(FILE *fpin, int N, char *cp)@
@define tve @Reads in N chars from fpin into cp@
void ATL_ReadCharTvec(FILE *fpin, int N, char *cp)
{
   int i;

   for (i=0; i < N; i++)
      assert(fscanf(fpin, "%c\n", cp+i) == 1);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
@define tvr @ATL_ReadStringTvec(FILE *fpin, int N, char **sa)@
@define tve @Reads in N strings from fpin into sa@
void ATL_ReadStringTvec(FILE *fpin, int N, char **sa)
{
   int i;

   for (i=0; i < N; i++)
   {
      char *sp;
      int n, j;
      char ln[512];

      assert(fgets(ln, 512, fpin));
      n = strlen(ln) + 1;
      sa[i] = sp = malloc(sizeof(char)*n);
      assert(sp);
      for (j=0; j < n; j++)
         sp[j] = ln[j];
   }
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
@define tvr @ATL_tvec_t *ATL_ReadTvec(FILE *fpin)@
@define tve @Returns one tvec read in from fpin@
ATL_tvec_t *ATL_ReadTvec(FILE *fpin)
{
   int N, nrep;
   char nm[64], pre;
   ATL_tvec_t *tp;

   assert(fscanf(fpin, "%s\n", nm) == 1);
   assert(fscanf(fpin, "%d %d %c", &N, &nrep, &pre) == 3);
   tp = ATL_GetTvec(nm, N, nrep, pre);
   if (pre == 'd')
     ATL_ReadDoubleTvec(fpin, N, tp->vp);
   else if (pre == 'i')
     ATL_ReadIntTvec(fpin, N, tp->vp);
   else if (pre == 'c')
     ATL_ReadCharTvec(fpin, N, tp->vp);
   else /* if (pre == 's') */
     ATL_ReadStringTvec(fpin, N, tp->vp);
   return(tp);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
@define tvr @ATL_tvec_t *ATL_ReadTvecFile(FILE *fpin, char **cmnt, int *nvec)@
@define tve @Return all tvecs from file fpin (fpin at beginning of file!)@
ATL_tvec_t *ATL_ReadTvecFile(FILE *fpin, char **cmnt, int *nvec)
/*
 * Reads an entire timing vector file.
 * RETURNS: linked list of timing vectors
 */
{
   int i, n;
   char ln[512];
   ATL_tvec_t *tb, *tp;

   if (!fgets(ln, 512, fpin))
      return(NULL);
   n = strlen(ln);
   while (n > 0 && isspace(ln[n-1]))
      ln[--n] = '\0';;
   *cmnt = malloc(sizeof(char)*n);
   assert(*cmnt);
   strcpy(*cmnt, ln+1);
   assert(fscanf(fpin, " %d\n", nvec) == 1);

   n = *nvec;
   if (n < 1)
      return(NULL);

   tb = tp = ATL_ReadTvec(fpin);
   for (i=1; i < n; i++)
   {
      tp->next = ATL_ReadTvec(fpin);
      tp = tp->next;
   }
   return(tb);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
@define tvr @void ATL_WriteTvec(FILE *fpout, ATL_tvec_t *tp)@
@define tve @Write a single timing vector to the stream fpout@
void ATL_WriteTvec(FILE *fpout, ATL_tvec_t *tp)
/*
 * Write a single timing vector to the stream fpout
 */
{
   fprintf(fpout, "%s\n", tp->name);
   fprintf(fpout, "%d %d %c\n", tp->N, tp->nrep, tp->pre);
   if (tp->pre == 'd')
   {
      double *dp = tp->vp;
      const int n = tp->N;
      int i;
      for (i=0; i < n; i++)
         fprintf(fpout, "%le\n", dp[i]);
   }
   else if (tp->pre == 'i')
   {
      int *ip = tp->vp;
      const int n = tp->N;
      int i;
      for (i=0; i < n; i++)
         fprintf(fpout, "%d\n", ip[i]);
   }
   else if (tp->pre == 'c')
   {
      char *cp = tp->vp;
      const int n = tp->N;
      int i;
      for (i=0; i < n; i++)
         fprintf(fpout, "%c\n", cp[i]);
   }
   else /* if (tp->pre == 's') */
   {
      char **sp = tp->vp;
      const int n = tp->N;
      int i;
      for (i=0; i < n; i++)
         fprintf(fpout, "%s\n", sp[i]);
   }
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
@define tvr @void ATL_WriteTvecs(FILE *fpout, ATL_tvec_t *tp)@
@define tve @Writes list of tvecs assuming stream already has preamble in it@
void ATL_WriteTvecs(FILE *fpout, ATL_tvec_t *tp)
/*
 * Writes out a queue of output vectors to a stream that has already had
 * the preample (name, nvec, nrep) written to it
 */
{
   while (tp)
   {
      ATL_WriteTvec(fpout, tp);
      tp = tp->next;
   }
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
@define tvr @void ATL_WriteTvecFile(FILE *fpout, char *cmnt, int nvec, ATL_tvec_t *tp)@
@define tve @Writes the entire output file given a queue of timing vectors@
void ATL_WriteTvecFile(FILE *fpout, char *cmnt, int nvec, ATL_tvec_t *tp)
/*
 * Writes the entire output file given a queue of timing vectors 
 */
{
   int i;
   fprintf(fpout, "#%s\n", cmnt);
   fprintf(fpout, "%d\n", nvec);
   ATL_WriteTvecs(fpout, tp);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
@define tvr @ATL_tvec_t *ATL_FindTvecByName(ATL_tvec_t *tb, char *name)@
@define tve @Returns first tvec with name name (NULL if not found)@
ATL_tvec_t *ATL_FindTvecByName(ATL_tvec_t *tb, char *name)
{
   ATL_tvec_t *tp;
   for (tp=tb; tp && strcmp(tp->name, name); tp = tp->next);
   return(tp);
}

@whiledef typ double int char
@iexp ip @(ip) 1 +
/* procedure @(ip) */
@define tvr @void ATL_FillComb@up@(typ)VecUsingInts@
@define tve @Merges two tvecs, go read the function@
void ATL_FillComb@up@(typ)VecUsingInts
(
   ATL_tvec_t *np,    /* combined vector */
   ATL_tvec_t *ip1,   /* 1st index array (we sort cp1 & cp2 on these ivecs) */
   ATL_tvec_t *ip2,   /* 2nd index array (we sort cp1 & cp2 on these ivecs) */
   ATL_tvec_t *cp1,   /* 1st array to be combined */
   ATL_tvec_t *cp2    /* 2st array to be combined */
)
{
   @(typ) *dn = np->vp;
   const @(typ) *d1 = cp1->vp, *d2 = cp2->vp;
   const int *s1 = ip1->vp, *s2 = ip2->vp;
   const int n = np->N, n1 = cp1->N, n2 = cp2->N;
   int ic, i1, i2;

   for (ic=i1=i2=0; ic < n; ic++)
   {
      if (i1 < n1)
      {
         if (i2 < n2)  /* both are available for comparison */
         {
            if (s1[i1] <= s2[i2])
               dn[ic] = d1[i1++];
            else
               dn[ic] = d2[i2++];
         }
         else
         {
            assert(i1 < n1);
            dn[ic] = d1[i1++];
         }
      }
      else
      {
         assert(i2 < n2);
         dn[ic] = d2[i2++];
      }
   }
}
@endwhile

@iexp ip @(ip) 1 +
/* procedure @(ip) */
@define tvr @ATL_tvec_t *ATL_CombineTheseVecsUsingInts@
@define tve @Merges two tvecs, go read the function@
ATL_tvec_t *ATL_CombineTheseVecsUsingInts
(
   ATL_tvec_t *sp1,      /* 1st vector's index array to sort on */
   ATL_tvec_t *sp2,      /* 2nd vector's index array to sort on */
   ATL_tvec_t *cp1,      /* vector to be combined */
   ATL_tvec_t *cp2       /* vector to be combined */
)
{
   ATL_tvec_t *np;
   const pre = cp1->pre;

   assert(sp1->N == cp1->N && sp2->N == cp2->N);
   assert(sp1->pre == sp2->pre && sp1->pre == 'i');
   assert(pre == cp2->pre);
   assert(sp1->nrep == sp2->nrep && sp1->nrep == cp1->nrep && 
          sp1->nrep == cp2->nrep);
   np = ATL_GetTvec(cp1->name, cp1->N+cp2->N, cp1->nrep, pre);
   if (pre == 'i')
      ATL_FillCombINTVecUsingInts(np, sp1, sp2, cp1, cp2);
   else if (pre == 'd')
      ATL_FillCombDOUBLEVecUsingInts(np, sp1, sp2, cp1, cp2);
   else if (pre == 'c')
      ATL_FillCombCHARVecUsingInts(np, sp1, sp2, cp1, cp2);
   return(np);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
@define tvr @void ATL_SuffixTvecNames(ATL_tvec_t *tb, char *suff)@
@define tve @suffix all names in tb with suff@
void ATL_SuffixTvecNames
(
   ATL_tvec_t *tb,   /* list whose names should be suffixed */
   char *suff 
)
{
   ATL_tvec_t *tp;
   int isu;

   isu = strlen(suff) + 1;
   for (tp=tb; tp; tp = tp->next)
   {
      int i, inm, n;
      char *sp;

      inm = strlen(tp->name);
      sp = malloc((inm+isu)*sizeof(char));
      for (i=0; i < inm; i++)
         sp[i] = tp->name[i];
      for (n=inm+isu; i < n; i++)
         sp[i] = suff[i-inm];
      free(tp->name);
      tp->name = sp;
   }
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
@define tvr @ATL_tvec_t *ATL_DupTvec(ATL_tvec_t *t0)@
@define tve @Return newly allocated tvec identical to t0, except ->next is NULL@
ATL_tvec_t *ATL_DupTvec(ATL_tvec_t *t0)
{
   ATL_tvec_t *tp;
   const int N = t0->N;
   int i;

   tp = ATL_GetTvec(t0->name, N, t0->nrep, t0->pre);
   tp->next = NULL;
   if (t0->pre == 'd')
   {
      double *d0 = t0->vp, *d=tp->vp;
      for (i=0; i < N; i++)
         d[i] = d0[i];
   }
   else if (t0->pre == 'i')
   {
      int *d0 = t0->vp, *d=tp->vp;
      for (i=0; i < N; i++)
         d[i] = d0[i];
   }
   else /* pre == 'c' */
   {
      char *d0 = t0->vp, *d=tp->vp;
      assert(t0->pre == 'c');
      for (i=0; i < N; i++)
         d[i] = d0[i];
   }
   return(tp);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
@define tvr @void ATL_AdhereTvec(ATL_tvec_t *dp, ATL_tvec_t *sp)@
@define tve @Stick data in sp->vp to end of dp->vp, sp not changed@
void ATL_AdhereTvec
/*
 * Concatonates sp's Tvec entries to the end of dp's.
 */
(
   ATL_tvec_t *dp,      /* destination Tvec */
   ATL_tvec_t *sp       /* source Tvec */
)
{
   ATL_tvec_t *tp;

   if (!sp)
      return;
   assert(dp);
   assert(dp->pre == sp->pre);
   assert(dp->nrep == sp->nrep);
   if (dp->pre == 's')
   {
      const int Nd = dp->N, Ns = sp->N, Nt = Nd+Ns;
      char **sd, **ss;
      int i;
      sd = malloc(Nt * sizeof(char *));
      for (ss=dp->vp, i=0; i < Nd; i++)
         sd[i] = ss[i];
      free(dp->vp);
      dp->vp = sd;
      dp->N = Nt;
      for (ss=sp->vp, i=0; i < Ns; i++)
         sd[i+Nd] = DupString(ss[i]);
   }
   else
   {
      const int Nd = dp->N, Ns = sp->N, Nt = Nd+Ns;
      int sz;
      char *cp;
      if (dp->pre == 'd')
         sz = sizeof(double);
      else
         sz = (dp->pre == 'i') ? sizeof(int) : sizeof(char);
      cp = malloc(Nt*sz);
      assert(cp);
      memcpy(cp, dp->vp, Nd*sz);
      free(dp->vp);
      dp->vp = cp;
      dp->N = Nt;
      memcpy(cp+Nd*sz, sp->vp, Ns*sz);
   }
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
@define tvr @ATL_tvec_t *ATL_ReverseTvecList(ATL_tvec_t *tb)@
@define tve @Reverse order in list tb@
ATL_tvec_t *ATL_ReverseTvecList  /* RETURNS: reversed list base */
(
   ATL_tvec_t *tb0              /* base of list to reverse */
)
{
   ATL_tvec_t *tb=NULL;
   while (tb0)
   {
      ATL_tvec_t *tp;
      tp = tb0;
      tb0 = tb0->next;
      tp->next = tb;
      tb = tp;
   }
   return(tb);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
@define tvr @ATL_tvec_t *ATL_DupNamedVecsFromList(int N, char** nm, tvec_t *tb, int order)@
@define tve @Returns dups of named vectors from tb; repeat names not duped!@
ATL_tvec_t *ATL_DupNamedVecsFromList  /* returns list of duped vecs */
(
   int N,               /* # of vectors to dup from list to */
   char **names,        /* names of vectors to duplicate */
   ATL_tvec_t *tb0,     /* original list unchanged */
   int order            /* 0: unordered, else: keep in same order as names */
)
{
   ATL_tvec_t *tb=NULL, *tp;
   int i;

   if (!tb0 || N < 1)
      return(NULL);

   for (i=0; i < N; i++)
   {
      tp = ATL_FindTvecByName(tb0, names[i]);
      assert(tp);
      tp = ATL_DupTvec(tp);
      tp->next = tb;
      tb = tp;
   }
   if (order)
      tb = ATL_ReverseTvecList(tb);
   return(tb);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
@define tvr @ATL_tvec_t *ATL_RemoveTvecFromList(ATL_tvec_t *bp, ATL_tvec_t *rp)@
@define tve @Returns new bp after removing rp from bp@
ATL_tvec_t *ATL_RemoveTvecFromList   /* RETURNS: possibly changed base */
(
   ATL_tvec_t *bp, 
   ATL_tvec_t *rp
)
{
   ATL_tvec_t *tp = bp, *prev;
   if (!bp)
      return(NULL);
   if (bp == rp)
      return(bp->next);

   prev=tp;
   for (tp=tp->next; tp; tp = tp->next)
   {
      if (tp == rp)
      {
         prev->next = tp->next;
         break;
      }
      prev = tp;
   }
   return(bp);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
@define tvr @ATL_tvec_t *ATL_PullNamedVecsFromListWithDups(int N, char **names, tvec_t bp)@
@define tve @Returns new list of all named tvecs, which are removed from bp@
ATL_tvec_t *ATL_PullNamedVecsFromListWithDups  /* returns list of pulled vecs */
(
   int N,               /* # of vectors to remove from list to */
   char **names,        /* names of vectors to grab */
   ATL_tvec_t **orig    /* original list has names removed */
)
/*
 * Note that the names will be returned in the provided order, with all
 * repeats of a given name contiguous in the list (so in name order, then
 * file order only within names).
 */
{
   ATL_tvec_t *ob=(*orig), *nb=NULL, *tp;
   int i;
   if (!ob || N < 1)
      return(NULL);
   for (i=0; i < N; i++)
   {
/*
 *    Remove all mentions of selected name, add to new list in reverse order
 */
      while ( (tp = ATL_FindTvecByName(ob, names[i])) )
      {
         ob = ATL_RemoveTvecFromList(ob, tp);
         tp->next = nb;
         nb = tp;
      }
   }
   *orig = ob;
   return(ATL_ReverseTvecList(nb));
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
@define tvr @ATL_tvec_t *ATL_PullNamedVecsFromList(int N, char **names, ATL_tvec_t bp)@
@define tve @Returns list of first instance of named tvecs, which are removed from bp@
ATL_tvec_t *ATL_PullNamedVecsFromList  /* returns list of pulled vecs */
(
   int N,               /* # of vectors to remove from list to */
   char **names,        /* names of vectors to grab */
   ATL_tvec_t **orig    /* original list has names removed */
)
/*
 * Note that the names will be returned in the provided order, and that
 * we assume a name only appears once in orig.
 */
{
   ATL_tvec_t *prev, *old=(*orig), *po, *pn, *nb=NULL;
   int i;
   if (!old || N < 1)
      return(NULL);
   for (i=0; i < N; i++)
   {
      prev = NULL;
      po = old;
      while (po)
      {
         if (!strcmp(names[i], po->name))
         {
            if (po == old)
               old = old->next;
            if (nb)
            {
               pn->next = po;
               pn = po;
            }
            else
               pn = nb = po;
            if (prev)
               prev->next = po->next;
            pn->next = NULL;
            break;
         }
         prev = po;
         po = po->next;
      }
   }
   *orig = old;
   return(nb);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
@define tvr @int ATL_CountTvecsInList(ATL_tvec_t *tb)@
@define tve @Returns number of tvecs in tb@
int ATL_CountTvecsInList
(
   ATL_tvec_t *tb      /* list to count */
)
{
   int i;
   for (i=0; tb; i++, tb = tb->next);
   return(i);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
@define tvr @ATL_tvec_t *ATL_FindLastTvecInList(ATL_tvec_t *tb)@
@define tve @Returns last tvec in list@
ATL_tvec_t *ATL_FindLastTvecInList  /* RETURNS: last Tvec in list */
(
   ATL_tvec_t *tb      /* list to look through */
)
{
   if (tb)
   {
      while (tb->next)
         tb = tb->next;
   }
   return(tb);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
@define tvr @ATL_tvec_t *ATL_AlphabetizeVecList(int N, ATL_tvec_t *tb)@
@define tve @Alphabatizes N-len tb, and returns new ordered list (old destroyed)@
ATL_tvec_t *ATL_AlphabetizeVecList  /* returns alphabatized list */
(
   int N,              /* # of vectors in list */
   ATL_tvec_t *tb      /* list to alphabetize */
)
/*
 * Alphabatizes N-len tb, and returns new ordered list (old is destroyed).
 */
{
   char **names;
   ATL_tvec_t *tp;
   int i, j;

   names = malloc(sizeof(char*)*N);
   assert(names);
   for (i=0; tp && i < N; i++, tp = tp->next)
      names[i] = tp->name;
   assert(i == N);
/*
 * Sort names using selection sort
 */
   for (j=0; j < N-1; j++)
   {
      for (i=j+1; i < N; i++)
      {
         if (strcmp(names[i], names[j]) < 0)
         {
            char *sp = names[j];
            names[j] = names[i];
            names[i] = sp;
         }
      }
   }
/*
 * Use sorted names to make new alphabetical list, free names and return list
 */
   tb = ATL_PullNamedVecsFromList(N, names, &tb);
   free(names);
   return(tb);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
@define tvr @void ATL_CopyStridedVec(char pre, int n, int inc, void *vin, void *vout)@
@define tve @copies every inc elts of vin to vout@
void ATL_CopyStridedVec(char pre, int n, int inc, void *vin, void *vout)
{
   if (pre == 'd')
   {
      int i, j;
      double *in = vin, *out = vout;
      for (j=i=0; i < n; i++, j += inc)
         out[i] = in[j];
   }
   else if (pre == 'i')
   {
      int i, j;
      int *in = vin, *out = vout;
      for (j=i=0; i < n; i++, j += inc)
         out[i] = in[j];
   }
   else if (pre == 'c')
   {
      int i, j;
      char *in = vin, *out = vout;
      for (j=i=0; i < n; i++, j += inc)
         out[i] = in[j];
   }
   else if (pre == 's')
   {
      int i, j;
      char **in = vin, **out = vout;
      for (j=i=0; i < n; i++, j += inc)
      {
         int n;
         n = strlen(in[i]) + 1;
         out[i] = malloc(n*sizeof(char));
         strcpy(out[i], in[j]);
      }
   }
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
@define tvr @void ATL_PrintTvecElt(FILE *fpout, ATL_tvec_t *tp, int idx)@
@define tve @Print element idx of tp->vp@
void ATL_PrintTvecElt
(
   FILE *fpout,         /* stream to print to */
   ATL_tvec_t *tp,      /* vector to print from */
   int idx              /* index in vector to print */
)
{
   if (tp->pre == 'd')
   {
      double *p = tp->vp;
      fprintf(fpout, "%e", p[idx]);
   }
   else if (tp->pre == 'i')
   {
      int *p = tp->vp;
      fprintf(fpout, "%12d", p[idx]);
   }
   else if (tp->pre == 'c')
   {
      char *p = tp->vp;
      fprintf(fpout, "%c", p[idx]);
   }
   else if (tp->pre == 's')
   {
      char **p = tp->vp;
      fprintf(fpout, "%s", p[idx]);
   }
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
@define tvr @void ATL_PrintTvecsInRow(FILE *fpout, ATL_tvec_t *tb, char *sep, int head)@
@define tve @Prints tb, 1 elt per line tvec cols seperated by sep@
void ATL_PrintTvecsInRow
(
   FILE *fpout,         /* stream to print to */
   ATL_tvec_t *tb,      /* list of vectors to print (rowwise) */
   char *sep,           /* string to print between elements */
   int head             /* should we print headers? */
)
{
   ATL_tvec_t *tp;
   const int N = tb->N;
   int i;

   if (!tb)
      return;
   for (tp=tb->next; tp; tp = tp->next)
      assert(tp->N >= N);

   if (head)
      for (tp=tb; tp; tp = tp->next)      /* loop over columns  */
         fprintf(fpout, "%12.12s%s", tp->name, sep);
   fprintf(fpout, "%s\n", sep);
   for (i=0; i < N; i++)                        /* loop over rows of vectors */
   {
      for (tp=tb; tp->next; tp = tp->next)      /* loop over columns  */
      {
         ATL_PrintTvecElt(fpout, tp, i);
         fprintf(fpout, "%s", sep);
      }
      ATL_PrintTvecElt(fpout, tp, i);
      fprintf(fpout, "%s\n", sep);
   }
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
@define tvr @ATL_tvec_t *ATL_GetRep1Tvec(ATL_tvec_t *tin, int istart)@
@define tve @Return new nrep=1 tvec wt only repitition istart represented@
ATL_tvec_t *ATL_GetRep1Tvec
(
   ATL_tvec_t *tin,    /* vector to split */
   int istart          /* which repetition to grab */
)
{
   char *name;
   ATL_tvec_t *t1=NULL;
   int n;
   const int Nr = tin->N / tin->nrep;
   const char pre = tin->pre;

   assert(tin->nrep < 10000000);
   n = strlen(tin->name) + 9;
   name = malloc(n*sizeof(char));
   assert(name);
   sprintf(name, "%s_%d", tin->name, istart);
   t1 = ATL_GetTvec(name, Nr, 1, pre);
   free(name);
   if (pre == 'd')
      ATL_CopyStridedVec(pre, Nr, tin->nrep,((double*)(tin->vp))+istart,t1->vp);
   else if (pre == 'i')
      ATL_CopyStridedVec(pre, Nr, tin->nrep, ((int*)(tin->vp))+istart, t1->vp);
   else if (pre == 'c')
      ATL_CopyStridedVec(pre, Nr, tin->nrep, ((char*)(tin->vp))+istart, t1->vp);
   else if (pre == 's')
      ATL_CopyStridedVec(pre, Nr, tin->nrep, ((char**)(tin->vp))+istart,t1->vp);

   return(t1);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
@define tvr @ATL_tvec_t *ATL_SplitRepsTvec(ATL_tvec_t *tin)@
@define tve @Returns list of seperate vecs for each rep (tin unchanged)@
ATL_tvec_t *ATL_SplitRepsTvec  /* returns Q of sep vecs for each rep */
(
   ATL_tvec_t *tin     /* vector to split */
)
{
   int i;
   const int nrep = tin->nrep;
   ATL_tvec_t *tb, *tp;

   tp = tb = ATL_GetRep1Tvec(tin, 0);
   for (i=1; i < nrep; i++)
   {
      tp->next = ATL_GetRep1Tvec(tin, i);
      tp = tp->next;
   }
   return(tb);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
@define tvr @ATL_tvec_t *ATL_GetStatTvecsDOUBLE(ATL_tvec_t *tin)@
@define tve @returns list of stat vectors: <,+,>@
ATL_tvec_t *ATL_GetStatTvecsDOUBLE  /* returns Q of stat vectors: <,+,> */
(
   ATL_tvec_t *tin     /* vector to get stats for */
)
{
   char *name;
   int i, j, n, N;
   ATL_tvec_t *tavg, *tmin, *tmax;
   double *dmin, *dmax, *davg;

   n = strlen(tin->name) + 5;
   name = malloc(sizeof(char)*n);
   assert(name);
   N = tin->N / tin->nrep;

   sprintf(name, "%s_min", tin->name);
   tmin = ATL_GetTvec(name, N, 1, tin->pre);
   sprintf(name, "%s_avg", tin->name);
   tavg = ATL_GetTvec(name, N, 1, tin->pre);
   sprintf(name, "%s_max", tin->name);
   tmax = ATL_GetTvec(name, N, 1, tin->pre);
   free(name);
   dmin = tmin->vp;
   dmax = tmax->vp;
   davg = tavg->vp;

   n = tin->nrep;
   for (j=0; j < N; j++)
   {
      double min, max, sum, *din;

      din = ((double*)(tin->vp)) + j*n;
      min = max = sum = *din;
      for (i=1; i < n; i++)
      {
         if (din[i] < min)
            min = din[i];
         if (din[i] > max)
            max = din[i];
         sum += din[i];
      }
      dmin[j] = min;
      dmax[j] = max;
      davg[j] = sum / n;
   }
   tmin->next = tavg;
   tavg->next = tmax;
   return(tmin);
}
/*
*******************************************************************************
*                   OVERVIEW OF FUNCTIONS IN THIS FILE                        *
*******************************************************************************
@whiledef tvr
* @(tvr)
*    @(tve)
   @undef tve
@endwhile
*******************************************************************************
*******************************************************************************
*/

#endif  /* end ifdef multi-inclusion guard */
