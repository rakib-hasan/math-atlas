@ROUT l2peak.sh
#!/bin/sh
# USAGE: ./l2peak.sh <L2 FLUSH> <in-L2size>
# First arg is size of L2 to pass to total flush, second is for L2 timings
#
# Discover the BLDdir
#
SRCdir=`fgrep "SRCdir =" Make.inc | sed -e "s/ *SRCdir = *//"`
BINdir=$SRCdir/bin
#
# First time out-of-cache operations
#
./xr1ksearch -T 2 -i R1CASES/mvtch.idx -2 $1 -o mvtch.out
./xr1ksearch -T 2 -i R1CASES/r1tch1.idx -2 $1 -o r1tch1.out
./xr1ksearch -T 2 -i R1CASES/r1tch2.idx -2 $1 -o r1tch2.out
#
# Run in-L2 timings
#
./xr1ksearch -T 32 -i R1CASES/mvtch_L2.idx -2 $2 -o mvtch_L2.out
./xr1ksearch -T 32 -i R1CASES/r1tch1_L2.idx -2 $2 -o r1tch1_L2.out
./xr1ksearch -T 32 -i R1CASES/r1tch2_L2.idx -2 $2 -o r1tch2_L2.out
#
# Translate generated files to csv format
#
$BINdir/sum2csv.sh mvtch.out 2
$BINdir/sum2csv.sh r1tch1.out 2
$BINdir/sum2csv.sh r1tch2.out 2
#
$BINdir/sum2csv.sh mvtch_L2.out 3
$BINdir/sum2csv.sh r1tch1_L2.out 3
$BINdir/sum2csv.sh r1tch2_L2.out 3
@ROUT sum2csv.sh
#!/bin/sh
#
# USAGE: sum2csv.sh <sum file> <mf index>
#
fil=$1
imf=$2
tfil=tmptmp.out
ofil=`echo ${fil} | sed -e "s/out/csv/"`
make xr1sum2csv
rm -f $ofil $tfil
n=`fgrep -n 'CUT HERE' $fil | sed 's/:.*//'`
head -n $n $fil > $tfil
./xr1sum2csv -i $tfil -m $imf -D 2 YU XU -p 1 -o $ofil
rm -f $tfil
@ROUT ccobj
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <stdlib.h>
#define Mstr2(m) # m
#define Mstr(m) Mstr2(m)
void PrintUsage(char *nam)
{
   fprintf(stderr, "USAGE: %s -DBETA[0,1,X,XI0] -o <outfile> --name <name> --objdir <objdir>\n", nam);
   exit(-1);
}
void GetFlags(int nargs, char **args, char *outfile, char *objdir, char *name,
              char **beta, char **conj, char *OS, char *ARCH)
{
   int i, j;
   char *sp;

   *beta = "1";
   *conj = "";
   objdir[0] = name[0] = outfile[0] = ARCH[0] = OS[0] = '\0';
   #ifdef TOPDIR
      strcpy(objdir, Mstr(TOPDIR));
      strcat(objdir, "/tune/blas/gemm/CASES/objs");
   #endif
   for (i=1; i < nargs; i++)
   {
      if (args[i][0] == '-')
      {
         if (args[i][1] == 'o' && args[i][2] == '\0')
            strcpy(outfile, args[++i]);
         else if (!strcmp(args[i], "--name")) strcpy(name, args[++i]);
         else if (!strcmp(args[i], "--objdir")) strcpy(objdir, args[++i]);
         else if (args[i][1] == 'D') /* macro definitions */
         {
            if (!strncmp(args[i], "-DBETA", 6))
            {
               if (args[i][6] == '1') *beta = "1";
               else if (args[i][6] == '0') *beta = "0";
               else if (args[i][6] == 'X') 
               {
                  if (args[i][7] == 'I') *beta = "Xi0";
                  else *beta = "X";
               }
            }
            else if (!strncmp(args[i], "-DATL_BETA=", 11)) /* alternate form */
            {
               if (args[i][11] == '0') *beta = "0";
               else if (args[i][11] == '1') *beta = "1";
               else if (args[i][11] == 'X') 
               {
                  if (args[i][12] == 'I') *beta = "Xi0";
                  else *beta = "X";
               }
            }
            else if (!strncmp(args[i], "-DConj_", 7)) *conj="c";
            else if (!strncmp(args[i], "-DATL_ARCH_", 11))
               strcpy(ARCH, args[i]+11);
            else if (!strncmp(args[i], "-DATL_OS_", 9)) strcpy(OS, args[i]+9);
         }
      }
      else if (strstr(args[i], ".c"))  /* is the file being "compiled" */
      {
         if (outfile[0] == '\0') /* ignore if we have explicit -o */
         {
            for(j=(int)(strstr(args[i], ".c") - args[i]); j; j--)
            {
                if (args[i][j] == '/' || args[i][j] == '\\')
                {
                   if (j) j--;
                   break;
                }
            }
            strcpy(outfile, args[i]+j);
            sp = strstr(outfile, ".c");
            sp[1] = 'o';
         }
      }
   }
   if (objdir[0] == '\0' || name[0] == '\0' || *beta == '\0' || 
       outfile[0] == '\0')
   {
      fprintf(stderr, "objdir='%s', name='%s', beta=%c, outfile='%s'\n",
              objdir, name, *beta, outfile); 
      PrintUsage(args[0]);
   }
   for (i=0; OS[i]; i++) OS[i] = tolower(OS[i]);
   for (i=0; ARCH[i]; i++) ARCH[i] = tolower(ARCH[i]);
}

void OSSysHack(char *name, char *OS, char *ARCH)
{
   if (strstr(name, "julian")) /* julian's Athlon kernel */
   {
      if (ARCH[0]) if (!strstr(ARCH, "athlon")) exit(-1); /* fake failure */
      if (strstr(OS, "win")) strcat(name, "_win");
   }
}
int main(int nargs, char **args)
/*
 * This guy fakes compilation by yanking .o out of
 *    ATLAS/tune/blas/gemm/CASES/objs (objdir)
 * and sticking it in local dir.  Given -D[BETAX,BETA0,BETA1] indicating the
 * beta case, and --name <name> indicating the base name, it copies the file
 *    ATLAS/tune/blas/gemm/CASES/objs/<name>_b[X,0,1].o
 * to the output file.  The output file can be selected by -o <outfile>, and
 * defaults to the name of the argument that ends in .c
 * This is a kludge of such magnitude that I'm almost proud to have written it.
 * To add to the kludge, it now grabs OS and ARCH from the arg list if they
 * are supplied.  Use OS to determine if we need windows version, and suffix
 * --name appropraitely, and use ARCH to see if we want to pretend to have
 * a compiler failure to avoid timing kernels that won't work for this OS.
 */
{
   char ln[1024], outfile[512], objdir[512], name[512], OS[128], ARCH[256]; 
   char *beta, *conj;
   GetFlags(nargs, args, outfile, objdir, name, &beta, &conj, OS, ARCH);
   OSSysHack(name, OS, ARCH);
   sprintf(ln, "cp -f %s/%s%s_b%s.o %s\n", objdir, name, conj, beta, outfile);
   
   fprintf(stderr, "%s", ln);
   return(system(ln));
}
@ROUT substr
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#include <assert.h>

static char LINE0[2048], LINE1[2048];

void PrintUsage(char *nam)
{
   fprintf(stderr, 
  "\nUSAGE: %s -i <infile> -o <outfile> -s \"<find str>\" \"<rep string>\"\n\n",
           nam);
   exit(-1);
}
void GetFlags(int nargs, char **args, FILE **fpin, FILE **fpout, 
              int *nsub, char ***finds, char ***reps)
{
   int i, j, n;
   char **nfind, **nrep;
   *nsub = 0;
   *fpin = stdin;
   *fpout = stdout;
   for (i=1; i < nargs; i++)
   {
      if (args[i][0] != '-') PrintUsage(args[0]);
      switch(args[i][1])
      {
      case 'o':
         i++;
         if (!strcmp(args[i], "stderr")) *fpout = stderr;
         else if (!strcmp(args[i], "stdout")) *fpout = stdout;
         else *fpout = fopen(args[i], "w");
         assert(*fpout);
         break;
      case 'i':
         i++;
         if (!strcmp(args[i], "stdin")) *fpout = stdin;
         else *fpin = fopen(args[i], "r");
         assert(*fpin);
         break;
      case 's':
         n = *nsub + 1;
         nfind = malloc(sizeof(char *)*n);
         nrep = malloc(sizeof(char *)*n);
         assert(nfind && nrep);
         for (j=0; j < *nsub; j++)
         {
            nfind[j] = (*finds)[j];
            nrep[j] = (*reps)[j];
         }
         nfind[j] = args[++i];
         nrep[j] = args[++i];
         if (*nsub > 0)
         {
            free(*finds);
            free(*reps);
         }
         *finds = nfind;
         *reps = nrep;
         *nsub = n;
         break;
      default :
         PrintUsage(args[0]);
      }
   }
}

void MakeSub(char *ln, char *find, char *replace)
{
   char *ln2=LINE1;
   int i, j;
   char *sp;

   sp = strstr(ln, find);
   if (sp)
   {
      i = strlen(find);
      j = strlen(replace);
      strcpy(ln2, sp+i);
      strcpy(sp, replace);
      strcpy(sp+j, ln2);
      MakeSub(sp+j, find, replace);
   }
}

void FirstCharSub(char *ln, char *find, char *replace)
{
   char *ln2=LINE1;
   int i, j;

   i = strlen(find);
   if (!strncmp(ln, find, i))
   {
      j = strlen(replace);
      strcpy(ln2, ln+i);
      strcpy(ln, replace);
      strcpy(ln+j, ln2);
   }
}

void GoToTown(FILE *fpin, FILE *fpout, int nsub, char **finds, char **reps)
{
   char *ln=LINE0;
   int i;

   while (fgets(ln, 1024, fpin))
   {
      for (i=0; i < nsub; i++) 
      {
         if (finds[i][0] == '^') FirstCharSub(ln, finds[i]+1, reps[i]);
         else MakeSub(ln, finds[i], reps[i]);
      }
      fputs(ln, fpout);
   }
}

int main(int nargs, char **args)
{
   FILE *fpin, *fpout;
   int nsub;
   char **finds, **reps;
   GetFlags(nargs, args, &fpin, &fpout, &nsub, &finds, &reps);
   GoToTown(fpin, fpout, nsub, finds, reps);
   if (nsub > 0)
   {
      free(finds);
      free(reps);
   }
   return(0);
}
@ROUT negvmmfile vmmf_gccsub
#include "atlas_vnbcase.h"

void PrintUsage(char *name)
{
@ROUT negvmmfile
   fprintf(stderr, "USAGE: %s <files>: negate mflop in standard MMFiles\n", 
           name);
@ROUT vmmf_gccsub
   fprintf(stderr,
           "USAGE: 'comp' 'sub' <files>: substitute sub for comp in files\n",
           name);
@ROUT negvmmfile vmmf_gccsub
   exit(-1);
}

int main(int nargs, char **args)
{
   MMNODE *mmq, *mmp;
   int i;
@ROUT vmmf_gccsub
   char *comp, *sub;

    comp = args[1];
    sub  = args[2];
   if (nargs < 4)
      PrintUsage(args[0]);
   for (i=3; i < nargs; i++)
@ROUT negvmmfile

   if (nargs < 2)
      PrintUsage(args[0]);
   for (i=1; i < nargs; i++)
@ROUT negvmmfile vmmf_gccsub
   {
      mmq = ReadMMFile(args[i]);
      if (!mmq)
      {
         fprintf(stderr, "\nUnable to open file '%s'!\n\n", args[i]);
         exit(-1);
      }
      for (mmp=mmq; mmp; mmp = mmp->next)
@ROUT vmmf_gccsub
      {
         if (mmp->comp && !strcmp(mmp->comp, comp))
         {
            free(mmp->comp);
            mmp->comp = DupString(sub);
         }
      }
@ROUT negvmmfile
         mmp->mflop = mmp->mflop <= 0 ? mmp->mflop : -mmp->mflop;
@ROUT negvmmfile vmmf_gccsub
      WriteMMFile(args[i], mmq);
      KillAllMMNodes(mmq);
   }
   return(0);
}

@ROUT negcpfile
   @define nmf @4@
   @define rt @cp@
@ROUT negmmfile
   @define nmf @8@
   @define rt @mm@
@ROUT negmvfile
   @define nmf @8@
   @define rt @mv@
@ROUT negr1file
   @define nmf @8@
   @define rt @r1@
@ROUT negr1file negmvfile negmmfile negcpfile
#include <stdio.h>
#include <stdlib.h>
#include "assert.h"
#include "atlas_@(rt)parse.h"
void PrintUsage(char *name)
{
   fprintf(stderr, 
           "USAGE: %s <files> : negate mflops in standard @up@(rt) files\n", 
           name);
   exit(-1);
}
int main(int nargs, char **args)
{
   int i, k;
   double *mfs;
   ATL_@(rt)node_t *p, *pb;
   if (nargs < 2)
      PrintUsage(args[0]);
   for (i=1; i < nargs; i++)
   {
      pb = Read@up@(rt)File(args[i]);
      assert(pb);
      for (p=pb; p; p = p->next)
      {
         mfs = p->mflop;
         for (k=0; k < @(nmf); k++)
            mfs[k] = (mfs[k] > 0.0) ? -mfs[k] : mfs[k];
      }
      ResubGoodGccIn@up@(rt)Nodes(pb);
      Write@up@(rt)File(args[i], pb);
      KillAll@up@(rt)Nodes(pb);
   }
   exit(0);
}
@ROUT negflt getcols stattime atl2tvec atlcat2tvec
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#include <assert.h>

@ROUT atlcat2tvec atl2tvec stattime `static char *SEPSTR = ",";`
typedef struct wOrDs WORDS;
struct wOrDs
{
   char *word;
   WORDS *next;
};

WORDS *GetWord(char *wrd, int wlen)
/*
 * returns a WORD, copying wlen chars from wrd into malloced space
 */
{
   WORDS *wp;
   wp = malloc(sizeof(WORDS));
   assert(wp);
   wp->word = malloc((wlen+1)*sizeof(char));
   assert(wp->word);
   strncpy(wp->word, wrd, wlen);
   wp->word[wlen] = '\0';
   wp->next = NULL;
   return(wp);
}

WORDS *KillWord(WORDS *wp)
{
   WORDS *next=NULL;
   if (wp)
   {
      next = wp->next;
      if (wp->word) free(wp->word);
      free (wp);
   }
   return(next);
}

WORDS *KillAllWords(WORDS *wp0)
{
   while (wp0)
      wp0 = KillWord(wp0);
   return(NULL);
}

void PrintWordList(WORDS *wp)
{
   int i;
   if (!wp) fprintf(stderr, "NULL wordlist\n");
   for (i=0; wp; i++, wp = wp->next)
   {
      fprintf(stderr, "word %d: %s\n", i, wp->word);
   }
}

WORDS *GetWords(char *ln)
{
   int i;
   WORDS *wp0, *wp;
   wp = wp0 = GetWord(" ", 1);
   while (*ln)
   {
      while(isspace(*ln)) ln++;
      if (*ln)
      {
         for (i=0; ln[i] && !isspace(ln[i]); i++);
         wp->next = GetWord(ln, i);
         wp = wp->next;
         ln += i;
      }
   }
   wp->next = NULL;
   if (wp0 != wp) wp = wp0->next;
   else wp = NULL;
   KillWord(wp0);
   return(wp);
}

int WordIsFloat(char *wrd)
/*
 * Returns 0 if wrd is not a valid float, 1 if it is
 * Floats have form [+,-][#].[#][e/d<exp>] 
 * where at least one [#] must appear
 */
{
   int GotDigit=0, GotDot=0, GotExp=0;
   int i;

   switch(*wrd)
   {
   case '0':
   case '1':
   case '2':
   case '3':
   case '4':
   case '5':
   case '6':
   case '7':
   case '8':
   case '9':
      GotDigit = 1;
      break;
   case '-':
   case '+':
      break;
   case '.':
      GotDot = 1;
      break;
   default:
      return(0);
   }
   for (i=1; wrd[i]; i++)
   {
      if (wrd[i] == '.') GotDot++;
      else if (isdigit(wrd[i])) GotDigit++;
      else if (wrd[i] != 'e' || wrd[i] == 'd') GotExp++;
      else if (wrd[i] == '-' || wrd[i] == '+')
      {
         if (wrd[i-1] != 'e' && wrd[i-1] != 'd') return(0);
      }
      else return(0);
   }
   return ( (GotDot == 1) && (GotDigit) && (GotExp==1 || GotExp==0) );
}

@ROUT atl2tvec atlcat2tvec
int WordIsInt(char *wrd)
/*
 * Returns 0 if wrd is not a valid integer.
 */
{
   int i;

   for (i=0; wrd[i]; i++)
      if (!isdigit(wrd[i])) 
         return(0);
   return(1);
}
@ROUT stattime atl2tvec atlcat2tvec
void UpCaseWords(WORDS *wb)
{
   int i;
   for (; wb; wb = wb->next)
   {
      if (wb->word)
         for (i=0; wb->word[i]; i++)
            wb->word[i] = toupper(wb->word[i]);
   }
}

@ROUT negflt
#ifndef REVERSE
void NegateWord(WORDS *wp)
/*
 * Whatever the sign, makes number negative
 */
{
   int i;
   char *cp;

   i = strlen(wp->word) + 1;
   if (wp->word[0] != '+' && wp->word[0] != '-') i++;
   cp = malloc(sizeof(char)*i);
   assert(cp);
   *cp = '-';
   if (wp->word[0] == '+' || wp->word[0] == '-') strcpy(cp+1, wp->word+1);
   else strcpy(cp+1, wp->word);
   free(wp->word);
   wp->word = cp;
}
#else
void NegateWord(WORDS *wp)
/*
 * Whatever the sign, makes opposite
 */
{
   int i;
   char *cp;

   i = strlen(wp->word) + 1;
   if (wp->word[0] != '+' && wp->word[0] != '-') i++;
   cp = malloc(sizeof(char)*i);
   assert(cp);
   if (wp->word[0] == '-') strcpy(cp, wp->word+1);
   else
   {
      *cp = '-';
      if (wp->word[0] == '+') strcpy(cp+1, wp->word+1);
      else strcpy(cp+1, wp->word);
   }
   free(wp->word);
   wp->word = cp;
}
#endif

void PrintUsage(char *nam)
{
   fprintf(stderr, "%s [-N # <flt1> ... <fltN>] <files>\n", nam);
   exit(-1);
}

WORDS *GetFlags(int nargs, char **args, int *n, int **flts)
{
   int i, j;
   WORDS *wp0=NULL, *wpp=NULL, *wp;

   *n = 0;
   *flts = NULL;
   for (i=1; i < nargs; i++)
   {
      if (args[i][0] == '-')
      {
         if (args[i][1] != 'N') PrintUsage(args[0]);
         *n = atoi(args[++i]);
         *flts = malloc((*n)*sizeof(int));
         for (j=0; j < *n; j++) (*flts)[j] = atoi(args[++i]);
      }
      else
      {
         wp = GetWord(args[i], strlen(args[i]));
         if (wpp) { wpp->next = wp; wpp = wp; }
         else wp0 = wpp = wp;
      }
   }
   if (!wp0) PrintUsage(args[0]);
   else wp->next = NULL;
   return(wp0);
}

int InList(int I, int N, int *list)
/*
 * returns 1 if I appears in list (or N < 1), 0 otherwise
 */
{
   int i;
   if (N < 1) return(1);
   for (i=0; i < N; i++) if (list[i] == I) return(i+1);
   return(0);
}

void NegateWords(WORDS *wp0, int N, int *cols)
/* 
 * Negates floats contained in word list.  If N > 0, negates only those
 * floats in the cols list (i.e., if N=1 and cols[0]=2, only the second
 * float in each line is negated
 */
{
   WORDS *wp;
   int IsFlt, i=0;

   for (wp=wp0; wp; wp = wp->next)
   {
      if (WordIsFloat(wp->word))
         if ( InList(++i, N, cols) ) NegateWord(wp);
   }
}

void NegFile(char *fnam, int N, int *cols)
{
   char *tnam;
   char ln[1024];
   FILE *fpin, *fpout;
   WORDS *wp0, *wp;

   tnam = tmpnam(NULL);
   fpin = fopen(fnam, "r");
   assert(fpin);
   fpout = fopen(tnam, "w");
   assert(fpout);
   while (fgets(ln, 1024, fpin))
   {
/* fprintf(stderr, "::::%s\n", ln); */
      wp0 = GetWords(ln);
      if (wp0)
      {
         NegateWords(wp0, N, cols); 
         fprintf(fpout, "%s", wp0->word);
         for (wp=wp0->next; wp; wp = wp->next) fprintf(fpout, " %s", wp->word);
         KillAllWords(wp);
      }
      fprintf(fpout, "\n");
   }
   fclose(fpin);
   fclose(fpout);
   remove(fnam);
   sprintf(ln, "cp -f %s %s\n", tnam, fnam);
   assert(system(ln) == 0);
   remove(tnam);
}

int main(int nargs, char **args)
{
   WORDS *wp, *wp0;
   int n, *cols;

   wp0 = GetFlags(nargs, args, &n, &cols);
   for (wp=wp0; wp; wp = wp->next) 
   {
   fprintf(stderr, "negating %s\n", wp->word);
      NegFile(wp->word, n, cols);
   fprintf(stderr, "done     %s\n", wp->word);
   }
   while (wp0)
   {
      wp = wp0->next;
      free(wp0);
      wp0 = wp;
   }
   exit(0);
}
@ROUT getcols

void GoToTown(FILE *fpin, FILE *fpout, int nskip, int ncols, int *cols)
{
   char ln[1024];
   WORDS *wpb, *wp;
   int i, j, k;

   for (i=0; i != nskip; i++) fgets(ln, 1024, fpin);
   while (fgets(ln, 1024, fpin))
   {
      i = 0;
      wp = NULL;
      wpb = GetWords(ln);
      for (k=0; k != ncols; k++) /* loop over cols user wants */
      {
         for(wp=wpb, j=0; j != cols[k] && wp; j++, wp = wp->next);
         if (j != cols[k]) wp = NULL;
         if (!wp) break;
         i += sprintf(ln+i, "%s ", wp->word);
      }
      if (wp) fprintf(fpout, "%s\n", ln);
      KillAllWords(wpb);
   }
}

void PrintUsage(char *nam)
{
   fprintf(stderr, "\nUSAGE: %s -C <# cols> <col1>...<coln> -o <outfile> -i <infile>\n\n", nam);
   exit(-1);
}

void GetFlags(int nargs, char **args, FILE **fpin, FILE **fpout, int *nskip,
              int *ncols, int **cols)
{
   int i, k, n;

   *ncols = -1;
   *fpin = stdin;
   *fpout = stdout;
   *nskip = 0;
   for (i=1; i < nargs; i++)
   {
      if (args[i][0] != '-') PrintUsage(args[0]);
      switch(args[i][1])
      {
      case 'C':
         n = *ncols = atoi(args[++i]);
         *cols = malloc(sizeof(int)*n);
         assert(*cols);
         for (k=0; k < n; k++) (*cols)[k] = atoi(args[++i]);
         break;
      case 'c':
         *ncols = 1;
         *cols = malloc(sizeof(int));
         assert(*cols);
         **cols = atoi(args[++i]);
         break;
      case 'o':
         i++;
         if (!strcmp(args[i], "stderr")) *fpout = stderr;
         else if (!strcmp(args[i], "stdout")) *fpout = stdout;
         else *fpout = fopen(args[i], "w");
         assert(*fpout);
         break;
      case 'i':
         i++;
         if (!strcmp(args[i], "stdin")) *fpin = stdin;
         else *fpin = fopen(args[i], "r");
         assert(*fpin);
         break;
      case 's':
         *nskip = atoi(args[++i]);
         break;
      default:
         PrintUsage(args[0]);
      }
   }
   if (*ncols < 1)
   {
      *ncols = 1;
      *cols = malloc(sizeof(int));
      assert(*cols);
      **cols = 1;
   }
   for (i=0; i < *ncols; i++) (*cols)[i]--;  /* start from 0 */
}

int main(int nargs, char **args)
/*
 * Gets columns indicated by -C from input, dumps them as new cols to output.
 * Skips -s leading rows, and ignores rows that do not have required cols
 * (eg., if you ask for 4th col, and a row has no 4th col, that line is simply
 * skipped).  The new cols in output are in order they were given on -C
 */
{
   FILE *fpin, *fpout;
   int nskip, ncols, *cols;
   GetFlags(nargs, args, &fpin, &fpout, &nskip, &ncols, &cols);
   GoToTown(fpin, fpout, nskip, ncols, cols);
   if (fpout != stderr && fpout != stdout) fclose(fpout);
   if (fpin != stdin) fclose(fpin);
   free(cols);
   exit(0);
}
@ROUT stattime atl2tvec atlcat2tvec
typedef struct wOrDQ WORDQ;
struct wOrDQ
{
   WORDS *wlist;
   WORDQ *next;
};

static WORDQ *GetWordQ(WORDS *wrds, WORDQ *next)
{
   WORDQ *wp;
   wp = malloc(sizeof(WORDQ));
   assert(wp);
   wp->wlist = wrds;
   wp->next = next;
   return(wp);
}

static WORDQ *KillWordQ(WORDQ *killme)
{
   WORDQ *next;
   if (killme)
   {
      if (killme->wlist)
         KillAllWords(killme->wlist);
      next = killme->next;
      free(killme);
      return(next);
   }
   return(NULL);
}

static WORDQ *KillAllWordQ(WORDQ *killme)
{
   while(killme)
      killme = KillWordQ(killme);
   return(NULL);
}
WORDQ *GetWordQTrans(WORDQ *wqN)
{
  WORDQ *wqT, *qT, *qN;
  WORDS *wpN, *wpT;
  int M, N, i, j, J;

  if (!wqN) 
     return(NULL);
/*
 * Find M rows of data with N outputs, stored one row per WORDQ
 */
  for (N=0, wpN=wqN->wlist; wpN; N++, wpN = wpN->next);
  for (M=0, qN = wqN; qN; M++, qN = qN->next);
/*
 * Allocate N WORDQ entries for transposed data
 */
   wqT = qT = GetWordQ(NULL, NULL);
   for (j=1; j < N; j++) 
   {
      qT->next = GetWordQ(NULL, NULL);
      qT = qT->next;
   }
/*
 * Transpose data
 */
   for (qT=wqT, J=0; J < N; J++, qT = qT->next)
   {
      for (wpN=wqN->wlist, j=0; j < J; j++, wpN = wpN->next);
      qT->wlist = GetWord(wpN->word, strlen(wpN->word));
      wpT = qT->wlist;
      for (qN=wqN->next, i=1; i < M; qN = qN->next, i++)
      {
         for (wpN=qN->wlist, j=0; j < J; j++, wpN = wpN->next);
         wpT->next = GetWord(wpN->word, strlen(wpN->word));
         wpT = wpT->next;
      }
   }
   return(wqT);
}

@ROUT atlcat2tvec
static char *ESUFF=NULL;
static int ENREP=0;
@ROUT stattime atl2tvec atlcat2tvec
WORDQ *ReadTimerFile(FILE* fpin)
/*
 * This routine scans an ATLAS timer output file and returns a queue of
 * word lists, where each entry in the WORDQ is a row, and the entries
 * of WORDQ->wlist are column entries
 * Upon return, the first entry in WORDQ should be the column headings
 * (labels), and subsequent entries are values
 */
{
   char ln0[1024], ln1[1024], *nxtln, *prvln, *ln;
   WORDQ *wq, *wbase;
   WORDS *wrds;
/*
 * Search for line of === indicating previous line are headers
 */
   if (!fgets(ln0, 1024, fpin))
      return(NULL);
   prvln = ln0;
   nxtln = ln1;
   while (fgets(nxtln, 1024, fpin))
   {
      if (strstr(nxtln, "====")) break;
      ln = nxtln;
      nxtln = prvln;
      prvln = ln;
   }
   assert(strstr(nxtln, "===="));
   wbase = wq = GetWordQ(GetWords(prvln), NULL);
   assert(wbase->wlist);
   ln = ln0;
   while (fgets(ln, 1024, fpin))
   {
@ROUT atlcat2tvec
      if (!strncmp(ln, "*** END LABEL=", 14))
      {
         char *sp;
         sp = strstr(ln+14, " NREP=");
         if (sp)
         {
            int i, j;
            for (i=14; !isspace(ln[i]); i++);
            ESUFF = malloc((i-13)*sizeof(char));
            assert(ESUFF);
            if (i == 18 && ln[14] == 'N' && ln[15] == 'O' && 
                ln[16] == 'N' && ln[17] == 'E')
               ESUFF[0] = '\0';
            else
            {
               for (j=14; j < i; j++)
                  ESUFF[j-14] = ln[j];
               ESUFF[i-14] = '\0';
            }
            assert(sscanf(sp+6, "%d", &ENREP) == 1);
            return(wbase);
         }
      }
@ROUT stattime atl2tvec atlcat2tvec
      wrds = GetWords(ln);
      if (wrds)
      {
         wq->next = GetWordQ(wrds, NULL);
         wq = wq->next;
      }
   }
@ROUT atlcat2tvec
   ESUFF = NULL;
   ENREP = 0;
@ROUT stattime atl2tvec atlcat2tvec
   return(wbase);
}


void PrintWordsWithSep(FILE *fpout, WORDS *wrds, char *suff, char *sep)
{
   if (!wrds)
      return;
   fprintf(fpout, "%s", wrds->word ? wrds->word : "ERROR");
   if (suff)
      fprintf(fpout, "%s", suff);
   for (wrds = wrds->next; wrds; wrds = wrds->next)
      fprintf(fpout, "%s%s", sep, wrds->word ? wrds->word : "ERROR");
   fprintf(fpout, "\n");
}

void PrintWordLine(FILE *fpout, WORDS *wrds)
{
   PrintWordsWithSep(fpout, wrds, NULL, SEPSTR);
}

void PrintWordQ(FILE *fpout, char *name, WORDQ *wq)
{
   fprintf(fpout, "*****%s*****\n", name);
   while (wq)
   {
      PrintWordsWithSep(fpout, wq->wlist, NULL, SEPSTR);
      wq = wq->next;
   }
}

WORDS *GetColByNum(WORDQ *wqb, int I)
/*
 * Returns WORDS list of Ith column in row-major struct wqb
 */
{
   WORDQ *wq;
   WORDS *wp, *cb=NULL, *cp;
   int i;

   if (!wqb)
      return(NULL);
   for (wq=wqb; wq; wq = wq->next)
   {
      for (wp=wq->wlist, i=0; i < I; i++, wp = wp->next);
      if (cb)
      {
         cp->next = GetWord(wp->word, strlen(wp->word));
         cp = cp->next;
      }
      else
         cp = cb = GetWord(wp->word, strlen(wp->word));
   }
   return(cb);
}

WORDS *GetColByName(WORDQ *wqb, char *name)
/*
 * Finds column with matching name, assuming row-major wt labels in row 0
 */
{
   int i;
   WORDS *wp;

   if (!wqb)
      return(NULL);
   for (i=0, wp=wqb->wlist; wp && strcmp(name, wp->word); wp = wp->next, i++);
   if (!wp)
      return(NULL);
   return(GetColByNum(wqb, i));
}

double *Words2Doubles(WORDS *wpb, int *N)
/*
 * Translates words to double array, N is length of array 
 */
{
   double *d;
   WORDS *wp;
   int n;

   for (n=0, wp=wpb; wp; n++, wp = wp->next);   /* count words */
   d = malloc(n*sizeof(double));
   for (n=0, wp=wpb; wp; n++, wp = wp->next)    /* convert to doubles */
      d[n] = atof(wp->word);
   *N = n;
   return(d);
}

WORDS *DupWordList(WORDS *wpb0)
/*
 * Duplicates wordlist wpb0
 */
{
   WORDS *wpb1, *wp1, *wp0;

   if (!wpb0)
      return(NULL);
   wpb1 = wp1 = GetWord(wpb0->word, strlen(wpb0->word));
   for (wp0=wpb0->next; wp0; wp0 = wp0->next)
   {
      wp1->next = GetWord(wp0->word, strlen(wp0->word));
      wp1 = wp1->next;
   }
   return(wpb1);
}

WORDQ *GetStridedQ(WORDQ *wqb, int stride)
/*
 * Allocates a new queue where inc elts of wqb are skipped between
 * each new queue
 */
{
   WORDQ *wqbS, *wqS, *wq;    /* S for strided */
   const int gap = stride-1;
   int i;

   if (!wqb)
      return(NULL);
   wqbS = wqS = GetWordQ(DupWordList(wqb->wlist), NULL);
   for (wq=wqb->next; wq; wq = wq->next)
   {
      for (i=0; i < gap && wq; i++)
         wq = wq->next;
      if (!wq)
         return(wqbS);
      wqS->next = GetWordQ(DupWordList(wq->wlist), NULL);
      wqS = wqS->next;
   }
   return(wqbS);
}

WORDQ *KillBadLines(WORDQ *wqb, int verb)
/*
 * Kills any WORDQ entry that doesn't have the same number of columns as wqb
 */
{
   int i, n;
   WORDQ *wq, *prev;
   WORDS *wrds;

   for (n=0,wrds=wqb->wlist; wrds; n++,wrds=wrds->next);  /* # of col labels */

   prev = wqb;
   wq = wqb->next;
   do
   {
      for (i=0,wrds=wq->wlist; wrds; i++,wrds=wrds->next);
      if (i != n)
      {
         if (verb)
         {
            fprintf(stderr, "killing anomolous line :");
            PrintWordLine(stderr, wq->wlist);
         }
         prev->next = wq = KillWordQ(wq);
      }
      else
      {
         prev = wq;
         wq = wq->next;
      }
   }
   while(wq);
   return(wqb);
}

void PrintDoublesWithSep(FILE *fpout, char *name, int N, double *d, char *sep)
{
   int i;

   fprintf(fpout, "%s", name);
   for (i=0; i < N; i++)
      fprintf(fpout, "%s%lf", sep, d[i]);
   fprintf(fpout, "\n");
}

void PrintDoublesWithSepRep(FILE *fpout, char *name, int n, int nrep, 
                            double *d, char *sep)
/*
 * Print all of d, which is in nrep-major storage, length >= n*nrep
 */
{
   int i, j;

   for (i=0; i < nrep; i++)
   {
      fprintf(fpout, "%s_%d", name, i);
      for (j=0; j < n; j++)
         fprintf(fpout, "%s%lf", sep, d[i+j*nrep]);
      fprintf(fpout, "\n");
   }
}

/*
 * This meanDiff function provided by Tony Castaldo
 */
//*****************************************************************************
// meanDiff.c: Tests whether the means on two timing lists are different, and
// returns the largest confidence interval of difference it can achieve. This
// is accomplished with a standard T-Test.
//*****************************************************************************
#include  <math.h>

#define MeanDiff_Rows 14                      /* Values per column */
#define MeanDiff_Cols 34                      /* Columns (DOF values) */
//-----------------------------------------------------------------------------
// These are the critical values of the t-Distribution. 
// Consider this in column major order; the first 14 values are the first 
// column; the next 14 values are the next column, etc. 
// Each column corresponds to one of the 34 DOF values {1-30,40,60,120,infty}. 
// We make infty equivalent to 1024 or more.
//-----------------------------------------------------------------------------
double meanDiffT_Table[]={
  0.40,    0.30,    0.20,    0.15,    0.10,    0.05,    0.025,   0.02,  
  0.015,   0.01,    0.0075,  0.005,   0.0025,  0.0005, 

  0.325,   0.727,   1.376,   1.963,   3.078,   6.314,  12.706,  15.895, // v=1
 21.205,  31.821,  42.434,  63.657, 127.322, 636.59,

  0.289,   0.617,   1.061,   1.386,   1.886,   2.920,   4.303,   4.849, // v=2
  5.643,   6.965,   8.073,   9.925,  14.089,  31.598,

  0.277,   0.584,   0.978,   1.250,   1.638,   2.353,   3.182,   3.482, // v=3
  3.896,   4.541,   5.047,   5.841,   7.453,  12.924,

  0.271,   0.569,   0.941,   1.190,   1.533,   2.132,   2.776,   2.999, // v=4
  3.298,   3.747,   4.088,   4.604,   5.598,   8.610,

  0.267,   0.559,   0.920,   1.156,   1.476,   2.015,   2.571,   2.757, // v=5
  3.003,   3.365,   3.634,   4.032,   4.773,   6.869,

  0.265,   0.553,   0.906,   1.134,   1.440,   1.943,   2.447,   2.612, // v=6
  2.829,   3.143,   3.372,   3.707,   4.317,   5.959,

  0.263,   0.549,   0.896,   1.119,   1.415,   1.895,   2.365,   2.517, // v=7
  2.715,   2.998,   3.203,   3.499,   4.029,   5.408,

  0.262,   0.546,   0.889,   1.108,   1.397,   1.860,   2.306,   2.449, // v=8
  2.634,   2.896,   3.085,   3.355,   3.833,   5.041,

  0.261,   0.543,   0.883,   1.100,   1.383,   1.833,   2.262,   2.398, // v=9
  2.574,   2.821,   2.998,   3.250,   3.690,   4.781, 

  0.260,   0.542,   0.879,   1.093,   1.372,   1.812,   2.228,   2.359, // v=10
  2.527,   2.764,   2.932,   3.169,   3.581,   4.587,

  0.260,   0.540,   0.876,   1.088,   1.363,   1.796,   2.201,   2.328, // v=11
  2.491,   2.718,   2.879,   3.106,   3.497,   4.437,

  0.259,   0.539,   0.873,   1.083,   1.356,   1.782,   2.179,   2.303, // v=12
  2.461,   2.681,   2.836,   3.055,   3.428,   4.318,

  0.259,   0.537,   0.870,   1.079,   1.350,   1.771,   2.160,   2.282, // v=13
  2.436,   2.650,   2.801,   3.012,   3.372,   4.221, 

  0.258,   0.537,   0.868,   1.076,   1.345,   1.761,   2.145,   2.264, // v=14
  2.415,   2.624,   2.771,   2.977,   3.326,   4.140,

  0.258,   0.536,   0.866,   1.074,   1.341,   1.753,   2.131,   2.249, // v=15
  2.397,   2.602,   2.746,   2.947,   3.286,   4.073,

  0.258,   0.535,   0.865,   1.071,   1.337,   1.746,   2.120,   2.235, // v=16
  2.382,   2.583,   2.724,   2.921,   3.252,   4.015,

  0.257,   0.534,   0.863,   1.069,   1.333,   1.740,   2.110,   2.224, // v=17
  2.368,   2.567,   2.706,   2.898,   3.222,   3.965,

  0.257,   0.534,   0.862,   1.067,   1.330,   1.734,   2.101,   2.214, // v=18
  2.356,   2.552,   2.689,   2.878,   3.197,   3.922, 

  0.257,   0.533,   0.861,   1.066,   1.328,   1.729,   2.093,   2.205, // v=19
  2.346,   2.539,   2.674,   2.861,   3.174,   3.883,

  0.257,   0.533,   0.860,   1.064,   1.325,   1.725,   2.086,   2.197, // v=20
  2.336,   2.528,   2.661,   2.845,   3.153,   3.849,

  0.257,   0.532,   0.859,   1.063,   1.323,   1.721,   2.080,   2.189, // v=21
  2.328,   2.518,   2.649,   2.831,   3.135,   3.819,

  0.256,   0.532,   0.858,   1.061,   1.321,   1.717,   2.074,   2.183, // v=22
  2.320,   2.508,   2.639,   2.819,   3.119,   3.792,

  0.256,   0.532,   0.858,   1.060,   1.319,   1.714,   2.069,   2.177, // v=23
  2.313,   2.500,   2.629,   2.807,   3.104,   3.768,

  0.256,   0.531,   0.857,   1.059,   1.318,   1.711,   2.064,   2.172, // v=24
  2.307,   2.492,   2.620,   2.797,   3.091,   3.745,

  0.256,   0.531,   0.856,   1.058,   1.316,   1.708,   2.060,   2.167, // v=25
  2.301,   2.485,   2.612,   2.787,   3.078,   3.725,

  0.256,   0.531,   0.856,   1.058,   1.315,   1.706,   2.056,   2.162, // v=26
  2.296,   2.479,   2.605,   2.779,   3.067,   3.707,

  0.256,   0.531,   0.855,   1.057,   1.314,   1.703,   2.052,   2.158, // v=27
  2.291,   2.473,   2.598,   2.771,   3.057,   3.690,

  0.256,   0.530,   0.855,   1.056,   1.313,   1.701,   2.048,   2.154, // v=28
  2.286,   2.467,   2.592,   2.763,   3.047,   3.674,

  0.256,   0.530,   0.854,   1.055,   1.311,   1.699,   2.045,   2.150, // v=29
  2.282,   2.462,   2.586,   2.756,   3.038,   3.659,

  0.256,   0.530,   0.854,   1.055,   1.310,   1.697,   2.042,   2.147, // v=30
  2.278,   2.457,   2.581,   2.750,   3.030,   3.646,

  0.255,   0.529,   0.851,   1.050,   1.303,   1.684,   2.021,   2.125, // v=40
  2.250,   2.423,   2.542,   2.704,   2.971,   3.551,

  0.254,   0.527,   0.848,   1.045,   1.296,   1.671,   2.000,   2.099, // v=60
  2.223,   2.390,   2.504,   2.660,   2.915,   3.460,

  0.254,   0.526,   0.845,   1.041,   1.289,   1.658,   1.980,   2.076, // v=120
  2.196,   2.358,   2.468,   2.617,   2.860,   3.373,

  0.253,   0.524,   0.842,   1.036,   1.282,   1.645,   1.960,   2.054, // v=infty
  2.170,   2.326,   2.432,   2.576,   2.807,   3.291};

int meanDiffT_DOF[MeanDiff_Cols]=
    {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18, 
     19,20,21,22,23,24,25,26,27,28,29,30,40,60,120, 
     1024};

//----------------------------------------------------------------------------
// meanDiff: Finds the appropriate confidence interval.
// Negative means A1 is better, Positive means A2 is better.
// 
// -1, +1: Undecided; sign based on least minimum.
// +/-.40, .30, .20, .15, .10, .05, .025, .02, .015, .01, .0075, .0025, .0005
// All mean we have that level of confidence (so far) that A1 or A2 has the
// lesser mean.
//----------------------------------------------------------------------------    
// We assume variances are NOT equal, but we demand the counts ARE equal.
// We compute a confidence interval for (meanA1 - meanA2), which requires
// T=t_{\alpha/2} and a standard error, SE=sqrt((s_1^2+s_2^2)/count); where 
// s_1^2 and s_2^2 are the variances of each population.
//
// The point estimate is PE=(meanA1-meanA2), and the confidence interval 
// is PE +/- T*SE. To compute DOF on T, we must truncate the value
// DOF = ((s_1^2+s_2^2)^2) / ((count-1)*(s_1^4 + s_2^4))  to the lowest
// available DOF in the table. Since we have v_1 and v_2,
// DOF = ((v_1+v_2)^2) / ((count-1.)*(v_1^2 + v_2^2))
//----------------------------------------------------------------------------    
double meanDiff(double *A1, double *A2, int count, 
                double *stddev1, double *stddev2) /* standard deviations */
{
  int i;
  double x, PE, SE, DOF, meanA1=0.0, meanA2=0.0;
  double varA1=0.0, varA2=0.0, lowerB, upperB;
  double* T;
  
  if (count < 1) return(1.);                          /* dumb call. */
  for (i=0; i<count; i++)                             /* Compute means. */
  {
    meanA1 += A1[i];                                  /* Add to mean. */
    meanA2 += A2[i];                                  /* .. */
  }

  meanA1 /= (double) count;                            /* Divide by count. */
  meanA2 /= (double) count;                            /* .. */

  if (count < 2)                                      /* If no DOF, */
  {
    if (meanA1 < meanA2) return(-1.);                 /* Go by only value. */
    return( 1.);                                      /* .. */
  }

  /* Must compute variances. */
  for (i=0; i<count; i++)
  {
    x = (A1[i]-meanA1);                               /* Find difference. */
    varA1 += x*x;                                     /* Add to variance. */
    x = (A2[i]-meanA2);                               /* Find difference. */
    varA2 += x*x;                                     /* Add to variance. */
  }

  varA1 /= (double) (count-1);                        /* Compute variance. */
  varA2 /= (double) (count-1);                        /* .. */
  *stddev1 = sqrt(varA1);                             /* standard deviation */
  *stddev2 = sqrt(varA2);                             /* standard deviation */

  SE = sqrt((varA1+varA2)/count);                 /* Compute standard error. */
  PE = meanA1 - meanA2;                           /* Point estimate of diff. */

  /*--------------------------------------------------
   * Compute degrees of freedom.
   *-------------------------------------------------- */
  x = (varA1+varA2);                                  /* Add variances. */
  DOF = x*x*(count-1.);                               /* Set the numerator. */
  x = (varA1*varA1 + varA2*varA2);                    /* Compute denominator. */
  DOF /= x;                                           /* Find the DOF. */
  for (i=1; i<MeanDiff_Cols; i++)                     /* Search widths. */
    if (DOF < meanDiffT_DOF[i]) break;           /* Exit when greater found. */

  /*--------------------------------------------------
   * Recall that the first column is the actual conf,
   * so we want 'i' to be one-relative, not zero rel.
   *-------------------------------------------------- */
  T = meanDiffT_Table + i*MeanDiff_Rows;              /* Point at our column. */

  /*--------------------------------------------------
   * Now, in reverse, we form the confidence interval
   * at every level of certainty; and when we find
   * one that does NOT include zero, we know there is
   * a difference in the means. If we don't find one,
   * we can't tell. 
   */
  /*-------------------------------------------------- */
  
  for (i=(MeanDiff_Rows-1); i>0; i--)                 /* Scan backwards. */
  {
    lowerB = PE - T[i]*SE;                  /* Find lower bound of conf int. */
    upperB = PE + T[i]*SE;                  /* Find upper bound of conf int. */
    if (lowerB > 0.0 || upperB < 0.0) break;     /* If zero impossible, exit. */
  }

  if (meanA1 < meanA2)                    /* If we are returning a negative, */
  {
    if (i == 0) return(-1.0);             /* Could not decide. */
    x = meanDiffT_Table[i];               /* Get the confidence interval. */
    x = 1.-2.*x;                          /* Find our surety level. */
    return(0.-x);                         /* Exit with result. */
  }                                       /* End if returning a negative. */

  // We are returning a positive.
  if (i==0) return(1.0);                  /* Could not decide.*/
  x = meanDiffT_Table[i];                 /* Get the confidence interval. */
  x = 1.-2.*x;                            /* Find our surety level. */
  return(x);                              /* Exit with A2 the greater. */
  
} /* END *** meanDiff *** */

FILE *OpenInputFile(char *file)
{
   FILE *fp;
   if (!strcmp(file, "stdin"))
      fp = stdin;
   else if (!strcmp(file, "stderr"))
      fp = stderr;
   else
   {
      fp = fopen(file, "r");
      if (!fp)
      {
         fprintf(stderr, "Unable to open input file %s!\n", file);
         exit(-1);
      }
   }
   return(fp);
}

FILE *OpenOutputFile(char *file)
{
   FILE *fp;
   if (!strcmp(file, "stdout"))
      fp = stdout;
   else if (!strcmp(file, "stderr"))
      fp = stderr;
   else
   {
      fp = fopen(file, "w");
      if (!fp)
      {
         fprintf(stderr, "Unable to open output file %s!\n", file);
         exit(-1);
      }
   }
   return(fp);
}

@ROUT atl2tvec atlcat2tvec
void PrintUsage(char *name, char *arg, int i)
{
   if (i > 0)
      fprintf(stderr, "BAD ARG '%s' ON %dth FLAG\n", arg, i);
   fprintf(stderr, "USAGE: %s <flags> ; flags include:\n", name);
@ROUT atl2tvec
   fprintf(stderr, 
           "   -# : # of reps of each timing consecutive output\n");
@ROUT atl2tvec atlcat2tvec
   fprintf(stderr, 
           "   -i <file> : input file for processed results [stdin]\n");
   fprintf(stderr, 
           "   -o <file> : output file for processed results [stdout]\n");
   fprintf(stderr, "   -c \"comment line\"\n");
   fprintf(stderr,"   -s <sepstr> : cols in output seperated by this string\n");
   fprintf(stderr,"   -H # <h1> ... <h#> : grab columns with header strings\n");
   fprintf(stderr,
           "   -C # <c1> ... <c#> : grab provided columns numbers (1-based)\n");
   fprintf(stderr, 
           "   -S <start> <stride> : grab strided rows starting at start\n");
   exit (i ? i : -1);
}

#define DWAVG 0  /* do what */
#define DWMIN 1
#define DWMAX 2

int GetFlags  /* returns: DOWHAT (AVG,MIN,MAX) */
(
   int nargs, char **args, 
   FILE **fpin,         /* input file (stdin) */
   FILE **fpout,        /* output file (stdout) */
   char **cmnt,         /* header comment ("No header specified") */
   int *nrep,           /* # of repititions (1) */
   int *start,          /* outline line to start at (1) */
   int *stride,         /* stride between lines (1) */
   int *ncols,          /* # of cols to make into vectors */
   int **cols,          /* NULL: specced by name, else list of col #s to use */
   char ***colnams      /* NULL: specced by #, else list of headers to get */
)
{
   int i, dow = DWAVG;
   *fpin = stdin;
   *fpout = stdout;
   *cmnt = "No  header specified";
   *nrep = *start = *stride = 1;
   *ncols = 0;
   *cols = NULL;
   *colnams = NULL;
   for (i=1; i < nargs; i++)
   {
      if (args[i][0] != '-')
         PrintUsage(args[0], "no '-' preceeding flag!", i);
      switch(args[i][1])
      {
         case 'c':
            if (++i >= nargs)
               PrintUsage(args[0], "out of flags in -c ", i-1);
            *cmnt = args[i];
            break;
         case 's':
            if (++i >= nargs)
               PrintUsage(args[0], "out of flags in -s ", i-1);
            SEPSTR = args[i];
            break;
         case '#':
            if (args[i][2] == '>')
               dow = DWMAX;
            else if (args[i][2] == '<')
               dow = DWMIN;
            else if (args[i][2] == '+')
               dow = DWAVG;
            if (++i >= nargs)
               PrintUsage(args[0], "out of flags in -# ", i-1);
            *nrep = atoi(args[i]);
            break;
         case 'o':
            if (++i >= nargs)
               PrintUsage(args[0], "out of flags in -# ", i-1);
            *fpout = OpenOutputFile(args[i]);
            break;
         case 'S':
            if (++i >= nargs)
               PrintUsage(args[0], "out of flags in -S", i-1);
            *start = atoi(args[i]);
            if (++i >= nargs)
               PrintUsage(args[0], "out of flags in -S", i-1);
            *stride = atoi(args[i]);
            break;
         case 'i':
            if (++i >= nargs)
               PrintUsage(args[0], "out of flags in -i ", i-1);
            *fpin = OpenInputFile(args[i]);
            break;
         case 'C':  /* col numbers: -C # <c1> ... <c#> */
         {
            int j, n, *cn;
            if (++i >= nargs)
               PrintUsage(args[0], "out of flags in -C ", i-1);
            n = atoi(args[i]);
            cn = malloc(sizeof(int)*n);
            assert(cn);
            for (j=0; j < n; j++)
            {
               if (++i >= nargs)
                  PrintUsage(args[0], "out of flags in -C ", i-1);
               cn[j] = atoi(args[i]) - 1;
            }
            if (*colnams)
                free(*colnams);  /* they are exclusive */
            *colnams = NULL;
            *ncols = n;
            *cols = cn;
         }
            break;
         case 'H':  /* column header strings: -H # <h1> ... <h#> */
         {
            int j, n;
            char **cn;

            if (++i >= nargs)
               PrintUsage(args[0], "out of flags in -H ", i-1);
            n = atoi(args[i]);
            cn = malloc(sizeof(char*)*n);
            assert(cn);
            for (j=0; j < n; j++)
            {
               if (++i >= nargs)
                  PrintUsage(args[0], "out of flags in -H ", i-1);
               cn[j] = args[i];
            }
            if (*cols)
               free(*cols);
            *cols = NULL;   /* exlusive */
            *ncols = n;
            *colnams = cn;
         }
            break;
         default :
            PrintUsage(args[0], args[i], i);
      }                 /* end of case over flags */
   }                    /* end of for over flags */
   return(dow);
}
@ROUT stattime
void PrintUsage(char *name, char *arg, int i)
{
   if (i > 0)
      fprintf(stderr, "BAD ARG '%s' ON %dth FLAG\n", arg, i);
   fprintf(stderr, "USAGE: %s <flags> ; flags include:\n", name);
   fprintf(stderr, "   -# : # of reps of each timing consecutive output\n");
   fprintf(stderr, "   -fd <file> : timing file, compare consecutive lines\n");
   fprintf(stderr, "   -fs <startA> <startB> <inc> <file> : timing file, compare strided lines\n");
   fprintf(stderr, 
   "   -f2 <fileA> <fileB> : compare all result lines fileA vs. fileB\n");
   fprintf(stderr, 
   "   -fA <startA> <inc> <file> : 1st timing file, compare against fB\n");
   fprintf(stderr, 
   "   -fB <startA> <inc> <file> : 2nd timing file, compare against fA\n");
   fprintf(stderr, "   -fm0 <file> : file 0 wt raw mflop/time results only\n");
   fprintf(stderr, "   -fm1 <file> : file 1 wt raw mflop/time results only\n");
   fprintf(stderr, "   -o <file> : output file for processed results\n");
   fprintf(stderr, "   -v <verb> : vary verbosity of output\n");
   fprintf(stderr,"   -s <sepstr> : cols in output seperated by this string\n");
   exit (i ? i : -1);
}

#define CompRawFlops   0
#define CompTwoFiles   1
#define CompOneFile    2

int GetFlags(int nargs, char **args, FILE **fpA, FILE **fpB, FILE **fpout,
             int *nrep, int *startA, int *startB, int *strideA, int *strideB,
             int *verb)
{
   int i, iret;
   *nrep = 1;
   *fpout = stdout;
   *startA = *startB = -1;
   *strideA = *strideB = 0;
   *fpA = NULL;
   *fpB = NULL;
   *fpout = stdout;
   *verb = 0;
   iret = CompOneFile;
   for (i=1; i < nargs; i++)
   {
      if (args[i][0] != '-')
         PrintUsage(args[0], "no '-' preceeding flag!", i);
      switch(args[i][1])
      {
         case 's':
            if (++i >= nargs)
               PrintUsage(args[0], "out of flags in -v ", i-1);
            SEPSTR = args[i];
            break;
         case 'v':
            if (++i >= nargs)
               PrintUsage(args[0], "out of flags in -v ", i-1);
            *verb = atoi(args[i]);
            break;
         case '#':
            if (++i >= nargs)
               PrintUsage(args[0], "out of flags in -# ", i-1);
            *nrep = atoi(args[i]);
            break;
         case 'o':
            if (++i >= nargs)
               PrintUsage(args[0], "out of flags in -# ", i-1);
            *fpout = OpenOutputFile(args[i]);
            break;
         case 'f':
            switch(args[i][2])
            {
            case 'A':   /* -fA <start> <inc> <file> */
               iret = CompTwoFiles;
               if (++i >= nargs)
                  PrintUsage(args[0], "out of flags in -fA", i-1);
               *startA = atoi(args[i]);
               if (++i >= nargs)
                  PrintUsage(args[0], "out of flags in -fA", i-1);
               *strideA = atoi(args[i]);
               if (++i >= nargs)
                  PrintUsage(args[0], "out of flags in -fA ", i-1);
               *fpA = OpenInputFile(args[i]);
               break;
            case 'B':   /* -fB <start> <inc> <file> */
               iret = CompTwoFiles;
               if (++i >= nargs)
                  PrintUsage(args[0], "out of flags in -fB", i-1);
               *startB = atoi(args[i]);
               if (++i >= nargs)
                  PrintUsage(args[0], "out of flags in -fB ", i-1);
               *strideB = atoi(args[i]);
               if (++i >= nargs)
                  PrintUsage(args[0], "out of flags in -fB", i-1);
               *fpB = OpenInputFile(args[i]);
               break;
            case '2':  /* -f2 <fileA> <fileB> */
               iret = CompTwoFiles;
               *strideA = *strideB = 1;
               *startA = *startB = 1;
               if (++i >= nargs)
                  PrintUsage(args[0], "out of flags in -f2", i-1);
               *fpA = OpenInputFile(args[i]);
               if (++i >= nargs)
                  PrintUsage(args[0], "out of flags in -f2", i-1);
               *fpB = OpenInputFile(args[i]);
               break;
            case 'm':   /* -fm[0,1] <file> */
               iret = CompRawFlops;
               if (++i >= nargs)
                  PrintUsage(args[0], "out of flags in -fm#", i-1);
               if (args[i-1][3] == '0')
                  *fpA = OpenInputFile(args[i]);
               else
                  *fpB = OpenInputFile(args[i]);
               break;
            case 'd':  /* -f <file> */
               iret = CompOneFile;
               *startA = 1;
               *startB = 2;
               *strideA = *strideB = 2;
               if (++i >= nargs)
                  PrintUsage(args[0], "out of flags in -f", i-1);
               *fpA = OpenInputFile(args[i]);
               break;
            case 's':  /* -fs <startA> <startB> <inc> <file>  */
               iret = CompOneFile;
               if (++i >= nargs)
                  PrintUsage(args[0], "out of flags in -f ", i-1);
               *startA = atoi(args[i]);
               if (++i >= nargs)
                  PrintUsage(args[0], "out of flags in -f ", i-1);
               *startB = atoi(args[i]);
               if (++i >= nargs)
                  PrintUsage(args[0], "out of flags in -f ", i-1);
               *strideA = *strideB = atoi(args[i]);
               if (++i >= nargs)
                  PrintUsage(args[0], "out of flags in -f", i-1);
               *fpA = OpenInputFile(args[i]);
               break;
            default :
               PrintUsage(args[0], args[i], i);
            }
            break;
      }
   }
   if (*fpA == NULL)
   {
      *fpA = stdin;
      *fpB = NULL;
      if (*startA < 0)
         *startA = 1;
      if (*startB < 0)
         *startB = 2;
      if (*strideA == 0)
         *strideA = 2;
      if (*strideB == 0)
         *strideB = 2;
      iret = CompOneFile;
   }
   return(iret);
}

double *GetConfidences(int n,            /* # of unique problems */
                       int nrep,         /* # of times each problem repeated */
                       double *mfA,      /* nrep-major mflop array for routA */
                       double *mfB)      /* nrep-major mflop array for routB */
/*
 * Returns 3*n length array, 1st $n$ elts hold the confidence, 2nd $n$ hold
 * the standard deviations of A, and the 3rd $n$ has std dev of B
 */
{
   double *conf;
   int i;

   conf = malloc(3*n*sizeof(double));
   assert(conf);
   for (i=0; i < n; i++)
   {
      conf[i] = 100.0*meanDiff(mfA+i*nrep, mfB+i*nrep, nrep, 
                               conf+n+i, conf+n+n+i);
      if (conf[i] == 100.0 || conf[i] == -100.0)
         conf[i] = 0.0;
   }
   return(conf);
}

@ROUT atl2tvec stattime atlcat2tvec
double *GetMaxMinAvgSample(int n, int nrep, double *mf0)
/*
 * Takes an n*nrep length nrep-major array, and returns an 3*n-length array
 * containing the minimum in the first $n$ elts, the avg in the next $n$ elts,
 * and the max in the last $n$ elts.
 */
{
   double *mfS, *mfL, *mfA, max, min, avg;
   const double dreps = 1.0 / (double)nrep;
   int i, k;

   mfS = malloc(3*n*sizeof(double));
   assert(mfS);
   mfA = mfS + n;
   mfL = mfA + n;

   for (i=0; i < n; i++)
   {
      min = avg = max = *mf0++;
      for (k=1; k < nrep; k++, mf0++)
      {
         if (max < *mf0)
            max = *mf0;
         if (min > *mf0)
            min = *mf0;
         avg += *mf0;
      }
      mfL[i] = max;
      mfS[i] = min;
      mfA[i] = avg * dreps;
   }
   return(mfS);
}

int WordsAreDiff(WORDS *wpA, WORDS *wpB)
/*
 * RETURNS word with difference (starting from 1), 0 if same
 */
{
   int i;
   for(i=1; wpA && wpB; i++, wpA = wpA->next, wpB = wpB->next)
      if (strcmp(wpA->word, wpB->word))
         return(i);
   return(wpA == wpB ? 0 : i);  /* not same if one longer */
}

WORDQ *ConsolidateDupWordQ(WORDQ **wqA0, WORDQ **wqB0)
/*
 * Finds duplicate WORDQs in A & B, and removes them from their data
 * structures and puts them on a new consolicated WORDQ, which is returned
 */
{
   WORDQ *wqA, *wqB;            /* gen ptr for A & B Qs */
   WORDQ *wqAp, *wqBp;          /* prev ptrs for A & B Qs */
   WORDQ *wqD=NULL, *wqd;      /* wqD (wqd) is base (gen) ptr for dup Q */

/*
 * Remove all common Qs at front; this requires changing wqA/B
 */
   wqA = *wqA0;
   wqB = *wqB0;
   while (wqA && wqB && !WordsAreDiff(wqA->wlist, wqB->wlist))
   {
      if (!wqD)
         wqD = wqA;
      else
         wqd->next = wqA;
      wqd = wqA;
      wqA = wqA->next;
      wqd->next = NULL;
      wqB = KillWordQ(wqB);
   }
   *wqA0 = wqA;
   *wqB0 = wqB;
   if (!wqA || !wqB)
      return(wqD);
/*
 * Search remainder of Q for dupls; this does not affect 1st ptrs of input Qs
 */
   wqAp = wqA;
   wqA = wqA->next;
   wqBp = wqB;
   wqB = wqB->next;
   while (wqA && wqB)
   {
      if (!WordsAreDiff(wqA->wlist, wqB->wlist))
      {
         if (!wqD)
            wqD = wqA;
         else
            wqd->next = wqA;
         wqd = wqA;
         wqAp->next = wqA = wqA->next;
         wqd->next = NULL;
         wqBp->next = wqB = KillWordQ(wqB);
      }
      else
      {
         wqAp = wqA;
         wqA = wqA->next;
         wqBp = wqB;
         wqB = wqB->next;
      }
   }
   return(wqD);
}

WORDQ *KillWordQByName(WORDQ *wq, char *name)
{
   WORDQ *wqb = wq, *wqP=NULL;
   while (wq)
   {
      if (strcmp(wq->wlist->word, name))
      {
         wqP = wq;
         wq = wq->next;
      }
      else /* names match, so kill this WORDQ */
      {
         if (wqP)
         {
            wq = wqP->next = KillWordQ(wq);
            wqP = wq;
         }
         else
            wq = wqb = KillWordQ(wq);
      }
   }
   return(wqb);
}

void PrintWordQsWithSep(FILE *fpout, WORDQ *wqb, char *suff, char *sep)
{
   while(wqb)
   {
      PrintWordsWithSep(fpout, wqb->wlist, suff, sep);
      wqb = wqb->next;
   }
}

WORDQ *GetMassagedQ(FILE *fpin, int start, int stride, int verb)
/*
 * Reads in file, then massages it into standard format:
 * 1. Labels/names (row 1) are upcased
 * 2. Lines w/o the proper number of cols are deleted
 * 3. Stride and start are taken care of
 * RETURNS: massaged queue.
 */
{
   int i;
   WORDQ *wqb, *wq;    /* base and general ptr, resp. */

   wqb = ReadTimerFile(fpin);
   if (!wqb)
      return(NULL);
   UpCaseWords(wqb->wlist);        /* upcase labels for ease of strcmp */
   wqb = KillBadLines(wqb, verb);
   if (start == 1 && stride == 1)
      return(wqb);
   for (i=0,wq=wqb; i < start; i++, wq = wq->next);
   wq = GetStridedQ(wq, stride);
   wq = GetWordQ(DupWordList(wqb->wlist), wq);  /* put headers back on */
   KillAllWordQ(wqb);
   return(wq);
}

@ROUT stattime
void HandleStandardQs(WORDQ *wqA, WORDQ *wqB, FILE *fpout, int nrep, int verb)
/*
 * Given two queues holding matching results for routA and routB, process
 * them for mflop/confidence, etc, and spit output into fpout.  wq[A,B] assumed
 * to have nrep contiguous entries per problem for statistical purposes.
 */
{
   WORDQ *wqD;          /* duplicate results from A & B */
   WORDQ *wq;           /* general WORDQ ptr */
   WORDS *wp;           /* general WORDS ptr */
   double *mfA, *mfB, *conf, *mfA1, *mfB1;
   int i, N, n;

/*
 * Translate MFLOP column to doubles for A & B;
 */
   wp = GetColByName(wqA, "MFLOP");
   if (!wp) 
      wp = GetColByName(wqA, "MFLOPS");
   assert(wp);
   mfA = Words2Doubles(wp->next, &N);
   KillAllWords(wp);

   wp = GetColByName(wqB, "MFLOP");
   if (!wp) 
      wp = GetColByName(wqB, "MFLOPS");
   assert(wp);
   mfB = Words2Doubles(wp->next, &i);
   KillAllWords(wp);

   n = N / nrep;                        /* # of difference cases timed */
   assert(i == N && n*nrep == N);
   conf = GetConfidences(n, nrep, mfA, mfB);
   mfA1 = GetMaxMinAvgSample(n, nrep, mfA);
   mfB1 = GetMaxMinAvgSample(n, nrep, mfB);

/* 
 * Now that we've got mflops with reps, kill reps of rest of args
 */
   wq = GetStridedQ(wqA->next, nrep);  /* non-repeated args w/o headers */
   KillAllWordQ(wqA->next);            /* free rep structure */
   wqA->next = wq;                     /* put header back on */
   wq = GetStridedQ(wqB->next, nrep);  /* non-repeated args w/o headers */
   KillAllWordQ(wqB->next);            /* free rep structure */
   wqB->next = wq;                     /* put header back on */
/*
 * Transpose columns into rows for ease of printing, and get rid of old rows
 */
   wq =  GetWordQTrans(wqA);
   KillAllWordQ(wqA);
   wqA = wq;
   wq =  GetWordQTrans(wqB);
   KillAllWordQ(wqB);
   wqB = wq;
/*
 * Kill MFLOP row, since we will print it using the doubles arrays
 * Kill TIME row as well, as it follows MFLOP & is not pricise enough
 */
   wqA = KillWordQByName(wqA, "MFLOP");
   wqA = KillWordQByName(wqA, "TIME");
   wqB = KillWordQByName(wqB, "MFLOP");
   wqB = KillWordQByName(wqB, "TIME");
/*
 * Reduce duplicate rows to one copy only, delete out of old structures
 */
   wqD = ConsolidateDupWordQ(&wqA, &wqB);
/*
 * Print rows common to both routs
 */
   PrintWordQsWithSep(fpout, wqD, NULL, SEPSTR);
   fprintf(fpout, "\n");
/*
 * Print rows unique to each routine, and confidence array
 */
   PrintWordQsWithSep(fpout, wqA, "_A", SEPSTR);
   PrintDoublesWithSep(fpout, "minmf_A", n, mfA1, SEPSTR);
   PrintDoublesWithSep(fpout, "maxmf_A", n, mfA1+n+n, SEPSTR);
   PrintDoublesWithSep(fpout, "avgmf_A", n, mfA1+n, SEPSTR);
   PrintDoublesWithSep(fpout, "stdev_A", n, conf+n, SEPSTR);
   fprintf(fpout, "\n");
   PrintWordQsWithSep(fpout, wqB, "_B", SEPSTR);
   PrintDoublesWithSep(fpout, "minmf_B", n, mfB1, SEPSTR);
   PrintDoublesWithSep(fpout, "maxmf_B", n, mfB1+n+n, SEPSTR);
   PrintDoublesWithSep(fpout, "avgmf_B", n, mfB1+n, SEPSTR);
   PrintDoublesWithSep(fpout, "stdev_B", n, conf+n+n, SEPSTR);
   fprintf(fpout, "\n");
   PrintDoublesWithSep(fpout, "confid", n, conf, SEPSTR);
/*
 * Print out full array of all results for each routine
 */
   fprintf(fpout, "\n\n");
   PrintDoublesWithSepRep(fpout, "mfA", n, nrep, mfA, SEPSTR);
   fprintf(fpout, "\n");
   PrintDoublesWithSepRep(fpout, "mfB", n, nrep, mfB, SEPSTR);
/*
 * Free all queues
 */
   KillAllWordQ(wqA);
   KillAllWordQ(wqB);
   KillAllWordQ(wqD);
   free(mfA);
   free(mfB);
   free(conf);
   free(mfA1);
   free(mfB1);
}

void HandleTwoFileComp(FILE *fpA, FILE *fpB, FILE *fpout, 
                       int startA, int startB, int strideA, int strideB,
                       int nrep, int verb)
/*
 * This routine compares timings where timings for routA are in fp0,
 * and timings for routB are in fp1.  Assumes ATLAS-style timer output, 
 * and that there are nrep rows of the same timing contiguous in the output.
 */
{
   WORDQ *wqA, *wqB;         /* original rows from file */
/*
 * Read in col column-based input, upcase the labels, and kill any lines
 * that don't have the right number of columns, and if necessary, grab
 * only certain lines, and then go to town.
 */
   wqA = GetMassagedQ(fpA, startA, strideA, verb);
   wqB = GetMassagedQ(fpB, startB, strideB, verb);
   HandleStandardQs(wqA, wqB, fpout, nrep, verb);
}

void HandleOneFileComp(FILE *fpin, FILE *fpout, int startA, int startB, 
                       int stride, int nrep, int verb)
/*
 * This routine compares timings where timings are found in same file.
 * Assumes ATLAS-style timer output, and that there are nrep rows of
 * the same two timing are contiguous.  Compares timing lines (ignoring nrep)
 * separated by stride-1 rows 
 */
{
   WORDQ *wqb;          /* original rows from file */
   WORDQ *wqA, *wqB;    /* results from routA & B respectively */
   WORDQ *wq;           /* general WORDQ ptr */
   int i;
   
/*
 * Read in col column-based input, upcase the labels, and kill any lines
 * that don't have the right number of columns
 */
   wqb = ReadTimerFile(fpin);
   UpCaseWords(wqb->wlist);    /* upcase labels for ease of strcmp */
   wqb = KillBadLines(wqb, verb);
/*
 * Separate results for each rout, and kill original merged queue
 */
   for (i=0,wq=wqb; i < startA; i++, wq = wq->next);
   wqA = GetStridedQ(wq, stride);
   wqA = GetWordQ(DupWordList(wqb->wlist), wqA); /* put headers back on */
   for (i=0,wq=wqb; i < startB; i++, wq = wq->next);
   wqB = GetStridedQ(wq, stride);
   wqB = GetWordQ(DupWordList(wqb->wlist), wqB); /* put headers back on */
   KillAllWordQ(wqb);
   HandleStandardQs(wqA, wqB, fpout, nrep, verb);
}

double *ReadRawFlopFile(FILE *fpin, int *N)
/*
 * Reads a file where each line has form <result as double>
 */
{
   char ln[1024];
   double tarr[1024], *d;
   int i, n=0;

/*
 * Read one result/line, skipping comment or malformed lines
 */
   while (fgets(ln, 1024, fpin))
   {
      if (ln[0] == '#')  /* skip comment lines */
         continue;
      if (sscanf(ln, "%lf", tarr+n) != 1)
      {
         fprintf(stderr, "Ignoring line '%s'!!\n", ln);
         continue;
      }
      n++;
   }

/*
 * Allocate and copy to user array, and return
 */
   assert(n);
   d = malloc(n*sizeof(double));
   assert(d);
   for (i=0; i < n; i++)
      d[i] = tarr[i];
   *N = n;
   return(d);
}

void HandleRawFlopFiles(FILE *fpA, FILE *fpB, FILE *fpout)
{
   double *dA, *dB, stdevA, stdevB;
   int N, i;
   double confidence;
   dA = ReadRawFlopFile(fpA, &N);
   dB = ReadRawFlopFile(fpB, &i);
   N = (N > i) ? i : N;
   confidence = meanDiff(dA, dB, N, &stdevA, &stdevB);
   if (confidence == 1.0 || confidence == -1.0)
      fprintf(fpout, "Results indistinguishable with %d samples\n", N);
   else if (confidence >= 0)
      fprintf(fpout,"%.2f%% confident resA larger than resB using %d samples\n",
              confidence*100.0, N);
   else
      fprintf(fpout,"%.2f%% confident resB larger than resA using %d samples\n",
              -confidence*100.0, N);
   fprintf(fpout, "Standard devations: A=%e, B=%e\n", stdevA, stdevB);
}

int main (int nargs, char **args)
{
   FILE *fp0, *fp1, *fpout;
   int action, nrep, startA, startB, strideA, strideB, verb;

   action = GetFlags(nargs, args, &fp0, &fp1, &fpout, &nrep, 
                     &startA, &startB, &strideA, &strideB, &verb);
   if (action == CompRawFlops)
      HandleRawFlopFiles(fp0, fp1, fpout);
   else if (action == CompTwoFiles)
      HandleTwoFileComp(fp0, fp1, fpout, startA, startB, strideA, strideB, 
                        nrep, verb);
   else if (action == CompOneFile)
      HandleOneFileComp(fp0, fpout, startA, startB, strideA, nrep, verb);
   else
   {
      fprintf(stderr, "unknown action %d!!\n", action);
      exit(-1);
   }

   exit(0);
}
@ROUT atl2tvec atlcat2tvec
int WordNumberInList
(
   WORDS *wl,           /* list of words to search through */
   char *mtch           /* word to search for in wl */
)
{
   int i;
   
   for (i=0; wl; i++, wl = wl->next)
   {
      if (!strcmp(mtch, wl->word))
         return(i);
   }
   return(-1);
}

int *ColNames2ColNums   /* returns N-len array of column #s to fetch */
(
   WORDS *headb,        /* headers of columns */
   int N,               /* # of names */
   char **names
)
{
   int i, *nums, uplen=0;
   char *upnam=NULL;

   nums = malloc(sizeof(int)*N);
   assert(nums);
   for (i=0; i < N; i++)
   {
      int k, len;

      len = strlen(names[i]) + 1;
      if (len > uplen)
      {
         if (upnam)
            free(upnam);
         upnam = malloc(sizeof(char)*len);
      }
      for (k=0; upnam[k] = toupper(names[i][k]); k++);
      nums[i] = WordNumberInList(headb, upnam);
      if (nums[i] < 0)
      {
         fprintf(stderr, "NO SUCH COLUMN HEADER = '%s'\n", names[i]);
         free(nums);
         exit(-1);
      }
   }
   if (upnam)
   free(upnam);
   return(nums);
}

WORDQ *GetColumnsByNums
(
   WORDQ *rowq,    /* original row-wise queue from ATLAS output file */
   int N,          /* # of columns to grab */
   int *cnums      /* N-len array of column indexes to grab */
)
{
   int j;
   WORDQ *wqb, *wqp;

   if (N < 1)
      return(NULL);
   wqb = wqp = GetWordQ(GetColByNum(rowq, cnums[0]), NULL);
   for (j=1; j < N; j++)
   {
      wqp->next = GetWordQ(GetColByNum(rowq, cnums[j]), NULL);
      wqp = wqp->next;
   }
   return(wqb);
}

int CountWords(WORDS *words)
{
   int i;
   for (i=0; words; words = words->next, i++);
   return(i);
}

char GetStringType  /* returns c for char, s for string */
(
   WORDS *wp
)
{
   for (; wp; wp = wp->next)
   {
      if (wp->word[1] != '\0')
         return('s');
   }
   return('c');
}

@ROUT atl2tvec
void PrintOutVectors
(
   int N,               /* # of vectors */
   int nrep,            /* # of repititions within the vectors */
   WORDQ *wqb,          /* N-len queue of vectors stored as WORDS */
   FILE *fpout,         /* stream to print to */
   char *cmnt           /* comment to stick as 1st line of file */
)
/*
 * Prints all vectors to fpout.  The output looks like:
 * #<cmnt>
 * <nvec>      # number of vectors
 * <vec1>
 * <vec2>
 *
 * Each vector consists of:
 * <name>
 * <len> <nrep> [i,d,s,c]    # char gives data type (int, double, string, char)
 * <elt1>
 * <elt2>
 */
{
   int j;
   char pre;
   WORDQ *wq=wqb;

   fprintf(fpout, "#%s\n", cmnt);
   fprintf(fpout, "%d\n", N);
   for (j=0; j < N; j++)
   {
      WORDS *wp = wq->wlist;
      if (WordIsFloat(wp->next->word))
         pre = 'd';
      else if (WordIsInt(wp->next->word))
         pre = 'i';
      else
         pre = GetStringType(wp->next);
      fprintf(fpout, "%s\n%d %d %c\n", wp->word, CountWords(wp->next), 
              nrep, pre);
      for (wp=wp->next; wp; wp = wp->next)
          fprintf(fpout, "%s\n", wp->word);
      wq = wq->next;
   }
}

int main (int nargs, char **args)
{
   int dw, nrep, start, stride, ncols;
   int *cols;
   FILE *fpin, *fpout;
   char *cmnt, **colnams;
   WORDQ *wqb, *wq;

   dw = GetFlags(nargs, args, &fpin, &fpout, &cmnt, &nrep, &start, &stride,
                 &ncols, &cols, &colnams);
   wqb = GetMassagedQ(fpin, start, stride, 0);
   if (colnams)
   {
      assert(!cols);
      cols = ColNames2ColNums(wqb->wlist, ncols, colnams);
      free(colnams);
      colnams = NULL;
   }
   assert(cols);
   wq = GetColumnsByNums(wqb, ncols, cols);
   KillAllWordQ(wqb);             /* into only selected column-major queues */
   PrintOutVectors(ncols, nrep, wq, fpout, cmnt);
   KillAllWordQ(wq);
   if (fpin != stdin)
      fclose(fpin);
   free(cols);
   return(0);
}
@ROUT atlcat2tvec
typedef struct tvecq tvecq_t;
struct tvecq
{
   char *suff;
   int nrep;
   WORDQ *wq;
   tvecq_t *next;
};

void PrintOutVectors
(
   int N,               /* # of vectors */
   tvecq_t *tb,         /* queue of tvectors */
   FILE *fpout,         /* stream to print to */
   char *cmnt           /* comment to stick as 1st line of file */
)
/*
 * Prints all vectors to fpout.  The output looks like:
 * #<cmnt>
 * <nvec>      # number of vectors
 * <vec1>
 * <vec2>
 *
 * Each vector consists of:
 * <name>
 * <len> <nrep> [i,d,s,c]    # char gives data type (int, double, string, char)
 * <elt1>
 * <elt2>
 */
{
   int j;
   char pre;

   fprintf(fpout, "#%s\n", cmnt);
   fprintf(fpout, "%d\n", N);
   while (tb)
   {
      tvecq_t *tn = tb->next;
      WORDQ *wq;

      for (wq=tb->wq; wq; wq = wq->next)
      {
         WORDS *wp = wq->wlist;
         if (WordIsFloat(wp->next->word))
            pre = 'd';
         else if (WordIsInt(wp->next->word))
            pre = 'i';
         else
            pre = GetStringType(wp->next);
         fprintf(fpout, "%s%s\n%d %d %c\n", wp->word, tb->suff, 
                 CountWords(wp->next), tb->nrep, pre);
         for (wp=wp->next; wp; wp = wp->next)
             fprintf(fpout, "%s\n", wp->word);
      }
      free(tb->suff);
      KillAllWordQ(tb->wq);
      free(tb);
      tb = tn;
   }
}
int main (int nargs, char **args)
{
   int dw, nrep, start, stride, ncols, ntvec=0;
   int *cols=NULL;
   FILE *fpin, *fpout;
   char *cmnt, **colnams, ln[4096];
   WORDQ *wqb, *wq;
   tvecq_t *tb=NULL, *tp;

   dw = GetFlags(nargs, args, &fpin, &fpout, &cmnt, &nrep, &start, &stride,
                 &ncols, &cols, &colnams);
   while (1)
   {
      wqb = GetMassagedQ(fpin, start, stride, 0);
      if (!ENREP || !wqb)
         break;
      if (colnams)
      {
         if (cols)
            free(cols);
         cols = ColNames2ColNums(wqb->wlist, ncols, colnams);
      }
      wq = GetColumnsByNums(wqb, ncols, cols);
      KillAllWordQ(wqb);     /* into only selected column-major queues */
      ntvec++;
      tp = malloc(sizeof(tvecq_t));
      assert(tp);
      tp->nrep = ENREP;
      tp->suff = ESUFF;
      tp->wq = wq;
      tp->next = tb;
      tb = tp;
   }
   free(colnams);
   PrintOutVectors(ncols*ntvec, tb, fpout, cmnt);
   if (fpin != stdin)
      fclose(fpin);
   free(cols);
   return(0);
}
@ROUT timelanb.sh
#!/bin/sh
if test $# -gt 0
then
   n=$1
else
   n=8
fi
if test $# -gt 1
then
   mfl=$2
else
   mfl=100
fi
@multidef nb 32 64 64
@whiledef op q g l
#
#      System LAPACK's
#
   @whiledef lib atl acm got
      if [ -e "LA@(lib)_@(lib)_@(op)${n}.out" ]
      then
         echo "LA@(lib)_@(lib)_@(op)${n}.out already exists, skipping!"
      else
         if [ -x "./xdlanbtst_l@(lib)_@(lib)" ]
         then
            ./xdlanbtst_l@(lib)_@(lib) -# ${n} -nb 1 @(nb) -F ${mfl} -U 1 @(op) \
               -n 15 100 200 300 400 500 600 700 800 900 1000 1200 1400 \
                     1600 1800 2000 | tee LA@(lib)_@(lib)_@(op)${n}.out 2>&1
         else
            echo "Cannot find ./xdlanbtst_l@(lib)_@(lib)"
         fi
      fi
      if [ -e "@(lib)_@(op)${n}_std.out" ]
      then
         echo "@(lib)_@(op)${n}_std.out already exists, skipping!"
      else
         if [ -x "./xdlanbtstF_fl_@(lib)" ]
         then
            ./xdlanbtstF_fl_@(lib) -# ${n} -nb 1 @(nb) -F ${mfl} -U 1 @(op) \
               -n 15 100 200 300 400 500 600 700 800 900 1000 1200 1400 \
                     1600 1800 2000 | tee @(lib)_@(op)${n}_std.out 2>&1
         else
            echo "Cannot find ./xdlanbtstF_fl_@(lib)!"
         fi
      fi
      if [ -e "@(lib)_@(op)${n}_opt.out" ]
      then
         echo "@(lib)_@(op)${n}_opt.out already exists, skipping!"
      else
         if [ -x "./xdlanbtstF_fl_@(lib)_opt" ]
         then
            ./xdlanbtstF_fl_@(lib)_opt -# ${n} -nb 1 1 -F ${mfl} -U 1 @(op) \
               -n 15 100 200 300 400 500 600 700 800 900 1000 1200 1400 \
                     1600 1800 2000 | tee @(lib)_@(op)${n}_opt.out 2>&1
         else
            echo "Cannot find ./xdlanbtstF_fl_@(lib)_opt!"
         fi
      fi
   @endwhile
   @undef nb
@endwhile
@ROUT findnsNB.sh
#!/bin/sh
@whiledef op q g
   @whiledef lib atl acm got
if [ -x "./xdlanbtstF_fl_@(lib)" ]
then
   echo "Tuning up @(lib)-@(op)"
   if [ -e "findnsNB_@(lib)_@up@(op).out" ]
   then
      echo "findnsNB_@(lib)_@up@(op).out already exists, skipping!"
   else
   @whiledef nb 64 32 8
   ./xdlanbtstF_fl_@(lib) -F 100 -# 8 -ob OPNB_@(lib)_@up@(op).f -U 1 @(op) \
      -n 9 25 50 100 300 500 1000 1200 2000 10000 -m 1 @(nb) -a 500 \
      -nb 13 1 4 8 12 16 20 24 28 32 36 40 44 48 -% 0 0 75 0 \
      > findnsNB_@(lib)_m@(nb)_@up@(op).out 2>&1 
   ./xdlanbtstF_fl_@(lib) -F 100 -# 8 -ob OPNB_@(lib)_@up@(op).f -U 1 @(op) \
      -m 9 25 50 100 300 500 1000 1200 2000 10000 -n 1 @(nb) \
      -nb 13 1 4 8 12 16 20 24 28 32 36 40 44 48 -% 0 0 75 0 \
      > findnsNB_@(lib)_n@(nb)_@up@(op).out 2>&1 
   @endwhile
   touch findnsNB_@(lib)_@up@(op).out
   fi
else
   echo "Cannot find ./xdlanbtstF_fl_@(lib)!"
fi
   @endwhile
@endwhile
@ROUT findNB.sh
#!/bin/sh
@whiledef op q g l
   @whiledef lib atl acm got
if [ -x "./xdlanbtstF_fl_@(lib)" ]
then
   echo "Tuning up @(lib)-@(op)"
   if [ -e "findNB_@(lib)_@up@(op).out" ]
   then
      echo "findNB_@(lib)_@up@(op).out already exists, skipping!"
   else
   ./xdlanbtstF_fl_@(lib) -% 4 16 50 0 -# 8 -ob OPNB_@(lib)_@up@(op).f -U 1 @(op) \
      -n 24 25 50 75 100 125 150 175 200 250 300 350 400 450 \
            500 600 700 800 900 1000 1200 1400 1600 1800 2000 \
      -nb 30 4 8 12 16 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 \
             96 112 128 144 160 176 192 224 256 \
      > findNB_@(lib)_@up@(op).out 2>&1 
   fi
else
   echo "Cannot find ./xdlanbtstF_fl_@(lib)!"
fi
   @endwhile
@endwhile
@rout mvsum2csv
   @define rt @mv@
@rout r1sum2csv
   @define rt @r1@
@rout mmsum2csv
   @define rt @mm@
@rout r1sum2csv mmsum2csv mvsum2csv
#include "atlas_misc.h"
#include "atlas_@(rt)parse.h"

@beginskip
double Flop2Sec(ATL_INT M, ATL_INT N, double mf)
/*
 * Translates flop-count back to time
 */
{
@ROUT r1sum2csv
   #ifdef TREAL
      return(((1.0*M)*(2.0*N)+Mmin(M,N))/(mf*1.0e6));
   #else
      return(((((6.0*M)*N+Mmin(M,N)) + (2.0*M)*N)*1.0e-6)/mf);
   #endif
@ROUT r1sum2csv mmsum2csv mvsum2csv
}

double Sec2BW(int eltsize, ATL_INT M, ATL_INT N, double secs)
/*
 * Translates seconds to bandwidth millions of bytes/second
 */
{
   return(((1.0*M)*N*eltsize)/(secs*1.0e6));
}

void Mflop2BW(int eltsz, ATL_CINT M, ATL_CINT N, ATL_@(rt)node_t *kp, int imf)
{
   int m, n;
   while (kp)
   {
      m = (M/kp->XU)*kp->XU;
      n = (N/kp->YU)*kp->YU;
      kp->mflop[imf] = Flop2Sec(m, n, kp->mflop[imf])
      kp->mflop[imf] = Sec2BW(etlsz, m, n, kp->mflop[imf])
      kp = kp->next;
   }
}
@endskip

void Mflop2Perc(ATL_@(rt)node_t *kp, int imf, double mf)
{
   for (; kp; kp = kp->next)
      kp->mflop[imf] /= mf;
}

void PrintMUxNU_CSV
(
   FILE *fpout,         /* file to print to */
   ATL_@(rt)node_t *kp, /* pointer to kernel queue */
   int imf,             /* mflop value to print out */
   int PERC             /* nonzero: convert mflop to % of 1st case */
)
/*
 * Builds a 2-D output CSV, with MU along the rows,
 * and NU along the columns, and MFLOP inside the matrix.  Builds a second
 * matrix with routine name in the matrix as well.
 */
{
   int *mus, *nus;
   char **names;
   ATL_@(rt)node_t *bp, *maxp, *minp, *p;
   int i, j, n, mmin, mmax, nmin, nmax, nmu, nnu;
   double mf1=0.0;

   bp = Clone@up@(rt)Queue(kp);
   assert(bp);
/*
 * Discover max size of each dim of 2-D table, and allocate space to store
 * the MU/NU labels
 */
   n = ATL_CountNumberOf@up@(rt)Nodes(bp);
   mmin = FindMinIntIn@up@(rt)Q(bp, &bp->XU)->XU;
   mmax = FindMaxIntIn@up@(rt)Q(bp, &bp->XU)->XU;
   nmin = FindMinIntIn@up@(rt)Q(bp, &bp->YU)->YU;
   nmax = FindMaxIntIn@up@(rt)Q(bp, &bp->YU)->YU;
   nmu = mmax - mmin;
   nnu = nmax - nmin;
   nmu = Mmin(nmu, n);
   nnu = Mmin(nnu, n);
   mus = malloc((nnu+nmu)*sizeof(int));
   assert(mus);
   nus = mus + nmu;

/*
 * Yank out all nodes that have minimum XU/MU, use this row to compute all the
 * legal YU/NUs, which are stored as our column headings (nus)
 */
   minp = Yank@up@(rt)NodesByIntVal(&bp, &bp->XU, mmin);  /* nodes wt min(XU) */
   assert(minp);
   minp = Sort@up@(rt)QByIntVal(minp, &minp->YU); /* sort least-to-great on YU */
   fprintf(fpout, "&&XU/YU");
   for (p=minp,nnu=0; p; p = p->next)            /* look thru all YU nodes */
   {
      nus[nnu++] = p->YU;                        /* and label Y axis */
      fprintf(fpout, "&%d", p->YU);              /* print label */
   }
   fprintf(fpout, "\n");
   names = malloc((nnu*nmu)*sizeof(char*));
   assert(names);
/*
 * Iteratively find the minimum XU, and then build a row of the table
 * by yanking out all entries with that XU value, and putting them in
 * a new queue
 */
   nmu = 0;
   do
   {
      fprintf(fpout, "&");
      fprintf(fpout, "&%d", minp->XU);
      for (j=0, p=minp; p; j++, p = p->next)
      {
         names[nmu*nnu+j] = DupString(p->rout);
@beginskip
         if (p->YU != nus[j])
            while(1);
         if (p->XU != mmin)
            while(1);
@endskip
         assert(p->YU == nus[j]);
         assert(p->XU == mmin);
         if (PERC)
         {
            if (mf1 == 0.0)
               mf1 = p->mflop[imf];
            fprintf(fpout, "&%.4f", p->mflop[imf]/mf1);
            
         }
         else
            fprintf(fpout, "&%.2f", p->mflop[imf]);
      }
      fprintf(fpout, "\n");
      mus[nmu++] = minp->XU;
      KillAll@up@(rt)Nodes(minp);
      if (!bp)
         break;
      mmin = FindMinIntIn@up@(rt)Q(bp, &bp->XU)->XU;
      minp = Yank@up@(rt)NodesByIntVal(&bp, &bp->XU, mmin);
      assert(minp);
      minp = Sort@up@(rt)QByIntVal(minp, &minp->YU);
   }
   while (minp);
/*
 * If we printed percentages, give the base MFLOP rate
 */
   if (PERC)
      fprintf(fpout, "\n\nBASE MFLOP&%.2f\n", mf1);

/*
 * Print names of all routs as error check on grabbing the right kernels
 */
   fprintf(fpout, "\n\n\n\n\n\nNAME MATRIX:\n");
   fprintf(fpout, "&&XU/YU");
   for (j=0; j < nnu; j++)
      fprintf(fpout, "&%d", nus[j]);
   fprintf(fpout, "\n");
   for (i=0; i < nmu; i++)
   {
      fprintf(fpout, "&&%d", mus[i]);
      for (j=0; j < nnu; j++)
         fprintf(fpout, "&%s", names[i*nnu+j]);
      fprintf(fpout, "\n");
   }

   j = nmu * nnu;
   for (i=0; i < j; i++)
      free(names[j]);
   free(names);
   free(mus);
}

void Dump2CSV
(
   FILE *fpout,         /* file to print to */
   ATL_@(rt)node_t *kb     /* pointer to kernel queue */
)
/*
 * Simply dumps all kp to CSV format, with all parameters present in
 * columns (col label is routine name)
 */
{
   ATL_@(rt)node_t *kp;
   fprintf(fpout, "&&OOCL1&OOCL2&OOC&inL2&inL1\n");
   fprintf(fpout, "&NAME&MFLOP&MFLOP&MFLOP&MFLOP&MFLOP&MU&NU&CacheElts\n");
   for (kp=kb; kp; kp = kp->next)
   {
      fprintf(fpout, "&%s&%.2f&%.2f&%.2f&%.2f&%.2f&%.2f&%d&%d&%d\n",
              kp->rout, kp->mflop[0], kp->mflop[1], kp->mflop[2], kp->mflop[3],
              kp->mflop[4], kp->mflop[5], kp->XU, kp->YU, kp->CacheElts);
   }
}

void Dump2RowI
(
   FILE *fpout,                 /* file to print to */
   ATL_@(rt)node_t *kb,         /* pointer to kernel queue */
   int ioff,                    /* offset of int param to put on rows */
   int imf,                     /* which mflop index to dump */
   int PERC                     /* dump percentages rather than mflop? */
)
/*
 * Simply dumps all kb to a single row with only the integer para ioff varying
 */
{
   double mfbase;
   ATL_@(rt)node_t *kp;
   int *ip;
   char *cp;

   if (PERC)
   {
      mfbase = kb->mflop[imf];
      assert(mfbase > 0.0);
      fprintf(fpout, "BASE MFLOP=%e\n\n", mfbase);
   }
/*
 * Print headers of int value of ioff
 */
   fprintf(fpout, "IVAL (%d):&", ioff);
   for (kp=kb; kp; kp = kp->next)
   {
      ip = (int*)(((char*)kp)+ioff);
      fprintf(fpout, "&%d", *ip);
   }
/*
 * Print selected mflop values
 */
   fprintf(fpout, "\nmflop[%d]:&", imf);
   for (kp=kb; kp; kp = kp->next)
   {
      if (PERC)
         fprintf(fpout, "&%.4f", kp->mflop[imf]/mfbase);
      else
         fprintf(fpout, "&%.2f", kp->mflop[imf]);
   }
}

void PrintUsage(char *name, int ierr, char *flag)
{
   if (ierr > 0)
      fprintf(stderr, "Bad argument #%d: '%s'\n",
              ierr, flag ? flag : "Not enough arguments");
   else if (ierr < 0)
      fprintf(stderr, "ERROR: %s\n", flag);
   fprintf(stderr, "USAGE: %s [flags]:\n", name);
   fprintf(stderr, "   -m #: [0] mflop entry to use\n");
   fprintf(stderr, 
           "   -p #: [0] nonzero -- convert mflops to %% of first case\n");
   fprintf(stderr, 
      "   -D 0/1/2 [field [field]]: [0] control output CSV file:)\n");
   fprintf(stderr, "      0: straight dump along rows of all kernels\n");
   fprintf(stderr, 
      "      1 [field]: [1 YU]: put all kerns with same YU along row\n");
   fprintf(stderr, 
      "      1 [field [field]]: [2 YU XU]: 2-D matrix, YU along rows\n");

   fprintf(stderr, "      Right now, the only fields accepted or XU & YU\n");
   fprintf(stderr, "-F field val : delete all kernels where field != val\n");
   fprintf(stderr, 
   "   -k # : [0] # of kernels to skip to get to first kernel of interest\n");
   fprintf(stderr, "   -s # : [1] stride between kernels of interest\n");
   fprintf(stderr, "   -n # : [0] # of kernels of interest\n");
   fprintf(stderr, "   -i <file> : [stdin] input file (output from timer)\n");
   fprintf(stderr, "   -o <file> : [tmp.csv] output file (CSV format)\n");
   exit(ierr ? ierr : -1);
}

int Name2Offset(char *name)
{
   ATL_@(rt)node_t kp;
   int off = -1;
   if (!strcmp(name, "XU") || !strcmp(name, "MU"))
      off = (int)(((char*)(&kp.XU)) - ((char*)&kp));
   else if (!strcmp(name, "YU") || !strcmp(name, "NU"))
      off = (int)(((char*)(&kp.YU)) - ((char*)&kp));
   else if (!strcmp(name, "ID"))
      off = (int)(((char*)(&kp.ID)) - ((char*)&kp));
   return(off);
}

ATL_@(rt)node_t *GetFlags
(
   int nargs, char **args,
   int *off1,   /* byte offset in structure to X axis dimension */
   int *off2,   /* byte offset in structure to Y axis dimension */
   int *imf,    /* mflop entry to use */
   int *perc,   /* non-zero : translate MFLOP to percentage of 1st case */
   FILE **FPOUT /* output file pointer */
)
/*
 * RETURNS: list of kernels read in from file, with any filtering applied
 */
{
   FILE *fpin=stdin;
   ATL_@(rt)node_t *kb=NULL, *kp, *kn=NULL;
   ATL_sidnode_t *wp, *wb=NULL;
   int i, k, j, iskip=0, stride=1, off;

   *perc = 0;
   *FPOUT = stdout;
   *off1 = *off2 = -1;
//   *off1 = Name2Offset("YU");
//   *off2 = Name2Offset("XU");
   *imf = 0;

   for (i=1; i < nargs; i++)
   {
      if (args[i][0] != '-')
         PrintUsage(args[0], i, args[i]);
      switch(args[i][1])
      {
      case 'D' : /* -D 1/2 field [field] */
         if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
         j = atoi(args[i]);
         if (j == 0)
         {
            *off1 = *off2 = -1;
            break;
         }
         if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
         *off1 = Name2Offset(args[i]);
         assert(*off1 >= 0);
         if (j > 1)
         {
            if (++i >= nargs)
               PrintUsage(args[0], i-1, NULL);
            *off2 = Name2Offset(args[i]);
            assert(*off2 >= 0);
         }
         break;
      case 'F' : /* -F field val */
         if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
         wp = ATL_NewSIDNode();
         wp->str = DupString(args[i]);
         if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
         wp->i = atoi(args[i]);
         wp->next = wb;
         wb = wp;
         break;
      case 'p' : /* -p # */
         if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
         *perc = atoi(args[i]);
         break;
      case 'm' : /* -n # */
         if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
         *imf = atoi(args[i]);
         break;
      case 'n' : /* -n # */
         if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
         iskip = atoi(args[i]);
         assert(iskip >= 0);
         break;
      case 's' : /* -s # */
         if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
         stride = atoi(args[i]);
         assert(stride >= 0);
         break;
      case 'i' : /* -i <infile> */
         if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
         kb = Read@up@(rt)File(args[i]);
         assert(kb);
         break;
      case 'o' : /* -o <outfile> */
         if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
         *FPOUT = fopen(args[i], "w");
         assert(*FPOUT);
         break;
      default:
         PrintUsage(args[0], i, args[i]);
      }
   }
   assert(kb);
/*
 * Weed out initial skip & strided kernels from kb
 */
   for (i=0; i < iskip && kb; i++)
      kb = Kill@up@(rt)Node(kb);
   if (stride > 1 && kb)
   {
      kp = CloneStridedR1Queue(kb, stride);
      KillAll@up@(rt)Nodes(kb);
      kb = kp;
   }
/*
 * Weed out any kernels excluded by -F
 */
   if (wb)
   {
      for (wp=wb; wp && kb; wp = wp->next)
      {
         off = Name2Offset(wp->str);
         kp = FindIntValIn@up@(rt)Q(kb, ((char*)kb)+off, wp->i);
         if (kp)
         {
            kb = Remove@up@(rt)NodeFromQ(kb, kp);
            kp->next = kn;
            kn = kp;
         }
      }
      if (kb)
         KillAll@up@(rt)Nodes(kb);
      kb = kn;
   }
   assert(kb);
   return(kb);
}

int main(int nargs, char **args)
{
   ATL_@(rt)node_t *kb, *kp;
   FILE *fpout;
   int off1, off2, imf, PERC;

   kb = GetFlags(nargs, args, &off1, &off2, &imf, &PERC, &fpout);
   if (off1 < 0 && off2 < 0)
      Dump2CSV(fpout, kb);
   else if (off2 < 0) /* dump 1-D stuff to rows wt only off1 varying */
      Dump2RowI(fpout, kb, off1, imf, PERC);
   else /* if (off1 == Name2Offset("YU") && off2 == Name2Offset("XU")) */
      PrintMUxNU_CSV(fpout, kb, imf, PERC);

   KillAll@up@(rt)Nodes(kb);
   if (fpout != stdout && fpout != stderr)
      fclose(fpout);

   return(0);
}
@ROUT tvecjoin
@extract -b @(topd)/cw.inc lang=C -def cwdate 2014
#include "atlas_tvec.h"

void PrintUsage(char *name, char *arg, int i)
{
   fprintf(stderr, "Joins multiple vectors so they form a contiguous range.\n");
   fprintf(stderr, "Range vectors should not overlap.\n\n");
   if (i > 0)
      fprintf(stderr, "BAD ARG '%s' ON %dth FLAG\n", arg, i);
   fprintf(stderr, "USAGE: %s <flags> ; flags include:\n", name);
   fprintf(stderr, "   -i <file> : (stdin) file wt vecs to combine\n");
   fprintf(stderr, "   -o <file>  : (stdout) file for joined vecs\n");
   fprintf(stderr, "   -J # <rngv1> <joinv1> ... <rngv#> <joinV#>\n");
   fprintf(stderr, 
      "      Vectors are joined into the first -J pair (rangv1 joinv1)\n");
   fprintf(stderr, 
           "      The -J flag may be repeated as many times as necessary.\n");
   exit (i ? i : -1);
}

typedef struct ATL_tvjoin ATL_tvjoin_t;
struct ATL_tvjoin
{
   int N;
   char **rangvs, **joinvs;
   ATL_tvjoin_t *next;
};

ATL_tvjoin_t *ATL_tvj_new(int N)
{
   ATL_tvjoin_t *tp;
   tp = malloc(sizeof(ATL_tvjoin_t));
   assert(tp);
   tp->N = N;
   tp->rangvs = calloc(N+N,sizeof(char *));
   assert(tp->rangvs);
   tp->joinvs = tp->rangvs + N;
   return(tp);
}

ATL_tvjoin_t *ATL_tvj_kill(ATL_tvjoin_t *tp)
{
   ATL_tvjoin_t *tn=NULL;
   if (tp)
   {
      tn = tp->next;
      free(tp->rangvs);  /* these pt to commandline args, so don't free them */
      free(tp);
   }
   return(tn);
}

ATL_tvjoin_t *GetFlags   /* RETURNS: queue of joinings to perform */
(
   int nargs,
   char **args,
   FILE **fpin,         /* input stream */
   FILE **fpout         /* output stream */
)
{
   char **na=NULL, *sp;
   int i, j, n;
   FILE *fp;
   ATL_tvjoin_t *jb=NULL, *jp, *jr;

   *fpin = stdin;
   *fpout = stdout;
   for (i=1; i < nargs; i++)
   {
      if (args[i][0] != '-')
         PrintUsage(args[0], "no '-' preceeding flag!", i);
      switch(args[i][1])
      {
      case 'i':    /* -i[1,2] <file> */
         if (++i >= nargs)
            PrintUsage(args[0], "out of flags in -i ", i-1);
         fp = fopen(args[i], "r");
         assert(fp);
         *fpin = fp;
         break;
      case 'o':    /* -o <file> */
         if (++i >= nargs)
            PrintUsage(args[0], "out of flags in -i ", i-1);
         fp = fopen(args[i], "w");
         assert(fp);
         *fpout = fp;
         break;
      case 'J':  /* -J # <rngv1> <joinv1> ... <rngv#> <joinV#> */
         if (++i >= nargs)
            PrintUsage(args[0], "out of flags in -J ", i-1);
         n = atoi(args[i]);
         assert(n > 1 && n < 2048);
         jp = ATL_tvj_new(n);
         for (j=0; j < n; j++)
         {
            if (++i >= nargs)
               PrintUsage(args[0], "out of flags in -J ", i-1);
            jp->rangvs[j] = args[i];
            if (++i >= nargs)
               PrintUsage(args[0], "out of flags in -J ", i-1);
            jp->joinvs[j] = args[i];
         }
         jp->next = jb;
         jb = jp;
         break;
      default :
         PrintUsage(args[0], args[i], i);
      }                                         /* end switch over flags */
   }                                            /* end for over flags */
   if (!jb)
   {
      fprintf(stderr, "You must join something!\n");
      exit(-1);
   }
/*
 * Reverse the join order so its in commandline order!
 */
   jr = NULL;
   while (jb)
   {
      jp = jb->next;
      jb->next = jr;
      jr = jb;
      jb = jp;
   }
   return(jr);
}

int main(int nargs, char **args)
{
   char *cmnt;
   FILE *fpin, *fpout;
   ATL_tvjoin_t *jb, *jp;
   ATL_tvec_t *tbu, *tjb=NULL;
   int i;

   jb = GetFlags(nargs, args, &fpin, &fpout);
/*
 * Read in all unjoined vectors
 */
   tbu = ATL_ReadTvecFile(fpin, &cmnt, &i);
/*
 * Loop over all joined vectors that need to be created
 */
   for (jp=jb; jp; jp = jp->next)
   {
      ATL_tvec_t *tb, *tp, *rb, *td, *rd;
      const int N = jp->N;
      int j;
/*
 *    Yank join & dup range pointers from unjoined pool
 */
      rb = ATL_DupNamedVecsFromList(N, jp->rangvs, tbu, 1);
      assert(ATL_CountTvecsInList(rb) == N);
      tb = ATL_PullNamedVecsFromList(N, jp->joinvs, &tbu);
      assert(ATL_CountTvecsInList(tb) == N);
/*
 *    Yank destination registers from list
 */
      rd = ATL_PullNamedVecsFromList(1, jp->rangvs, &rb);
      td = ATL_PullNamedVecsFromList(1, jp->joinvs, &tb);
      assert(rd->pre == 'i');
/*
 *    Loop over source registers, and join them into destination registers
 */
      for (j=1; j < N; j++)
      {
         ATL_tvec_t *ts, *rs;  /* source vectors */
/*
 *       Find source range & tvec, then join them into destination
 */
         rs = ATL_FindTvecByName(rb, jp->rangvs[j]);
         ts = ATL_FindTvecByName(tb, jp->joinvs[j]);
         tp = ATL_CombineTheseVecsUsingInts(rd, rs, td, ts);
         ATL_KillThisTvec(td);
         td = tp;
         tp = ATL_CombineTheseVecsUsingInts(rd, rs, rd, rs);
         ATL_KillThisTvec(rd);
         rd = tp;
      }
/*
 *    Kill the original tvecs that have been joined
 */
      ATL_KillAllTvecs(tb);
      ATL_KillAllTvecs(rb);
/*
 *    Add joined tvecs to queue.  Range vectors may be repeated, so don't
 *    add if it is already there.
 */
      td->next = tjb;
      tjb = td;
      tp = ATL_FindTvecByName(tjb, rd->name);
      if (!tp)
      {
         rd->next = tjb;
         tjb = rd;
      }
      else /* check that usage is correct */
      {
         int *ip = rd->vp, *ip2=tp->vp;
         const int N = rd->N;
         assert(tp->N == N && tp->nrep == rd->nrep && tp->pre == rd->pre);
         for (i=0; i < N; i++)
            assert(ip[i] == ip2[i]);
      }
   }

   ATL_KillAllTvecs(tbu);
   ATL_WriteTvecFile(fpout, cmnt, ATL_CountTvecsInList(tjb), tjb);
   ATL_KillAllTvecs(tjb);
   free(cmnt);
   while (jb)
      jb = ATL_tvj_kill(jb);
   if (fpout != stdout && fpout != stderr)
      fclose(fpout);
   return(0);
}
@ROUT tvecselect
@extract -b @(topd)/cw.inc lang=C -def cwdate 2014 -def cwauth "Md Rakib Hasan" -def contrib "R. Clint Whaley"
#include "atlas_tvec.h"

void PrintUsage(char *name, char *arg, int i)
{
   fprintf(stderr, "This routine takes tvecs in one or more files and outputs"
                   " the \nselected ones, while optionally renaming them.\n");
   if (i > 0)
      fprintf(stderr, "BAD ARG '%s' ON %dth FLAG\n", arg, i);
   fprintf(stderr, "USAGE: %s <flags> ; flags include:\n", name);
   fprintf(stderr, "   -i <file> : (stdin) file with vecs to read.\n");
   fprintf(stderr, "   -o <file> : (stdout) output file for all tvecs.\n");
   fprintf(stderr, "   -# <#> : # of tvec files concatonated in the input; "
                   "MUST be specified\n");
   fprintf(stderr, "      before -S or -R.\n");
   fprintf(stderr, "   -S # <nam1> ... <nam#> : vectors to select from 1st "
                   "file.\n      Repeat for later files.\n");
   fprintf(stderr, "   -R # <oldnam1> <newnam1> ... <oldnam#> <newnam#> : "
                   "name pairs from 1st file.\n      Used with -S. Repeat flag "
                   "for later files.\n");
   fprintf(stderr, "   -s # <nam1> ... <nam#> : vectors to select from all "
                   "files.\n      Can be used once. Cannot be used with "
                   "-S or -R.\n");
   fprintf(stderr, "   -r # <oldnam1> <newnam1> ... <oldnam#> <newnam#> : "
                   " rename list\n      for all files. "
                   "Can be used once and only with -s.\n");
   fprintf(stderr, "\n");
   exit (i ? i : -1);
}

void GetFlags
(
   int nargs, 
   char **args, 
   int *Nfiles,         /* # of tvec files in input stream */
   char *Mode,          /* S or s for -S/R or -s/r */
   int **Nselect,       /* array holding # of tvecs to select for each file */
   char ****sel_names,  /* array holding names of tvecs for each file */
   int **Nrename,       /* array holding # of tvecs to rename for each file */
   char ****ren_names,  /* array holding names of tvecs for each file */
   FILE **fpin,         /* input stream */
   FILE **fpout         /* output stream */
)
{
   int i, j, k, n;
   int si, ri;

   si = ri = 0;
   *fpin = stdin;
   *fpout = stdout;
   *Nfiles = 1;
   *Mode = 0; /* initially no mode */
   *Nselect = malloc(*Nfiles * sizeof(int));
   *sel_names = malloc(*Nfiles * sizeof(char**));
   *Nrename = malloc(*Nfiles * sizeof(int));
   *ren_names = malloc(*Nfiles * sizeof(char**));
   for (k=0; k<*Nfiles; k++)
   {
      (*Nselect)[k] = 0;
      (*Nrename)[k] = 0;
   }
   for (i=1; i<nargs; i++)
   {
      if (args[i][0] != '-')
         PrintUsage(args[0], "no '-' preceeding flag!", i);

      switch(args[i][1])
      {
         case '#':   /* -# <# files> */
            if (++i >= nargs)
               PrintUsage(args[0], "out of flags in -# ", i-1);
            *Nfiles = atoi(args[i]);
            free(*Nselect);
            free(*sel_names);
            free(*Nrename);
            free(*ren_names);
            *Nselect = malloc(*Nfiles * sizeof(int));
            *sel_names = malloc(*Nfiles * sizeof(char**));
            *Nrename = malloc(*Nfiles * sizeof(int));
            *ren_names = malloc(*Nfiles * sizeof(char**));
            for (k=0; k<*Nfiles; k++)
            {
               (*Nselect)[k] = 0;
               (*Nrename)[k] = 0;
            }
            break;
         case 'i':   /* -i <file> */
            if (++i >= nargs)
               PrintUsage(args[0], "out of flags in -i ", i-1);
            *fpin = fopen(args[i], "r");
            assert(*fpin);
            break;
         case 'o':   /* -o <file> */
            if (++i >= nargs)
               PrintUsage(args[0], "out of flags in -o ", i-1);
            *fpout = fopen(args[i], "w");
            assert(*fpout);
            break;
         case 'S':   /* -S # <nam1> ... <nam#> */
         case 's':   /* -s # <nam1> ... <nam#> */
            if (++i >= nargs)
               PrintUsage(args[0], "out of flags in -S/s ", i-1);
            assert(*Mode == 0 || *Mode == args[i-1][1]);
            *Mode = args[i-1][1];
            if (*Mode == 's') assert(si == 0);
            (*Nselect)[si] = n = atoi(args[i]);
            if (n > 0)
            {
               (*sel_names)[si] = malloc(n * sizeof(char*));
               assert((*sel_names)[si]);
               for (j=0; j<n; j++)
               {
                  if (++i >= nargs)
                     PrintUsage(args[0], "out of flags in -S/s ", i-1);
                  (*sel_names)[si][j] = args[i];
               }
            }
            si++;
            break;
         case 'R':   /* -R # <oldnam1> <newnam1> ... <oldnam#> <newnam#> */
         case 'r':   /* -r # <oldnam1> <newnam1> ... <oldnam#> <newnam#> */
            if (++i >= nargs)
               PrintUsage(args[0], "out of flags in -R/r ", i-1);
            assert(*Mode == 0 || *Mode == (args[i-1][1]+1));
@skip            *Mode = (char)((int)(args[i-1][1])+1); /* mode s/S */
            *Mode = args[i-1][1]+1;  /* mode s/S */
            if (*Mode == 'r') assert(ri == 0);
            (*Nrename)[ri] = n = atoi(args[i]);
            if (n > 0)
            {
               (*ren_names)[ri] = malloc(n*2 * sizeof(char*));
               assert((*ren_names)[ri]);
               for (j=0; j<n*2; j++) /* pair of names */
               {
                  if (++i >= nargs)
                     PrintUsage(args[0], "out of flags in -R/r ", i-1);
                  (*ren_names)[ri][j] = args[i];
               }
            }
            ri++;
            break;
         default:
            PrintUsage(args[0], args[i], i);
      }
   }
}

int main(int nargs, char **args)
{
   FILE *fpin, *fpout;
   int Nf, *Ns=NULL, *Nr=NULL;
   int i, j, n, ci;
   char mode = 0;
   char ***snames=NULL, ***rnames=NULL, *cmnt0=NULL, *cmnt=NULL;
   ATL_tvec_t *tp, *np, *nb, *ft;

   GetFlags(nargs, args, &Nf, &mode, &Ns, &snames, &Nr, &rnames, &fpin, &fpout);

   if (Ns[0] > 0)
   {
      tp = ATL_ReadTvecFile(fpin, &cmnt0, &n);
      /* select the tvecs */
      nb = ATL_PullNamedVecsFromListWithDups(Ns[0], snames[0], &tp);
      assert(nb);
      if (tp) ATL_KillAllTvecs(tp);
      /* rename the tvecs */
      for (j=0; j<Nr[0]; j++)
      {
         tp = ATL_FindTvecByName(nb, rnames[0][j*2]);
         if (tp) strcpy(tp->name, rnames[0][j*2+1]);
      }
   }
   for (i=1; i<Nf; i++)
   {
      ci = ((mode == 'S') ? i : 0);
      if (Ns[ci] > 0)
      {
         tp = ATL_ReadTvecFile(fpin, &cmnt, &n);
         np = ATL_PullNamedVecsFromListWithDups(Ns[ci], snames[ci], &tp);
         if (!np) break;
         if (tp) ATL_KillAllTvecs(tp);
         if (cmnt)
         {
            free(cmnt);
            cmnt = NULL;
         }

         /* rename the tvecs */
         for (j=0; j<Nr[ci]; j++)
         {
            tp = ATL_FindTvecByName(np, rnames[ci][j*2]);
            if (tp) strcpy(tp->name, rnames[ci][j*2+1]);
         }

         /* append the current list to the base list */
         ATL_FindLastTvecInList(nb)->next = np;
      }
   }
   if (mode == 's') /* -s/r mode, remove duplicates */
   {
      for (j=0; j<Nr[0]; j++)
      {
         for (i=0; i<Ns[0]; i++)
         {
            if (!strcmp(rnames[0][j*2], snames[0][i]))
            {
               strcpy(snames[0][i], rnames[0][j*2+1]);
            }
         }
      }
      tp = ATL_PullNamedVecsFromList(Ns[0], snames[0], &nb);
      ATL_KillAllTvecs(nb);
      nb = tp;
   }

   /*
    * Write them out, and we are done
    */
   ATL_WriteTvecFile(fpout, cmnt0, ATL_CountTvecsInList(nb), nb);
   ATL_KillAllTvecs(nb);

   /* free the args */
   for (i=0; i<Nf; i++)
   {
      if (Ns && Ns[i] > 0) free(snames[i]);
      if (Nr && Nr[i] > 0) free(rnames[i]);
   }
   if (cmnt0) free(cmnt0);
   if (snames) free(snames);
   if (rnames) free(rnames);
   if (Ns) free(Ns);
   if (Nr) free(Nr);
   if (fpin != stdin) fclose(fpin);
   if (fpout != NULL && fpout != stdout && fpout != stderr)
      fclose(fpout);
   return(0);
}
@ROUT mergetvecs
#include "atlas_tvec.h"

void PrintUsage(char *name, char *arg, int i)
{
   fprintf(stderr, 
"This routine takes two vector files, and combines a list of named vectors\n");
   fprintf(stderr, 
"so they form one contiguous range.  The range vector is specified by -r,\n");
   fprintf(stderr, "and these vectors should not overlap.\n\n");
   if (i > 0)
      fprintf(stderr, "BAD ARG '%s' ON %dth FLAG\n", arg, i);
   fprintf(stderr, "USAGE: %s <flags> ; flags include:\n", name);
   fprintf(stderr, "   -i1 <file> : (stdin) 1st file wt vecs to combine\n");
   fprintf(stderr, "   -i2 <file> : (stdin) 2nd file wt vecs to combine\n");
   fprintf(stderr, "   -o <file>  : (stdout) file for combined vecs\n");
   fprintf(stderr, 
           "   -r <name>  : (\"N\"): range vector to sort combine on\n");
   fprintf(stderr, "   -C # <nam1> ... <nam#>: vectors to combine\n");
   exit (i ? i : -1);
}

char **GetFlags         /* RETURNS: array of names to combine */
(
   int nargs,
   char **args,
   FILE **fp1,          /* 1st input stream */
   FILE **fp2,          /* 2nd input stream */
   FILE **fpout,        /* output stream */
   char **rngv,         /* name of range/sort vector */
   int *Nc              /* # of vectors to combine using rngv */
)
{
   char **na=NULL, *sp;
   int i, j, n;
   FILE *fp;

   *fp1 = *fp2 = stdin;
   *fpout = stdout;
   *rngv = "N";
   *Nc = 0;
   for (i=1; i < nargs; i++)
   {
      if (args[i][0] != '-')
         PrintUsage(args[0], "no '-' preceeding flag!", i);
      switch(args[i][1])
      {
      case 'i':    /* -i[1,2] <file> */
         if (++i >= nargs)
            PrintUsage(args[0], "out of flags in -i ", i-1);
         fp = fopen(args[i], "r");
         assert(fp);
         if (args[i-1][2] == '1')
            *fp1 = fp;
         else
            *fp2 = fp;
         break;
      case 'o':    /* -o <file> */
         if (++i >= nargs)
            PrintUsage(args[0], "out of flags in -i ", i-1);
         fp = fopen(args[i], "w");
         assert(fp);
         *fpout = fp;
         break;
      case 'r':    /* -r <name> */
         if (++i >= nargs)
            PrintUsage(args[0], "out of flags in -i ", i-1);
         *rngv = args[i];
         break;
      case 'C':    /* -C # <nam1> ... <nam#> */
         if (++i >= nargs)
            PrintUsage(args[0], "out of flags in -C ", i-1);
         *Nc = n = atoi(args[i]);
         assert(n > 0 && n < 2048);
         na = malloc(sizeof(char*)*n);
         assert(na);
         for (j=0; j < n; j++)
         {
            if (++i >= nargs)
               PrintUsage(args[0], "out of flags in -C ", i-1);
            na[j] = args[i];
         }
         break;
      default :
         PrintUsage(args[0], args[i], i);
      }                                         /* end switch over flags */
   }                                            /* end for over flags */
   if (*Nc == 0)
   {
      *Nc = 1;
      na = malloc(sizeof(char*));
      assert(na);
      na[0] = *rngv;
   }
//   assert(*fp1 != *fp2);
   return(na);
}

int main(int nargs, char **args)
{
   FILE *fp1, *fp2, *fpout;
   char *rngv, **combarr, *cmnt;
   int N, Nc, i, j, RNGINC=0, nrep;
   ATL_tvec_t *t1, *t2, *tp, *p1, *p2, *r1, *r2, *cb, *cp;

   combarr = GetFlags(nargs, args, &fp1, &fp2, &fpout, &rngv, &Nc);
/*
 * Grab only the vectors to be combined, in order user has specified from
 * both lists, and free all unused vectors 
 */
   t1 = ATL_ReadTvecFile(fp1, &cmnt, &N);
   if (fp1 != stdin)
      fclose(fp1);
   tp = ATL_PullNamedVecsFromList(Nc, combarr, &t1);
   if (t1)
      ATL_KillAllTvecs(t1);
   t1 = tp;

   t2 = ATL_ReadTvecFile(fp2, &cmnt, &j);
   if (fp2 != stdin)
      fclose(fp2);
   tp = ATL_PullNamedVecsFromList(Nc, combarr, &t2);
   if (t2)
      ATL_KillAllTvecs(t2);
   t2 = tp;
/*
 * Find range vectors
 */
   r1 = ATL_FindTvecByName(t1, rngv);
   r2 = ATL_FindTvecByName(t2, rngv);
   assert(r1->pre == 'i' && r2->pre == 'i');  /* restriction to fix later */
/*
 * Combine all vectors and build new list cb
 */
   for (cb=NULL, p1=t1, p2=t2; p1 && p2; p1 = p1->next, p2 = p2->next)
   {
      ATL_tvec_t *p;

      assert(!strcmp(p1->name, p2->name));
      assert(p1->nrep == p2->nrep);
      p = ATL_CombineTheseVecsUsingInts(r1, r2, p1, p2);
      if (cb)
         cp->next = p;
      else
         cb = p;
      cp = p;
   }
   ATL_KillAllTvecs(t1);
   ATL_KillAllTvecs(t2);
   ATL_WriteTvecFile(fpout, cmnt, Nc, cb);
   ATL_KillAllTvecs(cb);
   free(cmnt);
#if 0
   printf("rngv = '%s'\n", rngv);
   for (i=0; i < Nc; i++)
      printf("nam[%d] = '%s'\n", i, combarr[i]);
#endif
   if (fpout != stdout && fpout != stderr)
      fclose(fpout);
   return(0);
}
@ROUT reducetvec tvecreduce
#include "atlas_tvec.h"

void PrintUsage(char *name, char *arg, int i)
{
   fprintf(stderr, "This routine gets rid of the repititions within vectors\n");
   fprintf(stderr, "Vectors are *reduced* or *combined*:\n");
   fprintf(stderr, "   reduced vectors should be repeats (eg 100, 100)\n");
   fprintf(stderr, 
      "   combined vectors are combined and produce several vectors:\n");
   fprintf(stderr, "      v_1...v_<nreps>, v_avg, v_min, v_max\n");
   fprintf(stderr, 
   "   any vector not collapsed or combined does not appear in the output\n");
   if (i > 0)
      fprintf(stderr, "BAD ARG '%s' ON %dth FLAG\n", arg, i);
   fprintf(stderr, "USAGE: %s <flags> ; flags include:\n", name);
   fprintf(stderr, "   -i <file> : (stdin) file with vecs to reduce\n");
   fprintf(stderr, "   -o <file>  : (stdout) file for reduced vecs\n");
   fprintf(stderr, "   -R # <nam1> ... <nam#>: vectors to collapse\n");
   fprintf(stderr, "   -C # <nam1> ... <nam#>: vectors to combine\n");
@beginskip
   fprintf(stderr, "   -c [+,<,>,a] : specify how to combine repeated elts:\n");
   fprintf(stderr, "      +: repeated vector replaced by average of repeats\n");
   fprintf(stderr, "      <: repeated vector replaced by minimum of repeats\n");
   fprintf(stderr, "      >: repeated vector replaced by maximum of repeats\n");
@endskip
   exit (i ? i : -1);
}

char **GetFlags         /* RETURNS: array of names to combine/reduce */
(
   int nargs,
   char **args,
   int *ncomb,          /* # of vecs to combine, stored in 1st ncomb elts */
   int *nred,           /* # of vecs to reduce, stored at end of ret array */
   FILE **fpin,         /* input stream */
   FILE **fpout         /* output stream */
)
{
   char **vc=NULL, **vr=NULL, **vv, *sp;
   int i, j, n, nc=0, nr=0;
   FILE *fp;

   *fpin = stdin;
   *fpout = stdout;
   for (i=1; i < nargs; i++)
   {
      if (args[i][0] != '-')
         PrintUsage(args[0], "no '-' preceeding flag!", i);
      switch(args[i][1])
      {
      case 'i':    /* -i <file> */
         if (++i >= nargs)
            PrintUsage(args[0], "out of flags in -i ", i-1);
         *fpin = fopen(args[i], "r");
         assert(*fpin);
         break;
      case 'o':    /* -o <file> */
         if (++i >= nargs)
            PrintUsage(args[0], "out of flags in -i ", i-1);
         fp = fopen(args[i], "w");
         assert(fp);
         *fpout = fp;
         break;
   @whiledef lt c r
      case '@up@(lt)':    /* -@up@(lt) # <nam1> ... <nam#> */
         if (++i >= nargs)
            PrintUsage(args[0], "out of flags in -@up@(lt) ", i-1);
         n@(lt) = atoi(args[i]);
         assert(n@(lt) > 0 && n@(lt) < 2048);
         v@(lt) = malloc(sizeof(char*)*n@(lt));
         assert(v@(lt));
         for (j=0; j < n@(lt); j++)
         {
            if (++i >= nargs)
               PrintUsage(args[0], "out of flags in -@up@(lt) ", i-1);
            v@(lt)[j] = args[i];
         }
         break;
    @endwhile
      default :
         PrintUsage(args[0], args[i], i);
      }                                         /* end switch over flags */
   }                                            /* end for over flags */
   if (!nr && !nc)
   {
      nr = nc = 1;
      vv = malloc(2*sizeof(char*));
      assert(vv);
      vv[0] = "MFLOP";
      vv[1] = "N";
   }
   else
   {
      n = nr + nc;
      vv = malloc(n*sizeof(char*));
      assert(vv);
      for (i=0; i < nc; i++)
         vv[i] = vc[i];
      if (vc)
         free(vc);
      if (vr)
      {
         for (; i < n; i++)
            vv[i] = vr[i-nc];
         free(vr);
      }
   }
   *ncomb = nc;
   *nred = nr;
   return(vv);
}

int main(int nargs, char **args)
{
   FILE *fpin, *fpout;
   char **redarr, **combarr, *cmnt;
   int N, Nc, Nr, i, j, RNGINC=0;
   ATL_tvec_t *tr, *tc, *tp, *np, *nb=NULL;

   combarr = GetFlags(nargs, args, &Nc, &Nr, &fpin, &fpout);
   redarr = combarr + Nc;

/*
 * Grab only the vectors to be combined and reduced (in the order the user 
 * has specified) from list, and free all unused vectors 
 */

   np = ATL_ReadTvecFile(fpin, &cmnt, &N);
   if (fpin != stdin)
      fclose(fpin);
@ROUT tvecreduce
   tc = ATL_PullNamedVecsFromListWithDups(Nc, combarr, &np);
   tr = ATL_PullNamedVecsFromListWithDups(Nr, redarr, &np);
@ROUT reducetvec
   tc = ATL_PullNamedVecsFromList(Nc, combarr, &np);
   tr = ATL_PullNamedVecsFromList(Nr, redarr, &np);
@ROUT reducetvec tvecreduce
   if (np)
      ATL_KillAllTvecs(np);
/*
 * Create all individual run vectors, add to new list
 */
   for (tp=tc; tp; tp = tp->next)
   {
      ATL_tvec_t *p;
      p = ATL_SplitRepsTvec(tp);
      ATL_FindLastTvecInList(p)->next = nb;
      nb = p;
   }
/*
 * Create all statistic vectors in queue
 */
   for (tp=tc; tp; tp = tp->next)
   {
      ATL_tvec_t *p;
      if (tp->pre != 'd')
      {
         fprintf(stderr, "%s is %c!\n", tp->name, tp->pre);
         assert(tp->pre == 'd');         /* relax this later if needed */
      }
      p = ATL_GetStatTvecsDOUBLE(tp);
      p->next->next->next = nb;
      nb = p;
   }
   ATL_KillAllTvecs(tc);
/*
 * Now reduce any repeated vectors
 */
   for (tp=tr; tp; tp = tp->next)
   {
      ATL_tvec_t *p;
      int i;
      char *sp;

      p = ATL_GetRep1Tvec(tp, 0);
      p->next = nb;
      nb = p;

      for (sp=p->name,i=0; sp[i]; i++);   /* go to end of name */
      for (i--; sp[i] != '_'; i--);       /* backup to last _ */
      sp[i] = '\0';                       /* git rid of bad _0 */
   }
   ATL_KillAllTvecs(tr);

   ATL_WriteTvecFile(fpout, cmnt, ATL_CountTvecsInList(nb), nb);
   ATL_KillAllTvecs(nb);
   free(cmnt);
   free(combarr);
   if (fpout != stdout && fpout != stderr)
      fclose(fpout);
   return(0);
}
@ROUT tvec2plp tvecprint
#include "atlas_tvec.h"

void PrintUsage(char *name, char *arg, int i)
{
   fprintf(stderr, 
"This routine takes tvecs and spits them out in platicus prefab data format\n");
   if (i > 0)
      fprintf(stderr, "BAD ARG '%s' ON %dth FLAG\n", arg, i);
   fprintf(stderr, "USAGE: %s <flags> ; flags include:\n", name);
   fprintf(stderr, "   -i <file> : (stdin) file with vecs to reduce\n");
   fprintf(stderr, "   -o <file>  : (stdout) platicus prefab data file out\n");
   fprintf(stderr, "   -C # <nam1> ... <nam#>: vectors (in order) to use\n");
   fprintf(stderr, "   -h 1/0: do (don't) print headers\n");
   exit (i ? i : -1);
}

char **GetFlags         /* RETURNS: array of names to put into output file */
(
   int nargs,
   char **args,
   int *Nv,             /* # of vecs to put in output file */
   int *head,           /* print headers or not */
   FILE **fpin,         /* input stream */
   FILE **fpout         /* output stream */
)
{
   char **vs=NULL, *sp;
   int i, j, n=0;
   FILE *fp;

   *fpin = stdin;
   *fpout = stdout;
   *head = 0;
   for (i=1; i < nargs; i++)
   {
      if (args[i][0] != '-')
         PrintUsage(args[0], "no '-' preceeding flag!", i);
      switch(args[i][1])
      {
      case 'i':    /* -i <file> */
         if (++i >= nargs)
            PrintUsage(args[0], "out of flags in -i ", i-1);
         *fpin = fopen(args[i], "r");
         assert(*fpin);
         break;
      case 'o':    /* -o <file> */
         if (++i >= nargs)
            PrintUsage(args[0], "out of flags in -i ", i-1);
         fp = fopen(args[i], "w");
         if (!fp)
         {
            fprintf(stderr, "unable to open file %s!\n", args[i]);
            assert(fp);
         }
         *fpout = fp;
         break;
      case 'h':    /* -h 0/1 */
         if (++i >= nargs)
            PrintUsage(args[0], "out of flags in -h ", i-1);
         *head = atoi(args[i]);
         break;
      case 'C':    /* -C # <nam1> ... <nam#> */
         if (++i >= nargs)
            PrintUsage(args[0], "out of flags in -C ", i-1);
         n = atoi(args[i]);
         assert(n > 0 && n < 2048);
         vs = malloc(sizeof(char*)*n);
         assert(vs);
         for (j=0; j < n; j++)
         {
            if (++i >= nargs)
               PrintUsage(args[0], "out of flags in -C ", i-1);
            vs[j] = args[i];
         }
         break;
      default :
         PrintUsage(args[0], args[i], i);
      }                                         /* end switch over flags */
   }                                            /* end for over flags */
   if (!vs)
   {
      n = 2;
      vs = malloc(2*sizeof(char*));
      assert(vs);
      vs[0] = "MFLOP";
      vs[1] = "N";
   }
   *Nv = n;
   return(vs);
}

int main(int nargs, char **args)
{
   FILE *fpin, *fpout;
   char **vnams, *cmnt;
   int N, i, j, RNGINC=0, head;
   ATL_tvec_t *tp, *np, *nb=NULL;

   vnams = GetFlags(nargs, args, &N, &head, &fpin, &fpout);

/*
 * Grab only the vectors to be output (in the order the user has specified)
 * from list, and free all unused vectors
 */

   tp = ATL_ReadTvecFile(fpin, &cmnt, &i);
   if (fpin != stdin)
      fclose(fpin);
   free(cmnt);
   nb = ATL_PullNamedVecsFromList(N, vnams, &tp);
   free(vnams);
   if (tp)
      ATL_KillAllTvecs(tp);
/*
 * Print them out, and we are done
 */
   ATL_PrintTvecsInRow(fpout, nb, "\t", head);
   ATL_KillAllTvecs(nb);
   if (fpout != stdout && fpout != stderr)
      fclose(fpout);
   return(0);
}
@ROUT tvecratio
#include "atlas_tvec.h"

void PrintUsage(char *name, char *arg, int i)
{
   fprintf(stderr,
"This routine takes tvecs in two tvec files and produces their ratio\n");
   if (i > 0)
      fprintf(stderr, "BAD ARG '%s' ON %dth FLAG\n", arg, i);
   fprintf(stderr, "USAGE: %s <flags> ; flags include:\n", name);
   fprintf(stderr, "   -i <file> : (stdin) file with two concatonated tvecs files to read\n");
   fprintf(stderr, "   -o <file>  : (stdout) output file for all tvecs\n");
   fprintf(stderr, "   -R # <nam1> ... <nam#>: vectors coming from both files "
           "to use for ratio\n");
   fprintf(stderr, 
      "   -c # <nam1> ... <nam#>: vectors where we take first instance only\n");
   exit (i ? i : -1);
}

char **GetFlags         /* RETURNS: array of single/repeated names */
(
   int nargs,
   char **args,
   int *none,           /* # of vecs where we take only 1st definition */
   int *nmul,           /* # of vecs where we take all vectors of that name */
   FILE **fpin,         /* input stream */
   FILE **fpout         /* output stream */
)
{
   char **vc=NULL, **vr=NULL, **vv, *sp;
   int i, j, n, nc=0, nr=0;
   FILE *fp;

   *fpin = stdin;
   *fpout = stdout;
   for (i=1; i < nargs; i++)
   {
      if (args[i][0] != '-')
         PrintUsage(args[0], "no '-' preceeding flag!", i);
      switch(args[i][1])
      {
      case 'i':    /* -i <file> */
         if (++i >= nargs)
            PrintUsage(args[0], "out of flags in -i ", i-1);
         *fpin = fopen(args[i], "r");
         assert(*fpin);
         break;
      case 'o':    /* -o <file> */
         if (++i >= nargs)
            PrintUsage(args[0], "out of flags in -i ", i-1);
         fp = fopen(args[i], "w");
         assert(fp);
         *fpout = fp;
         break;
      case 'c':    /* -R # <nam1> ... <nam#> */
         if (++i >= nargs)
            PrintUsage(args[0], "out of flags in -c ", i-1);
         nr = atoi(args[i]);
         assert(nr > 0 && nr < 2048);
         vr = malloc(sizeof(char*)*nr);
         assert(vr);
         for (j=0; j < nr; j++)
         {
            if (++i >= nargs)
               PrintUsage(args[0], "out of flags in -c ", i-1);
            vr[j] = args[i];
         }
         break;
      case 'R':    /* -R # <nam1> ... <nam#> */
         if (++i >= nargs)
            PrintUsage(args[0], "out of flags in -S ", i-1);
         nc = atoi(args[i]);
         assert(nc > 0 && nc < 2048);
         vc = malloc(sizeof(char*)*nc);
         assert(vc);
         for (j=0; j < nc; j++)
         {
            if (++i >= nargs)
               PrintUsage(args[0], "out of flags in -S ", i-1);
            vc[j] = args[i];
         }
         break;
      default :
         PrintUsage(args[0], args[i], i);
      }                                         /* end switch over flags */
   }                                            /* end for over flags */
   if (!nr && !nc)
      exit(0);   /* no output at all! */

   n = nr + nc;
   vv = malloc(n*sizeof(char*));
   assert(vv);
   for (i=0; i < nr; i++)
      vv[i] = vr[i];
   if (vr)
      free(vr);
   if (vc)
   {
      for (; i < n; i++)
         vv[i] = vc[i-nr];
      free(vc);
   }
   *none = nr;
   *nmul = nc;
   return(vv);
}

int main(int nargs, char **args)
{
   FILE *fpin, *fpout;
   char **vnams1, **vnamsr, *cmnt, *cm;
   int Nf, N1, Nr, N, i, j, RNGINC=0;
   ATL_tvec_t *ib1, *ib2, *op, *ob=NULL;

   vnams1 = GetFlags(nargs, args, &N1, &Nr, &fpin, &fpout);
   vnamsr = vnams1 + N1;
/*
 * Read in both file's tvecs as input
 */
   ib1 = ATL_ReadTvecFile(fpin, &cmnt, &N);
   ib2 = ATL_ReadTvecFile(fpin, &cm, &N);
   free(cm);
   if (fpin != stdin)
      fclose(fpin);
/*
 * Grab one copy of all -c tvecs from input, and place on output queue
 */
   for (i=0; i < N1; i++)
   {
      if (!(op=ATL_PullNamedVecsFromList(1, vnams1+i, &ib1)))
      {
          assert((op=ATL_PullNamedVecsFromList(1, vnams1+i, &ib2)));
      }
      op->next = ob;
      ob = op;
   }
/*
 * Grab one copy of all -R tvecs from each file, and create a ratio tvec
 * that is put on queue
 */
   for (i=0; i < Nr; i++)
   {
      ATL_tvec_t *op2;
      int N;
      double *d1, *d2;

      op = ATL_PullNamedVecsFromList(1, vnamsr+i, &ib1);
      op2 = ATL_PullNamedVecsFromList(1, vnamsr+i, &ib2);
      assert(op);
      assert(op2);
      assert(op->pre == 'd' && op2->pre == 'd');
      assert(op->nrep = op2->nrep);
      assert(op->N == op->N);
      N = op->N;
      d1 = op->vp;
      d2 = op2->vp;
      for (j=0; j < N; j++)
      {
         d1[j] /= d2[j];
      }
      ATL_KillThisTvec(op2);
      op->next = ob;
      ob = op;
   }
   ATL_KillAllTvecs(ib1);
   ATL_KillAllTvecs(ib2);
/*
 * Get list in order from input: -c tvecs -S tvecs
 */
   ob = ATL_ReverseTvecList(ob);
/*
 * Write them out, and we are done
 */
   ATL_WriteTvecFile(fpout, cmnt, ATL_CountTvecsInList(ob), ob);
   ATL_KillAllTvecs(ob);
   free(cmnt);
   free(vnams1);
   if (fpout != stdout && fpout != stderr)
      fclose(fpout);
   return(0);
}
@ROUT tveccat
#include "atlas_tvec.h"

void PrintUsage(char *name, char *arg, int i)
{
   fprintf(stderr,
"This routine takes tvecs in multiple files and puts then into one\n");
   if (i > 0)
      fprintf(stderr, "BAD ARG '%s' ON %dth FLAG\n", arg, i);
   fprintf(stderr, "USAGE: %s <flags> ; flags include:\n", name);
   fprintf(stderr, "   -i <file> : (stdin) file with vecs to read\n");
   fprintf(stderr, "   -o <file>  : (stdout) output file for all tvecs\n");
   fprintf(stderr, 
      "   -C # <nam1> ... <nam#>: vectors coming from all files\n");
   fprintf(stderr, 
      "   -c # <nam1> ... <nam#>: vectors where we take first instance only\n");
   fprintf(stderr, 
      "   -f # <nam1> ... <nam#>: vectors where we take only\n"
      "                           the first instance from each file\n");
   fprintf(stderr, "   -s 0/1 : don't/do suffix tvecs wt file number\n");
   fprintf(stderr, 
           "   -S # suf1 ... sufN: suffix first N files' tvecs wt "
           "provided strings.\n"
           "                       Overrides -s for first N files.\n");
   exit (i ? i : -1);
}

ATL_tvstrq_t *GetFlags         /* RETURNS: queue of file suffixes to use */
(
   int nargs,
   char **args,
   int *SUFFCNT,
   ATL_tvstrq_t **namr, /* names to take all repeats (-C) */
   ATL_tvstrq_t **nam1, /* names to take first instance only (-c) */
   ATL_tvstrq_t **namf, /* names to take first instance frm each file (-f) */
   FILE **fpin,         /* input stream */
   FILE **fpout         /* output stream */
)
{
   char **vc=NULL, **vr=NULL, *vf, **vv, *sp;
   int i, j, n, nc=0, nr=0;
   FILE *fp;
   ATL_tvstrq_t *qp, *suffb=NULL;

   *SUFFCNT=0;
   *namr = *nam1 = *namf = NULL;
   *fpin = stdin;
   *fpout = stdout;
   for (i=1; i < nargs; i++)
   {
      int SKIP=0;
      ATL_tvstrq_t **qb=NULL;
      if (args[i][0] != '-')
         PrintUsage(args[0], "no '-' preceeding flag!", i);
      switch(args[i][1])
      {
      case 'i':    /* -i <file> */
         if (++i >= nargs)
            PrintUsage(args[0], "out of flags in -i ", i-1);
         *fpin = fopen(args[i], "r");
         assert(*fpin);
         break;
      case 'o':    /* -o <file> */
         if (++i >= nargs)
            PrintUsage(args[0], "out of flags in -i ", i-1);
         fp = fopen(args[i], "w");
         assert(fp);
         *fpout = fp;
         break;
      case 'C':    /* -c # <nam1> ... <nam#> */
         qb = namr;
      case 'f':    /* -f # <nam1> ... <nam#> */
         if (!qb)
            qb = namf;
      case 'c':    /* -c # <nam1> ... <nam#> */
         if (!qb)
            qb = nam1;
         if (++i >= nargs)
            PrintUsage(args[0], "out of flags in -c ", i-1);
         if (isdigit(args[i][0]))
            nr = atoi(args[i]);
         else
            SKIP = nr = 1;
         assert(nr > 0 && nr < 2048);
         for (j=0; j < nr; j++)
         {
            if (!SKIP)
            {
               if (++i >= nargs)
                  PrintUsage(args[0], "out of flags in -c ", i-1);
               SKIP=0;
            }
            qp = ATL_GetStrNode(args[i]);
            qp->next = *qb;
            *qb = qp;
         }
         break;
      case 'S':    /* -S # <suff1> ... <suff#> */
         if (++i >= nargs)
            PrintUsage(args[0], "out of flags in -c ", i-1);
         if (isdigit(args[i][0]))
            nr = atoi(args[i]);
         else
            SKIP = nr = 1;
         assert(nr > 0 && nr < 2048);
         for (j=0; j < nr; j++)
         {
            if (!SKIP)
            {
               if (++i >= nargs)
                  PrintUsage(args[0], "out of flags in -c ", i-1);
               SKIP=0;
            }
            qp = ATL_GetStrNode(args[i]);
            qp->next = suffb;
            suffb = qp;
         }
         break;
      case 's': /* -s [0,1] */
         if (++i >= nargs)
            PrintUsage(args[0], "out of flags in -s ", i-1);
         *SUFFCNT = (args[i][0] != '0');
         break;
      default :
         PrintUsage(args[0], args[i], i);
      }                                         /* end switch over flags */
   }                                            /* end for over flags */
   if (suffb)
      suffb = ATL_ReverseStrQ(suffb);
   if (*namf)
      *namf = ATL_ReverseStrQ(*namf);
   if (*nam1)
      *nam1 = ATL_ReverseStrQ(*nam1);
   if (*namr)
      *namr = ATL_ReverseStrQ(*namr);

   return(suffb);
}

int main(int nargs, char **args)
{
   FILE *fpin, *fpout;
   char *cmnt;
   ATL_tvec_t *tb;
   ATL_tvstrq_t *sfb, *nrb, *n1b, *nfb;
   int SUFFCNT;
   ATL_tvec_t *ob=NULL;

   sfb = GetFlags(nargs, args, &SUFFCNT, &nrb, &n1b, &nfb, &fpin, &fpout);
/*
 * If I'm not selecting tvecs, then I'll be outputing all tvecs
 */
   if (!nrb && !n1b && !nfb)
   {
      int nF=0, i;
      while ( (tb = ATL_ReadTvecFile(fpin, &cmnt, &i)) )
      {
         nF++;
         free(cmnt);
         if (sfb)
         {
            ATL_SuffixTvecNames(tb, sfb->sp);
            sfb = ATL_KillStrNode(sfb);
         }
         else if (SUFFCNT)
         {
            char suff[32];
            sprintf(suff, "_%d", nF);
            ATL_SuffixTvecNames(tb, suff);
         }
         if (ob)
            ATL_FindLastTvecInList(ob)->next = tb;
         else
            ob = tb;
      }
   }
   else  /* I'm pulling out only selected tvecs */
   {
      char **vnams1=NULL, **vnamsR=NULL, *cmnt;
      int nR=0, nf1=0, nF=0, i;
      ATL_tvec_t *b=NULL;

      if (nrb)
         vnamsR = ATL_StrQ2Arr(nrb, &nR);
      if (nfb)
         vnams1 = ATL_StrQ2Arr(nfb, &nf1);
      while ( (tb = ATL_ReadTvecFile(fpin, &cmnt, &i)) )
      {
         ATL_tvec_t *pp, *b=NULL;  /* pull ptr */
         free(cmnt);
         nF++;
/*
 *       See if there are any 1-time vectors to take 
 */
         if (n1b)
         {
/*
 *          Handle cases that match on n1b
 */
            while ( (pp = ATL_FindTvecByName(tb, n1b->sp)) )
            {
               tb = ATL_RemoveTvecFromList(tb, pp);
               pp->next = NULL;
               if (b)
                  ATL_FindLastTvecInList(b)->next = pp;
               else
                  b = pp;
               n1b = ATL_KillStrNode(n1b);
               if (!n1b)
                  break;
            }
/*
 *          Process non-base 1-time tvecs; removing them does not affect n1b
 */
            if (n1b)
            {
               ATL_tvstrq_t *qp=n1b->next;
               while (qp)
               {
                  pp = ATL_FindTvecByName(tb, qp->sp);
                  if (pp)
                  {
                     tb = ATL_RemoveTvecFromList(tb, pp);
                     pp->next = NULL;
                     if (b)
                        ATL_FindLastTvecInList(b)->next = pp;
                     else
                        b = pp;
                     qp = ATL_KillStrNode(qp);
                  }
                  else    /* didn't find tvec I'm looking for */
                     qp = qp->next;
               }
            }    /* end n1b if */
         }       /* end of if for 1-time tvec removal */
         if (nR)
         {
            pp = ATL_PullNamedVecsFromListWithDups(nR, vnamsR, &tb);
            if (b)
               ATL_FindLastTvecInList(b)->next = pp;
            else
               b = pp;
         }
         if (nf1)
         {
            pp = ATL_PullNamedVecsFromList(nf1, vnams1, &tb);
            if (b)
               ATL_FindLastTvecInList(b)->next = pp;
            else
               b = pp;
         }
/*
 *       At this point, we have removed all the required tvecs from the
 *       original base, and b has the complete tvec queue from this file
 *       in the correct order.  We now want to perform any required renaming,
 *       and then add it to the global output tvec list (ob)
 */
         if (sfb)  /* we've got user-provided suffixes to use */
         {
            ATL_SuffixTvecNames(b, sfb->sp);
            sfb = ATL_KillStrNode(sfb);
         }
         else if (SUFFCNT)  /* we need to add _file# suffix */
         {
            char suff[32];
            sprintf(suff, "_%d", nF);
            ATL_SuffixTvecNames(b, suff);
         }
         if (ob)
            ATL_FindLastTvecInList(ob)->next = b;
         else
            ob = b;
         if (tb)
            ATL_KillAllTvecs(tb);  /* get rid of this files leftover tvecs */
      } /* end while on reading in tvec files */
      if (vnams1)
      {
         for (i=0; i < nf1; i++)
            if (vnams1[i])
               free(vnams1[i]);
         free(vnams1);
      }
      if (vnamsR)
      {
         for (i=0; i < nR; i++)
            if (vnamsR[i])
               free(vnamsR[i]);
         free(vnamsR);
      }
   }    /* end if on selected or all tvecs */
   if (ob)
      ATL_WriteTvecFile(fpout, "file created by tveccat", 
                        ATL_CountTvecsInList(ob), ob);
   if (fpin != stdin)
      fclose(fpin);
   ATL_KillAllTvecs(ob);
   if (fpout != stdout && fpout != stderr)
      fclose(fpout);
   return(0);
}
@ROUT cattvecs
#include "atlas_tvec.h"

void PrintUsage(char *name, char *arg, int i)
{
   fprintf(stderr,
"This routine takes tvecs in multiple files and puts then into one\n");
   if (i > 0)
      fprintf(stderr, "BAD ARG '%s' ON %dth FLAG\n", arg, i);
   fprintf(stderr, "USAGE: %s <flags> ; flags include:\n", name);
   fprintf(stderr, "   -i <file> : (stdin) file with vecs to read\n");
   fprintf(stderr, 
           "   -# <#> : (2) # of tvec files concatonated in input file\n");
   fprintf(stderr, "   -o <file>  : (stdout) output file for all tvecs\n");
   fprintf(stderr, 
      "   -C # <nam1> ... <nam#>: vectors coming from all files\n");
   fprintf(stderr, 
      "   -c # <nam1> ... <nam#>: vectors where we take first instance only\n");
   exit (i ? i : -1);
}

char **GetFlags         /* RETURNS: array of single/repeated names */
(
   int nargs,
   char **args,
   int *Nfiles,         /* # of tvec files in input stream */
   int *none,           /* # of vecs where we take only 1st definition */
   int *nmul,           /* # of vecs where we take all vectors of that name */
   FILE **fpin,         /* input stream */
   FILE **fpout         /* output stream */
)
{
   char **vc=NULL, **vr=NULL, **vv, *sp;
   int i, j, n, nc=0, nr=0;
   FILE *fp;

   *fpin = stdin;
   *fpout = stdout;
   *Nfiles = 2;
   for (i=1; i < nargs; i++)
   {
      if (args[i][0] != '-')
         PrintUsage(args[0], "no '-' preceeding flag!", i);
      switch(args[i][1])
      {
      case '#':    /* -# <# files> */
         if (++i >= nargs)
            PrintUsage(args[0], "out of flags in -i ", i-1);
         *Nfiles = atoi(args[i]);
         break;
      case 'i':    /* -i <file> */
         if (++i >= nargs)
            PrintUsage(args[0], "out of flags in -i ", i-1);
         *fpin = fopen(args[i], "r");
         assert(*fpin);
         break;
      case 'o':    /* -o <file> */
         if (++i >= nargs)
            PrintUsage(args[0], "out of flags in -i ", i-1);
         fp = fopen(args[i], "w");
         assert(fp);
         *fpout = fp;
         break;
      case 'c':    /* -R # <nam1> ... <nam#> */
         if (++i >= nargs)
            PrintUsage(args[0], "out of flags in -c ", i-1);
         nr = atoi(args[i]);
         assert(nr > 0 && nr < 2048);
         vr = malloc(sizeof(char*)*nr);
         assert(vr);
         for (j=0; j < nr; j++)
         {
            if (++i >= nargs)
               PrintUsage(args[0], "out of flags in -c ", i-1);
            vr[j] = args[i];
         }
         break;
      case 'C':    /* -C # <nam1> ... <nam#> */
         if (++i >= nargs)
            PrintUsage(args[0], "out of flags in -C ", i-1);
         nc = atoi(args[i]);
         assert(nc > 0 && nc < 2048);
         vc = malloc(sizeof(char*)*nc);
         assert(vc);
         for (j=0; j < nc; j++)
         {
            if (++i >= nargs)
               PrintUsage(args[0], "out of flags in -C ", i-1);
            vc[j] = args[i];
         }
         break;
      default :
         PrintUsage(args[0], args[i], i);
      }                                         /* end switch over flags */
   }                                            /* end for over flags */
   if (!nr && !nc)
   {
      nr = nc = 1;
      vv = malloc(2*sizeof(char*));
      assert(vv);
      vv[0] = "N";
      vv[1] = "MFLOP";
   }
   else
   {
      n = nr + nc;
      vv = malloc(n*sizeof(char*));
      assert(vv);
      for (i=0; i < nr; i++)
         vv[i] = vr[i];
      if (vr)
         free(vr);
      if (vc)
      {
         for (; i < n; i++)
            vv[i] = vc[i-nr];
         free(vc);
      }
   }
   *none = nr;
   *nmul = nc;
   return(vv);
}

int main(int nargs, char **args)
{
   FILE *fpin, *fpout;
   char **vnams1, **vnamsr, *cmnt;
   int Nf, N1, Nr, N, i, j, RNGINC=0;
   ATL_tvec_t *tp, *np, *nb=NULL, *rb=NULL;

   vnams1 = GetFlags(nargs, args, &Nf, &N1, &Nr, &fpin, &fpout);
   vnamsr = vnams1 + N1;

/*
 * Grab one copy of all vectors from output
 */
   tp = ATL_ReadTvecFile(fpin, &cmnt, &N);
   N = N1 + Nr;
   nb = ATL_PullNamedVecsFromList(N, vnams1, &tp);
   assert(nb);
   if (tp)
      ATL_KillAllTvecs(tp);
/* 
 * Get repeated vectors from all files
 */
   for (i=1; i < Nf; i++)
   {
      char suff[16];

      tp = ATL_ReadTvecFile(fpin, &cmnt, &N);
      np = ATL_PullNamedVecsFromList(Nr, vnamsr, &tp);
      if (!np) 
         break;
      sprintf(suff, "_%d", i);
      ATL_SuffixTvecNames(np, suff);
      ATL_FindLastTvecInList(nb)->next = np;
      if (tp)
         ATL_KillAllTvecs(tp);
   }
   if (fpin != stdin)
      fclose(fpin);
/*
 * Write them out, and we are done
 */
   ATL_WriteTvecFile(fpout, cmnt, ATL_CountTvecsInList(nb), nb);
   ATL_KillAllTvecs(nb);
   free(cmnt);
   free(vnams1);
   if (fpout != stdout && fpout != stderr)
      fclose(fpout);
   return(0);
}
@ROUT perctvecs tvecscale
#include "atlas_tvec.h"

void PrintUsage(char *name, char *arg, int i)
{
   fprintf(stderr, 
           "This routine computes tvecs as percentages of a base tvec\n");
   fprintf(stderr, "   -P vectors are replaced by precentages of the -b vec\n");
   if (i > 0)
      fprintf(stderr, "BAD ARG '%s' ON %dth FLAG\n", arg, i);
   fprintf(stderr, "USAGE: %s <flags> ; flags include:\n", name);
   fprintf(stderr, "   -i <file> : (stdin) input file\n");
   fprintf(stderr, "   -o <file>  : (stdout) output file\n");
   fprintf(stderr, 
           "   -R # <nam1> ... <nam#>: vectors to scale\n");
   fprintf(stderr, "   -C # <nam1> ... <nam#>: vectors to keep unchanged\n");
   fprintf(stderr, "   -B <float> : scalar percentage base\n");
   fprintf(stderr, "   -b <nam> : vector to use as percentage base\n");
   fprintf(stderr, 
"   -m <mul> : multiplier for ratio (default 100.0 for %%; 1 for speedup)\n");
   exit (i ? i : -1);
}

char **GetFlags         /* RETURNS: array of names to combine/reduce */
(
   int nargs,
   char **args,
   int *nkeep,          /* # of vecs to keep unchanged stored at 1 of arr */
   int *nperc,          /* # of vecs to make %, stored at end of ret array */
   double *fdiv,        /* divisor for percentage */
   double *mul,         /* multiplier for ratio; set to 100.0 for % */
   FILE **fpin,         /* input stream */
   FILE **fpout         /* output stream */
)
{
   char **vc=NULL, **vr=NULL, **vv, *sp, *base="MFLOP_avg";
   int i, j, n, nk=0, nr=0;
   FILE *fp;

   *fdiv = 0.0;
   *mul = 100.0;
   *fpin = stdin;
   *fpout = stdout;
   for (i=1; i < nargs; i++)
   {
      if (args[i][0] != '-')
         PrintUsage(args[0], "no '-' preceeding flag!", i);
      switch(args[i][1])
      {
      case 'i':    /* -i <file> */
         if (++i >= nargs)
            PrintUsage(args[0], "out of flags in -i ", i-1);
         *fpin = fopen(args[i], "r");
         assert(*fpin);
         break;
      case 'o':    /* -o <file> */
         if (++i >= nargs)
            PrintUsage(args[0], "out of flags in -i ", i-1);
         fp = fopen(args[i], "w");
         assert(fp);
         *fpout = fp;
         break;
      case 'b':
         if (++i >= nargs)
            PrintUsage(args[0], "out of flags in -R ", i-1);
         *fdiv = 0.0;
         base = args[i];
         break;
      case 'm':
         if (++i >= nargs)
            PrintUsage(args[0], "out of flags in -m ", i-1);
         *mul = atof(args[i]);
         break;
      case 'B':
         if (++i >= nargs)
            PrintUsage(args[0], "out of flags in -m ", i-1);
         base = NULL;
         *fdiv = atof(args[i]);
         break;
      case 'R':    /* -R # <nam1> ... <nam#> */
         if (++i >= nargs)
            PrintUsage(args[0], "out of flags in -R ", i-1);
         nr = atoi(args[i]);
         assert(nr > 0 && nr < 2048);
         vr = malloc(sizeof(char*)*nr);
         assert(vr);
         for (j=0; j < nr; j++)
         {
            if (++i >= nargs)
               PrintUsage(args[0], "out of flags in -R ", i-1);
            vr[j] = args[i];
         }
         break;
      case 'C':    /* -C # <nam1> ... <nam#> */
         if (++i >= nargs)
            PrintUsage(args[0], "out of flags in -C ", i-1);
         nk = atoi(args[i]);
         assert(nk > 0 && nk < 2048);
         vc = malloc(sizeof(char*)*nk);
         assert(vc);
         for (j=0; j < nk; j++)
         {
            if (++i >= nargs)
               PrintUsage(args[0], "out of flags in -C ", i-1);
            vc[j] = args[i];
         }
         break;
      default :
         PrintUsage(args[0], args[i], i);
      }                                         /* end switch over flags */
   }                                            /* end for over flags */
   if (*fdiv != 0.0)
      assert(base == NULL);
   if (base)
     assert(*fdiv == 0.0);
   if (nr < 1)
   {
      fprintf(stderr, "Must reduce at least one vector to percentages!\n");
      exit(-1);
   }
   n = nr + nk + 1;
   vv = malloc(n*sizeof(char*));
   assert(vv);
   vv[0] = base;
   for (i=0; i < nk; i++)
      vv[i+1] = vc[i];
   if (vc)
      free(vc);
   if (vr)
   {
      for (; i < n-1; i++)
         vv[i+1] = vr[i-nk];
      free(vr);
   }
   *nkeep = nk;
   *nperc = nr;
   return(vv);
}

int main(int nargs, char **args)
{
   FILE *fpin, *fpout;
   char **redarr, **keeparr, *cmnt, *basev;
   int N, Nk, Nr, nrep, i;
   double mul, fdiv;
   ATL_tvec_t *tr, *tk, *tp, *tb, *np;

   keeparr = GetFlags(nargs, args, &Nk, &Nr, &fdiv, &mul, &fpin, &fpout);
   basev = keeparr[0];
   keeparr++;
   redarr = keeparr + Nk;

/*
 * Grab only the vectors to be scaled (tr) and kept (tk) (in the order the user
 * has specified) from list, and free all unused vectors
 */
   np = ATL_ReadTvecFile(fpin, &cmnt, &i);
   if (fpin != stdin)
      fclose(fpin);
   if (basev)
@ROUT tvecscale
      tb = ATL_DupNamedVecsFromList(1, &basev, np, 1);
@ROUT perctvecs
      tb = ATL_PullNamedVecsFromList(1, &basev, &np);
@ROUT perctvecs tvecscale
   else
      tb = NULL;
   tr = ATL_PullNamedVecsFromList(Nr, redarr, &np);
   tk = ATL_PullNamedVecsFromList(Nk, keeparr, &np);
   if (np)
      ATL_KillAllTvecs(np);
/*
 * Create all statistic vectors in queue
 */
   if (tb)
   {
      for (tp=tr; tp; tp = tp->next)
      {
         double *dp=tp->vp, *db=tb->vp;
         assert(tp->pre == 'd');
         for (N=tp->N,i=0; i < N; i++)
            dp[i] = (dp[i] / db[i])*mul;
      }
   }
   else
   {
      for (tp=tr; tp; tp = tp->next)
      {
         double *dp=tp->vp;
         assert(tp->pre == 'd');
         for (N=tp->N,i=0; i < N; i++)
            dp[i] = (dp[i] / fdiv)*mul;
      }
   }
/*
 * Link lists back up, and write to file
 */
@ROUT tvecscale
   if (tk)
      ATL_FindLastTvecInList(tk)->next = tr;
   else
      tk = tr;
   if (tk)
   {
      ATL_WriteTvecFile(fpout, cmnt, ATL_CountTvecsInList(tk), tk);
      ATL_KillAllTvecs(tk);
   }
@ROUT perctvecs
   ATL_FindLastTvecInList(tr)->next = tb;
   ATL_FindLastTvecInList(tk)->next = tr;
   ATL_WriteTvecFile(fpout, cmnt, ATL_CountTvecsInList(tk), tk);
   ATL_KillAllTvecs(tk);
@ROUT perctvecs tvecscale
   free(cmnt);
   free(--keeparr);
   if (fpout != stdout && fpout != stderr)
      fclose(fpout);
   return(0);
}
@ROUT tvecunify
#include "atlas_tvec.h"

void PrintUsage(char *name, char *arg, int i)
{
   fprintf(stderr, 
      "This routine combines all tvecs with duplicate names into one\n");
   fprintf(stderr, 
      "by simply stacking their entries together in the order they appear\n");
   fprintf(stderr, 
      "in the input (reverse order, if -r 1 is thrown)\n");

   if (i > 0)
      fprintf(stderr, "BAD ARG '%s' ON %dth FLAG\n", arg, i);
   fprintf(stderr, "USAGE: %s <flags> ; flags include:\n", name);
   fprintf(stderr, "   -i <file> : (stdin) input file\n");
   fprintf(stderr, "   -o <file> : (stdout) output file\n");
   fprintf(stderr, 
      "   -r 0/1    : don't / do reverse input order before stacking\n");
   exit (i ? i : -1);
}

int GetFlags         /* true if input should be reversed */
(
   int nargs,
   char **args,
   FILE **fpin,         /* input stream */
   FILE **fpout         /* output stream */
)
{
   int i, REV=0;
   FILE *fp;

   *fpin = stdin;
   *fpout = stdout;
   for (i=1; i < nargs; i++)
   {
      if (args[i][0] != '-')
         PrintUsage(args[0], "no '-' preceeding flag!", i);
      switch(args[i][1])
      {
      case 'i':    /* -i <file> */
         if (++i >= nargs)
            PrintUsage(args[0], "out of flags in -i ", i-1);
         *fpin = fopen(args[i], "r");
         assert(*fpin);
         break;
      case 'o':    /* -o <file> */
         if (++i >= nargs)
            PrintUsage(args[0], "out of flags in -i ", i-1);
         fp = fopen(args[i], "w");
         assert(fp);
         *fpout = fp;
         break;
      case 'r': /* os <suffix> */
         if (++i >= nargs)
            PrintUsage(args[0], "out of flags in -r ", i-1);
         REV = atoi(args[i]);
         break;
      default :
         PrintUsage(args[0], args[i], i);
      }                                         /* end switch over flags */
   }                                            /* end for over flags */
   return(REV);
}

int main(int nargs, char **args)
{
   FILE *fpin, *fpout;
   char *cmnt;
   int N, rev;
   ATL_tvec_t *tp, *tb;

   rev = GetFlags(nargs, args, &fpin, &fpout);
/*
 * Read in all vectors in file
 */
   tb = ATL_ReadTvecFile(fpin, &cmnt, &N);
   if (fpin != stdin)
      fclose(fpin);
   if (tb)
   {
      if (rev)
         tb = ATL_ReverseTvecList(tb);
      for (tp=tb; tp->next; tp = tp->next)
      {
         ATL_tvec_t *tk;
         while((tk = ATL_FindTvecByName(tp->next, tp->name)))
         {
            ATL_AdhereTvec(tp, tk);
            ATL_RemoveTvecFromList(tp, tk);
            ATL_KillThisTvec(tk);
         }
         if (!tp->next)
            break;
      }
   }
/*
 * Write the remaining vectors out, and we're done
 */
   ATL_WriteTvecFile(fpout, cmnt, ATL_CountTvecsInList(tb), tb);
   ATL_KillAllTvecs(tb);
   if (fpout != stdout && fpout != stderr)
      fclose(fpout);
   if (cmnt)
      free(cmnt);
   return(0);
}
@ROUT renametvecs
#include "atlas_tvec.h"

void PrintUsage(char *name, char *arg, int i)
{
   fprintf(stderr, 
      "This routine renames tvecs given by -R; other vecs left alone\n");
   fprintf(stderr, 
      "If -s is used, all tvecs (incl -R) are suffixed\n");
   if (i > 0)
      fprintf(stderr, "BAD ARG '%s' ON %dth FLAG\n", arg, i);
   fprintf(stderr, "USAGE: %s <flags> ; flags include:\n", name);
   fprintf(stderr, "   -i <file> : (stdin) input file\n");
   fprintf(stderr, "   -o <file>  : (stdout) output file\n");
   fprintf(stderr, "   -s <suff> : append suffix to all names in file\n");
   fprintf(stderr, 
           "   -R # <nam1> <rep1>... <nam#> <rep#>: orig & new names\n");
   exit (i ? i : -1);
}

char **GetFlags         /* RETURNS: array of orig & new names */
(
   int nargs,
   char **args,
   int *nrname,         /* # of vecs to rename */
   char **suff,
   FILE **fpin,         /* input stream */
   FILE **fpout         /* output stream */
)
{
   char **vr=NULL, **vv, *sp;
   int i, j, n, nk=0, nr=0;
   FILE *fp;

   *fpin = stdin;
   *fpout = stdout;
   *suff = NULL;
   for (i=1; i < nargs; i++)
   {
      if (args[i][0] != '-')
         PrintUsage(args[0], "no '-' preceeding flag!", i);
      switch(args[i][1])
      {
      case 'i':    /* -i <file> */
         if (++i >= nargs)
            PrintUsage(args[0], "out of flags in -i ", i-1);
         *fpin = fopen(args[i], "r");
         assert(*fpin);
         break;
      case 'o':    /* -o <file> */
         if (++i >= nargs)
            PrintUsage(args[0], "out of flags in -i ", i-1);
         fp = fopen(args[i], "w");
         assert(fp);
         *fpout = fp;
         break;
      case 's': /* os <suffix> */
         if (++i >= nargs)
            PrintUsage(args[0], "out of flags in -s ", i-1);
         *suff = args[i];
         break;
      case 'R':    /* -R # <nam1> <rep1> ... <nam#> <rep#> */
         if (++i >= nargs)
            PrintUsage(args[0], "out of flags in -R ", i-1);
         nr = atoi(args[i]);
         assert(nr > 0 && nr < 2048);
         vr = malloc(sizeof(char*)*(nr+nr));
         assert(vr);
         for (j=0; j < nr; j++)
         {
            if (++i >= nargs)
               PrintUsage(args[0], "out of flags in -R ", i-1);
            vr[j] = args[i];
            if (++i >= nargs)
               PrintUsage(args[0], "out of flags in -R ", i-1);
            vr[j+nr] = args[i];
         }
         break;
      default :
         PrintUsage(args[0], args[i], i);
      }                                         /* end switch over flags */
   }                                            /* end for over flags */
   if (nr < 1 && *suff == NULL)
   {
      fprintf(stderr, "Must rename at least one vector!\n");
      exit(-1);
   }
   *nrname = nr;
   return(vr);
}

int main(int nargs, char **args)
{
   FILE *fpin, *fpout;
   char **renarr, *cmnt, *suff;
   int N, Nr, nrep, i, sL=0;
   ATL_tvec_t *tp, *tb;

   renarr = GetFlags(nargs, args, &Nr, &suff, &fpin, &fpout);
   if (suff)
      sL = strlen(suff);
/*
 * Read in all vectors in file
 */
   tb = ATL_ReadTvecFile(fpin, &cmnt, &N);
   if (fpin != stdin)
      fclose(fpin);
/*
 * Rename all targeted vectors
 */
   for (tp=tb; tp; tp = tp->next)
   {
      for (i=0; i < Nr; i++)
      {
         char *sp = renarr[i];
         if (sp && !strcmp(sp, tp->name))
         {
            int L;
            L = strlen(renarr[Nr+i])+1;
            if (tp->name)
               free(tp->name);
            tp->name = malloc(L);
            assert(tp->name);
            strcpy(tp->name, renarr[Nr+i]);
            renarr[i] = NULL;
         }
      }
      if (sL)
      {
         int L;
         char *sp = tp->name;
         L = strlen(sp);
         tp->name = malloc(L+sL+1);
         assert(tp->name);
         strcpy(tp->name, sp);
         strcpy(tp->name+L, suff);
         free(sp);
      }
   }
/*
 * Write the renamed vectors out, and we're done
 */
   ATL_WriteTvecFile(fpout, cmnt, N, tb);
   ATL_KillAllTvecs(tb);
   if (fpout != stdout && fpout != stderr)
      fclose(fpout);
   if (cmnt)
      free(cmnt);
   free(renarr);
   return(0);
}
@ROUT atl2tvecd
#include "atlas_tvec.h"

void PrintUsage(char *name, char *arg, int i)
{
   fprintf(stderr, 
      "This routine takes an arbitrary # of ATL output files separated by\n");
   fprintf(stderr, "label lines and creates one massive tvec file\n");
   fprintf(stderr, "Assumes bin/ runs separated by label lines.\n);
   if (i > 0)
      fprintf(stderr, "BAD ARG '%s' ON %dth FLAG\n", arg, i);
   fprintf(stderr, "USAGE: %s <flags> ; flags include:\n", name);
   fprintf(stderr, "   -i <file> : input file\n");
   fprintf(stderr, "   -o <file>  : (stdout) output file\n");
   fprintf(stderr, "   -E <endstr> : (*** END LABEL=<lab>)\n");
   fprintf(stderr, "   -T <tmpf1> <tmpf2> (/tmp/tvecd[1,2].txt)\n");
   exit (i ? i : -1);
}

char *GetFlags         /* RETURNS: relative path to tool directory */
(
   int nargs,
   char **args,
   char **endstr,       /* sentinal string indicating end of given run */
   FILE **fpin,         /* input stream */
   FILE **fpout         /* output stream */
   FILE **fpt1,         /* first temporary file */
   FILE **fpt2          /* STOPPED HERE HERE */
)
{
   char *path, *sp, *s;
   int i, j, n, nk=0, nr=0;
   FILE *fp;

   *fpin = NULL;
   *fpout = stdout;
   *endstr = NULL;
   for (i=1; i < nargs; i++)
   {
      if (args[i][0] != '-')
         PrintUsage(args[0], "no '-' preceeding flag!", i);
      switch(args[i][1])
      {
      case 'i':    /* -i <file> */
         if (++i >= nargs)
            PrintUsage(args[0], "out of flags in -i ", i-1);
         *fpin = fopen(args[i], "r");
         assert(*fpin);
         break;
      case 'o':    /* -o <file> */
         if (++i >= nargs)
            PrintUsage(args[0], "out of flags in -o ", i-1);
         fp = fopen(args[i], "w");
         assert(fp);
         *fpout = fp;
         break;
      case 'E':   /* -E <string>;  LABEL=<lab> is added*/
         if (++i >= nargs)
            PrintUsage(args[0], "out of flags in -E ", i-1);
         *endstr = args[i];
         break;
      default :
         PrintUsage(args[0], args[i], i);
      }                                         /* end switch over flags */
   }                                            /* end for over flags */
   if (*fpin == NULL)
   {
      fprintf(stderr, "Must provide intput filename!\n");
      exit(-1);
   }
/*
 * If not specified, take default end string of *** END, and suffix LABEL=
 */
   sp = *endstr;
   if (sp == NULL)
      *sp = "*** END";
   j = strlen(sp);
   s = malloc((j+8)*sizeof(char));
   assert(s);
   strcpy(s, sp);
   strcpy(s+j, " LABEL=");
   *endstr = s;
/* 
 * Get path to this tool to get relative path to tool directory
 */
   for (sp=args[0], i=0; sp[i]; i++);
   for (i--; i && sp[i] != '/'; i--);
   if (sp[i] != '/')  /* path is current dir */
   {
      path = malloc(3*sizeof(char));
      assert(path);
      path[0] = '.';
      path[1] = '/';
      path[2] = '\0';
   }
   else
   {
      path = malloc((i+1)*sizeof(char));
      assert(path);
      for (j=0; j <= i; j++)
         path[j] = sp[j];
      path[j] = '\0';
   }
   return(path);
}

int main(int nargs, char **args)
{
   FILE *fpin, *fpout;
   char *tpath, *cmnt, *endstr;
   int nrep, i, eL, nruns;
   int nruns;
   ATL_tvec_t *tp, *tb;
   char ln[4096];

   path = GetFlags(nargs, args, &endstr, &fpin, &fpout, &fpt1, &fpt2);
/*
 * Count the number of runs in the file
 */
   eL = strlen(endstr);
   nruns = 0;
   while(fgets(ln, 4096, fpin);
   {
      if (!strncmp(ln, endstr, eL))
         nruns++;
   }
   rewind(fpin);
/*
 * Read in all vectors in file
 */
   tb = ATL_ReadTvecFile(fpin, &cmnt, &N, &nrep);
   if (fpin != stdin)
      fclose(fpin);
/*
 * Rename all targeted vectors
 */
   for (tp=tb; tp; tp = tp->next)
   {
      for (i=0; i < Nr; i++)
      {
         char *sp = renarr[i];
         if (sp && !strcmp(sp, tp->name))
         {
            int L;
            L = strlen(renarr[Nr+i])+1;
            if (tp->name)
               free(tp->name);
            tp->name = malloc(L);
            assert(tp->name);
            strcpy(tp->name, renarr[Nr+i]);
            renarr[i] = NULL;
         }
      }
      if (sL)
      {
         int L;
         char *sp = tp->name;
         L = strlen(sp);
         tp->name = malloc (L+sL+1);
         assert(tp->name);
         strcpy(tp->name, sp);
         strcpy(tp->name+L, suff);
         free(sp);
      }
   }
/*
 * Write the renamed vectors out, and we're done
 */
   ATL_WriteTvecFile(fpout, cmnt, N, nrep, tb);
   ATL_KillAllTvecs(tb);
   if (fpout != stdout && fpout != stderr)
      fclose(fpout);
   if (cmnt)
      free(cmnt);
   free(renarr);
   return(0);
}
@ROUT repcomp.sh
#!/bin/sh
if [$# -lt 4 ]
   echo "USAGE: $0 timer rep1 rep2 \"list\" [-R rout] [-E EF]"
      echo "   timer: x[z,c,d,s][t,s]latime_[a,s]l_[a,s]b, x[z,c,d,s][t,s]l3time__[a,s]b"
   echo "   rout(la): getrf, potrf, geqrf (default potrf)"
   echo "   rout(l3): gemm, trsm, trmm, syrk, syr2k, hemm, herk, her2k"
   echo "   list    : # N1 ... N#, eg. \"4 200 2000 4000 8000\""
   echo "   -E EF   : extra flags to pass to timer (eg, -E \"-U 1 L\") (default none)"
   exit 1
fi
t1=tmp1.tv
t2=tmp2.tv
scr=$0
tmr=$1
rp1=$2
rp2=$3
lst=$4
shift 4
RT=potrf
EF=
while [ $# -gt 0 ]
do
   case $1 in
   -E)  EF="-E ${2}"
        shift 2
        ;;
   *)  echo "illegal flag ${1}"
       $scr
       exit 1
       ;;
   esac
done
./tvrun_lst.sh $tmr $RT "${lst}" $rp1 $EF -L r
./tvrun_lst.sh $tmr $RT "${lst}" $rp2 $EF -L r
$BINdir/tvecget -H 2 N MFLOP
@ROUT tpkget.sh tpkeval.sh
#!/bin/sh
pre=d
la=_al
bl=_ab
N0=0
efs=0
EF=
lrts="getrf potrf geqrf"
while [ $# -gt 0 ]
do
   case $1 in
   -p)  pre=$2
        shift 2
        ;;
   -B)  bl=$2
        shift 2
        ;;
   -L)  la=$2
        shift 2
        ;;
   -E)  EF=$2
        efs=`echo "${EF}" | ${chksum} | cut -d ' ' -f 1`
        shift 2
        ;;
   -N)  N0=$2
        NN=$3
        Ni=$4
        reps=$5
        shift 5
        ;;
   *)   echo "USAGE: $0 [-N N0 NN Ni reps] [-p <pre>] [-L <lapack>] -B [<blas>]"
        echo "   N params & reps are for timings > 6000, by default not done"
        echo "   lapack : _al or _sl"
        echo "   blas   : _ab or _sb"
        echo "   pre    : z, c, d or s"
        exit 1
        ;;
   esac
done
@ROUT tpkget.sh

for rt in ${lrts}
do
   echo "\nRunning 200-2000 ${rt} with 20 reps"
   ./tvrun_rng.sh x${pre}tlatime${la}${bl} ${rt} 200 2000 200 20 -L _${rt}
   echo "\nRunning 3000-6000 ${rt} with 4 reps"
   ./tvrun_rng.sh x${pre}tlatime${la}${bl} ${rt} 3000 6000 1000 4 -L _${rt}
   if [ $N0 -gt 6000 ]
   then
      echo "\nRunning ${N0}-${NN} ${rt} with ${reps} reps"
      ./tvrun_rng.sh x${pre}tlatime${la}${bl} ${rt} $N0 $NN $Ni $reps -L _${rt}
   fi
done
rt=gemm
echo "\nRunning 200-2000 ${rt} with 20 reps"
./tvrun_rng.sh x${pre}tl3time${bl} ${rt} 200 2000 200 20 -L _${rt}
echo "\nRunning 3000-6000 ${rt} with 4 reps"
./tvrun_rng.sh x${pre}tl3time${bl} ${rt} 3000 6000 1000 4 -L _${rt}
if [ $N0 -gt 6000 ]
then
   echo "\nRunning ${N0}-${NN} ${rt} with ${reps} reps"
   ./tvrun_rng.sh x${pre}tl3time${bl} ${rt} $N0 $NN $Ni $reps -L _${rt}
fi
@ROUT tpkeval.sh
BINdir=../bin
t0=ttpk0.tv
t1=ttpk1.tv
rm -f $t1 $t2
if [ $N0 -gt 6000 ]
then
   eb=res/t${pre}gemm${bl}_${N0}_${NN}_${Ni}.out 
   el="res/t${pre}getrf${la}${bl}_${N0}_${NN}_${Ni}.out \
      res/t${pre}potrf${la}${bl}_${N0}_${NN}_${Ni}.out \
      res/t${pre}geqrf${la}${bl}_${N0}_${NN}_${Ni}.out"
else
   eb=
   el=
fi
cat res/t${pre}gemm${bl}_200_2000_200_20_${efs}.out \
    res/t${pre}gemm${bl}_3000_6000_1000_4_${efs}.out ${eb} \
    | $BINdir/tvecget -H 2 N MFLOP \
    | $BINdir/tvecreduce -R 1 N_gemm -C 1 MFLOP_gemm -o $t0
cat res/t${pre}getrf${la}${bl}_200_2000_200_20_${efs}.out \
    res/t${pre}potrf${la}${bl}_200_2000_200_20_${efs}.out \
    res/t${pre}geqrf${la}${bl}_200_2000_200_20_${efs}.out \
    res/t${pre}getrf${la}${bl}_3000_6000_1000_4_${efs}.out \
    res/t${pre}potrf${la}${bl}_3000_6000_1000_4_${efs}.out \
    res/t${pre}geqrf${la}${bl}_3000_6000_1000_4_${efs}.out ${el} \
    | $BINdir/tvecget -H 2 N MFLOP \
    | $BINdir/tvecreduce -C 3 MFLOP_getrf MFLOP_potrf MFLOP_geqrf -o $t1 
cat $t0 $t1 | $BINdir/tvecselect -# 2 \
    -S 2 N_gemm MFLOP_gemm_avg -R 2 N_gemm N MFLOP_gemm_avg MFLOP_gemm \
    -S 3 MFLOP_getrf_avg MFLOP_potrf_avg MFLOP_geqrf_avg \
    -R 3 MFLOP_getrf_avg MFLOP_getrf MFLOP_potrf_avg MFLOP_potrf \
         MFLOP_geqrf_avg MFLOP_geqrf \
    | $BINdir/tvecunify -r 1 \
    | $BINdir/tvecscale -m 1.0 -b MFLOP_gemm -C 1 MFLOP_gemm \
    -R 3 MFLOP_getrf MFLOP_potrf MFLOP_geqrf \
    | $BINdir/tvecrename \
    -R 3 MFLOP_getrf GETRFpcMM MFLOP_potrf POTRFpcMM MFLOP_geqrf GEQRFpcMM \
    | $BINdir/tvecprint -h 1 \
    -C 5 N MFLOP_gemm GETRFpcMM POTRFpcMM GEQRFpcMM
@ROUT tvrun_rng.sh tvrun_lst.sh
#!/bin/sh
@ROUT tvrun_lst.sh
if [ $# -lt 4 ]
@ROUT tvrun_rng.sh
if [ $# -lt 6 ]
@ROUT tvrun_rng.sh tvrun_lst.sh
then
   echo "This shell script times square LAPACK or BLAS problems."
@ROUT tvrun_lst.sh
   echo "USAGE: $0 timer rout "list" reps [-L lab] [-E EF]"
@ROUT tvrun_rng.sh
   echo "USAGE: $0 timer rout N1 NN incN reps [-L lab] [-E EF]"
@ROUT tvrun_rng.sh tvrun_lst.sh
   echo "   timer: x[z,c,d,s][t,s]latime_[a,s]l_[a,s]b, x[z,c,d,s][t,s]l3time__[a,s]b"
   echo "   rout(la): getrf, potrf, geqrf"
   echo "   rout(l3): gemm, trsm, trmm, syrk, syr2k, hemm, herk, her2k"
@ROUT tvrun_lst.sh
   echo "   list    : # N1 ... N#, eg. \"4 200 2000 4000 8000\""
@ROUT tvrun_rng.sh
   echo "   N1      : start of problem size range"
   echo "   NN      : end of problem size range"
   echo "   incN    : increment between problem sizes"
@ROUT tvrun_rng.sh tvrun_lst.sh
   echo "   reps    : number of times each problem should be timed"
   echo "   -L lab  : LABEL for run (default DEF)"
   echo "   -E EF   : extra flags to pass to timer (eg, -E \"-U 1 L\") (default none)"
   exit 1
fi
scr=$0
tmr=$1  # xdslatime_al_ab
RT=$2   # getrf
@ROUT tvrun_lst.sh
lst=$3
NREP=$4
shift 4
@ROUT tvrun_rng.sh
N1=$3   # 200
N2=$4   #2000
Ni=$5   # 200
NREP=$6
shift 6
@ROUT tvrun_rng.sh tvrun_lst.sh

EF=
efs=0
lab=DEF
chksum=cksum
while [ $# -gt 0 ]
do
   case $1 in
   -L)  lab=$2
        shift 2
        ;;
   -E)  EF=$2
        efs=chks
        efs=`echo "${EF}" | ${chksum} | cut -d ' ' -f 1`
        shift 2
        ;;
   *)   echo "illegal flag ${1}"
        $scr
        exit 1
        ;;
   esac
done
PRE=`echo "$tmr" | cut -c 2`
PT=`echo "$tmr" | cut -c 3`
LIBS=`echo "$tmr" | cut -c 11-`
@ROUT tvrun_lst.sh
chs=`echo "${lst}" | ${chksum} | cut -d ' ' -f 1`
outf=res/${PT}${PRE}${RT}_${LIBS}_${chs}_${NREP}_${efs}.out
@ROUT tvrun_rng.sh
outf=res/${PT}${PRE}${RT}_${LIBS}_${N1}_${N2}_${Ni}_${NREP}_${efs}.out
@ROUT tvrun_rng.sh tvrun_lst.sh
mydir=`pwd`
BINdir=../bin
if [ ! -x $BINdir/$tmr ]
then
   cd $BINdir ; make $tmr
   cd $mydir
fi
if [ ! -d res ]
then
   mkdir res
fi
if [ ! -f $outf ]
then
   echo "  -> running . . ."
@ROUT tvrun_lst.sh
   if $BINdir/$tmr -R 1 $RT $EF -n $lst -# $NREP > $outf
@ROUT tvrun_rng.sh
   if $BINdir/$tmr -R 1 $RT $EF -N $N1 $N2 $Ni -# $NREP > $outf
@ROUT tvrun_rng.sh tvrun_lst.sh
   then
      echo "  -> run finished, output in: ${outf}\n"
      echo "*** END LABEL=$lab NREP=$NREP" >> $outf
   else
      echo "\nERROR in RUN!\n"
      cat $outf
      mv -f $outf BAD.OUT
      exit $i
   fi
else
   echo "   -> output already available in: ${outf}!\n"
fi
@ROUT !
