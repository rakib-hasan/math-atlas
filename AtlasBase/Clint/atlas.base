@ifdef ! incd
   @define incd @/home/rwhaley/Base/ATLAS@
@endifdef
@extract -b @(topd)/gen.inc what=crsetup
@ROUT matime
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#ifdef QREAL
   #define TYPE long double
#elif defined(SREAL)
   #define TYPE float
#else
   #define TYPE double
#endif
#ifndef NTIM
   #define NTIM 3
#endif
#ifdef CPUTIME
   #define time00 ATL_cputime
#else
   #define time00 ATL_walltime
#endif
double time00(void);
double macase(int nrep, volatile TYPE *dum);

void PrintUsage(char *xnam)
{
   fprintf(stderr, "USAGE: %s -m <mflop>, -f <outfile> -t <0/1>\n", xnam);
   fprintf(stderr, "    -m x: do x MFLOPS of computation\n");
   fprintf(stderr, "   -f <outf>: write results to file outf\n");
   fprintf(stderr, "   -t 0: print mflop rates, else print times\n");
   exit(-1);
}

FILE *GetFlags(int nargs, char **args, double *MFLOPS, int *TIME)
{
   double mf=200;
   FILE *fpout = stdout;
   int i;

   *TIME = 0;
   for (i=1; i < nargs; i++)
   {
      if (args[i][0] != '-')
         PrintUsage(args[0]);
      switch(args[i][1])
      {
      case 't':
         if (++i == nargs)
            PrintUsage(args[0]);
         *TIME = atoi(args[i]);
         break;
      case 'm':
         if (++i == nargs)
            PrintUsage(args[0]);
         mf = atof(args[i]);
         break;
      case 'f':
         if (++i == nargs)
            PrintUsage(args[0]);
         fpout = fopen(args[i], "w");
         assert(fpout);
         break;
      default:
         PrintUsage(args[0]);
      }
   }
   *MFLOPS = mf;
   return(fpout);
}

int main(int nargs, char **args)
{
   FILE *fpout;
   TYPE dum[32];
   double lmf, mf, flops;
   char pre;
   int i, nrep, PTIME;

   fpout = GetFlags(nargs, args, &mf, &PTIME);
   for (i=0; i < 32; i++)
      dum[i] = 0.0;
   lmf = macase(1, dum);
   nrep = mf*1000000.0 / lmf;
   if (nrep < 0)
      nrep = 1;
   for (i=0; i < NTIM; i++)
   {
      double t0, flops;
      t0 = time00();
      flops = macase(nrep, dum);
      t0 = time00() - t0;
      mf = flops / (1000000.0*t0);
      if (PTIME)
         fprintf(fpout, "%.e\n", t0);
      else
         fprintf(fpout, "%.2f\n", mf);
@skip printf("nrep=%d, flpcnt=%e, time=%e, mf=%.2f\n", nrep, flops, t0, mf);
   }
   if (fpout != stdout && fpout != stderr)
      fclose(fpout);
   return(0);
}
@ROUT masrch
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>

#ifndef NTIM
   #define NTIM 3
#endif

void magen
(
   char pre,    /* precision: s,d,q */
   FILE *fpout,
   int flops,   /* rough flops/iteration target */
   int MAC,     /* 0: separate multiply & add;  1: use MAC */
   int lat      /* latency to use */
)
{
   const int lfl = 2*lat, ur = (flops) ? (flops+lfl-1)/lfl:1;
   int i, j;
   char *typ="double";

   if (pre == 's')
      typ = "float";
   else if (pre == 'q')
      typ = "long double";
   fprintf(fpout, "double macase(int nrep, volatile %s *dum)\n", typ);
   fprintf(fpout, 
      "/*\n *  Performs nrep loop its and returns mflops performed\n */\n");
   fprintf(fpout, "{\n");
   fprintf(fpout, "   register %s m0, a0=0.0", typ);
   for (i=1; i < lat; i++)
      fprintf(fpout, ", m%d, a%d=0.0", i, i);
   fprintf(fpout, ";\n");
   fprintf(fpout, "   register int i;\n");

   for (i=0; i < lat; i++)
      fprintf(fpout, "    m%d=dum[%d];\n", i, i);

   fprintf(fpout, "   for (i=0; i < nrep; i++)\n   {\n");
   for (j=0; j < ur; j++)
   {
      fprintf(fpout, "/*\n * Basic block %d\n */\n", j);
      for (i=0; i < lat; i++)
      {
         if (MAC)
            fprintf(fpout, "      a%d += m%d*m%d;  m%d=m%d;\n", 
                    i, i, i, i, (i+1)%lat);
         else
            fprintf(fpout, "      a%d += m%d; m%d *= m%d;\n", i, i, i, i);
      }
   }
   fprintf(fpout, "   }\n\n");
   for (i=0; i < lat; i++)
      fprintf(fpout, "   dum[%d] = a%d;\n", i, i);
   fprintf(fpout, "   return(nrep*%d.0);\n", lfl*ur);
   fprintf(fpout, "}\n");
}

double matime
(
   char pre,   /* precision: s,d,q */
   int MAC,    /* 0: separate mul/add, 1: FMAC */
   int lat,    /* latency : number of multiply and add registers */
   int fmf,    /* how many mflops to force during timing */
   int TIME,   /* 0: return mflops, else return times in seconds */
   int FRC     /* 1: force retime if output file already there */
)
{
   char fnam[128];
   FILE *fp;
   double t0, mflop[NTIM];
   int i, j;

   if (FRC)
   {
      sprintf(fnam, "res/%ctmp", pre);
      fp = NULL;
   }
   else
   {
      sprintf(fnam, "res/%cmuladd%d_%d", pre, MAC, lat);
      fp = fopen(fnam, "r");
   }
   if (!fp)
   {
      FILE *fpout;
      char maf[16], ln[128], flgs[64];
      maf[0] = pre;
      maf[1] = 'm';
      maf[2] = 'u';
      maf[3] = 'l';
      maf[4] = 'a';
      maf[5] = 'd';
      maf[6] = 'd';
      maf[7] = '.';
      maf[8] = 'c';
      maf[9] = '\0';
      fpout = fopen(maf, "w");
      assert(fpout);
      magen(pre, fpout, 256, MAC, lat);
      fclose(fpout);
      i = sprintf(ln, "make x%cma outf='%s' flags=\"-m %d", pre, fnam, fmf);
      if (TIME)
         i += sprintf(ln+i, " -t 1");
      ln[i++] = '"';
      ln[i] = '\0';
      sprintf(ln+i, "2>&1 > /dev/null");
      assert(!system(ln));
      fp = fopen(fnam, "r");
      assert(fp);
   }
   t0 = 0.0;
   j = 0;
   for (i=0; i != NTIM; i++)
   {
      assert( fscanf(fp, "%lf", &mflop[i]) );
   }
   fclose(fp);
/*
 * Sort results, largest first
 */
   for (i=0; i != NTIM; i++)
   {
      for (j=i+1; j < NTIM; j++)
      {
         if (mflop[i] < mflop[j])
         {
            t0 = mflop[i];
            mflop[i] = mflop[j];
            mflop[j] = t0;
         }
      }
   }

/*
 * For walltime, return min time, else return median
 */
   #if defined(PentiumCPS) || defined(WALL)
      return(TIME ? mflop[NTIM-1] : mflop[0]);
   #else
      return(mflop[NTIM/2]);
   #endif
}

int FindMflop
(
   char pre,   /* precision: s,d,q */
   int MAC,    /* 0: separate mul/add, 1: FMAC */
   int lat     /* latency : number of multiply and add registers */
)
/*
 * Finds minimum mflop setting required to get a timing that takes roughly
 * 0.1 seconds
 */
{
   double tim;
   int mf, mfn = 1, ratio;
   printf("Finding how many mflops required to get .025 second timings:\n");

   do
   {
      mf = mfn;
      tim = matime(pre, MAC, lat, mf, 1, 1);
      printf("   %d: %e\n", mf, tim);
      mfn = mf<<1;
   }
   while(tim < 0.025);
   printf("FORCE MFLOP=%d, TIME=%e\n\n", mf, tim);
   return(mf);
}

FindNreg
(
   char pre,   /* precision: s,d,q */
   int fmf,    /* number of mflops to force timer on */
   int MAC,    /* 0: separate mul/add, 1: FMAC */
   int lat     /* latency : number of multiply and add registers */
)
/*
 * Tries to find total number of registers by noticing when performance
 * goes down with latency increase
 */
{
   double mfmax, mf;
   int nr, n, nreg=0;

   printf("FINDING USABLE NREG:\n");
   nr = 1;
   mfmax = matime(pre, MAC, nr, fmf, 0, 0);
   printf("   %3d: %.2f\n", nr+nr, mfmax);
   do
   {
      nr <<= 1;
      mf = matime(pre, MAC, nr, fmf, 0, 0);
      printf("   %3d: %.2f\n", nr+nr, mf);
      if (mf > mfmax)
         mfmax = mf;
      else if (1.08*mf < mfmax)
         break;
      nreg = nr+nr;
   }
   while (nr < 256);
   printf("\n");
/*
 * Since some compilers reserve some registers for themselves, don't believe
 * power-of-two results alone.  Refine estimate by scoping if intermediate
 * number of registers is still competitive
 */
   if (nreg == 16)
      n = 10;
   else if (nreg < 16)
      n = (nreg>>1)+2;
   else
      n = (nreg>>1) + (nreg>>2);
   mf = matime(pre, MAC, n, fmf, 0, 0);
   printf("   %3d: %.2f\n", n+n, mf);
   if (mf*1.02 >= mfmax)   /* worth refining further */
   {
      const int maxreg=nreg;
      if (mf*1.01 >= mfmax)
         nreg = n+n;
      if (mf > mfmax)
         mfmax = mf;

      for (nr = n+1; nr < maxreg; nr++)
      {
         mf = matime(pre, MAC, nr, fmf, 0, 0);
         printf("   %3d: %.2f\n", nr+nr, mf);
         if (mf*1.01 >= mfmax)
            nreg = nr+nr;
         if (mf > mfmax)
            mfmax = mf;
         else if (1.03*mf < mfmax)
            break;
      }
   }
   for (n=1; n < nreg; n <<= 1);
   if (n == nreg)
      printf("NREG=%d\n\n", nreg);
   else
   {
      printf("DETECTED nreg=%d; ASSIGNED nreg=%d\n", nreg, n);
      nreg = n;
   }
   return(nreg);
}

int FindLat
(
   char pre,   /* precision: s,d,q */
   int fmf,    /* number of mflops to force timer on */
   int MAC,    /* 0: separate mul/add, 1: FMAC */
   int nreg,   /* max number of registers to try */
   double *MFMAX
)
{
   double mf, mfmax;
   int i, latmax = 1;

   printf("FINDING BEST LATENCY, MAC=%d:\n", MAC);
   mfmax = matime(pre, MAC, 1, fmf, 0, 0);
   printf("   lat=%d, MFLOPS=%.2f\n", 1, mfmax);
   for (i=2, nreg >>= 1; i <= nreg; i++)
   {
      mf = matime(pre, MAC, i, fmf, 0, 0);
      printf("   lat=%d, MFLOPS=%.2f\n", i, mf);
      if (mf < mfmax*1.02)
         break;
      mfmax = mf;
      latmax = i;
   }
   printf("LAT=%d, MFLOPS=%.2f\n\n", latmax, mfmax);
   *MFMAX = mfmax;
   return(latmax);
}

void PrintUsage(char *xnam)
{
   fprintf(stderr, 
   "USAGE: %s -p <pre> -o <outfile> -F <mflop> -n <nreg> -L <lat> -M <mac>\n",
           xnam);
   exit(-1);
}

char *GetFlags(int nargs, char **args, char *PRE, int *FMF, int *NREG,
               int *LAT, int *MAC)
{
   char *fnam=NULL;
   int i;
   *PRE = 'd';
   *LAT = *FMF = *NREG = 0;
   *MAC = -1;
   for (i=1; i < nargs; i++)
   {
      if (args[i][0] != '-')
         PrintUsage(args[0]);
      switch(args[i][1])
      {
      case 'p':
         if (++i == nargs)
            PrintUsage(args[0]);
         *PRE = args[i][0];
         break;
      case 'L':
         if (++i == nargs)
            PrintUsage(args[0]);
         *LAT = atoi(args[i]);
         break;
      case 'n':
         if (++i == nargs)
            PrintUsage(args[0]);
         *NREG = atoi(args[i]);
         break;
      case 'F':
         if (++i == nargs)
            PrintUsage(args[0]);
         *FMF = atoi(args[i]);
         break;
      case 'M':
         if (++i == nargs)
            PrintUsage(args[0]);
         *MAC = atoi(args[i]);
         break;
      case 'o':
         if (++i == nargs)
            PrintUsage(args[0]);
         fnam = args[i];
         break;
      default:
         PrintUsage(args[0]);
      }
   }
   assert(*PRE == 's' || *PRE == 'd' || *PRE == 'q');
   return(fnam);
}

int main(int nargs, char **args)
{
   char pre='d';
   int MAC=0, lat=1, fmf, nreg, latMAC, latMA, RUNSRCH=1;
   double mf, mfMAC, mfMA;
   char *fnam;
   FILE *fp;

   fnam = GetFlags(nargs, args, &pre, &fmf, &nreg, &lat, &MAC);
/*
 * If MAC is set, just time the indicated case and output to screen
 */
   if (MAC != -1)
   {
      mf = matime(pre, MAC, lat, fmf, 0, 1);
      printf("pre=%c, MAC=%d, lat=%d, mf=%.2f\n", pre, MAC, lat, mf);
      exit(0);
   }
/*
 * If user specified a file that already exists, just read in data and run
 * case
 */
   if (fnam)
   {
      fp = fopen(fnam, "r");
      if (fp)
      {
         assert(fscanf(fp, "%d", &MAC) == 1);
         assert(fscanf(fp, "%d", &lat) == 1);
         assert(fscanf(fp, "%lf", &mf) == 1);
         assert(fscanf(fp, "%d", &nreg) == 1);
         fclose(fp);
         fmf = FindMflop(pre, MAC, lat);
         mf = matime(pre, MAC, lat, fmf, 0, 1);
         RUNSRCH=0;
      }
   }
   if (RUNSRCH)
   {
      fmf = FindMflop(pre, 0, 4);
      if (nreg < 1)
         nreg = FindNreg(pre, fmf, 0, 4);
      latMA = FindLat(pre, fmf, 0, nreg, &mfMA);
      latMAC = FindLat(pre, fmf, 1, nreg, &mfMAC);
      if (mfMA*1.02 > mfMAC)
      {
         MAC = 0;
         lat = latMA;
         mf = mfMA;
      }
      else
      {
         MAC = 1;
         lat = latMAC;
         mf = mfMAC;
      }
      printf("NREG=%d, FMAC=%d, LAT=%d, MFLOP=%.2f\n", nreg, MAC, lat, mf);
   }
   if (fnam)
   {
      fp = fopen(fnam, "w");
      assert(fp);
      fprintf(fp, "%d\n%d\n%.2f\n%d\n", MAC, lat, mf, nreg);
      fclose(fp);
   }
   else
      printf("NREG=%d, FMAC=%d, LAT=%d, MFLOP=%.2f\n", nreg, MAC, lat, mf);
   return(0);
}
@ROUT masearch
@extract -b @(topd)/gen.inc what=cw
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>

#define NTIM 3
#define TOLERANCE 1.2
#define BETTER 1.04  /* require at least 4% improvement, see below */

/*
 * We require at least 4% improvement before declaring a longer latency to
 * be better.  This is because longer latencies have less loop overhead, which
 * gives them a possible advantage, depending on the unrollings the compiler
 * does.  When you actually have too small a latency, this event should be
 * relatively catastrophic, with drops greater > 10%, so this is relatively
 * safe assumption.  Also, the smaller latencies require less registers to
 * satisfy, so they tend to be preferable.  - Clint
 */

void emit_muladd(char *type, char pre, int MULADD, int lat, 
                 unsigned long nlma,  /* # muladds in loop */
                 unsigned long mflop)    /* n mflops to time */
{
   int i, j, nama;
   char *ma;
   unsigned long reps;
   double mf;
   FILE *fpout;

   nama = (nlma + lat-1) / lat;  /* # of actual muladds in loop */
   mflop *= 1000000;
   reps = mflop / (2*nama);

   fpout = fopen("muladd.c", "w");
   assert(fpout != NULL);
   if (MULADD) ma = "Combined MULADD";
   else ma = "Separate multiply and add";
   fprintf(fpout, 
           "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n");
   fprintf(fpout, "#if defined(PentiumCPS) || defined(WALL)\n");
   fprintf(fpout, "   #define time00 ATL_walltime\n");
   fprintf(fpout, "#else\n   #define time00 ATL_cputime\n#endif\n");
   fprintf(fpout, "double time00(void);\n");
/*
 * function macase()
 */
   fprintf(fpout, "\nstatic double macase(long nreps, int PRINT)\n{\n");
   fprintf(fpout, "   long i = nreps;\n");
   fprintf(fpout, "   double t0, tim, mf;\n");
   fprintf(fpout, "   register %s c0", type);
   for (i=1; i < lat; i++) fprintf(fpout, ", c%d", i);
   if (!MULADD) for (i=0; i < lat; i++) fprintf(fpout, ", m%d", i);
   fprintf(fpout, ";\n\n");
   fprintf(fpout, 
      "   if (!(rand()|rand()|rand()|rand()|rand()|rand())) nreps = rand();\n");

/*
 * Try to make sure compiler cannot figure out ops can be reduced to asg
 */
   for (i=0; i < lat; i++)
      fprintf(fpout, 
      "   if (rand()|rand()|rand()) c%d = 0.0;\n   else c%d = 1.%d*rand();\n",
              i, i, i);
   if (!MULADD)
      for (i=0; i < lat; i++)
         fprintf(fpout, 
      "   if (rand()|rand()|rand()) m%d = 0.0;\n   else m%d = 0.%d*rand();\n",
                 i, i, i+1);
@beginskip
   fprintf(fpout, "   if (nreps > 0) c0 = 0.0;\n   else c0 = 2.2*nreps;\n");
   if (lat > 1 || !MULADD)
   {
      fprintf(fpout, "   ");
      for (i=1; i < lat; i++) fprintf(fpout, "c%d = ", i);
      if (!MULADD) for (i=0; i < lat; i++) fprintf(fpout, "m%d = ", i);
      fprintf(fpout, "c0;\n");
   }
@endskip
   fprintf(fpout, "   t0 = time00();\n");
   fprintf(fpout, "   do\n   {\n");
   for (j=0; j < nama; j++)
   {
      for (i=0; i < lat; i++)
      {
         if (MULADD) fprintf(fpout, "      c%d += c%d * c%d;\n", i, i, i);
         else fprintf(fpout,"      c%d += m%d;\n      m%d = m%d * m%d;\n",
                      i, i, i, i, i);
      }
   }
   fprintf(fpout, "   }\n   while(--i);\n");
   fprintf(fpout, "   tim = time00() - t0;\n");
   fprintf(fpout, "   c0 = c0");
   if (!MULADD)
   {
      fprintf(fpout, "*m0");
      for (i=1; i < lat; i++) fprintf(fpout, " + c%d*m%d", i, i);
   }
   else
      for (i=1; i < lat; i++) fprintf(fpout, " + c%d", i);
   fprintf(fpout, ";\n");
   mf = (2.0 * nama)*lat ;
   fprintf(fpout, "   if (tim < 0.0) mf = tim = 0.0;\n");
   fprintf(fpout, "   else mf = (nreps*%lf) / (1000000.0 * tim);\n", mf);
   fprintf(fpout, "   if (PRINT) printf(\"%%.1f:   %s, lat=%d, time=%%f, mflop=%%f\\n\", (float) c0, tim, mf);\n", ma, lat);
   fprintf(fpout, "   else printf(\"      %%.0f: NFLOP=%%.0f, tim=%%f\\n\", (float) c0, nreps*%f, tim);\n", mf);
   fprintf(fpout, "   return(tim);\n");
   fprintf(fpout, "}\n");
/*
 * main()
 */
   fprintf(fpout, "\nint main(int nargs, char **args)\n{\n");
   fprintf(fpout, "   long nreps = 16000000/%d;\n", (2*nama));
   fprintf(fpout, "   int i, k;\n");
   fprintf(fpout, "   double t0, tim, mf;\n");
   fprintf(fpout, "   FILE *fp;\n");
   fprintf(fpout, "   fp = fopen(\"res/%cmuladd%d_%d\", \"w\");\n", pre, MULADD, lat);
   fprintf(fpout, "   assert(fp != NULL);\n");

   fprintf(fpout, "   fprintf(stdout, \"Finding granularity of timer:\\n\");");
   fprintf(fpout, "   while(macase(nreps, 0) < 0.75) nreps *= 4;\n");
   fprintf(fpout, "   fprintf(stdout, \"Done.\\n\");");

   fprintf(fpout, "   for(k=0; k < 3; k++)\n   {\n");
   fprintf(fpout, "   tim = macase(nreps, 1);\n");
   fprintf(fpout, "   if (tim < 0.0) mf = tim = 0.0;\n");
   fprintf(fpout, "   else mf = (nreps*%lf) / (1000000.0 * tim);\n", mf);
   fprintf(fpout, "   if (fp) fprintf(fp, \"%%f\\n\", mf);\n");
   fprintf(fpout, "   }\n");
   fprintf(fpout, "   fclose(fp);\n");
   fprintf(fpout, "   return(0);\n");
   fprintf(fpout, "}\n");
   fclose(fpout);
}

double macase(char *type, char pre, int MULADD, int lat, int nlma, int mflops)
{
   char fnam[80], ln[80];
   int i, j;
   double mflop[NTIM], t0, tavg;
   FILE *fp;

   lat++;
   sprintf(fnam, "res/%cmuladd%d_%d", pre, MULADD, lat);
   fp = fopen(fnam, "r");
   if (fp == NULL)
   {
      emit_muladd(type, pre, MULADD, lat, nlma, mflops);
      sprintf(ln, "make x%cmuladd\n", pre);
      assert(!system(ln));
@skip      assert(system("make xmuladd\n") == 0);
      assert( (fp = fopen(fnam, "r")) != NULL );
   }
   t0 = 0.0;
   j = 0;
   for (i=0; i != NTIM; i++)
   {
      assert( fscanf(fp, "%lf", &mflop[i]) );
   }
   fclose(fp);
/*
 * Sort results, largest first
 */
   for (i=0; i != NTIM; i++)
   {
      for (j=i+1; j < NTIM; j++)
      {
         if (mflop[i] < mflop[j])
         {
            t0 = mflop[i];
            mflop[i] = mflop[j];
            mflop[j] = t0;
         }
      }
   }

/* 
 * For walltime, return min time, else return median
 */
   #if defined(PentiumCPS) || defined(WALL)
      return(mflop[0]);
   #else
      return(mflop[NTIM/2]);
   #endif
@beginskip
/*
 * Throw out result if it is outside tolerance; rerun if two mflop not within
 * tolerance
 */
   if (TOLERANCE*mflop[1] < mflop[0])  /* too big a range in results */
   {
      if (TOLERANCE*mflop[2] < mflop[1])
      {
         fprintf(stderr, "MULADD=%d, lat=%d: kill file and rerun with higher reps; variation exceeds tolerence\n", MULADD, lat);
         exit(-1);
      }
      tavg = (mflop[1] + mflop[2]) / 2.0;
   }
   else if (TOLERANCE*mflop[2] < mflop[0]) tavg = (mflop[0] + mflop[1]) / 2.0;
   else tavg = (mflop[0] + mflop[1] + mflop[2]) / 3.0;
   return(tavg);
@endskip
}

int FindSafeNumRegs(char pre, char *type, int nlma, int mflops, 
                    int muladd, int lat)
{
   int i, k, lat2, nreg, nrmax, nrmin;
   double mf, mf0;

   if (muladd) nreg = lat;
   else nreg = 2*lat;
   mf0 = macase(type, pre, muladd, lat-1, nlma, mflops);
   for (k=1; k <= nreg; k *= 2);
   k /= 2;

   do
   {
      k *= 2;
      if (muladd) lat2 = k;
      else { lat2 = k / 2; k = lat2 * 2; }

      mf = macase(type, pre, muladd, lat2-1, nlma, mflops);
      if (k > 256)
      {
         fprintf(stdout, 
"      Either number of registers is > 256, or this test is not working.\n");
         fprintf(stdout, "      Unable to find NREG, setting to 32\n");
         return(32);
         break;
      }
      fprintf(stdout, "      nreg=%d, mflop = %.2lf (peak %.2lf)\n",k, mf, mf0);
   }
   while (mf*BETTER >= mf0);
   fprintf(stdout, "\n  nreg < %d (drop to %.2f%%)\n\n", k, mf/mf0);

   nrmax = k;
   nrmin = k / 2;
   do
   {
      k = nrmin + (nrmax - nrmin) / 2;
      if (muladd) lat2 = k;
      else lat2 = k / 2;
      mf = macase(type, pre, muladd, lat2-1, nlma, mflops);
      if (mf*BETTER >= mf0) nrmin = k;
      else nrmax = k;
      fprintf(stdout, "      nreg=%d, mflop = %.2lf (peak %.2lf)\n",k, mf, mf0);
   }
   while (nrmax-nrmin > 1);
   return(nrmin);
}

void RunTime(char pre, char *type, int nlma, int mflop)
/*
 * If necessary, fills in mflop field by timing previously chosen case
 */
{
   char fnam[64];
   int muladd, lat, nreg;
   double mf;
   FILE *fp;

   sprintf(fnam, "res/%cMULADD", pre);
   fp = fopen(fnam, "r");
   if (fp == NULL) return;
   fscanf(fp, "%d", &muladd);
   fscanf(fp, "%d", &lat);
   fscanf(fp, "%lf", &mf);
   fscanf(fp, "%d", &nreg);
   fclose(fp);
   if (mf < 0.0)
   {
      mf = macase(type, pre, muladd, lat-1, nlma, mflop);
      fp = fopen(fnam, "w");
      assert(fp != NULL);
      fprintf(fp, "%d\n", muladd);
      fprintf(fp, "%d\n", lat);
      fprintf(fp, "%lf\n", mf);
      fprintf(fp, "%d\n", nreg);
      fclose(fp);
   }
}

@extract -b @(basd)/atlas.base rout=Mylcm

int main(int nargs, char **args)
{
   char pre, *type, fnam[64];
   int k, kma, kno, kbest, maxlat, mflop, nlma=1;
   int MULADD=1;
   double mf0, mf, mfma=0, mfno=0;
   FILE *fp;

   if (nargs != 4 && nargs != 5)
   {
      fprintf(stderr, "usage: %s <pre> <maxlat> <mflop> [<nlma>]\n", args[0]);
      exit(-1);
   }
   pre = *args[1];
   if (pre == 'd') type = "double";
   else if (pre == 's') type = "float";
   else if (pre == 'q') type = "long double";
   else
   {
      fprintf(stderr, "\n\nUnknown prefix \'%c\'; aborting.\n\n", pre);
      exit(-1);
   }
   maxlat = atoi(args[2]);
   mflop = atoi(args[3]);  /* this is ignored now */
   if (nargs == 5) nlma = atoi(args[4]);
   else
   {
      nlma = 2;
      for (k=3; k < maxlat; k++)
         nlma = Mylcm(nlma, k);
      nlma = ((512+nlma-1)/nlma)*nlma;
   }
   if (maxlat <= 0)
   {
      RunTime(pre, type, nlma, mflop);
      exit(0);
   }
 
   kma = kno = kbest = -1;
   mf = mfma = mfno = 0.0;

   maxlat = 16;
@skip   #ifdef ATL_ARCH_IA64Itan
@skip      if (maxlat == 6) maxlat = 14; /* temporary kludge for IA64 */
@skip   #endif
   for (k=0; k < maxlat; k++)
   {
      mf0 = macase(type, pre, 1, k, nlma, mflop);
      if (mf0 > BETTER*mfma)
      {
         mfma = mf0;
         kma = k;
      }
      fprintf(stdout, "      MULADD=%d, lat=%d, mf=%.2lf\n", 1, k+1, mf0);
/*
 *    If we've timed the short lengths and longer is not improving perf, quit
 */
      if (k > 6 && mf0 < mfma)
         break;
   }
   for (k=0; k < maxlat; k++)
   {
      mf0 = macase(type, pre, 0, k, nlma, mflop);
      if (mf0 > BETTER*mfno)
      {
         mfno = mf0;
         kno = k;
      }
      fprintf(stdout, "      MULADD=%d, lat=%d, mf=%.2lf\n", 0, k+1, mf0);
/*
 *    If we've timed the short lengths and longer is not improving perf, quit
 */
      if (k > 6 && mf0 < mfma)
         break;
   }
/* 
 * Award ties to separate multiply/add, since it may just be the compiler
 * making the machine behave like it has muladd
 */
   if (BETTER*mfno >= mfma)
   {
      MULADD = 0;
      mf = mfno;
      kbest = kno;
   }
   else
   {
      mf = mfma;
      kbest = kma;
   }
   k = FindSafeNumRegs(pre, type, nlma, mflop, MULADD, kbest+1);
   fprintf(stdout, "\nLower bound on number of registers = %d\n", k);
   sprintf(fnam, "res/%cMULADD", pre);
   fp = fopen(fnam, "w");
   assert(fp != NULL);
   fprintf(fp, "%d\n", MULADD);
   fprintf(fp, "%d\n", kbest+1);
   fprintf(fp, "%lf\n", mf);
   fprintf(fp, "%d\n", k);
   fclose(fp);
   fprintf(stdout,
"\n\nAccording to these timings, I think you need a %d cycle latency,\n", kbest+1);
   if (MULADD) fprintf(stdout, "with a combined multiply/add instruction.\n");
   else fprintf(stdout, "with separate multiply and add instructions.\n\n");
   fprintf(stdout, "These parameters gave a performance of %f MFLOPS.\n\n", mf);
   return(0);
}

@ROUT l1search mvsearch hcsearch
@extract -b @(topd)/gen.inc what=cw
@ROUT mmsearch
 @multidef cwdate 
    2010 2009 2008 2007 2006 2005 2004 2003 2002 2001 2000 1999 1998 1997
 @endmultidef
 @extract -b @(topd)/cw.inc lang=c 
#define VERB 1
@ROUT ummsearch
@skip @extract -b @(topd)/gen.inc what=cw @(cw00)
 @multidef cwdate 2009 2008 2007 2006 2005 2004 2003 2002 2001 2000
 @extract -b @(topd)/cw.inc lang=c 
@ROUT mmsearch l1search mvsearch hcsearch ummsearch

#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <string.h>
#include "atlas_misc.h"
#include "atlas_fopen.h"
#include "atlas_prefetch.h"
@ROUT mmsearch ummsearch `#include "atlas_gentesttime.h"`
@ROUT mmsearch ummsearch `#include "atlas_mmtesttime.h"`

#define Mmin(x, y) ( (x) > (y) ? (y) : (x) )

#define TOLERANCE 1.2
@ROUT ummsearch
#define MAX_NB    80
@ROUT mmsearch
#define REPS 4096
#define L1FNAME "L1CacheSize"
#define NTIM 3
#define MAXLAT 6
/*
 * For 2-operand assemblers, no benefit from 2-D register blocking, so flag
 * them;  If unknown arch is also 2-op, no problem will just search longer
 */
@skip #if defined (ATL_GAS_x8632) || defined(ATL_GAS_x8664)
@skip   #define TWO_OP_ASM
@skip #endif

char LANG;

void PrintUsage(char *xnam)
{
   fprintf(stderr, "\n\nUsage: %s [-r #][-h][-f][-l #][-p s/d/c/z][-m #]\n",
           xnam);
   fprintf(stderr, "-h         : Print this help screen\n");
   fprintf(stderr, "-f         : Force complete search over given parameters\n");
   fprintf(stderr, "-p s/d/c/z : set the precision to search for\n");
   fprintf(stderr, "-r #       : Set max number of registers to use to # (default 32)\n");
   fprintf(stderr, "-m #       : Set max L1 cache size (kilobytes) to #\n");
   fprintf(stderr, "-L <c/f>   : Select what language to use (C or Fortran77)\n");
   fprintf(stderr, "-K #       : Set K-loop unrolling to # (-1 = K).\n");
   fprintf(stderr, "-l #       : Use latency factor #.  If set to 0,\n");
   fprintf(stderr, 
"             do not do latency checking.  By default, latency checking is\n");
   fprintf(stderr, 
"             done only if initial timings show it is a win.\n");
   exit(-1);
}

void GetSettings(int nargs, char *args[], char *pre, char *lang, int *ku, 
                 int *LAT, int *FRC, int *nreg, int *MaxL1Size, int *ROUT)
{
   int i;

   *FRC = 0;
   *LAT = -1;
   *nreg = -1;
   *MaxL1Size = 128;
   *pre = 'd';
   *lang = 'C';
   *ku = 0;
   *ROUT = 0;
   for (i=1; i < nargs; i++)
   {
      if (*args[i] != '-') PrintUsage(args[0]);
      switch(args[i][1])
      {
      case 'K':
         *ku = atoi(args[++i]);
         break;
      case 'L':
         i++;
         if ( (*args[i] == 'F') || (*args[i] == 'f') ) *lang = 'F';
         break;
      case 'm' :
         *MaxL1Size = atoi(args[++i]);
         break;
      case 'r' :
         *nreg = atoi(args[++i]);
         break;
      case 'f' :
         *FRC = atoi(args[++i]);
         break;
      case 'l' :
         *LAT = atoi(args[++i]);
         break;
      case 'p' :
         *pre = *args[++i];
         break;
      default:
      case 'R':
         *ROUT = atoi(args[++i]);
         break;
      case 'h' :
         PrintUsage(args[0]);
      }
   }
}

@ROUT mmsearch ummsearch
int L1Elts(char pre, int MaxL1Size)
{
   FILE *L1f;
   int L1Size, tsize;
   char ln[128];

   if (!FileExists("res/L1CacheSize"))
   {
      sprintf(ln, "make RunL1 MaxL1=%d\n",MaxL1Size);
      if (system(ln) != 0)
      {
         remove("res/L1CacheSize");
         fprintf(stderr, "Error in command: %s", ln);
         exit(-1);
      }
   }
   L1f = fopen("res/L1CacheSize", "r");
   assert(L1f != NULL);
   fscanf(L1f, "%d", &L1Size);
   fclose(L1f);
   switch (pre)
   {
      case 's':
         tsize = sizeof(float);
         break;
      case 'd':
         tsize = sizeof(double);
         break;
      case 'q':
         tsize = sizeof(long double);
         break;
      case 'c':
         tsize = sizeof(float);
         break;
      case 'z':
         tsize = sizeof(double);
         break;
   }
   return( (L1Size*1024) / tsize);
}

int GetCacheSize(int MaxL1Size)
/*
 * Returns L1 size in kilobytes
 */
{
   FILE *L1f;
   int L1Size;
   char ln[32];

   if (!FileExists("res/L1CacheSize"))
   {
      sprintf(ln, "make RunL1 MaxL1=%d\n",MaxL1Size);
      if (system(ln) != 0)
      {
         remove("res/L1CacheSize");
         fprintf(stderr, "Error in command: %s", ln);
         exit(-1);
      }
   }
   L1f = fopen("res/L1CacheSize", "r");
   assert(L1f != NULL);
   fscanf(L1f, "%d", &L1Size);
   fclose(L1f);
   fprintf(stderr, "\n      Read in L1 Cache size as = %dKB.\n",L1Size);
   return(L1Size);
}

int GetTypeSize(char pre)
{
   int tsize;
   if (pre == 'c' || pre == 's') tsize = ATL_ssize;
   else tsize = ATL_dsize;
   return(tsize);
}
void findNBs(char prec, char *NBnam, int MaxL1Size)
{
   FILE *NBf;
   char ln[80];
   int i, L1Size, tmp, tsize, tL1Size, CL, nNB;
   int NB[100];

   fprintf(stderr, "NB setting not supplied; calculating:\n");

   L1Size = GetCacheSize(MaxL1Size);
   tsize = GetTypeSize(prec);

   tL1Size = L1Size * (1024 / tsize);
   tmp = CL = ATL_Cachelen / tsize;
   if (!tmp) tmp=1;
   nNB = 0;
   fprintf(stderr, "tmp=%d, tL1size=%d\n",tmp, tL1Size);
   while (tmp*tmp <= tL1Size)
   {
      if (tmp >= 16)        /* no block sizes smaller than 16 */
         NB[nNB++] = tmp;
      if (tmp >= 80) break;  /* no block sizes bigger than 80 */
      tmp += CL;
   }
   if (!nNB)  /* this should never happen */
   {
      nNB = 3;
      NB[0] = 8;
      NB[1] = 4;
      NB[2] = 16;
   }
   else if (nNB > 2)  /* put second biggest blocking factor first in list */
   {
      tmp = NB[nNB-2];
      NB[nNB-2] = NB[0];
      NB[0] = tmp;
@beginskip
         tL1Size = 1.5 * L1Size * (1024 / tsize);
         for (i=0; i < nNB; i++) if (NB[i]*NB[i] >= tL1Size) break;
         if (i > 0)
         {
            if (NB[i] * NB[i] > tL1Size) i--;
            tmp = NB[i-1];
            NB[i-1] = NB[0];
            NB[0] = tmp;
         }
@endskip
   }

   NBf = fopen(NBnam, "w");
   fprintf(NBf, "%d\n", nNB);
   for (i=0; i != nNB; i++) fprintf(NBf, "%d\n", NB[i]);
   fclose(NBf);
}

int GetSafeNB(char pre, int MaxL1)
{
   int i, L1, tsize, inc;

   tsize = GetTypeSize(pre);
   inc = ATL_MinMMAlign / tsize;
   if (inc < 4) inc = 4;
   L1 = (GetCacheSize(MaxL1) * 1024) / tsize;
   for (i=inc; i*i < L1; i += inc);
   if (i*i > L1) i -= inc;
   if (pre == 'd' || pre == 's')
   {
      if (i*i == L1) i -= inc;
   }
   else
   {
      if (i*i == L1) i -= 2*inc;
      else i -= inc;
   }
   if (i < 16) i = 16;
   if (i > 80) i = 80;
   return(i);
}

@ROUT ATL_resfind
@extract -b @(topd)/gen.inc what=cw

#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
@ROUT ummsearch mmsearch l1search mvsearch hcsearch atl_resfind
double GetAvg(int n, double tolerance, double *mflop)
{
   int i, j;
   double t0, tavg;
/*
 * Sort results, largest first
 */
   for (i=0; i != n; i++)
   {
      for (j=i+1; j < n; j++)
      {
         if (mflop[i] < mflop[j])
         {
            t0 = mflop[i];
            mflop[i] = mflop[j];
            mflop[j] = t0;
         }
      }
   }
/*
 * Not doing tolerance anymore, just take largest mflop rate if doing wall
 * times, or median value if doing CPU
 */

#if 1
   #ifdef WALL
      tavg = mflop[0];
   #else
      tavg = mflop[n/2];
   #endif
#else
/*
 * Throw out result if it is outside tolerance; rerun if two mflop not within
 * tolerance;  this code assumes n == 3
 */
   if (tolerance*mflop[1] < mflop[0])  /* too big a range in results */
   {
      if (tolerance*mflop[2] < mflop[1]) return(-1.0);
      tavg = (mflop[1] + mflop[2]) / 2.0;
   }
   else if (tolerance*mflop[2] < mflop[0]) tavg = (mflop[0] + mflop[1]) / 2.0;
   else tavg = (mflop[0] + mflop[1] + mflop[2]) / 3.0;
#endif

   return(tavg);
}

@ROUT hcsearch
void PrintUsage(char *nam)
{
   fprintf(stderr, "USAGE: %s -p <pre> -n <nb> -C <m/n/k>\n", nam);
   exit(-1);
}

int main(int nargs, char *args[])
{
   char ln[127], pre='d', ln2[127], ch;
   int i, nb=28;
   double mflops[3];
   double mf1, mf4;
   FILE *fpin, *fp;

   for (i=1; i < nargs; i++)
   {
      if (args[i][0] != '-') PrintUsage(args[0]);
      switch(args[i][1])
      {
      case 'p':
         ch = args[++i][0];
         pre = Mlowcase(ch);
         break;
      case 'n':
         nb = atoi(args[++i]);
         break;
      default: 
         PrintUsage(args[0]);
      }
   }
   sprintf(ln, "res/M%cNB%d_4x1x1_0-1.mflop", pre, nb);
   if (!FileExists(ln))
   {
      sprintf(ln2, "make %chc_cases nb=%d\n", pre, nb);
      assert(system(ln2) == 0);
   }
   fpin = fopen(ln, "r");
   assert(fpin);
   for (i=0; i < 3; i++) assert( fscanf(fpin, "%lf", mflops+i) );
   mf1 = GetAvg(3, 1.2, mflops);
   fclose(fpin);

   sprintf(ln, "res/M%cNB%d_4x4x1_0-1.mflop", pre, nb);
   if (!FileExists(ln))
   {
      sprintf(ln2, "make %chc_cases nb=%d\n", pre, nb);
      if (system(ln2) != 0)
      {
         sprintf(ln, "rm -f res/M%cNB*\n", pre);
         system(ln);
         fprintf(stderr, "Error in command: %s", ln2);
         exit(-1);
      }
   }
   fpin = fopen(ln, "r");
   assert(fpin);
   for (i=0; i < 3; i++) assert( fscanf(fpin, "%lf", mflops+i) );
   mf4 = GetAvg(3, 1.2, mflops);
   fclose(fpin);

   sprintf(ln, "res/%cmmcase.h", pre);
   fp = fopen(ln, "w");
   assert(fp);
   fprintf(fp, "#ifndef %cMMCASE_H\n", Mupcase(pre));
   fprintf(fp, "   #define %cMMCASE_H\n", Mupcase(pre));
   if (mf1 >= mf4) fprintf(fp, "   #define Use4x1\n");
   else fprintf(fp, "   #define Use4x4\n");
   fprintf(fp, "#endif\n");
   fclose(fp);
   sprintf(ln, "res/%cHCRES", pre);
   fp = fopen(ln, "w");
   assert(fp);
   fprintf(fp, "%f\n", mf1);
   fprintf(fp, "%f\n", mf4);
   fclose(fp);

   return(0);
}
@ROUT mmsearch
double mms_case(char pre, int MULADD, int NB, int mu, int nu, int ku, 
                int pfA, int lat)
{
   char fnam[128], ln[256];
   int i;
   double mflop[NTIM], t0;
   FILE *fp;

   if (ku > NB) ku = NB;
   else if (ku == -1) ku = NB;
   sprintf(fnam, 
           "res/%c%smm%c%c%d_%dx%dx%d_%dx%dx%d_%dx%dx%d%s%s_%dx%d_%d_pf%d",
           pre, "JIK", 'T', 'N', NB, NB, NB, NB, NB, NB, 0, mu, nu, ku, 
           "_a1", "_b1", MULADD, lat, 1, pfA);
   if (!FileExists(fnam))
   {
      if (pre == 'c' || pre == 'z')
         sprintf(ln,
" make mmcase pre=%c loopO=%s ta=%c tb=%c mb=%d nb=%d kb=%d lda=%d ldb=%d ldc=%d mu=%d nu=%d ku=%d alpha=%d beta=%d muladd=%d lat=%d csA=1 csB=1 csC=2 cleanup=%d pfA=%d > /dev/null 2>&1\n",
                   pre, "JIK", 'T', 'N', NB, NB, NB, NB, NB, 0, mu, nu, ku,
                   1, 1, MULADD, lat, 1, pfA);
      else sprintf(ln,
" make mmcase pre=%c loopO=%s ta=%c tb=%c mb=%d nb=%d kb=%d lda=%d ldb=%d ldc=%d mu=%d nu=%d ku=%d alpha=%d beta=%d muladd=%d lat=%d cleanup=%d pfA=%d > /dev/null 2>&1\n",
                   pre, "JIK", 'T', 'N', NB, NB, NB, NB, NB, 0, mu, nu, ku,
                   1, 1, MULADD, lat, 1, pfA);
@skip      fprintf(stderr, "%s:\n",ln);
      if (system(ln) != 0)
      {
         fprintf(stderr, "ERROR IN COMMAND: %s", ln);
         fprintf(stderr, "   PROPOSED FILENAME: %s\n", fnam);
         sprintf(ln, "rm -f %s\n", fnam);
         system(ln);
         exit(-1);
      }
   }
   t0 = *((double*)ReadResultsFile(0, 3,fnam));
   fprintf(stdout, 
"   pre=%c, muladd=%d, lat=%d, pf=%d, nb=%d, mu=%d, nu=%d, ku=%d, mflop=%.2f\n",
           pre, MULADD, lat, pfA, NB, mu, nu, ku, t0);
   return(t0);
}

double mms_caseIC(char pre, int MULADD, int NB, int mu, int nu, int ku, 
                  int pfA, int lat)
/*
 * Do simple mmcase, where all operands are kept cache-resident 
 * (useful for FPU optimization phases)
 */
{
   char fnam[128], ln[512];
   int i;
   double mflop[NTIM], t0;
   FILE *fp;

   if (ku > NB) ku = NB;
   else if (ku == -1) ku = NB;
   sprintf(fnam, 
           "res/%c%smm%c%c%d_%dx%dx%d_%dx%dx%d_%dx%dx%d%s%s_%dx%d_%d_IC",
           pre, "JIK", 'T', 'N', NB, NB, NB, NB, NB, NB, 0, mu, nu, ku, 
           "_a1", "_b1", MULADD, lat, 1);
   if (!FileExists(fnam))
   {
      if (pre == 'c' || pre == 'z')
         sprintf(ln,
" make mmcase pre=%c loopO=%s ta=%c tb=%c mb=%d nb=%d kb=%d lda=%d ldb=%d ldc=%d mu=%d nu=%d ku=%d alpha=%d beta=%d muladd=%d lat=%d csA=1 csB=1 csC=2 cleanup=%d casnam=%s moves=\"\" > /dev/null 2>&1\n",
                   pre, "JIK", 'T', 'N', NB, NB, NB, NB, NB, 0, mu, nu, ku,
                   1, 1, MULADD, lat, 1, fnam);
      else sprintf(ln,
" make mmcase pre=%c loopO=%s ta=%c tb=%c mb=%d nb=%d kb=%d lda=%d ldb=%d ldc=%d mu=%d nu=%d ku=%d alpha=%d beta=%d muladd=%d lat=%d cleanup=%d casnam=%s moves=\"\" > /dev/null 2>&1\n",
                   pre, "JIK", 'T', 'N', NB, NB, NB, NB, NB, 0, mu, nu, ku,
                   1, 1, MULADD, lat, 1, fnam);
@skip      fprintf(stderr, "%s:\n",ln);
      if (system(ln) != 0)
      {
         fprintf(stderr, "ERROR IN COMMAND: %s", ln);
         fprintf(stderr, "   PROPOSED FILENAME: %s\n", fnam);
         sprintf(ln, "rm -f %s\n", fnam);
         system(ln);
         exit(-1);
      }
   }
   t0 = *((double*)ReadResultsFile(0, 3, fnam));
   fprintf(stdout, 
"   pre=%c, muladd=%d, lat=%d, pf=%d, nb=%d, mu=%d, nu=%d, ku=%d, mflop=%.2f\n",
           pre, MULADD, lat, pfA, NB, mu, nu, ku, t0);
   return(t0);
}

double mmcase0(char *nam, char pre, char *loopO, char ta, char tb, 
              int M, int N, int K, int mb, int nb, int kb, 
              int lda, int ldb, int ldc, int mu, int nu, int ku, 
              int muladd, int pfA, int lat, int beta, int csA, int csB, int csC,
              int FFetch, int ifetch, int nfetch, char *mmnam)
{
   char fnam[128], ln[512], bnam[16], casnam[128], mmcase[128];
   int i, N0, lda2=lda, ldb2=ldb, ldc2=ldc;
   double mflop[NTIM], t0;
   FILE *fp;

   if (lda < 0) { lda2 = -lda; lda = 0; }
   if (ldb < 0) { ldb2 = -ldb; ldb = 0; }
   if (ldc < 0) { ldc2 = -ldc; ldc = 0; }
   if (mmnam) sprintf(mmcase, "mmucase mmrout=%s", mmnam);
   else sprintf(mmcase, "mmcase");
   if (ifetch == -1 || nfetch == -1) { ifetch = mu+nu; nfetch = 1; }
   if (beta == 1) sprintf(bnam, "_b1");
   else if (beta == -1) sprintf(bnam, "_bn1");
   else if (beta == 0) sprintf(bnam, "_b0");
   else sprintf(bnam, "_bX");
   N0 = Mmax(M,N);
   if (N0 < K) N0 = K;
   if (ku > K) ku = K;
   else if (ku == -1) ku = K;
   if (nam)
   {
      strcpy(fnam, nam);
      sprintf(casnam, "casnam=%s", nam);
   }
   else
   {
      sprintf(fnam, 
              "res/%c%smm%c%c%d_%dx%dx%d_%dx%dx%d_%dx%dx%d%s%s_%dx%d_%d_pf%d",
              pre, loopO, ta, tb, N0, mb, nb, kb, lda, ldb, ldc, mu, nu, ku, 
              "_a1", bnam, muladd, lat, 1, pfA);
      casnam[0] = '\0';
   }
   if (!FileExists(fnam))
   {
      if (pre == 'c' || pre == 'z')
         sprintf(ln,
" make %s pre=%c loopO=%s ta=%c tb=%c M=%d N=%d K=%d mb=%d nb=%d kb=%d lda=%d ldb=%d ldc=%d lda2=%d ldb2=%d ldc2=%d mu=%d nu=%d ku=%d alpha=%d beta=%d muladd=%d lat=%d cleanup=%d csA=%d csB=%d csC=%d ff=%d if=%d nf=%d pfA=%d %s > /dev/null 2>&1\n",
                 mmcase,pre, loopO, ta, tb, M, N, K, mb, nb, kb, lda, ldb, ldc, 
                 lda2, ldb2, ldc2, mu, nu, ku, 1, beta, muladd, lat, 1, 
                 csA, csB, csC, FFetch, ifetch, nfetch, pfA, casnam);
      else sprintf(ln,
" make %s pre=%c loopO=%s ta=%c tb=%c M=%d N=%d K=%d mb=%d nb=%d kb=%d lda=%d ldb=%d ldc=%d lda2=%d ldb2=%d ldc2=%d mu=%d nu=%d ku=%d alpha=%d beta=%d muladd=%d lat=%d cleanup=%d ff=%d if=%d nf=%d pfA=%d %s > /dev/null 2>&1\n",
                   mmcase, pre, loopO, ta, tb, M, N, K, mb, nb, kb, lda, ldb,
                   ldc, lda2, ldb2, ldc2, mu, nu, ku, 1, beta, muladd, lat, 1, 
                   FFetch, ifetch, nfetch, pfA, casnam);
@skip      fprintf(stderr, "%s:\n",ln);
      if (system(ln) != 0)
      {
/*
 *       User cases, and large leading dimensions can fail to run
 */
         if (mmnam) return(-1.0);  /* user cases can fail to compile */
         if (lda2 != lda || ldb2 != ldb || ldc2 != ldc) return(-1);
         fprintf(stderr, "Error in command: %s", ln);
         sprintf(ln, "rm -f %s\n", fnam);
         system(ln);
         exit(-1);
      }
   }
   t0 = *((double*)ReadResultsFile(0, 3, fnam));
   fprintf(stdout, 
"   pre=%c, loopO=%s, ta=%c tb=%c, mb=%d, nb=%d, kb=%d, lda=%d, ldb=%d, ldc=%d\n",
           pre, loopO, ta, tb, mb, nb, kb, lda, ldb, ldc);
  fprintf(stdout, "   mu=%d, nu=%d, ku=%d, muladd=%d, lat=%d ====> mflop=%f\n",
          mu, nu, ku, muladd, lat, t0);
   return(t0);
}

double mmucase(int ifile, char pre, int nb, int muladd, int lat, 
               int mu, int nu, int ku, char *fnam)
{
   char fout[64];
   int iff;

   sprintf(fout, "res/%cuser%d", pre, ifile);
   if (mu == 1 && nu == 1) iff = 1;
   else iff = mu + nu;
   return(mmcase0(fout, pre, "JIK", 'T', 'N', nb, nb, nb, nb, nb, nb, 
                  nb, nb, 0, mu, nu, ku, muladd, 0, lat, 1, 1, 1, 2, 0, iff, 1,
                  fnam));
}

enum CW {CleanM=0, CleanN=1, CleanK=2, CleanNot=3};
double mmclean(char pre, enum CW which, char *loopO, char ta, char tb, 
               int M, int N, int K, int mb, int nb, int kb, 
               int lda, int ldb, int ldc, int mu, int nu, int ku, 
               int muladd, int pfA, int lat, int beta, int csA, int csB, 
               int csC, int FFetch, int ifetch, int nfetch)
{
   char nam[128];
   char cwh[3] = {'M', 'N', 'K'};
   sprintf(nam, "res/%cClean%c_%dx%dx%d", pre, cwh[which], M, N, K);
   return(mmcase0(nam, pre, loopO, ta, tb, M, N, K, mb, nb, kb, lda, ldb, ldc,
                  mu, nu, ku, muladd, pfA, lat, beta, csA, csB, csC, 
                  FFetch, ifetch, nfetch, NULL));
}

double mmcase(char *nam, char pre, char *loopO, char ta, char tb, 
              int M, int N, int K, int mb, int nb, int kb, 
              int lda, int ldb, int ldc, int mu, int nu, int ku, 
              int muladd, int pfA, int lat, int beta, 
              int csA, int csB, int csC, int FFetch, int ifetch, int nfetch)
{
   return(mmcase0(nam, pre, loopO, ta, tb, M, N, K, mb, nb, kb, lda, ldb, ldc,
                  mu, nu, ku, muladd, pfA, lat, beta, csA, csB, csC, 
                  FFetch, ifetch, nfetch, NULL));
}

@ROUT gmmsearch mmsearchN
@extract -b @(topd)/cw.inc lang=C -def cwdate 2010
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include "atlas_misc.h"
#include "atlas_mmtesttime.h"

@ROUT gmmsearch
#define MAXLAT 6
@ROUT mmsearch gmmsearch
int GetGoodLat(int MULADD, int kb, int mu, int nu, int ku, int lat)
{
   int slat, blat, i, ii = mu*nu*ku;
   if (MULADD) return(lat);
   if ( (lat > 1) && (kb > ku) && ((ii/lat)*lat != ii) )  /* lat won't work */
   {
      for (i=lat; i; i--) if ( (ii/i) * i == ii ) break;
      slat = i;
      for (i=lat; i < MAXLAT; i++) if ( (ii/i) * i == ii ) break;
      blat = i;
      if ( (ii/blat)*blat != ii ) blat = slat;
@skip fprintf(stderr, "\n\n !! kb=%d, mu=%d, nu=%d, ku=%d, lat=%d, slat=%d, blat=%d ", kb, mu, nu, ku, lat, slat, blat);
      if (slat < 2) lat = blat;
      else if (lat-slat < blat-lat) lat = slat;
      else lat = blat;
   }
@skip fprintf(stderr, "returning %d !!\n\n", lat);
   return(lat);
}

@ROUT mmsearch gmmsearch
int GetUniqueMuNus(int nregs, int muladd, int lat, int *mus, int *nus)
/*
 * RETURNS: number of unique MU,NU combos; always allow at least 1x1
 */
{
   int i, j, k, n=0;

   for (j=1; j <= nregs; j++)
   {
      for (i=1; i <= nregs; i++)
      {
         k = (muladd) ? 0 : lat;
         if ((i != 1 || j != 1) && i*j+i+1+k > nregs) continue;
         if (mus)
         {
            mus[n] = i;
            nus[n] = j;
         }
         n++;
      }
   }
   return(n);
}

#ifdef DEBUG
void PrintMUNUs(int N, int *mus, int *nus, double *fpls)
{
   int i;
   for (i=0; i < N; i++)
   {
      if (fpls)
         printf("%3d. MU=%d, NU=%d, fpl=%.3f\n", i, mus[i], nus[i], fpls[i]);
      else
         printf("%3d. MU=%d, NU=%d\n", i, mus[i], nus[i]);
   }
}
#endif

void SortByFlpLd(int N, int *mus, int *nus, double *FPL)
/*
 * Simple selection sort, sorting from best (greatest) flops/load to worst
 * ties in mflop are broken by taking the most square one, and if they
 * are equally square, then take the one with the bigger mu.
 */
{
   int i, j, imax, mindim, mindimB;
   double fpl, fplB;

   #ifdef DEBUG
      printf("\nUNSORTED:\n");
      PrintMUNUs(N, mus, nus, NULL);
   #endif
   for (i=0; i < N-1; i++)
   {
      imax = i;
      mindimB = (mus[i] <= nus[i]) ? mus[i] : nus[i];
      fplB = (2.0 * mus[i] * nus[i]) / (mus[i] + nus[i]);
      for (j=i+1; j < N; j++)
      {
          fpl = (2.0 * mus[j] * nus[j]) / (mus[j] + nus[j]);
          if (fpl > fplB)
          {
             imax = j;
             fplB = fpl;
             mindimB = (mus[j] <= nus[j]) ? mus[j] : nus[j];
          }
          else if (fpl == fplB)
          {
             mindim = (mus[j] <= nus[j]) ? mus[j] : nus[j];
             if (mindim > mindimB)
             {
                imax = j;
                mindimB = mindim;
             }
/*
 *           For symmetric shapes, choose the one with a bigger mu
 */
             else if (mindim == mindimB)
             {
                if (mus[j] > mindim)
                   imax = j;
             }
          }
      }
      if (imax != i)
      {
          j = mus[i];
          mus[i] = mus[imax];
          mus[imax] = j;
          j = nus[i];
          nus[i] = nus[imax];
          nus[imax] = j;
      }
      if (FPL)
         FPL[i] = fplB;
   }
   FPL[i] = (2.0 * mus[i] * nus[i]) / (mus[i] + nus[i]);
   #ifdef DEBUG
      printf("\n\nSORTED:\n");
      PrintMUNUs(N, mus, nus, FPL);
   #endif
}

#define LOWBOUND 0.6857
void GetMuNus(int nregs, int muladd, int lat, int *NGOOD, int *N0,
              int **mus, int **nus, double **fpls)
{
   int N, i;
   double fplB, *f;

   N = GetUniqueMuNus(nregs, muladd, lat, NULL, NULL);
   *mus = malloc(N*sizeof(int));
   *nus = malloc(N*sizeof(int));
   *fpls = malloc(N*sizeof(double));
   assert(*mus && *nus && *fpls);
   GetUniqueMuNus(nregs, muladd, lat, *mus, *nus);
   SortByFlpLd(N, *mus, *nus, *fpls);
   f = *fpls;
   fplB = LOWBOUND * f[0];
   for (i=1; i < N && f[i] >= fplB; i++);
   *NGOOD = i;
   *N0 = N;
}

int GetSafeGoodMuNu(int nreg, int muladd, int lat, 
                    int N, int *mus, int *nus, double *fpls)
/*
 * Find the good value to compare agains the "bad" ones; should be safe on not
 * overflowing registers
 * NOTE : assumes mus/nus already sorted by flops/load
 */
{
   int k, i;
   k = (muladd) ? 0 : lat;
   for (i=0; i < N; i++)
      if (mus[i]*nus[i]+mus[i]+nus[i]+k+4 <= nreg) 
         return(i);
   return(0);
}

void GetSafeMUNU(int nreg, int muladd, int lat, int *MU, int *NU)
{
   int N, Ng, i;
   int *mus, *nus;
   double *fpls;

   GetMuNus(nreg, muladd, lat, &Ng, &N, &mus, &nus, &fpls);
   i = GetSafeGoodMuNu(nreg, muladd, lat, N, mus, nus, fpls);
   *MU = mus[i];
   *NU = nus[i];
   free(mus);
   free(nus);
   free(fpls);
}
@ROUT mmsearch

@beginskip
int main(int nargs, char **args)
{
   int nreg=32, muladd=1, lat=4, ngood, ntot, i, k, icomp;
   int *mus, *nus;
   double *fpls;

   if (nargs > 1)
      nreg = atoi(args[1]);
   if (nargs > 2)
      muladd = atoi(args[2]);
   if (nargs > 3)
      lat = atoi(args[3]);

   GetMuNus(nreg, muladd, lat, &ngood, &ntot, &mus, &nus, &fpls);
   for (i=0; i < ntot; i++)
      printf("%3d. MU=%d, NU=%d, flops/load = %f\n", i,mus[i], nus[i], fpls[i]);
/*
 * Find the good value to compare agains the "bad" ones; should be safe on not
 * overflowing registers
 */
   k = (muladd) ? 0 : lat;
   for (i=0; i < ntot; i++)
      if (mus[i]*nus[i]+mus[i]+nus[i]+k+4 <= nreg) 
         break;
   printf("\nN=%d, NGOOD=%d (%.2f%%), icomp=%d\n", 
          ntot, ngood, (100.0*ngood)/ntot, i);
   return(0);
}
@endskip

void FindMUNU(int muladd,  /* 0: use separate multiply and add inst */
              int lat,     /* pipe len for muladd=0 */
              int nr,      /* # of registers available */
              int FullTest, /* 0: use shortcut if available */
              int *MU,     /* suggested MU */
              int *NU)     /* suggested NU */
/*
 * Find near-square muxnu using nr registers or less
 */
{
   int i, j, mu, nu, Ng, N;
   int *mus, *nus;
   double *fpls;

   if (nr < 1)
   {
      *MU = lat;
      *NU = 1;
      return;
   }
   if (muladd) j = nr;
   else j = nr - lat;
   if (j < 3) mu = nu = 1;
   else
   {
/*
 *    For x86, two-operand assembler means 1-D case almost certainly best
 */
      #ifdef TWO_OP_ASM
          if (!FullTest)
          {
             #ifdef ATL_USE64BITS
                mu = 8;
                mu = ((8+lat-1)/lat)*lat;
                if (mu > 12)
                   mu = Mmin(lat, 8);
                nu = 1;
             #else
                if (lat > 2) mu = lat;
                else mu = 4;
                nu = 1;
             #endif
          }
          else {
      #endif
         GetMuNus(nr, muladd, lat, &Ng, &N, &mus, &nus, &fpls);
         i = GetSafeGoodMuNu(nr, muladd, lat, N, mus, nus, fpls);
         mu = mus[i];
         nu = mus[i];
         free(mus);
         free(nus);
         free(fpls);
@beginskip
         mu = j + 1;
         for (nu=1; nu*nu < mu; nu++);
         if (nu*nu > mu) nu -= 2;
         else nu--;
         if (nu < 1) mu = nu = 1;
         else
         {
            mu = (nr-nu) / (1+nu);
            if (mu < 1) mu = 1;
         }
         if (mu < nu)
         {
            j = mu;
            mu = nu;
            nu = j;
         }
@endskip
      #ifdef TWO_OP_ASM
      }
      #endif
   }
   *MU = mu;
   *NU = nu;
}

@ROUT mmsearch ummsearch
void PutInstLogLine(FILE *fp, int muladd, int pfA, int lat, int nb, 
                    int mu, int nu, int ku, int ForceFetch, 
                    int ifetch, int nfetch, double mflop)
{
   fprintf(fp, "%6d  %3d %4d %3d %3d %3d %3d  %5d  %5d  %5d  %7.2lf\n",
           muladd, lat, pfA, nb, mu, nu, ku, ForceFetch, ifetch, nfetch, mflop);
}

void PutInstLogFile(FILE *fp, int muladd, int pfA, int lat, int nb, 
                    int mu, int nu, int ku, int ForceFetch, 
                    int ifetch, int nfetch, double mflop)
{
   fprintf(fp, 
   "MULADD  LAT  PREF NB  MU  NU  KU  FFTCH  IFTCH  NFTCH    MFLOP\n");
   PutInstLogLine(fp, muladd, pfA, lat, nb, mu, nu, ku, ForceFetch, 
                  ifetch, nfetch, mflop);
}

void PutInstLogFile1(char *fnam, char pre, int muladd, int pfA, int lat,
                     int nb, int mu, int nu, int ku, 
                     int ForceFetch, int ifetch, int nfetch, double mflop)
{
   FILE *fp;

   fp = fopen(fnam, "w");
   assert(fp);
   PutInstLogFile(fp, muladd, pfA, lat, nb, mu, nu, ku, ForceFetch, ifetch,
                  nfetch, mflop);
   fclose(fp);
}

void GetInstLogLine(FILE *fp, int *muladd, int *pfA, int *lat, int *nb, 
                    int *mu, int *nu, int *ku, int *ForceFetch,
                    int *ifetch, int *nfetch, double *mflop)
{
   assert(fscanf(fp, " %d %d %d %d %d %d %d %d %d %d %lf\n",
                 muladd, lat, pfA, nb, mu, nu, ku, ForceFetch, 
                 ifetch, nfetch, mflop) == 11);
}

void GetInstLogFile(char *nam, char pre, int *muladd, int *pfA, int *lat, 
                    int *nb, int *mu, int *nu, int *ku, int *ForceFetch,
                    int *ifetch, int *nfetch, double *mflop)
{
   char ln[128];
   FILE *fp;

   fp = fopen(nam, "r");
   if (fp == NULL) fprintf(stderr, "file %s not found!!\n\n", nam);
   assert(fp);
   fgets(ln, 128, fp);
   GetInstLogLine(fp, muladd, pfA, lat, nb, mu, nu, ku, ForceFetch, 
                  ifetch, nfetch, mflop);
   fclose(fp);
}
@ROUT mmsearch

void CreateFinalSumm(char pre, int muladd, int pfA, int lat, int nb, int mu,
                     int nu, int ku, int Ff, int If, int Nf, double gmf)
{
   char ln[64], auth[65];
   FILE *fp, *fp0;
   int icase, unb;
   double umf;

   sprintf(ln, "res/%cMMRES", pre);
   fp = fopen(ln, "w");
   PutInstLogFile(fp, muladd, pfA, lat, nb, mu, nu, ku, Ff, If, Nf, gmf);
   sprintf(ln, "res/%cuMMRES", pre);
   fp0 = fopen(ln, "r");
   assert(fp0);
   assert(fgets(ln, 64, fp0));
   assert(fscanf(fp0, " %d %d %lf \"%[^\"]\" \"%[^\"]", &icase, &unb, &umf,
                 ln, auth) == 5);
   fclose(fp0);
   fprintf(fp, "\nICASE  NB    MFLOP  ROUT  AUTHOR\n");
   fprintf(fp, "%5d %3d %8.2f  \"%.63s\" \"%.63s\"\n", icase, unb, umf,
           ln, auth);
   fclose(fp);
}


void FindFetch(char ta, char tb, char pre, int mb, int nb, int kb, 
               int mu, int nu, int ku, int muladd, int pfA, int lat,
               int *FFetch0, int *ifetch0, int *nfetch0)
/*
 * See what fetch patterns are appropriate
 */
{
   char fnam[128];
   const int nelts = mu+nu;
   int csA=1, csB=1, csC=1, nleft, i, j;
   int ifetch = mu+nu, nfetch = 1;
   double mf, mf0;

   if (pre == 'c' || pre == 'z') csC = 2;

   mf0 = mmcase(NULL, pre, "JIK", ta,  tb, mb, nb, kb, mb, nb, kb, 
                kb, kb, 0, mu, nu, ku, muladd, pfA, lat, 0, csA, csB, csC, 
                0, ifetch, nfetch);

   for (i=2; i < nelts; i++)
   {
      nleft = nelts - i;
      for (j=1; j <= nleft; j++)
      {
         sprintf(fnam, "res/%cMMfetch%d_%d", pre, i, j);
         mf = mmcase(fnam, pre, "JIK", ta,  tb, mb, nb, kb, mb, nb, kb, 
                     kb, kb, 0, mu, nu, ku, muladd, pfA, lat, 0, csA, csB, csC, 
                     0, i, j);
         if (mf > mf0)
         {
            mf = mf0;
            ifetch = i;
            nfetch = j;
         }
      }
   }
/*
 * See if prefetching good idea for beta=0 case
 */
   sprintf(fnam, "res/%cMM_b0", pre);
   mf0 = mmcase(fnam, pre, "JIK", ta,  tb, mb, nb, kb, mb, nb, kb, 
                kb, kb, 0, mu, nu, ku, muladd, pfA, lat, 0, csA, csB, csC, 
                0, ifetch, nfetch);

   sprintf(fnam, "res/%cMM_b0_pref", pre);
   mf = mmcase(fnam, pre, "JIK", ta,  tb, mb, nb, kb, mb, nb, kb, 
               kb, kb, 0, mu, nu, ku, muladd, pfA, lat, 0, csA, csB, csC, 
               1, ifetch, nfetch);

   *FFetch0 = (mf > mf0);
   *ifetch0 = ifetch;
   *nfetch0 = nfetch;
   fprintf(stdout, "\n\nFORCEFETCH=%d, IFETCH = %d, NFETCH = %d\n\n",
           *FFetch0, *ifetch0, *nfetch0);
}

void kucases(char pre, int muladd, int nb, int mu, int nu, int pfA, int LAT, 
             int Fku, double *mfB, int *nbB, int *muB, int *nuB, int *kuB, 
             int *latB)
{
   double mf;
   int ku, lat;

   if (Fku == -1 || !Fku) ku = nb;
   else ku = Fku;
   if (ku != nb) lat = GetGoodLat(muladd, nb, mu, nu, ku, LAT);
   else lat = LAT;
   mf = mms_case(pre, muladd, nb, mu, nu, ku, pfA, lat);
   if (mf > *mfB)
   {
      *mfB = mf;
      *nbB = nb;
      *muB = mu;
      *nuB = nu;
      *kuB = ku;
      *latB = lat;
   }
   if (!Fku)
   {
      lat = GetGoodLat(muladd, nb, mu, nu, 1, LAT);
      mf = mms_case(pre, muladd, nb, mu, nu, 1, pfA, lat);
      if (mf > *mfB)
      {
         *mfB = mf;
         *nbB = nb;
         *muB = mu;
         *nuB = nu;
         *kuB = 1;
         *latB = lat;
      }
   }
}

@beginskip
void searchnu_nu(char pre, int nb, int maxreg, int Fku, int muladd, int pfA,
                 int LAT, int NO1D, double *mfB, int *nbB, int *muB, int *nuB,
                 int *kuB, int *latB)
/*
 * For large number of registers, search only the near-square cases
 */
{
   int i, k, mu, nu, lat;
   double mf;

   for (k=16; k <= maxreg; k += 4)
   {
      for (nu=1; nu*nu < k; nu++);
      nu--;
      mu = k / nu;
      kucases(pre, muladd, nb, mu, nu, pfA, LAT, Fku, 
              mfB, nbB, muB, nuB, kuB, latB);
      if (mu != nu)  /* reverse them */
         kucases(pre, muladd, nb, nu, mu, pfA, LAT, Fku, 
                 mfB, nbB, muB, nuB, kuB, latB);
   }
}
@endskip

@beginskip
#ifdef TWO_OP_ASM
void searchmu_nu(char pre, int nb, int maxreg, int Fku, int muladd, int pfA,
                 int LAT, int NO1D, double *mfB, int *nbB, int *muB, int *nuB,
                 int *kuB, int *latB)
/*
 * For two-op assembly machines, search only 1-D register blockings
 */
{
   int i, n, nreg=Mmin(nb, maxreg);
   for (i=1; i <= nreg; i++)
   {
      kucases(pre, muladd, nb, i, 1, pfA, LAT, Fku, mfB, nbB, 
              muB, nuB, kuB, latB);
      if (i != 1)
         kucases(pre, muladd, nb, 1, i, pfA, LAT, Fku, mfB, nbB, 
                 muB, nuB, kuB, latB);
   }
}

/*
 * > 2 op machine can benefit from 2-D register blockings
 */
#else
@endskip
@beginskip
void searchmu_nu(char pre, int nb, int maxreg, int Fku, int muladd, int pfA,
                 int LAT, int NO1D, double *mfB, int *nbB, int *muB, int *nuB,
                 int *kuB, int *latB)
{
   int i, j, lat, ku, nr2, nreg=Mmin(nb, maxreg);
   double mf;

   printf("\nSEARCHING FOR GOOD MU/NU SETTINGS (%.2f):\n", *mfB);
   printf("   nb=%d, maxreg=%d, Fku=%d, muladd=%d, pfA=%d, lat=%d NO1D=%d\n\n",
          nb, maxreg, Fku, muladd, pfA, LAT, NO1D);
/*
 * For large number of registers, search only near-square cases
 */
   if (maxreg > 64)
   {
      searchnu_nu(pre, nb, maxreg, Fku, muladd, pfA, LAT, NO1D, mfB, nbB, muB, 
                  nuB, kuB, latB);
      return;
   }
   for (i=1; i <= nreg; i++)
   {
      nr2 = maxreg / i;
      if (nr2 > nb) nr2 = nb;
      for (j=1; j <= nreg; j++)
      {
         if ( (((i==1) && (j > 4)) || ((j==1) && (i > 4))) && NO1D) continue;
         lat = GetGoodLat(muladd, nb, i, j, ku, LAT);
         lat = Mmin(lat, LAT);
         if (i*j+i+j+(!muladd)*lat < maxreg)
            kucases(pre, muladd, nb, i, j, pfA, LAT, Fku, 
                    mfB, nbB, muB, nuB, kuB, latB);
      }
   }
   printf("\nDONE MU/NU SEARCH, NB=%d, MU=%d, NU=%d KU=%d, LAT=%d (%.2f)\n\n", 
          *nbB, *muB, *nuB, *kuB, *latB, *mfB);
}
@skip #endif
@endskip

void searchmu_nu
(
   char pre, 
   int nb, 
   int maxreg, /* # of registers usuable at once */
   int Fku,    /* 0: try KU=1&NB, else try only ku=Fku */
   int muladd, /* 0: machine lacks multiply & accumulate inst */
   int pfA,    /* prefetch setting */
   int LAT,    /* latency */
   int NO1D,   /* unused variable */
   /* best parameters found, init on entry, possibly changed on exit */
   double *mfB, int *nbB, int *muB, int *nuB, int *kuB, int *latB
)
{
   int N, Ng, i, j;
   int *mus, *nus;
   double mf, mfG, mf0;
   double *fpls;
   printf("\nTUNING MU & NU:\n");
/*
 * For the x86, always try some 1-D cases
 */
   #ifdef TWO_OP_ASM
      kucases(pre, muladd, nb, 6, 1, pfA, LAT, Fku, 
              mfB, nbB, muB, nuB, kuB, latB);
      kucases(pre, muladd, nb, 4, 1, pfA, LAT, Fku, 
              mfB, nbB, muB, nuB, kuB, latB);
      #ifdef ATL_USE64BITS
         kucases(pre, muladd, nb, 8, 1, pfA, LAT, Fku, 
                 mfB, nbB, muB, nuB, kuB, latB);
         kucases(pre, muladd, nb, 10, 1, pfA, LAT, Fku, 
                 mfB, nbB, muB, nuB, kuB, latB);
         kucases(pre, muladd, nb, 12, 1, pfA, LAT, Fku, 
                 mfB, nbB, muB, nuB, kuB, latB);
      #endif
   #endif
/*
 * Find all possible Mu/Nu combos.  Only the first Ng of these should
 * be competitive performance-wise.
 */
   GetMuNus(maxreg, muladd, LAT, &Ng, &N, &mus, &nus, &fpls);
/*
 * If we get roughly as good a performance out of using only half the
 * registers available, the compiler is so screwing things up that we'd
 * better search the entire space
 */
   i = GetSafeGoodMuNu(maxreg, muladd, LAT, N, mus, nus, fpls);
   j = GetSafeGoodMuNu(maxreg/2, muladd, LAT, N, mus, nus, fpls);
   mfG = mms_case(pre, muladd, nb, mus[i], nus[i], nb, pfA, LAT);
   mf  = mms_case(pre, muladd, nb, mus[i], nus[i], 1, pfA, 
                  GetGoodLat(muladd, nb, mus[i], nus[i], 1, LAT));
   mfG = Mmax(mfG, mf);
   mf0 = mms_case(pre, muladd, nb, mus[j], nus[j], nb, pfA, LAT);
   mf  = mms_case(pre, muladd, nb, mus[j], nus[j], 1, pfA, 
                  GetGoodLat(muladd, nb, mus[i], nus[i], 1, LAT));
   mf = Mmax(mf0, mf);
   if (mf*1.02 >= mfG)
   {
      fprintf(stderr, "%d:USING HALF THE REGISTERS GETS YOU %.2f, FULL=%.2f!\n",
              __LINE__, mf, mfG);
      if (maxreg >= 64 && mf > mfG)
      {
         if (mf > mfG)
         {
            free(mus);
            free(nus);
            free(fpls);
            i = (maxreg+maxreg)/3;
            assert(i);
            fprintf(stderr, "   %d:CHANGING #REGS FROM %d TO %d!!\n", 
                    __LINE__, maxreg, i);
            searchmu_nu(pre, nb, i, Fku, muladd, pfA, LAT, NO1D,
                        mfB, nbB, muB, nuB, kuB, latB);
            return;
         }
      }
      else
      {
         fprintf(stderr, "  %d:DOING FULL MU/NU SEARCH!\n", __LINE__);
         Ng = N;
      }
   }
   for (i=0; i < Ng; i++)
      kucases(pre, muladd, nb, Mmin(nb,mus[i]), Mmin(nb,nus[i]), pfA, LAT, Fku, 
              mfB, nbB, muB, nuB, kuB, latB);
   free(mus);
   free(nus);
   free(fpls);
   printf("BEST MU=%d, NU=%d\n", *muB, *nuB);
}

void FindKU(char pre, int muladd, int pfA, int LAT, int nb, int mu, int nu,
            double *mfB, int *kuB, int *latB)
/*
 * For best case, try various ku's
 */
{
   int k, lat, size, linesize;
   double mf;
  
   fprintf(stdout, "\nCONFIRMING K-LOOP UNROLLING FOR CHOSEN NB:\n");
   printf("   pre=%c, nb=%d, mu=%d, nu=%d, muladd=%d, pfA=%d (%.2f)\n\n",
          pre, nb, mu, nu, muladd, pfA, *mfB);
   mf = mms_case(pre, muladd, nb, mu, nu, nb, pfA, LAT);
   if (mf > *mfB)
   {
      *kuB = nb;
      *mfB = mf;
      *latB = LAT;
   }
/*
 * Try 2, 4, 6, 8
 */
   for (k=2; k < 8; k += 2)
   {
      lat = GetGoodLat(muladd, nb, mu, nu, k, *latB);
      mf = mms_case(pre, muladd, nb, mu, nu, k, pfA, lat);
      if (mf > *mfB)
      {
         *latB = lat;
         *kuB = k;
         *mfB = mf;
      }
   }
/*
 * Try all unrollings between cache-line size and nb/2, in multiples of
 * the cacheline size
 */
   if (pre == 's' || pre == 'c')
      linesize = ATL_L1LS / sizeof(float);
   else
      linesize = ATL_L1LS / sizeof(double);
   if (linesize < 4) linesize = 4;
   for (k=linesize; k < nb; k += linesize)
   {
      if (k >= nb/2) k = nb;
      lat = GetGoodLat(muladd, nb, mu, nu, k, *latB);
      mf = mms_case(pre, muladd, nb, mu, nu, k, pfA, lat);
      if (mf > *mfB)
      {
         *latB = lat;
         *kuB = k;
         *mfB = mf;
      }
   }
   printf("K-LOOP UNROLLING SELECTED: %d (%.2f)\n\n", *kuB, *mfB);
}

void FindLAT(char pre, int pfA, int maxlat, int nb, int muladd, 
             int mu, int nu, int ku, double *mfB, int *latB)

{
   int i, lat;
   double mf;
/*
 * Right now, search does not do accumulator expansion for small (mu, nu),
 * so there is no need to search for MAC
 */
   if (muladd) return;

   fprintf(stderr, "\nCONFIRMING LATENCY FACTOR FOR CHOSEN PARAMETERS:\n");
   for (i=1; i <= maxlat; i++)
   {
      lat = GetGoodLat(muladd, nb, mu, nu, ku, i);
      if (lat == i)
      {
         mf = mms_case(pre, muladd, nb, mu, nu, ku, pfA, lat);
         if (mf > *mfB)
         {
            *mfB = mf;
            *latB = i;
         }
      }
   }
   printf("\n\n   BEST LATENCY FACTOR=%d, (%.2f)\n\n", *latB, *mfB);
}

int ProbeLatency(char pre, int nr, int nb, int muladd, int mu, int nu)
/*
 * Finds a good setting for latency, assuming mu*nu > pipeline.  Uses
 * the minimum latency that gets good performance.  If latency has no
 * real affect on performance, returns latency of 1 (to avoid multiple probs
 * and minimize register waste)
 */
{
   int maxlat, i;
   double mf0, mf;

   if (muladd) return(1);
   maxlat = Mmin(nr/2, 16);
/*
 * Try latencies between 1 and 16, stopping anytime performance does not
 * improve; always unroll loop all way to help avoid having compiler pipeline
 * and so that all lats can be tried
 */
   fprintf(stderr, "\nPROBING FOR A GOOD LATENCY VALUE:\n");
   mf0 = mms_caseIC(pre, 0, nb, mu, nu, nb, 0, 1);
   fprintf(stderr, "   lat = %d, mf=%.2f\n", 1, mf0);
   for (i=2; i <= maxlat; i++)
   {
      mf = mms_caseIC(pre, 0, nb, mu, nu, nb, 0, 1);
      fprintf(stderr, "   lat = %d, mf=%.2f\n", i, mf);
      if (mf < mf0*1.01) /* w/o 1% improvement, latency not worth increasing */
         break;
      mf0 = mf;
   }
   i--;
   fprintf(stderr, "LATENCY %d (%.2f) SELECTED!\n", i, mf);
   return(i);
}

@ROUT Mylcm mmsearch
static int Mylcm(const int M, const int N)
/*
 * Returns least common multiple (LCM) of two positive integers M & N by
 * computing greatest common divisor (GCD) and using the property that
 * M*N = GCD*LCM.
 */
{
   register int tmp, max, min, gcd=0;

   if (M != N)
   {
      if (M > N) { max = M; min = N; }
      else { max = N; min = M; }
      if (min > 0)  /* undefined for negative numbers */
      {
         do  /* while (min) */
         {
            if ( !(min & 1) ) /* min is even */
            {
               if ( !(max & 1) ) /* max is also even */
               {
                  do
                  {
                     min >>= 1;
                     max >>= 1;
                     gcd++;
                     if (min & 1) goto MinIsOdd;
                  }
                  while ( !(max & 1) );
               }
               do min >>=1 ; while ( !(min & 1) );
            }
/*
 *          Once min is odd, halve max until it too is odd.  Then, use
 *          property that gcd(max, min) = gcd(max, (max-min)/2) 
 *          for odd max & min
 */
MinIsOdd:
            if (min != 1)
            {
               do  /* while (max >= min */
               {
                  max -= (max & 1) ? min : 0;
                  max >>= 1;
               }
               while (max >= min);
            }
            else return( (M*N) / (1<<gcd) );
            tmp = max;
            max = min;
            min = tmp;
         }
         while(tmp);
      }
      return( (M*N) / (max<<gcd) );
   }
   else return(M);
}
@ROUT mmsearch

static int GuessSmallNB(char pre, int L1Size, int mu, int nu)
/*
 * Returns a small nb useful for in-cache timings
 */
{
   int imult, nb, size;

   size = (pre == 'd' || pre == 'z') ? ATL_dsize : ATL_ssize;
   L1Size /= size;
   imult = Mylcm(mu, nu);
/*
 * Try to get a block factor where A, B & C all fit into cache
 */
   for (nb=imult; 3*nb*nb < L1Size; nb += imult);
   nb -= imult;
/*
 * If block to small, settle for fitting one block comfortably in cache
 */
   if (nb < 28)
   {
      for (; nb*nb+(mu+nu)*nb*2 < L1Size; nb += imult);
      nb -= imult;
   }
   fprintf(stderr, "L1Size=%d, pre=%c, Smallnb=%d\n", L1Size, pre, nb);
   assert(nb);
   return(nb);
}

void ProbeFPU(char pre, int L1Size, int nreg, int *muladd0, int *lat0)
/*
 * Estimates good muladd and latency for matmul
 */
{
   double mf0, mf1;
   int i, mu, nu, muladd_r, lat_r, nb, imult, lat;
   char upre=pre;
   void GetMulAdd(char pre, int *MULADD, int *lat);

   if (pre == 'c') upre = 's';
   else if (pre == 'z') upre = 'd';
/*
 * Get muladd & latency for register-to-register code
 */
   GetMulAdd(upre, &muladd_r, &lat_r);
   FindMUNU(0, lat_r, (nreg > 16) ? nreg-2 : nreg, 0, &mu, &nu);
/*
 * Find good nb to use with these parameters
 */
   nb = GuessSmallNB(pre, L1Size, mu, nu);
/*
 * Compute best latency setting for separate multiply and add
 */
   lat = ProbeLatency(pre, nreg, nb, 0, mu, nu);
/*
 * Get mu,nu and nb to use with real matmul-detected latency
 */
   FindMUNU(0, lat, (nreg > 16) ? nreg-2 : nreg, 0, &mu, &nu);
   nb = GuessSmallNB(pre, L1Size, mu, nu);
/*
 * Time separate and combined mul/add.
 * NOTE: may slightly disadvantage muladd=1 case, as it uses the mu,nu set
 * with muladd=0 (using lat extra regs), but this gives us the same blocking
 * factor.  To offset this, require mf0 by 3% better to avoid using muladd=1
 */
   mf0 = mms_caseIC(pre, 0, nb, mu, nu, nb, 0, lat);
   mf1 = mms_caseIC(pre, 1, nb, mu, nu, nb, 0, lat);
   if (mf0 >= 1.03*mf1)
   {
      *muladd0 = 0;
      *lat0 = lat;
   }
   else
   {
      *muladd0 = 1;
      *lat0 = lat_r;
   }
   fprintf(stdout, "\n\nMATMUL FPU PROBE RESULTS: muladd=%d, lat=%d (%.2f) selected over (%.2f)!!\n",
           *muladd0, *lat0, 
           *muladd0 == 0 ? mf0 : mf1, *muladd0 == 0 ? mf1 : mf0);
}

int GetSelectedNB(char pre)
/*
 * Returns ATLAS's NB.  This will be the best performing of the external
 * searches ran by ummsearch, and the generated files controlled here.
 */
{
   ATL_mmnode_t *mmp;
   int nb;

   mmp = ReadMMFileWithPath(pre, "res", "MMRES.sum");
   assert(mmp);
   nb = mmp->next ? mmp->next->nbB : mmp->nbB;
   KillAllMMNodes(mmp);
   return(nb);
}
int GetNO1D(char pre, int nreg, int nb, int MULADD, int pfA, int LAT)
{
   int lat, NO1D=0;
   double mf0, mf1, mf;

/*
 * Always do 1-D cases for 2-op assembler!
 */
   #ifdef TWO_OP_ASM
      return(0);
   #endif
   if (pre == 'z') pre = 'd';
   else if (pre == 'c') pre = 's';

   lat = GetGoodLat(MULADD, nb, 3, 3, 1, LAT);
   if (nreg >= 15+(!MULADD)*Mmax(LAT,lat))
   {
      mf0 = mms_case(pre, MULADD, nb, 3, 3, 1, pfA, lat);
      mf1 = mms_case(pre, MULADD, nb, 3, 3, nb, pfA, LAT);
      mf = Mmax(mf1, mf0);
      mf0 = mms_case(pre, MULADD, nb, 9, 1, 1, pfA, lat);
      if (mf0 > mf) NO1D = 0;
      else if (mms_case(pre, MULADD, nb, 9, 1, nb, pfA, LAT) > mf) NO1D = 0;
      else if (mms_case(pre, MULADD, nb, 1, 9, nb, pfA, LAT) > mf) NO1D = 0;
      else if (mms_case(pre, MULADD, nb, 1, 9, 1, pfA, lat) > mf) NO1D = 0;
      else NO1D = 1;
   }
   return(NO1D);
}

@beginskip
double VerifyMuladd(char pre,
                    int nreg,    /* number of registers detected */
                    int nb,      /* present blocking factor */
                    int pfA,     /* prefetch or not */
                    int *maB,    /* MULADD set by reg-reg code */
                    int *latB,   /* latency set by reg-reg code */
                    int *muB,    /* best M-loop unrolling */
                    int *nuB,    /* best N-loop unrolling */
                    int *kuB,    /* best K-loop unrolling */
                    int *lat_sens, /* 0: latency does not affect perf */
                    int *MA_sens,  /* 0: both muladd setting perf well */
                   )
/*
 * This routine figures out importance of and decent values for muladd & lat.
 * RETURNS: performance of best case found, returned in the xxB pointers.
 *    lat_sens : 0 perf not latency sensitive (true for muladd=1 when
 *               mu*nu > pipelen, and most tomasulo machines 
 *               [even wt muladd=0]).  This should allow us to use 
 *               minimal lat to save regs.
 *    MA_sens  : whether muladd setting has strong affect on kmm perf.  If
 *               compiler great at software pipelining, or machine supports
 *               both (SGI), or machine does OOE (x86) this is probably true.
 */
{
   int ma0, mu0=0, nu0, ku0, lat0;  /* separate muladd settings */
   int ma1, mu1=0, nu1, ku1, lat1;  /* combined muladd settings */
   int KUisNB;
   double mf0, mf1;
   KUisNB = (*kuB == nb);
   
   if (*maB) /* best case so far is for combined multiply/add */
   {
      ma1 = *maB; mu1 = *muB; nu1 = *nuB; ku1 = *kuB; lat1 = *latB; mf1 = *mfB;
/*
 *    Try muladd=0, varying latency for lat_sens
 *    Try muladd=1 & muladd=0 for MA_sens
 */
   }
   else     /* best case so far is for separate multiply/add */
   {
      ma0 = *maB; mu0 = *muB; nu0 = *nuB; ku0 = *kuB; lat0 = *latB; mf0 = *mfB;
   }
   mf = mms_case(pre, MA, nb, mu, nu, ku, pfA, lat);
}
@endskip

double SearchNBs(char pre,      /* s, d */
                 int MA,        /* muladd */
                 int Fku,/* =0, try both ku=1 and ku=KB, else try only ku=Fku */
                 int nNBs,      /* # of NBs in NB array */
                 int *NBs,      /* array of NBs to search */
                 int mu,        /* M-loop unrolling to use */
                 int nu,        /* N-loop unrolling to use */
                 int pfA,       /* 0: no prefetch of A */
                 int lat,       /* approx latency to enforce */
                 int *latBo,    /* latency used by best kernel */
                 int *kuBo)     /* KU used by best kernel */
/*
 * RETURNS: Mflop of case that got the best performance (best NB is returned
 *          in first position of NBs array).
 */
{
   double mf, mfB;
   int i, j, k, tlat, nb, ku, kuB, latB;

   printf("\nFINDING BEST NB\n\n");
   if (Fku < 0) Fku = 0;
   tlat = lat; kuB = Fku; latB = lat;
   i = 0; mfB = 0.0;
   for (k=0; k != nNBs; k++)
   {
      nb = NBs[k];
      ku = Fku ? Fku : nb;
      mf = mms_case(pre, MA, nb, mu, nu, ku, pfA, lat);
      if (mf > mfB)
      {
         mfB = mf;
         kuB = ku;
         latB = lat;
         i = k;
      }
      if (Fku == 0)  /* try no K-loop unrolling */
      {
         tlat = GetGoodLat(MA, nb, mu, nu, 1, lat);
         mf = mms_case(pre, MA, nb, mu, nu, 1, pfA, tlat);
         if (mf > mfB)
         {
            mfB = mf;
            kuB = 1;
            latB = tlat;
            i = k;
         }
      }
   }
/*
 * Put best-performing NB first in NB array
 */
   if (i)
   {
      j = NBs[i];
      NBs[i] = NBs[0];
      NBs[0] = j;
   }
   printf("NB SEARCH DONE; NB=%d selected (%.2f).\n\n", NBs[0], mfB);
   *kuBo = kuB;
   *latBo = latB;
   return(mfB);
}

void gmmsearch(char pre, int MULADD, int Fku, int nNBs, int *NBs, int nreg,
               int LAT, int Fnb)
/*
 * Does real generated mmsearch
 */
{
   int latB, muB, nuB, kuB, nbB;
   int i, j, k, NB, ku, nb, lat=LAT, nNB=nNBs, NO1D=0;
   int FFetch, ifetch, nfetch, muladd, pfA;
   int ldbot=1;
   double mf, mfB, mf1;
   char ln[32];
   FILE *fp;

   printf("LINE %d of %s\n", __LINE__, __FILE__);
   sprintf(ln, "res/%cgMMRES", pre);
   if (FileExists(ln)) /* already have needed result */
   {
      GetInstLogFile(ln, pre, &muladd, &pfA, &lat, &nb, &muB, &nuB, &kuB, 
                     &FFetch, &ifetch, &nfetch, &mf);
      if (mf <= 0.0)
      {
         mf = mmcase(NULL, pre, "JIK", 'T', 'N', nb, nb, nb, nb, nb, nb,
                     nb, nb, 0, muB, nuB, kuB, muladd, pfA, lat, 1, 1, 1, 2,
                     FFetch, ifetch, nfetch);
         PutInstLogFile1(ln, pre, muladd, pfA, lat, nb, muB, nuB, kuB, FFetch,
                         ifetch, nfetch, mf);
      }
      return;
   }
/*
 * Try not to tempt fate by using all registers
 */
   if (nreg > 16) i = nreg-2;
   else i = nreg;
   FindMUNU(MULADD, lat, i, 0, &muB, &nuB);
/*
 * First, find a good NB, with no prefetch
 */
   pfA = 0;
   mfB = SearchNBs(pre, MULADD,  Fku, nNBs, NBs, muB, nuB, (ldbot<<9),
                   lat, &latB, &kuB);
   nbB = NBs[0];

@beginskip
/*
 * Now make sure latency detected by register-register probe is needed for
 * gemm (will not be for most tomasulo machines)
 */
   lat = ProbeLatency(pre, nreg, nbB, 0, muB, nuB);
   if (lat != latB && !MULADD)
   {
      fprintf(stderr, "Present lat = %d, set to probed lat = %d\n", latB, lat);
      latB = lat; 
      lat = GetGoodLat(MULADD, nbB, muB, nuB, kuB, latB);
      mfB = mms_case(pre, MULADD, nbB, muB, nuB, kuB, 0, lat);
   }

/*
 * Now make sure that register-register MULADD is still a good idea for
 * gemm; unroll K-loop all the way to discourage smart compilers and to
 * allow for optimized lat
 */
   mf = mms_case(pre, 0, nbB, muB, nuB, nbB, 0, lat);
   mf1 = mms_case(pre, 1, nbB, muB, nuB, nbB, 0, lat);
   if (MULADD)
   {
      if (mf > mf1*1.01)   /* possibly switch muladd */
      {
         k = lat;
         lat = GetGoodLat(0, nbB, muB, nuB, kuB, lat);
         mf = mms_case(pre, 0, nbB, muB, nuB, kuB, 0, lat);
         if (mf > mfB*1.01)
         {
            fprintf(stderr, 
"\n\nSwitching from combined to separate mul/add, speedup=%.2f (%.2f,%.2f)\n\n",
                    mf/mfB, mfB, mf);
            mfB = mf;
            MULADD = 0;
            latB = lat;
            LAT = k;
         }
      }
   }
   else
   {
      if (mf1 > mf*1.01)  /* possibly switch muladd */
      {
         mf = mms_case(pre, 1, nbB, muB, nuB, kuB, 0, lat);
         if (mf > mfB)
         {
            fprintf(stderr, 
"\n\nSwitching from separate mul/add to combined, speedup=%.2f (%.2f,%.2f)\n\n",
                    mf/mfB, mfB, mf);
            mfB = mf;
            MULADD = 1;
         }
      }
   }
@endskip
   #ifndef ATL_NOPREFETCH
/*
 *    Now, find if prefetching helps this kernel; may want to user different
 *    NB if prefetch is a win (esp., smaller NB)
 */
      mf  = SearchNBs(pre, MULADD,  Fku, nNBs, NBs, muB, nuB, 1|(ldbot<<9), 
                      lat, &lat, &ku);
      nbB = NBs[0];
      if (mf > mfB)
      {
         fprintf(stdout, "\nPrefetch kernel %.2f faster.\n", mf/mfB);
         mfB = mf;
         latB = lat;
         kuB = ku;
         pfA = 1;
      }
      else fprintf(stdout, "\nNon-prefetch kernel %.2f faster.\n", mfB/mf);
   #endif
/*
 * With whatever the prefetch setting, try reversing load-C-at-top/bottom
 * After this, load-C setting stuck in pfA; give bottom preference due error
 */
   mf = mms_case(pre, MULADD, NBs[0], muB, nuB, kuB, pfA|((!ldbot)<<9), lat);
   if (ldbot? mf > mfB*1.005: mf*1.005 > mfB)
   {
      fprintf(stdout, "\nLoad-C-at-%s kernel %.2f faster.\n", 
              (!ldbot)?"bottom":"top", mf/mfB);
      pfA |= (!ldbot)<<9;
   }
   else
   {
      fprintf(stdout, "\nLoad-C-at-%s kernel %.2f faster.\n", 
              ldbot?"bottom":"top", mfB/mf);
      pfA |= ldbot<<9;
   }

   if (!Fnb) nNB = 1;
   if (MULADD)
      fprintf(stdout, "\nCombined multiply add, latency factor=%d, NB=%d ku=%d, chosen; initial MFLOP=%f.  Beginning unroll search:\n", latB, NBs[0], kuB, mfB);
   else
      fprintf(stdout, "\nSeparate multiply and add, latency factor=%d, NB=%d ku=%d, chosen; initial MFLOP=%f.  Beginning unroll search:\n", latB, NBs[0], kuB, mfB);

   NO1D = GetNO1D(pre, nreg, NBs[0], MULADD, pfA, LAT);
   if (NO1D) fprintf(stdout, "\n\nSkipping most 1D cases\n\n");
   else fprintf(stdout, "\n\nTiming 1D cases\n\n");
   for (k=0; k != nNB; k++)
   {
      NB = NBs[k];
      searchmu_nu(pre, NB, nreg, Fku, MULADD, pfA, LAT, NO1D,
                  &mfB, &nbB, &muB, &nuB, &kuB, &latB);
   }
   fprintf(stdout, "\n\nBest case so far: nb=%d, mu=%d, nu=%d, ku=%d, lat=%d; MFLOPS=%.2f.\n",
           nbB, muB, nuB, kuB, latB, mfB);
   fprintf(stdout, "Trying various other NB and KU settings:\n\n");
/*
 * If we haven't checked all permutations, try other blocking factors
 */
   nb = nbB;
   if (!Fnb)
   {
      if (nNBs > 1) fprintf(stdout, "Trying various blocking factors:\n");
      mf = mms_case(pre, MULADD, NBs[0], muB, nuB, kuB, pfA, latB);
      for (k=0; k < nNBs; k++)
      {
         NB = NBs[k];
         if (Fku == -1) ku = NB;
         else if (Fku) ku = Fku;
         else if (kuB == nbB) ku = NB;
         else ku = kuB;
         if (ku != NB) lat = GetGoodLat(MULADD, NB, muB, nuB, ku, latB);
         else lat = latB;
         mf = mms_case(pre, MULADD, NB, muB, nuB, ku, pfA, lat);
         if (mf > mfB)
         {
            kuB = ku;
            mfB = mf;
            nbB = NB;
            latB = lat;
         }
      }
   }
   if (nb != nbB) fprintf(stdout, "\nNew block factor of %d chosen!!\n\n", nbB);
   NB = nbB;

/*
 * Try all ku's, and then valid latencies
 */
   FindKU(pre, MULADD, pfA, LAT, nbB, muB, nuB, &mfB, &kuB, &latB);
   FindLAT(pre, pfA, MAXLAT, nbB, MULADD, muB, nuB, kuB, &mfB, &latB);

/*
 * Make sure MULADD is correct
 */
   lat = GetGoodLat(!MULADD, nbB, muB, nuB, kuB, latB);
   mf = mms_case(pre, !MULADD, nbB, muB, nuB, kuB, pfA, lat);
   if (mf > mfB*1.02)
   {
      fprintf(stdout, "\n\nMULADD MAY BE WRONG!!, old=%f, new=%f\n", mfB, mf);
      MULADD = !MULADD;
      latB = lat;
      mfB = mf;
   }
/*
 * See if swapping prefetch helps now, bust pfA into ld/pf again
 */
   ldbot = pfA & 512;
   pfA = pfA ^ ldbot;
   #ifndef ATL_NOPREFETCH
      mf = mms_case(pre, MULADD, nbB, muB, nuB, kuB, (!pfA)|ldbot, lat);
      if (mf > mfB*1.01)
      {
         fprintf(stdout, "\n\nPREFETCH SWAPPED TO %d\n\n", pfA);
         pfA = !pfA;
         mfB = mf;
      }
   #endif
/*
 * Try changing load at of C from top to bottom or vice versa; give 
 * load-at-bottom benefit of doubt, since it is the least error-prone
 */
   ldbot >>= 9;
   mf = mms_case(pre, MULADD, nbB, muB, nuB, kuB, pfA|((!ldbot)<<9), lat);
   if (ldbot ? mf > mfB*1.01 : mf*1.01 > mfB)
   {
      ldbot = !ldbot;
      fprintf(stdout, "\n\nSWAPPED TO LOAD-AT-%s\n\n", ldbot?"BOTTOM":"TOP");
      mfB = mf;
   }
   pfA = pfA | (ldbot<<9);

/*
 * Try various fetch patterns
 */
   FindFetch('T', 'N', pre, nbB, nbB, nbB, muB, nuB, kuB, MULADD, pfA, latB,
             &FFetch, &ifetch, &nfetch);
   fprintf(stdout, 
   "BEST GENERATED CASE: nb=%d, ma=%d, lat=%d mu=%d, nu=%d, ku=%d -- %.2f\n",
           nbB, MULADD, latB, muB, nuB, kuB, mfB);
   sprintf(ln, "res/%cgMMRES", pre);
   PutInstLogFile1(ln, pre, MULADD, pfA, latB, nbB, muB, nuB, kuB, 
                   FFetch, ifetch, nfetch, mfB);
   printf("LINE %d of %s\n", __LINE__, __FILE__);
}

@beginskip
/*
 * This not very useful since emit_mm creates only 1 beta at a time.
 * We will gen and time using old-school way
 */
char *GetEmitMMGenStr(char pre, ATL_mmnode_t *mmp)
/*
 * RETURNS: free-able string containing the line to make xemit_mm generate
 *          the kernel described in mmp.
 * NOTE: Assumes xemit_mm already build by makefile dependency.
 * NOTE: if fnam is NULL or empty, then no output redirect is added
 *       (assumed added later).
 */
{
   char ln[2048];
   int i;

   i = sprintf(ln, "./xemit_mm -p %c -l %d -M %d -N %d -K %d ", pre, 
               mmp->lat, mmp->mbB, mmp->nbB, mmp->kbB);
   i += sprintf(ln+i, "-m %d -n %d -k %d -F0 %d -FN %d -FF %d ",
                mmp->mu, mmp->nu, mmp->ku, mmp->iftch, mmp->nftch, mmp->fftch);
   i += sprintf(ln+i, "-csA 1 -csB 1 -csC %d ", 
                (pre == 'c' || pre == 'z') ? 2 : 1);
   sprin
   -csA 1 -csB 1
}
@endskip

void TimeAllKernels
(
   char pre,            /* type/precision prefix */
   int itime,           /* which entry in mflop to overwrite */
   int FORCE,           /* 1: do not accept answer from pre-existing files */
   ATL_mmnode_t *mmb    /* base ptr to list matmul nodes */
)
/*
 * Times all kernels in mmb list
 */
{
   ATL_mmnode_t *mp;
   for (mp = mmb; mp; mp = mp->next)
   {
      if (mp->ID <= 0)  /* generated kernel */
      {
         if (FORCE)
            assert(!system("rm -f res/GENOUT\n"));

         mp->mflop[itime] = mmcase(FORCE ? "res/GENOUT" : NULL, pre,
            FLAG_IS_SET(mp->flag, MMF_AOUTER) ? "IJK" : "JIK",
            mp->TA == AtlasTrans ? 'T' : 'N', mp->TB == AtlasTrans ? 'T' : 'N',
            mp->mbB, mp->nbB, mp->kbB, mp->mbB, mp->nbB, mp->kbB, 
            mp->kbB, mp->kbB, 0, mp->mu, mp->nu, mp->ku, mp->muladd, mp->pref,
            mp->lat, 1, 1, 1, (pre == 'c' || pre == 'z') ? 2 : 1,
            mp->fftch, mp->iftch, mp->nftch);
      }
      else
         mp->mflop[0] = TimeMMKernel(1, FORCE, mp, pre, mp->mbB, mp->nbB, 
                                     mp->kbB, 0, 0, 0, 1, 0, 0);
   }
}

void CreateFinalSumFile
(
   char pre, 
   ATL_mmnode_t *mmG,  /* best emit_mm.c generated file */
   ATL_mmnode_t *mmU   /* NULL or best user-contributed (external) file */
)
{
   char ln[64];
   FILE *fpout;

   sprintf(ln, "res/%cMMRES.sum", pre);
   fpout = fopen(ln, "w");
   assert(fpout);
   if (mmU && mmU->mflop[0] > mmG->mflop[0]*1.03)
   {
      fprintf(fpout, 
      "#\n# Best generated case that matches the selected kernel's NB\n#\n");
      PrintMMLine(fpout, mmG);
      fprintf(fpout, 
              "#\n# Selected main kernel (user-contributed/external)\n#\n");
      PrintMMLine(fpout, mmU);
   }
   else
   {
      fprintf(fpout, 
         "#\n# No user-genned case selected, best from emit_mm.c below.\n#\n");
      PrintMMLine(fpout, mmG);
   }
   fclose(fpout);
}

ATL_mmnode_t *GetOrTransMMRES(char pre)
/*
 * Reads pre-existing file <pre>MMRES.sum, or creates it by translating
 * old-style <pre>MMRES.  If neither file exists, returns NULL
 * NOTE: does not read user-contrib case from this file, since that has
 *       been superceded by <pre>eMMRES.sum
 * RETURNS: list of two kernels.  First is generated kernel from MMRES.sum or
 *          MMRES, 2nd is best user-contrib from MMRES.sum or eMMRES.sum.
 */
{
   char ln[1024];
   ATL_mmnode_t *mmb;

   mmb = ReadMMFileWithPath(pre, "res", "MMRES.sum");
   if (!mmb)
   {
      sprintf(ln, "make res/%cMMRES.sum pre=%c\n", pre, pre);
      assert(system(ln) == 0);
      mmb = ReadMMFileWithPath(pre, "res", "MMRES.sum");
   }
@beginskip
/*
 * If file does not exist, see if there is an old-style MMRES that we can
 * translate
 */
      mmb = GetMMNode();
      ln[10] = '\0';   /* ln = res/<pre>MMRES */
      if (FileExists(ln))
      {
         GetInstLogFile(ln, pre, &mmb->muladd, &mmb->pref, &mmb->lat, &mmb->nbB,
                        &mmb->mu, &mmb->nu, &mmb->ku, &mmb->fftch, &mmb->iftch,
                        &mmb->nftch, mmb->mflop);
         mmb->ID = -1;
         mmb->TA = AtlasTrans;
         mmb->TB = AtlasNoTrans;
         mmb->mbB = mmb->kbB = mmb->nbB;
         if (mmb->ku > (mmb->kbB>>1))
            mmb->ku = mmb->kbB;
         if (mmb->ku == mmb->kbB)
            mmb->kbmin = mmb->kbmax = mmb->ku;
         else
         {
            mmb->kbmin = mmb->ku;
            mmb->kbmax = ((4000)/mmb->ku)*mmb->ku;
            SET_FLAG(mmb->flag, MMF_KRUNTIME, 1);
         }
         if (mmb->mflop[0] <= 0.0)    /* time kernels if necessary */
            TimeAllKernels(pre, 0, 1, mmb);
/*
 *       Get best contrib kernel; if eMMRES does not exist, search to create it
 */
         sprintf(ln, "res/%ceMMRES.sum", pre);
         mmb->next = ReadMMFile(ln);
         if (!mmb->next)
         {
            printf("\nRUNNING EXTERNAL SEARCHES, PRE='%c', NB=%d:\n",
                   pre, mmb->nbB);
            sprintf(ln, "make RunUMMSearch pre=%c nb=%d\n", pre, mmb->nbB);
            assert(!system(ln));
            sprintf(ln, "res/%ceMMRES.sum", pre);
            mmb->next = ReadMMFile(ln);
            assert(mmb->next);
         }
/*
 *       If necessary, time kernels on this machine and store times
 */
         if (mmb->next->mflop[0] <= 0.0)
         {
            TimeAllKernels(pre, 0, 1, mmb->next);
            WriteMMFile(ln, mmb->next);
         }
         printf("\nREAD IN BEST CONTRIBUTED KERNEL AS:\n");
         PrintMMLine(stdout, mmb->next);
         printf("\n");
/*
 *       Kill user-selected kernel if it isn't faster
 */
         if (mmb->next->mflop[0] < 1.02*mmb->mflop[0])
            mmb->next = KillMMNode(mmb->next);
         CreateFinalSumFile(pre, mmb, mmb->next);
      }
   }
@endskip
   return(mmb);
}

ATL_mmnode_t *OldLogFile2MMNode(char pre, char *path, char *fnam)
{
   ATL_mmnode_t *mmp;
   char ln[1024];

   sprintf(ln, "%s/%c%s", path, pre, fnam);
   if (!FileExists(ln))
      return(NULL);
   mmp = GetMMNode();
   GetInstLogFile(ln, pre, &mmp->muladd, &mmp->pref, &mmp->lat, &mmp->nbB, 
                  &mmp->mu, &mmp->nu, &mmp->ku, 
                  &mmp->fftch, &mmp->iftch, &mmp->nftch, mmp->mflop);
   mmp->mbB = mmp->kbB = mmp->nbB;
   return(mmp);
}


void mmsearch(char pre, int MULADD, int Fku, int nNBs, int *NBs, int nreg,
              int LAT, int Fnb)
{
   int latB, muB, nuB, kuB, nbB;
   int muladd, nb, ifetch, nfetch, FFetch;
   int i, j, k, NB, pfA;
   int NO1D;
   int umb, unb, ukb, ma;  
   double mfB, gmf;
   char fnam[128];
   FILE *fp;
   ATL_mmnode_t *mmU, *mmG;

   mmG = GetOrTransMMRES(pre);
   if (mmG) /* already have result */
   {
      nb = mmG->nbB;
      mmU = mmG->next;
      sprintf(fnam, "make RunUMMSearch pre=%c nb=%d", pre, nb);
      assert(!system(fnam));            /* update user & external searches */
      if (mmG->mflop[0] <= 0.0)
      {
         gmmsearch(pre, mmG->muladd, Fku, nNBs, NBs, nreg, mmG->lat, Fnb);
         TimeAllKernels(pre, 0, 0, mmG);
         CreateFinalSumFile(pre, mmG, mmU);
      }
      if (mmU && mmU->nbB != mmG->nbB)
         goto RECONCILE;
      nbB = mmU ? mmU->nbB : mmG->nbB;
      sprintf(fnam, "res/%cNB", pre);
      fp = fopen(fnam, "w");
      fprintf(fp, "%d\n%d\n", 1, nbB);
      fclose(fp);
      KillAllMMNodes(mmG);
      return;
@beginskip
      GetInstLogFile(fnam, pre, &muladd, &pfA, &latB, &nb, &muB, &nuB, &kuB, 
                     &FFetch, &ifetch, &nfetch, &mfB);
      if (mfB <= 0.0)
      {
         mfB = mmcase(NULL, pre, "JIK", 'T', 'N', nb, nb, nb, nb, nb, nb,
                      nb, nb, 0, muB, nuB, kuB, muladd, pfA, latB, 1, 1, 1, 2,
                      FFetch, ifetch, nfetch);
         gmmsearch(pre, muladd, Fku, nNBs, NBs, nreg, latB, Fnb);
         nbB = nb = CheckUser(pre, 1.02, mfB, nb, NULL);
         CreateFinalSumm(pre, muladd, pfA, latB, nb, muB, nuB, kuB, 
                         FFetch, ifetch, nfetch, mfB);
      }
      else nbB = CheckUser(pre, 1.02, mfB, nb, NULL);
      sprintf(fnam, "res/%cNB", pre);
      fp = fopen(fnam, "w");
      fprintf(fp, "%d\n%d\n", 1, nbB);
      fclose(fp);
      return;
@endskip
   }
   gmmsearch(pre, MULADD, Fku, nNBs, NBs, nreg, LAT, Fnb);
   mmG = OldLogFile2MMNode(pre, "res",  "gMMRES");
   nbB = mmG->nbB;
   pfA = mmG->pref;
   muB = mmG->mu; nuB = mmG->nu; kuB = mmG->ku;
   gmf = mfB = mmG->mflop[0];
   mmU = ReadMMFileWithPath(pre, "res", "eMMRES.sum");
   if (!mmU)
   {
      printf("\nRUNNING EXTERNAL SEARCHES, PRE='%c', NB=%d:\n", pre, nbB);
      sprintf(fnam, "make RunUMMSearch pre=%c n=%d", pre, nbB);
      assert(!system(fnam));
      mmU = ReadMMFileWithPath(pre, "res", "eMMRES.sum");
      assert(mmU);
   }
RECONCILE:
   nbB = mmG->nbB;
   pfA = mmG->pref;
   muB = mmG->mu; nuB = mmG->nu; kuB = mmG->ku;
   gmf = mfB = mmG->mflop[0];

   printf("\nREAD IN BEST CONTRIBUTED KERNEL (ID=%d) AS:\n", mmU->ID);
   PrintMMLine(stdout, mmU);
   printf("\n");
/*
 * If user-written kernel is noticably better than generated, use it;
 * if it changes NB, we will need to retune the generated case to match new NB!
 */
   if (mmU->mflop[0] > 1.03*gmf)
   {
      nb = mmU->nbB;
      if (nb != nbB)
      {
         sprintf(fnam, "rm -f res/%cuClean* res/%cClean*", pre, pre);
         system(fnam);  /* if NB changed, must redu Cleanup searches! */
         if (kuB == nbB) kuB = nb;
         nbB = nb;
         if (nb % muB || nb % nuB)
         {
            NO1D = GetNO1D(pre, nreg, nb, MULADD, pfA, LAT);
            searchmu_nu(pre, nb, nreg, Fku, MULADD, pfA, LAT, NO1D,
                        &mfB, &nb, &muB, &nuB, &kuB, &mmG->lat);
         }
         FindKU(pre, MULADD, pfA, LAT, nbB, muB, nuB, &mfB, &kuB, &mmG->lat);
         FindLAT(pre, pfA, MAXLAT, nbB, MULADD, muB, nuB, kuB, &mfB, &mmG->lat);
         FindFetch('T', 'N', pre, nbB, nbB, nbB, muB, nuB, kuB, MULADD, pfA,
                   mmG->lat, &mmG->fftch, &mmG->iftch, &mmG->nftch);
         mmG->mu = muB; mmG->nu = nuB; mmG->ku = kuB;
         mmG->mflop[0] = mfB;
         mmG->nbB = mmG->mbB = mmG->kbB = nbB;
      }
   }
   else 
   {
      KillAllMMNodes(mmU);
      mmU = NULL;
   }
/*
 * Save NB we've found 
 */
   sprintf(fnam, "res/%cNB", pre);
   fp = fopen(fnam, "w");
   fprintf(fp, "%d\n%d\n", 1, nbB);
   fclose(fp);
/*
 * Save best case parameters we have found
 */
   CreateFinalSumFile(pre, mmG, mmU);
}

void FindNC_0(char ta, char tb, char pre, int N, int mb, int nb, int kb, 
              int mu, int nu, int ku, int muladd, int pfA, int lat,
              int FFetch, int ifetch, int nfetch)
{
   int kuB=ku, latB=lat, lat0=lat, kb0=kb;
   int i, j, k, csA=1, csB=1, csC=1, kmax;
   double mf0, mf;
   char fnam[128];
   FILE *fp;

   sprintf(fnam, "res/%cbest%c%c_%dx%dx%d", pre, ta, tb, mb, nb, kb);
   if (FileExists(fnam)) /* default already exists */
   {
      GetInstLogFile(fnam, pre, &muladd, &pfA, &lat, &nb, &mu, &nu, &ku,
                     &FFetch, &ifetch, &nfetch, &mf);
      if (mf < 0.0) /* need to retime */
      {
         mf = mmcase(NULL, pre, "JIK", ta, tb, nb, nb, nb,
                     nb, nb, nb, 0, 0, 0, mu, nu, ku, muladd, pfA, lat, 1,
                     1, 1, csC, FFetch, ifetch, nfetch);
         PutInstLogFile1(fnam, pre, muladd, pfA, lat, nb, mu, nu, ku,
                         FFetch, ifetch, nfetch, mf);
      }
      return;
   }
   if (pre == 'c' || pre == 'z') csA = csB = csC = 2;
   assert(N > 0);
   if (kb == 0)
   {
      kb0 = 100000;
      if ((mb*nb)/lat != lat) lat0 = GetGoodLat(muladd, kb0, mu, nu, 1, lat);
   }
   k = 1024 / (mu*nu);
   for (kmax=4; kmax*kmax < k; kmax += 4);
   if (pre == 'd' || pre == 's') kmax *= 2;
   if (kmax >= N) kmax = N;
   else if (kmax > N/2) kmax = N/2;
   if (kb == 0) kuB = k = Mmin(ku,kmax);
   else k = ku;
/*
 * Find best non-cleanup case
 */
   mf0 = mmcase(NULL, pre, "JIK", ta, tb, N, N, N, mb, nb, kb, 0, 0, 0, 
                mu, nu, k, muladd, pfA, lat0, 1, csA, csB, csC, 
                FFetch, ifetch, nfetch);
   latB = lat0;
/*
 * If kb is not known, try all available K unrollings; for large mu*nu*N
 * combinations, don't try maximal unrollings in order to avoid having
 * the compiler run out of space trying to optimize
 */
   if (kb == 0)
   {
      for (k=1; k < kmax; k += 4)
      {
         if (k == 5) k = 4;
         if (k > N/2) k = kmax;
         j = k;
         if (kb == 0) j = 1;
         i = GetGoodLat(muladd, kb0, mu, nu, j, lat);
         mf = mmcase(NULL, pre, "JIK", ta, tb, N, N, N, mb, nb, kb, 0, 0, 0, 
                     mu, nu, k, muladd, pfA, i, 1, csA, csB, csC, 
                     FFetch, ifetch, nfetch);
         if (mf > mf0) 
         {
            mf0 = mf;
            kuB = k;
            latB = i;
         }
      }
   }
/*
 * If K is known, try only the most common unrollings
 */
   else
   {
      i = GetGoodLat(muladd, kb0, mu, nu, 1, lat);
      mf = mmcase(NULL, pre, "JIK", ta, tb, N, N, N, mb, nb, kb, 0, 0, 0, 
                  mu, nu, 1, muladd, pfA, i, 1, csA, csB, csC, 
                  FFetch, ifetch, nfetch);
      if (mf > mf0) 
      {
         mf0 = mf;
         kuB = 1;
         latB = i;
      }
      i = GetGoodLat(muladd, kb0, mu, nu, 4, lat);
      mf = mmcase(NULL, pre, "JIK", ta, tb, N, N, N, mb, nb, kb, 0, 0, 0, 
                  mu, nu, 4, muladd, pfA, i, 1, csA, csB, csC,
                  FFetch, ifetch, nfetch);
      if (mf > mf0) 
      {
         mf0 = mf;
         kuB = 4;
         latB = i;
      }
      mf = mmcase(NULL, pre, "JIK", ta, tb, N, N, N, mb, nb, kb, 0, 0, 0, 
                  mu, nu, kb, muladd, pfA, lat, 1, csA, csB, csC,
                  FFetch, ifetch, nfetch);
      if (mf > mf0) 
      {
         mf0 = mf;
         kuB = kb;
         latB = lat;
      }
   }
/*
 * Try various latencies
 */
   if (kb) i = kuB;
   else i = 1;
   for (k=2; k < 9; k++)
   {
      if (((mu*nu*i)/k)*k == mu*nu*i)
      {
         mf = mmcase(NULL, pre, "JIK", ta, tb, N, N, N, mb, nb, kb, 0, 0, 0, 
                     mu, nu, kuB, muladd, pfA, k, 1, csA, csB, csC,
                     FFetch, ifetch, nfetch);
         if (mf > mf0)
         {
            mf0 = mf;
            latB = k;
         }
      }
   }
   fprintf(stdout, "BEST for %c%c_%dx%dx%d: mflop=%.2f\n", 
           ta, tb, mb, nb, kb, mf0);
   fprintf(stdout, 
           "pre=%c ta=%c tb=%c nb=%d mu=%d nu=%d ku=%d muladd=%d lat=%d\n",
           pre, ta, tb, nb, mu, nu, kuB, muladd, latB);
   sprintf(fnam, "res/%cbest%c%c_%dx%dx%d", pre, ta, tb, mb, nb, kb);
   fp = fopen(fnam, "w");
   assert(fp);
   PutInstLogFile(fp, muladd, pfA, latB, N, mu, nu, kuB, 
                  FFetch, ifetch, nfetch, mf0);
   fclose(fp);
}

void FindNC0(char ta, char tb, char pre, int nb, int mu, int nu, int ku, 
             int muladd, int pfA, int lat, int FFetch, int ifetch, int nfetch)
{
   FindNC_0(ta, tb, pre, nb, nb, nb, nb, mu, nu, ku, muladd, pfA, lat, FFetch, 
            ifetch, nfetch);
   FindNC_0(ta, tb, pre, nb, 0, 0, nb, mu, nu, ku, muladd, pfA, lat, FFetch,
            ifetch, nfetch);
   FindNC_0(ta, tb, pre, nb, 0, 0, 0, mu, nu, ku, muladd, pfA, lat, FFetch,
            ifetch, nfetch);
}

double NCcase(char pre, int nb, int mu, int nu, int ku, int ma, int pfA, 
              int lat, int ffetch, int ifetch, int nfetch)
{
   double mf;
   int ld=Mmax(1000,nb), cs=1;
   char fnam[128];

   if (pre == 'c' || pre == 'z') cs = 2;
   do
   {
      sprintf(fnam, "res/%cNCNB%d_%d", pre, nb, ld);
      mf = mmcase(fnam, pre, "JIK", 'N', 'N', nb, nb, nb, nb, nb, nb, 
                  -ld, nb, nb, mu, nu, ku, ma, pfA, lat, 1, cs, cs, cs, 
                  ffetch, ifetch, nfetch);
      ld -= 10;
   }
   while (mf <= 0.0 && ld >= nb);
   assert(mf > 0.0);
   return(mf);
}

int FindNoCopyNB(char pre, int nb, int mu, int nu, int ku0, int muladd, 
                 int *prefA, int lat, int FFetch, int ifetch, int nfetch)
/*
 * See if a smaller blocking factor is needed for no-copy
 */
{
   char fnam[128];
   int i, ku, nbB=nb, csA=2, csB=2, csC=2, kuIsNB=0, pfA=(*prefA);
   double mf, mfB, mf0;
   const double dmul = 1.02;
   FILE *fp;

   if (ku0 == nb) 
      kuIsNB = 1;
   else if (!muladd) 
      lat = GetGoodLat(muladd, nb, mu, nu, ku0, lat);
   sprintf(fnam, "res/%cNCNB", pre);
   if (!FileExists(fnam))
   {
/*
 *    Check both with and w/o prefetch, since no-copy prefetch different
 */
      mfB = NCcase(pre, nb, mu, nu, ku0, muladd, pfA, lat, 
                   FFetch, ifetch, nfetch);
      #ifndef ATL_NOPREFETCH
         mf0 = NCcase(pre, nb, mu, nu, ku0, muladd, !pfA, lat, 
                      FFetch, ifetch, nfetch);
         if (mf0 > mfB)
         {
            mfB = mf0;
            pfA = !pfA;
         }
      #endif
      mfB *= dmul;
      mf0 = mfB;
      i = (nb>>2)<<2;
      if (i == nb)
         i -= 4;
      for (; i >= 16; i -= 4)
      {
         if (kuIsNB) ku = i;
         else ku = Mmin(i, ku0);
         mf = NCcase(pre, i, mu, nu, ku, muladd, pfA, lat, 
                     FFetch, ifetch, nfetch);
         if (1.2*mf < mfB) break; /* stop search after 20% slowdown */
@skip RCW 02/01/10: got rid, since default nb comes from gMMRES, not MMRES
@skip         if (nb%i == 0) mf *= dmul; /* give modest bonus to mults of nb */
         if (mf > mfB)
         {
            mfB = mf;
            nbB = i;
         }
      }
/*
 *    For safety, check opposite of prefetch result wt new NB
 */
      #ifndef ATL_NOPREFETCH
         mf = NCcase(pre, nbB, mu, nu, ku, muladd, !pfA, lat, 
                     FFetch, ifetch, nfetch);
         if (mf > mfB)
         {
            mfB = mf;
            pfA = !pfA;
         }
      #endif

      fp = fopen(fnam, "w");
      assert(fp);
      fprintf(fp, "%d\n", nbB);
   }
   else   /* If we know the correct NB, just try prefetch or not */
   {
      fp = fopen(fnam, "r");
      *prefA = -1;
      fscanf(fp, "%d\n", &nbB);
      mf0 = mfB = -1.0;
      ku = kuIsNB ? nbB : (Mmin(ku0,nbB));
      mfB = NCcase(pre, nbB, mu, nu, ku, muladd, pfA, lat, 
                   FFetch, ifetch, nfetch);
      #ifndef ATL_NOPREFETCH
         mf  = NCcase(pre, nbB, mu, nu, ku, muladd, !pfA, lat, 
                      FFetch, ifetch, nfetch);
         if (mf > mfB)
         {
           pfA = !pfA;
           mfB = mf;
         }
      #endif
   }
   fclose(fp);
   fprintf(stdout, "\n%cNB = %d (%.2f), No copy %cNB = %d (%.2f)\n\n", 
           pre, nb, mf0, pre, nbB, mfB);
   *prefA = pfA;
   return(nbB);
}

void FindNoCopy(char pre)
{
   char ln[128];
   int nb, mu, nu, ku, muladd, pfA, lat, FFetch, ifetch, nfetch, i;
   double mf;
   FILE *fp;
   ATL_mmnode_t *mmp;

@beginskip
   sprintf(ln, "res/%cMMRES", pre);
   GetInstLogFile(ln, pre, &muladd, &pfA, &lat, &nb, &mu, &nu, &ku,
                  &FFetch, &ifetch, &nfetch, &mf);
   nb = CheckUser(pre, 1.02, mf, nb, NULL);
@skip   sprintf(ln, "res/%cgMMRES", pre);
@skip   GetInstLogFile(ln, pre, &muladd, &lat, &i, &mu, &nu, &ku,
@skip                  &FFetch, &ifetch, &nfetch, &mf);
@endskip
@skip   mmp = GetOrTransMMRES(pre);
   mmp = ReadMMFileWithPath(pre, "res", "gMMRES.sum");
   if (!mmp)
   {
      sprintf(ln, "make res/%cMMRES.sum\n", pre);
      assert(!system(ln));
      mmp = ReadMMFileWithPath(pre, "res", "MMRES.sum");
      assert(mmp);
   }
   muladd = mmp->muladd;
   lat = mmp->lat;
   pfA = mmp->pref;
   #ifndef ATL_NOPREFETCH  /* if no prefetch allowed */
      pfA &= 512;          /* just preserve load-at-bottom flag */
   #endif
   nb = mmp->next ? mmp->next->nbB : mmp->nbB;
   mu = mmp->mu; nu = mmp->nu;  ku = mmp->ku;
   FFetch = mmp->fftch; ifetch = mmp->iftch; nfetch = mmp->nftch;
   KillAllMMNodes(mmp);
   nb = FindNoCopyNB(pre, nb, mu, nu, ku, muladd, &pfA, lat, 
                     FFetch, ifetch, nfetch);
   ku = Mmin(ku, nb);
   if (!muladd && ku < nb)
      lat = GetGoodLat(muladd, nb, mu, nu, ku, lat);
   FindNC0('N', 'N', pre, nb, mu, nu, ku, muladd, pfA, lat, 
           FFetch, ifetch, nfetch);
   FindNC0('N', 'T', pre, nb, mu, nu, ku, muladd, pfA, lat, 
           FFetch, ifetch, nfetch);
   FindNC0('T', 'N', pre, nb, mu, nu, ku, muladd, pfA, lat, 
           FFetch, ifetch, nfetch);
   FindNC0('T', 'T', pre, nb, mu, nu, ku, muladd, pfA, lat, 
           FFetch, ifetch, nfetch);
}

void FindCleanupK(char pre, int nb, int mu, int nu, int ku0, int muladd, 
                  int pfA, int lat0, int FFetch, int ifetch, int nfetch)
{
   char fnam[256];
   int genlat, genku, speclat, ku, kumax;
   int kb, beta, csC;
   double mf, genmf, specmf;
   int i, TimeIt=0;
   FILE *fp;

   i = 1024 / (mu*nu);
   for (kumax=4; kumax*kumax < i; kumax += 4);
   if (pre == 'd' || pre == 's') kumax *= 2;
   if (kumax >= nb) kumax = nb;
   else if (kumax > nb/2) kumax = nb/2;
   if (ifetch == -1 || nfetch == -1) { ifetch = mu+nu; nfetch = 1; }
   if (pre == 's' || pre == 'd')
   {
      csC = 1;
      beta = 1;
   }
   else
   {
      csC = 2;
      beta = 8;
   }
   sprintf(fnam, "res/%cCleanK", pre);
   if (FileExists(fnam)) /* file already there */
   {
      fp = fopen(fnam, "r");
      assert(fgets(fnam, 256, fp));
      assert(fscanf(fp, " %d", &kb) == 1);
      fclose(fp);
      if (kb > 0 && kb != nb) TimeIt = 1;
      sprintf(fnam, "res/%cCleanK", pre);
   }
   else TimeIt = 1;
   if (TimeIt)
   {
      fp = fopen(fnam, "w");
      assert(fp);
      fprintf(fp, " KB  MULADD  LAT  PREF NB  MU  NU  KU  FFTCH  IFTCH  NFTCH  GEN-MFLOP  SPC-MFLOP\n");

      for (kb = nb; kb; kb--)
      {
         ku = Mmin(ku0, kb);
         sprintf(fnam, "res/%cKB_%d", pre, kb);
         speclat = GetGoodLat(muladd, kb, mu, nu, ku, lat0);
         specmf = mmcase(fnam, pre, "JIK", 'T', 'N', nb, nb, kb, 0, 0, 
                         kb, kb, kb, 0, mu, nu, ku, muladd, pfA, speclat, beta, 
                         1, 1, csC, FFetch, ifetch, nfetch);

         sprintf(fnam, "res/%cKB_0_%d", pre, ku);
         genlat = GetGoodLat(muladd, 8000, mu, nu, 1, lat0);
         genku = Mmin(kumax, ku);
         genmf = mmcase(fnam,pre, "JIK", 'T', 'N', nb, nb, kb, 0, 0, 0, 0, 0, 0,
                        mu, nu, genku, muladd, pfA, genlat, beta, 1, 1, csC,
                        FFetch, ifetch, nfetch);
         if (ku != 1)  /* always try ku == 1 for general case */
         {
            sprintf(fnam, "res/%cKB_0_1", pre);
            mf = mmcase(fnam,pre, "JIK", 'T', 'N', nb, nb, kb, 0, 0, 0, 0, 0, 0,
                        mu, nu, 1, muladd, pfA, genlat, beta, 1, 1, csC,
                        FFetch, ifetch, nfetch);
            if (mf > genmf) { genku = 1; genmf = mf; }
         }
         if (1.01 * genmf > specmf) break;
         fprintf(fp, 
          "%3d  %6d  %3d %4d %3d %3d %3d %3d  %5d  %5d  %5d  %9.2lf  %9.2lf\n",
                 kb, muladd, speclat, pfA, nb, mu, nu, ku, FFetch, ifetch,
                 nfetch, specmf, genmf);
         fflush(fp);
      }
      fprintf(fp, 
         "%3d  %6d  %3d %4d %3d %3d %3d %3d  %5d  %5d  %5d  %9.2lf  %9.2lf\n",
              0, muladd, genlat, pfA, nb, mu, nu, genku, FFetch, ifetch, 
              nfetch, specmf, genmf);
      fclose(fp);
   }
}

void FindCleanupMN(char pre, char cwh, int nb, int mu, int nu, int ku,
                   int muladd, int pfA, int lat, 
                   int FFetch, int ifetch, int nfetch)
{
   char fnam[128];
   int nnb=nb, beta=1, csC=1, TimeIt=0;
   int Mb=nb, Nb=nb;
   int mu0, nu0, ku0, ma0, lat0, ff0, if0, nf0;
   double mf;
   FILE *fp;

   if (cwh == 'M') Mb = 0;
   else Nb = 0;
   if (ifetch == -1 || nfetch == -1) { ifetch = mu+nu; nfetch = 1; }
   if (pre == 'c' || pre == 'z')
   {
      beta = 8;
      csC = 2;
   }
   sprintf(fnam, "res/%cClean%c", pre, cwh);
   if (FileExists(fnam))
   {
      GetInstLogFile(fnam, pre, &ma0, &pfA, &lat0, &nnb, &mu0, &nu0, &ku0, &ff0,
                     &if0, &nf0, &mf);
      if (nnb != nb || mf <= 0.0) TimeIt = 1;
   }
   else TimeIt = 1;
   if (TimeIt)
   {
      mf = mmcase(NULL, pre, "JIK", 'T', 'N', nb, nb, nb, Mb, Nb, nb, nb, nb, 0,
                  mu, nu, ku, muladd, pfA, lat, beta, 1, 1, csC, 
                  FFetch, ifetch, nfetch);
      fp = fopen(fnam, "w");
      assert(fp);
      PutInstLogFile(fp, muladd, pfA, lat, nb, mu, nu, ku,
                     FFetch, ifetch, nfetch, mf);
      fclose(fp);
   }
}

typedef struct CleanCase CLEANCASE;
struct CleanCase
{
   double mflop;
   CLEANCASE *next;
   int imult, icase, fixed, nb, nb0, nb1, nb2;
};

void PrintCleanCases(CLEANCASE *cp)
{
   for (; cp; cp = cp->next)
   {
      fprintf(stdout, 
              "imult=%d, icase=%d, fixed=%d, nb=%d, %d,%d,%d, mflop=%.2f\n",
              cp->imult, cp->icase, cp->fixed, cp->nb, cp->nb0, cp->nb1,
              cp->nb2, cp->mflop);
   }
   fprintf(stdout, "\n");
}
CLEANCASE *GetUserCleanup(char pre, int nb, enum CW which)
/*
 * Read in user clean file
 */
{
   FILE *fp;
   CLEANCASE *cp, *cp0;
   int i, n;
   char cwh[3] = {'M', 'N', 'K'};
   char ln[128];

   sprintf(ln, "res/%cuClean%c", pre, cwh[which]);
   if (!FileExists(ln))
   {
      sprintf(ln, "make RunUMMClean pre=%c nb=%d which=%c\n",
              pre, nb, tolower(cwh[which]));
      assert(system(ln) == 0);
      sprintf(ln, "res/%cuClean%c", pre, cwh[which]);
   }
   fp = fopen(ln, "r");
   assert(fp);
   assert(fgets(ln, 128, fp));
   assert(fgets(ln, 128, fp));
   sscanf(ln, " %d", &n);
   if (n < 1) return(NULL);
   cp0 = cp = malloc(sizeof(CLEANCASE));
   assert(cp0);
   for (i=0; i < n; i++)
   {
      assert(fgets(ln, 128, fp));
      sscanf(ln, " %d %d %d %d %d %d %d %lf", &cp->imult, &cp->icase,&cp->fixed,
             &cp->nb, &cp->nb0, &cp->nb1, &cp->nb2, &cp->mflop);
      if (i != n-1)
      {
         cp->next = malloc(sizeof(CLEANCASE));
         assert(cp->next);
         cp = cp->next;
      }
      else cp->next = NULL;
   }
   fclose(fp);
   return(cp0);
}

int *GetKBs(char pre, int nb)
/*
 * returns nb+1 length vector, KB[i] is KB & lda of KB Cleanup; 0 means var
 */
{
   FILE *fp;
   int k, *KB;
   char ln[128];

   sprintf(ln, "res/%cCleanK", pre);
   fp = fopen(ln, "r");
   assert(fp);
   assert(fgets(ln, 128, fp));  /* skip titles */
   KB = malloc((nb+1)*sizeof(int));
   assert(KB);
   for (k=nb; k; k--)
   {
      if (fgets(ln, 128, fp)) { assert(sscanf(ln, " %d", KB+k)==1); }
      else break;
   }
   for(; k; k--) KB[k] = 0;
   return(KB);
}

double RebuttUserKCase(char pre, int nb, int mu, int nu, int ku, int ma,
                       int pfA, int lat, int FF, int iff, int nf, int *KBs, 
                       int *NBs)
{
   double mf, mf0=0.0;
   int K, csC, i, ld, iku, ilat;

   if (pre == 'c' || pre == 'z') csC = 2;
   else csC = 1;

   for(i=0; i < 3 && NBs[i]; i++)
   {
      K = NBs[i];
      ld = KBs[K];
      iku = Mmin(ku, K);
      ilat = GetGoodLat(ma, K, mu, nu, 1, lat);
      mf = mmclean(pre, CleanK, "JIK", 'T', 'N', nb, nb, K,
                   nb, nb, ld, ld, ld, 0,
                   mu, nu, iku, ma, pfA, ilat, 1, 1, 1, csC, FF, iff, nf);
      fprintf(stdout, "   CleanK: %dx%dx%d : %.2f\n", nb, nb, K, mf);
      assert(mf > 0.0);
      mf0 += mf;
   }
   return(mf0 / i);
}

CLEANCASE *RebuttUserKClean(char pre, int nb, int mu, int nu, int ku,
                            int muladd, int pfA,  int lat,
                            int FF, int iff, int nf)
{
   double gmf, umf;
   int NB[3], *KBs;
   CLEANCASE *cp0, *cp;

   KBs = GetKBs(pre, nb);

   cp0 = GetUserCleanup(pre, nb, CleanK);
   for (cp=cp0; cp; cp = cp->next)
   {
      NB[0] = cp->nb0; NB[1] = cp->nb1; NB[2] = cp->nb2;
      gmf = RebuttUserKCase(pre, nb, mu, nu, ku, muladd, pfA, lat, FF, iff, nf,
                            KBs, NB);
      fprintf(stdout, "   pKBmm_%d: user=%.2f  generated=%.2f\n", 
              cp->imult, cp->mflop, gmf);
      if (1.02*gmf > cp->mflop) cp->icase = -1;
   }
   free(KBs);
   return(cp0);
}

double RebuttUserCase(char pre, int nb, enum CW which, int mu, int nu, int ku,
                      int ma, int pfA, int lat, int FF, int iff, int nf, 
                      int *NBs)
{
   double mf, mf0=0.0;
   int NB[3], M[3], NU[3], csC, i, j, NUmax, ilat;
   char cwh[3] = {'M', 'N', 'K'};

   if (pre == 'c' || pre == 'z') csC = 2;
   else csC = 1;
   NB[0] = NB[1] = NB[2] = M[0] = M[1] = M[2] = nb;
   NB[which] = 0;
   NU[0] = mu; NU[1] = nu; NU[2] = ku;

   NUmax = NU[which];
   for(i=0; i < 3 && NBs[i]; i++)
   {
      j = M[which] = NBs[i];
      NU[which] = Mmin(j, NUmax);
      ilat = GetGoodLat(ma, M[2], NU[0], NU[1], NU[2], lat);
      mf = mmclean(pre, which, "JIK", 'T', 'N', M[0], M[1], M[2],
                   NB[0], NB[1], NB[2], nb, nb, 0,
                   mu, nu, ku, ma, pfA, lat, 1, 1, 1, csC, FF, iff, nf);
      fprintf(stdout, "   Clean%c: %dx%dx%d : %.2f\n", cwh[which],
              M[0], M[1], M[2], mf);
      assert(mf > 0.0);
      mf0 += mf;
   }
   return(mf0 / i);
}

CLEANCASE *RebuttUserCases(char pre, int nb, enum CW which,
                           int mu, int nu, int ku, int muladd, int pfA, int lat,
                           int FF, int iff, int nf)
{
   double gmf, umf;
   int NB[3];
   CLEANCASE *cp0, *cp;
   char cwh[3] = {'M', 'N', 'K'};

   if (which == CleanK)
      return(RebuttUserKClean(pre, nb, mu, nu, ku, muladd, pfA, lat, 
                              FF, iff, nf));
   cp0 = GetUserCleanup(pre, nb, which);
   for (cp=cp0; cp; cp = cp->next)
   {
      NB[0] = cp->nb0; NB[1] = cp->nb1; NB[2] = cp->nb2;
      gmf = RebuttUserCase(pre, nb, which, mu, nu, ku, muladd, pfA, lat,
                           FF, iff, nf, NB);
      fprintf(stdout, "   p%cBmm_%d: user=%.2f  generated=%.2f\n", 
              cwh[which], cp->imult, cp->mflop, gmf);
      if (1.02*gmf > cp->mflop) cp->icase = -1;
   }
   return(cp0);
}

CLEANCASE *WeedOutLosers(CLEANCASE *cp0)
{
   CLEANCASE *cp, *cp1;

   while(cp0 && cp0->icase == -1)
   {
      cp = cp0->next;
      free(cp0);
      cp0 = cp;
   }
   if (cp0 && cp0->next)
   {
      for (cp=cp0; cp->next; cp = cp->next)
      {
         cp1 = cp->next;
         if (cp1->icase == -1)
         {
            cp->next = cp1->next;
            free(cp1);
            if (cp->next == NULL) break;
         }
      }
   }
   return(cp0);
}

void KillAllCleans(CLEANCASE *cp)
{
   CLEANCASE *cp1;
   while (cp)
   {
      cp1 = cp->next;
      free(cp);
      cp = cp1;
   }
}

int NumUserCleans(CLEANCASE *cp)
{
   int i;
   for (i=0; cp; cp = cp->next) if (cp->icase != -1) i++;
   return(i);
}

void FindUserCleanup(char pre, int nb, enum CW which, int mu, int nu, int ku,
                     int ma, int pfA, int lat, int FF, int iff, int nf)
{
   CLEANCASE *cp, *cp0;
   FILE *fp;
   char ln[128];
   char cwh[3] = {'M', 'N', 'K'};

   sprintf(ln, "res/%cuClean%cF", pre, cwh[which]);
   if (FileExists(ln)) return;/* already done */
   cp = RebuttUserCases(pre, nb, which, mu, nu, ku, ma, pfA, lat, FF, iff, nf);
   cp = WeedOutLosers(cp);
   fp = fopen (ln, "w");
   assert(fp);
   fprintf(fp, "MULT  ICASE  FIXED  NB\n");
   fprintf(fp, "%d\n", NumUserCleans(cp));
   for(cp0=cp; cp; cp = cp->next)
      fprintf(fp, "%4d  %5d  %5d %3d\n", 
              cp->imult, cp->icase, cp->fixed, cp->nb);
   fclose(fp);
   KillAllCleans(cp0);
}

void FindAllUserClean(char pre, int nb, int mu, int nu, int ku,
                      int ma, int pfA, int lat, int FF, int iff, int nf)
{
   FindUserCleanup(pre, nb, CleanM, mu, nu, ku, ma, pfA, lat, FF, iff, nf);
   FindUserCleanup(pre, nb, CleanN, mu, nu, ku, ma, pfA, lat, FF, iff, nf);
   FindUserCleanup(pre, nb, CleanK, mu, nu, ku, ma, pfA, lat, FF, iff, nf);
}

void FindAllUserClean0(char pre)
{
   double mf;
   int nb, mu, nu, ku, muladd, lat, FF, iff, nf, pfA;
   char ln[64];
   ATL_mmnode_t *mmp;

@beginskip
   sprintf(ln, "res/%cMMRES", pre);
   GetInstLogFile(ln, pre, &muladd, &pfA, &lat, &nb, &mu, &nu, &ku, &FF,
                     &iff, &nf, &mf);
   nb = CheckUser(pre, 1.02, mf, nb, NULL);
@endskip
   mmp = GetOrTransMMRES(pre);
   assert(mmp);
   pfA = mmp->pref;
   #ifndef ATL_NOPREFETCH  /* if no prefetch allowed */
      pfA &= 512;          /* just preserve load-at-bottom flag */
   #endif
   FindAllUserClean(pre, mmp->next ? mmp->next->nbB : mmp->nbB, 
                    mmp->mu, mmp->nu, mmp->ku, mmp->muladd, pfA, 
                    mmp->lat, mmp->fftch, mmp->iftch, mmp->nftch);
   KillAllMMNodes(mmp);
}

void FindCleanup(char pre, int nb, int mu, int nu, int ku, int muladd, int pfA,
                 int lat, int FFetch, int ifetch, int nfetch)
{
   int latS=lat;
   if (!muladd && ku < nb)
      latS = GetGoodLat(muladd, nb, mu, nu, ku, lat);
   FindCleanupMN(pre, 'M', nb, mu, nu, ku, muladd, pfA, latS, 
                 FFetch, ifetch, nfetch);
   FindCleanupMN(pre, 'N', nb, mu, nu, ku, muladd, pfA, latS, 
                 FFetch, ifetch, nfetch);
   FindCleanupK(pre, nb, mu, nu, ku, muladd, pfA, latS, FFetch, ifetch, nfetch);
   FindAllUserClean(pre, nb, mu, nu, ku, muladd, pfA, latS, 
                    FFetch, ifetch, nfetch);
}
void FindAllClean(char pre)
{
   double mf;
   int nb, mu, nu, ku, muladd, lat, FF, iff, nf, pfA;
   char ln[64];
   ATL_mmnode_t *mmp;

   fprintf(stdout, "\n\nSTARTING CLEANUP SEARCH\n\n");
@beginskip
   sprintf(ln, "res/%cMMRES", pre);
   GetInstLogFile(ln, pre, &muladd, &pfA, &lat, &nb, &mu, &nu, &ku, &FF,
                     &iff, &nf, &mf);
   nb = CheckUser(pre, 1.02, mf, nb, NULL);
@endskip
   mmp = GetOrTransMMRES(pre);
   assert(mmp);
   FindCleanup(pre, mmp->next ? mmp->next->nbB : mmp->nbB, 
               mmp->mu, mmp->nu, mmp->ku, mmp->muladd, mmp->pref, mmp->lat, 
               mmp->fftch, mmp->iftch, mmp->nftch);
   KillAllMMNodes(mmp);
   fprintf(stdout, "\n\nDONE CLEANUP SEARCH\n\n");
}

int GetNumRegs0(char pre, int muladd, int nb, int lat, 
                int nr0, int nrN, int incN)
/*
 * RETURNS: nregisters before 10% drop-off in performance occured, or
 *          -1 if this drop-off did not occur
 */
{
   int n, nr, i, imax, nu, mu, pfA=0, iret=(-1), nrlast;
   double *rates, mf, mf1d, mmf=0.0;

   n = 0;
   nrlast = i = nr0;
   while (i <= nrN)
   {
      if (incN == -2) i <<= 1;
      else i += incN;
      n++;
   }
   nr = nr0;
   for (i=0; i < n; i++)
   {
      FindMUNU(muladd, lat, nr, 1, &mu, &nu);
      mf = mms_caseIC(pre, muladd, nb, mu, nu, nb, pfA, lat);
/* 
 *    Try 1D case for small # regs in case we've got 2-op asg (eg, x86)
 */
      if (nr < 16)
      {
         mf1d = mms_caseIC(pre, muladd, nb, nr, 1, nb, pfA, lat);
         if (mf1d > mf)
            mf = mf1d;
      }
      if (mf > mmf)
      {
         mmf = mf;
         imax = i;
      }
/*
 *    Declare 10% drop in performance register exhaustion
 */
      else if (mf < 0.9*mmf)
      {
         iret = nrlast;
         break;
      }
      nrlast = nr;
      if (incN == -2) nr <<= 1;
      else nr += incN;
   }
   return(iret);
}

int RefineNumRegs(char pre, int muladd, int nb, int lat, int nr0, int nrN)
/*
 * recursively halves gap until true number is found
 */
{
   int i, nr;

   i = (nrN - nr0) / 2;
   if (i < 1) return(nr0);
   nr = GetNumRegs0(pre, muladd, nb, lat, nr0, nr0+i, i);
   if (nr != nr0) /* positive or no difference in two points, so go larger */
      nr0 += i;
   else          /* difference, point is between */
      nrN = nr0 + i;
   return(RefineNumRegs(pre, muladd, nb, lat, nr0, nrN));
}

int GetNumRegs00(char pre, int muladd, int nb, int lat, int maxnr)
{
   int nr, i;

   fprintf(stdout, "\n\nFINDING ROUGHLY HOW MANY REGISTERS TO USE:\n\n");

   nr = GetNumRegs0(pre, muladd, nb, lat, 4, maxnr, -2);
/*
 * Refine number of regs
 */
   if (nr != -1) i = RefineNumRegs(pre, muladd, nb, lat, nr, nr<<1);
   else i = nr;
   fprintf(stdout, "\n\nAPPROXIMATE NUMBER OF USABLE REGISTERS=%d\n\n", i);
   return(i);
}

int GetNumRegs(char pre, int MaxL1, int maxnreg)
{
   FILE *fp;
   int nreg, muladd, lat;
   char nam[32];
   void GetMulAdd(char pre, int *MULADD, int *lat);

   if (pre == 'z') pre = 'd';
   else if (pre == 'c') pre = 's';

   sprintf(nam, "res/%cnreg", pre);
   if (!FileExists(nam))
   {
      GetMulAdd(pre, &muladd, &lat);
      nreg = GetNumRegs00(pre, muladd, GuessSmallNB(pre, MaxL1*1024, 4, 3), 
                          lat, maxnreg);
      fp = fopen(nam, "w");
      fprintf(fp, "%d\n", nreg);
   }
   else
   {
      fp = fopen(nam, "r");
      fscanf(fp, " %d", &nreg);
   }
   fclose(fp);
   fprintf(stdout, "mmnreg = %d\n", nreg);
   return(nreg);
}

void RunTimes(char pre)
{
   const char TR[2] = {'N', 'T'};
   char fnam[128], fnam2[128], ln[128];
   const int COMPLEX = (pre == 'c' || pre == 'z');
   int csC = (COMPLEX ? 2 : 1);
   int NB, muladd, lat, nb, mu, nu, ku, ffetch, ifetch, nfetch, ia, ib;
   int uma, ulat, unb=0, umu, unu, uku, uff, uif, unf, pfA;
   int maxreg;
   double mf, umf;
   FILE *fp;
   ATL_mmnode_t *mmp;

   fprintf(stdout, "\n\nStart RunTimes\n");
   sprintf(fnam, "res/%cgMMRES", pre);
   fp = fopen(fnam, "r");
   assert(fp);
   fgets(ln, 128, fp);
   GetInstLogLine(fp, &muladd, &pfA, &lat, &nb, &mu, &nu, &ku, &ffetch,
                  &ifetch, &nfetch, &mf);
   fclose(fp);
   if (mf < 0.0) /* need to retime */
   {
      printf("\nRETIMING EXTERNAL KERNELS, PRE='%c':\n", pre);
      sprintf(ln, "make RunUMMSearch pre=%c nb=-1\n", pre);
      assert(!system(ln) == 0);
      mf = mmcase(NULL, pre, "JIK", 'T', 'N', nb, nb, nb, nb, nb, nb, 
                  nb, nb, 0, mu, nu, ku, muladd, pfA, lat, 1, 1, 1, csC, 
                  ffetch, ifetch, nfetch);
      PutInstLogFile1(fnam, pre, muladd, pfA, lat, nb, mu, nu, ku, 
                      ffetch, ifetch, nfetch, mf);
      mmp = GetOrTransMMRES(pre);
      if (!mmp)
      {
         sprintf(ln, "make res/%cMMRES.sum pre=%c\n", pre, pre);
         assert(system(ln) == 0);
         mmp = GetOrTransMMRES(pre);
         assert(mmp);
      }
      if (mmp->mflop[0] <= 0.0)
      {
         TimeAllKernels(pre, 0, 0, mmp);
         CreateFinalSumFile(pre, mmp, mmp->next);
      }
@beginskip
      sprintf(fnam, "res/%cMMRES", pre);
      if (!FileExists(fnam))
      {
         sprintf(ln, "make res/%cMMRES pre=%c\n", pre, pre);
         assert(system(ln) == 0);
      }
      else
      {
         GetInstLogFile(fnam, pre, &muladd, &pfA, &lat, &nb, &mu, &nu, &ku, 
                        &ffetch, &ifetch, &nfetch, &mf);
         mf = mmcase(NULL, pre, "JIK", 'T', 'N', nb, nb, nb, nb, nb, nb, 
                     nb, nb, 0, mu, nu, ku, muladd, pfA, lat, 1, 1, 1, csC, 
                     ffetch, ifetch, nfetch);
         CreateFinalSumm(pre, muladd, pfA, lat, nb, mu, nu, ku, ffetch, ifetch,
                         nfetch, mf);
      }
@endskip
   }
   sprintf(fnam, "res/%cNCNB", pre);
   if (!FileExists(fnam)) return;
   fp = fopen(fnam, "r");
   assert(fp);
   assert(fscanf(fp, " %d", &NB) == 1);
   fclose(fp);

   for (ia=0; ia < 2; ia++)
   {
      for (ib=0; ib < 2; ib++)
      {
         sprintf(fnam, "res/%cbest%c%c_%dx%dx%d", pre, TR[ia], TR[ib], 
                 NB, NB, NB);
         if (FileExists(fnam))
         {
            GetInstLogFile(fnam, pre, &muladd, &pfA, &lat, &nb, &mu, &nu, &ku,
                           &ffetch, &ifetch, &nfetch, &mf);
            if (mf < 0.0) /* need to retime */
            {
               mf = mmcase(NULL, pre, "JIK", TR[ia], TR[ib], nb, nb, nb, 
                           nb, nb, nb, 0, 0, 0, mu, nu, ku, muladd, pfA, lat,
                           1, 1, 1, csC, ffetch, ifetch, nfetch);
               PutInstLogFile1(fnam, pre, muladd, pfA, lat, nb, mu, nu, ku,
                              ffetch, ifetch, nfetch, mf);
            }
         }
         sprintf(fnam, "res/%cbest%c%c_%dx%dx%d", pre, TR[ia], TR[ib], 
                 0, 0, NB);
         if (FileExists(fnam))
         {
            GetInstLogFile(fnam, pre, &muladd, &pfA, &lat, &nb, &mu, &nu, &ku,
                           &ffetch, &ifetch, &nfetch, &mf);
            if (mf < 0.0) /* need to retime */
            {
               mf = mmcase(NULL, pre, "JIK", TR[ia], TR[ib], nb, nb, nb, 
                           0, 0, nb, 0, 0, 0, mu, nu, ku, muladd, pfA, lat, 1, 
                           1, 1, csC, ffetch, ifetch, nfetch);
               PutInstLogFile1(fnam, pre, muladd, pfA, lat, nb, mu, nu, ku,
                              ffetch, ifetch, nfetch, mf);
            }
         }
         sprintf(fnam, "res/%cbest%c%c_%dx%dx%d", pre, TR[ia], TR[ib], 
                 0, 0, 0);
         if (FileExists(fnam))
         {
            GetInstLogFile(fnam, pre, &muladd, &pfA, &lat, &nb, &mu, &nu, &ku,
                           &ffetch, &ifetch, &nfetch, &mf);
            if (mf < 0.0) /* need to retime */
            {
               mf = mmcase(NULL, pre, "JIK", TR[ia], TR[ib], nb, nb, nb, 
                           0, 0, 0, 0, 0, 0, mu, nu, ku, muladd, pfA, lat, 1, 
                           1, 1, csC, ffetch, ifetch, nfetch);
               PutInstLogFile1(fnam, pre, muladd, pfA, lat, nb, mu, nu, ku,
                              ffetch, ifetch, nfetch, mf);
            }
         }
      }
   }
   fprintf(stdout, "\nDone  RunTimes\n\n");
}

void cmmsearch(char pre, int MULADD, int Fku, int nNBs, int *NBs, int nreg,
               int LAT, int Fnb)
/*
 * With all other parameters set by real search, find good complex NB
 */
{
   char *typ, ln[64], upre;
   int i, k, nbB, muladd, lat, nb, mu, nu, ku, ffetch, ifetch, nfetch, pfA;
   int KUisNB, NO1D;
   double mf, mfB;
   FILE *fp;
   ATL_mmnode_t *mmU, *mmG, *mmR;

   printf("LINE %d of %s\n", __LINE__, __FILE__);
   if (pre == 'c') upre = 's';
   else upre = 'd';
/*
 * See if search is available in new MMRES.sum or old-style MMRES
 */
   mmG = GetOrTransMMRES(pre);
   if (mmG)             /* already have result */
   {
      sprintf(ln, "make RunUMMSearch pre=%c nb=%d", pre, nb);
      assert(!system(ln));            /* update user & external searches */
      if (mmG->mflop[0] <= 0.0)   /* need to retime */
      {
         gmmsearch(upre, muladd, Fku, nNBs, NBs, nreg, lat, Fnb);
         TimeAllKernels(pre, 0, 0, mmG);
         CreateFinalSumFile(pre, mmG, mmG->next);
      }
      mmU = mmG->next;
      if (mmU && mmU->nbB != mmG->nbB)
         goto RECONCILE;
      nb = mmG->nbB;
      if (mmG->next && mmU->mflop[0] < 1.02*mmG->mflop[0])
      {
         mmU = mmG->next = KillMMNode(mmU);
         CreateFinalSumFile(pre, mmG, mmU);
      }
      nb = mmU ? mmU->nbB : mmG->nbB;
      sprintf(ln, "res/%cNB", pre);
      fp = fopen(ln, "w");
      fprintf(fp, "%d\n%d\n", 1, nb);
      fclose(fp);
      return;
   }
/*
 * If we don't have full search results, must run at least some searches
 */
   mmG = OldLogFile2MMNode(pre, "res", "gMMRES");
   if (!mmG)
   {
/*
 *    Complex search depends on the associated real search.  If the real search
 *    hasn't already been done, do it, and get the real values as starting
 *    points for complex search.  We don't care if real search timed or not.
 */
      mmR = OldLogFile2MMNode(upre, "res", "gMMRES");
      if (!mmR)
      {
         gmmsearch(upre, MULADD, Fku, nNBs, NBs, nreg, LAT, Fnb);
         mmR = OldLogFile2MMNode(upre, "res", "gMMRES");
      }
      assert(mmR);
/*
 *    Take real parameters as are starting point for restricted complex search
 */
      muladd = mmR->muladd;
      lat = mmR->lat;
      nb = mmR->nbB;
      mu = mmR->mu; nu = mmR->nu; ku = mmR->ku;
      mfB = 0.0;
      nbB = nb;
      KUisNB = (nb <= ku);
/*
 *    Find the best block factor using the real values for everything else
 */
      for (i=0; i < nNBs; i++)
      {
         if (KUisNB) k = NBs[i];
         else k = Mmin(ku, NBs[i]);
         mf = mms_case(pre, muladd, NBs[i], mu, nu, k, pfA, lat);
         if (mf > mfB)
         {
            mfB = mf;
            nbB = NBs[i];
         }
      }
      nb = nbB;
      fprintf(stdout, "\n\nBEST REAL NB=%d, BEST COMPLEX NB=%d (%.2f)\n\n", 
              mmR->nbB, nbB, mfB);
/*
 *    See if not changing prefetch of A improves performance
 */
      mf = mms_case(pre, muladd, nb, mu, nu, KUisNB?nb:Mmin(ku,nb),
                    (pfA^1), lat);
      if (mf > mfB)
      {
         fprintf(stdout, "\n\nPREFETCH SWAPPED TO %d (%.2f)\n\n", pfA, mfB);
         pfA ^= 1;
         mfB = mf;
      }
/*
 *    If case is presently load-at-top, try load-at-bottom; give bottom an
 *    advantage, as it enormously better for error
 */
      if ((pfA | 512) != pfA)
      {
         mf = mms_case(pre, muladd, nb, mu, nu, KUisNB?nb:Mmin(ku,nb),
                       (pfA|512), lat);
         if (mf*1.01 > mfB)
         {
            pfA |= 512;
            mfB = mf;
         }
      }
/*
 *    Save best generated case in old-style gMMRES file
 */
      if (KUisNB) ku = nbB;
      else ku = Mmin(ku, nbB);
      sprintf(ln, "res/%cgMMRES", pre);
      PutInstLogFile1(ln, pre, muladd, pfA, lat, nbB, mu, nu, ku, 
                      mmR->fftch, mmR->iftch, mmR->nftch, mfB);
      mmG = OldLogFile2MMNode(pre, "res", "gMMRES");
      assert(mmG);
   }
   else
   { 
      if (mmG->mflop[0] <= 0.0) /* need to retime */
         TimeAllKernels(pre, 0, 0, mmG);
      nbB = mmG->nbB;
   }
/*
 * mmG has the best generated case found.  Figure out the best contributed
 * kernel (mmU)
 */
   mmU = ReadMMFileWithPath(pre, "res", "eMMRES.sum");
   if (!mmU)  /* need to run xummsearch */
   {
      sprintf(ln, "make RunUMMSearch pre=%c n=%d", pre, mmG->nbB);
      assert(!system(ln));
      mmU = ReadMMFileWithPath(pre, "res", "eMMRES.sum");
      assert(mmU);
   }
RECONCILE:
/*
 * If user-written kernel is noticably better than generated, use it;
 * if it changes NB, we will need to retune the generated case for new NB!
 */
   if (mmU->mflop[0] > 1.03*mfB)
   {
/*
 *    If user kernel has different NB, will need to retune most params
 *    (prefetch strategy, unrolling and register blocking possibly affected)
 */
      if (mmU->nbB != nbB)
      {
         sprintf(ln, "rm -f res/%cuClean* res/%cClean*", pre, pre);
         system(ln);  /* if NB changed, must redo cleanup searches */
         nbB = mmU->nbB;
         if (mmG->ku == mmG->nbB)  /* keep full unrolling wt new NB */
            ku = mmG->ku = mmU->nbB;
         else 
            ku = mmG->ku;
         nb = mmG->nbB = mmG->mbB = mmG->kbB = nbB;
         mu = mmG->mu;  nu = mmG->nu;
         muladd = mmG->muladd;
         lat = mmG->lat;
         pfA = mmG->pref;
/*
 *       If present MU and NU don't evenly divide new NB, but do evenly divide
 *       the old NB, must re-search MU/NU
 */
         if (((mmG->nbB % mmG->mu == 0) && (mmU->nbB % mmG->mu != 0)) ||
             ((mmG->nbB % mmG->nu == 0) && (mmU->nbB % mmG->nu != 0)))
         {
            NO1D = GetNO1D(pre, nreg, nb, muladd, pfA, LAT);
            searchmu_nu(pre, nb, nreg, Fku, muladd, pfA, LAT, NO1D,
                        &mfB, &nbB, &mu, &nu, &ku, &lat);
            mmG->mu = mu;
            mmG->nu = nu;
            mmG->lat = lat;
         }
         FindKU(pre, muladd, pfA, LAT, nb, mu, nu, &mfB, &ku, &lat);
         mmG->ku = ku;
         FindLAT(pre, pfA, MAXLAT, nb, muladd, mu, nu, ku, &mfB, &lat);
         mmG->lat = lat;
         FindFetch('T', 'N', upre, nb, nb, nb, mu, nu, ku, muladd, pfA, lat,
                   &mmG->fftch, &mmG->iftch, &mmG->nftch);
         TimeAllKernels(pre, 0, 1, mmG);  /* force timing of resulting kernel */
         if (mmG->mflop[0]*1.03 > mmU->mflop[0])
         {
            KillAllMMNodes(mmU);
            mmU = NULL;
         }
      }
   }
/*
 * If user-supplied case slower than generated, kill mmU
 */
   else
   {
      KillAllMMNodes(mmU);
      mmU = NULL;
   }
/*
 * Save NB we've found
 */
   sprintf(ln, "res/%cNB", pre);
   fp = fopen(ln, "w");
   fprintf(fp, "%d\n%d\n", 1, mmG->nbB);
   fclose(fp);
   CreateFinalSumFile(pre, mmG, mmU);
   printf("LINE %d of %s\n", __LINE__, __FILE__);
}
  
@ROUT ummsearch

#define AUTHLEN 256
#define ROUTLEN 256
#define NOTIMED -8.0
#define ATL_MMNoClean(iflag_) ( ((iflag_) | 8) == (iflag_) )
#define ATL_MMCleanOnly(iflag_) ( ((iflag_) | 16) == (iflag_) )
#define ATL_MMVarLda(iflag_) ( ((iflag_) | 32) == (iflag_) )
#define ATL_MMVarM(iflag_) ( ((iflag_) | 64) == (iflag_) )
#define ATL_MMVarN(iflag_) ( ((iflag_) | 128) == (iflag_) )
#define ATL_MMVarK(iflag_) ( ((iflag_) | 256) == (iflag_) )

enum CLEAN_WHICH{CleanM=0, CleanN=1, CleanK=2, CleanNot=3};

typedef struct RoutNode ROUTNODE;
struct RoutNode
{
   double mflop;
   char *rout;
   ROUTNODE *next;
   int icase;
   int fixed; /* 0: pNB input para; 1: pNB=NB; 2: pNB=imult */
};
typedef struct MultHead MULTHEAD;
struct MultHead
{
   int imult;
   MULTHEAD *next;
   ROUTNODE *rn;
} *imhead=NULL;

@ROUT ummsearch usercase
int LineIsCont(char *ln)
{
   int i, iret=0;
   for(i=0; ln[i]; i++);
   if (i)
   {
      for(i--; isspace(ln[i]); i--);
      if (ln[i] == '\\') iret = 1;
   }
   return(iret);
}

int NumUserCases0(char *nam)
{
   int iret=0;
   char ln[512];
   FILE *fp;

   fp = fopen(nam, "r");
   if (fp)
   {
      fgets(ln, 512, fp);  /* skip comment line */
      assert(fscanf(fp, " %d", &iret) == 1);
      fclose(fp);
   }
   return(iret);
}

int NumUserCases(char pre)
{
   char ln[64];

   sprintf(ln, "%ccases.dsc", pre);
   return(NumUserCases0(ln));
}

void NoEndLineWhiteSpace(char *ln)
{
   int i;

   for (i=0; ln[i]; i++);
   if (i)
      for (i--; isspace(ln[i]); i--) ln[i] = '\0';
}

int GetUserCase(char pre, int icase, int *iflag, int *mb, int *nb, int *kb, 
                int *ma, int *lat, int *mu, int *nu, int *ku, 
                char *fnam, char *auth, char **MCC, char **MMFLAGS)
/*
 * if icase < 0, go to that line in file; if icase > 0 find that ID in file
 * return ID of selected line
 */
{
   int i, n, ID;
   char ln[512];
   static char sMCC[1024], sMMFLAGS[2048];
   FILE *fp;

   *MCC = *MMFLAGS = NULL;
   n = NumUserCases(pre);
   sprintf(ln, "%ccases.dsc", pre);
   fp = fopen(ln, "r");
   if (!fp) return(0);
   assert(fp);
   fgets(ln, 256, fp);  /* skip comment line */
   fgets(ln, 256, fp);  /* skip number of cases */
   for (i=0; i < n; i++)
   {
      if ( fgets(ln, 256, fp) == NULL )
      {
         fclose(fp);
         return(0);
      }
      assert(sscanf(ln, " %d %d %d %d %d %d %d %d %d %d %s \"%[^\"]", &ID, 
                    iflag, mb, nb, kb, ma, lat, mu, nu, ku, fnam, auth) == 12);
      assert(ID > 0);
      if (i == -icase || ID == icase)
      {
         if (LineIsCont(ln))
         {
            assert( fgets(ln, 256, fp) != NULL );
            strcpy(sMCC, ln);
            NoEndLineWhiteSpace(sMCC);
            assert( fgets(ln, 512, fp) != NULL );
            strcpy(sMMFLAGS, ln);
            NoEndLineWhiteSpace(sMMFLAGS);
            *MCC = sMCC;
            *MMFLAGS = sMMFLAGS;
         }
         else *MCC = *MMFLAGS = NULL;
         fclose(fp);
         return(ID);
      }
      if (i != icase && LineIsCont(ln))
      {
         assert( fgets(ln, 256, fp) != NULL );
         assert( fgets(ln, 256, fp) != NULL );
      }
   }
   fclose(fp);
   return(0);
}
@ROUT ummsearch

int IsCaseFixed(char pre, int icase, enum CLEAN_WHICH which)
{
   char stmp[ROUTLEN], *MCC, *MMFLAGS;
   int iflag, ma, lat, mu, nu, ku, NB[3];
   assert(GetUserCase(pre, icase, &iflag, NB, NB+1, NB+2, &ma, &lat, 
                      &mu, &nu, &ku, stmp, stmp, &MCC, &MMFLAGS));
   if (NB[which] > 0)
   {
      if (which == CleanM && ATL_MMVarM(iflag)) ma = 0;
      else if (which == CleanN && ATL_MMVarN(iflag)) ma = 0;
      else if (which == CleanK && ATL_MMVarK(iflag) && ATL_MMVarLda(iflag))
         ma = 0;
      else ma = 1;
   }
   else if (NB[which] < 0) ma = 2;
   else
   {
      if (which == CleanK && !ATL_MMVarLda(iflag)) ma = 1;
      else ma = 0;
   }
   return(ma);
}

ROUTNODE *CreateRoutNode(char *rout, int icase, double mflop)
{
   ROUTNODE *rn;
   int i;

   rn = malloc(sizeof(ROUTNODE));
   assert(rn);
   i = strlen(rout)+1;
   rn->rout = malloc(i * sizeof(char));
   assert(rn->rout);
   strcpy(rn->rout, rout);
   rn->icase = icase;
   rn->mflop = mflop;
   rn->fixed = -1;
   rn->next = NULL;
   return(rn);
}

void KillRoutNode(ROUTNODE *rn)
{
   free(rn->rout);
   free(rn);
}

void RemoveRoutNode(MULTHEAD *mh, ROUTNODE *rn0)
{
   ROUTNODE *rn;

   if (rn0 == NULL) return;
   assert(mh->next);
   if (mh->rn != rn0)
   {
      for (rn=mh->rn; rn->next != rn0 && rn->next; rn = rn->next);
      assert(rn->next == rn0);
      rn->next = rn0->next;
   }
   else mh->rn = rn0->next;
   KillRoutNode(rn0);
}

void KillAllRoutNodes(ROUTNODE *rn0)
{
   ROUTNODE *rn;
   while(rn0)
   {
      rn = rn0->next;
      KillRoutNode(rn0);
      rn0 = rn;
   }
}

MULTHEAD *CreateMultNode(int imult)
{
   MULTHEAD *mh;

   mh = malloc(sizeof(MULTHEAD));
   assert(mh);
   mh->imult = imult;
   mh->rn = NULL;
   mh->next = NULL;
   return(mh);
}

MULTHEAD *GetMultNode(int imult)
/*
 * Finds, and if necessary, creates MULTHEAD with value imult, keeping it
 * in ascending order
 */
{
   MULTHEAD *mh, *mh0;
   if (imhead)
   {
      for (mh=imhead; mh; mh = mh->next) if (mh->imult >= imult) break;
      if (mh && imhead == mh && mh->imult != imult)
      {
         mh = CreateMultNode(imult);
         mh->next = imhead;
         imhead = mh;
      }
      else if (!mh || mh->imult != imult)
      {
         for (mh0=imhead; mh0->next != mh; mh0 = mh0->next);
         mh0->next = CreateMultNode(imult);
         mh0->next->next = mh;
         mh = mh0->next;
      }
   }
   else mh = imhead = CreateMultNode(imult);
   return(mh);
}

void KillMultNode(MULTHEAD *mh)
{
   KillAllRoutNodes(mh->rn);
   free(mh);
}

void KillThisMultNode(MULTHEAD *mhD)
{
   MULTHEAD *mh;

   if (mhD == NULL) return;
   if (mhD == imhead) imhead = imhead->next;
   else
   {
      for (mh=imhead; mh && mh->next != mhD; mh = mh->next);
      assert(mh);
      if (mh->next) mh->next = mh->next->next;
   }
   KillMultNode(mhD);
}

void KillAllMultNodes()
{
   MULTHEAD *mh;

   while(imhead)
   {
      mh = imhead->next;
      KillMultNode(imhead);
      imhead = mh;
   }
}

ROUTNODE *GetRoutNode(int imult, char *rout, int icase, double mflop)
/*
 * Finds, and if necessary creates, the desired RoutNode
 */
{
   MULTHEAD *mh;
   ROUTNODE *rn;

   mh = GetMultNode(imult);
@skip   for (rn = mh->rn; rn; rn = rn->next) if (!strcmp(rn->rout, rout)) break;
   for (rn = mh->rn; rn; rn = rn->next) if (rn->icase == icase) break;
   if (!rn)
   {
      rn = CreateRoutNode(rout, icase, mflop);
      if (mh->rn)
      {
         rn->next = mh->rn;
         mh->rn = rn;
      }
      else mh->rn = rn;
   }
   return(rn);
}

void PrintTable(FILE *fpout)
{
   MULTHEAD *mh;
   ROUTNODE *rn;
   for (mh=imhead; mh; mh = mh->next)
   {
      fprintf(fpout, "%3d: ", mh->imult);
      for (rn=mh->rn; rn; rn = rn->next)
         fprintf(fpout, "%3d:%1d,%5.1f ", rn->icase, rn->fixed, rn->mflop);
      fprintf(fpout, "\n");
   }
   fprintf(fpout, "\n");
}

MULTHEAD *BuildTable(char pre, enum CLEAN_WHICH which, int nb)
/*
 * Builds table of possible cleanup codes, depending on which:
 * 0 : pMB
 * 1 : pNB
 * 2 : pKB
 */
{
   ROUTNODE *rn;
   int i, n, ID, NB[3];
   int iin, io1, io2, iflag, muladd, lat, mu, nu, ku;
   char *MCC, *MMFLAGS;
   char rout[ROUTLEN], auth[AUTHLEN];

   switch(which)
   {
   case CleanM:
      iin = 0;
      io1 = 1;
      io2 = 2;
      break;
   case CleanN:
      iin = 1;
      io1 = 0;
      io2 = 2;
      break;
   case CleanK:
      iin = 2;
      io1 = 0;
      io2 = 1;
      break;
   case CleanNot:
      exit(-1);
   }

   n = NumUserCases(pre);
   for (i=0; i < n; i++)
   {
      rn = NULL;
      ID = GetUserCase(pre, -i, &iflag, NB, NB+1, NB+2, &muladd, &lat,
                       &mu, &nu, &ku, rout, auth, &MCC, &MMFLAGS);
      if (ATL_MMNoClean(iflag)) continue;
      if (NB[io1] < 0 && NB[io1] != -nb) continue;
      if (NB[io2] < 0 && NB[io2] != -nb) continue;
      if (NB[io1] && (nb % NB[io1])) continue;
      if (NB[io2] && (nb % NB[io2])) continue;
      if (NB[iin] < 0)
      {
         if (-NB[iin] < nb) rn = GetRoutNode(-NB[iin], rout, ID, NOTIMED);
      }
      else if (NB[iin] == 0) rn = GetRoutNode(1, rout, ID, NOTIMED);
      else if (NB[iin] < nb) rn = GetRoutNode(NB[iin], rout, ID, NOTIMED);
      if (rn) rn->fixed = IsCaseFixed(pre, ID, which);
   }
   return(imhead);
}

int MakeMult(int nb, int mul)
/*
 * takes nb, makes it a multiple of mul by reducing
 */
{
   return( (nb / mul) * mul );
}

int GetPNB(char pre, enum CLEAN_WHICH which, int icase, int NB, int imul,
           int *pNB)
/*
 * Returns number of pNB that are multiple of imul (max of 3) to be timed;
 * pNB contains the values to try
 */
{
   int i=1, j;
   int iflag, NBs[3], muladd, lat, mu, nu, ku;
   char fnam[ROUTLEN], *MCC, *MMFLAGS;

   pNB[0] = pNB[1] = pNB[2] = 0;

   assert(GetUserCase(pre, icase, &iflag, NBs, NBs+1, NBs+2, &muladd, &lat, 
                      &mu, &nu, &ku, fnam, fnam, &MCC, &MMFLAGS));
   if (NBs[which] < 0) pNB[0] = -NBs[which];
   else
   {
      j = pNB[0] = MakeMult(NB-NB/8, imul);
      if (!j) pNB[0] = imul;
      j = MakeMult(NB/2, imul);
      if (j && j != pNB[0])
      {
         pNB[1] = j;
         i = 2;
         j = NB/8;
         if (NB >= 32) j = Mmax(j, 16);
         j = pNB[2] = ((j+imul-1)/imul)*imul;
         if (j && j != pNB[1] && j != pNB[0]) i = 3;
         else pNB[2] = 0;
      }
   }
   return(i);
}

#define NO_RESULTS -88.7
double GetRes(char *fnam)
{
   double *dp;
   dp = ReadResultsFile(0, 3, fnam);
   if (dp)
      return(*dp);
   return(NO_RESULTS);
@beginskip
   FILE *fp;
   double mf, mflop[3];
   int i;

   fp = fopen(fnam, "r");
   if (!fp) return(NO_RESULTS);
   for (i=0; i != 3; i++)
   {
      if (fscanf(fp, " %lf", &mflop[i]) != 1)
      {
         fclose(fp);
         remove(fnam);
         return(NO_RESULTS);
      }
   }
   fclose(fp);
   mf = GetAvg(3, TOLERANCE, mflop);
   return(mf);
@endskip
}
double ummcase0
(
   char pre,                  /* type prefix */
   int M, int N, int K,       /* problem sizes to time */
   int mb, int nb, int kb,    /* 0: variable NB, else fixed cpp macro of NB */
   int lda, int ldb, int ldc, /* leading dims */
   int muladd, int lat,       /* muladd and latency settings */
   int mu, int nu, int ku,    /* unrolling factors */
   char *fnam,                /* file name to compile */
   char *MCC, char *MMFLAGS,  /* NULL : use defaults, else comp to use */
   char *outnam               /* output name */
)
{
   char ln[4096];
   char ch;
   int i;
   double mf;

   if (!FileExists(outnam))
   {
      if (pre == 'c' || pre == 'z') 
         i = sprintf(ln, "make cmmucase mmrout=CASES/%s csC=2 ", fnam);
      else i = sprintf(ln, "make mmucase mmrout=CASES/%s ", fnam);
      if (MCC) 
      {
         ch = (pre == 'c' || pre == 's') ? 'S' : 'D';
         i += sprintf(ln+i, "%cMC=\"%s\" %cMCFLAGS=\"%s\" ", 
                      ch, MCC, ch, MMFLAGS);
      }
      i += sprintf(ln+i, "casnam=%s ", outnam);
      i += sprintf(ln+i, "pre=%c muladd=%d lat=%d M=%d N=%d K=%d mb=%d nb=%d kb=%d mu=%d nu=%d ku=%d lda=%d ldb=%d ldc=%d ",
                   pre, muladd, lat, M, N, K, mb, nb, kb, mu, nu, ku,
                   lda, ldb, ldc);
      i += sprintf(ln+i, "> /dev/null 2>&1\n");
@skip      fprintf(stdout, "%s", ln);
      if (system(ln) != 0) return(-1.0);
   }
   mf = GetRes(outnam);
   if (mf == NO_RESULTS) mf = -1.0;
   return(mf);
}

int GetIflag(char pre, int icase)
{
   int iflag, mb, nb, kb, muladd, lat, mu, nu, ku;
   char fnam[ROUTLEN], *MCC, *MMFLAGS;
   assert(GetUserCase(pre, icase, &iflag, &mb, &nb, &kb, &muladd, &lat, 
                      &mu, &nu, &ku, fnam, fnam, &MCC, &MMFLAGS));
   return(iflag);
}

double GetCleanCase(char pre, enum CLEAN_WHICH which, int icase, int imul,
                    int mb, int nb, int kb)
{
   char cwh[3] = {'M', 'N', 'K'};
   char outf[ROUTLEN], fnam[ROUTLEN], *MCC, *MMFLAGS;
   int ld=kb, NB[3], NB1[3], NBs[3], nb0;
   int iflag, mb1, nb1, kb1, muladd, lat, mu, nu, ku;

   assert(GetUserCase(pre, icase, &iflag, NB1, NB1+1, NB1+2, &muladd, &lat, 
                      &mu, &nu, &ku, fnam, outf, &MCC, &MMFLAGS));
   if (ATL_MMNoClean(iflag)) return(-1.0);
   NBs[0] = mb;
   NBs[1] = nb;
   NBs[2] = kb;
   nb0 = kb;
   if (which == CleanK)
   {
      nb0 = nb;
      if (ATL_MMVarLda(iflag)) ld = 0;
   }
   NB[0] = NB[1] = NB[2] = nb0;
   if (NB1[which]) NB[which] = NBs[which];
   else NB[which] = 0;
   sprintf(outf, "res/%cup%cB%d_%d_%dx%dx%d", pre, cwh[which], icase, imul, 
           mb, nb, kb);
   return(ummcase0(pre, mb, nb, kb, NB[0], NB[1], NB[2], ld, ld, 0, muladd, lat,
                   mu, nu, ku, fnam, MCC, MMFLAGS, outf));
}

double GetCleanCases0(char pre, enum CLEAN_WHICH which, int nb, int imul,
                      int icase, int n, int *pNB)
{
   int i, NB[3];
   double mf0, mf=0.0;

   NB[0] = NB[1] = NB[2] = nb;
   for (i=0; i < n; i++)
   {
      NB[which] = pNB[i];
      mf0 = GetCleanCase(pre, which, icase, imul, NB[0], NB[1], NB[2]);
      if (mf0 <= 0.0) return(-1.0); /* reject if it fails to run */
      mf += mf0;
   }
   return(mf / n);
}

double GetCleanCases(char pre, enum CLEAN_WHICH which, int nb, int imul,
                     int icase)
{
   int n, pNB[3];

   n = GetPNB(pre, which, icase, nb, imul, pNB);
   return(GetCleanCases0(pre, which, nb, imul, icase, n, pNB));
}

void TimeRouts(char pre, enum CLEAN_WHICH which, int nb, int imul,
               ROUTNODE *rn0)
{
   ROUTNODE *rn;

   for (rn=rn0; rn; rn = rn->next)
      if (rn->mflop == NOTIMED)
         rn->mflop = GetCleanCases(pre, which, nb, imul, rn->icase);
}

void TimeTable(char pre, enum CLEAN_WHICH which, int nb)
/*
 * Times table of cleanup codes, depending on which
 */
{
   MULTHEAD *mh;

   for (mh=imhead; mh; mh = mh->next)
      TimeRouts(pre, which, nb, mh->imult, mh->rn);
}

ROUTNODE *FindBestRout(ROUTNODE *rn0, double adv)
/*
 * Excludes those of fixed size 
 */
{
   ROUTNODE *rnB=NULL, *rn;
   double mfB=0.0, ad;
   for (rn=rn0; rn; rn = rn->next)
   {
      if (rn->fixed != 2)
      {
         ad = (rn->fixed == 0)*adv*rn->mflop;
         if (rn->mflop+ad > mfB)
         {
            rnB = rn;
            mfB = rn->mflop+ad;
         }
      }
   }
   return(rnB);
}

ROUTNODE *FindBestFixed2(ROUTNODE *rn0)
{
   ROUTNODE *rnB=NULL, *rn;
   double mfB=0.0;
   for (rn=rn0; rn; rn = rn->next)
   {
      if (rn->fixed == 2 && rn->mflop > mfB)
      {
         rnB = rn;
         mfB = rn->mflop;
      }
   }
   return(rnB);
}

void ReduceRouts(char pre, enum CLEAN_WHICH which, MULTHEAD *mh,
                 double adv, int nb)
/*
 * reduces routs to best, giving adv advantage to non-fixed routs
 */
{
   double mf;
   ROUTNODE *rn, *rnN, *rnF, *rnNF=NULL;
   int n, NB[3];

   rn = FindBestRout(mh->rn, adv);
   rnF = FindBestFixed2(mh->rn);
   if (rn || rnF) /* some case actually compiled and ran */
   {
      if (rnF && rn)
      {
         n = GetPNB(pre, which, rnF->icase, nb, mh->imult, NB);
         mf = GetCleanCases0(pre, which, nb, mh->imult, rn->icase, n, NB);
         mf += adv*mf;
         if (mf < rnF->mflop)
         {
            rnNF = CreateRoutNode(rnF->rout, rnF->icase, rnF->mflop);
            rnNF->fixed = 2;
         }
      }
      else if (rnF)
      {
         rnNF = CreateRoutNode(rnF->rout, rnF->icase, rnF->mflop);
         rnNF->fixed = 2;
         KillAllRoutNodes(mh->rn);
         mh->rn = rnNF;
      }
      if (rn)
      {
         rnN = CreateRoutNode(rn->rout, rn->icase, rn->mflop);
         rnN->fixed = rn->fixed;
         KillAllRoutNodes(mh->rn);
         mh->rn = rnN;
         if (rnNF) mh->rn->next = rnNF;
         else mh->rn->next = NULL;
      }
   }
   else KillThisMultNode(mh);
}

void ReduceMults(char pre, enum CLEAN_WHICH which, double adv, int nb)
/*
 * Finds mults that are multiples of each other, and takes best,
 * giving adv advantage to non-fixed routs, and .5 adv to lower imults
 */
{
   MULTHEAD *mh, *mh0, *mh1;
   double mf0, mf1;
   int imult;
   int NB[3];
   NB[0] = NB[1] = NB[2] = nb;
   for (mh0=imhead; mh0; mh0 = mh0->next)
   {
      if (mh0->rn->fixed == 2) continue;
      for (mh1=mh0, mh=mh0->next; mh; mh = mh->next)
      {
         if (mh->imult % mh0->imult == 0) /* higher mult is mult of lower */
         {
            imult = mh->imult;
            if (mh->rn->fixed == 2)
            {
               NB[which] = imult;
               mf1 = mh->rn->mflop;
            }
            else
            {
               NB[which] = imult <= 4 ? ((nb-imult)/imult)*imult :
                                         ((nb-1)/imult)*imult;
               mf1 = GetCleanCase(pre, which, mh->rn->icase, imult, 
                                  NB[0], NB[1], NB[2]);
            }
            mf0 = GetCleanCase(pre, which, mh0->rn->icase, imult, 
                               NB[0], NB[1], NB[2]);
            if (((mh0->rn->fixed == 0)+0.5)*adv*mf0+mf0 >
                (mh->rn->fixed == 0)*adv*mf1+mf1)
            {
               mh1->next = mh->next;
               KillMultNode(mh);
               mh = mh1;
            }
         }
         mh1 = mh;
      }
   }
}

void ReduceTable(char pre, enum CLEAN_WHICH which, int nb)
/*
 * Reduces table to best in each catagory
 */
{
   MULTHEAD *mh, *mhnext;
   const double advant=0.03;

   for (mh=imhead; mh; mh = mhnext)
   {
      mhnext = mh->next;
      ReduceRouts(pre, which, mh, advant, nb);
   }
   ReduceMults(pre, which, advant, nb);
}

int ummtstcase0
(
   char pre,                  /* type prefix */
   int M, int N, int K,       /* problem sizes to test */
   int mb, int nb, int kb,    /* 0: variable NB, else fixed cpp macro of NB */
   int lda, int ldb, int ldc, /* leading dims */
   int muladd, int lat,       /* muladd and latency settings */
   int mu, int nu, int ku,    /* unrolling factors */
   char *fnam,                /* file name to compile */
   char *MCC, char *MMFLAGS   /* NULL : use defaults, else comp to use */
)
{
   char ln[512];
   int i;
   char ch;

   if (pre == 'c' || pre == 'z') 
      i = sprintf(ln, "make cmmutstcase mmrout=CASES/%s csC=2 ", fnam);
   else i = sprintf(ln, "make mmutstcase mmrout=CASES/%s ", fnam);
   if (MCC)
   {
      ch = (pre == 's' || pre == 'c') ? 'S' : 'D';
      i += sprintf(ln+i, "%cMC=\"%s\" %cMCFLAGS=\"%s\" ", ch, MCC, ch, MMFLAGS);
   }
   i += sprintf(ln+i, "pre=%c muladd=%d lat=%d M=%d N=%d K=%d mb=%d nb=%d kb=%d mu=%d nu=%d ku=%d lda=%d ldb=%d ldc=%d ",
                pre, muladd, lat, M, N, K, mb, nb, kb, mu, nu, ku,
                lda, ldb, ldc);
   i += sprintf(ln+i, "> /dev/null 2>&1\n");
   fprintf(stdout, "     TESTING PRE='%c' FILE='%s', NB=%d . . .", 
           pre, fnam, nb);
   i = system(ln);
   if (!i) fprintf(stdout, " PASSED!\n");
   else fprintf(stdout, " FAILED!\n");
   return(i == 0);
@skip   fprintf(stdout, "%s", ln);
@skip   return(system(ln) == 0);
}

static int Mylcm(const int M, const int N)
/*
 * Returns least common multiple (LCM) of two positive integers M & N by
 * computing greatest common divisor (GCD) and using the property that
 * M*N = GCD*LCM.
 */
{
   register int tmp, max, min, gcd=0;

   if (M != N)
   {
      if (M > N) { max = M; min = N; }
      else { max = N; min = M; }
      if (min > 0)  /* undefined for negative numbers */
      {
         do  /* while (min) */
         {
            if ( !(min & 1) ) /* min is even */
            {
               if ( !(max & 1) ) /* max is also even */
               {
                  do
                  {
                     min >>= 1;
                     max >>= 1;
                     gcd++;
                     if (min & 1) goto MinIsOdd;
                  }
                  while ( !(max & 1) );
               }
               do min >>=1 ; while ( !(min & 1) );
            }
/*
 *          Once min is odd, halve max until it too is odd.  Then, use
 *          property that gcd(max, min) = gcd(max, (max-min)/2) 
 *          for odd max & min
 */
MinIsOdd:
            if (min != 1)
            {
               do  /* while (max >= min */
               {
                  max -= (max & 1) ? min : 0;
                  max >>= 1;
               }
               while (max >= min);
            }
            else return( (M*N) / (1<<gcd) );
            tmp = max;
            max = min;
            min = tmp;
         }
         while(tmp);
      }
      return( (M*N) / (max<<gcd) );
   }
   else return(M);
}

int GetUserNB(char pre, int NB, int mb, int nb, int kb, int iflag)
/*
 * Given ATLAS's preference for NB, finds a good nb based on user's input
 */
{
   int i, mult;
   static int nelt=0;

   if (mb < 0)
   {
      if ( (nb < 0 && nb != mb) || (kb < 0 && kb != mb) ) return(0);
      else return(-mb);
   }
   else if (nb < 0)
   {
      if (kb < 0 && kb != nb) return(0);
      else return(-nb);
   }
   else if (kb < 0) return(-kb);
   if (!nelt)
      nelt = L1Elts(pre, 128*1024);
   if (!nb) nb = 1;
   if (!mb) mb = 1;
   if (!kb) kb = 1;
   mult = Mylcm(mb,nb);
   mult = Mylcm(kb,mult);
   if (iflag&512)  /* needs to keep 4 matrices in cache */
   {
      if ( (NB%mb == 0) && (NB%nb == 0) && (NB%kb == 0) && 3*NB*NB <= nelt) 
         return(NB);
      i = (NB/mult)*mult;
      if (4*i*i <= nelt)
         return(i);
      for (; i >= 16; i -= mult)
         if (4*i*i <= nelt || i <= 16)
            return(i);
   }
   if ( (NB%mb == 0) && (NB%nb == 0) && (NB%kb == 0) ) return(NB);
   i = ((NB+mult-1)/mult)*mult;
   if (i*i < nelt) return(i);
   else return((NB/mult)*mult);
@beginskip
   for (i=NB; (i%nb || i%mb || i%kb) && i*i < nelt; i += 4);
   if ( (i%mb == 0) && (i%nb == 0) && (i%kb == 0) ) return(i);
   for (i=NB-4; i > 16 && (i%nb || i%mb || i%kb); i -= 4);
   if ( (i%mb == 0) && (i%nb == 0) && (i%kb == 0) ) return(i);
@endskip
   return(0);
}


char *GetUserOutFile(char pre, int ifile, int mb, int nb, int kb)
{
   static char ln[32];
   sprintf(ln, "res/%cuser%03d_%dx%dx%d", pre, ifile+1, mb, nb, kb);
   return(ln);
}

double ummcase(char pre, int ifile, int NB)
{
   char outnam[256], fnam[256];
   char *MCC, *MMFLAGS;
   int iflag, mb, nb, kb, muladd, lat, mu, nu, ku;

   assert(GetUserCase(pre, ifile, &iflag, &mb, &nb, &kb, &muladd, &lat, 
                      &mu, &nu, &ku, fnam, outnam, &MCC, &MMFLAGS));
   if (ATL_MMCleanOnly(iflag)) return(0.0); /* don't run if for cleanup only */
   return(ummcase0(pre, NB, NB, NB, NB, NB, NB, NB, NB, 0, muladd, lat,
                   mu, nu, ku, fnam, MCC, MMFLAGS, 
                   GetUserOutFile(pre, ifile, NB, NB, NB)));
}

int utstmmcase(char pre, int ifile, int NB)
{
   char outnam[256], fnam[256];
   char *MCC, *MMFLAGS;
   int iflag, mb, nb, kb, muladd, lat, mu, nu, ku;

   assert(GetUserCase(pre, ifile, &iflag, &mb, &nb, &kb, &muladd, &lat, 
                      &mu, &nu, &ku, fnam, outnam, &MCC, &MMFLAGS));
   return(ummtstcase0(pre, NB, NB, NB, NB, NB, NB, NB, NB, 0, muladd, lat,
                      mu, nu, ku, fnam, MCC, MMFLAGS));
}


int GetUserFNB(char pre, int NB, int mb, int nb, int kb, int iflag)
/*
 * RETURNS: 0 if described kernel cannot handle NB, else NB
 */
{
   int i, mult;
   static int nelt=0;

   if ((mb < 0 && mb != -NB) || (nb < 0 && nb != -NB) || (kb < 0 && kb != -NB))
      return(0);
   if (mb > 0 && NB%mb)
      return(0);
   if (nb > 0 && NB%nb)
      return(0);
   if (kb > 0 && NB%kb)
      return(0);
   return(NB);
}

int FindBestUserFNB(char pre, int nb0)
/*
 * returns index in <pre>cases.dsc of best user-supplied GEMM, using
 * a blocking factor of exactly nb
 */
{
   char *MCC, *MMFLAGS;
   char ln[256], fnam[256];
   double mf, mfbest=0.0, adv;
   int ibest=(-1), i, ncases;
   int ID, iflag, NB, mb, nb, kb, ma, lat, mu, nu, ku, nbB=0;
   FILE *fpsum;

   sprintf(ln, "res/%cucases.res", pre);
   fpsum = fopen(ln, "w");
   ncases = NumUserCases(pre);
   for (i=0; i < ncases; i++)
   {
      ID = GetUserCase(pre, -i, &iflag, &mb, &nb, &kb, &ma, &lat, 
                       &mu, &nu, &ku, fnam, ln, &MCC, &MMFLAGS);
      assert(ID > 0);
      NB = GetUserFNB(pre, nb0, mb, nb, kb, iflag);
      if (!NB)
         printf("Rejected icase=%d, NB=%d, MB,NB,KB=%d,%d,%d\n", 
                ID, nb0, mb, nb, kb);
      else
      {
         mf = ummcase(pre, ID, NB);
         adv = 1.0;
            
         if (mf > adv*mfbest)
         {
            if (utstmmcase(pre, ID, NB))
            { /* test kernel before accepting */
               ibest = ID;
               mfbest = mf;
               nbB = NB;
            }
         }
         fprintf(stdout, "%3d. NB=%3d, rout=%40s, MFLOP=%.2f\n", 
                 i, NB, fnam, mf);
         if (fpsum)
            fprintf(fpsum, "%3d. ID=%8d, NB=%3d, rout=%40s, MFLOP=%.2f\n", 
                    i, ID, NB, fnam, mf);
      }
   }
   if (fpsum)
      fclose(fpsum);
   printf("BEST CASE IS ID=%d, NB=%d, MFLOP=%.2f\n", ibest, nbB, mfbest);
   return(ibest);
}

int FindBestUser(char pre, int nb0)
/*
 * returns index in <pre>cases.dsc of best user-supplied GEMM, using
 * a blocking factor as close to nb0 as possible
 */
{
   char *MCC, *MMFLAGS;
   char ln[256], fnam[256];
   double mf, mfbest=0.0, adv;
   int ibest=(-1), i, ncases;
   int ID, iflag, NB, mb, nb, kb, ma, lat, mu, nu, ku, nbB=0;
   FILE *fpsum;

   sprintf(ln, "res/%cucases.res", pre);
   fpsum = fopen(ln, "w");
   ncases = NumUserCases(pre);
   for (i=0; i < ncases; i++)
   {
      ID = GetUserCase(pre, -i, &iflag, &mb, &nb, &kb, &ma, &lat, 
                       &mu, &nu, &ku, fnam, ln, &MCC, &MMFLAGS);
      assert(ID > 0);
      NB = GetUserNB(pre, nb0, mb, nb, kb, iflag);
      if (NB)
      {
         mf = ummcase(pre, ID, NB);
         if (NB > 80 && nbB < NB-8)
            adv = 1.08;           /* penalize large NB due to cleanup probs */
         else if (NB > nbB)       /* slightly favor small NB */
            adv = 1.001;
         else if (NB < nbB)       /* slightly favor small NB */
            adv = 0.999;
         else 
            adv = 1.0;
            
         if (mf > adv*mfbest)
         {
            if (utstmmcase(pre, ID, NB))
            { /* test kernel before accepting */
               ibest = ID;
               mfbest = mf;
               nbB = NB;
            }
         }
         fprintf(stdout, "%3d. NB=%3d, rout=%40s, MFLOP=%.2f\n", 
                 i, NB, fnam, mf);
         if (fpsum)
            fprintf(fpsum, "%3d. ID=%8d, NB=%3d, rout=%40s, MFLOP=%.2f\n", 
                    i, ID, NB, fnam, mf);
      }
   }
   if (fpsum)
      fclose(fpsum);
   printf("BEST CASE IS ID=%d, NB=%d, MFLOP=%.2f\n", ibest, nbB, mfbest);
   return(ibest);
}

void PrintUsage(char *fnam)
{
   fprintf(stderr, 
           "\nUSAGE: %s -p <pre> -n <nb> -e <search summary file\n\n", fnam);
   exit(-1);
}

ROUTNODE *GetFlags(int nargs, char **args, char *pre, int *nb0, int *FNB,
                   enum CLEAN_WHICH *which)
/*
 * RETURNS: a queue of filenames, which are the output files from external
 *          searches (using atlas_mmtesttime.h format).
 */
{
   int i, ID=10000;
   char ch;
   ROUTNODE *efb=NULL, *ef, *ep;/* base &ptr to external search summary files */

   *FNB = *nb0 = 0;
   *pre = 'd';
   *which = CleanNot;
   for (i=1; i < nargs; i++)
   {
      if (args[i][0] != '-') PrintUsage(args[0]);
      switch(args[i][1])
      {
      case 'p':
         i++;
         ch = tolower(args[i][0]);
         if (ch == 'd' || ch == 's' || ch == 'z' || ch == 'c') *pre = ch;
         else PrintUsage(args[0]);
         break;
      case 'n':
         *nb0 = atoi(args[++i]);
         break;
      case 'N':
         *FNB = atoi(args[++i]);
         break;
      case 'e':
         if (++i > nargs)
            PrintUsage(args[0]);
          ep = CreateRoutNode(args[i], ID, 0.0);
          if (efb)
             ef->next = ep;
          else
             efb = ep;
          ef = ep;
          ID += 5000;
          break;
      case 'C':
         switch(args[++i][0])
         {
         case 'm':
            *which = CleanM;
            break;
         case 'n':
            *which = CleanN;
            break;
         case 'k':
            *which = CleanK;
            break;
         default:
            *which = CleanNot;
         }
         break;
      default:
         PrintUsage(args[0]);
      }
   }
   return(efb);
}

int FindBestNB(pre, icase)
{
   double mf, mfb;
   int iflag, mb, nb, kb, muladd, lat, mu, nu, ku;
   int i, j, mult, iret=0;
   char fnam[ROUTLEN], *MCC, *MMFLAGS;
   assert(GetUserCase(pre, icase, &iflag, &mb, &nb, &kb, &muladd, &lat, 
                      &mu, &nu, &ku, fnam, fnam, &MCC, &MMFLAGS));

   if (mb < 0) iret = -mb;
   else if (nb < 0) iret = -nb;
   else if (kb < 0) iret = -kb;
   else
   {
/*
 *    Find mult necessary to satisfy user constraints on mb, nb, and kb
 */
      if (mb != 0) i = mb;
      else i = 1;
      if (nb != 0) j = nb;
      else j = 1;
      mult = Mylcm(i, j);
      if (kb != 0) i = kb;
      else i = 1;
      mult = Mylcm(i, mult);
/*
 *    Make sure mult is a multiple of Cachelen as well
 */
      if (pre == 's' || pre == 'c') i = ATL_Cachelen / ATL_ssize;
      else i = ATL_Cachelen / ATL_dsize;
      if (i > 1) mult = Mylcm(i, mult);
      fprintf(stdout, "\nFINDING BEST BLOCKING FACTOR FOR CASE %d, MUL=%d:\n",
              icase, mult);

      j = L1Elts(pre, 128);
      for (i=mult; i < 16; i += mult);
      mfb = 0.0;
      iret = i;
      for (; ((i*i <= j) && (i <= MAX_NB)); i += mult)
      {
         mf = ummcase(pre, icase, i);
         if (mf > mfb)
         {
            mfb = mf;
            iret = i;
         }
         fprintf(stdout, "   NB=%d: %.2f MFLOP\n", i, mf);
      }
   }
   fprintf(stdout, "BEST BLOCKING FACTOR FOR CASE %d:  %d\n", icase, iret);
   return(iret);
}

int NumMults(void)
{
   MULTHEAD *mh;
   int i;

   for(i=0, mh=imhead; mh; mh = mh->next, i++) if (mh->rn->next) i++;
   return(i);
}

void Printpline(char pre, enum CLEAN_WHICH which, int nb, int imult, 
                ROUTNODE *rn, FILE *fp)
{
   int NB[3];
   GetPNB(pre, which, rn->icase, nb, imult, NB);
   fprintf(fp, "%4d  %5d  %5d %3d  %3d  %3d  %3d  %8.2f  %s\n",
           imult, rn->icase, rn->fixed, nb, NB[0], NB[1], NB[2],
           rn->mflop, rn->rout);
}
void CreatepUMMOut(char pre, enum CLEAN_WHICH which, int nb)
{
   MULTHEAD *mh;
   char cwh[3] = {'M', 'N', 'K'};
   char fnam[128];
   int NB[3];
   FILE *fp;

   sprintf(fnam, "res/%cuClean%c", pre, cwh[which]);
   fp = fopen(fnam, "w");
   assert(fp);
   fprintf(fp, "MULT  ICASE  FIXED  NB  NB0  NB1  NB2     MFLOP  ROUT\n");
   fprintf(fp, "%d\n", NumMults());
   for (mh=imhead; mh; mh = mh->next)
   {
      Printpline(pre, which, nb, mh->imult, mh->rn, fp);
      if (mh->rn->next) Printpline(pre, which, nb, mh->imult, mh->rn->next, fp);
   }
}

void FindUClean(char pre, int nb0, enum CLEAN_WHICH which)
{
   BuildTable(pre, which, nb0);
   PrintTable(stdout);
   TimeTable(pre, which, nb0);
   PrintTable(stdout);
   ReduceTable(pre, which, nb0);
   PrintTable(stdout);

   CreatepUMMOut(pre, which, nb0);
   KillAllMultNodes();
}

void CreateUMMOut(char pre, int icase, int NB, double mf)
{
   char fnam[ROUTLEN], auth[AUTHLEN], *MCC, *MMFLAGS;
   int iflag, mb, nb, kb, muladd, lat, mu, nu, ku;
   FILE *fp;

   sprintf(auth, "res/%cuMMRES", pre);
   fp = fopen(auth, "w");
   assert(fp);

   if (icase > 0)
   {
      assert(GetUserCase(pre, icase, &iflag, &mb, &nb, &kb, &muladd, &lat, 
                         &mu, &nu, &ku, fnam, auth, &MCC, &MMFLAGS));
   }
   else
   {
      mf = -1.0;
      strcpy(auth, "Nobody");
      strcpy(fnam, "Nocomp");
   }
   fprintf(fp, "CASE  NB    MFLOP  ROUTINE\n");
   fprintf(fp, "%4d %3d %8.2f  \"%.64s\" \"%.64s\"\n", 
           icase, NB, mf, fnam, auth);
   fclose(fp);
}

void FindUMM(char pre, int nb0)
{
   double mf, mf0;
   int nb, icase;

   icase = FindBestUser(pre, nb0);
   if (icase >= 0)
   {
      mf0 = GetRes(GetUserOutFile(pre, icase, nb0, nb0, nb0));
      nb = FindBestNB(pre, icase);
      mf = GetRes(GetUserOutFile(pre, icase, nb, nb, nb));
      if (mf <= mf0) 
      {
         nb = nb0;
         mf = mf0;
      }
   }
   else
   {
      nb = nb0;
      mf = -1.0;
   }
   CreateUMMOut(pre, icase, nb, mf);
   fprintf(stdout, "\nBEST USER CASE %d, NB=%d: %.2f MFLOP\n\n", icase, nb, mf);
}

void RunTimes(char pre)
{
   double mf;
   FILE *fp;
   int j, icase, nb;
   char ln[128];
   ATL_mmnode_t *mmp;

   sprintf(ln, "res/%cuMMRES", pre);
   if (FileExists(ln))
   {
      fp = fopen(ln, "r");
      assert( fgets(ln, 128, fp) != NULL );
      assert( fscanf(fp, " %d %d", &icase, &nb) == 2);
      fclose(fp);
      if (icase >= 0)
      {
         mf = ummcase(pre, icase, nb);
         CreateUMMOut(pre, icase, nb, mf);
         fprintf(stdout, "\nBEST USER CASE %d, NB=%d: %.2f MFLOP\n\n",
                 icase, nb, mf);
      }
   }
   else
   {
      mmp = ReadMMFileWithPath(pre, "res", "MMRES.sum");
      if (!mmp)
         mmp = ReadMMFileWithPath(pre, "res", "gMMRES.sum");
      assert(mmp);
      nb = (mmp->next) ? mmp->next->nbB : mmp->nbB;
      KillAllMMNodes(mmp);
@beginskip
      sprintf(ln, "res/%cMMRES", pre);
      if (!FileExists(ln)) sprintf(ln, "res/%cgMMRES", pre);
      GetInstLogFile(ln, pre, &j, &j, &j, &nb, &j, &j, &j, &j, &j, &j, &mf);
@endskip
      FindUMM(pre, nb);
   }
}

void GetuMMRES(char pre)
{
   double mf;
   FILE *fp;
   int j, icase, nb;
   char ln[128];
   ATL_mmnode_t *mmp;

   sprintf(ln, "res/%cuMMRES", pre);
   if (FileExists(ln))
   {
      fp = fopen(ln, "r");
      assert( fgets(ln, 128, fp) != NULL );
      assert( fscanf(fp, " %d %d %lf", &icase, &nb, &mf) == 3);
      fclose(fp);
      if (icase >= 0 && mf <= 0.0)
      {
         mf = ummcase(pre, icase, nb);
         CreateUMMOut(pre, icase, nb, mf);
         fprintf(stdout, "\nBEST USER CASE %d, NB=%d: %.2f MFLOP\n\n",
                 icase, nb, mf);
      }
   }
   else
   {
      mmp = ReadMMFileWithPath(pre, "res", "MMRES.sum");
      if (!mmp)
         mmp = ReadMMFileWithPath(pre, "res", "gMMRES.sum");
      assert(mmp);
      nb = (mmp->next) ? mmp->next->nbB : mmp->nbB;
      KillAllMMNodes(mmp);
@beginskip
      sprintf(ln, "res/%cMMRES", pre);
      if (!FileExists(ln)) sprintf(ln, "res/%cgMMRES", pre);
      GetInstLogFile(ln, pre, &j, &j, &j, &nb, &j, &j, &j, &j, &j, &j, &mf);
@endskip
      FindUMM(pre, nb);
   }
}

ATL_mmnode_t *ReadOldUserFile(char pre)
/*
 * Reads original res/<pre>uMMRES file, and returns filled-in ATL_mmnode_t
 */
{
   char ln[1024], ln2[1024];
   double mf;
   int id, nb, iflag, i;
   ATL_mmnode_t *mmp;
   FILE *fp;

   mmp = GetMMNode();
   sprintf(ln, "res/%cuMMRES", pre);
   fp = fopen(ln, "r");
   assert(fp);
   assert(fgets(ln, 1024, fp));
   assert(fgets(ln, 1024, fp));
   sscanf(ln, "%d %d %lf", &id, &nb, &mf);
   fclose(fp);
   mmp->ID = id;
   mmp->mflop[0] = mf;
   mmp->mbB = mmp->nbB = mmp->kbB = nb;
   assert(GetUserCase(pre, id, &iflag, &i, &i, &i, &mmp->muladd, &mmp->lat,
                      &mmp->mu, &mmp->nu, &mmp->ku, ln, ln2,
                      &mmp->comp, &mmp->cflags));
   mmp->comp = DupString(mmp->comp);
   mmp->cflags = DupString(mmp->cflags);
   i = strlen(ln) + 7;
   mmp->rout= malloc(i * sizeof(char));
   assert(mmp->rout);
   mmp->auth = DupString(ln2);
   sprintf(mmp->rout, "CASES/%s", ln);
   if (iflag & 32)
   {
      SET_FLAG(mmp->flag, MMF_LDISKB, 0);
      SET_FLAG(mmp->flag, MMF_LDAB, 0);
   }
   if (iflag & 64)
      SET_FLAG(mmp->flag, MMF_MRUNTIME, 1);
   if (iflag & 128)
      SET_FLAG(mmp->flag, MMF_NRUNTIME, 1);
   if (iflag & 256)
      SET_FLAG(mmp->flag, MMF_KRUNTIME, 1);
   return(mmp);
}

void getBestOfSearches
(
   char pre,            /* precision prefix */
   int verb,            /* verbosity */
   ROUTNODE *esumb      /* list of search output files */
)
/*
 * Scopes all external search summary files, output res/<pre>eMMRES.sum
 * file describing best user/external kernel available.
 */
{
   ATL_mmnode_t *mmb, *mmp, *mmB;
   double mfB;
   ROUTNODE *ep;
   char ln[2048];

   mmb = ReadMMFileWithPath(pre, "res", "eMMRES.sum");
   if (mmb)    /* already have output file from previous run */
   {
/*
 *    Rerun external searches to force generation of any needed files
 */
      for (ep=esumb; ep; ep = ep->next)
      {
         sprintf(ln, "make %s\n", ep->rout);
         if (system(ln))
            fprintf(stderr, "EXTERNAL SEARCH FAILED: %s", ln);
      }
/*
 *    Retime best kernel, and rewrite output file if necessary
 */
      if (mmb->mflop[0] <= 0.0)
      {
         TimeAllMMKernels(0, verb, 0, mmb, pre, 0, 0, 0, 1, 0, 0);
         WriteMMFileWithPath(pre, "res", "eMMRES.sum", mmb);
      }
/*
 *    Echo best case to screen and return
 */
      fprintf(stdout, "\nBEST OF USER CASES AND EXTERNAL SEARCHES:\n");
      PrintMMNodes(stdout, mmb);
      KillAllMMNodes(mmb);
      return;
   }
   mmb = mmp = ReadOldUserFile(pre);   /* get best user case */
   assert(mmb);
   for (ep=esumb; ep; ep = ep->next)
   {
      sprintf(ln, "make %s\n", ep->rout);
      if (system(ln))
      {
         fprintf(stderr, "EXTERNAL SEARCH FAILED: %s", ln);
         continue;
      }
      mmp->next = ReadMMFile(ep->rout);
      if (!mmp->next)
      {
         fprintf(stderr, "EXTERNAL SEARCH FAILED: %s", ep->rout);
         continue;
      }
/*
 *    If MFLOPs not set, time and the write back out
 */
      if (mmp->next->mflop[0] <= 0.0)
      {
         TimeAllMMKernels(0, verb, 1, mmp->next, pre, 0, 0, 0, 1, 0, 0);
         WriteMMFile(ep->rout, mmp->next);
      }
/*
 *    Right now, should always be one kernel, but if there are multiple,
 *    they all get considered, so find the last one as link in the queue
 *    to be compared
 */
      while (mmp->next) 
         mmp = mmp->next;
   }
/*
 * Nuke kernels that don't pass basic tests, time survivors, in mflop[1]
 * NOTE: could time BETA cases separately and build best-of-breed, but
 *       this would require that kernels have same NB, and be kind of
 *       messy, so for now assume perf follows BETA=1 case
 */
   mmb = DelBadMMKernels(pre, verb, mmb);
   TimeAllMMKernels(1, verb, 1, mmb, pre, 0, 0, 0, 1, 0, 0);
/*
 * Pick fastest kernel whose NB <= 80
 */
   mfB = mmb->mflop[1];
   mmB = mmb;
   for (mmp=mmb->next; mmp; mmp = mmp->next)
   {
      if (mmp->nbB <= 80 && mfB < mmp->mflop[1])
      {
         mfB = mmp->mflop[1];
         mmB = mmp;
      }
   }
   mmB = CloneMMNode(mmB);
   KillAllMMNodes(mmb);
@skip   sprintf(ln, "res/%ceMMRES.sum", pre);
@skip   WriteMMFile(ln, mmB);
   WriteMMFileWithPath(pre, "res", "eMMRES.sum", mmB);
   fprintf(stdout, "\nBEST OF USER CASES AND EXTERNAL SEARCHES:\n");
   PrintMMNodes(stdout, mmB);
   KillAllMMNodes(mmB);
}

int main(int nargs, char **args)
{
   int i, nb0, verb=1, FNB;
   enum CLEAN_WHICH which;
   char pre, ln[16];
   ROUTNODE *esumb;

   esumb = GetFlags(nargs, args, &pre, &nb0, &FNB, &which);
   if (FNB)
   {
      i = FindBestUserFNB(pre, FNB);
      printf("nb=%d, i=%d\n", FNB, i);
   }
   else if (nb0 <= 0)
   {
      GetuMMRES(pre);
      getBestOfSearches(pre, verb, esumb);
   }
   else if (which == CleanNot)
   {
      sprintf(ln, "res/%cuMMRES", pre);
      if (FileExists(ln))
         GetuMMRES(pre);
      else
         FindUMM(pre, nb0);
      getBestOfSearches(pre, verb, esumb);
   }
   else
   {
      getBestOfSearches(pre, verb, esumb);
      FindUClean(pre, nb0, which);
   }
   KillAllRoutNodes(esumb);
   fprintf(stderr, "SUCCESSFUL FINISH FOR %s\n\n", args[0]);
   return(0);
}
@ROUT ccsearch
void PrintUsage(char *nam)
{
   fprintf(stderr, "\n\nUSAGE: %s [-b <nb> -m <mu> -n <nu> -k <ku> -l <lat> -m <muladd> -p <pre>] <infile>\n\n");
}
@ROUT GetSysSum
@extract -b @(topd)/gen.inc what=cw

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <assert.h>
#include "atlas_type.h"
#include "atlas_fopen.h"
#include "atlas_sys.h"
@ROUT mvsearch GetSysSum
int GetL1CacheSize(int MaxL1Size)
{
   FILE *L1f;
   char ln[80];
   int L1Size;

   if (!FileExists("res/L1CacheSize"))
   {
      sprintf(ln, "make RunL1 MaxL1=%d\n",MaxL1Size);
      assert(system(ln) == 0);
   }
   L1f = fopen("res/L1CacheSize", "r");
   assert(L1f != NULL);
   assert(fscanf(L1f, "%d", &L1Size) == 1);
   fclose(L1f);
   fprintf(stderr, "\n      Read in L1 Cache size as = %dKB.\n",L1Size);
   return(L1Size);
}

@ROUT GetSysSum
size_t GetPageSize(void)
{
   size_t pgsz=4096;
   char *sp;
   sp = atlsys_1L(NULL, "getconf PAGESIZE", 0, 1);
   if (!sp)
      sp = atlsys_1L(NULL, "getconf PAGE_SIZE", 0, 1);
   if (sp)
   {
      unsigned long sz;
      if (sscanf(sp, "%lu", &sz) == 1)
         pgsz = sz;
      free(sp);
   }
   return(pgsz);
}
void getfpinfo0(char pre, int *muladd, int *lat, int *lbnreg, double *mf)
{
   char fnam[128];
   FILE *fp;

   if (pre == 'z') pre = 'd';
   else if (pre == 'c') pre = 's';

   sprintf(fnam, "res/%cMULADD", pre);
   if (!FileExists(fnam))
   {
      sprintf(fnam, "make res/%cMULADD pre=%c\n", pre, pre);
      assert(system(fnam) == 0);
      sprintf(fnam, "res/%cMULADD", pre);
   }
   fp = fopen(fnam, "r");
   assert(fp);
   assert(fscanf(fp, " %d", muladd) == 1);
   assert(fscanf(fp, " %d", lat) == 1);
   assert(fscanf(fp, " %lf", mf) == 1);
   assert(fscanf(fp, " %d", lbnreg) == 1);
   fclose(fp);
}

void getfpinfo(char pre, int *muladd, int *lat, int *lbnreg, int *nkflop)
{
   double mf;
   char ln[32];

   getfpinfo0(pre, muladd, lat, lbnreg, &mf);
   if (mf <= 0.0)
   {
      if (pre == 'c') pre = 's';
      else if (pre == 'z') pre = 'd';
      sprintf(ln, "make RunMADef pre=%c\n", pre);
      assert(system(ln) == 0);
      getfpinfo0(pre, muladd, lat, lbnreg, &mf);
      assert(mf >= 0.0);
   }
   mf = mf * 0.75 * 750;
   #ifdef ATL_ARCH_ATHLON  /* kludge for athlon defaults */
      mf *= 3.0;
   #endif
   if (mf > (double)(1<<30)) *nkflop = ~(1<<31);
   else *nkflop = mf;
}

void CreateHeader(char pre, char *fnam, int L1Size, int muladd, int lat,
                  int lbnreg, int nkflop, int mmnreg, size_t pgsz)
{
   FILE *fpout;

   fpout = fopen(fnam, "w");
   assert(fpout);
   fprintf(fpout, "#ifndef ATL_%cSYSINFO_H\n   #define ATL_%cSYSINFO_H\n\n",
           toupper(pre), toupper(pre));
   if (muladd) fprintf(fpout, "#define ATL_MULADD\n");
   else fprintf(fpout, "#define ATL_NOMULADD\n");
   fprintf(fpout, "#define ATL_L1elts %d\n", L1Size);
   fprintf(fpout, "#define ATL_fplat  %d\n", lat);
   fprintf(fpout, "#define ATL_lbnreg %d\n", lbnreg);
   fprintf(fpout, "#define ATL_mmnreg %d\n", mmnreg);
   fprintf(fpout, "#define ATL_nkflop %d\n", nkflop);
   fprintf(fpout, "#define ATL_pgsz %lu\n", pgsz);
   fprintf(fpout, "\n#endif\n");
   fclose(fpout);
}

int getmmnreg(char pre)
{
   char fnam[128];
   int mmnregs;
   FILE *fp;

   if (pre == 'z') pre = 'd';
   else if (pre == 'c') pre = 's';
   sprintf(fnam, "res/%cnreg", pre);
   if (!FileExists(fnam))
   {
      sprintf(fnam, "make res/%cnreg\n", pre);
      assert(system(fnam) == 0);
      sprintf(fnam, "res/%cnreg", pre);
   }
   fp = fopen(fnam, "r");
   assert(fp);
   assert(fscanf(fp, " %d", &mmnregs) == 1);
   fclose(fp);
   return(mmnregs);
}

int main(int nargs, char **args)
{
   size_t pgsz;
   int MaxL1Size;
   int muladd, lat, lbnreg, L1Size, mmnreg, nkflop;
   FILE *fpout;
   char pre;

   if (nargs != 3)
   {
      fprintf(stderr, "USAGE: %s <pre> <file>\n", args[0]);
      exit(-1);
   }
   pre = *args[1];

   L1Size = 1024 * GetL1CacheSize(64);
   if (pre == 'd') L1Size /= ATL_dsize;
   else if (pre == 's') L1Size /= ATL_ssize;
   else if (pre == 'c') L1Size /= ATL_csize;
   else if (pre == 'z') L1Size /= ATL_zsize;
   getfpinfo(pre, &muladd, &lat, &lbnreg, &nkflop);
   pgsz = GetPageSize();
   CreateHeader(pre, args[2], L1Size, muladd, lat, lbnreg, nkflop, 0, pgsz);
   mmnreg = getmmnreg(pre);
   CreateHeader(pre, args[2], L1Size, muladd, lat, lbnreg, nkflop, mmnreg,pgsz);
   return(0);
}
@ROUT masearch
@ROUT mvsearch mmsearch l1search gmmsearch
void GetMulAdd(char pre, int *MULADD, int *lat)
{
   char nam[64], ln[128];
   FILE *fp;

   sprintf(nam, "res/%cMULADD", pre);
   if (!FileExists(nam))
   {
      sprintf(ln, "make RunMulAdd pre=%c maxlat=%d mflop=%d\n", pre, 6, 200);
      assert(system(ln) == 0);
   }
   fp = fopen(nam, "r");
   assert(fp != NULL);
   assert(fscanf(fp, "%d", MULADD) == 1);
   assert(fscanf(fp, "%d", lat) == 1);
   fclose(fp);
}

@ROUT mmsearch
int GetNumRegsMM(char pre, int MaxL1Size, int MAX_NREG)
{
   int nreg;
   nreg = GetNumRegs(pre, MaxL1Size, MAX_NREG);
   if (nreg == -1)
   {
      fprintf(stderr, 
         "\nUNABLE TO FIND NUMBER OF REGISTERS, ASSUMMING 32.\n\n");
      nreg = 32;
   }
/*
   if (nreg > 128)
   {
      fprintf(stderr, "FOUND NUMBER OF REGISTERS TO BE %d; THIS WOULD TAKE TOO LONG TO SEARCH, SO SETTING TO 128.\n", nreg);
      nreg = 128;
   }
*/
   if (nreg < 8)
   {
      fprintf(stderr, 
              "FOUND # OF REGISTERS TO BE %d; TRYING 8 FOR SAFETY.\n", nreg);
      nreg = 8;
   }
#if !defined (ATL_GAS_x8632) && !defined(ATL_GAS_x8664)
   else if (nreg < 16)
   {
      fprintf(stderr, 
              "FOUND # OF REGISTERS TO BE %d; TRYING 16 FOR SAFETY.\n", nreg);
      nreg = 16;
   }
#endif
   return(nreg);
}

void GetMMRES(char pre, int nreg, int MaxL1Size, int ForceLat)
{
   char upre;
   char ln[128];
   int i, nNBs, muladd, lat, l1size;
   int *NBs;
   FILE *fp;

   if (pre == 'c') upre = 's';
   else if (pre == 'z') upre = 'd';
   else upre = pre;

   sprintf(ln, "res/%cNB", pre);
   if (!FileExists(ln)) findNBs(upre, ln, MaxL1Size);
   assert( (fp = fopen(ln, "r")) != NULL );
   fscanf(fp, "%d", &nNBs);
   fprintf(stdout, "\nNB's to try: ");
   NBs = malloc(nNBs*sizeof(int));
   for (i=0; i != nNBs; i++)
   {
      fscanf(fp, "%d", NBs+i);
      fprintf(stdout, "%d   ",NBs[i]);
   }
   fprintf(stdout, "\n\n");

   l1size = GetCacheSize(MaxL1Size) * 1024;
   ProbeFPU(pre, l1size, nreg, &muladd, &lat);
@skip   GetMulAdd(upre, &muladd, &lat);
   if (ForceLat != -1) lat = ForceLat;


   if (pre == 'c' || pre == 'z')
      cmmsearch(pre, muladd, 0, nNBs, NBs, nreg, lat, 0);
   else mmsearch(pre, muladd, 0, nNBs, NBs, nreg, lat, 0);
   free(NBs);
}
#ifndef ATL_MAXNREG
   #define ATL_MAXNREG 64
#endif
int main(int nargs, char *args[])
{
   char prec, upre, lang;
   int MULADD, MaxL1Size, ForceLat, i, nreg, ROUT, FRC;
   int muladd, lat, nb, mu, nu, ku, ffetch, ifetch, nfetch, pfA;
   int unb, icase;
   double mf, umf;
   FILE *fp;
   char ln[128], auth[65];
   ATL_mmnode_t *mmp;

   GetSettings(nargs, args, &prec, &lang, &ku, &ForceLat, &FRC, &nreg, 
               &MaxL1Size, &ROUT);
   assert(FRC == 0 && ku == 0); /* obsolete flags */
   LANG = lang;

   if (prec == 'z') upre = 'd';
   else if (prec == 'c') upre = 's';
   else upre = prec;
@beginskip
   if (ROUT == -2)
   {
      #if VERB > 0
         fprintf(stderr, "%d of %s\n", __LINE__, __FILE__);
      #endif
      RunTimes(prec);
      #if VERB > 0
         fprintf(stderr, "%d of %s\n", __LINE__, __FILE__);
      #endif
      exit(0);
   }
@endskip
   if (ROUT == -3)
   {
      #if VERB > 0
         fprintf(stderr, "%d of %s\n", __LINE__, __FILE__);
      #endif
      FindAllClean(prec);
      #if VERB > 0
         fprintf(stderr, "%d of %s\n", __LINE__, __FILE__);
      #endif
      exit(0);
   }
   else if (ROUT == -4)
   {
      #if VERB > 0
         fprintf(stderr, "%d of %s\n", __LINE__, __FILE__);
      #endif
      FindAllUserClean0(prec);
      #if VERB > 0
         fprintf(stderr, "%d of %s\n", __LINE__, __FILE__);
      #endif
      exit(0);
   }
   else if (ROUT == -5) /* produce ATL_mmnreg for sysinfo */
   {
      #if VERB > 0
         fprintf(stderr, "%d of %s\n", __LINE__, __FILE__);
      #endif
      GetNumRegs(prec, Mmin(MaxL1Size,32), ATL_MAXNREG);
      #if VERB > 0
         fprintf(stderr, "%d of %s\n", __LINE__, __FILE__);
      #endif
      exit(0);
   }
   else if (ROUT == -6) /* Find the best no-copy code */
   {
      #if VERB > 0
         fprintf(stderr, "%d of %s\n", __LINE__, __FILE__);
      #endif
      FindNoCopy(prec);
      #if VERB > 0
         fprintf(stderr, "%d of %s\n", __LINE__, __FILE__);
      #endif
      exit(0);
   }
   fprintf(stderr, "Precision='%c', FORCE=%d, LAT=%d, nreg=%d, MaxL1=%d\n",
           prec, FRC, ForceLat, nreg, MaxL1Size);

   #if VERB > 0
      fprintf(stderr, "%d of %s\n", __LINE__, __FILE__);
   #endif
   if (nreg == -1) nreg = GetNumRegsMM(upre, Mmin(MaxL1Size,32), ATL_MAXNREG);
   #if VERB > 0
      fprintf(stderr, "%d of %s\n", __LINE__, __FILE__);
   #endif
   GetMMRES(prec, nreg, MaxL1Size, ForceLat);
   #if VERB > 0
      fprintf(stderr, "%d of %s\n", __LINE__, __FILE__);
   #endif
   FindNoCopy(prec);
   #if VERB > 0
      fprintf(stderr, "%d of %s\n", __LINE__, __FILE__);
   #endif
   FindAllClean(prec);
   #if VERB > 0
      fprintf(stderr, "%d of %s\n", __LINE__, __FILE__);
   #endif

@beginskip
   sprintf(ln, "res/%cMMRES", prec);
   fp = fopen(ln, "r");
   assert(fp);
   assert( fgets(ln, 128, fp) != NULL );
   GetInstLogLine(fp, &muladd, &pfA, &lat, &nb, &mu, &nu, &ku, &ffetch,
                     &ifetch, &nfetch, &mf);
   assert( fgets(ln, 128, fp) != NULL );
   assert(fscanf(fp, " %d %d %lf \"%[^\"]\" \"%[^\"]", &icase, &unb, &umf, 
                 ln, auth) == 5);
   fclose(fp);
@endskip
   mmp = GetOrTransMMRES(prec);
   assert(mmp);
   if (!mmp->next || mmp->mflop[0] >= mmp->next->mflop[0])
   {
      fprintf(stdout, "\n\nFor this run, the best parameters found were MULADD=%d, lat=%d, NB=%d, MU=%d, NU=%d, KU=%d\n",
              mmp->muladd, mmp->lat, mmp->nbB, mmp->mu, mmp->nu, mmp->ku);
      mf = mmp->mflop[0];
   }
   else
   {
       mf = umf;
       fprintf(stdout, 
               "\n\nFor this run, the best case found was NB=%d user case %d\n",
               mmp->next->nbB, mmp->next->ID);
       fprintf(stdout, "written by %s.\n", mmp->next->auth);
      mf = mmp->next->mflop[0];
   }
   fprintf(stdout, "This gave a performance = %f MFLOP.\n", mf);
   fprintf(stdout, 
"The necessary files have been created.  If you are happy with\n");
   fprintf(stdout, 
"the above mflops for your system, type 'make %cinstall'.\n", prec);
   fprintf(stdout, 
"Otherwise, try the xmmsearch with different parameters, or hand\n");
   fprintf(stdout, "tweak the code.\n");
   return(0);
}
@ROUT mvsearch
#define NTIM 3
#define MAXLAT 6

#define Rmax(x, y) ( (x) > (y) ? (x) : (y) )

void PrintUsage(char *xnam)
{
   fprintf(stderr, "\n\nUsage: %s [-r #][-h][-f][-l #][-p s/d/c/z][-m #]\n",
           xnam);
   fprintf(stderr, "-h         : Print this help screen\n");
@skip   fprintf(stderr, "-f         : Force complete search over given parameters\n");
   fprintf(stderr, "-p s/d/c/z : set the precision to search for\n");
   fprintf(stderr, "-r #       : Set max number of registers to use to # (default 8)\n");
   fprintf(stderr, "-c #       : Set max L1 cache size (kilobytes) to #\n");
   fprintf(stderr, "-N #       : Set max M unrolling factor to #\n");
   fprintf(stderr, "-A n/t/c   : choose a transpose setting.\n");
   fprintf(stderr, "-l #       : Use latency factor #.  If set to 0,\n");
   fprintf(stderr, 
"             do not do latency checking.  By default, latency checking is\n");
   fprintf(stderr, 
"             done only if initial timings show it is a win.\n");
   fprintf(stderr, 
"-M <startMU> <endMU> <incMU> : Set the beginning end and increment between each\n");
   fprintf(stderr, 
"                               M unrolling factor to check.\n");
   fprintf(stderr, 
"-N <startNU> <endNU> <incNU> : Set the beginning end and increment between each\n");
   fprintf(stderr, 
"                               N unrolling factor to check.\n");
   exit(-1);
}

void GetSettings(int nargs, char *args[], char *pre, char *TA,
                 int *MaxL1Size, int *startMU, int *endMU, int *incMU,
                 int *startNU, int *endNU, int *incNU)
{
   int i;

   *TA = 'N';
   *startMU = -1;
   *startNU = 1;
   *endNU = 8;
   *incNU = 1;
   *MaxL1Size = 64;
   *pre = 'd';
   for (i=1; i < nargs; i++)
   {
      if (*args[i] != '-') PrintUsage(args[0]);
      switch(args[i][1])
      {
      case 'A':
         i++;
         if ( (*args[i] == 'T') || (*args[i] == 't') ) *TA = 'T';
         else if ( (*args[i] == 'C') || (*args[i] == 'c') ) *TA = 'C';
         else *TA = 'N';
         break;
      case 'M':
         *startMU = atoi(args[++i]);
         *endMU = atoi(args[++i]);
         *incMU = atoi(args[++i]);
         break;
      case 'N':
         *startNU = atoi(args[++i]);
         *endNU = atoi(args[++i]);
         *incNU = atoi(args[++i]);
         break;
      case 'c' :
         *MaxL1Size = atoi(args[++i]);
         break;
      case 'p' :
         *pre = *args[++i];
         break;
      default:
      case 'h' :
         PrintUsage(args[0]);
      }
   }
   if (*startMU == -1)
   {
      if (*TA == 'N')
      {
         *startMU = 4;
         *endMU = 8;
         *incMU = 4;
      }
      else
      {
         *startMU = 1;
         *endMU = 8;
         *incMU = 1;
      }
   }
}

double mvs_case(char pre, char TA, int muladd, int mu, int nu, int lat, 
                int Xregs, int Ydup, int maxM)
{
   char fnam[80], ln[80];
   int i, j;
   double mflop[NTIM], t0;
   FILE *fp;
   lat = 1;

   sprintf(fnam, "res/%cmv%c%dx%d_x%d_d%d_m%d_%dx%d.mflop", pre, TA, mu, nu, 
           Xregs, Ydup, maxM, lat, muladd);
   if (!FileExists(fnam))
   {
      sprintf(ln, "make %cmvtime%c mu=%d nu=%d muladd=%d lat=%d xregs=%d ydup=%d maxm=%d\n", 
              pre, TA, mu, nu, muladd, lat, Xregs, Ydup, maxM);
      fprintf(stderr, "%s:\n",ln);
      assert(system(ln) == 0);
   }
   assert( (fp = fopen(fnam, "r")) != NULL );
   t0 = 0.0;
   j = 0;
   for (i=0; i != NTIM; i++) assert( fscanf(fp, "%lf", &mflop[i]) );
   fclose(fp);
   t0 = GetAvg(NTIM, TOLERANCE, mflop);

   if (t0 == -1.0)
   {
      fprintf(stderr, "MU=%d, NU=%d: kill file and rerun with higher reps; variation exceeds tolerence\n", mu, nu);
      exit(-1);
   }
   return(t0);
}

typedef struct mvbest MVBEST;
struct mvbest
{
   int mu, nu, muladd, Ydup, Xregs, maxM;
   double mflop;
};

double mvsearchN0(char pre, char TA, int muladd, int mu, int nu, int lat, 
                  int Ydup, MVBEST *bp)
{
   double mf0, mf, mmf=0.0;
   int i;

   if (Ydup > 1) mf0 = 1000000.0;
   else mf0 = mvs_case(pre, TA, muladd, mu, nu, lat, nu, Ydup, 1);
   for (i=nu; i; i--)
   {
      mf = mvs_case(pre, TA, muladd, mu, nu, lat, i, Ydup, 1);
      if (mf > bp->mflop)
      {
         bp->mu = mu;
         bp->nu = nu;
         bp->muladd = muladd;
         bp->Ydup = Ydup;
         bp->Xregs = i;
         bp->maxM = 1;
         bp->mflop = mf;
      }
      if (mf > mmf) mmf = mf;
      if (mf < mf0) break;  /* stop on slowdown */
      mf0 = mf;
   }
   return(mmf);
}

void mvsearchN(char pre, char TA, int muladd, int mu, int nu, int lat, 
               MVBEST *bp)
{
   int ydup;
   double mf0, mf;

   mf0 = mvsearchN0(pre, TA, muladd, mu, nu, lat, 1, bp);
   mvsearchN0(pre, TA, muladd, mu, nu, lat, nu, bp);
   if (lat > mu)
      mvsearchN0(pre, TA, muladd, mu, nu, lat, (lat+mu-1)/mu, bp);
   for (ydup=2; ydup < nu; ydup++)
   {
      mf = mvsearchN0(pre, TA, muladd, mu, nu, lat, ydup, bp);
      if (mf < mf0) break;
   }
}

double mvsearchT0(char pre, char TA, int muladd, int mu, int nu, int lat, 
                  int maxM, MVBEST *bp)
{
   double mf0, mf, mmf=0.0;
   int i, Ydup;

   if (lat) Ydup = (lat+maxM-1)/maxM;
   else Ydup = 1;

   if (maxM < mu) mf0 = 1000000.0;
   else mf0 = mvs_case(pre, TA, muladd, mu, nu, lat, nu, Ydup, maxM);
   for (i=nu; i; i--)
   {
      if (nu % i) continue;
      mf = mvs_case(pre, TA, muladd, mu, nu, lat, i, Ydup, maxM);
      if (mf > bp->mflop)
      {
         bp->mu = mu;
         bp->nu = nu;
         bp->muladd = muladd;
         bp->Ydup = Ydup;
         bp->Xregs = i;
         bp->maxM = maxM;
         bp->mflop = mf;
      }
      if (mf > mmf) mmf = mf;
      if (mf < mf0) break;  /* stop on slowdown */
      mf0 = mf;
   }
   return(mmf);
}
void mvsearchT(char pre, char TA, int muladd, int mu, int nu, int lat, 
               MVBEST *bp)
{
   int maxM;
   double mf0, mf;

   mf0 = mvsearchT0(pre, TA, muladd, mu, nu, lat, 1, bp);
   mvsearchT0(pre, TA, muladd, mu, nu, lat, mu, bp);
   for (maxM=2; maxM < mu; maxM++)
   {
      mf = mvsearchN0(pre, TA, muladd, mu, nu, lat, maxM, bp);
      if (mf < mf0) break;
   }
}

void mvsearch(char pre, char TA, int muladd, int lat, int begMU, int endMU,
              int incMU, int begNU, int endNU, int incNU)
{
   char TB;
   int i, j, k, NB, nu, mu;
   double mf0=0.0, mf;
   char ln[80];
   FILE *fp;
   MVBEST bs;
   void (*mvsearchX)(char pre, char TA, int muladd, int mu, int nu, int lat, 
                     MVBEST *bp);

   assert( (begMU >= 0) && (endMU >= begMU) && (incMU > 0) );
   assert( (begNU >= 0) && (endNU >= begNU) && (incNU > 0) );

   if (TA == 'N') mvsearchX = mvsearchN;
   else mvsearchX = mvsearchT;
   bs.mu = bs.nu = bs.muladd = bs.Ydup = bs.Xregs = bs.maxM = -1;
   bs.mflop = 0.0;

   for (mu=begMU; mu <= endMU; mu += incMU)
   {
      for (nu=begNU; nu <= endNU; nu += incNU)
      {
         mvsearchX(pre, TA, muladd, mu, nu, lat, &bs);
      }
   }
   fprintf(stdout, "\n\nBest case pre='%c', TA='%c': mflops=%lf, mu=%d, nu=%d muladd=%d, Ydup=%d, Xregs=%d, maxM=%d\n",
           pre, TA, bs.mflop, bs.mu, bs.nu, bs.muladd, bs.Ydup, bs.Xregs, 
           bs.maxM);
   sprintf(ln, "res/%cmv_best%c", pre, TA);
   fp = fopen(ln, "w");
   fprintf(fp, "pre=%c mu=%d nu=%d muladd=%d Ydup=%d Xregs=%d maxM=%d\n",
           pre, bs.mu, bs.nu, bs.muladd, bs.Ydup, bs.Xregs, bs.maxM);
   fclose(fp);
   fprintf(stdout, "If the above mflops look good to you, type:\n");
   if (TA == 'N') TB = 'T';
   else TB = 'N';
   sprintf(ln, "res/%cmv_best%c", pre, TB);
   if (FileExists(ln)) fprintf(stdout,   "   make %cmvinstall\n", pre);
   else fprintf(stdout, "   xmvsearch -p %c -A %c\n", pre, TB);
}

int main(int nargs, char *args[])
{
   char prec, TA;
   char NBnam[80];
   int MaxL1Size, i;
   int begMU, endMU, incMU, begNU, endNU, incNU;
   int L1, MULADD, lat;

   GetSettings(nargs, args, &prec, &TA, &MaxL1Size, &begMU, &endMU, &incMU,
               &begNU, &endNU, &incNU);

   L1 = GetL1CacheSize(MaxL1Size);
   GetMulAdd(prec, &MULADD, &lat);

   fprintf(stderr, "Precision='%c', MaxL1=%d\n", prec, MaxL1Size);

   mvsearch(prec, TA, MULADD, lat, begMU, endMU, incMU, begNU, endNU, incNU);
   return(0);
}
@ROUT l1search
void PrintUsage(char *xnam)
{
   fprintf(stderr, "\n\nUsage: %s -p <s/d> -a <alpha> -X <incX> -n <max unroll> -N <Vector length>\n", xnam);
   exit(-1);
}
int GetGoodLat(int nu, int lat)
{
   if (lat == 0) return(0);
   if (nu%lat == 0) return(lat);
   if (lat > nu) return(nu);
   while(nu%lat) lat++;
   return(lat);
}
#define NREP 3
double l1case(char pre, int N, int nu, int numul, int lat, int incX, 
              float alpha, int imflop)
{
   char calp, fnam[128], ln[128];
   int i;
   double mflop[NREP], t0;
   FILE *fp;

   if (alpha == 1.0) calp = '1';
   else if (alpha == 0.0) calp = '0';
   else if (alpha == -1.0) calp = 'n';
   else calp = 'X';

   sprintf(fnam, "res/%cscal%d_%dx%d_X%d_A%c_%d", pre, N, nu, numul, incX,
           calp, lat);
   if (!FileExists(fnam))  /* gotta run the case */
   {
      sprintf(ln, "make bob_scal pre=%c nu=%d lat=%d numul=%d alpha=%f incX=%d n=%d mflop_l1=%d\n",
              pre, nu, lat, numul, alpha, incX, N, imflop);
      assert(system(ln) == 0);
   }
   assert( (fp = fopen(fnam, "r")) != NULL );
   for (i=0; i < NREP; i++) assert(fscanf(fp, " %lf", &mflop[i]) == 1);
   close(fp);
   t0 = GetAvg(NREP, TOLERANCE, mflop);
   if (t0 == -1.0)
   {
      fprintf(stderr, "pre=%c nu=%d lat=%d numul=%d alpha=%f incX=%d n=%d: kill file and rerun with higher reps; variation exceed tolerence\n",
              pre, nu, lat, numul, alpha, incX, N);
      exit(-1);
   }
   return(t0);
}

typedef struct L1Case L1CASE;
struct L1Case
{
   double mflop;
   int nu, numul, lat;
};
void l1search0(L1CASE *mp, char pre, int N, int nu, int maxNU, int lat,
               int incX, float alpha, int imflop)
/*
 * Tries all valid numul's
 */
{
   static int TRYMUL=(-1);
   double mf, mf0;
   int i, lat0;

   if (TRYMUL == -1)  /* check if numul is a good idea */
   {
      if (pre == 's') i = 8;
      else i = 4;
      lat0 = GetGoodLat(i*2, lat);
      mf0 = l1case(pre, N, i*2, 1, lat0, incX, alpha, imflop);
      mf  = l1case(pre, N, i, 2, lat0, incX, alpha, imflop);
      if (mf > mf0)
      {
         TRYMUL = 1;
         if (mf > mp->mflop)
         {
            mp->mflop = mf;
            mp->nu = i;
            mp->numul = 2;
            mp->lat = lat0;
         }
      }
      else
      {
         TRYMUL = 0;
         if (mf0 > mp->mflop)
         {
            mp->mflop = mf0;
            mp->nu = 2*i;
            mp->numul = 1;
            mp->lat = lat0;
         }
      }
   }
   for (i=1; i*nu <= maxNU; i++)
   {
      lat0 = GetGoodLat(nu*i, lat);
      mf = l1case(pre, N, nu, i, lat0, incX, alpha, imflop);
      if (mf > mp->mflop)
      {
         mp->mflop = mf;
         mp->nu = nu;
         mp->numul = i;
         mp->lat = lat0;
      }
      if (incX == 0) break;  /* don't try numul for unknown strides */
      if (!TRYMUL) break;    /* only check muls if we think its a good idea */
   }
}

void l1search1(L1CASE *mp, char pre, int N, int NUstart, int NUinc, int maxNU,
               int lat, int incX, float alpha, int imflop)
/*
 * Tries all valid nu's
 */
{
   int i;
   for (i=NUstart; i <= maxNU; i += NUinc)
      l1search0(mp, pre, N, i, maxNU, lat, incX, alpha, imflop);
}

void l1search(char pre, int N, int muladd, int maxNU, int lat, int incX,
              float alpha, int imflop)
{
   char fnam[128], calp;
   int i, j;
   double t0;
   L1CASE maxcase;
   FILE *fp;

   if (pre == 's') i = 8;
   else i = 4;
   if (alpha == 1.0) calp = '1';
   else if (alpha == 0.0) calp = '0';
   else if (alpha == -1.0) calp = 'n';
   else calp = 'X';

   maxcase.mflop = 0.0;
   maxcase.nu = maxcase.numul = maxcase.lat = 0;
   l1search1(&maxcase, pre, N, 4, 4, 4, lat, incX, alpha, imflop);
   do
   {
      j = maxNU;
      l1search1(&maxcase, pre, N, i, i, maxNU, lat, incX, alpha, imflop);
      if (maxcase.nu*maxcase.numul >= maxNU) maxNU += i;
   }
   while (j < maxNU);
   if (lat)
   {
      if (4%lat)
         l1search1(&maxcase, pre, N, lat, lat, maxNU, lat, incX, alpha, imflop);
      if (maxcase.lat)  /* always try lat=0 */
      {
         t0 = l1case(pre, N, maxcase.nu, maxcase.numul, 0, incX, alpha, imflop);
         if (t0 > maxcase.mflop) maxcase.mflop = t0;
      }
   }
   t0 = l1case(pre, N, 1, 1, 0, incX, alpha, imflop);  /* always try no unrolling */
   if (t0 > maxcase.mflop)
   {
      maxcase.mflop = t0;
      maxcase.nu = maxcase.numul = 1;
      maxcase.lat = 0;
   }
   fprintf(stdout, "\n\nFastest case (%f MFLOPS) for N=%d, incX=%d, alpha=%f, maxNU=%d:\n", maxcase.mflop, N, incX, alpha, maxNU);
   fprintf(stdout, "   NU=%d, NUMUL=%d, lat=%d.\n\n",
           maxcase.nu, maxcase.numul, maxcase.lat);
   sprintf(fnam, "res/%cscalBEST%d_X%d_A%c", pre, N, incX, calp);
   fp = fopen(fnam, "w");
   assert(fp != NULL);
   fprintf(fp, "pre=%c nu=%d lat=%d numul=%d alpha=%f incX=%d n=%d\n",
           pre, maxcase.nu, maxcase.lat, maxcase.numul, alpha, incX, N);
   fclose(fp);
}

int main(int nargs, char *args[])
{
   char pre='d';
   int i;
   float alpha=3.2;
   int muladd=1, lat=(-1), incX=1, N=200, maxNU=16, imflop=50;

   for (i=1; i < nargs; i++)
   {
      if (*args[i] != '-') PrintUsage(args[0]);
      switch(args[i][1])
      {
         case 'p':
            pre = *args[++i];
            break;
         case 'a':
            alpha = atof(args[++i]);
            break;
         case 'X':
            incX = atoi(args[++i]);
            break;
         case 'l':
            lat = atoi(args[++i]);
            break;
         case 'n':
            maxNU = atoi(args[++i]);
            break;
         case 'N':
            N = atoi(args[++i]);
            break;
         case 'F':
            imflop = atoi(args[++i]);
            break;
         default:
            PrintUsage(args[0]);
            break;
      }
   }
   if (lat == -1) GetMulAdd(pre, &muladd, &lat);
   fprintf(stderr, "Precision='%c', lat=%d, maxNU=%d, incX=%d, alpha=%f\n",
           pre, lat, maxNU, incX, alpha);
   if (alpha == 0.0) lat = 0;
/*
 * Adjust mflop based on stride (assuming major cost of scal is memory fetch)
 * so that we don't waste a lot of time during install
 */
   if (incX > 1 && imflop)
   {
      if (pre == 's') i = 8;
      else i = 4;
      if (incX > i) imflop /= 2*i;
      else imflop /= 2*((i+incX-1) / incX);
      if (imflop < 0) imflop = 1;
   }
   l1search(pre, N, muladd, maxNU, lat, incX, alpha, imflop);
   return(0);
}
@ROUT TLB
@extract -b @(topd)/gen.inc what=cw
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
/* 
 * Note that this program assumes: 
 * (1) pagesize is the size of a page pointed to by a TLB entry
 * (2) Each TLB entry points to only 1 page
 */

FILE *fpout=NULL;
int *tlbinitmem(int n, size_t pglen)
/*
 * allocates and initializes relevant memory with values that won't overflow
 */
{
   int k=0;
   int *mem, *p, *stp;
   size_t len = n * pglen, ilen = pglen / sizeof(int);

   assert(n*ilen > 0);
   mem = p = malloc(len);
   assert(mem != NULL);
   stp = p + ilen * n;
   do
   {
      if (k == 0) *p = 0;
      else if (k == 1) *p = 1;
      else k = *p = -1;
      k++;
      p += ilen;
   }
   while(p != stp);
   
   return(mem);
}

double tlbaccesstime(int n, size_t pglen, int refs)
/*
 * Finds time to perform (refs) references, which are pglen apart.  We
 * allocate n separate pages
 */
{
   int *m, *mem, *p, *stp, reps;
   size_t len = pglen * n, ilen = pglen / sizeof(int);
   double tim;
   double time00(void);

   m = mem = tlbinitmem(n, pglen);
   reps = refs / n;
   stp = mem + n * ilen;
   tim = time00();
   do
   {
      p = mem;
      do
      {
         *m += *p;
         p += ilen;
      }
      while (p != stp);
      if (++m == stp) m = mem;
   }
   while(--reps);
   tim = time00() - tim;
   free(mem);
   return(tim);
}

int tlbnentries(size_t refs, int maxN, size_t maxpglen)
{
   int i, j, n=(-1);
   double tim1, tim2, diff, maxdiff=0.0;

   for (j=maxN; j >= 16; j /= 2)
   {
      tim1 = tlbaccesstime(j+1, maxpglen, refs);
      for (i=(-1); i < 6; i++)
      {
         tim2 = tlbaccesstime(j-i, maxpglen, refs);
         diff = tim1 - tim2;
         if (diff > maxdiff) {  maxdiff = diff;  n = j-i;  }
         printf("n=%d, time=%f, diff=%f\n", j-i, tim2, diff);
         if (fpout) fprintf(fpout, "n=%d, time=%f, diff=%f\n", j-i, tim2, diff);
         tim1 = tim2;
      }
   }
   return(n);
}

size_t tlbpglen(size_t refs, int nentries, int maxpglen)
/*
 * Given nentries in TLB, finds the page length
 */
{
   int n = nentries+8;
   double tim1, tim2, diff, maxdiff=0.0;
   size_t i, pglen=0;

   tim1 = tlbaccesstime(n, maxpglen, refs);
   tim1 = tlbaccesstime(n, maxpglen, refs);
   for (i=maxpglen/2; i > 256; i /= 2)
   {
      tim2 = tlbaccesstime(n, i, refs);
      diff = tim1 - tim2;
      if (diff > maxdiff) {  maxdiff = diff; pglen = i * 2;  }
      printf("len=%d, time=%f, diff=%f\n", i, tim2, diff);
      if (fpout) fprintf(fpout, "len=%d, time=%f, diff=%f\n", i, tim2, diff);
      tim1 = tim2;
   }
   return(pglen);
}

int main(int nargs, char *args)
{
   size_t refs=6400000, maxlen=512*1024, pglen;
   int maxn = 128, n;
   FILE *fp;

   fpout = fopen("res/TLBrun", "w");  /* stores run */
   assert (fpout != NULL);
#ifdef NoPageSize
   n = tlbnentries(refs, maxn, maxlen);
   printf("\n\n*****  Number of usable entries in TLB = %d\n\n", n);
   pglen = tlbpglen(refs, n, maxlen);
   printf("\n\n*****  Length of page in bytes         = %d\n\n", pglen);
#else
   pglen = getpagesize();
   printf("\n\n*****  Length of page in bytes         = %d\n\n", pglen);
   n = tlbnentries(refs, maxn, pglen);
   printf("\n\n*****  Number of usable entries in TLB = %d\n\n", n);
#endif
   fp = fopen("res/TLB", "w");
   assert (fp != NULL);
   fprintf(fp, "%d\n", n);
   fprintf(fp, "%d\n", pglen);
   fclose(fp);
   return(0);
}

@ROUT L1CacheSize
@extract -b @(topd)/gen.inc what=cw

#include <stdio.h>
#include <stdlib.h>

#define REPS 4096

#ifndef time00
   #define time00 ATL_walltime
#endif
double time00(void);

@beginskip
int L1CacheSize_write(int MAXL1CACHE)
{
   int ntests, h, i, j, k, reps=REPS*MAXL1CACHE, len, dlen, size=0;
   double *p, *d1, *d2, *st;
   double t1, t2, *times;

   for (i=2, j=0; i <= MAXL1CACHE; i <<= 1, j++);
   times = malloc(j*sizeof(double));
   ntests = j;

   h=0;
   for (i=2; i <= MAXL1CACHE; i <<= 1)
   {
      len = i * 1024;
      dlen = len / sizeof(double);
      d1 = p = malloc(len);
      st = p + dlen;
      d2 = st - 1;

      for (k=0; k != dlen; k++) d1[k] = 1.0*k;
      t1 = time00();
      for (j=0; j != reps; j++)
      {
         do *d1++ = *d2--; while (d1 != st);
         d2 = st - 1;
         d1 = p;
      }
      times[h] = time00() - t1;

      fprintf(stderr, "      L1CS=%d, time=%f\n",i, times[h]);
      reps >>= 1;
      free(p);
      h++;
   }
   t2 = 0.0;  j = 0;
   for (i=1; i < ntests; i++)
   {
      t1 = times[i] - times[i-1];
      if (t1 < 0) t1 = 0.0;
      if (t1 > t2) { t2 = t1;  j=i; }
   }
   free(times);
   fprintf(stderr, "\n");
   return(1 << j);
}

@endskip
// #define USE_OLD
#ifdef USE_OLD
int L1CacheSize_read(int MAXL1CACHE, double tol)
{
   int ntests, h, i, j, k, reps=REPS*MAXL1CACHE, len, dlen, size=0;
   double *p, *d, *st;
   double t1, t2, *times;
   register double d0, d1, d2, d3;

   for (i=2, j=0; i <= MAXL1CACHE; i <<= 1, j++);
   times = malloc(j*sizeof(double));
   ntests = j;

   h=0;
   for (i=2; i <= MAXL1CACHE; i <<= 1)
   {
      dlen = (i*1024+7) / sizeof(double);
      dlen = (dlen >> 3)<<3;
      len = dlen * 8;
      d = p = malloc(len);
      if (p == NULL)
      {
         fprintf(stderr, "malloc failed, len=%d\n", len);
         assert(p);
      }
      st = p + dlen;

      for (k=0; k != dlen; k += 8)
      {
         d[k] = 5.0;
         d[k+1] = -5.0;
         d[k+2] = -5.0;
         d[k+3] = 5.0;
         d[k+4] = -5.0;
         d[k+5] = 5.0;
         d[k+6] = 5.0;
         d[k+7] = -5.0;
      }
      d0 = d1 = d2 = d3 = 0.0;
      do
      {
         t1 = time00();
         for (j=0; j != reps; j++)
         {
            do
            {
                d0 += *d;
                d1 += d[2];
                d2 += d[4];
                d3 += d[6];
@skip            if (*d == 27.5) exit(-99);
@skip            d += 2;
                d += 8;
            }
            while (d != st);
            d = p;
         }
         t1 = time00() - t1;
         if (t1 < 0.6 && h == 0) reps += reps;
      }
      while (t1 < 0.6 && h == 0);
      times[h] = t1;
      d0 += d1 + d2 + d3;
      if (d0 > 100.0)
         exit(-1);

      fprintf(stderr, "      L1CS=%d, time=%f\n",i, times[h]);
      reps >>= 1;
      free(p);
      h++;
   }
#ifdef RawSize
   t2 = 0.0;  j = 0;
   for (i=1; i < ntests; i++)
   {
      t1 = times[i] - times[i-1];
      if (t1 < 0) t1 = 0.0;
      if (t1 > t2) { t2 = t1;  j=i; }
   }
#else
   t2 = 1.0;  j = 0;
   for (i=1; i < ntests; i++)  /* find biggest % increase */
   {
      t1 = times[i] / times[i-1];
      if (t1 > t2) { t2 = t1;  j=i; }
   }
#endif
   fprintf(stderr, "\n");
   if (tol != 0.0)
   {
      if (tol*times[j-1] > times[j])
      {
         free(times);
         return(0);
      }
   }
   free(times);
   return(1 << j);
}
#else
void initmem(int n, double *mem)
/*
 * Initialize mem to something that won't cause overlow, but confuse
 * things a little so compiler can't get rid of code
 */
{
   double d;
   int i;
   if (rand() > 27) d = ( 0.5 - ((double)rand())/((double)RAND_MAX) );
   else d = ( 1.0 - ((double)rand())/((double)RAND_MAX) );
   for (i=0; i < n; i++)
      mem[i] = ( 0.5 - ((double)rand())/((double)RAND_MAX) );
   for (i=0; i < n; i += 8)
   {
      mem[i] = d;
      mem[i+2] = -d;
      mem[i+4] = -d;
      mem[i+6] = d;
      d = -d;
   }
}

int L1CacheSize_read(int MAXL1CACHE, double tol)
{
   int ntests, h, i, j, k, reps=REPS*MAXL1CACHE, len, dlen, size=0;
   double *p, *d, *st;
   double t1, t2, *times;
   register double d0, d1, d2, d3;

   for (i=2, j=0; i <= MAXL1CACHE; i <<= 1, j++);
   times = malloc(j*sizeof(double));
   ntests = j;

   h=0;
   for (i=2; i <= MAXL1CACHE; i <<= 1)
   {
      dlen = (i*1024+7) / sizeof(double);
      dlen = (dlen >> 3)<<3;
      len = dlen * 8;
      d = p = malloc(len);
      st = p + dlen;

      initmem(dlen, d);
      d0 = d1 = d2 = d3 = 0.0;
      do
      {
         t1 = time00();
         for (j=0; j != reps; j++)
         {
            do
            {
                d0 += *d;
                d1 += d[2];
                d2 += d[4];
                d3 += d[6];
@skip            if (*d == 27.5) exit(-99);
@skip            d += 2;
                d += 8;
            }
            while (d != st);
            d = p;
         }
         t1 = time00() - t1;
         if (t1 < 0.6 && h == 0) reps += reps;
      }
      while (t1 < 0.6 && h == 0);
      times[h] = t1;
      d0 += d1 + d2 + d3;

      fprintf(stderr, "      L1CS=%d, time=%f (ignore=%.1e)\n",i, times[h], d0);
      reps >>= 1;
      free(p);
      h++;
   }
#ifdef RawSize
   t2 = 0.0;  j = 0;
   for (i=1; i < ntests; i++)
   {
      t1 = times[i] - times[i-1];
      if (t1 < 0) t1 = 0.0;
      if (t1 > t2) { t2 = t1;  j=i; }
   }
#else
   t2 = 1.0;  j = 0;
   for (i=1; i < ntests; i++)  /* find biggest % increase */
   {
      t1 = times[i] / times[i-1];
      if (t1 > t2) { t2 = t1;  j=i; }
   }
#endif
   fprintf(stderr, "\n");
   if (tol != 0.0)
   {
      if (tol*times[j-1] > times[j])
      {
         free(times);
         return(0);
      }
   }
   free(times);
   return(1 << j);
}
#endif

#define BIGBOY 256
#define L1CacheSize L1CacheSize_read

int GetL1Size(int MaxSize, double tol)
{
   int L1Size, tmp, correct=1;

   fprintf(stderr, "\n   Calculating L1 cache size:\n");
   L1Size = L1CacheSize(MaxSize, tol);
   if (L1Size == 0) tmp = -1.0;
   else
   {
      fprintf(stderr, "      Confirming result of %dkb:\n", L1Size);
      tmp = L1CacheSize(MaxSize, 0.0);
      if (tmp == L1Size) tmp = L1CacheSize(MaxSize, 0.0);
   }
   if (tmp != L1Size && MaxSize < BIGBOY)
   {
      if (L1Size) fprintf(stderr, 
                     "   L1 size not confirmed; trying large maximum size:\n");
      else fprintf(stderr, "      Timing differences below tolerance, trying larger maximum cache size:\n");
      L1Size = L1CacheSize(BIGBOY, 0.0);
      fprintf(stderr, "      Confirming result of %dkb:\n", L1Size);
      tmp = L1CacheSize(BIGBOY, 0.0);
      if (tmp == L1Size) tmp = L1CacheSize(BIGBOY, 0.0);
   }
   correct = (tmp == L1Size);
   fprintf(stderr, "Calculated L1 cache size = %dkb; Correct=%d\n",
           L1Size, correct);
   return (correct ? L1Size : 0);
}

int main(int nargs, char *args[])
{
   int L1Size, MaxSize=64, correct=1;
   FILE *L1f;

   if (nargs > 2)
   {
      fprintf(stderr, "USAGE: %s <max L1 cache size (in kilobytes)>\n",args[0]);
      exit(-1);
   }
   if (nargs > 1) MaxSize = atoi(args[1]);
   L1Size = GetL1Size(MaxSize, 1.08);
   if (!L1Size)
      L1Size = GetL1Size(MaxSize, 1.08);
   if (!L1Size)
   {
      fprintf(stderr, "\nCan't detect the L1 cache; setting to 32KB.\n");
      L1Size = 32;
      correct = 0;
   }
   fprintf(stderr, "Calculated L1 cache size = %dkb; Correct=%d\n",
           L1Size, correct);
   L1f = fopen("res/L1CacheSize", "w");
   if (L1f)
   {
      fprintf(L1f, "%d\n",L1Size);
      fclose(L1f);
      exit(0);
   }
   return(-1);
}
@ROUT ATL_small_mm
@extract -b @(topd)/gen.inc what=cw
#include "atlas_misc.h"
#include "atlas_lvl3.h"

@whiledef ta t n
   @whiledef tb t n
void Mjoin(PATL,@(ta)@(tb)_mm)(int M, int N, int K, const SCALAR alpha, 
                       const TYPE *A, int lda, const TYPE *B, int ldb, 
                       const SCALAR beta, TYPE *C, int ldc)
{
   if ( SCALAR_IS_NONE(alpha) )
   {
      if ( SCALAR_IS_ZERO(beta) )
         Mjoin(PATL,@(ta)@(tb)_mm_an1_b0)
            (M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
      else if ( SCALAR_IS_ONE(beta) )
         Mjoin(PATL,@(ta)@(tb)_mm_an1_b1)
            (M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
      else if ( SCALAR_IS_NONE(beta) )
         Mjoin(PATL,@(ta)@(tb)_mm_an1_bn1)
            (M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
      else
         Mjoin(PATL,@(ta)@(tb)_mm_an1_bX)
            (M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
   }
   else if ( SCALAR_IS_ONE(alpha) )
   {
      if ( SCALAR_IS_ZERO(beta) )
         Mjoin(PATL,@(ta)@(tb)_mm_a1_b0)
            (M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
      else if ( SCALAR_IS_ONE(beta) )
         Mjoin(PATL,@(ta)@(tb)_mm_a1_b1)
            (M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
      else if ( SCALAR_IS_NONE(beta) )
         Mjoin(PATL,@(ta)@(tb)_mm_a1_bn1)
            (M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
      else
         Mjoin(PATL,@(ta)@(tb)_mm_a1_bX)
            (M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
   }
   else
   {
      if ( SCALAR_IS_ZERO(beta) )
         Mjoin(PATL,@(ta)@(tb)_mm_aX_b0)
            (M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
      else if ( SCALAR_IS_ONE(beta) )
         Mjoin(PATL,@(ta)@(tb)_mm_aX_b1)
            (M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
      else if ( SCALAR_IS_NONE(beta))
         Mjoin(PATL,@(ta)@(tb)_mm_aX_bn1)
            (M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
      else
         Mjoin(PATL,@(ta)@(tb)_mm_aX_bX)
            (M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
   }
}

   @endwhile
@endwhile 
@ROUT ATL_gereal2cplx
@extract -b @(topd)/gen.inc what=cw @(cw07)
#include "atlas_misc.h"

void Mjoin(PATL,gereal2cplx)
   (const int M, const int N, const TYPE *alpha, const TYPE *R, const int ldr, 
    const TYPE *I, const int ldi, const TYPE *beta, TYPE *C, const int ldc)
/*
 * C = beta*C + (R,I)*alpha
 * where R is a MxN matrix representing the real components to be added into
 * the output complex matrix, and the I matrix contains the imaginary components
 */
{
   const TYPE ralp=(*alpha), ialp=alpha[1], rbet=(*beta), ibet=beta[1];
   register TYPE ra, ia, rc, ic, tmp;
   const int ldc2 = (ldc-M)<<1;
   int i, j;

/*
 * Cannot read C if BETA is 0
 */
   if (rbet == ATL_rzero && ibet == ATL_rzero)
   {
      if (ialp == ATL_rzero)  /* alpha is a real number */
      {
         if (ralp == ATL_rone) /* alpha = 1.0 */
         {
            for (j=0; j < N; j++, R += ldr, I += ldi, C += ldc2)
            {
               for (i=0; i < M; i++, C += 2)
               {
                  *C = R[i];
                  C[1] = I[i];
               }
            }
         }
         else
         {
            for (j=0; j < N; j++, R += ldr, I += ldi, C += ldc2)
            {
               for (i=0; i < M; i++, C += 2)
               {
                  *C = ralp * R[i];
                  C[1] = ralp * I[i];
               }
            }
         }
      }
      else                   /* alpha is a complex number */
      {
         for (j=0; j < N; j++, R += ldr, I += ldi, C += ldc2)
         {
            for (i=0; i < M; i++, C += 2)
            {
               ra = R[i]; ia = I[i];
               C[0] = ralp * ra - ialp * ia;
               C[1] = ralp * ia + ialp * ra;
            }
         }
      }
   }
/*
 * If alpha and beta are both real numbers 
 */
   else if (ialp == ATL_rzero && ibet == ATL_rzero)
   {
      if (ralp == ATL_rone && rbet == ATL_rone)
      {
         for (j=0; j < N; j++, R += ldr, I += ldi, C += ldc2)
         {
            for (i=0; i < M; i++, C += 2)
            {
               *C += R[i];
               C[1] += I[i];
            }
         }
      }
      else  /* general case real alpha, beta case */
      {
         for (j=0; j < N; j++, R += ldr, I += ldi, C += ldc2)
         {
            for (i=0; i < M; i++, C += 2)
            {
               *C = ralp*R[i] + rbet * *C;
               C[1] = ralp*I[i] + rbet*C[1];
            }
         }
      }
   }
/*
 * General case where both alpha & beta are complex, specialize later
 */
   else
   {
      for (j=0; j < N; j++, R += ldr, I += ldi, C += ldc2)
      {
         for (i=0; i < M; i++, C += 2)
         {
            rc = *C; ic = C[1];
            ra = R[i]; ia = I[i];
            tmp = rc*rbet - ic*ibet;
            ic = rc*ibet + ic*rbet;
            tmp += ra*ralp - ia*ialp;
            ic += ra*ialp + ia*ralp;
            C[0] = tmp; C[1] = ic;
         }
      }
   }
}
@ROUT ATL_cputblk
@extract -b @(topd)/gen.inc what=cw
#include "atlas_misc.h"
#include "atlas_lvl3.h"

#define putblk0 Mjoin(Mjoin(Mjoin(ATL_c,PRE),putblk),BNM)
void putblk0(const int M, const int N, const TYPE *v, const TYPE *beta,
             TYPE *C, const int ldc)
{
   const int incC=(ldc-M)<<1;
   int i, j;
   const TYPE *vr=v, *vi=v+M*N;
   #ifdef BETAXI0
      const register TYPE rbeta = *beta;
   #elif defined(BETAX)
      const register TYPE rbeta = *beta, ibeta = beta[1];
      register TYPE rc, ic;
   #endif

   if (M == MB)
   {
      if (N == NB)
      {
         for(j=NB; j; j--)
         {
            for (i=0; i != MB; i++)
            {
               #ifdef BETA0
                  *C = v[i];
                  C[1] = v[NBNB+i];
               #elif defined(BETA1)
                  *C += v[i];
                  C[1] += v[NBNB+i];
               #elif defined(BETAN1)
                  *C = v[i] - *C;
                  C[1] = v[NBNB+i] - C[1];
               #elif defined(BETAXI0)
                  *C = *C * rbeta + v[i];
                  C[1] = C[1] * rbeta + v[NBNB+i];
               #elif defined(BETAX)
                  rc = *C;
                  ic = C[1];
                  *C = rc * rbeta - ic * ibeta + v[i];
                  C[1] = rc * ibeta + ic * rbeta + v[NBNB+i];
               #endif
               C += 2;
            }
            C += incC;
            v += MB;
         }
      }
      else
      {
         for(j=N; j; j--)
         {
            for (i=0; i != MB; i++)
            {
               #ifdef BETA0
                  *C = vr[i];
                  C[1] = vi[i];
               #elif defined(BETA1)
                  *C += vr[i];
                  C[1] += vi[i];
               #elif defined(BETAN1)
                  *C = vr[i] - *C;
                  C[1] = vi[i] - C[1];
               #elif defined(BETAXI0)
                  *C = *C * rbeta + vr[i];
                  C[1] = C[1] * rbeta + vi[i];
               #elif defined(BETAX)
                  rc = *C;
                  ic = C[1];
                  *C = rc * rbeta - ic * ibeta + vr[i];
                  C[1] = rc * ibeta + ic * rbeta + vi[i];
               #endif
               C += 2;
            }
            C += incC;
            vr += MB;
            vi += MB;
         }
      }
   }
   else
   {
      for(j=N; j; j--)
      {
         for (i=0; i != M; i++)
         {
            #ifdef BETA0
               *C = vr[i];
               C[1] = vi[i];
            #elif defined(BETA1)
               *C += vr[i];
               C[1] += vi[i];
            #elif defined(BETAN1)
               *C = vr[i] - *C;
               C[1] = vi[i] - C[1];
            #elif defined(BETAXI0)
               *C = *C * rbeta + vr[i];
               C[1] = C[1] * rbeta + vi[i];
            #elif defined(BETAX)
               rc = *C;
               ic = C[1];
               *C = rc * rbeta - ic * ibeta + vr[i];
               C[1] = rc * ibeta + ic * rbeta + vi[i];
            #endif
            C += 2;
         }
         C += incC;
         vr += M;
         vi += M;
      }
   }
}
@ROUT ATL_putblk
@extract -b @(topd)/gen.inc what=cw
#include "atlas_misc.h"
#include "atlas_lvl3.h"

void Mjoin(Mjoin(PATL,putblk),BNM)(int M, int N, TYPE *V, TYPE *C, int ldc,
                                  const SCALAR beta0)
{
   TYPE *st0 = V + (M*N SHIFT), *st1 = V + (M SHIFT);
#if defined(TREAL) && !defined(BETA0) && !defined(BETA1) && !defined(BETAN1)
      const register TYPE beta = beta0;
#endif
#ifdef TCPLX
   TYPE tmp;
   #ifdef BETAXI0
      const register TYPE beta = *beta0;
   #endif

   ldc <<= 1;
   M <<= 1;
#endif
   ldc -= M;
   do
   {
      #if defined(BETA0)
         do *C++ = *V; while (++V != st1);
      #elif defined(BETA1)
         do *C++ += *V; while (++V != st1);
      #else
         do 
         {
            #if defined BETAN1
               *C = *V++ - *C;
               C++;
            #else
               #if defined(TREAL) || defined(BETAXi0)
                  *C = beta * *C + *V++;
                  C++;
               #else
                  CMULT2(V, beta0, C, tmp);
                  C += 2;
                  V += 2;
               #endif
            #endif
         }
         while(V != st1);
      #endif
      st1 += M;
      C += ldc;
   }
   while(V != st0);
}
@ROUT ATL_row2blkT
@extract -b @(topd)/gen.inc what=cw
#include "atlas_misc.h"
#include "atlas_lvl3.h"
#include "atlas_prefetch.h"

#define ATL_row2blkT_NB Mjoin(Mjoin(PATL,row2blkT_NB),NM)
#define ATL_row2blkT_KB Mjoin(Mjoin(PATL,row2blkT_KB),NM)
#define ATL_row2blkT Mjoin(Mjoin(PATL,row2blkT),NM)
#define ATL_row2blkT2 Mjoin(Mjoin(PATL,row2blkT2),NM)

#if defined (DREAL) && defined(ATL_GAS_x8664) && 0
void ATL_row2blkT_NB(const int M, const int N, const TYPE *A, const int lda,
                     TYPE *V, const TYPE alpha);
#else
static void ATL_row2blkT_NB
   (const int M, const int N, const TYPE *A, const int lda, TYPE *V,
    const TYPE alpha0)
/*
 * copy where M & N are NB, compiler should be able to completely unroll
 */
{
   const int lda2 = lda<<1;
   int i, j;
   TYPE *v=V;
   const TYPE *pA0 = A, *pA1 = A + lda;
   const register TYPE alpha=alpha0;
   #ifdef ATL_AltiVec
@skip      static int cwrd=0, cwrdV;
      static int cwrd=0;
      if (cwrd) goto L1;
      i = 1; /* one block unless NB is too big */
      j = ATL_MulBySize(NB)>>4;
      while (j > 32) { j >>= 1; i <<= 1; }
      if (j == 32) j = 0;
      cwrd = ATL_GetCtrl(j<<4, i, j);
@skip      cwrdV = ATL_GetCtrl(ATL_MulBySize(NB), NB, 1);
L1:
      ATL_pfavR(pA0, cwrd, 2);
      ATL_pfavR(pA1, cwrd, 3);
   #endif

#if (NB/2)*2 != NB  /* ATLAS should ensure NB is divisable by two */
   assert((NB/2)*2 == NB);
#endif
   for (j=NB; j; j -= 2)
   {
      #ifdef ATL_AltiVec
@skip         ATL_pfavW(v, cwrdV, 2);
         ATL_pfavR(pA0+lda2, cwrd, 0);
         ATL_pfavR(pA1+lda2, cwrd, 1);
      #endif
      for (i=0; i != NB; i++, v += NB)
      {
         *v = ATL_MulByALPHA(pA0[i]);
         v[1] = ATL_MulByALPHA(pA1[i]);
      }
      V += 2;
      v = V;
      pA0 += lda2;
      pA1 += lda2;
   }
}
#endif

static void ATL_row2blkT_KB
   (const int M, const int N, const TYPE *A, const int lda, TYPE *V,
    const TYPE alpha0)
{
   const int n = N >> 1, lda2 = lda<<1;
   int i, j;
   TYPE *v=V;
   const TYPE *pA0 = A, *pA1 = A + lda;
   const register TYPE alpha=alpha0;

   for (j=n; j; j--)
   {
      for (i=0; i != M; i++, v += N)
      {
         *v = ATL_MulByALPHA(pA0[i]);
         v[1] = ATL_MulByALPHA(pA1[i]);
      }
      V += 2;
      v = V;
      pA0 += lda2;
      pA1 += lda2;
   }
   if ((n<<1) != N) 
      for (i=0; i != M; i++, v += N) *v = ATL_MulByALPHA(pA0[i]);
}

void ATL_row2blkT(const int N, const int nb, const TYPE *A, const int lda, 
                  TYPE *V, const SCALAR alpha)
/*
 * A is a nbxN matrix, v is a N*nb length vector.
 * v receives trans(A) in block major order.
 */
{
   const int Nb = ATL_DivByNB(N), incA = ATL_MulByNB(lda);
   const int incV = ATL_MulByNB(nb);
   int k;

   if (nb == NB)
      for (k=0; k != Nb; k++, A += incA, V += incV)
         ATL_row2blkT_NB(Nb, NB, A, lda, V, alpha);

   else
      for (k=0; k != Nb; k++, A += incA, V += incV)
         ATL_row2blkT_KB(nb, NB, A, lda, V, alpha);
   if (k = N - ATL_MulByNB(Nb))
      ATL_row2blkT_KB(nb, k, A, lda, V, alpha);
}
void ATL_row2blkT2(const int M, const int N, const TYPE *A, const int lda, 
                   TYPE *V, const SCALAR alpha)
{
   const int Mb = ATL_DivByNB(M), Nb = ATL_DivByNB(N);
   const int mr = M - ATL_MulByNB(Mb), nr = N - ATL_MulByNB(Nb);
   const int incV = ATL_MulByNB(N), incA = ATL_MulByNB(lda) - M + mr;
   const int incVV = ATL_MulByNB(mr);
   int i, j;
   TYPE *v=V, *vv = V+Mb*incV;

   for (j=Nb; j; j--)
   {
      for (i=Mb; i; i--, A += NB, v += incV)
         ATL_row2blkT_NB(NB, NB, A, lda, v, alpha);
      if (mr) 
      {
         ATL_row2blkT_KB(mr, NB, A, lda, vv, alpha);
         vv += incVV;
      }
      A += incA;
      V += NBNB;
      v = V;
   }
   if (nr)
   {
      for (i=Mb; i; i--, A += NB, v += incV)
         ATL_row2blkT_KB(NB, nr, A, lda, v, alpha);
      if (mr) ATL_row2blkT_KB(mr, nr, A, lda, vv, alpha);
   }
}
@ROUT ATL_ccol2blk ATL_crow2blkT
@extract -b @(topd)/gen.inc what=cw @(cw99)

#include "atlas_misc.h"
#include "atlas_lvl3.h"

#ifdef Conj_
   #if defined(ALPHA1)
      #define scalcp(A_, rp_, ip_) \
      { \
         *(rp_) = *(A_); \
         *(ip_) = -((A_)[1]); \
      }
   #elif defined(ALPHAN1)
      #define scalcp(A_, rp_, ip_) \
      { \
         *(rp_) = -(*(A_)); \
         *(ip_) = (A_)[1]; \
      }
   #elif defined(ALPHAXI0)
      #define scalcp(A_, rp_, ip_) \
      { \
         *(rp_) = ralpha * *(A_); \
         *(ip_) = calpha * (A_)[1]; \
      }
   #elif defined(ALPHAX)
      #define scalcp(A_, rp_, ip_) \
      { \
         ra = *(A_); ia = (A_)[1]; \
         *(rp_) = ralpha * ra + ialpha * ia; \
         *(ip_) = ialpha * ra - ralpha * ia; \
      }
   #endif
#else
   #if defined(ALPHA1)
      #define scalcp(A_, rp_, ip_) \
      { \
         *(rp_) = *(A_); \
         *(ip_) = (A_)[1]; \
      }
   #elif defined(ALPHAN1)
      #define scalcp(A_, rp_, ip_) \
      { \
         *(rp_) = -(*(A_)); \
         *(ip_) = -((A_)[1]); \
      }
   #elif defined(ALPHAXI0)
      #define scalcp(A_, rp_, ip_) \
      { \
         *(rp_) = ralpha * *(A_); \
         *(ip_) = ralpha * (A_)[1]; \
      }
   #elif defined(ALPHAX)
      #define scalcp(A_, rp_, ip_) \
      { \
         ra = *(A_); ia = (A_)[1]; \
         *(rp_) = ralpha * ra - ialpha * ia; \
         *(ip_) = ialpha * ra + ralpha * ia; \
      }
   #endif
#endif

@ROUT ATL_crow2blkT
static void row2blkT_NB(const int M, const int N, const TYPE *A, const int lda,
                        TYPE *vr, TYPE *vi, const SCALAR alpha)
{
   const int incA = lda<<2, incv = 2 - NBNB;
   const TYPE *pA0 = A, *pA1 = A + (lda<<1);
   int i, j;
   #ifdef ALPHAXI0
      #ifdef Conj_
         const register TYPE ralpha = *alpha, calpha = -ralpha;
      #else
         const register TYPE ralpha = *alpha;
      #endif
   #elif defined(ALPHAX)
      const register TYPE ralpha = *alpha, ialpha = alpha[1];
      register TYPE ra, ia;
   #endif

   #if ((NB/2)*2 != NB)  /* ATLAS should ensure NB divisible by 2 */
      ATL_assert((NB/2)*2 == NB);
   #endif
   for (j=(NB>>1); j; j --, pA0 += incA, pA1 += incA, vr += incv, vi += incv)
   {
      for (i=0; i != NB2; i += 2, vr += NB, vi += NB)
      {
         scalcp(pA0+i, vr, vi);
         scalcp(pA1+i, vr+1, vi+1);
      }
   }
}

static void row2blkT_KB(const int M, const int N, const TYPE *A, const int lda,
                        TYPE *vr, TYPE *vi, const SCALAR alpha)
{
   const int M2 = M<<1, lda2 = lda<<1, incv = 1 - M*N;
   int i, j;
   #ifdef ALPHAXI0
      #ifdef Conj_
         const register TYPE ralpha = *alpha, calpha = -ralpha;
      #else
         const register TYPE ralpha = *alpha;
      #endif
   #elif defined(ALPHAX)
      const register TYPE ralpha = *alpha, ialpha = alpha[1];
      register TYPE ra, ia;
   #endif

   for (j=N; j; j--, A += lda2, vr += incv, vi += incv)
   {
      for (i=0; i != M2; i += 2, vr += N, vi += N) scalcp(A+i, vr, vi);
   }
}

#ifdef Conj_
   #define row2blkT Mjoin(Mjoin(PATL,row2blkC),NM)
   #define row2blkT2 Mjoin(Mjoin(PATL,row2blkC2),NM)
#else
   #define row2blkT Mjoin(Mjoin(PATL,row2blkT),NM)
   #define row2blkT2 Mjoin(Mjoin(PATL,row2blkT2),NM)
#endif

void row2blkT(const int N, const int nb, const TYPE *A, const int lda,
              TYPE *v, const SCALAR alpha)
{
   const int nNb = ATL_DivByNB(N), incA = ATL_MulByNB(lda)<<1;
   const int incv = ATL_MulByNB(nb), incV = incv<<1;
   int k;

   if (nb == NB)
      for (k=nNb; k; k--, A += incA, v += NBNB2)
         row2blkT_NB(NB, NB, A, lda, v+NBNB, v, alpha);
   else
      for (k=nNb; k; k--, A += incA, v += incV)
         row2blkT_KB(nb, NB, A, lda, v+incv, v, alpha);
   if ( k = N-ATL_MulByNB(nNb) )
      row2blkT_KB(nb, k, A, lda, v+k*nb, v, alpha);
}

void row2blkT2(const int M, const int N, const TYPE *A, const int lda,
               TYPE *V, const SCALAR alpha)
{
   const int nNb = ATL_DivByNB(N), nMb = ATL_DivByNB(M);
   const int mr = M - ATL_MulByNB(nMb), nr = N - ATL_MulByNB(nNb);
   const int incA = (ATL_MulByNB(lda) - M + mr)<<1;
   const int incV = ATL_MulByNB(N)<<1, incvv = ATL_MulByNB(mr), incVV=incvv<<1;
   TYPE *v = V, *vv = V + nMb * incV;
   int i, j;

   for (j=nNb; j; j--)
   {
      for (i=nMb; i; i--, A += NB2, v += incV)
         row2blkT_NB(NB, NB, A, lda, v+NBNB, v, alpha);
      if (mr)
      {
         row2blkT_KB(mr, NB, A, lda, vv+incvv, vv, alpha);
         vv += incVV;
      }
      A += incA;
      V += NBNB2;
      v = V;
   }
   if (nr)
   {
      j = ATL_MulByNB(nr);
      for (i=nMb; i; i--, A += NB2, v += incV)
         row2blkT_KB(NB, nr, A, lda, v+j, v, alpha);
      if (mr) row2blkT_KB(mr, nr, A, lda, vv+mr*nr, vv, alpha);
   }
}
@ROUT ATL_ccol2blk

#ifdef Conj_
   #define col2blk Mjoin(Mjoin(PATL,col2blkConj),NM)
   #define col2blk2 Mjoin(Mjoin(PATL,col2blkConj2),NM)
#else
   #define col2blk Mjoin(Mjoin(PATL,col2blk),NM)
   #define col2blk2 Mjoin(Mjoin(PATL,col2blk2),NM)
#endif

void col2blk(const int M, const int N, const TYPE *A, const int lda, TYPE *V,
             const SCALAR alpha)
{
   const int nMb = ATL_DivByNB(M), ib = M - ATL_MulByNB(nMb);
   const int incA = (lda - M)<<1, incv = ATL_MulByNB(N);
   const int incV = (incv<<1) - NB;
   int i, ii, j;
   TYPE *rp = V+ATL_MulByNB(N), *ip = V, *prp, *pip;
   #ifdef ALPHAXI0
      #ifdef Conj_
         const register TYPE ralpha = *alpha, calpha = -ralpha;
      #else
         const register TYPE ralpha = *alpha;
      #endif
   #elif defined(ALPHAX)
      const register TYPE ralpha = *alpha, ialpha = alpha[1];
      register TYPE ra, ia;
   #endif

   pip = V + (M-ib)*(N<<1);
   prp = pip + ib*N;

   for (j=N; j; j--, V += NB, A += incA)
   {
      ip = V;
      rp = V + incv;
      for (ii=nMb; ii; ii--, rp += incV, ip += incV)
      {
         for (i=NB; i; i--, A += 2, rp++, ip++) scalcp(A, rp, ip);
      }
      for (i=ib; i; i--, A += 2, prp++, pip++) scalcp(A, prp, pip);
   }
}

void col2blk2(const int M, const int N, const TYPE *A, const int lda, TYPE *V, 
              const TYPE *alpha)
{
   int j;
   const int nNb = ATL_DivByNB(N), jb = N - ATL_MulByNB(nNb);
   size_t incA = (lda*NB)<<1, incV = (M*NB)<<1;

   for (j=nNb; j; j--)
   {
      col2blk(M, NB, A, lda, V, alpha);
      A += incA;
      V += incV;
   }
   if (jb) col2blk(M, jb, A, lda, V, alpha);
}
@ROUT ATL_col2blk
@extract -b @(topd)/gen.inc what=cw

#include "atlas_misc.h"
#include "atlas_lvl3.h"
#include "atlas_prefetch.h"

void Mjoin(Mjoin(PATL,col2blk),NM)
   (const int M, const int N, const TYPE *A, const int lda, TYPE *V, 
    const SCALAR alpha0)
{
   const int Mb = ATL_DivByNB(M), m = ATL_MulByNB(Mb), mr = M-m;
   const int Nb = ATL_DivByNB(N), n = ATL_MulByNB(Nb), nr = N-n; 
   const int nb2 = NB >> 1;
   const int incA = (lda<<1) - m;
@skip   const int incV  = ( Mb ? (NB<<1) - Mb*NBNB : (mr<<1) );
   const int incV  = ( Mb ? (NB<<1) - Mb*NBNB : 0 );
   const int incVv = ( Mb ? (Mb-1)*NBNB + ATL_MulByNB(mr) : ATL_MulByNB(mr) );
   const int incV0 = ATL_MulByNB(nr);
   const int incV1 = ( Mb ? (NB<<1) - incV0*Mb : (mr<<1) );
   int ib, jb, i, j;
   const TYPE *pA0 = A, *pA1 = A + lda;
   TYPE *v0 = V, *vv=V + ATL_MulByNB(m);
   const register TYPE alpha=alpha0;
   #ifdef ATL_AltiVec
      static int cwrd=0;
      if (cwrd) goto L1;
      i = 1; /* one block unless NB is too big */
      j = ATL_MulBySize(NB)>>4;
      while (j > 32) { j >>= 1; i <<= 1; }
      if (j == 32) j = 0;
      cwrd = ATL_GetCtrl(j<<4, i, j);
L1:
   #endif


   #if ((NB/2)*2 != NB)  /* ATLAS should ensure NB divisible by 2 */
      ATL_assert((NB/2)*2 == NB);
   #endif
#if defined(DREAL) && defined(ATL_GAS_x8664) && 0
   for (jb=Nb; jb; jb--, v0 += M*NB, pA0 += NB*lda)
      Mjoin(ATL_dcol2blk_NB,NM)(M, NB, pA0, lda, v0, alpha);
   pA1 = pA0 + lda;
#else
   for (jb=Nb; jb; jb--, v0 += incVv)
   {
      vv = v0 + ATL_MulByNB(m);
      for (j=nb2; j; j--, v0 += incV, pA0 += incA, pA1 += incA)
      {
         for (ib=Mb; ib; ib--, pA0 += NB, pA1 += NB, v0 += NBNB)
         {
            #ifdef ATL_AltiVec
               ATL_pfavR(pA0+NB, cwrd, 0);
               ATL_pfavR(pA1+NB, cwrd, 1);
            #endif
            for (i=0; i != NB; i++)  /* easy loop to unroll */
            {
               v0[i] = ATL_MulByALPHA(pA0[i]);
               v0[NB+i] = ATL_MulByALPHA(pA1[i]);
            }
         }
         if (mr)
         {
            for (i=0; i != mr; i++)
            {
               vv[i] = ATL_MulByALPHA(pA0[i]);
               vv[mr+i] = ATL_MulByALPHA(pA1[i]);
            }
            vv += mr << 1;
         }
      }
   }
#endif
   if (nr)  /* partial column panel remainder */
   {
      v0 = V + Nb * NB * M;
      vv = v0 + nr*m;
      for (j=jb=(nr>>1); j; j--, pA0 += incA, pA1 += incA, v0 += incV1)
      {
         for (ib=Mb; ib; ib--, pA0 += NB, pA1 += NB, v0 += incV0)
         {
            for (i=0; i != NB; i++)  /* easy loop to unroll */
            {
               v0[i] = ATL_MulByALPHA(pA0[i]);
               v0[i+NB] = ATL_MulByALPHA(pA1[i]);
            }
         }
         if (mr)
         {
            for (i=0; i != mr; i++)
            {
               vv[i] = ATL_MulByALPHA(pA0[i]);
               vv[i+mr] = ATL_MulByALPHA(pA1[i]);
            }
            vv += mr << 1;
         }
      }
      if ((jb<<1) != nr)
      {
         for (ib=Mb; ib; ib--, pA0 += NB, v0 += incV0)
         {
            for (i=0; i != NB; i++) v0[i] = ATL_MulByALPHA(pA0[i]);
         }
         if (mr) for (i=0; i != mr; i++) vv[i] = ATL_MulByALPHA(pA0[i]);
      }
   }
}

void Mjoin(Mjoin(PATL,col2blk2),NM)
   (const int M, const int N, const TYPE *A, const int lda, 
    TYPE *V, const SCALAR alpha)
{
   Mjoin(Mjoin(PATL,col2blk),NM)(M, N, A, lda, V, alpha);
}
@ROUT ATL_MBJBmm
@extract -b @(topd)/gen.inc what=cw
#include "atlas_misc.h"
#include "atlas_lvl3.h"
void Mjoin(PATL,MBJBmm)(const int N, const int K, const TYPE *A, const TYPE *B,
                        const TYPE beta, TYPE *C, const int ldc)
{
   const int nKb = ATL_DivByNB(K);
   #ifdef TREAL
      const int incB = ATL_MulByNB(N);
      #define incA NBNB;
      #define zero ATL_rzero
   #else
      const int incB = ATL_MulByNB(N)<<1;
      #define incA NBNB2;
      const TYPE zero[2] = {ATL_rzero, ATL_rzero};
   #endif
   register int k;

   if (nKb)
   {
      if (beta == ATL_rone)
         Mjoin(PATL,pNBmm_b1)(MB, N, KB, ATL_rone, A, KB, B, KB, beta, C, ldc);
      else if (beta == ATL_rzero)
         Mjoin(PATL,pNBmm_b0)(MB, N, KB, ATL_rone, A, KB, B, KB, beta, C, ldc);
      else
         Mjoin(PATL,pNBmm_bX)(MB, N, KB, ATL_rone, A, KB, B, KB, beta, C, ldc);
      A += incA;
      B += incB;
      for (k=nKb-1; k; k--)
      {
         Mjoin(PATL,pNBmm_b1)(MB, N, KB, ATL_rone, A, KB, B, KB, 
                              ATL_rone, C, ldc);
         A += incA;
         B += incB;
      }
      if (k = K - ATL_MulByNB(nKb))
         Mjoin(PATL,pKBmm)(MB, N, k, ATL_rone, A, k, B, k, ATL_rone, C, ldc);
   }
   else if (k = K - ATL_MulByNB(nKb))
   {
      if (beta == ATL_rzero) Mjoin(PATL,gezero)(MB, N, C, ldc);
      Mjoin(PATL,pKBmm)(MB, N, k, ATL_rone, A, k, B, k, beta, C, ldc);
   }
}
@ROUT ATL_IBNBmm
@extract -b @(topd)/gen.inc what=cw
#include "atlas_misc.h"
#include "atlas_lvl3.h"
void Mjoin(PATL,IBNBmm)(const int M, const int K, const TYPE *A, const TYPE *B,
                        const TYPE beta, TYPE *C, const int ldc)
{
   const int nKb = ATL_DivByNB(K);
   #ifdef TREAL
      const int incA = ATL_MulByNB(M);
      #define incB NBNB
      #define zero ATL_rzero
   #else
      const int incA = ATL_MulByNB(M)<<1;
      #define incB NBNB2
      const TYPE zero[2] = {ATL_rzero, ATL_rzero};
   #endif
   register int k;

   if (nKb)
   {
      if (beta == ATL_rone)
         Mjoin(PATL,pMBmm_b1)(M, NB, KB, ATL_rone, A, KB, B, KB, beta, C, ldc);
      else if (beta == ATL_rzero)
         Mjoin(PATL,pMBmm_b0)(M, NB, KB, ATL_rone, A, KB, B, KB, beta, C, ldc);
      else
         Mjoin(PATL,pMBmm_bX)(M, NB, KB, ATL_rone, A, KB, B, KB, beta, C, ldc);
      A += incA;
      B += incB;
      for (k=nKb-1; k; k--)
      {
         Mjoin(PATL,pMBmm_b1)(M, NB, KB, ATL_rone, A, KB, B, KB, 
                              ATL_rone, C, ldc);
         A += incA;
         B += incB;
      }
      if (k = K - ATL_MulByNB(nKb)) 
         Mjoin(PATL,pKBmm)(M, NB, k, ATL_rone, A, k, B, k, ATL_rone, C, ldc);
   }
   else if (k = K - ATL_MulByNB(nKb)) 
   {
      if (beta == ATL_rzero) Mjoin(PATL,gezero)(M, NB, C, ldc);
      Mjoin(PATL,pKBmm)(M, NB, k, ATL_rone, A, k, B, k, beta, C, ldc);
   }
}
@ROUT ATL_IBJBmm
@extract -b @(topd)/gen.inc what=cw
#include "atlas_misc.h"
#include "atlas_lvl3.h"
void Mjoin(PATL,IBJBmm)(int IB, int JB, int K, const TYPE *A, const TYPE *B,
                        TYPE beta, TYPE *C, const int ldc)
{
   const int nKb = ATL_DivByNB(K); 
   const int incB = ATL_MulByNB(JB)SHIFT, incA = ATL_MulByNB(IB)SHIFT;
   #ifdef TREAL
      #define zero ATL_rzero
   #else
      const TYPE zero[2] = {ATL_rzero, ATL_rzero};
   #endif
   int k;

   if (beta == ATL_rzero) Mjoin(PATL,gezero)(IB, JB, C, ldc);
   if (nKb)
   {
      Mjoin(PATL,pKBmm)(IB, JB, KB, ATL_rone, A, NB, B, NB, beta, C, ldc);
      B += incB;
      A += incA;
      for (k=nKb-1; k; k--)
      {
         Mjoin(PATL,pKBmm)(IB, JB, KB, ATL_rone, A, NB, B, NB, ATL_rone, 
                           C, ldc);
         B += incB;
         A += incA;
      }
      if (k = K-ATL_MulByNB(nKb))
         Mjoin(PATL,pKBmm)(IB, JB, k, ATL_rone, A, k, B, k, ATL_rone, C, ldc);
   }
   else if (k = K-ATL_MulByNB(nKb))
      Mjoin(PATL,pKBmm)(IB, JB, k, ATL_rone, A, k, B, k, beta, C, ldc);
}
@ROUT ATL_mmJKI
@extract -b @(topd)/gen.inc what=cw @(cw06)

#include "atlas_misc.h"
#include "atlas_lvl3.h"
#include <stdlib.h>

void Mjoin(PATL,mm_axpy)
   (const enum ATLAS_TRANS TA, const enum ATLAS_TRANS TB, const int M,
    const int N, const int K, const SCALAR alpha, const TYPE *A, const int lda,
    const TYPE *B, const int ldb, const SCALAR beta, TYPE *C, const int ldc)
/*
 * TA == AtlasNoTrans
 * GEMM implemented by calling axpy, with any M partitioning already done
 */
{
   int i, j, k, incBk, incBn;
   size_t incAn = lda*K;

   if (TB == AtlasNoTrans)
   {
      incBk = 1; 
      incBn = ldb - K;
   }
   else
   {
      incBk = ldb; 
      incBn = 1 - ldb*K;
   }

   if (beta == ATL_rone)
   {
      if (alpha == ATL_rone)
      {
         for(j=0; j < N; j++)
         {
            for (k=0; k < K; k++, B += incBk, A += lda)
               Mjoin(PATL,axpy)(M, *B, A, 1, C, 1);
            C += ldc;
            B += incBn;
            A -= incAn;
         }
      }
      else
      {
         for(j=0; j < N; j++)
         {
            Mjoin(PATL,axpby)(M, alpha*(*B), A, 1, beta, C, 1);
            B += incBk;
            A += lda;
            for (k=1; k < K; k++, B += incBk, A += lda)
               Mjoin(PATL,axpy)(M, alpha*(*B), A, 1, C, 1);
            C += ldc;
            B += incBn;
            A -= incAn;
         }
      }
   }
   else /* BETA != 1.0 */
   {
      if (alpha == ATL_rone)
      {
         for(j=0; j < N; j++)
         {
            Mjoin(PATL,axpby)(M, *B, A, 1, beta, C, 1);
            B += incBk;
            A += lda;
            for (k=1; k < K; k++, B += incBk, A += lda)
               Mjoin(PATL,axpy)(M, *B, A, 1, C, 1);
            C += ldc;
            B += incBn;
            A -= incAn;
         }
      }
      else
      {
         for(j=0; j < N; j++)
         {
            Mjoin(PATL,axpby)(M, alpha*(*B), A, 1, beta, C, 1);
            B += incBk;
            A += lda;
            for (k=1; k < K; k++, B += incBk, A += lda)
               Mjoin(PATL,axpy)(M, alpha*(*B), A, 1, C, 1);
            C += ldc;
            B += incBn;
            A -= incAn;
         }
      }
   }
}

int Mjoin(PATL,mmJKI)(const enum ATLAS_TRANS TA, const enum ATLAS_TRANS TB, 
                      const int M, const int N, const int K, 
                      const SCALAR alpha, const TYPE *A, const int lda, 
                      const TYPE *B, const int ldb, const SCALAR beta, 
                      TYPE *C, const int ldc)
/*
 * This gemm is for small K, so we build gemm out of AXPY (outer product)
 * rather than dot (inner product).
 */
{
   int Mp, mp, m, k, ldaa=lda;
   void *vA=NULL;
   TYPE *pA;
   SCALAR alp=alpha;

/*
 * Compute M partition necessary to promote reuse in the L1 cache.  Check
 * NB^2 in addition to L1elts, to catch machines where L1 is not used by FPU.
 * If this gives a small Mp, use CacheEdge instead (reuse in L2 instead of L1).
 */
   Mp = NB*NB;
   if (ATL_L1elts > Mp) Mp = ATL_L1elts;
   Mp /= (K+2);
   if (Mp < 256)
   {
      #if !defined(CacheEdge) || CacheEdge == 0
         Mp = M;
      #else
         Mp = (CacheEdge) / ((K+2)*ATL_sizeof);
         if (Mp < 256)
            Mp = M;
      #endif
   }
   if (Mp > M)
      Mp = M;
/*
 * Change Mp if remainder is very small
 */
   else
   {
      Mp -= 16;      /* small safety margin on filling cache */
      mp = M / Mp;
      m = M - mp*Mp;
      if (m && m < 32)
         Mp += (m+mp-1)/mp;
   }
/*
 * If A not in NoTrans format, need to copy so it can use axpy wt stride=1.  
 * NOTE: this routine should not be called when you can't afford this copy
 */
   if (TA != AtlasNoTrans)
   {
      vA = malloc(ATL_Cachelen + Mp*ATL_MulBySize(K));
      if (!vA) return(-1);
      pA = ATL_AlignPtr(vA);
      alp = ATL_rone;
      ldaa = Mp;
      pA += Mp;
   }
   else
      pA = (TYPE *) A;
   for (m=0; m < M; m += Mp)
   {
      mp = M - m;
      if (mp > Mp)
         mp = Mp;
/*
 *    If the thing is in Trans format, copy to NoTrans
 */
      if (vA)
      {
         pA -= Mp;
         for (k=0; k < K; k++)
            Mjoin(PATL,cpsc)(mp, alpha, A+k, lda, pA+k*ldaa, 1);
         A += mp*lda;
      }
      Mjoin(PATL,mm_axpy)(AtlasNoTrans, TB, mp, N, K, alp, pA, ldaa, B, ldb, 
                          beta, C, ldc);
      pA += mp;
      C += mp;
   }
   if (vA) free(vA);
   return(0);
}

@ROUT ATL_cmmJITcp
@extract -b @(topd)/gen.inc what=cw @(cw07)
#include "atlas_misc.h"
#include "atlas_level3.h"
#ifdef SCPLX
   #include "smm.h"
#else
   #include "dmm.h"
#endif
#ifndef ATL_MaxMalloc   /* temp, defined in atlas_lvl3.h */
   #define ATL_MaxMalloc 16777216
#endif
@beginskip
#ifdef SCLPX
   #undef SCPLX
   #undef TCPLX
   #define TREAL
   #define SREAL
   #include atlas_lvl3.h
   #undef TREAL
   #undef SREAL
   #define SCPLX
   #define TCPLX
#else
   #undef DCPLX
   #undef TCPLX
   #define TREAL
   #define DREAL
   #include atlas_lvl3.h
   #undef TREAL
   #undef DREAL
   #define DCPLX
   #define TCPLX
#endif
@endskip

typedef void (*MAT2BLK3)(const int, const int, const SCALAR, const TYPE*, 
                         const int, TYPE*, const int, TYPE*, const int);

@whiledef be 0 1 X
   @whiledef rout pKBmm pMBmm pNBmm
void Mjoin(PATLU,@(rout)_b@(be))(const int M, const int N, const int K,
                          const TYPE alpha, const TYPE *A, const int lda,
                          const TYPE *B, const int ldb, const TYPE beta,
                          TYPE *C, const int ldc);
   @endwhile
void NBmm_b@(be)(const int M, const int N, const int K,
             const TYPE alpha, const TYPE *A, const int lda,
             const TYPE *B, const int ldb, const TYPE beta,
             TYPE *C, const int ldc);
@endwhile
void Mjoin(PATLU,pKBmm)(const int M, const int N, const int K,
                        const TYPE alpha, const TYPE *A, const int lda,
                        const TYPE *B, const int ldb, const TYPE beta,
                        TYPE *C, const int ldc);
void Mjoin(PATL,row2blkT_a1)(int, int, const TYPE*, int, TYPE*, const SCALAR);
void Mjoin(PATL,col2blk_a1)(int, int, const TYPE*, int, TYPE*, const SCALAR);
void Mjoin(PATL,gereal2cplx)
   (const int M, const int N, const TYPE *alpha, const TYPE *R, const int ldr, 
    const TYPE *I, const int ldi, const TYPE *beta, TYPE *C, const int ldc);


@whiledef T C T
   @addkeys KTA=@(T)
@KTA C
static void ATL_gecplx2realConj_a1
@KTA T
static void ATL_gecplx2real_a1
@KTA !
   (const int M, const int N, const SCALAR alpha, const TYPE *A, const int lda,
    TYPE *pR, const int ldr, TYPE *pI, const int ldi)
/*
 * Splits real & imag components of A into separate real arrays R/I.
 */
{
   const int incA = (lda-M)<<1;
   int i, j;

/*
 * Copy backwards so 1st part of matrix is LRU
 */
   A += ((N-1)*lda+M-1)<<1;
   pR += (N-1)*ldr;
   pI += (N-1)*ldi;

   for (j=N; j; j--, A -= incA, pR -= ldr, pI -= ldi)
   {
      for (i=M-1; i >= 0; i--, A -= 2)
      {
         pR[i] = *A;
@KTA C
         pI[i] = -A[1];
@KTA T
         pI[i] = A[1];
@KTA !
      }
   }
}
static void ATL_gecplx2real@(T)_a1
   (const int M, const int N, const SCALAR alpha, const TYPE *A, const int lda,
    TYPE *pR, const int ldr, TYPE *pI, const int ldi)
/*
 * Splits real & imag components of A' into separate real arrays R/I.
 * Output matrix is MxN, so A must be NxM
 */
{
   const int lda2 = (lda-N)<<1, incR = 1-N*ldr, incI = 1-N*ldi;
   int i, j;
/*
 * Loop over M cols of A
 */
   for (i=M; i; i--, A += lda2, pR += incR, pI += incI)
   {
      for (j=N; j; j--, A += 2, pR += ldr, pI += ldi)
      {
         *pR = *A;
   @KTA C
         *pI = -A[1];
   @KTA T
         *pI = A[1];
   @KTA !
      }
   }
}
   @killkeys KTA
@endwhile

static void Mjoin(PATL,mmK)
   (int M,  /* true # of rows in row-panel, M <= MB */
    int N,  /* true # of cols in col-panel, N < = NB */
    int nblk, /* # of blocks in K dimension */
    int KR,   /* KR = K - nKb*KB; */
    const TYPE *A, /* array to copy from, NULL if already cp */
    const int lda,  /* leading dimension of A */
    const int incA, /* inc to next blk in A */
    const TYPE *alpha,
    TYPE *pA,       /* wrkspace to copy A to */
    const int incAW, /* 0 : keep using same KBxMB space */
    const TYPE *B, /* array to copy from, NULL if already cp */
    const int ldb,  /* leading dimension of B */
    const int incB, /* inc to next blk in B */
    TYPE *pB,       /* wrkspace to copy B to */
    const int incBW, /* 0 : keep using same KBxNB space */
    const TYPE *beta,
    TYPE *C,         /* output matrix */
    const int ldc,
    TYPE *pC,       /* ldpc x NB workspace */
    const int ldpc,
    MAT2BLK3 A2blk, /* rout to copy A */
    MAT2BLK3 B2blk) /* rout to copy B */
/*
 * Performs a K-inner-loop matmul, while copying A & B if necessary.
 * If M > m, we are doing extra flops so we don't call cleanup (same for N)
 * This just-in-time copy is better alg when K dim dominates M & N.
 */
{
   int m, n, kr;  /* # of row/cols to operate on, m >= M, n >= N */
   int k, ZEROED=0;
   const TYPE one[2] = {ATL_rone, ATL_rzero}, zero[2] = {ATL_rzero, ATL_rzero};
/*
 * Indexes to next blk (i.e. real to imag) of matrices; always uses full
 * block stride, even when we have a partial block 
 */
   int ipb = NB*KB, ipa = MB*KB, ipc = ldpc*NB;
   void (*NBmm0)(const int, const int, const int, const TYPE,
                 const TYPE*, const int, const TYPE*, const int,
                 const TYPE, TYPE*, const int);
   void (*NBmm1)(const int, const int, const int, const TYPE,
                 const TYPE*, const int, const TYPE*, const int,
                 const TYPE, TYPE*, const int);
   void (*NBmmX)(const int, const int, const int, const TYPE,
                 const TYPE*, const int, const TYPE*, const int,
                 const TYPE, TYPE*, const int);

   m = (M < MB && M+ATL_mmMU >= MB) ? MB : M;
   n = (N < NB && N+ATL_mmNU >= NB) ? NB : N;
   if (m == MB && n == NB)
   {
      NBmm0 = NBmm_b0;
      NBmm1 = NBmm_b1;
      NBmmX = NBmm_bX;
   }
   else if (m == MB)  /* N cleanup needed */
   {
      NBmm0 = Mjoin(PATLU,pNBmm_b0);
      NBmm1 = Mjoin(PATLU,pNBmm_b1);
      NBmmX = Mjoin(PATLU,pNBmm_bX);
   }
   else if (n == NB) /* M cleanup needed */
   {
      NBmm0 = Mjoin(PATLU,pMBmm_b0);
      NBmm1 = Mjoin(PATLU,pMBmm_b1);
      NBmmX = Mjoin(PATLU,pMBmm_bX);
   }
   else  /* two or more dim < NB, requires generated cleanup */
   {
      NBmm0 = NBmm1 = NBmmX = Mjoin(PATLU,pKBmm);
/*
 *    Must zero regardless of BETA, since we call wrkspc wt beta=0
 */
      Mjoin(PATLU,gezero)(M, N, pC+ipc, ldpc);
      Mjoin(PATLU,gezero)(M, N, pC, ldpc);
      ZEROED = 1;
   }
   if (nblk)
   {
      if (B) 
      {
         if (n > N)
         {
            Mjoin(PATLU,gezero)(KB, n-N, pB+KB*N, KB);
            Mjoin(PATLU,gezero)(KB, n-N, pB+ipb+KB*N, KB);
         }
         B2blk(KB, N, one, B, ldb, pB+ipb, KB, pB, KB); 
         B += incB; 
      }
      if (A) 
      {
         if (m > M)
         {
            Mjoin(PATLU,gezero)(KB, m-M, pA+KB*M, KB);
            Mjoin(PATLU,gezero)(KB, m-M, pA+ipa+KB*M, KB);
         }
         A2blk(KB, M, one, A, lda, pA+ipa, KB, pA, KB);
         A += incA; 
      }
      NBmm0(m, n, KB, ATL_rone, pA, KB, pB, KB, ATL_rzero, pC, ldpc);
      NBmm0(m, n, KB, ATL_rone, pA, KB, pB+ipb, KB, ATL_rzero, pC+ipc, ldpc);
      NBmmX(m, n, KB, ATL_rone, pA+ipa, KB, pB+ipb, KB, ATL_rnone, pC, ldpc);
      NBmm1(m, n, KB, ATL_rone, pA+ipa, KB, pB, KB, ATL_rone, pC+ipc, ldpc);
      pA += incAW; pB += incBW;
      for (k=nblk-1; k; k--)
      {
         if (B) 
         { 
            if (n > N)
            {
               Mjoin(PATLU,gezero)(KB, n-N, pB+KB*N, KB);
               Mjoin(PATLU,gezero)(KB, n-N, pB+ipb+KB*N, KB);
            }
            B2blk(KB, N, one, B, ldb, pB+ipb, KB, pB, KB); 
            B += incB; 
         }
         if (A) 
         { 
            if (m > M)
            {
               Mjoin(PATLU,gezero)(KB, m-M, pA+KB*M, KB);
               Mjoin(PATLU,gezero)(KB, m-M, pA+ipa+KB*M, KB);
            }
            A2blk(KB, M, one, A, lda, pA+ipa, KB, pA, KB); 
            A += incA; 
         }
         NBmmX(m, n, KB, ATL_rone, pA, KB, pB, KB, ATL_rnone, pC, ldpc);
         NBmm1(m, n, KB, ATL_rone, pA, KB, pB+ipb, KB, ATL_rone, pC+ipc, ldpc);
         NBmmX(m, n, KB, ATL_rone, pA+ipa, KB, pB+ipb, KB, ATL_rnone, pC, ldpc);
         NBmm1(m, n, KB, ATL_rone, pA+ipa, KB, pB, KB, ATL_rone, pC+ipc, ldpc);
         pA += incAW; pB += incBW;
      }
   }
   if (KR)  /* need to cleanup K-loop */
   {
      if (KR+4 >= KB)  /* do extra flops to avoid cleanup loop */
         kr = KB;
      else  /* must use K cleanup */
      {
         kr = KR;
         if (m < MB || n < NB) /* use general K cleanup */
         {
            n = N; m = M;
            if (!nblk && !ZEROED)
            {
               Mjoin(PATLU,gezero)(M, N, pC, ldpc);
               Mjoin(PATLU,gezero)(M, N, pC+ipc, ldpc);
            }
            NBmm1 = NBmmX = NBmm0 = Mjoin(PATLU,pKBmm);
         }
         else /* use K-only cleanup */
         {
            NBmm0 = Mjoin(PATLU,pKBmm_b0);
            NBmm1 = Mjoin(PATLU,pKBmm_b1);
            NBmmX = Mjoin(PATLU,pKBmm_bX);
         }
      }
      if (B) 
      {
         if (n > N)
         {
            Mjoin(PATLU,gezero)(kr, n-N, pB+kr*N, kr);
            Mjoin(PATLU,gezero)(kr, n-N, pB+ipb+kr*N, kr);
         }
         if (kr != KR)
         {
            Mjoin(PATLU,gezero)(kr-KR, n, pB+KR, kr);
            Mjoin(PATLU,gezero)(kr-KR, n, pB+ipb+KR, kr);
         }
         B2blk(KR, N, one, B, ldb, pB+ipb, kr, pB, kr); 
      }
      if (A) 
      { 
         if (m > M)
         {
            Mjoin(PATLU,gezero)(kr, m-M, pA+kr*M, kr);
            Mjoin(PATLU,gezero)(kr, m-M, pA+ipa+kr*M, kr);
         }
         if (kr != KR)
         {
            Mjoin(PATLU,gezero)(kr-KR, n, pA+KR, kr);
            Mjoin(PATLU,gezero)(kr-KR, n, pA+ipa+KR, kr);
         }
         A2blk(KR, M, one, A, lda, pA+ipa, kr, pA, kr); 
      }
      if (nblk)
      {
         NBmmX(m, n, kr, ATL_rone, pA, kr, pB, kr, ATL_rnone, pC, ldpc);
         NBmm1(m, n, kr, ATL_rone, pA, kr, pB+ipb, kr, ATL_rone, pC+ipc, ldpc);
      }
      else
      {
         NBmm0(m, n, kr, ATL_rone, pA, kr, pB, kr, ATL_rzero, pC, ldpc);
         NBmm0(m, n, kr, ATL_rone, pA, kr, pB+ipb, kr, ATL_rzero, pC+ipc, ldpc);
      }
      NBmmX(m, n, kr, ATL_rone, pA+ipa, kr, pB+ipb, kr, ATL_rnone, pC, ldpc);
      NBmm1(m, n, kr, ATL_rone, pA+ipa, kr, pB, kr, ATL_rone, pC+ipc, ldpc);
   }
   Mjoin(PATL,gereal2cplx)(M, N, alpha, pC, ldpc, pC+ipc, ldpc, beta, C, ldc);
}

static int mmNMK
   (const int M, const int N, const int K, const int cnmblks, const int cnnblks,
    const int cnkblks, const int nkblks, const int kr, const TYPE *alpha, 
    const TYPE *A, const int lda, int incAk, int incAW, 
    const TYPE *B, const int ldb, int incBk, int incBW,
    const TYPE *beta, TYPE *C, const int ldc, MAT2BLK3 A2blk, MAT2BLK3 B2blk)
{
   int incAm, incAn, incBn, incW, incCn, i, j, mb, nb;
   void *vp=NULL;
   const TYPE *b;
   TYPE *pA, *pB, *pC;

   incAm = (incAk == KB*2 ? MB*(lda+lda) : 2*MB);
   incBn = (incBk == KB*2 ? NB*(ldb+ldb) : 2*NB);
   incW = (incAW ? 2*MB*cnkblks*KB : 0);
   incCn = NB*(ldc+ldc) - cnmblks*(MB+MB);
   incAn = -cnmblks * (incAW ? incW : incAm);
   i = incAW ? 2*cnmblks*MB*cnkblks*KB : 2*MB*KB; /* wrk for A */
   i += incBW ? 2*cnkblks*KB*NB : 2*NB*KB;
   i += 2*MB*NB;
   i *= sizeof(TYPE);
   if (i <= ATL_MaxMalloc)
      vp = malloc(ATL_Cachelen+i);
   if (!vp) return(-1);
   pC = ATL_AlignPtr(vp);
   pB = pC + 2*MB*NB;
   pA = pB + (incBW ? 2*cnkblks*KB*NB : 2*NB*KB);
   for (j=0; j < N; j += NB, B += incBn)
   {
      b = B;
      nb = N - j;
      nb = Mmin(NB, nb);
      for (i=0; i < M; i += MB, A += incAm)
      {
         mb = M - i;
         mb = Mmin(MB, mb);
         Mjoin(PATL,mmK)(mb, nb, nkblks, kr, A, lda, incAk, alpha, pA, incAW,
                         b, ldb, incBk, pB, incBW, beta, C, ldc, pC, MB,
                         A2blk, B2blk);
         pA += incW;
         b = incBW ? NULL : b;  /* reuse col-panel of B if copied */
         C += MB+MB;
      }
      if (incAW)  /* we have copied all of A, just reuse now */
      {
         A = NULL;
         incAm = incAk = 0;
         pA += incAn;
      }
      else
         A += incAn;
      C += incCn;
   }
   free(vp);
   return(0);
}

static int mmMNK
   (const int M, const int N, const int K, const int cnmblks, const int cnnblks,
    const int cnkblks, const int nkblks, const int kr, const TYPE *alpha, 
    const TYPE *A, const int lda, int incAk, int incAW, 
    const TYPE *B, const int ldb, int incBk, int incBW,
    const TYPE *beta, TYPE *C, const int ldc, MAT2BLK3 A2blk, MAT2BLK3 B2blk)
{
   int incW, incAm, incBn, incBm, incCn, incCm;
   int i, j, mb, nb;
   void *vp=NULL;
   const TYPE *a;
   TYPE *pA, *pB, *pC;

   incW = (incBW ? 2*NB*cnkblks*KB : 0);
   incAm = (incAk == 2*KB ? 2*MB*lda : 2*MB);
   incCn = (ldc+ldc)*NB;
   incCm = MB+MB - cnnblks*incCn;
   incBn = (incBk == 2*KB ? 2*NB*ldb : 2*NB);
   incBm = -cnnblks * (incBW ? incW : incBn);

   i = incAW ? 2*cnkblks*KB*MB : 2*MB*KB;           /* wrk for A */
   i += incBW ? 2*cnnblks*cnkblks*KB*NB : 2*NB*KB;  /* wrk for B */
   i += 2*MB*NB;                                    /* wrk for C */
   i *= sizeof(TYPE);
   if (i <= ATL_MaxMalloc)
      vp = malloc(ATL_Cachelen+i);
   if (!vp) return(-1);

   pC = ATL_AlignPtr(vp);
   pA = pC + 2*MB*NB;
   pB = pA + (incAW ? 2*MB*cnkblks*KB : 2*MB*KB);

   for (i=0; i < M; i += MB, A += incAm)
   {
      a = A;
      mb = M - i;
      mb = Mmin(MB, mb);
      for (j=0; j < N; j += NB)
      {
         nb = N - j;
         nb = Mmin(NB, nb);
         Mjoin(PATL,mmK)(mb, nb, nkblks, kr, a, lda, incAk, alpha, pA, incAW,
                         B, ldb, incBk, pB, incBW, beta, C, ldc, pC, MB,
                         A2blk, B2blk);
         B += incBn;
         pB += incW;
         a = incAW ? NULL : a;  /* reuse row-panel of A if copied */
         C += incCn;
      }
      if (incBW)  /* we have copied all of B, just reuse now */
      {
         B = NULL;
         incBn = incBk = 0;
         pB += incBm;
      }
      else
         B += incBm;
      C += incCm;
   }
   free(vp);
   return(0);
}

int Mjoin(PATL,mmJITcp)(const enum ATLAS_TRANS TA, const enum ATLAS_TRANS TB,
                        const int M0, const int N, const int K,
                        const SCALAR alpha, const TYPE *A, const int lda,
                        const TYPE *B, const int ldb, const SCALAR beta,
                        TYPE *C, const int ldc)
/*
 * This routine copies A & B just before using them, which gets better
 * cache reuse when the copy cost is dominant (K dominates M & N).  Normally,
 * (lots of reuse in algorithm) the extra cache noise makes this a bad idea.
 */
{
   size_t incAk, incBk, incAW, incBW, incAB, incC;
   int i, j, m, n;
   const int M = (M0 >= 0) ? M0 : -M0; 
   const int nkblks = (K/KB), kr = K-nkblks*KB;
   const int cnkblks=(K+KB-1)/KB, cnmblks=(M+MB-1)/MB, cnnblks=(N+NB-1)/NB;
   MAT2BLK3 A2blk, B2blk;

   if (M0 > 0)  /* normally, only copy all of matrix if reuse is possible */
   {
       incAW = (N > NB) ? KB*MB*2 : 0;
       incBW = (M > NB) ? KB*NB*2 : 0;
   }
   else  /* M0 < 0 flag to use minimal workspace */
      incAW = incBW = 0;
   if (TA == AtlasNoTrans)
   {
      incAk = lda*2*KB;
      A2blk = ATL_gecplx2realT_a1;
   }
   else if (TA == AtlasConjTrans)
   {
      incAk = KB*2;
      A2blk = ATL_gecplx2realConj_a1;
   }
   else
   {
      incAk = KB*2;
      A2blk = ATL_gecplx2real_a1;
   }
   if (TB == AtlasNoTrans)
   {
      incBk = KB*2;
      B2blk = ATL_gecplx2real_a1;
   }
   else if (TB == AtlasConjTrans)
   {
      incBk = ldb*2*KB;
      B2blk = ATL_gecplx2realC_a1;
   }
   else
   {
      incBk = ldb*2*KB;
      B2blk = ATL_gecplx2realT_a1;
   }
/*
 * If A isn't copied, or is smaller than B, copy it as inner matrix
 */
   if (M <= N || incAW)
   {
      if (mmNMK(M, N, K, cnmblks, cnnblks, cnkblks, nkblks, kr, alpha, 
                A, lda, incAk, incAW, B, ldb, incBk, incBW, 
                beta, C, ldc, A2blk, B2blk))
      {
         if (!incAW)
            return(-1);
         m = cnmblks;
         i = cnmblks >> 1;
/*
 *       Keep trying half-size M until we can copy all of A subsection
 */
         j = 0;       /* # of M blocks to do undefined */
         while(i > 2)
         {
            i += m - i - i;  /* # of blks to try at a whack */
            if (!mmNMK(i*MB, N, K, i, cnnblks, cnkblks, nkblks, kr, alpha, 
                       A, lda, incAk, incAW, B, ldb, incBk, incBW, 
                       beta, C, ldc, A2blk, B2blk))
            {
               incAB = (TA == AtlasNoTrans) ? 2*MB*i : 2*MB*lda*i;
               incC = 2*MB*i;
               j = i;
               break;
            }
            m = i;
            i >>= 1;
         }
         if (j)  /* we've handled first J rows of A */
         {
            for (i=j; i < cnmblks; i += j)
            {
               A += incAB;
               C += incC;
               if (i+j < cnmblks)
                  m = j * MB;
               else
               {
                  m = M - i*MB;
                  j = cnmblks - i;
               }
               if (mmNMK(m, N, K, j, cnnblks, cnkblks, nkblks, kr, alpha, 
                         A, lda, incAk, incAW, B, ldb, incBk, incBW, 
                         beta, C, ldc, A2blk, B2blk))
                  if (mmNMK(m, N, K, j, cnnblks, cnkblks, nkblks, kr, alpha, 
                            A, lda, incAk, 0, B, ldb, incBk, incBW, 
                            beta, C, ldc, A2blk, B2blk))
                     ATL_assert(!mmNMK(m, N, K, j, cnnblks, cnkblks, nkblks, kr,
                                       alpha, A, lda, incAk, 0, B, ldb, incBk, 
                                       0, beta, C, ldc, A2blk, B2blk));
            }
         }
         else  /* just try not copying A at all */
            return(mmNMK(M, N, K, cnmblks, cnnblks, cnkblks, nkblks, kr, alpha, 
                         A, lda, incAk, 0, B, ldb, incBk, incBW, 
                         beta, C, ldc, A2blk, B2blk));
      }
   }
/*
 * If A is copied and is larger than B, copy B as inner matrix
 */
   else if (mmMNK(M, N, K, cnmblks, cnnblks, cnkblks, nkblks, kr, alpha, 
                  A, lda, incAk, incAW, B, ldb, incBk, incBW, 
                  beta, C, ldc, A2blk, B2blk))
   {
      if (!incBW)
         return(-1);
      n = cnnblks;
      i = cnnblks >> 1;
/*
 *    Keep trying half-size M until we can copy all of A subsection
 */
      j = 0;       /* # of M blocks to do undefined */
      while(i > 2)
      {
         i += n - i - i;  /* # of blks to try at a whack */
         if (!mmMNK(M, i*NB, K, cnmblks, i, cnkblks, nkblks, kr, alpha, 
                    A, lda, incAk, incAW, B, ldb, incBk, incBW, 
                    beta, C, ldc, A2blk, B2blk))
         {
            incAB = (TB == AtlasNoTrans) ? 2*NB*ldb*i : 2*NB*i;
            incC = 2*NB*i*ldc;
            j = i;
            break;
         }
         n = i;
         i >>= 1;
      }
      if (j)  /* we've handled first J cols of B */
      {
         for (i=j; i < cnnblks; i += j)
         {
            B += incAB;
            C += incC;
            if (i+j < cnnblks)
               n = j * MB;
            else
            {
               n = N - i*NB;
               j = cnnblks - i;
            }
            if (mmMNK(M, n, K, cnmblks, j, cnkblks, nkblks, kr, alpha, 
                      A, lda, incAk, incAW, B, ldb, incBk, incBW, 
                      beta, C, ldc, A2blk, B2blk))
               if (mmMNK(M, n, K, cnmblks, j, cnkblks, nkblks, kr, alpha, 
                         A, lda, incAk, incAW, B, ldb, incBk, 0, 
                         beta, C, ldc, A2blk, B2blk))
                  ATL_assert(!mmMNK(M, n, K, cnmblks, j, cnkblks, nkblks, kr,
                                    alpha, A, lda, incAk, 0, B, ldb, incBk, 0, 
                                    beta, C, ldc, A2blk, B2blk));
         }
      }
      else  /* just try not copying A at all */
         return(mmNMK(M, N, K, cnmblks, cnnblks, cnkblks, nkblks, kr, alpha, 
                      A, lda, incAk, 0, B, ldb, incBk, incBW, 
                      beta, C, ldc, A2blk, B2blk));
   }
   return(0);
}
@ROUT ATL_mmK
@extract -b @(topd)/gen.inc what=cw @(cw07)
#include "atlas_misc.h"
#include "atlas_lvl3.h"

void Mjoin(PATL,mmK)(int M,  /* true # of rows in row-panel, M <= MB */
                     int m,  /* # of rows to operate on, m >= M */
                     int N,  /* true # of cols in col-panel, N < = NB */
                     int n,  /* # of cols to operate on, n >= N */
                     int nblk, /* # of blocks in K dimension */
                     int kr,   /* kr = K - nKb*KB; */
                     int KR,   /* 0 : do not do full KB-call to avoid cleanup */
                     const SCALAR alphaA,  /* alpha to apply during A copy */
                     const SCALAR alphaB,  /* alpha to apply during B copy */
                     const SCALAR beta,    /* beta to apply to C */
                     const TYPE *A, /* array to copy from, NULL if already cp */
                     const int lda,  /* leading dimension of A */
                     const int incA, /* inc to next blk in A */
                     TYPE *pA,       /* wrkspace to copy A to */
                     const int incAW, /* 0 : keep using same KBxMB space */
                     const TYPE *B, /* array to copy from, NULL if already cp */
                     const int ldb,  /* leading dimension of B */
                     const int incB, /* inc to next blk in B */
                     TYPE *pB,       /* wrkspace to copy B to */
                     const int incBW, /* 0 : keep using same KBxNB space */
                     TYPE *C,         /* output matrix */
                     const int ldc,
                     MAT2BLK2 A2blk, /* rout to copy A */
                     MAT2BLK2 B2blk, /* rout to copy B */
                     NBMM0 NBmm0,    /* rout to do first mul (applies beta) */
                     NBMM0 NBmm1)    /* rout to do later muls (beta=1) */
/*
 * Performs a K-inner-loop matmul, while copying A & B if necessary.
 * If M > m, we are doing extra flops so we don't call cleanup (same for N)
 */
{
   int k;
   if (nblk)
   {
      if (B) { B2blk(KB, N, alphaB, B, ldb, pB, KB); B += incB; }
      if (A) { A2blk(KB, M, alphaA, A, lda, pA, KB); A += incA; }
      NBmm0(m, n, KB, ATL_rone, pA, KB, pB, KB, beta, C, ldc);
      pA += incAW; pB += incBW;
      for (k = nblk-1; k; k--)
      {
         if (B) { B2blk(KB, N, alphaB, B, ldb, pB, KB); B += incB; }
         if (A) { A2blk(KB, M, alphaA, A, lda, pA, KB); A += incA; }
         NBmm1(m, n, KB, ATL_rone, pA, KB, pB, KB, ATL_rone, C, ldc);
         pA += incAW; pB += incBW;
      }
   }
   if (kr)  /* need to cleanup K loop */
   {
      if (KR)
      {
         if (B)
         {
            B2blk(kr, N, alphaB, B, ldb, pB, KB);
            Mjoin(PATL,gezero)(KB-kr, n, pB+kr, KB);
         }
         if (A)
         {
            A2blk(kr, M, alphaA, A, lda, pA, KB);
            Mjoin(PATL,gezero)(KB-kr, m, pA+kr, KB);
         }
         if (nblk)
            NBmm1(m, n, KB, ATL_rone, pA, KB, pB, KB, ATL_rone, C, ldc);
         else
            NBmm0(m, n, KB, ATL_rone, pA, KB, pB, KB, beta, C, ldc);
      }
      else
      {
         if (B) B2blk(kr, N, alphaB, B, ldb, pB, kr);
         if (A) A2blk(kr, M, alphaA, A, lda, pA, kr);
         Mjoin(PATL,pKBmm)(M, N, kr, ATL_rone, pA, kr, pB, kr, 
                           nblk ? ATL_rone : beta, C, ldc);
      }
   }
}

@ROUT ATL_mmJITcp
@extract -b @(topd)/gen.inc what=cw @(cw07)
#include "atlas_misc.h"
#include "atlas_lvl3.h"
#include <stdlib.h>

int Mjoin(PATL,mmJITcp)(const enum ATLAS_TRANS TA, const enum ATLAS_TRANS TB,
                        const int M0, const int N, const int K,
                        const SCALAR alpha, const TYPE *A, const int lda,
                        const TYPE *B, const int ldb, const SCALAR beta,
                        TYPE *C, const int ldc)
/*
 * Copy matmul algorithm, copies A and B on-the-fly
 * If M < 0, allocates only (MB+NB)*KB workspace
 */
{
   void *v=NULL;
   const TYPE *a=A;
   TYPE *pA, *pB, *pB0;
   MAT2BLK2 A2blk, B2blk;
   NBMM0 NBmm0, NBmm1, pNBmm0;
   const int M = (M0 >= 0) ? M0 : -M0;
   int nkblks, nmblks, nnblks, mr, nr, kr, KR, bigK, h, i, j, ZEROC;
   size_t incAk, incBk, incAm, incBn, incAW, incAWp, incBW, incBWp, incW;

/*
 * If both M and N <= NB, and one of them is not full, call BPP, which
 * can sometimes avoid doing cleanup forall cases
 */
   if (M <= MB && N <= NB && (M != MB || N != NB))
      return(Mjoin(PATL,mmBPP)(TA, TB, M, N, K, alpha, A, lda, B, ldb,
                               beta, C, ldc));
/*
 * If these workspace increments are 0, we do JIT NBxNB copies instead of
 * copying entire array/panel.  Don't copy mat if you can't reuse it.
 */
   if (M0 > 0)
   {
      incAW = (N > NB) ? KB*MB : 0;
      incBW = (M > NB) ? KB*NB : 0;
   }
   else /* allocate in minimal space */
      incAW = incBW = 0;
   nmblks = M/MB;
   nnblks = N/NB;
   nkblks = K/KB;
   mr = M - nmblks*MB;
   nr = N - nnblks*NB;
   kr = K - nkblks*KB;
/*
 * K-loop is special, in that we don't call user cleanup, must explicitly zero,
 * and K-cleanup is typically slower even for generated kernels.  Therefore,
 * allow extra leaway for doing extra flops.  Note error is unaffected by
 * any of these extra flops: K-loop has elts zeroed, and multiplying zeros
 * and adding in zeros doesn't add to error
 */
   KR = (kr && kr+4 >= KB) ? KB : kr;
   bigK = nkblks*KB+KR;
   if (incAW)
   {
      i = MB*bigK;
      incAWp = KB*mr;
   }
   else
   {
      i = MB*KB;
      incAWp = 0;
   }
   if (incBW)
   {
      incBWp = KB*nr;
      incW = bigK*NB;
      i += N*bigK;
   }
   else
   {
      incBWp = incW = 0;
      i += NB*KB;
   }
   i *= sizeof(TYPE);
   if (i <= ATL_MaxMalloc || !(incAW | incBW))
      v = malloc(ATL_Cachelen+i);
   if (!v) return(-1);
   pA = ATL_AlignPtr(v);
   pB0 = pA + (incAW ? bigK*MB : KB*MB);
   if (TA == AtlasNoTrans)
   {
      A2blk = Mjoin(PATL,gemoveT);
      incAk = lda*KB;
      incAm = MB;
   }
   else
   {
      A2blk = Mjoin(PATL,gemove);
      incAk = KB;
      incAm = MB*lda;
   }
   if (TB == AtlasNoTrans)
   {
      B2blk = Mjoin(PATL,gemove);
      incBk = KB;
      incBn = NB*ldb;
   }
   else
   {
      B2blk = Mjoin(PATL,gemoveT);
      incBk = ldb*KB;
      incBn = NB;
   }
/*
 * See what kernel we're calling
 */
   if ( SCALAR_IS_ONE(beta) )
   {
      NBmm0 = NBmm_b1;
      pNBmm0 = Mjoin(PATL,pNBmm_b1);
   }
   else if ( SCALAR_IS_ZERO(beta) )
   {
      NBmm0 = NBmm_b0;
      pNBmm0 = Mjoin(PATL,pNBmm_b0);
   }
   else
   {
      NBmm0 = NBmm_bX;
      pNBmm0 = Mjoin(PATL,pNBmm_bX);
   }
   KR = (KR == KB) ? KB : 0;
@skip   ZEROC = !(nnblks | nkblks | KR) && SCALAR_IS_ZERO(beta);
   ZEROC = !KR && SCALAR_IS_ZERO(beta);
   
   for (i=0; i < nmblks; i++)
   {
      a = A+i*incAm;
      pB = pB0;       /* foreach row-panel of A, start at B's copy space */
      for (j=nnblks; j; j--)
      {
         Mjoin(PATL,mmK)(MB, MB, NB, NB, nkblks, kr, KR, ATL_rone, alpha, beta,
                         a, lda, incAk, pA, incAW, B, ldb, incBk, pB, incBW,
                         C, ldc, A2blk, B2blk, NBmm0, NBmm_b1);
         B += incBn;             /* copy next col panel of B */
         pB += incW;             /* to next col panel of pB  */
         a = (incAW ? NULL : a); /* reuse row-panel of A if copied */
         C += ldc*NB;
      }
      if (nr)
      {
         if (ZEROC)
            Mjoin(PATL,gezero)(MB, nr, C, ldc);
         Mjoin(PATL,mmK)(MB, MB, nr, nr, nkblks, kr, KR, ATL_rone, alpha, beta,
                         a, lda, incAk, pA, incAW, B, ldb, incBk, pB, incBWp,
                         C, ldc, A2blk, B2blk, pNBmm0, Mjoin(PATL,pNBmm_b1));
      }
      C += MB - nnblks*ldc*NB;
      if (incBW)
      {
         B = NULL;              /* finished copying B */
         incBn = 0;
      }
      else
         B -= nnblks*incBn;
   }
   if (mr)
   { 
      a = A + nmblks*incAm; 
      pB = pB0;
      if ( SCALAR_IS_ONE(beta) ) NBmm0 = Mjoin(PATL,pMBmm_b1);
      else if ( SCALAR_IS_ZERO(beta) ) NBmm0 = Mjoin(PATL,pMBmm_b0);
      else NBmm0 = Mjoin(PATL,pMBmm_bX);
      for (j=nnblks; j; j--)
      {
         Mjoin(PATL,mmK)(mr, mr, NB, NB, nkblks, kr, KR, ATL_rone, alpha, beta,
                         a, lda, incAk, pA, incAWp, B, ldb, incBk, pB, incBW,
                         C, ldc, A2blk, B2blk, NBmm0, Mjoin(PATL,pMBmm_b1));
         B += incBn;              /* copy next col panel of B */
         pB += incW;              /* to next col panel of pB  */
         a = (incAW ? NULL : a);  /* reuse row-panel of A if copied */
         C += ldc*NB;
      }
      if (nr)
      {
         if ( SCALAR_IS_ZERO(beta) )
            Mjoin(PATL,gezero)(mr, nr, C, ldc);
         Mjoin(PATL,mmK)(mr, mr, nr, nr, nkblks, kr, (incAW | incBW) ? KR:0,
                         ATL_rone, alpha, beta, a, lda, incAk, pA, incAWp, 
                         B, ldb, incBk, pB, incBWp, C, ldc, A2blk, B2blk, 
                         Mjoin(PATL,pKBmm), Mjoin(PATL,pKBmm));
      }
   }
   free(v);
   return(0);
}
@ROUT ATL_mmBPP
@extract -b @(topd)/gen.inc what=cw @(cw07)
#include "atlas_misc.h"
#include "atlas_lvl3.h"
#include <stdlib.h>

int Mjoin(PATL,mmBPP)(const enum ATLAS_TRANS TA, const enum ATLAS_TRANS TB,
                      const int M, const int N, const int K,
                      const SCALAR alpha, const TYPE *A, const int lda,
                      const TYPE *B, const int ldb, const SCALAR beta,
                      TYPE *C, const int ldc0)
/*
 * Copy algorithm, assuming M <= MB && N <= NB, K large (shape: block, panel,
 * panel); copies A and B on-the-fly
 */
{
   void *vC;
   TYPE *pA, *pB, *pC;
   void (*A2blk)(int N, int M, const SCALAR alpha, const TYPE *A, int lda, 
                 TYPE *C, int ldc);
   void (*B2blk)(int N, int M, const SCALAR alpha, const TYPE *A, int lda,
                 TYPE *C, int ldc);
   NBMM0 NBmm0, NBmm1;
   size_t ldc, incA, incB;
   int m, n, nblk, k, kr;

   if (M > MB || N > NB)  /* don't handle multiple M/N blocks */
      return(1);
   if (M < MB && M+ATL_mmMU >= MB)
      m = MB;
   else
      m = M;
   if (N < NB && N+ATL_mmNU >= NB)
      n = NB;
   else
      n = N;
   ldc = (((m*sizeof(TYPE)+ATL_Cachelen-1)/ATL_Cachelen)*ATL_Cachelen)
          / sizeof(TYPE);
   vC = malloc(ATL_Cachelen+ATL_MulBySize(ldc*n+KB*(m+n)));
   if (!vC) return(-1);
   pC = ATL_AlignPtr(vC);
   pA = pC + ldc*n;
   pB = pA + KB*m;
   if (TA == AtlasNoTrans)
   {
      A2blk = Mjoin(PATL,gemoveT);
      incA = lda*KB;
   }
   else
   {
      A2blk = Mjoin(PATL,gemove);
      incA = KB;
   }
   if (TB == AtlasNoTrans)
   {
      B2blk = Mjoin(PATL,gemove);
      incB = KB;
   }
   else
   {
      B2blk = Mjoin(PATL,gemoveT);
      incB = ldb*KB;
   }
/*
 * If we are going to multiply zeros to avoid cleanup, zero workspace
 */
   if (m != M || n != N)
      Mjoin(PATL,zero)(ldc*n+KB*(m+n), pC, 1);
/*
 * See what kernel we're calling
 */
   if (m == MB)
   {
      if (n == NB)  /* no cleanup */
      {
         NBmm0 = NBmm_b0;
         NBmm1 = NBmm_b1;
      }
      else         /* need to call N-cleanup kernel */
      {
         NBmm0 = Mjoin(PATL,pNBmm_b0);
         NBmm1 = Mjoin(PATL,pNBmm_b1);
      }
   }
   else if (n == NB) /* call M-cleanup kernel */
   {
      NBmm0 = Mjoin(PATL,pMBmm_b0);
      NBmm1 =  Mjoin(PATL,pMBmm_b1);
   }
   else              /* both N & M are cleanup, call general K clean */
   {
      NBmm0 = Mjoin(PATL,pKBmm);
      NBmm1 = Mjoin(PATL,pKBmm);
      if (m == M && n == N)  /* must zero pC if not done above */
         Mjoin(PATL,zero)(ldc*n, pC, 1);

   }
   nblk = K / KB;
   kr = K - nblk*KB;
   if (!nblk && kr)
      Mjoin(PATL,zero)(ldc*n, pC, 1);
   Mjoin(PATL,mmK)(M, m, N, n, nblk, kr, (kr && kr+4 >= KB) ? KB : 0, 
                   ATL_rone, ATL_rone, ATL_rzero, A, lda, incA, pA, 0, 
                   B, ldb, incB, pB, 0, pC, ldc, A2blk, B2blk, NBmm0, NBmm1);
   Mjoin(PATL,geadd)(M, N, alpha, pC, ldc, beta, C, ldc0);
   free(vC);
   return(0);
}
@ROUT ATL_rankK_JI
/*
 * Developed this code to see if it was meaningfully faster than JIK, and
 * it doesn't appear to be.  Might still be worthwhile for odd K if we want
 * to fill that in later & try
 */
@extract -b @(topd)/gen.inc what=cw @(cw08)
#include "atlas_misc.h"
#include "atlas_lvl3.h"

#define KBmm Mjoin(PATL,pKBmm)
#define IBNBmm Mjoin(PATL,IBNBmm)
#define NBJBmm Mjoin(PATL,MBJBmm)
#define IBJBmm Mjoin(PATL,IBJBmm)

int Mjoin(PATL,rk_JI)(const enum ATLAS_TRANS TA, const enum ATLAS_TRANS TB,
                      const int M, const int N, const int K,
                      const SCALAR alpha, const TYPE *A, const int lda,
                      const TYPE *B, const int ldb, 
                      const SCALAR beta, TYPE *C, const int ldc)
/*
 * Special-case code for when K <= KB
 */
{
   int j, i, incB;
   const int incK = ATL_MulByNB(K);   /* incK = NB*K  =  sizeof(colpan(B)) */
   const int nMb = ATL_DivByNB(M), nNb = ATL_DivByNB(N);
   const int ib = M-ATL_MulByNB(nMb), jb = N-ATL_MulByNB(nNb);
   const int incC = ATL_MulByNB(ldc-nMb);
   TYPE *pA0, *pA, *pB;
   void *vB;
   NBMM0 NBmm0;
   MAT2BLK B2blk;

   if (K != KB)
      return(1);
   if ( SCALAR_IS_ONE(beta) ) NBmm0 = NBmm_b1;
   else if ( SCALAR_IS_ZERO(beta) ) NBmm0 = NBmm_b0;
   else NBmm0 = NBmm_bX;
   i = ATL_Cachelen + ATL_MulBySize(M*K + incK);
   if (i <= ATL_MaxMalloc)
      vB = malloc(i);
   if (!vB) return(2); 
   pB = ATL_AlignPtr(vB);
   pA0 = pA = pB + incK;
/*
 * Copy all of A into block-major format
 */
   if (TA == AtlasNoTrans)
   {
      if ( SCALAR_IS_ONE(alpha) ) 
         Mjoin(PATL,row2blkT2_a1)(M, K, A, lda, pA, alpha);
      else 
         Mjoin(PATL,row2blkT2_aX)(M, K, A, lda, pA, alpha);
   }
   else
   {
      if ( SCALAR_IS_ONE(alpha) ) 
         Mjoin(PATL,col2blk2_a1)(M, K, A, lda, pA, alpha);
      else 
         Mjoin(PATL,col2blk2_aX)(M, K, A, lda, pA, alpha);
   }
   if (TB == AtlasNoTrans)
   {
      incB = ATL_MulByNB(ldb);
      B2blk = Mjoin(PATL,col2blk_a1);
   }
   else
   {
      incB = NB;
      B2blk = Mjoin(PATL,row2blkT_a1);
   }
   if (K == KB)
   {
      for (j=0; j < nNb; j++)
      {
         B2blk(K, NB, B, ldb, pB, alpha);
         B += incB;
         for (i=0; i < nMb; i++)
         {
            NBmm0(MB, NB, KB, ATL_rone, pA, KB, pB, KB, beta, C, ldc);
            pA += NBNB;
            C += NB;
         }
         if (ib)
            IBNBmm(ib, K, pA, pB, beta, C, ldc);
         C += incC;
         pA = pA0;
      }
      if (jb)
      {
         B2blk(K, jb, B, ldb, pB, alpha);
         for (i=0; i < nMb; i++)
         {
            NBJBmm(jb, K, pA, pB, beta, C, ldc);
            pA += incK;
            C += NB;
         }
         if (ib)
            IBJBmm(ib, jb, K, pA, pB, beta, C, ldc);
      }
   }
   else
   {
   }
   return(0);
}
@ROUT ATL_mmJIK
@extract -b @(topd)/gen.inc what=cw

#include "atlas_misc.h"
#include "atlas_lvl3.h"
#include <stdlib.h>

#define KBmm Mjoin(PATL,pKBmm)
#define IBNBmm Mjoin(PATL,IBNBmm)
#define NBJBmm Mjoin(PATL,MBJBmm)
#define IBJBmm Mjoin(PATL,IBJBmm)

void Mjoin(PATL,mmJIK2)
             (int K, int nMb, int nNb, int nKb, int ib, int jb, int kb, 
              const SCALAR alpha, const TYPE *pA0, const TYPE *B, int ldb, 
              TYPE *pB0, int incB, MAT2BLK B2blk, const SCALAR beta, 
              TYPE *C, int ldc, TYPE *pC, PUTBLK putblk, NBMM0 NBmm0)
{
   const int incK = ATL_MulByNB(K), incC = ATL_MulByNB(ldc-nMb);
   const int ZEROC = ((putblk == NULL) && (beta == ATL_rzero));
   int i, j = nNb, ldpc;
   const TYPE *pA=pA0;
   const TYPE cubeta = ( (putblk) ? ATL_rzero : beta );
   TYPE *pB=pB0, *stB=pB0+ATL_MulByNBNB(nKb);

   if (putblk)
   {
      ldpc = NB;
      if (!nKb && kb) Mjoin(PATL,gezero)(MB, NB, pC, MB);
   }
   else ldpc = ldc;

   if (nNb)
   {
      do  /* Loop over full column panels of B */
      {
         if (B)
         {
            B2blk(K, NB, B, ldb, pB, alpha);
            B += incB;
         }
         if (nMb)
         {
            i = nMb;
            do /* loop over full row panels of A */
            {
               if (nKb) /* loop over full blocks in panels */
               {  /* 1st block does scaling */
                  NBmm0(MB, NB, KB, ATL_rone, pA, KB, pB, KB, beta, pC, ldpc);
                  pA += NBNB;
                  pB += NBNB;
                  if (nKb != 1)
                  {
                     do
                     {
                        NBmm(MB, NB, KB, ATL_rone, pA, KB, pB, KB, ATL_rone, 
                             pC, ldpc);
                        pA += NBNB;
                        pB += NBNB;
                     }
                     while (pB != stB);
                  }
                  if (kb)
                  {
                     KBmm(MB, NB, kb, ATL_rone, pA, kb, pB, kb, ATL_rone,
                          pC, ldpc);
                     pA += ATL_MulByNB(kb);
                  }
               }
               else
               {
                  if (ZEROC) Mjoin(PATL,gezero)(MB, NB, pC, ldpc);
                  if (kb)
                  {
                     KBmm(MB, NB, kb, ATL_rone, pA, kb, pB, kb, cubeta, 
                          pC, ldpc);
                     pA += ATL_MulByNB(kb);
                  }
               }
               pB = pB0;
               if (putblk) putblk(NB, NB, pC, C, ldc, beta);
               else pC += NB;
               C += NB;
            }
            while (--i);
         }
         if (ib)
         {
            if (putblk)
            {
               IBNBmm(ib, K, pA, pB, ATL_rzero, pC, ib);
               putblk(ib, NB, pC, C, ldc, beta);
            }
            else IBNBmm(ib, K, pA, pB, beta, C, ldc);
         }
         if (!B)
         {
            pB0 += incK;
            pB = pB0;
            stB += incK;
         }
         C += incC;
         if (!putblk) pC = C;
         pA = pA0;
      }
      while (--j);
   }
   if (jb)
   {
      if (B) B2blk(K, jb, B, ldb, pB, alpha);
      for (i=nMb; i; i--)
      {
         NBJBmm(jb, K, pA, pB, cubeta, pC, ldpc);
         if (putblk) putblk(NB, jb, pC, C, ldc, beta);
         else pC += NB;
         pA += incK;
         C += NB;
      }
      if (ib)
      {
         if (putblk)
         {
            IBJBmm(ib, jb, K, pA, pB, ATL_rzero, pC, ib);
            putblk(ib, jb, pC, C, ldc, beta);
         }
         else IBJBmm(ib, jb, K, pA, pB, beta, C, ldc);
      }
   }
}

@beginskip
int Mjoin(PATL,mmJIK)(const enum ATLAS_TRANS TA, const enum ATLAS_TRANS TB, 
                      const int M0, const int N, const int K, 
                      const SCALAR alpha, const TYPE *A, const int lda, 
                      const TYPE *B, const int ldb, const SCALAR beta, 
                      TYPE *C, const int ldc)
/*
 * Outer three loops for matmul with outer loop over columns of B
 */
{
   int M = M0;
   int nMb, nNb, nKb, ib, jb, kb, h, i, j, k, incB;
   const int incK = ATL_MulByNB(K);
   void *vB=NULL, *vC=NULL;
   TYPE *pA, *pB, *pC;
   MAT2BLK B2blk;
   PUTBLK putblk;
   NBMM0 NBmm0;

   nMb = ATL_DivByNB(M);
   nNb = ATL_DivByNB(N);
   nKb = ATL_DivByNB(K);
   ib = M - ATL_MulByNB(nMb);
   jb = N - ATL_MulByNB(nNb);
   kb = K - ATL_MulByNB(nKb);

/*
 * If K sufficiently large, write to temporary C as safety measure;  otherwise
 * write directly to C
 */
   if (nKb < 12)
   {
      putblk = NULL;
      pC = C;
      if ( SCALAR_IS_ONE(beta) ) NBmm0 = NBmm_b1;
      else if ( SCALAR_IS_ZERO(beta) ) NBmm0 = NBmm_b0;
      else NBmm0 = NBmm_bX;
   }
   else
   {
      NBmm0 = NBmm_b0;
      vC = malloc(ATL_MulBySize(NBNB)+ATL_Cachelen);
      if (!vC) return(-1);
      pC = ATL_AlignPtr(vC);
      if ( SCALAR_IS_ONE(beta) ) putblk = Mjoin(PATL,putblk_b1);
      else if ( SCALAR_IS_ZERO(beta) ) putblk = Mjoin(PATL,putblk_b0);
      else if ( SCALAR_IS_NONE(beta) ) putblk = Mjoin(PATL,putblk_bn1);
      else putblk = Mjoin(PATL,putblk_bX);
   }
@beginskip
@skip REMOVED THIS SPECIAL CASE BECAUSE IT CAN CAUSE SLOWDOWN UNPREDICTABLY,
@skip AS DISCOVERED BY TONY ON OPT8
/*
 * Special case for when we don't need to copy one or more of our matrices
 */
   if (K == NB && TA == AtlasTrans && lda == NB && ATL_DataIsMinAligned(A))
   {
      pA = (TYPE *) A;
      if (TB == AtlasNoTrans && ldb == NB && SCALAR_IS_ONE(alpha) &&
          ATL_DataIsMinAligned(B))
      {
         i = NBNB;
         pB = (TYPE *) B;
         B = NULL;
         B2blk = NULL;
         incB = 0;
      }
      else 
      {
         i = NBNB + incK;
         vB = malloc(ATL_MulBySize(incK) + ATL_Cachelen);
         if (!vB)
         {
            if (vC) free(vC);
            return(-1);
         }
         pB = ATL_AlignPtr(vB);
         if (TB == AtlasNoTrans)
         {
            incB = ATL_MulByNB(ldb);
            if ( SCALAR_IS_ONE(alpha) ) B2blk = Mjoin(PATL,col2blk_a1);
            else B2blk = Mjoin(PATL,col2blk_aX);
         }
         else
         {
            incB = NB;
            if ( SCALAR_IS_ONE(alpha) ) B2blk = Mjoin(PATL,row2blkT_a1);
            else B2blk = Mjoin(PATL,row2blkT_aX);
         }
      }
      Mjoin(PATL,mmJIK2)(K, nMb, nNb, nKb, ib, jb, kb, alpha, pA, B, ldb, pB, 
                          incB, B2blk, beta, C, ldc, pC, putblk, NBmm0);
      if (vB) free(vB);
      if (vC) free(vC);
      return(0);
   }
@endskip
/*
 * Special case for when what we are really doing is 
 *    C <- beta*C + alpha * A * A'   or   C <- beta*C + alpha * A' * A
 */
   if ( A == B && M == N && && lda == ldb && TA != TB && 
        (SCALAR_IS_ONE(alpha) || M <= NB) )
   {
      i = ATL_MulBySize(M * K);
      if (!SCALAR_IS_ONE(alpha) && pC == C && !SCALAR_IS_ZERO(beta)) 
         i += ATL_MulBySize(M*N);
      if (i <= ATL_MaxMalloc) vB = malloc(i + ATL_Cachelen);
      if (vB)
      {
         pA = ATL_AlignPtr(vB);
         if (TA == AtlasNoTrans)
            Mjoin(PATL,row2blkT2_a1)(M, K, A, lda, pA, alpha);
         else Mjoin(PATL,col2blk_a1)(K, M, A, lda, pA, alpha);
/*
 *       Can't write directly to C if alpha is not one
 */
         if (!SCALAR_IS_ONE(alpha))
         {
            if (SCALAR_IS_ZERO(beta)) h = ldc;
            else if (pC == C)
            {
               pC = pA + ((size_t)M) * K;
               h = M;
            }
            else h = NB;
            Mjoin(PATL,mmJIK2)(K, nMb, nNb, nKb, ib, jb, kb, 1.0, pA, NULL, 
                                 ldb, pA, 0, NULL, 0.0, pC, h, pC, NULL, 
                                 NBmm_b0);

            Mjoin(PATL,gescal_bX)(M, N, alpha, pC, h);

            if (C != pC)
            {
               if (SCALAR_IS_ONE(beta)) 
                  Mjoin(PATL,putblk_b1)(M, N, pC, C, ldc, beta);
               else if (SCALAR_IS_NONE(beta))
                  Mjoin(PATL,putblk_bn1)(M, N, pC, C, ldc, beta);
               else if (SCALAR_IS_ZERO(beta))
                  Mjoin(PATL,putblk_b0)(M, N, pC, C, ldc, beta);
               else
                  Mjoin(PATL,putblk_bX)(M, N, pC, C, ldc, beta);
            }
         }
         else
            Mjoin(PATL,mmJIK2)(K, nMb, nNb, nKb, ib, jb, kb, alpha, pA, NULL, 
                                 ldb, pA, 0, NULL, beta, C, ldc, pC, 
                                 putblk, NBmm0);
         free(vB);
         if (vC) free(vC);
         return(0);
      }
   }
   i = ATL_Cachelen + ATL_MulBySize(M*K + incK);
   if (i <= ATL_MaxMalloc || K <= KB) vB = malloc(i);
/*
 * If we can't get enough memory, chop K until we can
 */
   if (!vB)
   {
      if (vC) free(vC);
      if (TA != AtlasNoTrans && TB != AtlasNoTrans) return(1);
      if (nKb < 2) return(-1);
      k = ATL_MulByNB(nKb>>1);
      h = K - k;
      i = Mjoin(PATL,mmJIK)(TA, TB, M0, N, k, alpha, A, lda, B, ldb,
                            beta, C, ldc);
      if (i) return(-2);
      if (TA == AtlasNoTrans) A += k*lda;
      else A += k;
      if (TB == AtlasNoTrans) B += k;
      else B += k*ldb;
      if ( Mjoin(PATL,mmJIK)(TA, TB, M0, N, h, alpha, A, lda, B, ldb,
                             ATL_rone, C, ldc) );
      {
         if ( Mjoin(PATL,mmIJK)(TA, TB, M0, N, h, alpha, A, lda, B, ldb,
                                ATL_rone, C, ldc) );
         {
            ATL_assert( Mjoin(PATL,NCmmJIK)(TA, TB, M0, N, h, alpha, A, lda,
                                            B, ldb, ATL_rone, C, ldc) == 0 );
         }
      }
      return(0);
   }

   pB = ATL_AlignPtr(vB);
   pA = pB + incK;
   if (TA == AtlasNoTrans)
   {
      if ( SCALAR_IS_ONE(alpha) )
         Mjoin(PATL,row2blkT2_a1)(M, K, A, lda, pA, alpha);
      else Mjoin(PATL,row2blkT2_aX)(M, K, A, lda, pA, alpha);
   }
   else
   {
      if ( SCALAR_IS_ONE(alpha) )
         Mjoin(PATL,col2blk2_a1)(K, M, A, lda, pA, alpha);
      else Mjoin(PATL,col2blk2_aX)(K, M, A, lda, pA, alpha);
   }
   if (TB == AtlasNoTrans)
   {
      incB = ATL_MulByNB(ldb);
      B2blk = Mjoin(PATL,col2blk_a1);
   }
   else
   {
      incB = NB;
      B2blk = Mjoin(PATL,row2blkT_a1);
   }

   Mjoin(PATL,mmJIK2)(K, nMb, nNb, nKb, ib, jb, kb, alpha, pA, B, ldb, pB,
                      incB, B2blk, beta, C, ldc, pC, putblk, NBmm0);
   free(vB);
   if (vC) free(vC);
   return(0);
}
@endskip
int Mjoin(PATL,mmJIK)(const enum ATLAS_TRANS TA, const enum ATLAS_TRANS TB, 
                      const int M0, const int N, const int K, 
                      const SCALAR alpha, const TYPE *A, const int lda0, 
                      const TYPE *B, const int ldb0, const SCALAR beta, 
                      TYPE *C, const int ldc0)
/*
 * Outer three loops for matmul with outer loop over columns of B
 */
{
   int M = M0;
   int nMb, nNb, nKb, ib, jb, kb, ib2, h, i, j, k, m, n;
   const size_t lda = lda0, ldb = ldb0, ldc = ldc0;
   const size_t incK = ATL_MulByNB((size_t)K);
   size_t incA, incB, incC;
   void *vB=NULL, *vC=NULL;
   TYPE *pA, *pB, *pC;
   MAT2BLK A2blk, B2blk;
   PUTBLK putblk;
   NBMM0 NBmm0;

   nMb = ATL_DivByNB(M);
   nNb = ATL_DivByNB(N);
   nKb = ATL_DivByNB(K);
   ib = M - ATL_MulByNB(nMb);
   jb = N - ATL_MulByNB(nNb);
   kb = K - ATL_MulByNB(nKb);

/*
 * If K sufficiently large, write to temporary C as safety measure;  otherwise
 * write directly to C
 */
   if (nKb < 12)
   {
      putblk = NULL;
      pC = C;
      if ( SCALAR_IS_ONE(beta) ) NBmm0 = NBmm_b1;
      else if ( SCALAR_IS_ZERO(beta) ) NBmm0 = NBmm_b0;
      else NBmm0 = NBmm_bX;
   }
   else
   {
      NBmm0 = NBmm_b0;
      vC = malloc(ATL_MulBySize(NBNB)+ATL_Cachelen);
      if (!vC) return(-1);
      pC = ATL_AlignPtr(vC);
      if ( SCALAR_IS_ONE(beta) ) putblk = Mjoin(PATL,putblk_b1);
      else if ( SCALAR_IS_ZERO(beta) ) putblk = Mjoin(PATL,putblk_b0);
      else if ( SCALAR_IS_NONE(beta) ) putblk = Mjoin(PATL,putblk_bn1);
      else putblk = Mjoin(PATL,putblk_bX);
   }
/*
 * Special case for when we don't need to copy one or more of our matrices
 */
   if (K == NB && TA == AtlasTrans && lda == NB && ATL_DataIsMinAligned(A))
   {
      pA = (TYPE *) A;
      if (TB == AtlasNoTrans && ldb == NB && SCALAR_IS_ONE(alpha) &&
          ATL_DataIsMinAligned(B))
      {
         i = NBNB;
         pB = (TYPE *) B;
         B = NULL;
         B2blk = NULL;
         incB = 0;
      }
      else 
      {
         i = NBNB + incK;
         vB = malloc(ATL_MulBySize(incK) + ATL_Cachelen);
         if (!vB)
         {
            if (vC) free(vC);
            return(-1);
         }
         pB = ATL_AlignPtr(vB);
         if (TB == AtlasNoTrans)
         {
            incB = ATL_MulByNB(ldb);
            if ( SCALAR_IS_ONE(alpha) ) B2blk = Mjoin(PATL,col2blk_a1);
            else B2blk = Mjoin(PATL,col2blk_aX);
         }
         else
         {
            incB = NB;
            if ( SCALAR_IS_ONE(alpha) ) B2blk = Mjoin(PATL,row2blkT_a1);
            else B2blk = Mjoin(PATL,row2blkT_aX);
         }
      }
      Mjoin(PATL,mmJIK2)(K, nMb, nNb, nKb, ib, jb, kb, alpha, pA, B, ldb, pB, 
                          incB, B2blk, beta, C, ldc, pC, putblk, NBmm0);
      if (vB) free(vB);
      if (vC) free(vC);
      return(0);
   }
/*
 * Special case for when what we are really doing is 
 *    C <- beta*C + alpha * A * A'   or   C <- beta*C + alpha * A' * A
 */
   if ( A == B && M == N && TA != TB && lda == ldb &&
        (SCALAR_IS_ONE(alpha) || M <= NB) )
   {
      i = ATL_MulBySize(M * K);
      if (!SCALAR_IS_ONE(alpha) && pC == C && !SCALAR_IS_ZERO(beta)) 
         i += ATL_MulBySize(M*N);
      if (i <= ATL_MaxMalloc) vB = malloc(i + ATL_Cachelen);
      if (vB)
      {
         pA = ATL_AlignPtr(vB);
         if (TA == AtlasNoTrans)
            Mjoin(PATL,row2blkT2_a1)(M, K, A, lda, pA, alpha);
         else Mjoin(PATL,col2blk_a1)(K, M, A, lda, pA, alpha);
/*
 *       Can't write directly to C if alpha is not one
 */
         if (!SCALAR_IS_ONE(alpha))
         {
            if (SCALAR_IS_ZERO(beta)) h = ldc;
            else if (pC == C)
            {
               pC = pA + ((size_t)M) * K;
               h = M;
            }
            else h = NB;
            Mjoin(PATL,mmJIK2)(K, nMb, nNb, nKb, ib, jb, kb, 1.0, pA, NULL, 
                                 ldb, pA, 0, NULL, 0.0, pC, h, pC, NULL, 
                                 NBmm_b0);

            Mjoin(PATL,gescal_bX)(M, N, alpha, pC, h);

            if (C != pC)
            {
               if (SCALAR_IS_ONE(beta)) 
                  Mjoin(PATL,putblk_b1)(M, N, pC, C, ldc, beta);
               else if (SCALAR_IS_NONE(beta))
                  Mjoin(PATL,putblk_bn1)(M, N, pC, C, ldc, beta);
               else if (SCALAR_IS_ZERO(beta))
                  Mjoin(PATL,putblk_b0)(M, N, pC, C, ldc, beta);
               else
                  Mjoin(PATL,putblk_bX)(M, N, pC, C, ldc, beta);
            }
         }
         else
            Mjoin(PATL,mmJIK2)(K, nMb, nNb, nKb, ib, jb, kb, alpha, pA, NULL, 
                                 ldb, pA, 0, NULL, beta, C, ldc, pC, 
                                 putblk, NBmm0);
         free(vB);
         if (vC) free(vC);
         return(0);
      }
   }
   i = ATL_Cachelen + ATL_MulBySize(M*K + incK);
   if (i <= ATL_MaxMalloc) vB = malloc(i);
   if (!vB)
   {
      if (TA != AtlasNoTrans && TB != AtlasNoTrans)
      {
         if (vC) free(vC);
         return(1);
      }
      if (ib) n = nMb + 1;
      else n = nMb;
      for (j=2; !vB; j++)
      {
         k = n / j;
         if (k < 1) break;
         if (k*j < n) k++;
         h = ATL_Cachelen + ATL_MulBySize((k+1)*incK);
         if (h <= ATL_MaxMalloc) vB = malloc(h);
      }
      if (!vB)
      {
         if (vC) free(vC);
         return(-1);
      }
      n = k;
      m = ATL_MulByNB(n);
      ib2 = 0;
   }
   else
   {
      n = nMb;
      m = M;
      ib2 = ib;
   }
   pB = ATL_AlignPtr(vB);
   if (TA == AtlasNoTrans)
   {
      incA = m;
      if ( SCALAR_IS_ONE(alpha) ) A2blk = Mjoin(PATL,row2blkT2_a1);
      else A2blk = Mjoin(PATL,row2blkT2_aX);
   }
   else
   {
      incA = lda*m;
      if ( SCALAR_IS_ONE(alpha) ) A2blk = Mjoin(PATL,col2blk2_a1);
      else A2blk = Mjoin(PATL,col2blk2_aX);
   }
   if (TB == AtlasNoTrans)
   {
      incB = ATL_MulByNB(ldb);
      B2blk = Mjoin(PATL,col2blk_a1);
   }
   else
   {
      incB = NB;
      B2blk = Mjoin(PATL,row2blkT_a1);
   }
   incC = m;

   pA = pB + incK;
   do
   {
      if (TA == AtlasNoTrans) A2blk(m, K, A, lda, pA, alpha);
      else A2blk(K, m, A, lda, pA, alpha);
      Mjoin(PATL,mmJIK2)(K, n, nNb, nKb, ib2, jb, kb, alpha, pA, B, ldb, pB,
                          incB, B2blk, beta, C, ldc, pC, putblk, NBmm0);
      M -= m;
      nMb -= n;
      if (M <= m)
      {
         ib2 = ib;
         m = M;
         n = nMb;
      }
      C += incC;
      A += incA;
      if (!putblk) pC = C;
   }
   while (M);
   free(vB);
   if (vC) free(vC);
   return(0);
}
@ROUT ATL_CNBmm_b0
@extract -b @(topd)/gen.inc what=cw @(cw99)

#include "atlas_misc.h"
#include "atlas_lvl3.h"

void Mjoin(PATL,CNBmm_b0)(const int M, const int N, const int K, 
                          const TYPE alpha, const TYPE *A, const int lda, 
                          const TYPE *B, const int ldb, 
                          const TYPE beta, TYPE *C, const int ldc)
{
   NBmm_b0(M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
}
@ROUT ATL_CNBmm_b1
@extract -b @(topd)/gen.inc what=cw @(cw99)

#include "atlas_misc.h"
#include "atlas_lvl3.h"

void Mjoin(PATL,CNBmm_b1)(const int M, const int N, const int K, 
                          const TYPE alpha, const TYPE *A, const int lda, 
                          const TYPE *B, const int ldb, 
                          const TYPE beta, TYPE *C, const int ldc)
{
   NBmm_b1(M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
}
@ROUT ATL_CNBmm_bX
@extract -b @(topd)/gen.inc what=cw @(cw99)

#include "atlas_misc.h"
#include "atlas_lvl3.h"

void Mjoin(PATL,CNBmm_bX)(const int M, const int N, const int K, 
                          const TYPE alpha, const TYPE *A, const int lda, 
                          const TYPE *B, const int ldb, 
                          const TYPE beta, TYPE *C, const int ldc)
{
   NBmm_bX(M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
}
@ROUT ATL_cmmIJK
@extract -b @(topd)/gen.inc what=cw @(cw99)

#include "atlas_misc.h"
#include "atlas_lvl3.h"
#include <stdlib.h>

#define KBmm Mjoin(PATL,pKBmm)
#define IBNBmm Mjoin(PATL,IBNBmm)
#define MBJBmm Mjoin(PATL,MBJBmm)
#define IBJBmm Mjoin(PATL,IBJBmm)

void Mjoin(PATL,mmIJK2)
   (int K, int nMb, int nNb, int nKb, int ib, int jb, int kb, 
    const SCALAR alpha, const TYPE *A, const int lda, TYPE *pA0, const int incA,
    MAT2BLK A2blk, TYPE *pB0, const SCALAR beta, TYPE *C, int ldc, 
    MATSCAL gescal, NBMM0 NBmm0)
{
   const int incK = ATL_MulByNB(K)<<1;
   const int incCn = ATL_MulByNB(ldc)<<1, incCm = (MB<<1) - nNb*incCn;
   const int ZEROC = ((gescal == NULL) && SCALAR_IS_ZERO(beta));
   int i, j, k;
   const TYPE *pB=pB0;
   const TYPE rbeta = ( (gescal) ? ATL_rone : *beta );
   TYPE *pA=pA0;

   for (i=nMb; i; i--)
   {
      if (A)
      {
         A2blk(K, NB, A, lda, pA, alpha);  /* get 1 row panel of A */
         A += incA;
      }
      for (j=nNb; j; j--)
      {
         if (gescal) gescal(MB, NB, beta, C, ldc);
         if (nKb)
         {
            NBmm0(MB, NB, KB, ATL_rone, pA, KB, pB, KB, rbeta, C, ldc);
            pA += NBNB2;
            pB += NBNB2;
            if (nKb != 1)
            {
               for (k=nKb-1; k; k--, pA += NBNB2, pB += NBNB2)
                  NBmm_b1(MB, NB, KB, ATL_rone, pA, KB, pB, KB, 
                          ATL_rone, C, ldc);
            }
            if (kb)
            {
               KBmm(MB, NB, kb, ATL_rone, pA, kb, pB, kb, ATL_rone, C, ldc);
               pB += ATL_MulByNB(kb)<<1;
            }
         }
         else
         {
            if (ZEROC) Mjoin(PATL,gezero)(MB, NB, C, ldc);
            if (kb)
            {
               KBmm(MB, NB, kb, ATL_rone, pA, kb, pB, kb, rbeta, C, ldc);
               pB += ATL_MulByNB(kb)<<1;
            }
         }
         pA = pA0;
         C += incCn;
      }
      if (jb)
      {
         if (gescal) gescal(MB, jb, beta, C, ldc);
         MBJBmm(jb, K, pA, pB, rbeta, C, ldc);
      }
      pB = pB0;
      if (!A)
      {
         pA0 += incK;
         pA = pA0;
      }
      C += incCm;
   }
   if (ib)
   {
      if (A) A2blk(K, ib, A, lda, pA, alpha);   /* get last row panel of A */
      for(j=nNb; j; j--) /* full column panels of B */
      {
         if (gescal) gescal(ib, NB, beta, C, ldc);
         IBNBmm(ib, K, pA, pB, rbeta, C, ldc);
         pB += incK;
         C += incCn;
      }
      if (jb)
      {
         if (gescal) gescal(ib, jb, beta, C, ldc);
         IBJBmm(ib, jb, K, pA, pB, rbeta, C, ldc);
      }
   }
}

int Mjoin(PATL,mmIJK)(const enum ATLAS_TRANS TA, const enum ATLAS_TRANS TB, 
                      const int M, const int N0, const int K, 
                      const SCALAR alpha, const TYPE *A, const int lda0,
                      const TYPE *B, const int ldb0, const SCALAR beta, 
                      TYPE *C, const int ldc0)
{
   int N = N0;
   int nMb, nNb, nKb, ib, jb, kb, jb2, h, i, j, k, n;
   const size_t incK = ATL_MulByNB(K), lda=lda0, ldb=ldb0, ldc=ldc0;
   size_t incA, incB, incC;
   void *vA=NULL;
   TYPE *pA, *pB;
   MAT2BLK A2blk, B2blk;
   MATSCAL gescal;
   NBMM0 NBmm0;

   nMb = ATL_DivByNB(M);
   nNb = ATL_DivByNB(N);
   nKb = ATL_DivByNB(K);
   ib = M - ATL_MulByNB(nMb);
   jb = N - ATL_MulByNB(nNb);
   kb = K - ATL_MulByNB(nKb);

   if (beta[1] == ATL_rzero)
   {
      gescal = NULL;
      if (*beta == ATL_rone) NBmm0 = Mjoin(PATL,CNBmm_b1);
      else if (*beta == ATL_rzero) NBmm0 = Mjoin(PATL,CNBmm_b0);
      else NBmm0 = Mjoin(PATL,CNBmm_bX);
   }
   else
   {
      gescal = Mjoin(PATL,gescal_bX);
      NBmm0 = Mjoin(PATL,CNBmm_b1);
   }

   i = ATL_Cachelen + ATL_MulBySize(N*K + incK);
   if (i <= ATL_MaxMalloc) vA = malloc(i);
   if (!vA)
   {
      if (TA == AtlasNoTrans && TB == AtlasNoTrans) return(1);
      if (jb) n = nNb + 1;
      else n = nNb;
      for (j=2; !vA; j++)
      {
         k = n / j;
         if (k < 1) break;
         if (k*j < n) k++;
         h = ATL_Cachelen + ATL_MulBySize((k+1)*incK);
         if (h <= ATL_MaxMalloc) vA = malloc(h);
      }
      if (!vA) return(-1);
      n = ATL_MulByNB(k);
      jb2 = 0;
   }
   else
   {
      jb2 = jb;
      k = nNb;
      n = N;
   }
   pA = ATL_AlignPtr(vA);
   if (TB == AtlasNoTrans)
   {
      incB = ldb*n<<1;
      if (alpha[1] == ATL_rzero)
      {
         if (*alpha == ATL_rone) B2blk = Mjoin(PATL,col2blk2_a1);
         else B2blk = Mjoin(PATL,col2blk2_aXi0);
      }
      else B2blk = Mjoin(PATL,col2blk2_aX);
   }
   else if (TB == AtlasConjTrans)
   {
      incB = n<<1;
      if (alpha[1] == ATL_rzero)
      {
         if (*alpha == ATL_rone) B2blk = Mjoin(PATL,row2blkC2_a1);
         else B2blk = Mjoin(PATL,row2blkC2_aXi0);
      }
      else B2blk = Mjoin(PATL,row2blkC2_aX);
   }
   else
   {
      incB = n<<1;
      if (alpha[1] == ATL_rzero)
      {
         if (*alpha == ATL_rone) B2blk = Mjoin(PATL,row2blkT2_a1);
         else B2blk = Mjoin(PATL,row2blkT2_aXi0);
      }
      else B2blk = Mjoin(PATL,row2blkT2_aX);
   }
   if (TA == AtlasNoTrans)
   {
      incA = NB<<1;
      A2blk = Mjoin(PATL,row2blkT_a1);
   }
   else if (TA == AtlasConjTrans)
   {
      incA = ATL_MulByNB(lda)<<1;
      A2blk = Mjoin(PATL,col2blkConj_a1);
   }
   else
   {
      incA = ATL_MulByNB(lda)<<1;
      A2blk = Mjoin(PATL,col2blk_a1);
   }
   incC = ldc*n<<1;
   pB = pA + (incK<<1);

   do
   {
      if (TB == AtlasNoTrans) B2blk(K, n, B, ldb, pB, alpha);
      else B2blk(n, K, B, ldb, pB, alpha);
      Mjoin(PATL,mmIJK2)(K, nMb, k, nKb, ib, jb2, kb, alpha, A, lda, pA,
                         incA, A2blk, pB, beta, C, ldc, gescal, NBmm0);
      N -= n;
      nNb -= k;
      if (N < n)
      {
         jb2 = jb;
         n = N;
         k = nNb;
      }
      C += incC;
      B += incB;
   }
   while (N);

   free(vA);
   return(0);
}
@ROUT ATL_cmmJKI
@extract -b @(topd)/gen.inc what=cw @(cw06)

#include "atlas_misc.h"
#include "atlas_lvl3.h"
#include <stdlib.h>

#define ATL_cplxmul(out_, in1_, in2_) \
{ \
   r1 = in1_[0]; i1 = in1_[1]; \
   r2 = in2_[0]; i2 = in2_[1]; \
   out_[0] = r1*r2 - i1*i2; \
   out_[1] = r1*i2 + i1*r2; \
}

void Mjoin(PATL,mm_axpy)
   (const enum ATLAS_TRANS TA, const enum ATLAS_TRANS TB, const int M,
    const int N, const int K, const SCALAR alpha, const TYPE *A, const int lda0,
    const TYPE *B, const int ldb0, const SCALAR beta, TYPE *C, const int ldc0)
/*
 * TA == AtlasNoTrans
 * GEMM implemented by calling axpy, with any M partitioning already done
 */
{
   int i, j, k, incBk, incBn;
   const size_t lda=((size_t)lda0)+lda0, ldc=((size_t)ldc0)+ldc0, incAn = lda*K;
   const int ALONE=SCALAR_IS_ONE(alpha), BEONE=SCALAR_IS_ONE(beta);
   TYPE alph[2], BC[2];
   register TYPE r1, r2, i1, i2;

   if (TB == AtlasNoTrans)
   {
      incBk = 2; 
      incBn = ldb0 - K;
   }
   else
   {
      incBk = ldb0+ldb0;
      incBn = 1 - ldb0*K;
   }
   incBn += incBn;

   if (TB == AtlasConjTrans)
   {
      if (BEONE)
      {
         if (ALONE)
         {
            for(j=0; j < N; j++)
            {
               for (k=0; k < K; k++, B += incBk, A += lda)
               {
                  BC[0] = B[0]; BC[1] = -B[1];
                  Mjoin(PATL,axpy)(M, BC, A, 1, C, 1);
               }
               C += ldc;
               B += incBn;
               A -= incAn;
            }
         }
         else
         {
            for(j=0; j < N; j++)
            {
               BC[0] = B[0]; BC[1] = -B[1];
               ATL_cplxmul(alph, alpha, BC);
               Mjoin(PATL,axpby)(M, alph, A, 1, beta, C, 1);
               B += incBk;
               A += lda;
               for (k=1; k < K; k++, B += incBk, A += lda)
               {
                  BC[0] = B[0]; BC[1] = -B[1];
                  ATL_cplxmul(alph, alpha, BC);
                  Mjoin(PATL,axpy)(M, alph, A, 1, C, 1);
               }
               C += ldc;
               B += incBn;
               A -= incAn;
            }
         }
      }
      else /* BETA != 1.0 */
      {
         if (ALONE)
         {
            for(j=0; j < N; j++)
            {
               BC[0] = B[0]; BC[1] = -B[1];
               Mjoin(PATL,axpby)(M, BC, A, 1, beta, C, 1);
               B += incBk;
               A += lda;
               for (k=1; k < K; k++, B += incBk, A += lda)
               {
                  BC[0] = B[0]; BC[1] = -B[1];
                  Mjoin(PATL,axpy)(M, BC, A, 1, C, 1);
               }
               C += ldc;
               B += incBn;
               A -= incAn;
            }
         }
         else
         {
            for(j=0; j < N; j++)
            {
               BC[0] = B[0]; BC[1] = -B[1];
               ATL_cplxmul(alph, alpha, BC);
               Mjoin(PATL,axpby)(M, alph, A, 1, beta, C, 1);
               B += incBk;
               A += lda;
               for (k=1; k < K; k++, B += incBk, A += lda)
               {
                  BC[0] = B[0]; BC[1] = -B[1];
                  ATL_cplxmul(alph, alpha, BC);
                  Mjoin(PATL,axpy)(M, alph, A, 1, C, 1);
               }
               C += ldc;
               B += incBn;
               A -= incAn;
            }
         }
      }
   }
   else /* B is not conjugated */
   {
      if (BEONE)
      {
         if (ALONE)
         {
            for(j=0; j < N; j++)
            {
               for (k=0; k < K; k++, B += incBk, A += lda)
                  Mjoin(PATL,axpy)(M, B, A, 1, C, 1);
               C += ldc;
               B += incBn;
               A -= incAn;
            }
         }
         else
         {
            for(j=0; j < N; j++)
            {
               ATL_cplxmul(alph, alpha, B);
               Mjoin(PATL,axpby)(M, alph, A, 1, beta, C, 1);
               B += incBk;
               A += lda;
               for (k=1; k < K; k++, B += incBk, A += lda)
               {
                  ATL_cplxmul(alph, alpha, B);
                  Mjoin(PATL,axpy)(M, alph, A, 1, C, 1);
               }
               C += ldc;
               B += incBn;
               A -= incAn;
            }
         }
      }
      else /* BETA != 1.0 */
      {
         if (ALONE)
         {
            for(j=0; j < N; j++)
            {
               Mjoin(PATL,axpby)(M, B, A, 1, beta, C, 1);
               B += incBk;
               A += lda;
               for (k=1; k < K; k++, B += incBk, A += lda)
                  Mjoin(PATL,axpy)(M, B, A, 1, C, 1);
               C += ldc;
               B += incBn;
               A -= incAn;
            }
         }
         else
         {
            for(j=0; j < N; j++)
            {
               ATL_cplxmul(alph, alpha, B);
               Mjoin(PATL,axpby)(M, alph, A, 1, beta, C, 1);
               B += incBk;
               A += lda;
               for (k=1; k < K; k++, B += incBk, A += lda)
               {
                  ATL_cplxmul(alph, alpha, B);
                  Mjoin(PATL,axpy)(M, alph, A, 1, C, 1);
               }
               C += ldc;
               B += incBn;
               A -= incAn;
            }
         }
      }
   }
}

int Mjoin(PATL,mmJKI)(const enum ATLAS_TRANS TA, const enum ATLAS_TRANS TB, 
                      const int M, const int N, const int K, 
                      const SCALAR alpha, const TYPE *A, const int lda, 
                      const TYPE *B, const int ldb, const SCALAR beta, 
                      TYPE *C, const int ldc)
/*
 * This gemm is for small K, so we build gemm out of AXPY (outer product)
 * rather than dot (inner product).
 */
{
   int Mp, mp, m, k, ldaa=lda;
   void *vA=NULL;
   TYPE *pA;
   const TYPE CONE[2]={ATL_rone, ATL_rzero}, CNONE[2]={ATL_rnone, ATL_rzero};
   const SCALAR alp=alpha;

/*
 * Compute M partition necessary to promote reuse in the L1 cache.  Check
 * NB^2 in addition to L1elts, to catch machines where L1 is not used by FPU.
 * If this gives a small Mp, use CacheEdge instead (reuse in L2 instead of L1).
 */
   Mp = NB*NB;
   m = ATL_L1elts >> 1;
   Mp = (m > Mp) ? m : Mp;
   Mp /= ((K+2)<<1);
   if (Mp < 128)
   {
      #if !defined(CacheEdge) || CacheEdge == 0
         Mp = M;
      #else
         Mp = (CacheEdge) / ((K+2)*ATL_sizeof);
         if (Mp < 128)
            Mp = M;
      #endif
   }
   if (Mp > M)
      Mp = M;
/*
 * Change Mp if remainder is very small
 */
   else
   {
      Mp -= 16;      /* small safety margin on filling cache */
      mp = M / Mp;
      m = M - mp*Mp;
      if (m && m < 32)
         Mp += (m+mp-1)/mp;
   }
/*
 * If A not in NoTrans format, need to copy so it can use axpy wt stride=1.  
 * NOTE: this routine should not be called when you can't afford this copy
 */
   if (TA != AtlasNoTrans)
   {
      vA = malloc(ATL_Cachelen + Mp*ATL_MulBySize(K));
      if (!vA) return(-1);
      pA = ATL_AlignPtr(vA);
      alp = CONE;
      ldaa = Mp;
      pA += Mp+Mp;
   }
   else
      pA = (TYPE *) A;
   for (m=0; m < M; m += Mp)
   {
      mp = M - m;
      if (mp > Mp)
         mp = Mp;
/*
 *    If the thing is in Trans format, copy to NoTrans
 */
      if (vA)
      {
         pA -= (Mp+Mp);
         if (TA == AtlasConjTrans)
         {
            for (k=0; k < K; k++)
            {
               Mjoin(PATL,copy)(mp, A+k+k, lda, pA+((k*ldaa)<<1), 1);
               Mjoin(PATLU,scal)(mp, ATL_rnone, pA+1+((k*ldaa)<<1), 2);
               if (!SCALAR_IS_ONE(alpha))
                  Mjoin(PATL,scal)(mp, alpha, pA+((k*ldaa)<<1), 1);
            }
         }
         else
         {
            for (k=0; k < K; k++)
               Mjoin(PATL,cpsc)(mp, alpha, A+k+k, lda, pA+((k*ldaa)<<1), 1);
         }
         A += mp*(lda+lda);
      }
      Mjoin(PATL,mm_axpy)(AtlasNoTrans, TB, mp, N, K, alp, pA, ldaa, B, ldb, 
                          beta, C, ldc);
      pA += mp+mp;
      C += mp+mp;
   }
   if (vA) free(vA);
   return(0);
}
@ROUT ATL_cmmJIK
@extract -b @(topd)/gen.inc what=cw @(cw99)

#include "atlas_misc.h"
#include "atlas_lvl3.h"
#include <stdlib.h>

#define KBmm Mjoin(PATL,pKBmm)
#define IBNBmm Mjoin(PATL,IBNBmm)
#define NBJBmm Mjoin(PATL,MBJBmm)
#define IBJBmm Mjoin(PATL,IBJBmm)

void Mjoin(PATL,mmJIK2)
             (int K, int nMb, int nNb, int nKb, int ib, int jb, int kb, 
              const SCALAR alpha, const TYPE *pA0, const TYPE *B, int ldb, 
              TYPE *pB0, int incB, MAT2BLK B2blk, const SCALAR beta, 
              TYPE *C, int ldc, MATSCAL gescal, NBMM0 NBmm0)
{
   const int incK = ATL_MulByNB(K)SHIFT, incC = ATL_MulByNB(ldc-nMb) SHIFT;
   const int ZEROC = ((gescal == NULL) && SCALAR_IS_ZERO(beta));
   int i, j = nNb;
   const TYPE *pA=pA0;
   const TYPE rbeta = ( (gescal) ? ATL_rone : *beta );
   TYPE *pB=pB0, *stB=pB0+(ATL_MulByNBNB(nKb)SHIFT);

   if (nNb)
   {
      do  /* Loop over full column panels of B */
      {
         if (B)
         {
            B2blk(K, NB, B, ldb, pB, alpha);
            B += incB;
         }
         if (nMb)
         {
            i = nMb;
            do /* loop over full row panels of A */
            {
               if (gescal) gescal(NB, NB, beta, C, ldc);
               if (nKb) /* loop over full blocks in panels */
               {
                  NBmm0(MB, NB, KB, ATL_rone, pA, KB, pB, KB, rbeta, C, ldc);
                  pA += NBNB2;
                  pB += NBNB2;
                  if (nKb != 1)
                  {
                     do
                     {
                        NBmm_b1(MB, NB, KB, ATL_rone, pA, KB, pB, KB, ATL_rone, 
                                C, ldc);
                        pA += NBNB2;
                        pB += NBNB2;
                     }
                     while (pB != stB);
                  }
                  if (kb)
                  {
                     KBmm(MB, NB, kb, ATL_rone, pA, kb, pB, kb, ATL_rone, 
                          C, ldc);
                     pA += ATL_MulByNB(kb)<<1;
                  }
               }
               else if (kb)
               {
                  if (ZEROC) Mjoin(PATL,gezero)(MB, NB, C, ldc);
                  KBmm(MB, NB, kb, ATL_rone, pA, kb, pB, kb, rbeta, C, ldc);
                  pA += ATL_MulByNB(kb)<<1;
               }
               pB = pB0;
               C += NB2;
            }
            while (--i);
         }
         if (ib) 
         {
            if (gescal) gescal(ib, NB, beta, C, ldc);
            IBNBmm(ib, K, pA, pB, rbeta, C, ldc);
         }
         if (!B)
         {
            pB0 += incK;
            pB = pB0;
            stB += incK;
         }
         C += incC;
         pA = pA0;
      }
      while (--j);
   }
   if (jb)
   {
      if (B) B2blk(K, jb, B, ldb, pB, alpha);
      for (i=nMb; i; i--)
      {
         if (gescal) gescal(NB, jb, beta, C, ldc);
         NBJBmm(jb, K, pA, pB, rbeta, C, ldc);
         pA += incK;
         C += NB2;
      }
      if (ib)
      {
         if (gescal) gescal(ib, jb, beta, C, ldc);
         IBJBmm(ib, jb, K, pA, pB, rbeta, C, ldc);
      }
   }
}

int Mjoin(PATL,mmJIK)(const enum ATLAS_TRANS TA, const enum ATLAS_TRANS TB, 
                      const int M0, const int N, const int K, 
                      const SCALAR alpha, const TYPE *A, const int lda0, 
                      const TYPE *B, const int ldb0, const SCALAR beta, 
                      TYPE *C, const int ldc0)
/*
 * Outer three loops for matmul with outer loop over columns of B
 */
{
   int M = M0;
   int nMb, nNb, nKb, ib, jb, kb, ib2, h, i, j, k, m, n;
   const size_t lda=lda0, ldb=ldb0, ldc=ldc0;
   size_t incA, incB, incC;
   int AlphaIsOne;
   const size_t incK = ATL_MulByNB((size_t)K);
   void *vB=NULL, *vC=NULL;
   TYPE *pA, *pB, *pC;
   const TYPE one[2] = {1.0,0.0}, zero[2] = {0.0,0.0};
   MAT2BLK A2blk, B2blk;
   MATSCAL gescal;
   NBMM0 NBmm0;

   nMb = ATL_DivByNB(M);
   nNb = ATL_DivByNB(N);
   nKb = ATL_DivByNB(K);
   ib = M - ATL_MulByNB(nMb);
   jb = N - ATL_MulByNB(nNb);
   kb = K - ATL_MulByNB(nKb);

   pC = C;
   if (beta[1] == ATL_rzero)
   {
      gescal = NULL;
      if (*beta == ATL_rone) NBmm0 = Mjoin(PATL,CNBmm_b1);
      else if (*beta == ATL_rzero) NBmm0 = Mjoin(PATL,CNBmm_b0);
      else NBmm0 = Mjoin(PATL,CNBmm_bX);
   }
   else
   {
      NBmm0 = Mjoin(PATL,CNBmm_b1);
      gescal = Mjoin(PATL,gescal_bX);
   }
/*
 * Special case for when what we are really doing is 
 *    C <- beta*C + alpha * A * A'   or   C <- beta*C + alpha * A' * A
 */
   if ( A == B && M == N && TA != TB && (SCALAR_IS_ONE(alpha) || M <= NB)
        && TA != AtlasConjTrans && TB != AtlasConjTrans && lda == ldb )
   {
      AlphaIsOne = SCALAR_IS_ONE(alpha);
      i = ATL_MulBySize(M * K);
      if (!AlphaIsOne && pC == C && !SCALAR_IS_ZERO(beta)) 
         i += ATL_MulBySize(M*N);
      if (i <= ATL_MaxMalloc) vB = malloc(i + ATL_Cachelen);
      if (vB)
      {
         pA = ATL_AlignPtr(vB);
         if (TA == AtlasNoTrans)
            Mjoin(PATL,row2blkT2_a1)(M, K, A, lda, pA, alpha);
         else Mjoin(PATL,col2blk2_a1)(K, M, A, lda, pA, alpha);
/*
 *       Can't write directly to C if alpha is not one
 */
         if (!AlphaIsOne)
         {
            if (SCALAR_IS_ZERO(beta)) h = ldc;
            else if (pC == C)
            {
               pC = pA + (((size_t)M) * K SHIFT);
               h = M;
            }
            else h = NB;
            Mjoin(PATL,mmJIK2)(K, nMb, nNb, nKb, ib, jb, kb, one, pA, NULL, 
                               ldb, pA, 0, NULL, zero, pC, h, 
                               Mjoin(PATL,gescal_b0), Mjoin(PATL,CNBmm_b0));

            if (alpha[1] == ATL_rzero) 
               Mjoin(PATL,gescal_bXi0)(M, N, alpha, pC, h);
            else Mjoin(PATL,gescal_bX)(M, N, alpha, pC, h);

            if (C != pC)
            {
               if (beta[1] == ATL_rzero)
               {
                  if (*beta == ATL_rone) 
                     Mjoin(PATL,putblk_b1)(M, N, pC, C, ldc, beta);
                  else if (*beta == ATL_rnone)
                     Mjoin(PATL,putblk_bn1)(M, N, pC, C, ldc, beta);
                  else if (*beta == ATL_rzero)
                     Mjoin(PATL,putblk_b0)(M, N, pC, C, ldc, beta);
                  else Mjoin(PATL,putblk_bXi0)(M, N, pC, C, ldc, beta);
               }
               else Mjoin(PATL,putblk_bX)(M, N, pC, C, ldc, beta);
            }
         }
         else Mjoin(PATL,mmJIK2)(K, nMb, nNb, nKb, ib, jb, kb, alpha, pA, NULL, 
                                 ldb, pA, 0, NULL, beta, C, ldc, gescal, NBmm0);
         free(vB);
         if (vC) free(vC);
         return(0);
      }
   }
   i = ATL_Cachelen + ATL_MulBySize(M*K + incK);
   if (i <= ATL_MaxMalloc) vB = malloc(i);
   if (!vB)
   {
      if (TA != AtlasNoTrans && TB != AtlasNoTrans) return(1);
      if (ib) n = nMb + 1;
      else n = nMb;
      for (j=2; !vB; j++)
      {
         k = n / j;
         if (k < 1) break;
         if (k*j < n) k++;
         h = ATL_Cachelen + ATL_MulBySize((k+1)*incK);
         if (h <= ATL_MaxMalloc) vB = malloc(h);
      }
      if (!vB) return(-1);
      n = k;
      m = ATL_MulByNB(n);
      ib2 = 0;
   }
   else
   {
      n = nMb;
      m = M;
      ib2 = ib;
   }
   pB = ATL_AlignPtr(vB);
   if (TA == AtlasNoTrans)
   {
      incA = m SHIFT;
      if (alpha[1] == ATL_rzero)
      {
         if (*alpha == ATL_rone) A2blk = Mjoin(PATL,row2blkT2_a1);
         else A2blk = Mjoin(PATL,row2blkT2_aXi0);
      }
      else A2blk = Mjoin(PATL,row2blkT2_aX);
   }
   else if (TA == AtlasConjTrans)
   {
      incA = lda*m SHIFT;
      if (alpha[1] == ATL_rzero)
      {
         if (*alpha == ATL_rone) A2blk = Mjoin(PATL,col2blkConj2_a1);
         else A2blk = Mjoin(PATL,col2blkConj2_aXi0);
      }
      else A2blk = Mjoin(PATL,col2blkConj2_aX);
   }
   else
   {
      incA = lda*m SHIFT;
      if (alpha[1] == ATL_rzero)
      {
         if (*alpha == ATL_rone) A2blk = Mjoin(PATL,col2blk2_a1);
         else A2blk = Mjoin(PATL,col2blk2_aXi0);
      }
      else A2blk = Mjoin(PATL,col2blk2_aX);
   }
   if (TB == AtlasNoTrans)
   {
      incB = ATL_MulByNB(ldb) SHIFT;
      B2blk = Mjoin(PATL,col2blk_a1);
   }
   else if (TB == AtlasConjTrans)
   {
      incB = NB2;
      B2blk = Mjoin(PATL,row2blkC_a1);
   }
   else
   {
      incB = NB2;
      B2blk = Mjoin(PATL,row2blkT_a1);
   }
   incC = m SHIFT;

   pA = pB + (incK SHIFT);
   do
   {
      if (TA == AtlasNoTrans) A2blk(m, K, A, lda, pA, alpha);
      else A2blk(K, m, A, lda, pA, alpha);
      Mjoin(PATL,mmJIK2)(K, n, nNb, nKb, ib2, jb, kb, alpha, pA, B, ldb, pB,
                         incB, B2blk, beta, C, ldc, gescal, NBmm0);
      M -= m;
      nMb -= n;
      if (M <= m)
      {
         ib2 = ib;
         m = M;
         n = nMb;
      }
      C += incC;
      A += incA;
   }
   while (M);
   free(vB);
   if (vC) free(vC);
   return(0);
}
@ROUT ATL_cmmJIK_mixed
@extract -b @(topd)/gen.inc what=cw @(cw99)

#include "atlas_misc.h"
#include "atlas_lvl3.h"
#include <stdlib.h>

#define PATLC  Mjoin(ATL_c,PRE)
#define mmJIK Mjoin(Mjoin(ATL_c,PRE),mmJIK)
#define mmJIK2 Mjoin(Mjoin(ATL_c,PRE),mmJIK2)
#define CNBmm_b0 Mjoin(Mjoin(ATL_c,PRE),NBmm_b0)
#define CNBmm_b1 Mjoin(Mjoin(ATL_c,PRE),NBmm_b1)
#define CNBmm_bX Mjoin(Mjoin(ATL_c,PRE),NBmm_bX)
#define CKBmm Mjoin(Mjoin(ATL_c,PRE),KBmm)
#define IBNBmm Mjoin(Mjoin(ATL_c,PRE),IBNBmm)
#define NBJBmm Mjoin(Mjoin(ATL_c,PRE),MBJBmm)
#define IBJBmm Mjoin(Mjoin(ATL_c,PRE),IBJBmm)
#define putblk0 Mjoin(Mjoin(ATL_c,PRE),putblk)
#define row2blkT0 Mjoin(PATLC,row2blkT)
#define row2blkT20 Mjoin(PATLC,row2blkT2)
#define col2blk0 Mjoin(PATLC,col2blk)
#define col2blk20 Mjoin(PATLC,col2blk2)

void Mjoin(putblk0,_b0)(const int M, const int N, const TYPE *v, 
                        const TYPE *beta, TYPE *C, const int ldc);
void Mjoin(putblk0,_b1)(const int M, const int N, const TYPE *v, 
                        const TYPE *beta, TYPE *C, const int ldc);
void Mjoin(putblk0,_bn1)(const int M, const int N, const TYPE *v, 
                         const TYPE *beta, TYPE *C, const int ldc);
void Mjoin(putblk0,_bXi0)(const int M, const int N, const TYPE *v, 
                          const TYPE *beta, TYPE *C, const int ldc);
void Mjoin(putblk0,_bX)(const int M, const int N, const TYPE *v, 
                        const TYPE *beta, TYPE *C, const int ldc);

@whiledef an a1 aX aXi0 aXi0c a1c aXc
   @whiledef rout row2blkT row2blkT2 col2blk col2blk2
void Mjoin(@(rout)0,_@(an))(int, int, const TYPE*, int, TYPE*, const TYPE*);
   @endwhile
@endwhile

#ifndef NBmm_bn1
   #define NBmm_bn1 NBmm_bX
#endif

typedef void (*CRMAT2BLK)(int, int, const TYPE*, int, TYPE*, const TYPE*);

static void CKBmm(const int M, const int N, const int K, const TYPE alpha,
                  const TYPE *A, const int lda, const TYPE *B, const int ldb,
                  const TYPE beta, TYPE *C, const int ldc)
{
   const int inc = ATL_MulByNB(K);
   Mjoin(PATL,pKBmm)(MB, NB, K, ATL_rone, A, K, B, K, -beta, C, MB);
   Mjoin(PATL,pKBmm)(MB, NB, K, ATL_rone, A, K, B+inc, K, beta, C+NBNB, MB);
   Mjoin(PATL,pKBmm)(MB, NB, K, ATL_rone, A+inc, K, B+inc, K, ATL_rnone, C, MB);
   Mjoin(PATL,pKBmm)(MB, NB, K, ATL_rone, A+inc, K, B, K, ATL_rone, C+NBNB, MB);
}

static void CNBmm_b0(const int M, const int N, const int K, const TYPE alpha,
                     const TYPE *A, const int lda, const TYPE *B, const int ldb,
                     const TYPE beta, TYPE *C, const int ldc)
{
   NBmm_b0(MB, NB, KB, ATL_rone, A, KB, B, KB, ATL_rzero, C, MB);
   NBmm_b0(MB, NB, KB, ATL_rone, A, KB, B+NBNB, KB, ATL_rzero, C+NBNB, MB);
   NBmm_bn1(MB, NB, KB, ATL_rone, A+NBNB, KB, B+NBNB, KB, ATL_rnone, C, MB);
   NBmm_b1(MB, NB, KB, ATL_rone, A+NBNB, KB, B, KB, ATL_rone, C+NBNB, MB);
}

static void CNBmm_b1(const int M, const int N, const int K, const TYPE alpha,
                     const TYPE *A, const int lda, const TYPE *B, const int ldb,
                     const TYPE beta, TYPE *C, const int ldc)
{
   NBmm_bn1(MB, NB, KB, ATL_rone, A, KB, B, KB, ATL_rnone, C, MB);
   NBmm_b1(MB, NB, KB, ATL_rone, A, KB, B+NBNB, KB, ATL_rone, C+NBNB, MB);
   NBmm_bn1(MB, NB, KB, ATL_rone, A+NBNB, KB, B+NBNB, KB, ATL_rnone, C, MB);
   NBmm_b1(MB, NB, KB, ATL_rone, A+NBNB, KB, B, KB, ATL_rone, C+NBNB, MB);
}

static void CNBmm_bX(const int M, const int N, const int K, const TYPE alpha,
                     const TYPE *A, const int lda, const TYPE *B, const int ldb,
                     const TYPE beta, TYPE *C, const int ldc)
{
   NBmm_bX(MB, NB, KB, ATL_rone, A, KB, B, KB, -beta, C, MB);
   NBmm_bX(MB, NB, KB, ATL_rone, A, KB, B+NBNB, KB, beta, C+NBNB, MB);
   NBmm_bn1(MB, NB, KB, ATL_rone, A+NBNB, KB, B+NBNB, KB, ATL_rnone, C, MB);
   NBmm_b1(MB, NB, KB, ATL_rone, A+NBNB, KB, B, KB, ATL_rone, C+NBNB, MB);
}

static void NBJBmm(const int N, const int K, const TYPE *A, const TYPE *B,
                   TYPE *C, const int ldc)
{
   const int nKb = ATL_DivByNB(K);
   const int incB = ATL_MulByNB(N), incB2 = incB<<1, incC=ATL_MulByNB(N);
   int i, j;
   register int k;

   if (nKb)
   {
      Mjoin(PATL,pNBmm_b0)(MB, N, KB, ATL_rone, A, KB, B, KB, 
                           ATL_rzero, C, MB);
      Mjoin(PATL,pNBmm_b0)(MB, N, KB, ATL_rone, A, KB, B+incB, KB, 
                        ATL_rzero, C+incC, MB);
      Mjoin(PATL,pNBmm_bX)(MB, N, KB, ATL_rone, A+NBNB, KB, B+incB, KB, 
                           ATL_rnone, C, MB);
      Mjoin(PATL,pNBmm_b1)(MB, N, KB, ATL_rone, A+NBNB, KB, B, KB, 
                           ATL_rone, C+incC, MB);
      A += NBNB2;
      B += incB2;
      for (k=nKb-1; k; k--)
      {
         Mjoin(PATL,pNBmm_bX)(MB, N, KB, ATL_rone, A, KB, B, KB, 
                              ATL_rnone, C, MB);
         Mjoin(PATL,pNBmm_b1)(MB, N, KB, ATL_rone, A, KB, B+incB, KB, 
                              ATL_rone, C+incC, MB);
         Mjoin(PATL,pNBmm_bX)(MB, N, KB, ATL_rone, A+NBNB, KB, B+incB, KB, 
                              ATL_rnone, C, MB);
         Mjoin(PATL,pNBmm_b1)(MB, N, KB, ATL_rone, A+NBNB, KB, B, KB, 
                              ATL_rone, C+incC, MB);
         A += NBNB2;
         B += incB2;
      }
      if (k = K - ATL_MulByNB(nKb))
      {
         i = ATL_MulByNB(k);
         j = N*k;
         Mjoin(PATL,pKBmm)(MB, N, k, ATL_rone, A, k, B, k, ATL_rnone, C, MB);
         Mjoin(PATL,pKBmm)(MB, N, k, ATL_rone, A, k, B+j, k, 
                           ATL_rone, C+incC, MB);
         Mjoin(PATL,pKBmm)(MB, N, k, ATL_rone, A+i, k, B+j, k,
                           ATL_rnone, C, MB);
         Mjoin(PATL,pKBmm)(MB, N, k, ATL_rone, A+i, k, B, k, 
                           ATL_rone, C+incC, MB);
      }
   }
   else if (k = K - ATL_MulByNB(nKb))
   {
      i = ATL_MulByNB(k);
      j = N*k;
      Mjoin(PATL,pKBmm)(MB, N, k, ATL_rone, A, k, B, k, ATL_rzero, C, MB);
      Mjoin(PATL,pKBmm)(MB, N, k, ATL_rone, A, k, B+j, k, 
                        ATL_rzero, C+incC, MB);
      Mjoin(PATL,pKBmm)(MB, N, k, ATL_rone, A+i, k, B+j, k,
                        ATL_rnone, C, MB);
      Mjoin(PATL,pKBmm)(MB, N, k, ATL_rone, A+i, k, B, k, 
                        ATL_rone, C+incC, MB);
   }
}

static void IBNBmm(const int M, const int K, const TYPE *A, const TYPE *B,
                   TYPE *C, const int ldc)
{
   const int nKb = ATL_DivByNB(K);
   const int incA = ATL_MulByNB(M), incA2=incA<<1, incC=ATL_MulByNB(M);
   int i, j;
   register int k;

   if (nKb)
   {
      Mjoin(PATL,pMBmm_b0)(M, NB, KB, ATL_rone, A, KB, B, KB, ATL_rzero, C, M);
      Mjoin(PATL,pMBmm_b0)(M, NB, KB, ATL_rone, A, KB, B+NBNB, KB, 
                        ATL_rzero, C+incC, M);
      Mjoin(PATL,pMBmm_bX)(M, NB, KB, ATL_rone, A+incA, KB, B+NBNB, KB,
                           ATL_rnone, C, M);
      Mjoin(PATL,pMBmm_b1)(M, NB, KB, ATL_rone, A+incA, KB, B, KB, 
                           ATL_rone, C+incC, M);
      A += incA2;
      B += NBNB2;
      for (k=nKb-1; k; k--)
      {
         Mjoin(PATL,pMBmm_bX)(M, NB, KB, ATL_rone, A, KB, B, KB, 
                              ATL_rnone, C, M);
         Mjoin(PATL,pMBmm_b1)(M, NB, KB, ATL_rone, A, KB, B+NBNB, KB, 
                              ATL_rone, C+incC, M);
         Mjoin(PATL,pMBmm_bX)(M, NB, KB, ATL_rone, A+incA, KB, B+NBNB, KB,
                               ATL_rnone, C, M);
         Mjoin(PATL,pMBmm_b1)(M, NB, KB, ATL_rone, A+incA, KB, B, KB, 
                              ATL_rone, C+incC, M);
         A += incA2;
         B += NBNB2;
      }
      if (k = K - ATL_MulByNB(nKb)) 
      {
         i = M*k;
         j = ATL_MulByNB(k);
         Mjoin(PATL,pKBmm)(M, NB, k, ATL_rone, A, k, B, k, ATL_rnone, C, M);
         Mjoin(PATL,pKBmm)(M, NB, k, ATL_rone, A, k, B+j, k, 
                           ATL_rone, C+incC, M);
         Mjoin(PATL,pKBmm)(M, NB, k, ATL_rone, A+i, k, B+j, k,
                           ATL_rnone, C, M);
         Mjoin(PATL,pKBmm)(M, NB, k, ATL_rone, A+i, k, B, k, 
                           ATL_rone, C+incC, M);
      }
   }
   else if (k = K - ATL_MulByNB(nKb)) 
   {
      i = M*k;
      j = ATL_MulByNB(k);
      Mjoin(PATL,pKBmm)(M, NB, k, ATL_rone, A, k, B, k, ATL_rzero, C, M);
      Mjoin(PATL,pKBmm)(M, NB, k, ATL_rone, A, k, B+j, k, ATL_rzero, C+incC, M);
      Mjoin(PATL,pKBmm)(M, NB, k, ATL_rone, A+i, k, B+j, k, ATL_rnone, C, M);
      Mjoin(PATL,pKBmm)(M, NB, k, ATL_rone, A+i, k, B, k, ATL_rone, C+incC, M);
   }
}

void IBJBmm(int IB, int JB, int K, const TYPE *A, const TYPE *B,
            TYPE *C, const int ldc)
{
   const int nKb = ATL_DivByNB(K), incC = IB*JB; 
   const int incB = ATL_MulByNB(JB), incB2 = incB<<1;
   const int incA = ATL_MulByNB(IB), incA2 = incA<<1;
   int k, i, j;

   if (nKb)
   {
      Mjoin(PATL,pKBmm)(IB, JB, KB, ATL_rone, A, KB, B, KB, 
                        ATL_rzero, C, ldc);
      Mjoin(PATL,pKBmm)(IB, JB, KB, ATL_rone, A, KB, B+incB, KB, 
                        ATL_rzero, C+incC, ldc);
      Mjoin(PATL,pKBmm)(IB, JB, KB, ATL_rone, A+incA, KB, B+incB, KB, 
                        ATL_rnone, C, ldc);
      Mjoin(PATL,pKBmm)(IB, JB, KB, ATL_rone, A+incA, KB, B, KB, 
                        ATL_rone, C+incC, ldc);
      B += incB2;
      A += incA2;
      for (k=nKb-1; k; k--)
      {
         Mjoin(PATL,pKBmm)(IB, JB, KB, ATL_rone, A, KB, B, KB, 
                           ATL_rnone, C, ldc);
         Mjoin(PATL,pKBmm)(IB, JB, KB, ATL_rone, A, KB, B+incB, KB, 
                           ATL_rone, C+incC, ldc);
         Mjoin(PATL,pKBmm)(IB, JB, KB, ATL_rone, A+incA, KB, B+incB, KB, 
                           ATL_rnone, C, ldc);
         Mjoin(PATL,pKBmm)(IB, JB, KB, ATL_rone, A+incA, KB, B, KB, 
                           ATL_rone, C+incC, ldc);
         B += incB2;
         A += incA2;
      }
      if (k = K-ATL_MulByNB(nKb))
      {
         i = k * IB;
         j = k * JB;
         Mjoin(PATL,pKBmm)(IB, JB, k, ATL_rone, A, k, B, k, 
                           ATL_rnone, C, ldc);
         Mjoin(PATL,pKBmm)(IB, JB, k, ATL_rone, A, k, B+j, k, 
                           ATL_rone, C+incC, ldc);
         Mjoin(PATL,pKBmm)(IB, JB, k, ATL_rone, A+i, k, B+j, k, 
                           ATL_rnone, C, ldc);
         Mjoin(PATL,pKBmm)(IB, JB, k, ATL_rone, A+i, k, B, k, 
                           ATL_rone, C+incC, ldc);
      }
   }
   else if (k = K-ATL_MulByNB(nKb))
   {
      i = k * IB;
      j = k * JB;
      Mjoin(PATL,pKBmm)(IB, JB, k, ATL_rone, A, k, B, k, 
                        ATL_rzero, C, ldc);
      Mjoin(PATL,pKBmm)(IB, JB, k, ATL_rone, A, k, B+j, k, 
                        ATL_rzero, C+incC, ldc);
      Mjoin(PATL,pKBmm)(IB, JB, k, ATL_rone, A+i, k, B+j, k, 
                        ATL_rnone, C, ldc);
      Mjoin(PATL,pKBmm)(IB, JB, k, ATL_rone, A+i, k, B, k, 
                        ATL_rone, C+incC, ldc);
   }
}

void mmJIK2(int K, int nMb, int nNb, int nKb, int ib, int jb, int kb, 
             const TYPE *alpha, const TYPE *pA0, const TYPE *B, int ldb, 
             TYPE *pB0, int incB, CRMAT2BLK B2blk, const TYPE *beta, 
             TYPE *C, int ldc)
{
   const int incK = ATL_MulByNB(K)<<1, incC = ATL_MulByNB(ldc-nMb)<<1;
   int i, j = nNb;
   const TYPE *pA=pA0;
   const TYPE rbeta = *beta;
   TYPE *pB=pB0, *stB=pB0+(ATL_MulByNBNB(nKb)SHIFT);
   TYPE *pC = C;
   void *vC;
   void (*putblk)(const int M, const int N, const TYPE *v, 
                  const TYPE *beta, TYPE *C, const int ldc);

   vC = malloc(ATL_MulBySize(NBNB2) + ATL_Cachelen);
   ATL_assert(vC);
   pC = ATL_AlignPtr(vC);
   if (kb) Mjoin(PATL,gezero)(NB2, NB, pC, NB2);

   if (beta[1] == ATL_rzero)
   {
      if (rbeta == ATL_rone) putblk = Mjoin(putblk0,_b1);
      else if (rbeta == ATL_rzero) putblk = Mjoin(putblk0,_b0);
      else if (rbeta == ATL_rnone) putblk = Mjoin(putblk0,_bn1);
      else putblk = Mjoin(putblk0,_bXi0);
   }
   else putblk = Mjoin(putblk0,_bX);

   if (nNb)
   {
      do  /* Loop over full column panels of B */
      {
         if (B)
         {
            B2blk(K, NB, B, ldb, pB, alpha);
            B += incB;
         }
         if (nMb)
         {
            i = nMb;
            do /* loop over full row panels of A */
            {
               if (nKb) /* loop over full blocks in panels */
               {
                  CNBmm_b0(MB, NB, KB, ATL_rone, pA, KB, pB, KB, 
                           ATL_rzero, pC, MB);
                  pA += NBNB2;
                  pB += NBNB2;
                  if (nKb != 1)
                  {
                     do
                     {
                        CNBmm_b1(MB, NB, KB, ATL_rone, pA, KB, pB, KB, 
                                 ATL_rone, pC, MB);
                        pA += NBNB2;
                        pB += NBNB2;
                     }
                     while (pB != stB);
                  }
                  if (kb)
                  {
                     CKBmm(MB, NB, kb, ATL_rone, pA, kb, pB, kb,
                           ATL_rone, pC, MB);
                     pA += ATL_MulByNB(kb)<<1;
                  }
               }
               else if (kb)
               {
                  CKBmm(MB, NB, kb, ATL_rone, pA, kb, pB, kb, 
                        ATL_rzero, pC, MB);
                  pA += ATL_MulByNB(kb)<<1;
               }
               putblk(MB, NB, pC, beta, C, ldc);
               pB = pB0;
               C += NB2;
            }
            while (--i);
         }
         if (ib)
         {
            IBNBmm(ib, K, pA, pB, pC, ib);
            putblk(ib, NB, pC, beta, C, ldc);
         }
         if (!B)
         {
            pB0 += incK;
            pB = pB0;
            stB += incK;
         }
         C += incC;
         pA = pA0;
      }
      while (--j);
   }
   if (jb)
   {
      if (B) B2blk(K, jb, B, ldb, pB, alpha);
      for (i=nMb; i; i--)
      {
         NBJBmm(jb, K, pA, pB, pC, MB);
         putblk(MB, jb, pC, beta, C, ldc);
         pA += incK;
         C += NB2;
      }
      if (ib)
      {
         IBJBmm(ib, jb, K, pA, pB, pC, ib);
         putblk(ib, jb, pC, beta, C, ldc);
      }
   }
   free(vC);
}

int mmJIK(const enum ATLAS_TRANS TA, const enum ATLAS_TRANS TB, 
          const int M0, const int N, const int K, const TYPE *alpha, 
          const TYPE *A, const int lda0, const TYPE *B, const int ldb0,
          const TYPE *beta, TYPE *C, const int ldc0)
/*
 * Blocked matmul with JIK loop ordering
 */
{
   int M = M0;
   size_t incA, incB, incC;
   size_t lda=lda0, ldb=ldb0; ldc=ldc0;
   int nMb, nNb, nKb, ib, jb, kb, ib2, h, i, j, k, m, n;
   int AlphaIsOne;
   const int incK = ATL_MulByNB(K);
   void *vB=NULL, *vC=NULL;
   TYPE *pA, *pB, *pC;
   const TYPE one[2] = {1.0,0.0}, zero[2] = {0.0,0.0};
   CRMAT2BLK A2blk, B2blk;
   MATSCAL gescal;
   NBMM0 NBmm0;

   nMb = ATL_DivByNB(M);
   nNb = ATL_DivByNB(N);
   nKb = ATL_DivByNB(K);
   ib = M - ATL_MulByNB(nMb);
   jb = N - ATL_MulByNB(nNb);
   kb = K - ATL_MulByNB(nKb);

/*
 * Special case for when what we are really doing is 
 *    C <- beta*C + alpha * A * A'   or   C <- beta*C + alpha * A' * A
 */
#if 0
   if ( A == B && M == N && TA != TB && (SCALAR_IS_ONE(alpha) || M <= NB)
        && TA != AtlasConjTrans && TB != AtlasConjTrans && lda == ldb )
   {
      AlphaIsOne = SCALAR_IS_ONE(alpha);
      i = ATL_MulBySize(M * K);
      if (!AlphaIsOne && pC == C && !SCALAR_IS_ZERO(beta)) 
         i += ATL_MulBySize(M*N);
      if (i <= ATL_MaxMalloc) vB = malloc(i + ATL_Cachelen);
      if (vB)
      {
         pA = ATL_AlignPtr(vB);
         if (TA == AtlasNoTrans)
            Mjoin(PATL,row2blkT2_a1)(M, K, A, lda, pA, alpha);
         else Mjoin(PATL,col2blk_a1)(K, M, A, lda, pA, alpha);
/*
 *       Can't write directly to C if alpha is not one
 */
         if (!AlphaIsOne)
         {
            if (SCALAR_IS_ZERO(beta)) h = ldc;
            else if (pC == C)
            {
               pC = pA + (M * K SHIFT);
               h = M;
            }
            else h = NB;
            Mjoin(PATL,mmJIK2)(K, nMb, nNb, nKb, ib, jb, kb, one, pA, NULL, 
                                 ldb, pA, 0, NULL, zero, pC, h, 
                                 Mjoin(PATL,gescal_b0), pC,
                                 Mjoin(PATL,CNBmm_b0));

            if (alpha[1] == ATL_rzero) 
               Mjoin(PATL,gescal_bXi0)(M, N, alpha, pC, h);
            else Mjoin(PATL,gescal_bX)(M, N, alpha, pC, h);

            if (C != pC)
            {
               if (beta[1] == ATL_rzero)
               {
                  if (*beta == ATL_rone) 
                     Mjoin(PATL,putblk_b1)(M, N, pC, C, ldc, beta);
                  else if (*beta == ATL_rnone)
                     Mjoin(PATL,putblk_bn1)(M, N, pC, C, ldc, beta);
                  else if (*beta == ATL_rzero)
                     Mjoin(PATL,putblk_b0)(M, N, pC, C, ldc, beta);
                  else Mjoin(PATL,putblk_bXi0)(M, N, pC, C, ldc, beta);
               }
               else Mjoin(PATL,putblk_bX)(M, N, pC, C, ldc, beta);
            }
         }
         else
            Mjoin(PATL,mmJIK2)(K, nMb, nNb, nKb, ib, jb, kb, alpha, pA, NULL, 
                                 ldb, pA, 0, NULL, beta, C, ldc, gescal, 
                                 pC, NBmm0);
         free(vB);
         if (vC) free(vC);
         return(0);
      }
   }
#endif
   i = ATL_Cachelen + ((ATL_MulBySize(incK) + ATL_MulBySize(M*K))<<1);
   if (i <= ATL_MaxMalloc) vB = malloc(i);
   if (!vB)
   {
      if (TA != AtlasNoTrans && TB != AtlasNoTrans) return(1);
      if (ib) n = nMb + 1;
      else n = nMb;
      for (j=2; !vB; j++)
      {
         k = n / j;
         if (k < 1) break;
         if (k*j < n) k++;
         h = ATL_Cachelen + ATL_MulBySize(incK)*((k+1)<<1);
         if (h <= ATL_MaxMalloc) vB = malloc(h);
      }
      if (!vB) return(-1);
      n = k;
      m = ATL_MulByNB(n);
      ib2 = 0;
   }
   else
   {
      n = nMb;
      m = M;
      ib2 = ib;
   }
   pB = ATL_AlignPtr(vB);
   if (TA == AtlasNoTrans)
   {
      incA = m<<1;
      if (alpha[1] == ATL_rzero)
      {
         if (*alpha == ATL_rone) A2blk = Mjoin(row2blkT20,_a1);
         else A2blk = Mjoin(row2blkT20,_aXi0);
      }
      else A2blk = Mjoin(row2blkT20,_aX);
   }
   else if (TA == AtlasConjTrans)
   {
      incA = lda*(m<<1);
      if (alpha[1] == ATL_rzero)
      {
         if (*alpha == ATL_rone) A2blk = Mjoin(col2blk20,_a1c);
         else A2blk = Mjoin(col2blk20,_aXi0c);
      }
      else A2blk = Mjoin(col2blk20,_aXc);
   }
   else
   {
      incA = lda*m << 1;
      if (alpha[1] == ATL_rzero)
      {
         if (*alpha == ATL_rone) A2blk = Mjoin(col2blk20,_a1);
         else A2blk = Mjoin(col2blk20,_aXi0);
      }
      else A2blk = Mjoin(col2blk20,_aX);
   }
   if (TB == AtlasNoTrans)
   {
      incB = ATL_MulByNB(ldb)<<1;
      B2blk = Mjoin(col2blk0,_a1);
   }
   else if (TB == AtlasConjTrans)
   {
      incB = NB2;
      B2blk = Mjoin(row2blkT0,_a1c);
   }
   else
   {
      incB = NB2;
      B2blk = Mjoin(row2blkT0,_a1);
   }
   incC = m<<1;

   pA = pB + (incK<<1);
   do
   {
      if (TA == AtlasNoTrans) A2blk(m, K, A, lda, pA, alpha);
      else A2blk(K, m, A, lda, pA, alpha);
      mmJIK2(K, n, nNb, nKb, ib2, jb, kb, alpha, pA, B, ldb, pB, incB, B2blk, 
             beta, C, ldc);
      M -= m;
      nMb -= n;
      if (M <= m)
      {
         ib2 = ib;
         m = M;
         n = nMb;
      }
      C += incC;
      A += incA;
   }
   while (M);
   free(vB);
   if (vC) free(vC);
   return(0);
}
@ROUT ATL_mmIJK
@extract -b @(topd)/gen.inc what=cw

#include "atlas_misc.h"
#include "atlas_lvl3.h"

#define KBmm Mjoin(PATL,pKBmm)
#define IBNBmm Mjoin(PATL,IBNBmm)
#define NBJBmm Mjoin(PATL,MBJBmm)
#define IBJBmm Mjoin(PATL,IBJBmm)
#define col2blk Mjoin(PATL,col2blk_a1)

void Mjoin(PATL,mmIJK2)(int K, int nMb, int nNb, int nKb, int ib, int jb,
                        int kb, const SCALAR alpha, const TYPE *A, int lda,
                        TYPE *pA0, int incA, MAT2BLK A2blk, const TYPE *pB0,
                        const SCALAR beta, TYPE *C, int ldc, TYPE *pC, 
                        PUTBLK putblk, NBMM0 NBmm0)
/*
 * Outer three loops for matmul with outer loop over rows of A
 */
{
   int i, j, ldpc;
   const int ZEROC = ((putblk == NULL) && SCALAR_IS_ZERO(beta));
   const int incK = ATL_MulByNB(K), incC = ATL_MulByNB(ldc);
   TYPE *pA=pA0, *stA=pA0+ATL_MulByNBNB(nKb);
   const TYPE *pB=pB0;
   const TYPE cubeta = ( (putblk) ? ATL_rzero : beta );
   TYPE *c;

   if (putblk)
   {
      ldpc = NB;
      if (!nKb && kb) Mjoin(PATL,gezero)(MB, NB, pC, MB);
   }
   else ldpc = ldc;
   for (i=nMb; i; i--)    /* loop over full row panels of A */
   {
      if (A)
      {
         A2blk(K, NB, A, lda, pA, alpha);  /* get 1 row panel of A */
         A += incA;
      }
      if (!putblk) pC = C;
      c = C;
      C += NB;
      for (j=nNb; j; j--)  /* full column panels of B */
      {
         if (nKb)
         {
            NBmm0(MB, NB, KB, ATL_rone, pA, KB, pB, KB, beta, pC, ldpc);
            pA += NBNB;
            pB += NBNB;
            if (nKb != 1)
            {
               do
               {
                  NBmm(MB, NB, KB, ATL_rone, pA, KB, pB, KB, ATL_rone, 
                       pC, ldpc);
                  pA += NBNB;
                  pB += NBNB;
               }
               while (pA != stA);
            }
            if (kb)
            {
               KBmm(MB, NB, kb, ATL_rone, pA, kb, pB, kb, ATL_rone, pC, ldpc);
               pB += kb*NB;
            }
         }
         else
         {
            if (ZEROC) Mjoin(PATL,gezero)(MB, NB, pC, ldpc);
            if (kb)
            {
               KBmm(MB, NB, kb, ATL_rone, pA, kb, pB, kb, cubeta, pC, ldpc);
               pB += kb*NB;
            }
         }
         pA = pA0;
         if (putblk) putblk(NB, NB, pC, c, ldc, beta);
         else pC += incC;
         c += incC;
      }
      if (jb)
      {
         NBJBmm(jb, K, pA, pB, cubeta, pC, ldpc);
         if (putblk) putblk(NB, jb, pC, c, ldc, beta);
      }
      pB = pB0;
      if (!A)
      {
         pA0 += incK;
         pA = pA0;
         stA += incK;
      }
   }
   if (ib)
   {
      c = C;
      if (A) A2blk(K, ib, A, lda, pA, alpha);  /* get last row panel of A */
      for (j=nNb; j; j--)  /* full column panels of B */
      {
         if (putblk)
         {
            IBNBmm(ib, K, pA, pB, ATL_rzero, pC, ib);
            putblk(ib, NB, pC, c, ldc, beta);
         }
         else IBNBmm(ib, K, pA, pB, beta, c, ldc);
         pB += incK;
         c += incC;
      }
      if (jb)
      {
         if (putblk)
         {
            IBJBmm(ib, jb, K, pA, pB, ATL_rzero, pC, ib);
            putblk(ib, jb, pC, c, ldc, beta);
         }
         else IBJBmm(ib, jb, K, pA, pB, beta, c, ldc);
      }
   }
}

@beginskip
int Mjoin(PATL,mmIJK)(const enum ATLAS_TRANS TA, const enum ATLAS_TRANS TB, 
                      const int M, const int N, const int K, 
                      const SCALAR alpha, const TYPE *A, const int lda,
                      const TYPE *B, const int ldb, const SCALAR beta, 
                      TYPE *C, const int ldc)
{
   int nMb, nNb, nKb, ib, jb, kb, h, i, j, k, incA;
   const int incK = ATL_MulByNB(K);
   void *vA=NULL, *vC=NULL;
   TYPE *pA, *pB, *pC;
   MAT2BLK A2blk;
   PUTBLK putblk;
   NBMM0 NBmm0;

   nMb = ATL_DivByNB(M);
   nNb = ATL_DivByNB(N);
   nKb = ATL_DivByNB(K);
   ib = M - ATL_MulByNB(nMb);
   jb = N - ATL_MulByNB(nNb);
   kb = K - ATL_MulByNB(nKb);

/*
 * If K sufficiently large, write to temporary C as safety measure;  otherwise
 * write directly to C
 */
   if (nKb < 12)
   {
      putblk = NULL;
      pC = C;
      if ( SCALAR_IS_ONE(beta) ) NBmm0 = NBmm_b1;
      else if ( SCALAR_IS_ZERO(beta) ) NBmm0 = NBmm_b0;
      else NBmm0 = NBmm_bX;
   }
   else
   {
      NBmm0 = NBmm_b0;
      vC = malloc(ATL_Cachelen + ATL_MulBySize(NBNB));
      if (!vC) return(-1);
      pC = ATL_AlignPtr(vC);
      if ( SCALAR_IS_ONE(beta) ) putblk = Mjoin(PATL,putblk_b1);
      else if ( SCALAR_IS_ZERO(beta) ) putblk = Mjoin(PATL,putblk_b0);
      else if ( SCALAR_IS_NONE(beta) ) putblk = Mjoin(PATL,putblk_bn1);
      else putblk = Mjoin(PATL,putblk_bX);
   }
@beginskip
@skip REMOVED THIS SPECIAL CASE BECAUSE IT CAN CAUSE SLOWDOWN UNPREDICTABLY,
@skip AS DISCOVERED BY TONY ON OPT8 on 08/09/08
/*
 * Special case if we don't need to copy one or more input matrix
 */
   if (K == NB && TB == AtlasNoTrans && ldb == NB && ATL_DataIsMinAligned(B))
   {
      if (lda == NB && TA == AtlasTrans && SCALAR_IS_ONE(alpha) && 
          ATL_DataIsMinAligned(A))
      {
         i = NBNB;
         pA = (TYPE *) A;
         A = NULL;
         A2blk = NULL;
         incA = 0;
      }
      else
      {
         vA = malloc(ATL_Cachelen + ATL_MulBySize(incK));
         if (!vA)
         {
            free(vC);
            return(-1);
         }
         pA = ATL_AlignPtr(vA);
         if (TA == AtlasNoTrans)
         {
            incA = NB;
            if ( SCALAR_IS_ONE(alpha) ) A2blk = Mjoin(PATL,row2blkT_a1);
            else A2blk = Mjoin(PATL,row2blkT_aX);
         }
         else
         {
            incA = ATL_MulByNB(lda);
            if ( SCALAR_IS_ONE(alpha) ) A2blk = Mjoin(PATL,col2blk_a1);
            else A2blk = Mjoin(PATL,col2blk_aX);
         }
      }
      Mjoin(PATL,mmIJK2)(K, nMb, nNb, nKb, ib, jb, kb, alpha, A, lda, pA, 
                          incA, A2blk, B, beta, C, ldc, pC, putblk, NBmm0);
      if (vA) free(vA);
      if (vC) free(vC);
      return(0);
   }
@endskip
   i = ATL_Cachelen + ATL_MulBySize(N*K + incK);
   if (i <= ATL_MaxMalloc || K <= KB) vA = malloc(i);
/*
 * If we can't fit in workspace, chop K until we can
 */
   if (!vA)
   {
      if (vC) free(vC);
      if (TA == AtlasNoTrans && TB == AtlasNoTrans) return(1);
      if (nKb < 2) return(-1);
      k = ATL_MulByNB(nKb>>1);
      h = K - k;
      if ( Mjoin(PATL,mmIJK)(TA, TB, M, N, k, alpha, A, lda, B, ldb,
                             beta, C, ldc) ) return(-2);

      A += ( TA==AtlasNoTrans ? k*lda : k );
      B += ( TB==AtlasNoTrans ? k : k*ldb );

      if ( Mjoin(PATL,mmIJK)(TA, TB, M, N, h, alpha, A, lda, B, ldb,
                             ATL_rone, C, ldc) )
      {
         if ( Mjoin(PATL,mmJIK)(TA, TB, M, N, h, alpha, A, lda, B, ldb,
                                ATL_rone, C, ldc) )
         {
            ATL_assert( Mjoin(PATL,NCmmIJK)(TA, TB, M, N, h, alpha, A, lda,
                                            B, ldb, ATL_rone, C, ldc) == 0 );
         }
      }
      return(0);
   }

   pA = ATL_AlignPtr(vA);
   pB = pA + incK;
   if (TB == AtlasNoTrans)
   {
      if ( SCALAR_IS_ONE(alpha) )
         Mjoin(PATL,col2blk2_a1)(K, N, B, ldb, pB, alpha);
      else Mjoin(PATL,col2blk2_aX)(K, N, B, ldb, pB, alpha);
   }
   else
   {
      if ( SCALAR_IS_ONE(alpha) )
         Mjoin(PATL,row2blkT2_a1)(N, K, B, ldb, pB, alpha);
      else Mjoin(PATL,row2blkT2_aX)(N, K, B, ldb, pB, alpha);
   }
   if (TA == AtlasNoTrans)
   {
      incA = NB;
      A2blk = Mjoin(PATL,row2blkT_a1);
   }
   else
   {
      incA = ATL_MulByNB(lda);
      A2blk = Mjoin(PATL,col2blk_a1);
   }

   Mjoin(PATL,mmIJK2)(K, nMb, nNb, nKb, ib, jb, kb, alpha, A, lda, pA,
                      incA, A2blk, pB, beta, C, ldc, pC, putblk, NBmm0);

   if (vC) free(vC);
   free(vA);
   return(0);
}
@endskip
int Mjoin(PATL,mmIJK)(const enum ATLAS_TRANS TA, const enum ATLAS_TRANS TB, 
                      const int M, const int N0, const int K, 
                      const SCALAR alpha, const TYPE *A, const int lda0,
                      const TYPE *B, const int ldb0, const SCALAR beta, 
                      TYPE *C, const int ldc0)
{
   size_t incA, incB, incC;
   const size_t lda=lda0, ldb=ldb0, ldc=ldc0;
   const size_t incK = ATL_MulByNB((size_t)K);
   int N = N0;
   int nMb, nNb, nKb, ib, jb, kb, jb2, h, i, j, k, n;
   void *vA=NULL, *vC=NULL;
   TYPE *pA, *pB, *pC;
   MAT2BLK A2blk, B2blk;
   PUTBLK putblk;
   NBMM0 NBmm0;

   nMb = ATL_DivByNB(M);
   nNb = ATL_DivByNB(N);
   nKb = ATL_DivByNB(K);
   ib = M - ATL_MulByNB(nMb);
   jb = N - ATL_MulByNB(nNb);
   kb = K - ATL_MulByNB(nKb);

/*
 * If K sufficiently large, write to temporary C as safety measure;  otherwise
 * write directly to C
 */
   if (nKb < 12)
   {
      putblk = NULL;
      pC = C;
      if ( SCALAR_IS_ONE(beta) ) NBmm0 = NBmm_b1;
      else if ( SCALAR_IS_ZERO(beta) ) NBmm0 = NBmm_b0;
      else NBmm0 = NBmm_bX;
   }
   else
   {
      NBmm0 = NBmm_b0;
      vC = malloc(ATL_Cachelen + ATL_MulBySize(NBNB));
      if (!vC) return(-1);
      pC = ATL_AlignPtr(vC);
      if ( SCALAR_IS_ONE(beta) ) putblk = Mjoin(PATL,putblk_b1);
      else if ( SCALAR_IS_ZERO(beta) ) putblk = Mjoin(PATL,putblk_b0);
      else if ( SCALAR_IS_NONE(beta) ) putblk = Mjoin(PATL,putblk_bn1);
      else putblk = Mjoin(PATL,putblk_bX);
   }
/*
 * Special case if we don't need to copy one or more input matrix
 */
   if (K == NB && TB == AtlasNoTrans && ldb == NB && ATL_DataIsMinAligned(B))
   {
      if (lda == NB && TA == AtlasTrans && SCALAR_IS_ONE(alpha) && 
          ATL_DataIsMinAligned(A))
      {
         i = NBNB;
         pA = (TYPE *) A;
         A = NULL;
         A2blk = NULL;
         incA = 0;
      }
      else
      {
         vA = malloc(ATL_Cachelen + ATL_MulBySize(incK));
         if (!vA)
         {
            free(vC);
            return(-1);
         }
         pA = ATL_AlignPtr(vA);
         if (TA == AtlasNoTrans)
         {
            incA = NB;
            if ( SCALAR_IS_ONE(alpha) ) A2blk = Mjoin(PATL,row2blkT_a1);
            else A2blk = Mjoin(PATL,row2blkT_aX);
         }
         else
         {
            incA = ATL_MulByNB(lda);
            if ( SCALAR_IS_ONE(alpha) ) A2blk = Mjoin(PATL,col2blk_a1);
            else A2blk = Mjoin(PATL,col2blk_aX);
         }
      }
      Mjoin(PATL,mmIJK2)(K, nMb, nNb, nKb, ib, jb, kb, alpha, A, lda, pA, 
                          incA, A2blk, B, beta, C, ldc, pC, putblk, NBmm0);
      if (vA) free(vA);
      if (vC) free(vC);
      return(0);
   }
   i = ATL_Cachelen + ATL_MulBySize(N*K + incK);
   if (i <= ATL_MaxMalloc) vA = malloc(i);
   if (!vA)
   {
      if (TA == AtlasNoTrans && TB == AtlasNoTrans)
      {
         if (vC) free(vC);
         return(1);
      }
      if (jb) n = nNb + 1;
      else n = nNb;
      for (j=2; !vA; j++)
      {
         k = n / j;
         if (k < 1) break;
         if (k*j < n) k++;
         h = ATL_Cachelen + ATL_MulBySize((k+1)*incK);
         if (h <= ATL_MaxMalloc) vA = malloc(h);
      }
      if (!vA)
      {
         if (vC) free(vC);
         return(-1);
      }
      n = ATL_MulByNB(k);
      jb2 = 0;
   }
   else
   {
      jb2 = jb;
      k = nNb;
      n = N;
   }
   pA = ATL_AlignPtr(vA);
   if (TB == AtlasNoTrans)
   {
      incB = ldb*n;
      if ( SCALAR_IS_ONE(alpha) ) B2blk = Mjoin(PATL,col2blk2_a1);
      else B2blk = Mjoin(PATL,col2blk2_aX);
   }
   else
   {
      incB = n;
      if ( SCALAR_IS_ONE(alpha) ) B2blk = Mjoin(PATL,row2blkT2_a1);
      else B2blk = Mjoin(PATL,row2blkT2_aX);
   }
   if (TA == AtlasNoTrans)
   {
      incA = NB;
      A2blk = Mjoin(PATL,row2blkT_a1);
   }
   else
   {
      incA = ATL_MulByNB(lda);
      A2blk = Mjoin(PATL,col2blk_a1);
   }
   incC = ldc*n;
   pB = pA + incK;

   do
   {
      if (TB == AtlasNoTrans) B2blk(K, n, B, ldb, pB, alpha);
      else B2blk(n, K, B, ldb, pB, alpha);
      Mjoin(PATL,mmIJK2)(K, nMb, k, nKb, ib, jb2, kb, alpha, A, lda, pA,
                          incA, A2blk, pB, beta, C, ldc, pC, putblk, NBmm0);
      N -= n;
      nNb -= k;
      if (N < n)
      {
         jb2 = jb;
         n = N;
         k = nNb;
      }
      C += incC;
      B += incB;
      if (!putblk) pC = C;
   }
   while (N);

   if (vC) free(vC);
   free(vA);
   return(0);
}
@ROUT ATL_xerbla
@extract -b @(topd)/gen.inc what=cw
#include <stdio.h>
#include <stdarg.h>
#include "atlas_misc.h"
void ATL_xerbla(int p, char *rout, char *form, ...)
{
   va_list argptr;

   va_start(argptr, form);
#ifdef GCCWIN
   if (p) printf("Parameter %d to routine %s was incorrect\n", p, rout);
   vprintf(form, argptr);
#else
   if (p)
      fprintf(stderr, "Parameter %d to routine %s was incorrect\n", p, rout);
   vfprintf(stderr, form, argptr);
#endif
   va_end(argptr);
   exit(-1);
}
@ROUT ptgemm
#include "atlas_misc.h"
#include "atlas_lvl3.h"

#define F77gemm Mjoin(PRE,gemm)
#define Cmatadd Mjoin(Mjoin(ATL_Cpt,PRE),matadd)
#define Cptgemm2 Mjoin(Mjoin(ATL_Cpt,PRE),gemm2)
#define Cptgemm Mjoin(Mjoin(ATL_Cpt,PRE),gemm)
#define Cgemm Mjoin(Mjoin(ATL_C,PRE),gemm)

struct t_MaT T_MAT;
struct t_MaT
{
   ATLAS_TRANS TA, TB;
   int m, n, k, lda, ldb, ldc;
   const void *A, *B;
   void *C;
   const SCALAR alpha;
   const SCALAR beta;
};

Cmatadd(int M, int N, const TYPE *A, TYPE *C, int ldc)
/*
 * C += A;  I should generate and thread this, but I'm not going to bother
 * right now, since the code should only rarely partition along K.
 */
{
   const *stA = A + M, *st=A+M*N;;
   ldc -= M;
#ifdef TCPLX
   ldc <<= 1;
   M <<= 1;
#endif

   do
   {
      do
      {
         *C++ += *A++;
      }
      while(A != stA);
      stA += M;
      C += ldc;
   }
   while (A != st);
}

Cptgemm2(void *ptr)
{
   T_MAT *mp=ptr;
   Mjoin(CPAT,gemm)(mp->TA, mp->TB, mp->m, mp->n, mp->k, mp->alpha, mp->A, 
                    mp->lda, mp->B, mp->ldb, mp->beta, mp->C, mp->ldc);
}

void Cptgemm(const enum ATLAS_TRANS TA, const enum ATLAS_TRANS TB, int M, int N,
             int K, const SCALAR alpha, const TYPE *A, int lda, const TYPE *B,
             int ldb, const SCALAR beta, TYPE *C, int ldc)
{
   int i, nblock, nblock1, neb, np = ATL_MAXPROC, Np;
   enum {PartN, PartM, PartK, NoPart} part=NoPart; /* what dim to partition */
#if TREAL
   const TYPE Zero = 0.0;;
#else
   const TYPE Zero[2] = {0.0, 0.0};
#endif
   static int nb=0;
   static pthread_t tp[ATL_MAXPROC];
   static pthread_attr_t attr;
   static T_MAT MAT[ATL_MAXPROC];

   if (!nb) nb = Mjoin(PATL, GetNB)();
   i = nb * np;
   if (N >= i) part = PartN;
   else if (M >= i) part = PartM;
   else if (K >= i) part = PartK;
   if (NoPart) /* no dimension will go over procs */
   {
      if (M > N)
      {
         part = PartM;
         Np = M / nb;
      }
      else
      {
         part = PartN;
         Np = N / nb;
      }
      if (Np < 2) part = NoPart;
   }
   if (part == PartN);
   {
      nblock = N / nb;
      nblock1 = nblock / Np;
      neb = nblock - nblock1*Np;
      for (i=0; i != Np; i++)
      {
         if (i < neb) k = MAT[i].n = (nblock1+1)*nb;
         else if (i == neb) k = MAT[i].n = N - nblock*nb + nblock1*nb;
         else k = MAT[i].n = nblock1*nb;
         MAT[i].TA = TA;        MAT[i].TB = TB;
         MAT[i].m = M;                              MAT[i].k = K;
         MAT[i].lda = lda;      MAT[i].ldb = ldb;   MAT[i].ldc = ldc;
         MAT[i].A = A;          MAT[i].B = B;       MAT[i].C = C;
         MAT[i].alpha = alpha;  MAT[i].beta = beta;
         if (TB == AtlasNoTrans) B += k * ldb;
         else B += k;
         C += k * ldc;
      }
   }
   else if (part == PartM)
   {
      nblock = M / nb;
      nblock1 = nblock / Np;
      neb = nblock - nblock1*Np;
      for (i=0; i != Np; i++)
      {
         if (i < neb) k = MAT[i].m = (nblock1+1)*nb;
         else if (i == neb) k = MAT[i].m = M - nblock*nb + nblock1*nb;
         else k = MAT[i].m = nblock1*nb;
         MAT[i].TA = TA;        MAT[i].TB = TB;
                                MAT[i].n = N;       MAT[i].k = K;
         MAT[i].lda = lda;      MAT[i].ldb = ldb;   MAT[i].ldc = ldc;
         MAT[i].A = A;          MAT[i].B = B;       MAT[i].C = C;
         MAT[i].alpha = alpha;  MAT[i].beta = beta;
         if (TA == AtlasNoTrans) A += k;
         else A += k * lda;
         C += k;
      }
   }
   else if (part == PartK)
   {
      nblock = K / nb;
      nblock1 = nblock / Np;
      neb = nblock - nblock1*Np;
      MAT[Np].ldc = ldc;
      MAT[Np].C = C;
      MAT[Np].beta = beta;
      for (i=0; i != Np; i++)
      {
         if (i < neb) k = MAT[i].k = (nblock1+1)*nb;
         else if (i == neb) k = MAT[i].k = N - nblock*nb + nblock1*nb;
         else k = MAT[i].k = nblock1*nb;
         MAT[i].TA = TA;        MAT[i].TB = TB;
         MAT[i].m = M;          MAT[i].n = N;
         MAT[i].lda = lda;      MAT[i].ldb = ldb;
         MAT[i].A = A;          MAT[i].B = B;
         MAT[i].alpha = alpha;
         if (i != Np)
         {
            MAT[i].C = malloc(ATL_MulBySize(M*N));
            assert(MAT[i].C != NULL);
            MAT[i].beta = Zero;
            MAT[i].ldc = M;
         }
         if (TA == AtlasNotrans) A += k * lda;
         else A += k;
         if (TB == AtlasNotrans) B += k;
         else B += k * ldb;
      }
   }
   else  /* No dimension big enough, just call one-processor code */
   {
      Cgemm(TA, TB, M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
      return;
   }
   Np--;
   for (i=0; i != Np; i++) pthread_create(&tp[i], &attr, Cptgemm2, &MAT[i]);
   Cptgemm2(&MAT[Np]);
   if (part = partK)
   {
      for (i=0; i != Np; i++)
      {
         pthread_join(tp[i], NULL);
         Cmatadd(M, N, MAT[i].C, C, ldc);
      }
   }
   else for (i=0; i != Np; i++) pthread_join(tp[i], NULL);
}
#undef Cgemm
#define Cgemm Cptgemm
#include "atlas_f77gemm.h"
@ROUT ATL_mm_tMK
@extract -b @(topd)/gen.inc what=cw

#include "atlas_misc.h"
#include "atlas_lvl3.h"
#include "atlas_cacheedge.h"

#ifndef L1CacheSize
   #define L1CacheSize 8192
#endif

int Mjoin(PATL,mm_tMK)(const enum ATLAS_TRANS TA, const enum ATLAS_TRANS TB, 
                       const int M, const int N, const int K, 
                       const SCALAR alpha, const TYPE *A, const int lda,
                       const TYPE *B, const int ldb, const SCALAR beta, 
                       TYPE *C, const int ldc)
/*
 * Special code for when M & K <= NB; no reuse of panels, so need to promote
 * internal reuse within either L1 or CacheEdge (typically L2)
 * If C & B are same matrix, we can use aX code to handle a=0.0, since we
 * know the matrix is initialized.
 */
{
   const int nNb = ATL_DivByNB(N);
   const int incpB=ATL_MulByNB(K), incC = ATL_MulByNB(ldc);
   int incB, Np0, Np, Npb, CS, J, j;
   void *vA=NULL, *vB=NULL;
   TYPE *b, *pB, *pA;
   MATSCAL gescal;
   NBMM0 NBmm0;
   MAT2BLK copyB;

   ATL_assert(M <= NB && K <= NB);
   CS = ATL_DivBySize(L1CacheSize);
   if (ldc == ldb && C == B && M == K && TB == AtlasNoTrans)
      Npb = ATL_DivByNB((CS - M*K) / (2*K));
   else Npb = ATL_DivByNB((CS - M*K) / (2*K+M));
   if (Npb == 0)  /* if it won't fit in L1, try in CacheEdge */
   {
      #ifndef CacheEdge
         Npb = ATL_DivByNB(1000);
      #elif CacheEdge == 0
         Npb = ATL_DivByNB(1000);
      #else
         CS = ATL_DivBySize(CacheEdge);
         if (ldc == ldb && C == B && M == K && TB == AtlasNoTrans)
            Npb = ATL_DivByNB((CS - M*K) / (2*K));
         else Npb = ATL_DivByNB((CS - M*K) / (2*K+M));
         if (!Npb) Npb = 1;
      #endif
   }
   if (Npb > nNb) Npb = nNb;
   Np = ATL_MulByNB(Npb);

   if (K == lda && TA == AtlasTrans && alpha == ATL_rone) pA = (TYPE *) A;
   else
   {
      vA = malloc(ATL_MulBySize(M*K) + ATL_Cachelen);
      if (!vA) return(-1);
      pA = ATL_AlignPtr(vA);
      if (TA == AtlasNoTrans) 
      {
         if (alpha == ATL_rone) 
            Mjoin(PATL,row2blkT_a1)(K, M, A, lda, pA, alpha);
         else Mjoin(PATL,row2blkT_aX)(K, M, A, lda, pA, alpha);
      }
      else
      {
         if (alpha == ATL_rone) Mjoin(PATL,col2blk_a1)(K, M, A, lda, pA, alpha);
         else Mjoin(PATL,col2blk_aX)(K, M, A, lda, pA, alpha);
      }
   }

   if (ldb == K && TB == AtlasNoTrans)
   {
      pB = (TYPE *) B;
      copyB = NULL;
      incB = Np * ldb;
   }
   else
   {
      vB = malloc(ATL_MulBySize(K*Np) + ATL_Cachelen);
      while (!vB && Np)
      {
         Npb--; Np -= NB;
         if (Np) vB = malloc(ATL_MulBySize(K*Np) + ATL_Cachelen);
      }
      if (!vB) return(-1);
      pB = ATL_AlignPtr(vB);
      if (TB == AtlasNoTrans)
      {
         copyB = Mjoin(PATL,col2blk_a1);
         incB = Np * ldb;
      }
      else
      {
         copyB = Mjoin(PATL,row2blkT_a1);
         incB = Np;
      }
   }

   if (K == NB)
   {
      gescal = NULL;
      if (M == NB)
      {
         if (beta == ATL_rzero) NBmm0 = NBmm_b0;
         else if (beta == ATL_rone) NBmm0 = NBmm_b1;
         else NBmm0 = NBmm_bX;
      }
      else
      {
         if (beta == ATL_rzero) NBmm0 = Mjoin(PATL,pMBmm_b0);
         else if (beta == ATL_rone) NBmm0 = Mjoin(PATL,pMBmm_b1);
         else NBmm0 = Mjoin(PATL,pMBmm_bX);
      }
   }
   else
   {
      NBmm0 = Mjoin(PATL,pKBmm);
      if ( beta == ATL_rzero && 
           ((B != C) || (ldc != ldb) || (TB != AtlasNoTrans)) )
         gescal = Mjoin(PATL,gescal_b0);
      else gescal = NULL;
   }
   Np0 = Np;

   for (J=nNb; J; J -= Npb)
   {
      if (Npb > J)
      {
         Npb = J;
         Np = ATL_MulByNB(Npb);
      }
      if (copyB)
      {
         copyB(K, Np, B, ldb, pB, ATL_rone);
         B += incB;
      }
      if (gescal) gescal(M, Np, beta, C, ldc);
      for (b=pB, j=Npb; j; j--, b += incpB, C += incC)
         NBmm0(M, NB, K, ATL_rone, pA, K, b, K, beta, C, ldc);
      if (copyB == NULL) pB += incB;
   }
   if (j = (N-ATL_MulByNB(nNb)))
   {
      if (copyB)
      {
         if (TB == AtlasNoTrans) B -= (Np0 - Np)*ldb;
         else B -= Np0 - Np;
         copyB(K, j, B, ldb, pB, ATL_rone);
      }
      else pB -= (Np0 - Np)*K;
      if (M == MB && K == NB)
      {
         if (beta == ATL_rzero)
            Mjoin(PATL,pNBmm_b0)(M, j, K, ATL_rone, pA, K, pB, K, beta, C, ldc);
         else if (beta == ATL_rone)
            Mjoin(PATL,pNBmm_b0)(M, j, K, ATL_rone, pA, K, pB, K, beta, C, ldc);
         else
            Mjoin(PATL,pNBmm_b1)(M, j, K, ATL_rone, pA, K, pB, K, beta, C, ldc);
      }
      else
      {
         if (gescal) Mjoin(PATL,gezero)(M, j, C, ldc);
         Mjoin(PATL,pKBmm)(M, j, K, ATL_rone, pA, K, pB, K, beta, C, ldc);
      }
   }
   if (vA) free(vA);
   if (vB) free(vB);
}
@ROUT ATL_gemmXX
@extract -b @(topd)/gen.inc what=cw
#include "atlas_misc.h"
#include "atlas_lvl3.h"
#ifdef ATL_TGEMM
   #include "atlas_tcacheedge.h"
#else
   #include "atlas_cacheedge.h"
#endif
@skip #include Mstr(Mjoin(Mjoin(atlas_,UPR),geamm_use.h))
@beginskip
#ifdef TREAL
   #include Mstr(Mjoin(Mjoin(atlas_,PRE),rkXover.h))
#endif
@endskip
#ifdef DCPLX
   #include "atlas_zdNKB.h"
   #ifdef ATL_DZNKB
      #define NKB_maxK (ATL_DZNKB * KB)
   #else
      #define NKB_maxK 0
   #endif
#elif defined(SCPLX)
   #include "atlas_csNKB.h"
   #ifdef ATL_CSNKB
      #define NKB_maxK (ATL_CSNKB * KB)
   #else
      #define NKB_maxK 0
   #endif
#endif

#ifndef C2R_K
   #define C2R_K (~(1<<31))
#endif

#ifdef NoTransA_
   #define ETA AtlasNoTrans
   #define TA_ N
   #define ta_ n
   #define incA (Kp*lda SHIFT)
#elif defined(TransA_)
   #define ETA AtlasTrans
   #define TA_ T
   #define ta_ t
   #define incA (Kp SHIFT)
#elif defined(ConjTransA_)
   #define ETA AtlasConjTrans
   #define TA_ C
   #define ta_ c
   #define incA (Kp SHIFT)
#endif

#ifdef NoTransB_
   #define ETB AtlasNoTrans
   #define TB_ N
   #define tb_ n
   #define incB (Kp SHIFT)
#elif defined (TransB_)
   #define ETB AtlasTrans
   #define TB_ T
   #define tb_ t
   #define incB (Kp*ldb SHIFT)
#elif defined (ConjTransB_)
   #define ETB AtlasConjTrans
   #define TB_ C
   #define tb_ c
   #define incB (Kp*ldb SHIFT)
#endif
#define tatb Mjoin(ta_,tb_)
#define TATB Mjoin(TA_,TB_)

#if defined(BIG_MM) || defined(SMALLK_MM) || defined(CRBIG_MM)
   #define ATL_OOM ATL_bigmmOutOfMem =
#else
   #define ATL_OOM
#endif

#ifndef Cgemm__
   #define UNDEF_ATL_VOID
   #define ATL_VOID void
   #ifdef ALIASED_GEMM
      #define Cgemm__ Mjoin(Mjoin(PATL,aliased_gemm),TATB)
   #elif defined(ATL_TGEMM)
      #define Cgemm__ Mjoin(Mjoin(PATL,tgemm),TATB)
   #else
      #define Cgemm__ Mjoin(Mjoin(PATL,gemm),TATB)
   #endif
#endif

@beginskip
#ifdef TREAL
   #define loop3mm Mjoin(Mjoin(PATL,Mjoin(ta_,tb_)),_mm)
   void loop3mm(int M, int N, int K, const SCALAR alpha, const TYPE *A, int lda, 
                const TYPE *B, int ldb, const SCALAR beta, TYPE *C, int ldc);
#endif

@endskip
#ifdef FindingJITCPCE
   #define FindingCE
#endif
#if defined(FindingJITCPCE) || defined(CRBIG_MM) || defined(SMALLK_MM) || \
    defined(BIG_MM) || defined(FindingCE)
   #ifdef ATL_USE_AMM
      #undef ATL_USE_AMM
   #endif
   #define ATL_USE_AMM 0
#endif
#ifndef ATL_USE_AMM
   #define ATL_USE_AMM 0
#endif

#if ATL_USE_AMM
   #include "atlas_amm.h"
#endif

ATL_VOID Cgemm__(const int M, const int N, const int K, const SCALAR alpha,
                 const TYPE *A, const int lda, const TYPE *B, const int ldb, 
                 const SCALAR beta, TYPE *C, const int ldc)
{
   int DOCOPY;
   #if defined(CacheEdge) || defined(FindingCE)
      #ifdef FindingCE
         extern int FoundCE, CompCE;
         const int CE_maxK = ( (ATL_DivBySize(FoundCE)-(MB*NB)) / 
                               ((MB+NB)*KB) ) * KB;
      #else
         static const int CE_maxK = ( (ATL_DivBySize(CacheEdge)-(MB*NB)) / 
                                      (KB*(MB+NB)) )*KB;
      #endif
@beginskip
      #ifdef FindingCE
         extern int FoundCE;
         const int CE_maxK = ((ATL_DivBySize(FoundCE)-(NBNB SHIFT)) / 
                              (NB*(NB+NB)))*NB;
      #else
         static const int CE_maxK = ((ATL_DivBySize(CacheEdge)-(NBNB SHIFT)) / 
                                     (NB*(NB+NB)))*NB;
      #endif
@endskip
      int Kp, k=K;
      #ifdef TCPLX
         const TYPE ONE[2] = {1.0, 0.0};
         const TYPE *bet=beta;
      #else
         const TYPE ONE=1.0;
         TYPE bet=beta;
      #endif
   #endif
   MMINTR mm1, mm2, mmNC;

/*
 *  If computing Kp only, return it w/o calling anything
 */
   #ifdef FindingCE
      if (CompCE)
      {
         CompCE = CE_maxK;
         return;
      }
   #endif
   if (!M  ||  !N || !K) return;  /* quick return */
   #if ATL_USE_AMM
      if (!Mjoin(PATL,ammm)(ETA, ETB, M, N, K, alpha, A, lda, B, ldb, beta,
                            C, ldc))
         return;
   #endif
   #ifdef USERGEMM
      mm1 = mm2 = Mjoin(PATU,usergemm);
      if (N >= M)
      {
         mm2 = Mjoin(PATL,mmJIK);
         mmNC = Mjoin(PATL,NCmmJIK);
      }
      else
      {
         mm2 = Mjoin(PATL,mmJIK);
         mmNC = Mjoin(PATL,NCmmIJK);
      }
   #elif defined(FindingJITCPCE) || defined(CRBIG_MM)
      mm2 = mm1 = Mjoin(PATL,mmJITcp);
      mmNC = (N >= M) ? Mjoin(PATL,NCmmJIK) : Mjoin(PATL,NCmmIJK);
   #else
/*
 *    Chose outside loop order based on workspace needs unless we are
 *    doing a rank-K update, where we want JIK for superior C access
 */
      if (N >= M || (K <= KB+KB && M > MB && N > NB))
      {
         mm1 = Mjoin(PATL,mmJIK);
         mm2 = Mjoin(PATL,mmIJK);
         mmNC = Mjoin(PATL,NCmmJIK);
      }
      else
      {
         mm1 = Mjoin(PATL,mmIJK);
         mm2 = Mjoin(PATL,mmJIK);
         mmNC = Mjoin(PATL,NCmmIJK);
      }
      #ifdef TREAL
/*
 *       Use mmJITcp which does JIT A&B copy to avoid streaming data twice
 *       from mem if the reuse of the copied matrices is low; this algorithm
 *       is slower on many systems due to prefetch & noisy cache use, so
 *       don't use it unless K completely dominates
 */
              if ((M<=MB || N <= NB) && ((K>>4) > ATL_3NB))
@skip         if ( ((M <= MB || N <= NB) && K > ATL_3NB) ||
@skip              ((M <= MB+MB) && (N <= NB+NB) && K > M*N) )
      #else
/*
 *        For complex, JIT code calls real GEMM, which is faster on some
 *        platforms for all shapes, once K is long enough
 */
         if (K >= C2R_K || ((M < MB || N < NB) && (K>>4) >= ATL_3NB))
      #endif
         {
            mm2 = mm1;
            mm1 = Mjoin(PATL,mmJITcp);
         }
   #endif
@beginskip
   #if defined(TREAL) && defined(ATL_RK_MAXK) && !defined(BIGNORK_MM)
      if (SCALAR_IS_ZERO(beta))
      {
         if (K <= ATL_RK_MAXK_B0 && ATL_rkXover_b0[K])
         {
            mm2 = mm1;
            mm1 = Mjoin(PATL,vrankK);
         }
      }
      else if (K <= ATL_RK_MAXK_BX && ATL_rkXover_bX[K])
      {
         mm2 = mm1;
         mm1 = Mjoin(PATL,vrankK);
      }
   #endif
@endskip
   #ifdef SMALLK_MM
      if (ATL_OOM Mjoin(PATL,mmJKI)(ETA, ETB, M, N, K, alpha, A, lda, B, ldb,
                                    beta, C, ldc))
         ATL_assert(mmNC(ETA, ETB, M, N, K, alpha, A, lda, B, ldb, 
                         beta, C, ldc) == 0);
      return;
   #endif

/*
 * See what shape matrix has, in order to determine crossover point
 */
   #if defined(SMALL_MM)
      DOCOPY = 0;
   #elif defined(BIG_MM) || defined(FindingCE) || defined(ALIASED_GEMM) || \
         defined(CRBIG_MM)
      DOCOPY = 1;
   #else
      #if defined(TREAL) && defined(ATL_RK_MAXK)
         if (K <= ATL_RK_MAXK) DOCOPY = M*N >= Mjoin(TATB,_MNK_K)/K;
      #else
         if (K <= ATL_3NB) DOCOPY = M*N >= Mjoin(TATB,_MNK_K)/K;
      #endif
      else if (N <= ATL_3NB)
      {
         if (M <= ATL_3NB) DOCOPY = M*N >= Mjoin(TATB,_MNK_MN)/K;
         else DOCOPY = M*N >= Mjoin(TATB,_MNK_N)/K;
      }
      else if (M <= ATL_3NB) DOCOPY = M*N >= Mjoin(TATB,_MNK_M)/K;
      else DOCOPY = M*N >= Mjoin(TATB,_MNK_GE)/K;
   #endif
   if (!DOCOPY)
   {
/*
 *    If we've got a low-rank GEMM with a long M loop that cannot use copy code,
 *    can use axpy-based algorithm.  Should time for crossover, but I'm lazy.
 */
      if (K <= 4 && M > 40)
      {
         if (!Mjoin(PATL,mmJKI)(ETA, ETB, M, N, K, alpha, A, lda, B, ldb,
                                beta, C, ldc))
             return;
      }
      mm1 = mm2 = mmNC;
   }
/*
 * If CacheEdge is set, try to partition K so we have cache reuse
 * on panels of outer matrix
 */
   #if defined(CacheEdge) || defined(FindingCE)
      #ifdef TREAL
         Kp = Mmin(CE_maxK, K);
      #else
         if (mm1 == Mjoin(PATL,mmJITcp))
            Kp = Mmin(NKB_maxK, K);
         else
            Kp = Mmin(CE_maxK, K);
      #endif
      if (Kp < KB) Kp = K;
/*
 *    If we aren't cutting K, make sure we don't need to cut in order to be
 *    able to allocate the required panels of A & B
 *    K so that we have something that will fit
 */
      #ifdef TREAL
      if (K == Kp)
      #else
      if (mm1 != Mjoin(PATL,mmJITcp) && K == Kp)
      #endif
      {
         Kp = (ATL_DivBySize(ATL_MaxMalloc) - MB*NB) / (MB+NB);
         if (Kp > K || Kp < KB) Kp = K;
      }
      do
      {
            if ( mm1(ETA, ETB, M, N, Kp, alpha, A, lda, B, ldb, bet, C, ldc) )
               if ( ATL_OOM mm2(ETA, ETB, M, N, Kp, alpha, A, lda, B, ldb, 
                                bet, C, ldc) )
                  if ( ATL_OOM Mjoin(PATL,mmJITcp)(ETA, ETB, -M, N, Kp, alpha,
                          A, lda, B, ldb, bet, C, ldc) )
                  ATL_assert(mmNC(ETA, ETB, M, N, Kp, alpha, A, lda, B, ldb, 
                                  bet, C, ldc) == 0);
         bet = ONE;
         A += incA;
         B += incB;
         k -= Kp;
         if (Kp > k) Kp = k;
      }
      while(k);
   #else
      if ( mm1(ETA, ETB, M, N, K, alpha, A, lda, B, ldb, beta, C, ldc) )
         if ( mm2(ETA, ETB, M, N, K, alpha, A, lda, B, ldb, beta, C, ldc) )
            if ( Mjoin(PATL,mmJITcp)(ETA, ETB, -M, N, K, alpha, A, lda, B, ldb,
                                     beta, C, ldc) )
               ATL_assert(mmNC(ETA, ETB, M, N, K, alpha, A, lda, B, ldb, 
                               beta, C, ldc) == 0);
   #endif
}

@skip #undef loop3mm
#undef TATB
#undef tatb
#undef ETB
#undef TB_
#undef tb_
#undef incB
#undef ETA
#undef TA_
#undef ta_
#undef incA
#ifdef UNDEF_ATL_VOID
   #undef UNDEF_ATL_VOID
   #undef ATL_VOID
#endif
@ROUT ATL_AgemmXX
@extract -b @(topd)/gen.inc what=cw

#include "atlas_misc.h"
#include "atlas_lvl3.h"
#include <stddef.h>

#ifdef NoTransA_
   #define ETA AtlasNoTrans
   #define TA_ N
   #define ta_ n
   #define nA_ K
   #define incA (NB SHIFT)
   #define A2BLK Mjoin(PATL,row2blkT)
   #define A_M_ M
   #define A_N_ K
#elif defined(ConjTransA_)
   #define ETA AtlasConjTrans
   #define TA_ C
   #define ta_ c
   #define nA_ M
   #define incA ATL_MulByNB(lda<<1)
   #define A2BLK Mjoin(PATL,col2blkConj)
   #define A_M_ K
   #define A_N_ M
#else
   #define ETA AtlasTrans
   #define TA_ T
   #define ta_ t
   #define nA_ M
   #define incA ATL_MulByNB(lda SHIFT)
   #define A2BLK Mjoin(PATL,col2blk)
   #define A_M_ K
   #define A_N_ M
#endif

#ifdef NoTransB_
   #define ETB AtlasNoTrans
   #define TB_ N
   #define tb_ n
   #define incB ATL_MulByNB(ldb SHIFT)
   #define nB_ N
   #define B2BLK Mjoin(PATL,col2blk)
   #define B_M_ K
   #define B_N_ N
#elif defined(ConjTransB_)
   #define ETB AtlasConjTrans
   #define TB_ C
   #define tb_ c
   #define nB_ K
   #define B2BLK Mjoin(PATL,row2blkC)
   #define B_M_ N
   #define B_N_ K
   #define incB NB2
#else
   #define ETB AtlasTrans
   #define TB_ T
   #define tb_ t
   #define nB_ K
   #define B2BLK Mjoin(PATL,row2blkT)
   #define B_M_ N
   #define B_N_ K
   #define incB (NB SHIFT)
#endif
#define tatb Mjoin(ta_,tb_)
#define TATB Mjoin(TA_,TB_)

void Mjoin(Mjoin(PATL,aliased_gemm),TATB)
   (const int M, const int N, const int K, const SCALAR alpha,
    const TYPE *A, const int lda, const TYPE *B, const int ldb, 
    const SCALAR beta, TYPE *C, const int ldc)
/*
 * Does right thing when output matrix is aliased with one or more of the input
 * matrices
 */
{
   const ptrdiff_t  bA=(ptrdiff_t)A, bB=(ptrdiff_t)B, bC=(ptrdiff_t)C;
   const ptrdiff_t eA = bA + ATL_MulBySize(nA_*lda); 
   const ptrdiff_t eB = bB + ATL_MulBySize(nB_*ldb); 
   const ptrdiff_t eC = bC + ATL_MulBySize(N*ldc);
   const int AC_aliased = ( (bA <= bC && eA >= bC) || (bC <= bA && eC >= bA) );
   const int BC_aliased = ( (bB <= bC && eB >= bC) || (bC <= bB && eC >= bB) );
@beginskip
   const int AC_aliased = ( (bA >= bC && bA <= eC) || (eA >= bC && eA <= eC) );
   const int BC_aliased = ( (bB >= bC && bB <= eC) || (eB >= bC && eB <= eC) );
@endskip
   const int nMb=ATL_DivByNB(M), nNb=ATL_DivByNB(N), nKb=ATL_DivByNB(K);
   const int ib = M - ATL_MulByNB(nMb); 
   const int jb = N - ATL_MulByNB(nNb); 
   const int kb = K - ATL_MulByNB(nKb);
   void *vA=NULL, *vB=NULL;
   TYPE *pA, *pB;
   NBMM0 NBmm0;
   MAT2BLK mat2blk;
   #ifdef TCPLX
      MATSCAL gescal;
   #endif

#ifdef USERGEMM
   int ldpb=ldb, ldpa=lda;
   pA = (TYPE *) A; pB = (TYPE *) B;

   if (BC_aliased)
   {
      vB = malloc(ATL_Cachelen + ATL_MulBySize(N*K));
      ATL_assert(vB);
      pB = ATL_AlignPtr(vB);
      #ifdef NoTransB_
         Mjoin(PATL,gecopy)(K, N, B, ldb, pB, K);
         ldpb = K;
      #else
         Mjoin(PATL,gecopy)(N, K, B, ldb, pB, N);
         ldpb = N;
      #endif
    }
    if (AC_aliased)
    {
       vA = malloc(ATL_Cachelen + ATL_MulBySize(M*K));
       ATL_assert(vA);
       pA = ATL_AlignPtr(vA);
       #ifdef NoTransA_
          Mjoin(PATL,gecopy)(M, K, A, lda, pA, M);
          ldpa = M;
       #else
          Mjoin(PATL,gecopy)(K, M, A, lda, pA, K);
          ldpa = K;
       #endif
    }
    if (Mjoin(PATU,usergemm)(ETA, ETB, M, N, K, alpha, pA, ldpa, pB, ldpb, 
                             beta, C, ldc))
       ATL_assert(Mjoin(PATL,NCmmJIK)(ETA, ETB, M, N, K, alpha, pA, ldpa, 
                                      pB, ldpb, beta, C, ldc)==0);
#else

   #ifdef TCPLX
      if (beta[1] == ATL_rzero)
      {
         gescal = NULL;
         if (*beta == ATL_rone) NBmm0 = Mjoin(PATL,CNBmm_b1);
         else if (*beta == ATL_rzero) NBmm0 = Mjoin(PATL,CNBmm_b0);
         else NBmm0 = Mjoin(PATL,CNBmm_bX);
      }
      else
      {
         NBmm0 = Mjoin(PATL,CNBmm_b1);
         gescal = Mjoin(PATL,gescal_bX);
      }
   #else
      if ( SCALAR_IS_ONE(beta) ) NBmm0 = NBmm_b1;
      else if ( SCALAR_IS_ZERO(beta) ) NBmm0 = NBmm_b0;
      else NBmm0 = NBmm_bX;
   #endif

   if (N >= M)  /* B on outside, A in inner loop */
   {
/*
 *    If B & C are aliased, we will need to copy entire matrix up front
 *    unless B is NoTranspose, and B & C start at the same place
 */
      if (BC_aliased)
      {
         #ifdef NoTransB_
            if (B != C || ldb != ldc)
            {
         #endif
         vB = malloc(ATL_Cachelen + ATL_MulBySize(N*K));
         ATL_assert(vB);
         pB = ATL_AlignPtr(vB);
         Mjoin(B2BLK,2_a1)(B_M_, B_N_, B, ldb, pB, alpha);
         mat2blk = NULL;
         B = NULL;
         #ifdef NoTransB_
            }
         #endif
      }
/*
 *    Otherwise, we can copy B column panel at a time
 */
      if (vB == NULL)
      {
/*
 *       See if we can avoid the copy of B
 */
         #if defined(NoTransB_) && defined(TREAL)
            if (!BC_aliased && ldb == NB && K == NB)
            {
               pB = (TYPE *) B;
               mat2blk = NULL;
               B = NULL;
            }
            else
            {
         #endif

         vB = malloc(ATL_Cachelen + ATL_MulBySize(NB*K));
         ATL_assert(vB);
         pB = ATL_AlignPtr(vB);
         mat2blk = Mjoin(B2BLK,_a1);

         #if defined(NoTransB_) && defined(TREAL)
            }
         #endif
      }
/*
 *    See if it is possible to avoid copying A
 */
      #if !defined(NoTransA_) && defined(TREAL)
         if ( !AC_aliased && lda == NB && K == NB && SCALAR_IS_ONE(alpha) ) 
            pA = (TYPE *) A;
         else
         {
      #endif

         vA = malloc(ATL_Cachelen + ATL_MulBySize(M*K));
         ATL_assert(vA);
         pA = ATL_AlignPtr(vA);
         if ( SCALAR_IS_ONE(alpha) )
            Mjoin(A2BLK,2_a1)(A_M_, A_N_, A, lda, pA, alpha);
         else Mjoin(A2BLK,2_aX)(A_M_, A_N_, A, lda, pA, alpha);

      #if !defined(NoTransA_) && defined(TREAL)
         }
      #endif

      #ifdef TREAL
         Mjoin(PATL,mmJIK2)(K, nMb, nNb, nKb, ib, jb, kb, alpha, pA, 
                              B, ldb, pB, incB, mat2blk, beta, 
                              C, ldc, C, NULL, NBmm0);
      #else
         Mjoin(PATL,mmJIK2)(K, nMb, nNb, nKb, ib, jb, kb, alpha, pA, 
                            B, ldb, pB, incB, mat2blk, beta, 
                            C, ldc, gescal, NBmm0);
      #endif
   }
   else  /* put A as outer matrix, B as inner */
   {

/*
 *    If A & C are aliased, we will need to copy entire matrix up front
 *    unless A is NoTranspose, and A & C start at the same place, with the same
 *    stride between columns
 */
      if (AC_aliased)
      {
         #ifdef NoTransA_
            if (A != C || lda != ldc)
            {
         #endif
         vA = malloc(ATL_Cachelen + ATL_MulBySize(M*K));
         ATL_assert(vA);
         pA = ATL_AlignPtr(vA);
         Mjoin(A2BLK,2_a1)(A_M_, A_N_, A, lda, pA, alpha);
         mat2blk = NULL;
         A = NULL;
         #ifdef NoTransA_
            }
         #endif
      }
/*
 *    Otherwise, we can copy A row panel at a time
 */
      if (vA == NULL)
      {
/*
 *       See if we can avoid the copy of A
 */
         #if !defined(NoTransA_) && defined(TREAL)
            if (!AC_aliased && lda == NB && K == NB)
            {
               pA = (TYPE *) A;
               mat2blk = NULL;
               A = NULL;
            }
            else
            {
         #endif

         vA = malloc(ATL_Cachelen + ATL_MulBySize(NB*K));
         ATL_assert(vA);
         pA = ATL_AlignPtr(vA);
         mat2blk = Mjoin(A2BLK,_a1);

         #if !defined(NoTransA_) && defined(TREAL)
            }
         #endif
      }
/*
 *    See if it is possible to avoid copying B
 */
      #if defined(NoTransB_) && defined(TREAL)
         if (!BC_aliased && ldb == NB && K == NB && alpha == 1.0) 
            pB = (TYPE *) B;
         else
         {
      #endif

         vB = malloc(ATL_Cachelen + ATL_MulBySize(N*K));
         ATL_assert(vB);
         pB = ATL_AlignPtr(vB);
         if ( SCALAR_IS_ONE(alpha) )
              Mjoin(B2BLK,2_a1)(B_M_, B_N_, B, ldb, pB, alpha);
         else Mjoin(B2BLK,2_aX)(B_M_, B_N_, B, ldb, pB, alpha);

      #if defined(NoTransB_) && defined(TREAL)
         }
      #endif
      #ifdef TREAL
         Mjoin(PATL,mmIJK2)(K, nMb, nNb, nKb, ib, jb, kb, alpha, A, lda, pA, 
                              incA, mat2blk, pB, beta, C, ldc, C, NULL, NBmm0);
      #else
         Mjoin(PATL,mmIJK2)(K, nMb, nNb, nKb, ib, jb, kb, alpha, A, lda, pA, 
                            incA, mat2blk, pB, beta, C, ldc, gescal, NBmm0);
      #endif
   }
#endif
   if (vA) free(vA);
   if (vB) free(vB);
}

#undef tatb
#undef TATB

#undef ETA
#undef TA_
#undef ta_
#undef incA
#undef nA_
#undef A2BLK
#undef A_M_
#undef A_N_
#undef incA

#undef ETB
#undef TB_
#undef tb_
#undef incB
#undef nB_
#undef B2BLK
#undef B_M_
#undef B_N_
@ROUT ATL_gemmRecXX
@extract -b @(topd)/gen.inc what=cw @(cw07)
#include <stdio.h>
#include <stdarg.h>
#include "atlas_misc.h"
#include "atlas_lvl3.h"
#ifdef ConjTransB_
   #define TB AtlasConjTrans
#elif defined(TransB_)
   #define TB AtlasTrans
#else
   #define TB AtlasNoTrans
#endif
#ifdef ConjTransA_ 
   #define TA AtlasConjTrans
   #ifdef ConjTransB_
      #define ATL_gemmRec Mjoin(PATL,gemmRec_CC)
   #elif defined(TransB_)
      #define ATL_gemmRec Mjoin(PATL,gemmRec_CT)
   #else
      #define ATL_gemmRec Mjoin(PATL,gemmRec_CN)
   #endif
#elif defined(TransA_)
   #define TA AtlasTrans
   #ifdef ConjTransB_
      #define ATL_gemmRec Mjoin(PATL,gemmRec_TC)
   #elif defined(TransB_)
      #define ATL_gemmRec Mjoin(PATL,gemmRec_TT)
   #else
      #define ATL_gemmRec Mjoin(PATL,gemmRec_TN)
   #endif
#else
   #define TA AtlasNoTrans
   #ifdef ConjTransB_
      #define ATL_gemmRec Mjoin(PATL,gemmRec_NC)
   #elif defined(TransB_)
      #define ATL_gemmRec Mjoin(PATL,gemmRec_NT)
   #else
      #define ATL_gemmRec Mjoin(PATL,gemmRec_NN)
   #endif
#endif
void ATL_gemmRec(const int M, const int N, const int K, const SCALAR alpha, 
                 const TYPE *A, const int lda, const TYPE *B, const int ldb, 
                 const SCALAR beta, TYPE *C, const int ldc, const int REC_STOP)
{
   int ipL, ipR;
   if (M >= N && M >= K)
   {
      if (M <= REC_STOP || M < MB+MB)
         Mjoin(PATL,gemm)(TA, TB, M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
      else
      {
         ipL = (((M+MB-1)/MB)>>1)*MB;
         ipR = M - ipL;
         ATL_gemmRec(ipL, N, K, alpha, A, lda, B, ldb, beta, C, ldc, REC_STOP);
   #ifdef NoTransA_
         ATL_gemmRec(ipR, N, K, alpha, A+(ipL SHIFT), lda, B, ldb,
   #else
         ATL_gemmRec(ipR, N, K, alpha, A+ipL*(lda SHIFT), lda, B, ldb,
   #endif
                     beta, C+(ipL SHIFT), ldc, REC_STOP);
      }
   }
   else if (N >= K)
   {
      if (N <= REC_STOP || N < NB+NB)
         Mjoin(PATL,gemm)(TA, TB, M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
      else
      {
         ipL = (((N+NB-1)/NB)>>1)*NB;
         ipR = N - ipL;
         ATL_gemmRec(M, ipL, K, alpha, A, lda, B, ldb, beta, C, ldc, REC_STOP);
   #ifdef NoTransB_
         ATL_gemmRec(M, ipR, K, alpha, A, lda, B+ipL*(ldb SHIFT), ldb,
   #else
         ATL_gemmRec(M, ipR, K, alpha, A, lda, B+(ipL SHIFT), ldb,
   #endif
                     beta, C+ipL*(ldc SHIFT), ldc, REC_STOP);
      }
   }
   else
   {
      if (K <= REC_STOP || K < KB+KB)
         Mjoin(PATL,gemm)(TA, TB, M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
      else
      {
         ipL = (((K+KB-1)/KB)>>1)*KB;
         ipR = K - ipL;
         ATL_gemmRec(M, N, ipL, alpha, A, lda, B, ldb, beta, C, ldc, REC_STOP);
   #ifdef NoTransA_
      #ifdef NoTransB_
         ATL_gemmRec(M, N, ipR, alpha, A+ipL*(lda SHIFT), lda, 
                     B+(ipL SHIFT), ldb, ATL_rone, C, ldc, REC_STOP);
      #else
         ATL_gemmRec(M, N, ipR, alpha, A+ipL*(lda SHIFT), lda, 
                     B+ipL*(ldb SHIFT), ldb, ATL_rone, C, ldc, REC_STOP);
      #endif
   #else
      #ifdef NoTransB_
         ATL_gemmRec(M, N, K, alpha, A+(ipL SHIFT), lda, 
                     B+(ipL SHIFT), ldb, ATL_rone, C, ldc, REC_STOP);
      #else
         ATL_gemmRec(M, N, K, alpha, A+(ipL SHIFT), lda, 
                     B+ipL*(ldb SHIFT), ldb, ATL_rone, C, ldc, REC_STOP);
      #endif
   #endif
      }
   }
}
@ROUT ATL_gemm
@extract -b @(topd)/gen.inc what=cw
#include <stdio.h>
#include <stdarg.h>
#include "atlas_misc.h"
#include "atlas_lvl3.h"
#include "atlas_cacheedge.h"

#ifdef SMALL_MM
   #define Cgemm Mjoin(PATL,small_mm)
#elif defined(SMALLK_MM)
   extern int ATL_bigmmOutOfMem;
   #define Cgemm Mjoin(PATL,smallK_mm)
#elif defined (BIG_MM)
   int ATL_bigmmOutOfMem=0;
   #define Cgemm Mjoin(PATL,big_mm)
#elif defined (BIGNORK_MM)
   #define Cgemm Mjoin(PATL,bignork_mm)
#elif defined (CRBIG_MM)
   extern int ATL_bigmmOutOfMem;
   #define Cgemm Mjoin(PATL,Mjoin(UPR,big_mm))
#elif defined(FindingCE) || defined(FindingJITCPCE)
   #define Cgemm Mjoin(PATL,FindCE_mm)
#elif defined (ATLGEMM)
   #define Cgemm Mjoin(PATL,gemm)
#elif defined (ALIASED_GEMM)
   #define Cgemm Mjoin(PATL,aliased_gemm)
#endif

/*
 * This is for a gemm where the matrix C can overlap with A and/or B
*/
#ifdef ALIASED_GEMM
   #define CgemmNN Mjoin(PATL,aliased_gemmNN)
   #define CgemmNT Mjoin(PATL,aliased_gemmNT)
   #define CgemmTN Mjoin(PATL,aliased_gemmTN)
   #define CgemmTT Mjoin(PATL,aliased_gemmTT)
   #ifdef TCPLX
      #define CgemmCN Mjoin(PATL,aliased_gemmCN)
      #define CgemmNC Mjoin(PATL,aliased_gemmNC)
      #define CgemmCT Mjoin(PATL,aliased_gemmCT)
      #define CgemmTC Mjoin(PATL,aliased_gemmTC)
      #define CgemmCC Mjoin(PATL,aliased_gemmCC)
   #endif
/*
 * Otherwise, include routines for doing the various transpose cases of gemm. 
 * These are included & declared "static void" to encourage inlining
 */
#else
   #define CgemmNN Mjoin(Mjoin(PATL,GEMM2),NN)
   #define CgemmNT Mjoin(Mjoin(PATL,GEMM2),NT)
   #define CgemmTN Mjoin(Mjoin(PATL,GEMM2),TN)
   #define CgemmTT Mjoin(Mjoin(PATL,GEMM2),TT)
   #ifdef TCPLX
      #define CgemmCN Mjoin(Mjoin(PATL,GEMM2),CN)
      #define CgemmNC Mjoin(Mjoin(PATL,GEMM2),NC)
      #define CgemmCT Mjoin(Mjoin(PATL,GEMM2),CT)
      #define CgemmTC Mjoin(Mjoin(PATL,GEMM2),TC)
      #define CgemmCC Mjoin(Mjoin(PATL,GEMM2),CC)
   #endif
   #define ATL_VOID static void

/* 
 * Cases for A is NoTranspose 
 */
   #define NoTransA_

   #define NoTransB_
   #define Cgemm__ CgemmNN
   #include "ATL_gemmXX.c"
   #undef Cgemm__
   #undef NoTransB_

   #define TransB_
   #define Cgemm__ CgemmNT
   #include "ATL_gemmXX.c"
   #undef Cgemm__
   #undef TransB_

   #ifdef TCPLX
       #define ConjTransB_
       #define Cgemm__ CgemmNC
       #include "ATL_gemmXX.c"
       #undef Cgemm__
       #undef ConjTransB_
   #endif

   #undef NoTransA_

/*
 * Cases for A is ConjTrans
 */
   #ifdef TCPLX
      #define ConjTransA_

      #define NoTransB_
      #define Cgemm__ CgemmCN
      #include "ATL_gemmXX.c"
      #undef Cgemm__
      #undef  NoTransB_

      #define TransB_
      #define Cgemm__ CgemmCT
      #include "ATL_gemmXX.c"
      #undef Cgemm__
      #undef  TransB_

      #define ConjTransB_
      #define Cgemm__ CgemmCC
      #include "ATL_gemmXX.c"
      #undef Cgemm__
      #undef  ConjTransB_

      #undef  ConjTransA_
   #endif

/* 
 * Cases for A is transpose
 */
   #define TransA_

   #define NoTransB_
   #define Cgemm__ CgemmTN
   #include "ATL_gemmXX.c"
   #undef Cgemm__
   #undef NoTransB_

   #define TransB_
   #define Cgemm__ CgemmTT
   #include "ATL_gemmXX.c"
   #undef Cgemm__
   #undef TransB_

   #ifdef TCPLX
       #define ConjTransB_
       #define Cgemm__ CgemmTC
       #include "ATL_gemmXX.c"
       #undef Cgemm__
       #undef ConjTransB_
   #endif
   #undef  TransA_

#endif


void Cgemm(const enum ATLAS_TRANS TA, const enum ATLAS_TRANS TB, 
           const int M, const int N, const int K, const SCALAR alpha, 
           const TYPE *A, const int lda, const TYPE *B, const int ldb, 
           const SCALAR beta, TYPE *C, const int ldc)
/*
 * Error checks have been done by interface routine
 */
{
   if (!M  ||  !N) return;  /* quick return */
   if ( SCALAR_IS_ZERO(alpha) || !K)
   {
      #ifdef TREAL
         if (beta == ATL_rzero) Mjoin(PATL,gezero)(M, N, C, ldc);
         else if (beta != ATL_rone) Mjoin(PATL,gescal_bX)(M, N, beta, C, ldc);
      #else
         if (beta[1] == ATL_rzero)
         {
            if (*beta == ATL_rzero) Mjoin(PATL,gezero)(M, N, C, ldc);
            else if (*beta != ATL_rone) 
               Mjoin(PATL,gescal_bXi0)(M, N, beta, C, ldc);
         }
         else Mjoin(PATL,gescal_bX)(M, N, beta, C, ldc);
      #endif
      return;
   }
@beginskip
/*
 * Call SYRK when that's what the user is actually asking for
 */
   if (A == B && M == N && TA != TB && lda == ldb)
   {
      #ifdef TCPLX
      if (TA != AtlasConjTrans && TB != AtlasConjTrans)
      {
      #endif
         Mjoin(PATL,syrk)(AtlasUpper, TA, N, K, alpha, A, lda, beta, C, ldc);
         Mjoin(PATL,syreflect)(AtlasUpper, N, C, ldc);
         return;
      #ifdef TCPLX
      }
      #endif
   }
@endskip
   if (TA == AtlasNoTrans)
   {
      if (TB == AtlasNoTrans)
         CgemmNN(M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
#ifdef TCPLX
      else if (TB == AtlasConjTrans)
         CgemmNC(M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
#endif
      else
         CgemmNT(M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
   }
#ifdef TCPLX
   else if (TA == AtlasConjTrans)
   {
      if (TB == AtlasNoTrans)
         CgemmCN(M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
      else if (TB == AtlasConjTrans)
         CgemmCC(M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
      else
         CgemmCT(M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
   }
#endif
   else
   {
      if (TB == AtlasNoTrans)
         CgemmTN(M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
#ifdef TCPLX
      else if (TB == AtlasConjTrans)
         CgemmTC(M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
#endif
      else
         CgemmTT(M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
   }
}

@ROUT emit_mmN
@extract -b @(topd)/gen.inc what=cw

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include "atlas_prefetch.h"
#include "atlas_mmparse.h"

static int LD_AT_BOTTOM=0;  /* load $C$ after K-loop, rather than before? */
static int TEMP_TYPE=0; /* type of temp regs: 0-TYPE, 1-double, 2-long double */
#define VERB 1

typedef struct CleanNode CLEANNODE;
struct CleanNode
{                          /* let Nc by dim of cleanup */
   CLEANNODE *next;
   int *NBs;
   int imult;   /* kernel handles all Nc where Nc%imult = 0 */
   int icase;   /* ID of user kernel */
   int fixed;   /* how does kernel handle imult? 0: imult set at run-time, */
                /* 1: must recompile for all Nc, 2: only works for Nc=imult */
   int nb; 
   int ncomps;
   char rout[256], CC[256], CCFLAGS[512];
};

#if defined(ATL_SSE1)
   #define ICC_IS_RETARDED
#endif
#ifndef MAX_CASG_KU
   #define MAX_CASG_KU 2
#endif
#define Mmin(x, y) ( (x) > (y) ? (y) : (x) )
#define Mmax(x, y) ( (x) > (y) ? (x) : (y) )
#define ATL_Mlcm(x_, y_, ans_) \
{ \
   if ((x_) >= (y_)) \
   { \
      (ans_) = (x_); \
      while( ((ans_)/(y_))*(y_) != (ans_) ) (ans_) += (x_); \
   } \
   else \
   { \
      (ans_) = (y_); \
      while( ((ans_)/(x_))*(x_) != (ans_) ) (ans_) += (y_); \
   } \
}
#define Mlowcase(C) ( ((C) > 64 && (C) < 91) ? (C) | 32 : (C) )

char PRE='d';
char *TYPE="double";
int MUL=1;

enum CW {CleanM=0, CleanN=1, CleanK=2, CleanNot=3};
enum ATLAS_LOOP_ORDER {AtlasIJK=0, AtlasJIK=1};
@skip enum ATLAS_TRANS {AtlasNoTrans=111, AtlasTrans=112, AtlasConjTrans=113};
typedef void (*KLOOPFUNC)(FILE *, char*, enum ATLAS_LOOP_ORDER, 
                          enum ATLAS_TRANS, enum ATLAS_TRANS, int, int, int,
                          int, int, int, int, char*, char*, char*, char*, char*,
                          int, int, int, int, int, int, int, int, int, 
                          char*, char*);
#define SAFE_ALPHA -3
@ROUT print_buildinfo
int main(int nargs, char **args)
{
   void ATL_buildinfo(void);
   ATL_buildinfo();
   return(0);
}
@ROUT emit_buildinfo
@extract -b @(topd)/gen.inc what=cw @(cw01)
@multidef flg0
   F77 F77FLAGS ICC ICCFLAGS SMC SMCFLAGS DMC DMCFLAGS 
   SKC SKCFLAGS DKC DKCFLAGS 
   ARCHDEFS F2CDEFS INSTFLAGS ARCH
@endmultidef
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#define LNLEN 2048
@declare "static char " y y ";"
   @whiledef flg0
      @(flg0)[LNLEN]
      @define flg @@(flg0)@
   @endwhile
@enddeclare
static char ICCVERS[LNLEN], F77VERS[LNLEN], SYS[LNLEN];
static char SMCVERS[LNLEN], DMCVERS[LNLEN], SKCVERS[LNLEN], DKCVERS[LNLEN];
static char UNAM[64], DATE[128];
char *CmndResults(char *cmnd)
{
   static char tnam[128];
   static int FirstTime=1;
   char ln[512];

   if (FirstTime)
   {
      FirstTime = 0;
      assert(tmpnam(tnam));
   }
@skip   sprintf(ln, "%s > %s 2>&1\n", cmnd, tnam);
   sprintf(ln, "%s > %s\n", cmnd, tnam);
   fprintf(stderr, "system: %s", ln);
   if (!system(ln)) return(tnam);
   else return(NULL);
}

void FixString(char *ln)
/*
 * Replaces all control characters and whitespaces with spaces,
 * kills all trailing whitespace from string, and replaces [",`] with '
 */
{
   int i;
   char ch;

   for (i=0; ln[i]; i++)
   {
      ch = ln[i];
      if (ch == '"' || ch == '`')
         ln[i] = '\'';
      else if (ch >= 32 && ch <= 125)
         ln[i] = ch;
      else 
         ln[i] = ' ';
   }

   for (i--; i >= 0 && (ln[i] == ' ' || ln[i] == '\n' || ln[i] == '\t'); i--)
      ln[i] = '\0';
}

int CmndOneLine(char *cmnd, char *ln)
/*
 * executes a system call with contents of cmnd, returns the output in ln;
 * Returns value returned by system call
 */
{
   int i;
   FILE *fp;
   char *tnam;

   ln[0] = '\0';
   tnam = CmndResults(cmnd);
   if (tnam)
   {
      fp = fopen(tnam, "r");
      assert(fp);
      if (!fgets(ln, 512, fp)) ln[0] = '\0';
      fclose(fp);
      return(0);
   }
   else ln[0] = '\0';
   return(1);
}

void GetVers(char *comp, char *vers)
{
   char *vflag[4] = {"--version", "-V", "-v", "-version"};
   char ln[LNLEN];
   int i, iret;

   for (i=0; i < 4; i++)
   {
      sprintf(ln, "%s %s", comp, vflag[i]);
      iret = CmndOneLine(ln, vers);
      if (!iret) return;
   }
   strcpy(vers, "UNKNOWN");
}

void GetMakeMacro(char *str, char *val)
{
   char ln[128];
   sprintf(ln, "make print_%s | fgrep -v make", str);
   if (CmndOneLine(ln, val)) strcpy(val, "UNKNOWN");
}
void GetInstInfo()
{
@whiledef flg
   GetMakeMacro("@(flg)", @(flg));
   FixString(@(flg));
   @define flg0 @@(flg)@
@endwhile
@whiledef comp F77 ICC SMC DMC SKC DKC
   GetVers(@(comp), @(comp)VERS);
   FixString(@(comp)VERS);
@endwhile
   if (CmndOneLine("uname -a", SYS)) strcpy(UNAM, "UNKNOWN");
   else FixString(SYS);
   if (CmndOneLine("whoami", UNAM)) strcpy(UNAM, "UNKNOWN");
   FixString(UNAM);
   if (CmndOneLine("date", DATE)) strcpy(DATE, "UNKNOWN");
   FixString(DATE);
}

void PrintInstInfo(FILE *fpout)
{
   char *vstr="@(ver)", *sp, *vs;
   int i, maj=0, min=0, pat=0;
@whiledef flg0
   fprintf(fpout, "#define ATL_@(flg0) \"%s\"\n", @(flg0));
@endwhile
@whiledef comp F77 ICC SMC DMC SKC DKC
   fprintf(fpout, "#define ATL_@(comp)VERS \"%s\"\n", @(comp)VERS);
@endwhile
   fprintf(fpout, "#define ATL_SYSINFO \"%s\"\n", SYS);
   fprintf(fpout, "#define ATL_DATE    \"%s\"\n", DATE);
   fprintf(fpout, "#define ATL_UNAM    \"%s\"\n", UNAM);
   fprintf(fpout, "#define ATL_VERS    \"@(ver)\"\n");
/*
 * Find major release number by parsing version string, which is of form
 *  XX.YY.ZZ, XX=Major release number, YY=Minor release number, ZZ=patch 
 */
   vs = sp = malloc((strlen(vstr)+1)*sizeof(char));
   strcpy(vs, vstr);
   assert(vs);
   for (i=0; sp[i] && sp[i] != '.'; i++);
   assert(sp[i] == '.');   /* major must end wt . */
   sp[i] = '\0';
   assert(sscanf(sp, "%d", &maj) == 1);
   sp += i+1;

   for (i=0; sp[i] && sp[i] != '.'; i++);
   assert(sp[i] == '.');   /* minor must end wt . */
   sp[i] = '\0';  
   assert(sscanf(sp, "%d", &min) == 1);
   sp += i+1;

   for (i=0; sp[i]; i++);
   assert(sp[i] == '\0');
   assert(sscanf(sp, "%d", &pat) == 1);
   free(vs);
   assert(maj >= 3 && min >= 0 && pat >= 0);
   fprintf(fpout, "#define ATL_VERS_MAJOR %d\n", maj);
   fprintf(fpout, "#define ATL_VERS_MINOR %d\n", min);
   fprintf(fpout, "#define ATL_VERS_PATCH %d\n", pat);
}

void CreateFile(char *file)
{
   FILE *fpout;

   GetInstInfo();

   if (file) fpout = fopen(file, "w");
   else fpout = stdout;
   assert(fpout);

   fprintf(fpout, "#ifndef ATL_INSTINFO_H\n   #define ATL_INSTINFO_H\n\n");

   PrintInstInfo(fpout);

   fprintf(fpout, "\n#endif\n");
   if (fpout != stdout) fclose(fpout);
}

int main(int nargs, char **args)
{
   FILE *fpout=stdout;
   char *file=NULL;
   if (nargs > 1) file = args[1];
   CreateFile(file);
   return(0);
}
@ROUT PrintTypeHead emit_lvl1 emitmv genmv
@extract -b @(topd)/gen.inc what=cw
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <string.h>
#include <ctype.h>
@ROUT emitmv genmv

#define Mmin(x, y) ( (x) > (y) ? (y) : (x) )

FILE *fpout;

@ROUT emit_lvl1

#define INCX_X -993
enum ROUT {Swap=1, Scal, Copy, Axpy, Dot, Nrm, Amax, Axpby, ax} Rout=Scal;
char as[8], bs[8], ixs[8], iys[8];

@ROUT emitmv emit_lvl1 genmv emit_mmN
void PrintC99Defines(FILE *fpout, char *spc)
{
   fprintf(fpout, "%s#ifndef ATL_RESTRICT\n", spc);
   fprintf(fpout, 
      "%s#if defined(__STDC_VERSION__) && (__STDC_VERSION__/100 >= 1999)\n",
           spc);
   fprintf(fpout, "%s   #define ATL_RESTRICT restrict\n", spc);
   fprintf(fpout, "%s#else\n%s   #define ATL_RESTRICT\n%s#endif\n", 
           spc, spc, spc);
   fprintf(fpout, "%s#endif\n", spc);
}
@ROUT emitmv printtypehead emit_lvl1 genmv emit_mmN

int GetPower2(int n)
{
   int pwr2, i;

   if (n == 1) return(0);
   for (pwr2=0, i=1; i < n; i <<= 1, pwr2++);
   if (i != n) pwr2 = 0;
   return(pwr2);
}

@ROUT emit_ger emitmv PrintTypeHead emit_lvl1 genmv emit_mmN
#define ShiftThresh 2
char *GetDiv(int N, char *inc)
{
   static char ln[256];
   int pwr2 = GetPower2(N);
   if (N == 1) sprintf(ln, "%s", inc);
   else if (pwr2) sprintf(ln, "((%s) >> %d)", inc, pwr2);
   else sprintf(ln, "((%s) / %d)", inc, N);
   return(ln);
}

char *GetInc(int N, char *inc)
{
   static char ln0[256];
   char ln[256];
   char *p=ln;
   int i, n=N, iPLUS=0;

   if (n == 0)
   {
      ln[0] = '0';
      ln[1] = '\0';
   }
   while(n > 1)
   {
      for (i=0; n >= (1<<i); i++);
      if ( (1 << i) > n) i--;
      if (iPLUS++) *p++ = '+';
@skip      p += sprintf(p, "(%s << %d)", inc, i);
      sprintf(p, "((%s) << %d)", inc, i);
      p += strlen(p);
      n -= (1 << i);
   }
   if (n == 1)
   {
      if (iPLUS++) *p++ = '+';
      sprintf(p, "%s", inc);
   }
   if (iPLUS > ShiftThresh) sprintf(ln0, "(%d*(%s))", N, inc);
   else if (iPLUS) sprintf(ln0, "(%s)", ln);
   else sprintf(ln0, "%s", ln);
   return(ln0);
}

@ROUT emit_mmN
void emit_uhead(FILE *fp, char pre, enum CW which, int mb, int nb, int kb, 
                int lda, int ldb, int ldc, int beta)
/*
 * if which != CleanNot, ldc is not used, lda is imult ldb is fixed,
 * and ldc is NBs[j]
 */
{
   char *cbet;
   char cwh[3] = {'M', 'N', 'K'};
   int i;

   if (beta == 1) cbet = "1";
   else if (beta == 0) cbet = "0";
   else if (beta == -1) cbet = "n1";
   else cbet = "X";

   if (which == CleanNot)
   {
      fprintf(fp, "#define ATL_USERMM ATL_%cJIK%dx%dx%dTN%dx%dx%d_a1_b%s\n",
              pre, mb, nb, kb, lda, ldb, ldc, cbet);
      fprintf(fp, "#define ATL_USERMM_b1 ATL_%cJIK%dx%dx%dTN%dx%dx%d_a1_b1\n",
              pre, mb, nb, kb, lda, ldb, ldc);
      fprintf(fp, "#define ATL_USERMM_bn1 ATL_%cJIK%dx%dx%dTN%dx%dx%d_a1_bn1\n",
              pre, mb, nb, kb, lda, ldb, ldc);
      fprintf(fp, "#define ATL_USERMM_b0 ATL_%cJIK%dx%dx%dTN%dx%dx%d_a1_b0\n",
              pre, mb, nb, kb, lda, ldb, ldc);
      fprintf(fp, "#define ATL_USERMM_bX ATL_%cJIK%dx%dx%dTN%dx%dx%d_a1_bX\n",
              pre, mb, nb, kb, lda, ldb, ldc);
   }
   else
   {
      fprintf(fp, "#define ATL_USERMM ATL_%cup%cBmm%d_%d_%d_b%s\n",
              pre, cwh[which], ldc, lda, ldb, cbet);
      fprintf(fp, "#define ATL_USERMM_b1 ATL_%cup%cBmm%d_%d_%d_b1\n",
              pre, cwh[which], ldc, lda, ldb);
      fprintf(fp, "#define ATL_USERMM_bn1 ATL_%cup%cBmm%d_%d_%d_bn1\n",
              pre, cwh[which], ldc, lda, ldb);
      fprintf(fp, "#define ATL_USERMM_b0 ATL_%cup%cBmm%d_%d_%d_b0\n",
              pre, cwh[which], ldc, lda, ldb);
      fprintf(fp, "#define ATL_USERMM_bX ATL_%cup%cBmm%d_%d_%d_bX\n",
              pre, cwh[which], ldc, lda, ldb);
   }
   if (beta == -1) fprintf(fp, "#define BETAN1\n");
   else fprintf(fp, "#define BETA%s\n", cbet);
   if (pre == 's') fprintf(fp, "#define SREAL\n");
   else if (pre == 'd') fprintf(fp, "#define DREAL\n");
   else if (pre == 'c') fprintf(fp, "#define SCPLX\n");
   else if (pre == 'z') fprintf(fp, "#define DCPLX\n");
   fprintf(fp, "\n#define MB %d\n#define NB %d\n#define KB %d\n", mb, nb, kb);
   fprintf(fp, "\n#define MBMB %d\n#define NBNB %d\n#define KBKB %d\n", 
           mb*mb, nb*nb, kb*kb);
   for (i=2; i <= 8; i++)
      fprintf(fp, "\n#define MB%d %d\n#define NB%d %d\n#define KB%d %d\n\n", 
              i, i*mb, i, i*nb, i, i*kb);
}

void emit_head(int NC, FILE *fpout, char pre, int nb, int muladd, int lat,
               int mu, int nu, int ku)
{
   int i, pow2nb;
   char nam[128];
   char upr;
   
   fprintf(fpout, "#ifndef %cMM_H\n", toupper(pre));
   fprintf(fpout, "   #define %cMM_H\n\n", toupper(pre));
   if (muladd) fprintf(fpout, "   #define ATL_mmMULADD\n");
   else fprintf(fpout, "   #define ATL_mmNOMULADD\n");
   fprintf(fpout, "   #define ATL_mmLAT %d\n", lat);
   fprintf(fpout, "   #define ATL_mmMU  %d\n", mu);
   fprintf(fpout, "   #define ATL_mmNU  %d\n", nu);
   fprintf(fpout, "   #define ATL_mmKU  %d\n", ku);
   fprintf(fpout, "   #define MB %d\n", nb);
   fprintf(fpout, "   #define NB %d\n", nb);
   fprintf(fpout, "   #define KB %d\n", nb);
   fprintf(fpout, "   #define NBNB %d\n", nb*nb);
   fprintf(fpout, "   #define MBNB %d\n", nb*nb);
   fprintf(fpout, "   #define MBKB %d\n", nb*nb);
   fprintf(fpout, "   #define NBKB %d\n", nb*nb);
   fprintf(fpout, "   #define NB2 %d\n", 2*nb);
   fprintf(fpout, "   #define NBNB2 %d\n\n", 2*nb*nb);

   for (i=1,pow2nb=0; i < nb; i <<= 1, pow2nb++);
   if (i == nb)
   {
      fprintf(fpout, "   #define ATL_MulByNB(N_) ((N_) << %d)\n", pow2nb);
      fprintf(fpout, "   #define ATL_DivByNB(N_) ((N_) >> %d)\n", pow2nb);
      fprintf(fpout, "   #define ATL_MulByNBNB(N_) ((N_) << %d)\n", 2*pow2nb);
   }
   else 
   {
      fprintf(fpout, "   #define ATL_MulByNB(N_) ((N_) * %d)\n", nb);
      fprintf(fpout, "   #define ATL_DivByNB(N_) ((N_) / %d)\n", nb);
      fprintf(fpout, "   #define ATL_MulByNBNB(N_) ((N_) * %d)\n", nb*nb);
   }
   if (!NC)
   {
      sprintf(nam, "ATL_%cJIK%dx%dx%dTN%dx%dx%d", pre, nb, nb, nb, nb, nb, 0);
      if (pre == 'd' || pre == 's')
      {
         fprintf(fpout, "   #define NBmm %s_a1_b1\n", nam);
         fprintf(fpout, "   #define NBmm_b1 %s_a1_b1\n", nam);
         fprintf(fpout, "   #define NBmm_b0 %s_a1_b0\n", nam);
         fprintf(fpout, "   #define NBmm_bX %s_a1_bX\n", nam);
      }
      else
      {
   
         fprintf(fpout, "void %s_a1_b0(const int M, const int N, const int K, const TYPE alpha, const TYPE *A, const int lda, const TYPE *B, const int ldb, const TYPE beta, TYPE *C, const int ldc);\n", nam);
         fprintf(fpout, "void %s_a1_b1(const int M, const int N, const int K, const TYPE alpha, const TYPE *A, const int lda, const TYPE *B, const int ldb, const TYPE beta, TYPE *C, const int ldc);\n", nam);
         fprintf(fpout, "void %s_a1_bX(const int M, const int N, const int K, const TYPE alpha, const TYPE *A, const int lda, const TYPE *B, const int ldb, const TYPE beta, TYPE *C, const int ldc);\n\n", nam);

         fprintf(fpout, "   #define NBmm_b1(m_, n_, k_, al_, A_, lda_, B_, ldb_, be_, C_, ldc_) \\\n");
         fprintf(fpout, "{ \\\n");
            fprintf(fpout, "   %s_a1_bX(m_, n_, k_, al_, (A_), lda_, (B_), ldb_, ATL_rnone, C_, ldc_); \\\n", nam);
            fprintf(fpout, "   %s_a1_b1(m_, n_, k_, al_, (A_), lda_, (B_)+NBNB, ldb_, ATL_rone, (C_)+1, ldc_); \\\n", nam);
            fprintf(fpout, "   %s_a1_bX(m_, n_, k_, al_, (A_)+NBNB, lda_, (B_)+NBNB, ldb_, ATL_rnone, C_, ldc_); \\\n", nam);
            fprintf(fpout, "   %s_a1_b1(m_, n_, k_, al_, (A_)+NBNB, lda_, (B_), ldb_, ATL_rone, (C_)+1, ldc_); \\\n", nam);
         fprintf(fpout, "   }\n");

         fprintf(fpout, "   #define NBmm_b0(m_, n_, k_, al_, A_, lda_, B_, ldb_, be_, C_, ldc_) \\\n");
         fprintf(fpout, "{ \\\n");
         fprintf(fpout, "   %s_a1_b0(m_, n_, k_, al_, (A_), lda_, (B_), ldb_, ATL_rzero, C_, ldc_); \\\n", nam);
         fprintf(fpout, "   %s_a1_b0(m_, n_, k_, al_, (A_), lda_, (B_)+NBNB, ldb_, ATL_rzero, (C_)+1, ldc_); \\\n", nam);
         fprintf(fpout, "   %s_a1_bX(m_, n_, k_, al_, (A_)+NBNB, lda_, (B_)+NBNB, ldb_, ATL_rnone, C_, ldc_); \\\n", nam);
         fprintf(fpout, "   %s_a1_b1(m_, n_, k_, al_, (A_)+NBNB, lda_, (B_), ldb_, ATL_rone, (C_)+1, ldc_); \\\n", nam);
         fprintf(fpout, "   }\n");

         fprintf(fpout, "   #define NBmm_bX(m_, n_, k_, al_, A_, lda_, B_, ldb_, be_, C_, ldc_) \\\n");
         fprintf(fpout, "{ \\\n");
         fprintf(fpout, "   %s_a1_bX(m_, n_, k_, al_, (A_), lda_, (B_), ldb_, -(be_), C_, ldc_); \\\n", nam);
         fprintf(fpout, "   %s_a1_bX(m_, n_, k_, al_, (A_), lda_, (B_)+NBNB, ldb_, be_, (C_)+1, ldc_); \\\n", nam);
         fprintf(fpout, "   %s_a1_bX(m_, n_, k_, al_, (A_)+NBNB, lda_, (B_)+NBNB, ldb_, ATL_rnone, C_, ldc_); \\\n", nam);
         fprintf(fpout, "   %s_a1_b1(m_, n_, k_, al_, (A_)+NBNB, lda_, (B_), ldb_, ATL_rone, (C_)+1, ldc_); \\\n", nam);
         fprintf(fpout, "   }\n");

         if (pre == 'z') upr = 'd';
         else upr = 's';
         sprintf(nam, "ATL_%cJIK%dx%dx%dTN%dx%dx%d", upr, nb, nb, nb, nb, nb,0);
         fprintf(fpout, "   #define rNBmm_b1 %s_a1_b1\n", nam);
         fprintf(fpout, "   #define rNBmm_b0 %s_a1_b0\n", nam);
         fprintf(fpout, "   #define rNBmm_bX %s_a1_bX\n", nam);
      }
   }

   fprintf(fpout, "\n#endif\n");
}

int GetGoodLat(int muladd, int mu, int nu, int ku, int lat)
{
   int mul=mu*nu*ku, slat, blat;
   if (muladd) return(lat);
   for(slat=lat; mul % slat; slat--);
   for(blat=lat; mul % blat && blat < mul; blat++);
   if (blat-lat > lat-slat || mul%blat) return(slat);
   else return(blat);
}

void opfetch(FILE *fpout,          /* where to print */
             char *spc,            /* indentation string */
             int ifetch, /* number of elts to fetch from memory into regs */
             char *rA,  /* name for register holding elt of inner matrix */
             char *rB,  /* name for register holding elt of outer matrix */
             char *pA,  /* name for pointer to elt of inner matrix */
             char *pB,  /* name for pointer to elt of outer matrix */
             int mu,    /* register blocking for inner matrix */
             int nu,    /* register blocking for outer matrix */
             int offA,  /* offset to first elt of this block of inner matrix */
             int offB,  /* offset to first elt of this block of outer matrix */
             int lda,   /* row stride; if 0, row stride is arbitrary */
             int ldb,   /* row stride; if 0, row stride is arbitrary */
             int mulA,  /* col stride; 1: real, 2: cplx */
             int mulB,  /* col stride; 1: real, 2: cplx */
             int rowA,  /* if 0 : fetch within column, else fetch within row */
             int rowB,  /* if 0 : fetch within column, else fetch within row */
             int *ia0,  /* elt of inner matrix to be fetched */
             int *ib0)  /* elt of inner matrix to be fetched */
/*
 * This routine is used to generate memory-to-register fetches
 * A is inner matrix, fetched first;  B is outer matrix, fetched last
 * Assumes each matrix has either a pointer for each column of accessed, labeled
 * <pA><col#>, or the number of rows is a constant (ldx), and only one pointer,
 * <pA>0.
 */
{
   int ia = *ia0, ib = *ib0, nf = 0;

   if (ia >= mu && ib >= nu) return;

   if (ia == 0 && ib == 0) /* initial fetch, always get 2 */
   {
      assert(ifetch >= 2);
      if (offA) fprintf(fpout, "%s   %s0 = %s0[%d];\n", spc, rA, pA, offA);
      else fprintf(fpout, "%s   %s0 = *%s0;\n", spc, rA, pA);
      if (offB) fprintf(fpout, "%s   %s0 = %s0[%d];\n", spc, rB, pB, offB);
      else fprintf(fpout, "%s   %s0 = *%s0;\n", spc, rB, pB);
      nf = 2;
      ia = ib = 1;
   }
   while ( (nf < ifetch) && (ia < mu || ib < nu) )
   {
      if (ia < mu) /* remaining elts of inner matrix to be fetched */
      {
         if (rowA) /* fetching from row */
         {
            if (lda) fprintf(fpout, "%s   %s%d = %s0[%d];\n", 
                              spc, rA, ia, pA, offA+(ia*lda)*mulA);
            else if (offA == 0) 
               fprintf(fpout, "%s   %s%d = *%s%d;\n", spc, rA, ia, pA, ia);
            else fprintf(fpout, "%s   %s%d = %s%d[%d];\n", spc, rA, ia, pA, 
                         ia, offA);
         }
         else fprintf(fpout, "%s   %s%d = %s0[%d];\n", 
                      spc, rA, ia, pA, offA+ia*mulA);
         ia++;
      }
      else  /* after inner matrix fetched, fetch outer matrix */
      {
         if (rowB) /* fetching from row */
         {
            if (ldb) fprintf(fpout, "%s   %s%d = %s0[%d];\n", 
                              spc, rB, ib, pB, offB+ib*ldb*mulB);
            else if (offB == 0) 
               fprintf(fpout, "%s   %s%d = *%s%d;\n", spc, rB, ib, pB, ib);
            else fprintf(fpout, "%s   %s%d = %s%d[%d];\n", spc, rB, ib, pB, 
                         ib, offB);
         }
         else fprintf(fpout, "%s   %s%d = %s0[%d];\n", 
                      spc, rB, ib, pB, offB+ib*mulB);
         ib++;
      }
      nf++;
   }
   *ia0 = ia;
   *ib0 = ib;
}

/*
 * incABk : increment A & B pointers or offsets inside K-loop
 */
void incABk(FILE *fpout, char *spc, 
            char *pA, char *pB,   /* varnams of pointers to matrices */
            int mu, int nu,       /* unrollings */
            int *offA, int *offB,  /* offsets from ptr to first part of block */
            int lda, int ldb,      /* leading dimensions */
            int mulA, int mulB,    /* col increment: 1 = real, 2 = cplx */
            int incpA, int incpB,  /* Increment ptrs at each K iteration? */
            char *incAk, char *incBk, /* if needed, K-loop inc constant */
            int rowA, int rowB)    /* 0: fetch from col, else fetch from row */
{
   int p;

   if (incpA)
   {
      if (rowA)
      {
         if (mulA == 1)
         {
            if (lda) fprintf(fpout, "%s   %s0++;\n", spc, pA);
            else for(p=0; p < mu; p++) 
                    fprintf(fpout, "%s   %s%d++;\n",spc, pA, p);
         }
         else
         {
            if (lda) fprintf(fpout, "%s   %s0 += %d;\n", spc, pA, mulA);
            else for(p=0; p < mu; p++) 
                    fprintf(fpout, "%s   %s%d += %d;\n",spc, pA, p, mulA);
         }
      }
      else  /* mu unroll is along a column */
      {
         if (lda) fprintf(fpout, "%s   %s0 += %d;\n", spc, pA, lda*mulA);
         else fprintf(fpout, "%s   %s0 += %s;\n", spc, pA, incAk);
      }
   }
   else
   {
      if (rowA) (*offA) += mulA;
      else
      {
         assert(lda);
         *offA += mulA*lda;
      }
   }

   if (incpB)
   {
      if (rowB)
      {
         if (mulB == 1)
         {
            if (ldb) fprintf(fpout, "%s   %s0++;\n", spc, pB);
            else for(p=0; p < nu; p++) 
                    fprintf(fpout, "%s   %s%d++;\n",spc, pB, p);
         }
         else
         {
            if (ldb) fprintf(fpout, "%s   %s0 += %d;\n", spc, pB, mulB);
            else for(p=0; p < nu; p++) 
                    fprintf(fpout, "%s   %s%d += %d;\n",spc, pB, p, mulB);
         }
      }
      else  /* nu unroll is along a row */
      {
         if (ldb) fprintf(fpout, "%s   %s0 += %d;\n", spc, pB, ldb*mulB);
         else fprintf(fpout, "%s   %s0 += %s;\n", spc, pB, incBk);
      }
   }
   else  /* incrementing offset, not pointers */
   {
      if (rowB) (*offB) += mulB;
      else
      {
         assert(ldb);
         *offB += mulB*ldb;
      }
   }
}

/*
 * regKunroll_ma: K-loop unrolling for combine multiply/add instruction.
 * Unrolls k loop by ku, with mu unroll along inner matrix & nu along outer.
 * If actual inner matrix is B instead of A, pass B's data in A and vice versa,
 * and assign pC[i][j] = rCji.
 */
void regKunroll_ma(FILE *fpout, 
                   char *spc,  /* indentation string */
                   enum ATLAS_LOOP_ORDER LoopOrder,
                   int Asg1stC,/* 1: first C update gets =, instead of += */
                   int ifetch, /* number of initial fetches to perform */
                   int nfetch, /* # of fetches to perform for every flop */
                   char *rA,   /* varnam for registers of inner matrix */
                   char *rB,   /* varnam for registers of outer matrix */
                   char *rC,   /* varnam for registers holding C */
                   char *pA,   /* varnam for pointer(s) to inner matrix */
                   char *pB,   /* varnam for pointer(s) to outer matrix */
                   int mu,     /* unrolling along inner loop */
                   int nu,     /* unrolling along outer loop */
                   int ku,     /* unrolling along k-loop (innermost) */
                   int *offA0, /* offset to first elt of this block */
                   int *offB0, /* offset to first elt of this block */
                   int lda,    /* row stride; if 0, row stride is arbitrary */
                   int ldb,    /* row stride; if 0, row stride is arbitrary */
                   int mulA,   /* col stride; 1: real 2: cplx */
                   int mulB,   /* col stride; 1: real 2: cplx */
                   int incpA,  /* Increment A for every K iteration? */
                   int incpB,  /* Increment B for every K iteration? */
                   char *incAk,  /* if !rowA, k-loop increment for ptrs */
                   char *incBk,  /* if !rowB, k-loop increment for ptrs */
                   int rowA, /* if 0, fetch within col, else fetch within row */
                   int rowB) /* if 0, fetch within col, else fetch within row */
{
   int i, j, k, ia=0, ib=0, offA=(*offA0), offB=(*offB0);

   if (LoopOrder == AtlasIJK)
   {
      regKunroll_ma(fpout, spc, AtlasJIK, Asg1stC, ifetch, nfetch, rB, rA, rC,
                    pB, pA, nu, mu, ku, offB0, offA0, ldb, lda, mulB, mulA, 
                    incpA, incpB, incBk, incAk, rowB, rowA);
      return;
   }
   for (k=0; k < ku; k++)
   {
      ia = ib = 0;
      opfetch(fpout, spc, ifetch, rA, rB, pA, pB, mu, nu, offA, offB, 
              lda, ldb, mulA, mulB, rowA, rowB, &ia, &ib);
      for (j=0; j < nu; j++)
      {
         for (i=0; i < mu; i++)
         {
            if (Asg1stC && !k)
               fprintf(fpout, "%s   %s%d_%d = %s%d * %s%d;\n", 
                       spc, rC, i, j, rA, i, rB, j);
            else
               fprintf(fpout, "%s   %s%d_%d += %s%d * %s%d;\n", 
                       spc, rC, i, j, rA, i, rB, j);
            opfetch(fpout, spc, nfetch, rA, rB, pA, pB, mu, nu, offA, offB, 
                    lda, ldb, mulA, mulB, rowA, rowB, &ia, &ib);
         }
      }
      incABk(fpout, spc, pA, pB, mu, nu, &offA, &offB, lda, ldb, mulA, mulB, 
             incpA, incpB, incAk, incBk, rowA, rowB);
   }
}

/*
 * regKloop_ma : Creates a full K-loop, unrolled by ku, assuming M & N
 * unrollings of mu & nu, using combined muladd instruction
 */
void regKloop_ma(FILE *fpout, 
                 char *spc,  /* indentation string */
                 enum ATLAS_LOOP_ORDER LoopOrder,
                 enum ATLAS_TRANS TA,
                 enum ATLAS_TRANS TB,
                 int AsgC1, /* if 1, 1st iter does c = instead of c += */
                 int M,     /* if 0, M is arbitrary, else M is len of M-loop */
                 int N,     /* if 0, N is arbitrary, else N is len of N-loop */
                 int K,      /* if 0, K is arbitrary, else K is len of K-loop */
                 int ifetch, /* number of initial fetches to perform */
                 int nfetch, /* # of fetches to perform for every flop */
                 int lat,    /* latency */
                 char *rA,   /* varnam for registers of inner matrix */
                 char *rB,   /* varnam for registers of outer matrix */
                 char *rC,   /* varnam for registers holding C */
                 char *pA,   /* varnam for pointer(s) to inner matrix */
                 char *pB,   /* varnam for pointer(s) to outer matrix */
                 int mu,     /* unrolling along inner loop */
                 int nu,     /* unrolling along outer loop */
                 int ku,     /* unrolling along k-loop (innermost) */
                 int lda,    /* row stride: 0 = unknown */
                 int ldb,    /* row stride: 0 = unknown */
                 int mulA,   /* column stride: 1 = real, 2 = cplx */
                 int mulB,   /* column stride: 1 = real, 2 = cplx */
                 int incpA,  /* Increment A for every K iteration? */
                 int incpB,  /* Increment B for every K iteration? */
                 char *incAk,  /* if !rowA, k-loop increment for ptrs */
                 char *incBk)  /* if !rowB, k-loop increment for ptrs */
{
   char kadj[8];
   int i;
   int rowA, rowB; /* mu/nu elts fetched from row? */
   int offA=0, offB=0;
   char *incAk0, *incBk0;
   if (K) assert (ku*2 <= K || K == ku);  /* need at least one iter. for loop */

   if (TA == AtlasNoTrans) rowA = 0;
   else rowA = 1;
   if (TB == AtlasNoTrans) rowB = 1;
   else rowB = 0;

   if (ku == K) /* loop fully unrolled */
   {
      regKunroll_ma(fpout, spc, LoopOrder, AsgC1, ifetch, nfetch, rA, rB,
                    rC, pA, pB, mu, nu, ku, &offA, &offB, lda, ldb, mulA, mulB, 
                    incpA, incpB, incAk, incBk, rowA, rowB);
      if (!incpA)
      {
         fprintf(fpout, "%s   %s0 += %s;\n", spc, pA, incAk);
         if (lda == 0 && TA != AtlasNoTrans)
            for (i=1; i < mu; i++)
               fprintf(fpout, "%s   %s%d += %s;\n", spc, pA, i, incAk);
      }
      if (!incpB)
      {
         fprintf(fpout, "%s   %s0 += %s;\n", spc, pB, incBk);
         if (ldb == 0 && TB == AtlasNoTrans)
            for (i=1; i < nu; i++)
               fprintf(fpout, "%s   %s%d += %s;\n", spc, pB, i, incBk);
      }
      return;
   }

   if (K)
   {
/*
 *    If need to do C = on 1st iteration, peal 1st ku iterations, and then
 *    do loop with K-ku
 */
      if (AsgC1 && (K > ku) && ku <= MAX_CASG_KU)
      {
         fprintf(fpout, 
         "/*\n *%s Peel 1st iter to assign C regs\n */\n", spc);
         regKunroll_ma(fpout, spc, LoopOrder, 1, ifetch, nfetch, rA, rB, rC, 
                       pA, pB, mu, nu, ku, &offA, &offB, lda, ldb, mulA, mulB,
                       incpA, incpB, incAk, incBk, rowA, rowB);
         if (!incpA)
         {
            fprintf(fpout, "%s   %s0 += %s;\n", spc, pA, incAk);
            if (lda == 0 && TA != AtlasNoTrans)
               for (i=1; i < mu; i++)
                  fprintf(fpout, "%s   %s%d += %s;\n", spc, pA, i, incAk);
         }
         if (!incpB)
         {
            fprintf(fpout, "%s   %s0 += %s;\n", spc, pB, incBk);
            if (ldb == 0 && TB == AtlasNoTrans)
               for (i=1; i < nu; i++)
                  fprintf(fpout, "%s   %s%d += %s;\n", spc, pB, i, incBk);
         }
         fprintf(fpout, "/*\n *%s Unpeeled K iterations\n */\n", spc);
         K -= ku;
      }
#ifdef ICC_IS_RETARDED
      if (ku == 1) 
         fprintf(fpout, 
                 "%s   for (k=0; k < %d; k++) /* easy loop to unroll */\n",
                 spc, K);
      else fprintf(fpout, 
                   "%s   for (k=0; k < %d; k++) /* easy loop to unroll */\n",
                   spc, K/ku);
#else
      if (ku == 1) 
         fprintf(fpout, "%s   for (k=%d; k; k--) /* easy loop to unroll */\n",
                 spc, K);
      else fprintf(fpout, 
                   "%s   for (k=%d; k; k -= %d) /* easy loop to unroll */\n",
                   spc, (K/ku)*ku, ku);
#endif
   }
   else
   {
#ifdef ICC_IS_RETARDED
      if (ku == 1) 
         fprintf(fpout, 
                 "%s   for (k=0; k < K; k++) /* easy loop to unroll */\n", spc);
      else fprintf(fpout, 
                  "%s   for (k=0; k < Kb; k += %d) /* easy loop to unroll */\n",
                   spc, ku);
#else
      if (ku == 1) 
         fprintf(fpout, "%s   for (k=K; k; k--) /* easy loop to unroll */\n",
                 spc);
      else fprintf(fpout, 
                   "%s   for (k=Kb; k; k -= %d) /* easy loop to unroll */\n",
                   spc, ku);
#endif
   }
   fprintf(fpout, "%s   {\n", spc);
   spc -= 3;
   regKunroll_ma(fpout, spc, LoopOrder, 0, ifetch, nfetch, rA, rB, rC, pA, pB, 
                 mu, nu, ku, &offA, &offB, lda, ldb, mulA, mulB, incpA, incpB,
                 incAk, incBk, rowA, rowB);
   if (!incpA) /* need to increment the A pointers ourselves */
   {  
      fprintf(fpout, "%s   %s0 += %s;\n", spc, pA, incAk);
      if (rowA && !lda)
         for (i=1; i < mu; i++) 
            fprintf(fpout, "%s   %s%d += %s;\n", spc, pA, i, incAk);
   }
   if (!incpB) /* need to increment the B pointers ourselves */
   {
      fprintf(fpout, "%s   %s0 += %s;\n", spc, pB, incBk);
      if (rowB && !ldb) 
         for (i=1; i < nu; i++) 
            fprintf(fpout, "%s   %s%d += %s;\n", spc, pB, i, incBk);
   }
   spc += 3;
   fprintf(fpout, "%s   }\n", spc);

/*
 * K-loop cleanup
 */
   if (K) /* known cleanup */
   {
      if (K%ku)
         regKunroll_ma(fpout, spc, LoopOrder, 0, ifetch, nfetch, rA, rB, rC, 
                       pA, pB, mu, nu, K%ku, &offA, &offB, lda, ldb, mulA, mulB,
                       incpA, incpB, incAk, incBk, rowA, rowB);
      sprintf(kadj, "%d", K%ku);
   }
   else if (ku > 1) /* cleanup between 0-(ku-1) */
   {
      fprintf(fpout, "%s   switch(k = (K-Kb))\n%s   {\n", spc, spc);
      for (i=1; i < ku; i++)
      {
         fprintf(fpout, "%s   case %d:\n", spc, i);
         regKunroll_ma(fpout, spc-3, LoopOrder, 0, ifetch, nfetch, rA, rB, rC, 
                       pA, pB, mu, nu, i, &offA, &offB, lda, ldb, mulA, mulB, 
                       incpA, incpB, incAk, incBk, rowA, rowB);
         fprintf(fpout, "%s      break;\n", spc);
      }
      fprintf(fpout, "%s   case 0: ;\n%s   }\n", spc, spc);
      sprintf(kadj, "k");
   }
   if ( (K && K%ku) || ku > 1)
   {
      if (incpA)
      {
         fprintf(fpout, "%s   %s0 -= %s*%s;\n", spc, pA, kadj, incAk);
         if (lda == 0 && TA != AtlasNoTrans)
            for (i=1; i < mu; i++)
               fprintf(fpout, "%s   %s%d -= %s*%s;\n", spc, pA, i, kadj, incAk);
      }
      if (incpB)
      {
         fprintf(fpout, "%s   %s0 -= %s*%s;\n", spc, pB, kadj, incBk);
         if (rowB && !ldb) 
            for (i=1; i < nu; i++) 
               fprintf(fpout, "%s   %s%d -= %s*%s;\n", spc, pB, i, kadj, incBk);
      }
   }
}

/*
 * regKunroll: K-loop unrolling for separate multiply and add instructions.
 * Unrolls k loop by ku, with mu unroll along inner matrix & nu along outer.
 * If actual inner matrix is B instead of A, pass B's data in A and vice versa,
 * and assign pC[i][j] = rCji.
 * Assumes lat flops of this iteration done previously, lat of next done here,
 * Present flop to be done is (iop,jop) of the mu*nu to be done.
 * assumes ifetch has enough data for all lat operations !!!!
 */
int regKunroll(FILE *fpout,
               char *spc,  /* indentation string */
               enum ATLAS_LOOP_ORDER LoopOrder,
               int ifetch, /* number of initial fetches to perform */
               int nfetch, /* # of fetches to perform for every flop */
               int lat,    /* skew of K-loop */
               int STARTUP,/* 0: not starting pipeline, else doing so */
               int Asg1stC,/* 1: first C update gets =, instead of += */
               char *rA,   /* varnam for registers of inner matrix */
               char *rB,   /* varnam for registers of outer matrix */
               char *rC,   /* varnam for registers of C */
               char *pA,   /* varnam for pointer(s) to inner matrix */
               char *pB,   /* varnam for pointer(s) to outer matrix */
               int mu,     /* unrolling along inner loop */
               int nu,     /* unrolling along outer loop */
               int ku,     /* unrolling along k-loop (innermost) */
               int *offA,  /* offset to first elt of this block */
               int *offB,  /* offset to first elt of this block */
               int lda,    /* row stride; if 0, row stride is arbitrary */
               int ldb,    /* row stride; if 0, row stride is arbitrary */
               int mulA,   /* col stride; 1: real 2: cplx */
               int mulB,   /* col stride; 1: real 2: cplx */
               int incpA,  /* Increment A for every K iteration? */
               int incpB,  /* Increment B for every K iteration? */
               char *incAk,  /* if !rowA, k-loop increment for ptrs */
               char *incBk,  /* if !rowB, k-loop increment for ptrs */
               int rowA, /* if 0, fetch within col, else fetch within row */
               int rowB, /* if 0, fetch within col, else fetch within row */
               int *ia,    /* elt of inner matrix to be fetched */
               int *ib,    /* elt of outer matrix to be fetched */
               int *iop0,   /* 1st operand of inner matrix to use */
               int *jop0)   /* 1st operand of outer matrix to use */
{
   int i, j, k, h=0;
   int iop = *iop0, jop = *jop0;

   if (LoopOrder == AtlasIJK)
      return(regKunroll(fpout, spc, AtlasJIK, ifetch, nfetch, lat, STARTUP, 
                        Asg1stC, rB, rA, rC, pB, pA, nu, mu, ku, offB, offA,
                        ldb, lda, mulB, mulA, incpB, incpA, incBk, incAk,
                        rowB, rowA, ib, ia, jop0, iop0));
   if (STARTUP) fprintf(fpout, "/*\n *%s Start pipeline\n */\n", spc);
/*
 * If we have not fetched any data for this iteration yet, do so
 */
   if (STARTUP && *ia == 0 && *ib == 0) 
      opfetch(fpout, spc, ifetch, rA, rB, pA, pB, mu, nu, *offA, *offB, 
              lda, ldb, mulA, mulB, rowA, rowB, ia, ib);
/*
 * One iteration of the ku-unrolled K loop
 */
   for (k=0; k < ku; k++)
   {
      for (j=0; j < nu; j++)
      {
         for (i=0; i < mu; i++)
         {
            if (!STARTUP) 
            {
               if (Asg1stC && !k)
                  fprintf(fpout, "%s   %s%d_%d = m%d;\n", spc, rC, i, j, h);
               else
                  fprintf(fpout, "%s   %s%d_%d += m%d;\n", spc, rC, i, j, h);
            }
            fprintf(fpout, "%s   m%d = %s%d * %s%d;\n", 
                    spc, h, rA, iop, rB, jop);
            if (++iop == mu)
            {
               iop = 0;
               if (++jop == nu) /* used all this iteration's data */
               {
                  jop = 0;
                  incABk(fpout, spc, pA, pB, mu, nu, offA, offB, lda, ldb, 
                         mulA, mulB, incpA, incpB, incAk, incBk, rowA, rowB);
                  *ia = *ib = 0;
                  opfetch(fpout, spc, ifetch, rA, rB, pA, pB, mu, nu, 
                          *offA, *offB, lda, ldb, mulA, mulB, rowA, rowB, 
                          ia, ib);
               }
            }
            opfetch(fpout, spc, nfetch, rA, rB, pA, pB, mu, nu, *offA, *offB,
                    lda, ldb, mulA, mulB, rowA, rowB, ia, ib);
            if (++h == lat)
            {
               if (STARTUP)
               {
                  fprintf(fpout, "\n");
                  *iop0 = iop;
                  *jop0 = jop;
                  return(lat);
               }
               h = 0;
            }
         }
      }
   }
   *iop0 = iop;
   *jop0 = jop;
   return(h);
}

/* 
 * regKdrain: drains the pipe by explicitly unrolling last K iteration
 */
void regKdrain(FILE *fpout,
               char *spc,  /* indentation string */
               enum ATLAS_LOOP_ORDER LoopOrder,
               int ifetch, /* number of initial fetches to perform */
               int nfetch, /* # of fetches to perform for every flop */
               int lat,    /* skew of K-loop */
               char *rA,   /* varnam for registers of inner matrix */
               char *rB,   /* varnam for registers of outer matrix */
               char *rC,   /* varnam for registers of C */
               char *pA,   /* varnam for pointer(s) to inner matrix */
               char *pB,   /* varnam for pointer(s) to outer matrix */
               int mu,     /* unrolling along inner loop */
               int nu,     /* unrolling along outer loop */
               int ku,     /* unrolling along k-loop (innermost) */
               int *offA,  /* offset to first elt of this block */
               int *offB,  /* offset to first elt of this block */
               int lda,    /* row stride; if 0, row stride is arbitrary */
               int ldb,    /* row stride; if 0, row stride is arbitrary */
               int mulA,   /* col stride; 1: real 2: cplx */
               int mulB,   /* col stride; 1: real 2: cplx */
               int incpA,  /* Increment A for every K iteration? */
               int incpB,  /* Increment B for every K iteration? */
               char *incAk,  /* if !rowA, k-loop increment for ptrs */
               char *incBk,  /* if !rowB, k-loop increment for ptrs */
               int rowA, /* if 0, fetch within col, else fetch within row */
               int rowB, /* if 0, fetch within col, else fetch within row */
               int *ia,    /* elt of inner matrix to be fetched */
               int *ib,    /* elt of outer matrix to be fetched */
               int iop,   /* 1st operand of inner matrix to use */
               int jop,   /* 1st operand of outer matrix to use */
               int h)     /* */
{
   int i, j, k=0;
   int REGFETCH=1;

   if (LoopOrder == AtlasIJK)
   {
      regKdrain(fpout, spc, AtlasJIK, ifetch, nfetch, lat, rB, rA, rC,
                pB, pA, nu, mu, ku, offB, offA, ldb, lda, mulB, mulA,
                incpB, incpA, incBk, incAk, rowB, rowA, ib, ia, jop, iop, h);
      return;
   }
/*
 * Drain part of pipe where we are still doing multiplies.  Once iop and jop
 * reach mu/nu, we stop doing fetches
 */
   fprintf(fpout, "/*\n *%s Drain pipe on last iteration of K-loop\n */\n",
           spc);
@skip   if (lat == mu*nu && iop == 0 && jop == 0) { iop = mu; jop = nu; }
   for (j=0; j < nu; j++)
   {
      for (i=0; i < mu; i++)
      {
         fprintf(fpout, "%s   %s%d_%d += m%d;\n", spc, rC, i, j, h);
         if (iop < mu || jop < nu)
         {
            fprintf(fpout, "%s   m%d = %s%d * %s%d;\n", 
                    spc, h, rA, iop, rB, jop);
            if (++iop == mu)
            {
               iop = 0;
               if (++jop == nu) /* used all this iteration's data */
               {
                  REGFETCH = 0;
                  iop = mu;
                  incABk(fpout, spc, pA, pB, mu, nu, offA, offB, lda, ldb, 
                         mulA, mulB, incpA, incpB, incAk, incBk, rowA, rowB);
               }
            }
         }
         else k++;
         if (++h == lat) h = 0;
         if (REGFETCH)
            opfetch(fpout, spc, nfetch, rA, rB, pA, pB, mu, nu, *offA, *offB, 
                    lda, ldb, mulA, mulB, rowA, rowB, ia, ib);
      }
   }
/*
 * Drain last of pipe, where all we do is adds
 */
   while (k < lat)
   {
      for (j=0; j < nu && k < lat; j++)
      {
         for (i=0; i < mu && k < lat; i++, k++)
         {
            fprintf(fpout, "%s   %s%d_%d += m%d;\n", spc, rC, i, j, h);
            if (++h == lat) h = 0;
         }
      }
   }
}
void fetchC(FILE*,char*, enum ATLAS_LOOP_ORDER, int, int, int, int, char*,
            char*, int, int, int, int, int, char*);
/*
 * regKloop : Creates a full K-loop, unrolled by ku, assuming M & N
 * unrollings of mu & nu, using separate muladd instruction
 */
void regKloop(FILE *fpout, 
              char *spc,  /* indentation string */
              enum ATLAS_LOOP_ORDER LoopOrder,
              enum ATLAS_TRANS TA,
              enum ATLAS_TRANS TB,
              int AsgC1, /* if 0, 1st iter does cij = not cij += */
              int M,     /* if 0, M is arbitrary, else M is len of M-loop */
              int N,     /* if 0, N is arbitrary, else N is len of N-loop */
              int K,      /* if 0, K is arbitrary, else K is len of K-loop */
              int ifetch, /* number of initial fetches to perform */
              int nfetch, /* # of fetches to perform for every flop */
              int lat,    /* latency */
              char *rA,   /* varnam for registers of inner matrix */
              char *rB,   /* varnam for registers of outer matrix */
              char *rC,   /* varnam for registers holding C */
              char *pA,   /* varnam for pointer(s) to inner matrix */
              char *pB,   /* varnam for pointer(s) to outer matrix */
              int mu,     /* unrolling along inner loop */
              int nu,     /* unrolling along outer loop */
              int ku,     /* unrolling along k-loop (innermost) */
              int lda,    /* row stride: 0 = unknown */
              int ldb,    /* row stride: 0 = unknown */
              int mulA,   /* column stride: 1 = real, 2 = cplx */
              int mulB,   /* column stride: 1 = real, 2 = cplx */
              int incpA,  /* Increment A for every K iteration? */
              int incpB,  /* Increment B for every K iteration? */
              char *incAk,  /* if !rowA, k-loop increment for ptrs */
              char *incBk)  /* if !rowB, k-loop increment for ptrs */
{
   int k, Kb, Kpipe, Kloop, kr;
   int i, j, h;
   int rowA, rowB; /* mu/nu elts fetched from row? */
   int offA=0, offB=0, offA0, offB0;
   int ia=0, ib=0, iop=0, jop=0;
   char incAk0[64], incBk0[64];

   sprintf(incAk0, "%s0", incAk);
   sprintf(incBk0, "%s0", incBk);
   if (K)
   {
      Kb = K - K % ku;
      if (2*lat > K)
      {
         regKloop_ma(fpout, spc, LoopOrder, TA, TB, AsgC1, M, N, K, 
                     ifetch, nfetch, lat, rA, rB, rC, pA, pB, mu, nu, ku, 
                     lda, ldb, mulA, mulB, incpA, incpB, incAk, incBk);
         return;
      }
      assert (ku*2 <= K || K == ku);  /* need at least one iter. for loop */
   }
   if (K != ku)
   {
      if (K) i = mu*nu*ku;
      else i = mu*nu;
      if (i > lat) assert(i == ((i)/lat)*lat);
      else assert(lat == (lat/i)*i);
   }
@skip   assert( ifetch+nfetch*lat <= ku*(mu+nu) );

   if (TA == AtlasNoTrans) rowA = 0;
   else rowA = 1;
   if (TB == AtlasNoTrans) rowB = 1;
   else rowB = 0;


   if (K == ku)  /* fully unrolled loop */
   {
      regKunroll(fpout, spc, LoopOrder, ifetch, nfetch, lat, 1, AsgC1,
                 rA, rB, rC, pA, pB, mu, nu, ku, &offA, &offB, lda, ldb,
                 mulA, mulB, incpA, incpB, incAk, incBk, rowA, rowB, 
                 &ia, &ib, &iop, &jop);
      fprintf(fpout, "/*\n *%s Completely unrolled K-loop\n */\n", spc);
      i = ku - (lat/(mu*nu)) - 1;
      h = regKunroll(fpout, spc, LoopOrder, ifetch, nfetch, lat, 0, AsgC1,
                     rA, rB, rC, pA, pB, mu, nu, i, &offA, &offB, lda, ldb,
                     mulA, mulB, incpA, incpB, incAk, incBk, rowA, rowB,
                     &ia, &ib, &iop, &jop);
      regKdrain(fpout, spc, LoopOrder, ifetch, nfetch, lat, rA, rB, rC, pA, pB,
                mu, nu, ku, &offA, &offB, lda, ldb, mulA, mulB, incpA, incpB,
                incAk, incBk, rowA, rowB, &ia, &ib, iop, jop, h);
      if (!incpA)
      {
         fprintf(fpout, "%s   %s0 += %s;\n", spc, pA, incAk);
         if (lda == 0 && TA != AtlasNoTrans)
            for (i=1; i < mu; i++)
               fprintf(fpout, "%s   %s%d += %s;\n", spc, pA, i, incAk);
      }
      if (!incpB)
      {
         fprintf(fpout, "%s   %s0 += %s;\n", spc, pB, incBk);
         if (ldb == 0 && TB == AtlasNoTrans)
            for (i=1; i < nu; i++)
               fprintf(fpout, "%s   %s%d += %s;\n", spc, pB, i, incBk);
      }
   }
   else  /* unknown K != ku */
   {
      Kpipe = lat / (mu*nu) + 1;  /* its done in pipeline startup & drain */
      if (K)
      {
         Kloop = ((K-Kpipe)/ku)*ku;
         if (AsgC1 && ku <= MAX_CASG_KU && Kloop < ku)
         {
            regKloop_ma(fpout, spc, LoopOrder, TA, TB, AsgC1, M, N, K, 
                        ifetch, nfetch, lat, rA, rB, rC, pA, pB, mu, nu, ku, 
                        lda, ldb, mulA, mulB, incpA, incpB, incAk, incBk);
            return;
         }
         kr = K - Kpipe - Kloop;
      }
      else Kloop = kr = 0;
/*
 *    Issue pre-loop mulpipe fill, and increment ptrs if asked
 */
      offA0 = offA; offB0 = offB;
      regKunroll(fpout, spc, LoopOrder, ifetch, nfetch, lat, 1, 0, rA, rB, rC, 
                 pA, pB, mu, nu, ku, &offA, &offB, lda, ldb, mulA, mulB, 
                 incpA, incpB, incAk0, incBk0, rowA, rowB, 
                 &ia, &ib, &iop, &jop);
      k = Kpipe - 1;
      if (!incpA && k) /* need to increment the A pointers ourselves */
      {  
         fprintf(fpout, "%s   %s0 += %s;\n", spc, pA, GetInc(k, incAk0));
         if (rowA && !lda)
            for (i=1; i < mu; i++) 
               fprintf(fpout, "%s   %s%d += %s;\n", spc, pA, i, 
                       GetInc(k, incAk0));
      }
      if (!incpB && k) /* need to increment the B pointers ourselves */
      {
         fprintf(fpout, "%s   %s0 += %s;\n", spc, pB, GetInc(k, incBk0));
         if (rowB && !ldb) 
            for (i=1; i < nu; i++) 
               fprintf(fpout, "%s   %s%d += %s;\n", spc, pB, i, 
                       GetInc(k, incBk0));
      }
      offA = offA0; offB = offB0;  /* offsets stay as set by pipeline */

      if (AsgC1 && ku <= MAX_CASG_KU)
      {
         fprintf(fpout,
                 "/*\n *%s Peel first %d iterations for C assignment\n */\n", 
                 spc, ku);
         if (!K)
         {
            fprintf(fpout, "%s   if (Kloop >= %d)\n%s   {\n", spc, ku, spc);
            spc -= 3;
         }
/*
 *       Peel first iteration of unrolled loop to use C = rather than C +=
 */
         h = regKunroll(fpout, spc, LoopOrder, ifetch, nfetch, lat, 0, 1, 
                        rA, rB, rC, pA, pB, mu, nu, ku, &offA, &offB, lda, ldb,
                        mulA, mulB, incpA, incpB, incAk, incBk, rowA, rowB, 
                        &ia, &ib, &iop, &jop);
         if (!incpA) /* need to increment the A pointers ourselves */
         {  
            fprintf(fpout, "%s   %s0 += %s;\n", spc, pA, incAk);
            if (rowA && !lda)
               for (i=1; i < mu; i++) 
                  fprintf(fpout, "%s   %s%d += %s;\n", spc, pA, i, incAk);
         }
         if (!incpB) /* need to increment the B pointers ourselves */
         {
            fprintf(fpout, "%s   %s0 += %s;\n", spc, pB, incBk);
            if (rowB && !ldb) 
               for (i=1; i < nu; i++) 
                  fprintf(fpout, "%s   %s%d += %s;\n", spc, pB, i, incBk);
         }
         fprintf(fpout, "/*\n *%s Unpeeled K iterations\n */\n", spc);
         if (K)
         {
            if (ku == 1) 
              fprintf(fpout, 
                      "%s   for (k=0; k < %d; k++) /* easy loop to unroll */\n",
                       spc, Kloop-1);
            else fprintf(fpout, 
                 "%s   for (k=0; k < %d; k += %d) /* easy loop to unroll */\n",
                         spc, Kloop-ku, ku);
         }
         else if (ku == 1) 
            fprintf(fpout, 
            "%s   for (k=1; k < Kloop; k++) /* easy loop to unroll */\n", spc);
         else fprintf(fpout, 
              "%s   for (k=%d; k < Kloop; k += %d) /* easy loop to unroll */\n",
                      spc, ku, ku);
         offA = offA0;  offB = offB0;
      }
      else if (K)
      {
#ifdef ICC_IS_RETARDED
         if (ku == 1) 
           fprintf(fpout, 
                   "%s   for (k=0; k < %d; k++) /* easy loop to unroll */\n",
                    spc, Kloop);
         else fprintf(fpout, 
                  "%s   for (k=0; k < %d; k += %d) /* easy loop to unroll */\n",
                      spc, Kloop, ku);
#else
         if (ku == 1) 
           fprintf(fpout, "%s   for (k=%d; k; k--) /* easy loop to unroll */\n",
                    spc, Kloop);
         else fprintf(fpout, 
                      "%s   for (k=%d; k; k -= %d) /* easy loop to unroll */\n",
                      spc, Kloop, ku);
#endif
      }
      else
      {
#ifdef ICC_IS_RETARDED
         if (ku == 1) 
            fprintf(fpout, 
            "%s   for (k=0; k < Kloop; k++) /* easy loop to unroll */\n", spc);
         else fprintf(fpout, 
              "%s   for (k=0; k < Kloop; k += %d) /* easy loop to unroll */\n",
                      spc, ku);
#else
         if (ku == 1) 
            fprintf(fpout, 
                    "%s   for (k=Kloop; k; k--) /* easy loop to unroll */\n",
                    spc);
         else fprintf(fpout, 
                 "%s   for (k=Kloop; k; k -= %d) /* easy loop to unroll */\n",
                      spc, ku);
#endif
      }
      fprintf(fpout, "%s   {\n", spc);
      spc -= 3;
      h = regKunroll(fpout, spc, LoopOrder, ifetch, nfetch, lat, 0, 0, 
                     rA, rB, rC, pA, pB, mu, nu, ku, &offA, &offB, lda, ldb,
                     mulA, mulB, incpA, incpB, incAk, incBk, rowA, rowB, 
                     &ia, &ib, &iop, &jop);
      if (!incpA) /* need to increment the A pointers ourselves */
      {  
         fprintf(fpout, "%s   %s0 += %s;\n", spc, pA, incAk);
         if (rowA && !lda)
            for (i=1; i < mu; i++) 
               fprintf(fpout, "%s   %s%d += %s;\n", spc, pA, i, incAk);
      }
      if (!incpB) /* need to increment the B pointers ourselves */
      {
         fprintf(fpout, "%s   %s0 += %s;\n", spc, pB, incBk);
         if (rowB && !ldb) 
            for (i=1; i < nu; i++) 
               fprintf(fpout, "%s   %s%d += %s;\n", spc, pB, i, incBk);
      }
      spc += 3;
      fprintf(fpout, "%s   } /* end K-loop */\n", spc);
      if (!K && AsgC1 && ku <= MAX_CASG_KU)
      {
         spc += 3;
         fprintf(fpout, "%s   }\n", spc);
         fprintf(fpout, "%s   else\n%s   {\n", spc, spc);
         spc -= 3;
         fetchC(fpout, spc, LoopOrder, 0, mu, nu, 0, NULL, rC, 1, 0, 0, 0, 1, 
                NULL);
         spc += 3;
         fprintf(fpout, "%s   }\n", spc);
      }
      if (kr)
      {
         offA = offA0;  offB = offB0;
         h = regKunroll(fpout, spc, LoopOrder, ifetch, nfetch, lat, 0, 0,
                        rA, rB, rC, pA, pB, mu, nu, kr, &offA, &offB, 
                        lda, ldb, mulA, mulB, incpA, incpB, incAk, incBk, 
                        rowA, rowB, &ia, &ib, &iop, &jop);
         if (!incpA) /* need to increment the A pointers ourselves */
         {  
            fprintf(fpout, "%s   %s0 += %s;\n", spc, pA, GetInc(kr, incAk0));
            if (rowA && !lda)
               for (i=1; i < mu; i++) 
                  fprintf(fpout, "%s   %s%d += %s;\n", spc, pA, i, 
                          GetInc(kr, incAk0));
         }
         if (!incpB) /* need to increment the B pointers ourselves */
         {
            fprintf(fpout, "%s   %s0 += %s;\n", spc, pB, GetInc(kr, incBk0));
            if (rowB && !ldb) 
               for (i=1; i < nu; i++) 
                  fprintf(fpout, "%s   %s%d += %s;\n", spc, pB, i, 
                          GetInc(kr, incBk0));
         }
      }
      else if (K == 0 && ku != 1)
      {
         fprintf(fpout, "%s   switch(kr)\n%s   {\n", spc, spc);
         for (i=1; i < ku; i++)
         {
            fprintf(fpout, "%s   case %d:\n", spc, i);
            spc -= 3;
            offA = offA0;  offB = offB0;
            regKunroll(fpout, spc, LoopOrder, ifetch, nfetch, lat, 0, 0,
                       rA, rB, rC, pA, pB, mu, nu, i, &offA, &offB, 
                       lda, ldb, mulA, mulB, incpA, incpB, incAk, incBk, 
                       rowA, rowB, &ia, &ib, &iop, &jop);
            if (!incpA) /* need to increment the A pointers ourselves */
            {  
               fprintf(fpout, "%s   %s0 += %s;\n", spc, pA, GetInc(i, incAk0));
               if (rowA && !lda)
                  for (j=1; j < mu; j++) 
                     fprintf(fpout, "%s   %s%d += %s;\n", spc, pA, j, 
                             GetInc(i, incAk0));
            }
            if (!incpB) /* need to increment the B pointers ourselves */
            {
               fprintf(fpout, "%s   %s0 += %s;\n", spc, pB, GetInc(i, incBk0));
               if (rowB && !ldb) 
                  for (j=1; j < nu; j++) 
                     fprintf(fpout, "%s   %s%d += %s;\n", spc, pB, j, 
                             GetInc(i, incBk0));
            }
            spc += 3;
            fprintf(fpout, "%s      break;\n", spc);
         }
         fprintf(fpout, "%s   case 0: ;\n%s   }\n", spc, spc);

@beginskip
         if (!incpA) /* need to increment the A pointers ourselves */
         {  
            fprintf(fpout, "%s   k = kr * %s;\n", incAk0);
            fprintf(fpout, "%s   %s0 += k;\n", spc, pA);
            if (rowA && !lda)
               for (i=1; i < mu; i++) 
                  fprintf(fpout, "%s   %s%d += k;\n", spc, pA, i);
         }
         if (!incpB) /* need to increment the B pointers ourselves */
         {
            fprintf(fpout, "%s   k = kr * %s;\n", incBk0);
            fprintf(fpout, "%s   %s0 += k;\n", spc, pB);
            if (rowB && !ldb) 
               for (i=1; i < nu; i++) 
                  fprintf(fpout, "%s   %s%d += k;\n", spc, pB, i);
         }
         fprintf(fpout, "%s   }\n", spc);
@endskip
      }
      offA = offA0;  offB = offB0;
      regKdrain(fpout, spc, LoopOrder, ifetch, nfetch, lat, rA, rB, rC, pA, pB,
                mu, nu, ku, &offA, &offB, lda, ldb, mulA, mulB, incpA, incpB,
                incAk0, incBk0, rowA, rowB, &ia, &ib, iop, jop, h);
      if (!incpA)
      {
         fprintf(fpout, "%s   %s0 += %s;\n", spc, pA, incAk0);
         if (rowA && !lda)
            for (i=1; i < mu; i++) 
               fprintf(fpout, "%s   %s%d += %s;\n", spc, pA, i, incAk0);

      }
      if (!incpB)
      {
         fprintf(fpout, "%s   %s0 += %s;\n", spc, pB, incBk0);
         if (rowB && !ldb) 
            for (i=1; i < nu; i++) 
               fprintf(fpout, "%s   %s%d += %s;\n", spc, pB, i, incBk0);
      }
   }
}

void DoPrefA_lda0(FILE *fpout, char *spc, char pre, int nprefA, int FIRST)
/*
 * DoPrefA_lda0: issues prefetch instructions to prefetch next block of A
 * when lda is unknown; we call this routine inside N loop, but split 1/2
 * pref inst before M loop, and other half at end of N loop
 */
{
   int i, k, size, npref, stpref;

   size = (pre == 's' || pre == 'c') ? 4 : 8;
/*
 * For small prefetch, do all prefetch at top of loop
 * NOTE: use this always, as splitting doesn't seem to help
 */
   if (nprefA <= 2 || 1)
   {
      if (FIRST)
      {
         for (i=0; i < nprefA; i++)
            fprintf(fpout, "%s   ATL_pfl1R(pfA+%d);\n", spc, i*(ATL_L1LS/size));
         fprintf(fpout, "%s   pfA += lda;\n", spc);
      }
   }
/*
 * If issuing initial prefetch at top of N-loop and we have a bunch
 * of prefetches to do (worth splitting between top and bottom of loop)
 */
   else if (FIRST)
   {
      nprefA = (nprefA+1)/2;
      for (i=0; i < nprefA; i++)
         fprintf(fpout, "%s   ATL_pfl1R(pfA+%d);\n", spc, i*(ATL_L1LS/size));
   }
/*
 * If issuing trailing prefetch at bottom of N-loop
 */
   else
   {
      k = ((nprefA+1)/2)*(ATL_L1LS/size);
      nprefA = nprefA/2;
      for (i=0; i < nprefA; i++)
         fprintf(fpout, "%s   ATL_pfl1R(pfA+%d);\n", spc, k+i*(ATL_L1LS/size));
      fprintf(fpout, "%s   pfA += lda;\n", spc);
   }
}

void DoPrefA(FILE *fpout, char *spc, int nprefA)
/*
 * DoPrefA: issues prefetch instructions to prefetch next block of A;
 * we call this routine inside M & N loop, but outside K-loop
 */
{
   int i;

   if (nprefA < 1) return;
   fprintf(fpout, "%s   ATL_pfl1R(pfA);\n", spc);
   if (nprefA > 1)
      fprintf(fpout, "%s   ATL_pfl1R(pfA+ATL_L1LS);\n", spc);
   for (i=3; i < nprefA; i++)
      fprintf(fpout, "%s   ATL_pfl1R(pfA+%d*ATL_L1LS);\n", spc, i);
   fprintf(fpout, "%s   pfA += incPFA;\n", spc);
}

/*
 * fetchC : fetches mu*nu elts of C, & applies beta
 * If LoopOrder is IJK, we will pass B in as A, so we need to transpose C
 */
void fetchC(FILE *fpout,
            char *spc,
            enum ATLAS_LOOP_ORDER LoopOrder,
            int ForceFetch,  /* fetch C even if beta==0? */
            int mu,          /* unroll of inner loop */
            int nu,          /* unroll of outer loop */
            int offC,    /* offset to start of C */
            char *pC,    /* varnam of pointer to C */
            char *rC,    /* register name for elts of C */
            int mul,     /* stride in elts of C in column (1=real, 2=cplx) */
            int ldc,     /* if 0: use ptrs for cols of C; else row stride */
            int alpha,
            int beta,
            int fetch,   /* 0: just do lame pref, don't actually fetch C */
            char *reg)   /* name of unrelated register for beta */
{
   int i, j;
/*
 * If we aren't fetching C, only thing to do is ForceFetch, and we might
 * as well act as if beta = 0 
 */
   if (!fetch)
   {
      if (!ForceFetch) return;
      beta = 0;
   }
   if (ForceFetch && beta == 0) /* lame-ass prefetch on C */
   {
      fprintf(fpout, "/*\n *%s Feeble prefetch of C\n */\n", spc);
      for (j=0; j < nu; j++)
      {
         fprintf(fpout, "%s   %s%d_%d = ", spc, rC, 0, j);
         if (ldc)
         {
            if (offC+j) fprintf(fpout, "%s0[%d];\n", pC, offC+(j*ldc)*mul);
            else fprintf(fpout, "*%s0;\n", pC);
         }
         else
         {
            if (offC) fprintf(fpout, "%s%d[%d];\n", pC, j, offC);
            else fprintf(fpout, "*%s%d;\n", pC, j);
         }
      }
      if (!fetch) return;
   }
   else if ( (beta && alpha != SAFE_ALPHA) )
   {
      if (alpha != 1)
         fprintf(fpout, "%s   %s = BetaAlpha;\n", spc, reg);
      else if (beta != 1 && beta != -1 && beta != 0)
         fprintf(fpout, "%s   %s = beta;\n", spc, reg);
      for (j=0; j < nu; j++)
      {
         for (i=0; i < mu; i++)
         {
            if (LoopOrder == AtlasJIK) 
               fprintf(fpout, "%s   %s%d_%d = ", spc, rC, i, j);
            else if (LoopOrder == AtlasIJK) 
               fprintf(fpout, "%s   %s%d_%d = ", spc, rC, j, i);
            if (ldc)
            {
               if (offC+i+j) 
                  fprintf(fpout, "%s0[%d];\n", pC, offC+(j*ldc+i)*mul);
               else fprintf(fpout, "*%s0;\n", pC);
            }
            else
            {
               if (offC+i) fprintf(fpout, "%s%d[%d];\n", pC, j, offC+i*mul);
               else fprintf(fpout, "*%s%d;\n", pC, j);
            }
            if (beta == -1) fprintf(fpout, "%s   %s%d_%d = -%s%d_%d;\n", 
                                    spc, rC, i, j, rC, i, j);
            else if (beta != 1 && beta != 0 || alpha != 1)
               fprintf(fpout, "%s   %s%d_%d *= %s;\n", spc, rC, i, j, reg);
         }
      }
   }
   if (beta == 0 || alpha == SAFE_ALPHA)
   {
      fprintf(fpout, "%s   ", spc);
      for (j=0; j < nu; j++)
         for (i=0; i < mu; i++) fprintf(fpout, "%s%d_%d = ", rC, i, j);
      fprintf(fpout, "0.0;\n");
   }
}

void IncPtrs(FILE *fpout,
             char *spc, 
             int np,    /* number of pointers to increment */
             char var,  /* variable: A, B, C */
             char loop) /* which loop: n, m, k */
{
   int i;

   for (i=0; i < np; i++)
      fprintf(fpout, "%s   p%c%d += inc%c%c;\n", spc, var, i, var, loop);
}
             
void Cass(FILE *fpout,
          char *spc,
          enum ATLAS_LOOP_ORDER LoopOrder,
          int LoadC,   /* 1 load C & apply beta before assignment */
          int mu,      /* unroll of inner loop */
          int nu,      /* unroll of outer loop */
          int alpha,
          int beta,
          int offC,    /* offset to start of C */
          char *rA,    /* register name for elts of A */
          char *rB,    /* register name for elts of B */
          char *pC,    /* varnam of pointer to C */
          char *rC,    /* register name for elts of C */
          int mulC,     /* stride in elts of C in column (1=real, 2=cplx) */
          int ldc,     /* if 0: use ptrs for cols of C; else row stride */
          char *incC)  /* increment for this loop; if NULL don't use */
{
   int i, j;
   char *cp, calpha[32], Cderef[32];
   int AlphaReg = (nu > 1);

   if (!beta) LoadC = 0;  /* never load C if beta == 0.0 */
   if (LoadC && alpha == SAFE_ALPHA) alpha = SAFE_ALPHA - 1;
   if (alpha == SAFE_ALPHA) 
   {
      if (LoopOrder == AtlasIJK)
      {
         cp = rA;
         rA = rB;
         rB = cp;
         if (nu > 1) sprintf(calpha, "%s1", rB);
         else sprintf(calpha, "alpha");
      }
      else
      {
         if (nu > 1) sprintf(calpha, "%s1", rB);
         else sprintf(calpha, "alpha");
      }
      fprintf(fpout, "%s   %s0 = beta;\n", spc, rB);
      if (AlphaReg) fprintf(fpout, "%s   %s = alpha;\n", spc, calpha);
      for (j=0; j < nu; j++)
      {
         for (i=0; i < mu; i++)
         {
            fprintf(fpout, "%s   %s%d_%d *= %s;\n", spc, rC, i, j, calpha);
            if (ldc) fprintf(fpout, "%s   %s%d = %s0[%d];\n", 
                             spc, rA, i, pC, mulC*(j*ldc+i));
            else fprintf(fpout, "%s   %s%d = %s%d[%d];\n", 
                         spc, rA, i, pC, j, i*mulC);
            fprintf(fpout, "%s   %s%d_%d += %s0 * %s%d;\n", 
                    spc, rC, i, j, rB, rA, i);
         }
      }
   }
   else if (alpha != 1)
   {
      fprintf(fpout, "%s   %s0 = alpha;\n", spc, rB);
      for (i=0; i < mu; i++)
      {
         for (j=0; j < nu; j++)
         {
            if (LoopOrder == AtlasJIK) 
               fprintf(fpout, "%s   %s%d_%d *= %s0;\n", spc, rC, i, j, rB);
            else if (LoopOrder == AtlasIJK) 
               fprintf(fpout, "%s   %s%d_%d *= %s0;\n", spc, rC, j, i, rB);
         }
      }
   }
   if (LoadC && beta != 0 && beta != 1)
         fprintf(fpout, "%s   %s0 = beta;\n", spc, rB);
   for (j=0; j < nu; j++)
   {
      for (i=0; i < mu; i++)
      {
         if (ldc)
         {
            if (offC+j+i) sprintf(Cderef, "%s0[%d]", pC, offC+(ldc*j+i)*mulC);
            else sprintf(Cderef, "*%s0", pC);
         }
         else
         {
            if (i) sprintf(Cderef, "%s%d[%d]", pC, j, i*mulC);
            else sprintf(Cderef, "*%s%d", pC, j);
         }
         fprintf(fpout, "%s   %s", spc, Cderef);
         if (LoadC)
         {
            if (beta == 1)
               fprintf(fpout, " += ");
            else if (beta == 0)
               fprintf(fpout, " = ");
            else
               fprintf(fpout, " = %s * %s0 + ", Cderef, rB);
            if (LoopOrder == AtlasJIK) 
               fprintf(fpout, "%s%d_%d;\n", rC, i, j);
            else if (LoopOrder == AtlasIJK) 
               fprintf(fpout, "%s%d_%d;\n", rC, j, i);
         }
         else
         {
            if (LoopOrder == AtlasJIK) 
               fprintf(fpout, " = %s%d_%d;\n", rC, i, j);
            else if (LoopOrder == AtlasIJK) 
               fprintf(fpout, " = %s%d_%d;\n", rC, j, i);
         }
@beginskip
         if (ldc)
         {
            if (offC+j+i)
               fprintf(fpout, "%s   %s0[%d] = ", spc, pC, offC+(ldc*j+i)*mulC);
            else fprintf(fpout, "%s   *%s0 = ", spc, pC);
         }
         else
         {
            if (i) fprintf(fpout, "%s   %s%d[%d] = ", spc, pC, j, i*mulC);
            else fprintf(fpout, "%s   *%s%d = ", spc, pC, j);
         }
         if (LoopOrder == AtlasJIK) fprintf(fpout, "%s%d_%d;\n", rC, i, j);
         else if (LoopOrder == AtlasIJK) fprintf(fpout, "%s%d_%d;\n", rC, j,i);
@endskip
      }
   }
}

#define RegCallSeq 1
void CallMM(FILE *fpout, char *spc, char pre, char *loopstr, 
            int CleanUp, enum ATLAS_TRANS TA, enum ATLAS_TRANS TB,
            int M, int N, int K, int mu, int nu, int ku, int alpha, int beta, 
            int lda, int ldb, int ldc, int Mb, int Nb, int Kb, 
            char *cA, char *cB, char *cC, char *cM, char *cN, char *cK)
{
   char cTA='N', cTB='N';

   if (TA == AtlasTrans) cTA = 'T';
   else if (TA == AtlasConjTrans) cTA = 'C';
   if (TB == AtlasTrans) cTB = 'T';
   else if (TB == AtlasConjTrans) cTB = 'C';

   if (CleanUp)
      fprintf(fpout, "%s   ATL_%c%s%dx%dx%d%c%c%dx%dx%d", spc, pre, loopstr, 
              M, N, K, cTA, cTB, mu, nu, ku);
   else
      fprintf(fpout, "%s   ATL_%c%s%dx%dx%d%c%c%dx%dx%d", spc, pre, loopstr, 
              M, N, K, cTA, cTB, lda, ldb, ldc);

   if (alpha == 1) fprintf(fpout, "_a1");
   else if (alpha == -1) fprintf(fpout, "_an1");
   else if (alpha == SAFE_ALPHA) fprintf(fpout, "_aXX");
   else fprintf(fpout, "_aX");
   if (beta == 1 || beta == 0) fprintf(fpout, "_b%d(", beta);
   else if (beta == -1) fprintf(fpout, "_bn1(");
   else fprintf(fpout, "_bX(");
   if (M) fprintf(fpout, "%d, ", M);
   else fprintf(fpout, "%s, ", cM);
   if (N) fprintf(fpout, "%d, ", N);
   else fprintf(fpout, "%s, ", cN);
   if (K) fprintf(fpout, "%d, ", K);
   else fprintf(fpout, "%s, ", cK);
   if ((alpha != 1 && alpha != -1) || RegCallSeq) fprintf(fpout, "alpha, ");
   fprintf(fpout, "%s, ", cA);
   if (!lda || RegCallSeq) fprintf(fpout, "lda, ");
   fprintf(fpout, "%s, ", cB);
   if (!ldb || RegCallSeq) fprintf(fpout, "ldb, ");
   if ( (beta != 1 && beta != 0 && beta != -1) || RegCallSeq) 
      fprintf(fpout, "beta, ");
   fprintf(fpout, "%s", cC);
   if (!ldc || RegCallSeq) fprintf(fpout, ", ldc");
   fprintf(fpout, ");\n");
}

void MMDeclare(FILE *fpout, char *spc, char pre, char *type, char *decmod, 
               char *loopstr, enum ATLAS_TRANS TA, enum ATLAS_TRANS TB, 
               int M, int N, int K, int mu, int nu, int ku, 
               int alpha, int beta, int lda, int ldb, int ldc, int pfA)
{
   char cTA='N', cTB='N';

   if (TA == AtlasTrans) cTA = 'T';
   else if (TA == AtlasConjTrans) cTA = 'C';
   if (TB == AtlasTrans) cTB = 'T';
   else if (TB == AtlasConjTrans) cTB = 'C';
/*
 * For cleanup, put unrolling in name to distinguish from original function.
 * For regular function, encode leading dimensions instead
 */
   if (decmod[0] == '\0')
      fprintf(fpout, "%svoid ATL_%c%s%dx%dx%d%c%c%dx%dx%d", 
              spc, pre, loopstr, M, N, K, cTA, cTB, lda, ldb, ldc);
   else
      fprintf(fpout, "%s%svoid ATL_%c%s%dx%dx%d%c%c%dx%dx%d", 
              spc, decmod, pre, loopstr, M, N, K, cTA, cTB, mu, nu, ku);
   if (alpha == 1) fprintf(fpout, "_a1");
   else if (alpha == -1) fprintf(fpout, "_an1");
   else if (alpha == SAFE_ALPHA) fprintf(fpout, "_aXX");
   else fprintf(fpout, "_aX");
   if (beta == 1 || beta == 0) fprintf(fpout, "_b%d", beta);
   else if (beta == -1) fprintf(fpout, "_bn1");
   else fprintf(fpout, "_bX");
   fprintf(fpout, "\n   (");
   if (!M || RegCallSeq) fprintf(fpout, "const int M, ");
   if (!N || RegCallSeq) fprintf(fpout, "const int N, ");
   if (!K || RegCallSeq) fprintf(fpout, "const int K, ");
   if ( (alpha != 1 && alpha != -1) || RegCallSeq)
      fprintf(fpout, "const %s alpha, ", type);
   fprintf(fpout, "const %s * ATL_RESTRICT A, ", type);
   if (!lda || RegCallSeq) fprintf(fpout, "const int lda, ");
   fprintf(fpout, "const %s * ATL_RESTRICT B, ", type);
   if (!ldb || RegCallSeq) fprintf(fpout, "const int ldb, ");
   if (beta != 1 && beta != -1 && beta != 0 || RegCallSeq)
      fprintf(fpout, "const %s beta, ", type);
   fprintf(fpout, "%s * ATL_RESTRICT C", type);
   if (!ldc || RegCallSeq) fprintf(fpout, ", const int ldc");
   fprintf(fpout, ")\n");
   fprintf(fpout, "/*\n * matmul with TA=%c, TB=%c, MB=%d, NB=%d, KB=%d, \n", 
           cTA, cTB, M, N, K);
   fprintf(fpout, " * lda=%d, ldb=%d, ldc=%d, mu=%d, nu=%d, ku=%d, pf=%d\n",
           lda, ldb, ldc, mu, nu, ku, pfA);
   fprintf(fpout, " * Generated by ATLAS/tune/blas/gemm/emit_mm.c (@(ver))\n");
   fprintf(fpout, " */\n");
}

static int ncucases=0;
static int cucases[64][7];
/* 
 * For every operand involved in a given loop, we pass:
 *  ldx : if 0, use pointer for each column, and moving between columns is
 *              accomplished by incrementing by constant passed in string incX
 *        else: use only 1 pointer, increment by ldx move between columns
 */
void emit_mm(FILE *fpout, 
             char *spc,  /* indentation string */
             char pre,
             char *type,
             char *decmod,  /* routine declaration modifier (eg. static) */
             enum ATLAS_LOOP_ORDER LoopOrder,
             enum ATLAS_TRANS TA,
             enum ATLAS_TRANS TB,
             int CleanUp, /* 1 : issue cleanup code, 0: do not */
             int muladd, /* 0: separate mult & add, ELSE: combined muladd */
             int prefA,  /* 0: don't prefetch nxt blk of A */
             int lat,    /* pipeline length */
             int ForceFetch,
             int ifetch, /* number of initial fetches to perform */
             int nfetch, /* # of fetches to perform for every flop */
             int M,      /* if 0, M is arbitrary, else M is len of M-loop */
             int N,      /* if 0, N is arbitrary, else N is len of N-loop */
             int K,      /* if 0, K is arbitrary, else K is len of K-loop */
             int mu,     /* unrolling along inner loop */
             int nu,     /* unrolling along outer loop */
             int ku,     /* unrolling along k-loop (innermost) */
             int mulA,   /* column stride: 1 = real, 2 = cplx */
             int mulB,   /* column stride: 1 = real, 2 = cplx */
             int mulC,   /* column stride: 1 = real, 2 = cplx */
             int lda,    /* row stride: 0 = unknown */
             int ldb,    /* row stride: 0 = unknown */
             int ldc,    /* row stride: 0 = unknown */
             int alpha,
             int beta)

{
   char *lstr[2] = {"IJK", "JIK"};
   char *incAk="incAk", *incBk="incBk";
   char *rA = "rA";   /* varnam for registers holding A */
   char *rB = "rB";   /* varnam for registers of B */
   char *rC = "rC";
   char *pA = "pA";   /* varnam for pointer(s) to A */
   char *pB = "pB";   /* varnam for pointer(s) to B */
   char *pC = "pC";
   char *op, *ip;
   char outmat, innmat, OUTMAT, INNMAT;
   char cA[64], cB[64], cC[64], ctmp[64];
   char ln[64];
   int i, j, k, kuA, kuB, AsgC1, LdBott;
   int size = 8;
   int muC, nuC;
   int Mb, Nb, Kb, Kb0;
   int Aptrs, Bptrs, OuterLoop, OuterTest, InnerLoop, InnerTest, lat2;
   int incpA, incpB;
   int CleanN=0, Cleaning=0;
   int CleaningM=0, CleaningN=0;
   int nprefA = 0, prefA1=prefA, prefA2=0;
   KLOOPFUNC kloop;

   if (pre == 's' || pre == 'c')
     size = 4;
   if (CleanUp) CleaningM = CleaningN = 1;
   cucases[ncucases][0] = mu;
   cucases[ncucases][1] = nu;
   cucases[ncucases][2] = ku;
   cucases[ncucases][3] = LoopOrder;
   cucases[ncucases][4] = M;
   cucases[ncucases][5] = N;
   cucases[ncucases][6] = K;
   ncucases++;
/*
 * Error checks
 */
   assert(mulA == 1 || mulA == 2);
   assert(mulB == 1 || mulB == 2);
   assert(mulC == 1 || mulC == 2);
   assert(K >= 0 && M >= 0 && N >= 0);
   assert(mu > 0 && nu > 0 && ku > 0);
   if (M) if (mu > M) mu = M;
   if (N) if (nu > N) nu = N;
   if (K)
   {
      if (2*ku > K) ku = K;
      if (2*lat > K) muladd = lat = 1;  /* no use in pipelining short loop */
   }
   if (K != ku && !muladd)
   {
      if (K) i = mu*nu*ku;
      else i = mu*nu;
      assert(i == ((i)/lat)*lat);
@skip      if (i > lat) assert(i == ((i)/lat)*lat);
@skip      else assert(lat == (lat/i)*i);
   }
   if (ifetch == -1) ifetch = mu + nu;
   if (ifetch < mu+nu) assert(nfetch > 0);
/*
 * If there is a discrepency between the number of items fetched by entering
 * the loop, and not entering it (the K=0 case), fix it
 */
   if (K == 0 && muladd == 0 && lat < mu*nu)
      while(ifetch+nfetch*lat < mu+nu) ifetch++;
/*
 * If prefetch is selected, but lda != KB, do prefetch col-at-time
 */
   if (lda != K || K == 0)
   {
      prefA2 = prefA;
      prefA1 = 0;
   }

/*
 * If iterating in the K loop indexes A/B by non compile time constant, we
 * must increment that pointer at each step in the K loop, even if the K loop
 * is unrolled
 */
#if 0
   incpA = (lda == 0 && TA == AtlasNoTrans || ku == 1);
   incpB = (ldb == 0 && TB != AtlasNoTrans || ku == 1);
#else
   incpA = (lda == 0 && TA == AtlasNoTrans);
   incpB = (ldb == 0 && TB != AtlasNoTrans);
#endif
   if (incpA) kuA = 1;
   else kuA = ku;
   if (incpB) kuB = 1;
   else kuB = ku;

   if (muladd) kloop = regKloop_ma;
   else kloop = regKloop;

   PrintC99Defines(fpout, "");
   if (prefA1 || prefA2)
      fprintf(fpout, "#include \"atlas_prefetch.h\"\n\n");

   if (!muladd && !K)
   {
      for (k=0; k < ncucases; k++) 
         if (1==cucases[k][0] && 1==cucases[k][1] && 1==cucases[k][2]
             && LoopOrder == cucases[k][3] &&
             cucases[k][4]==M && cucases[k][5]==N && cucases[k][6]==K) break;
      if ( (k == ncucases) ||
           (1==cucases[0][0] && 1==cucases[0][1] && 1==cucases[0][2] &&
            ncucases == 1 && mu*nu <= lat) )
         emit_mm(fpout, spc, pre, type, "static ", LoopOrder, TA, TB, 1, 1,
                 prefA, lat, ForceFetch, ifetch, nfetch, M, N, 0, 1, 1, 1, 
                 mulA, mulB, mulC, lda, ldb, ldc, alpha, beta);
   }
   if (N)  /* generate N-cleanup, routine, if known */
   {
      if (N%nu)
      {
         if (K) lat2 = GetGoodLat(muladd, mu, N%nu, ku, lat);
         else lat2 = GetGoodLat(muladd, mu, N%nu, 1, lat);
         CleanN = Cleaning = 1;
         emit_mm(fpout, spc, pre, type, "static ", LoopOrder, TA, TB, 1, muladd,
                 prefA, lat2, ForceFetch, ifetch, nfetch, M, N%nu, K, 
                 mu, N%nu, ku, mulA, mulB, mulC, lda, ldb, ldc, alpha, beta);
      }
   }
   else if (nu > 1 && CleaningN) /* unknown N */
   {
      if (K) lat2 = GetGoodLat(muladd, mu, 1, ku, lat);
      else lat2 = GetGoodLat(muladd, mu, 1, 1, lat);
      CleanN = Cleaning = 1;
      for (k=0; k < ncucases; k++) 
         if (mu==cucases[k][0] && 1==cucases[k][1] && ku==cucases[k][2]
             && LoopOrder == cucases[k][3] &&
             cucases[k][4]==M && cucases[k][5]==N && cucases[k][6]==K) break;
      if (k == ncucases)
         emit_mm(fpout, spc, pre, type, "static ", LoopOrder, TA, TB, 1, muladd,
                 prefA, lat2, ForceFetch, ifetch, nfetch, M, 0, K, mu, 1, ku, 
                 mulA, mulB, mulC, lda, ldb, ldc, alpha, beta);
   }
   if (CleanN) i = N - N % nu;
   else i = N;
   if (M)
   {
      if (M%mu)
      {
         if (K) lat2 = GetGoodLat(muladd, M%mu, nu, ku, lat);
         else lat2 = GetGoodLat(muladd, M%mu, nu, 1, lat);
         Cleaning = 1;
         emit_mm(fpout, spc, pre, type, "static ", LoopOrder, TA, TB, !CleanN, 
                 muladd, prefA, lat2, ForceFetch, ifetch, nfetch, M%mu, i, K, 
                 M%mu, nu, ku, mulA, mulB, mulC, lda, ldb, ldc, alpha, beta);
      }
   }
   else if (mu > 1 && CleaningM)
   {
      Cleaning = 1;
      if (K) lat2 = GetGoodLat(muladd, 1, nu, ku, lat);
      else lat2 = GetGoodLat(muladd, 1, nu, 1, lat);
      for (k=0; k < ncucases; k++) 
         if (1==cucases[k][0] && nu==cucases[k][1] && ku==cucases[k][2]
             && LoopOrder == cucases[k][3] &&
             cucases[k][4]==M && cucases[k][5]==N && cucases[k][6]==K) break;
      if (k == ncucases)
         emit_mm(fpout, spc, pre, type, "static ", LoopOrder, TA, TB, 1, 
                 muladd, prefA, lat2, ForceFetch, ifetch, nfetch, 0, i, K, 1, 
                 nu, ku, mulA, mulB, mulC, lda, ldb, ldc, alpha, beta);
   }
/*
 * Name : ATL_<pre><IJK/JIK><MB>x<NB>x<KB>mm<mu>x<nu>x<ku>_aX_bX
 *        ATL_dJIK40x40x40mm4x4x1_a1_b1
 */
   MMDeclare(fpout, spc, pre, type, decmod, lstr[LoopOrder], TA, TB, M, N, K, 
             mu, nu, ku, alpha, beta, lda, ldb, ldc, prefA);
   fprintf(fpout, "{\n");

   if (LoopOrder == AtlasJIK)
   {
      muC = mu;
      nuC = nu;
      outmat = 'n';
      innmat  = 'm';
   }
   else
   {
      muC = nu;
      nuC = mu;
      outmat = 'm';
      innmat  = 'n';
   }
/*
 * Figure dimension size, in multiples of blocking factor
 */
   if (!M)
   {
      if (mu == 1) fprintf(fpout, "   #define Mb M\n");
      else
      {
         i = GetPower2(mu);
         if (i) fprintf(fpout, "   const int Mb = (M>>%d)<<%d;\n", i, i);
         else fprintf(fpout, "   const int Mb = (M/%d)*%d;\n", mu, mu);
      }
      Mb = 0;
   }
   else Mb = M - M%mu;
   if (!N)
   {
      if (nu == 1) fprintf(fpout, "   #define Nb N\n");
      else
      {
         i = GetPower2(nu);
         if (i) fprintf(fpout, "   const int Nb = (N>>%d)<<%d;\n", i, i);
         else fprintf(fpout, "   const int Nb = (N/%d)*%d;\n", nu, nu);
      }
      Nb = 0;
   }
   else Nb = N - N%nu;
   if (!K)
   {
      Kb = 0;
      i = GetPower2(ku);
      if (!muladd)
      {
         fprintf(fpout, "   #define Kb K\n");
         j = lat/(mu*nu) + 1;
         if (ku == 1)
            fprintf(fpout, "   const int Kloop = K - %d;\n", j);
         else
         {
            if (ku == 1)
            {
               fprintf(fpout, "   const int Kloop = K-%d;\n", j);
               fprintf(fpout, "   #define kr 0\n");
            }
            else
            {
               if (i) fprintf(fpout, 
                              "   const int Kloop = ((K-%d)>>%d)<<%d", j, i, i);
               else fprintf(fpout, 
                              "   const int Kloop = ((K-%d)/%d)*%d", j, ku, ku);
               fprintf(fpout, ", kr = K - Kloop - %d;\n", j);
            }
         }
      }
      else
      {
         if (ku == 1) fprintf(fpout, "   #define Kb K\n");
         else
         {
            if (i) fprintf(fpout, "   const int Kb = (K>>%d)<<%d;\n", i, i);
            else fprintf(fpout, "   const int Kb = (K/%d)*%d;\n", ku, ku);
         }
      }
   }
   else Kb = K - K%ku;
   Kb0 = Kb;
   if (!muladd) Kb = K;

   if (Cleaning)
      fprintf(fpout, "   const %s *ca=A, *cb=B;\n   %s *cc=C;\n", type, type);
/*
 * Figure loop boundary tests, stM & stN
 */
   if (TA == AtlasNoTrans)
   {
      if (M) fprintf(fpout, "   const %s *stM = A + %d;\n", 
                     type, mulA*Mb);
      else   fprintf(fpout, "   const %s *stM = A + %s;\n", 
                     type, GetInc(mulA, "Mb"));
   }
   else
   {
      if (M)
      {
         if (lda) fprintf(fpout, "   const %s *stM = A + %d;\n", 
                          type, Mb*lda*mulA);
         else fprintf(fpout, "   const %s *stM = A + %s;\n", 
                      type, GetInc(Mb*mulA, "lda"));
      }
      else if (lda) fprintf(fpout, "   const %s *stM = A + %s;\n", 
                            type, GetInc(mulA*lda, "Mb"));
      else fprintf(fpout, "   const %s *stM = A + %s;\n", 
                   type, GetInc(mulA, "lda*Mb"));
   }
   if (TB == AtlasNoTrans)
   {
      if (N)
      {
         if (ldb) fprintf(fpout, "   const %s *stN = B + %d;\n", 
                          type, Nb*ldb*mulB);
         else fprintf(fpout, "   const %s *stN = B + %s;\n", 
                      type, GetInc(Nb*mulB, "ldb"));
      }
      else if (ldb) fprintf(fpout, "   const %s *stN = B + %s;\n", 
                            type, GetInc(mulB*ldb, "Nb"));
      else fprintf(fpout, "   const %s *stN = B + %s;\n", 
                   type, GetInc(mulB, "ldb*Nb"));
   }
   else
   {
      if (N) fprintf(fpout, "   const %s *stN = B + %d;\n",
                     type, mulB*Nb);
      else   fprintf(fpout, "   const %s *stN = B + %s;\n", 
                     type, GetInc(mulB, "Nb"));
   }
   if (prefA1)
   {
      fprintf(fpout, "   const %s *pfA = stM;\n", type);
      if (N && M)
      {
         fprintf(fpout, 
      "   const int incPFA0 = (((int)(stM - A))*%d*%d)/(%d*%d);\n",
                 mu, nu, M, N);
      }
      else
      {
         if (M)
            fprintf(fpout, 
         "   const int incPFA0 = (((int)(stM - A))*%d*%d)/(%d*N*sizeof(%s));\n",
                    mu, nu, M, type);
         else
            fprintf(fpout, 
         "   const int incPFA0 = (((int)(stM - A))*%d*%d)/(M*N*sizeof(%s));\n",
                    mu, nu, type);
      }
      fprintf(fpout, "   const int incPFA = (1 > incPFA0) ? 1 : incPFA0;\n");
/*
 *    Figure number of prefetch instructions that must be issued:
 *       (MB*KB*size)/ [ linesize*(MB*NB)/(mu*nu) ] 
 *     = (KB*size*mu*nu) / (linesize*NB) 
 *    ~= (size*mu*nu)/(linesize)
 */
      if (K && N) nprefA = (K*mu*nu*size)/(N*ATL_L1LS);
      else nprefA = (mu*nu*size)/ATL_L1LS;
      if (nprefA < 1) nprefA = 1;
   }   
   else if (prefA2)
   {
      if (TA == AtlasTrans || TA == AtlasConjTrans)
         fprintf(fpout, "   const %s *pfA = A + M;\n", type);
      else
         fprintf(fpout, "   const %s *pfA = A + lda*M;\n", type);

/*
 *    True # of items to fetch is K; if it's not set, try M/N (usually square)
 *    If none set, only do 2 prefetch/col (hardware prefetch may get rest)
 */
      if (K)
         nprefA = (K*size) / ATL_L1LS;
      else if (M)
         nprefA = (M*size) / ATL_L1LS;
      else if (N)
         nprefA = (N*size) / ATL_L1LS;
      else
      { 
         nprefA = (ku*size) / ATL_L1LS;
         if (nprefA < 2) nprefA = 2;
      }
   }
   if (alpha != SAFE_ALPHA && alpha != 1)
      fprintf(fpout, "   const %s BetaAlpha = beta / alpha;\n", type);

/*
 * Figure A & B's increments for all three loops
 */
   if (LoopOrder == AtlasJIK)
   {
      if (TA == AtlasNoTrans)
      {
         if (lda) fprintf(fpout, "   #define incAk %d\n", mulA*lda*kuA);
         else fprintf(fpout, "   const int incAk = %s;\n", 
                      GetInc(kuA*mulA, "lda"));
@skip         if (K) fprintf(fpout, "   const int incAm = %d - %s", mulA*mu, 
@skip                        GetInc((K/kuA)*mulA, "incAk"));
         if (K)
         {
            if (lda) fprintf(fpout, "   const int incAm = %d - %d",
                             mulA*mu, Kb*mulA*lda);
            else fprintf(fpout, "   const int incAm = %d - %s", mulA*mu,
                         GetInc(Kb*mulA, "lda"));
         }
         else fprintf(fpout, "   const int incAm = %d - %s", mulA*mu, 
                      GetInc(mulA, "Kb*lda"));
         if (M) fprintf(fpout, ", incAn = -%d;\n", mulA*Mb);
         else fprintf(fpout, ", incAn = -%s;\n", GetInc(mulA, "Mb"));
      }
      else
      {
         fprintf(fpout, "   #define incAk %d\n", kuA*mulA);
         if (K)
         {
            if (lda)
               fprintf(fpout, "   const int incAm = %d", mulA*(lda*mu - Kb));
            else
            {
               sprintf(ln, "%s - %d", GetInc(mu, "lda"), Kb);
               fprintf(fpout, "   const int incAm = %s", GetInc(mulA, ln));
            }
         }
         else
         {
            if (lda) fprintf(fpout, "   const int incAm = %d - %s", mulA*lda*mu,
                             GetInc(mulA,"Kb"));
            else
            {
               sprintf(ln, "%s - Kb", GetInc(mu, "lda"));
               fprintf(fpout, "   const int incAm = %s", GetInc(mulA, ln));
            }
         }
         if (M)
         {
            if (lda) fprintf(fpout, ", incAn = -%d;\n", mulA*lda*Mb);
            else fprintf(fpout, ", incAn = -%s;\n", GetInc(mulA*Mb, "lda"));
         }
         else if (lda)
            fprintf(fpout, ", incAn = -%s;\n", GetInc(mulA*lda,"Mb"));
         else fprintf(fpout, ", incAn = -%s;\n", GetInc(mulA, "Mb*lda"));
      }
      if (TB == AtlasNoTrans)
      {
         fprintf(fpout, "   #define incBk %d\n", mulB*kuB);
         if (K) fprintf(fpout, "   const int incBm = -%d", mulB*Kb);
         else fprintf(fpout, "   const int incBm = -%s", GetInc(mulB, "Kb"));
         if (ldb) fprintf(fpout, ", incBn = %d;\n", ldb*nu*mulB);
         else fprintf(fpout, ", incBn = %s;\n", GetInc(nu*mulB, "ldb"));
      }
      else
      {
         if (ldb)
         {
            fprintf(fpout, "   const int incBk = %d", mulB*kuB*ldb);
            if (K) fprintf(fpout, ", incBm = -%d", mulB*ldb*Kb);
            else fprintf(fpout, ", incBm = -%s", GetInc(mulB*ldb, "Kb"));
         }
         else
         {
            fprintf(fpout, "   const int incBk = %s", GetInc(mulB*kuB, "ldb"));
            if (K) fprintf(fpout, ", incBm = -%s", GetInc(mulB*Kb, "ldb"));
            else fprintf(fpout, ", incBm = -%s", GetInc(mulB, "Kb*ldb"));
         }
         fprintf(fpout, ";\n   #define incBn %d\n", nu*mulB);
      }
   }
   else if (LoopOrder == AtlasIJK)
   {
      if (TA == AtlasNoTrans)
      {
         if (lda)
         {
            fprintf(fpout, "   const int incAk = %d", lda*kuA*mulA);
            if (K) fprintf(fpout, ", incAn = -%d", mulA*lda*Kb);
            else fprintf(fpout, ", incAn = -%s", GetInc(mulA*lda, "Kb"));
         }
         else
         {
            fprintf(fpout, "   const int incAk = %s", GetInc(kuA*mulA, "lda"));
            if (K) fprintf(fpout, ", incAn = -%s", GetInc(mulA*Kb, "lda"));
            else fprintf(fpout, ", incAn = -%s", GetInc(mulA, "lda*Kb"));
         }
         fprintf(fpout, ";\n   #define incAm %d\n", mu*mulA);
      }
      else
      {
         fprintf(fpout, "   #define incAk %d\n", kuA*mulA);
         if (K) fprintf(fpout, "   const int incAn = -%d", Kb*mulA);
         else fprintf(fpout, "   const int incAn = -%s", GetInc(mulA, "Kb"));
         if (lda) fprintf(fpout, ";\n   #define incAm %d\n", mulA*lda*mu);
         else fprintf(fpout, ", incAm = %s;\n", GetInc(mulA*mu, "lda"));
      }
      if (TB == AtlasNoTrans)
      {
         fprintf(fpout, "   #define incBk %d\n", mulB*kuB);
         if (ldb)
         {
            if (K) fprintf(fpout, "   #define incBn %d;\n", mulB*(nu*ldb-Kb));
            else fprintf(fpout, "   const int incBn = %d - %s;\n", 
                         mulB*nu*ldb, GetInc(mulB, "Kb"));
            if (N) fprintf(fpout, "   #define incBm -%d\n", mulB*ldb*Nb);
            else fprintf(fpout, "   const int incBm = -%s;\n", 
                         GetInc(mulB*ldb, "Nb"));
         }
         else
         {
            if (K) fprintf(fpout, "   const int incBn = %s - %d", 
                           GetInc(mulB*nu, "ldb"), mulB*Kb);
            else
            {
               fprintf(fpout, "   const int incBn = %s - ", 
                       GetInc(mulB*nu, "ldb"));
               fprintf(fpout, "%s",  GetInc(mulB*nu, "Kb"));
            }
            if (N) fprintf(fpout, ", incBm = -%s;\n", GetInc(mulB*Nb, "ldb"));
            else fprintf(fpout, ", incBm = -%s;\n", 
                         GetInc(mulB, "Nb*ldb"));
         }
      }
      else
      {
         if (ldb)
         {
            fprintf(fpout, "   #define incBk %d\n", mulB*kuB*ldb);
            if (K) fprintf(fpout, "   const int incBn = %d", mulB*(nu-ldb*Kb));
            else fprintf(fpout, "   const int incBn = %d - %s", 
                         mulB*nu, GetInc(mulB*ldb, "Kb"));
         }
         else
         {
            fprintf(fpout, "   const int incBk = %s", 
                      GetInc(mulB*kuB, "ldb"));
            if (K) fprintf(fpout, ", incBn = %d - %s", 
                           mulB*nu, GetInc(mulB*Kb, "ldb"));
            else fprintf(fpout, ", incBn = %d - %s", 
                         mulB*nu, GetInc(mulB, "Kb*ldb"));
         }
         if (N) fprintf(fpout, ";\n   #define incBm -%d\n", mulB*Nb);
         else fprintf(fpout, ", incBm = %s;\n", GetInc(mulB, "-Nb"));
      }
   }
   if (!muladd)
   {
      if (ku == 1) 
         fprintf(fpout, "   #define incAk0 incAk\n   #define incBk0 incBk\n");
      else
      {
         if (!incpA) 
         {
            fprintf(fpout, "   const int incAk0 = %s", GetDiv(ku, "incAk"));
            if (!incpB) fprintf(fpout, ", incBk0 = %s;\n", GetDiv(ku, "incBk"));
            else fprintf(fpout, ";\n   #define incBk0 incBk\n");
         }
         else
         {
            fprintf(fpout, "   #define incAk0 incAk\n");
            if (!incpB) fprintf(fpout, "   const int incBk0 = %s;\n", 
                                GetDiv(ku, "incBk"));
            else fprintf(fpout, "   #define incBk0 incBk\n");
         }
      }
   }
   if (LoopOrder == AtlasJIK)
   {
      fprintf(fpout, "   #define incCm %d\n", mulC*mu);
      if (ldc)
      {
         if (M) fprintf(fpout, "   #define incCn %d\n", mulC*(ldc*nu-Mb));
         else fprintf(fpout, "   const int incCn = %d - %s;\n", 
                      mulC*ldc*nu, GetInc(mulC,"Mb"));
      }
      else
      {
         fprintf(fpout, "   const int incCn = %s", GetInc(mulC*nu, "ldc"));
         if (M)
         {
            if (Mb) fprintf(fpout, " - %d;\n", mulC*Mb);
            else fprintf(fpout, ";\n");
         }
         else fprintf(fpout, " - %s;\n", GetInc(mulC, "Mb"));
      }
   }
   else if (LoopOrder == AtlasIJK)
   {
      if (ldc)
      {
         fprintf(fpout, "   #define incCn %d\n", mulC*nu*ldc);
         if (N) fprintf(fpout, "   #define incCm %d\n", mulC*(mu - Nb*ldc));
         else fprintf(fpout, "   const int incCm = %d - %s;\n", 
                      mulC*mu, GetInc(mulC*ldc, "Nb"));
      }
      else
      {
         fprintf(fpout, "   const int incCn = %s", GetInc(mulC*nu, "ldc"));
         fprintf(fpout, ", incCm = %d", mulC*mu);
         if (N)
         {
            if (Nb) fprintf(fpout, " - %s;\n", GetInc(mulC*Nb, "ldc"));
            else fprintf(fpout, ";\n");
         }
         else fprintf(fpout, " - %s;\n", GetInc(mulC, "ldc*Nb"));
      }
   }
/*
 * Need to get mu[nu] ptrs when A [B] is accessed within a row inside the
 * K-loop, and the row-stride (ldx) is not known
 */
   Aptrs = ( (lda == 0) && (TA != AtlasNoTrans) );
   Bptrs = ( (ldb == 0) && (TB == AtlasNoTrans) );
/*
 * Setup necessary pointers
 */
   fprintf(fpout, "   %s *%s0=C", type, pC);
   if (!ldc)  /* need extra pointers if row stride is unknown */
      for (j=1; j < nu; j++) 
         fprintf(fpout, ", *%s%d=%s%d+%s", pC, j, pC, j-1, GetInc(mulC,"ldc"));
   fprintf(fpout, ";\n");
   fprintf(fpout, "   const %s *%s0=A", type, pA);

   if (Aptrs)
      for (j=1; j < mu; j++) 
         fprintf(fpout, ", *%s%d=%s%d+%s", pA, j, pA, j-1, GetInc(mulA,"lda"));
   fprintf(fpout, ";\n");
   fprintf(fpout, "   const %s *%s0=B", type, pB);
   if (Bptrs)
      for (j=1; j < nu; j++) 
         fprintf(fpout, ", *%s%d=%s%d+%s", pB, j, pB, j-1, GetInc(mulB,"ldb"));
   fprintf(fpout, ";\n");

   fprintf(fpout, "   register int k;\n");

   fprintf(fpout, "   register %s %s0", type, rA);
   for (j=1; j < mu; j++) fprintf(fpout, ", %s%d", rA, j);
   fprintf(fpout, ";\n");

   fprintf(fpout, "   register %s %s0", type, rB);
   for (j=1; j < nu; j++) fprintf(fpout, ", %s%d", rB, j);
   fprintf(fpout, ";\n");

   if (!muladd && lat)
   {
      if (TEMP_TYPE == 1)
         fprintf(fpout, "   register double m0");
      else if (TEMP_TYPE == 2)
         fprintf(fpout, "   register long double m0");
      else
         fprintf(fpout, "   register %s m0", type);
      for (j=1; j < lat; j++) fprintf(fpout, ", m%d", j);
      fprintf(fpout, ";\n");
   }

   for (j=0; j < nuC; j++)
   {
      for (i=0; i < muC; i++)
      {
         if (i || j) fprintf(fpout, ", %s%d_%d", rC, i, j);
         else if (TEMP_TYPE == 1)
            fprintf(fpout, "   register double %s0_0", rC);
         else if (TEMP_TYPE == 2)
            fprintf(fpout, "   register long double %s0_0", rC);
         else
            fprintf(fpout, "   register %s %s0_0", type, rC);
      }
   }
   fprintf(fpout, ";\n");
/*
 * See which loops exist 
 */
   if (LoopOrder == AtlasJIK)
   {
      OuterLoop = (nu != N);
      OuterTest = (N == 0) && (nu > 1) && CleaningN;
      InnerLoop = (mu != M);
      InnerTest = (M == 0) && (mu > 1) && CleaningM;
      outmat = 'n';
      OUTMAT = 'N';
      innmat  = 'm';
      INNMAT  = 'M';
      op = pB;
      ip = pA;
   }
   else if (LoopOrder == AtlasIJK)
   {
      OuterLoop = (mu != M);
      OuterTest = (M == 0) && (mu > 1) && CleaningM;
      InnerLoop = (nu != N);
      InnerTest = (N == 0) && (nu > 1) && CleaningN;
      outmat = 'm';
      OUTMAT = 'M';
      innmat  = 'n';
      INNMAT  = 'N';
      op = pA;
      ip = pB;
   }

   if (!muladd && !K && mu*nu <= lat)
   {
      k = 2 + lat/(mu*nu);
      fprintf(fpout, "%s   if (K < %d)\n%s   {\n", spc, k, spc);
      CallMM(fpout, spc-3, pre, lstr[LoopOrder], 1, TA, TB, M, N, K, 
             1, 1, 1, alpha, beta, lda, ldb, ldc, Mb, Nb, Kb0,
             "A", "B", "C", "M", "N", "K");
      fprintf(fpout, "%s      return;\n%s   }\n", spc, spc);
   }
   if (InnerLoop && InnerTest) 
   {
      fprintf(fpout, "%s   if (%s0 != st%c)\n%s   {\n", 
              spc, ip, INNMAT, spc);
      spc -= 3;
   }
   if (OuterLoop)
   {
      if (OuterTest) 
      {
         fprintf(fpout, "%s   if (%s0 != st%c)\n%s   {\n", 
                 spc, op, OUTMAT, spc);
         spc -= 3;
      }
      fprintf(fpout, "%s   do /* %c-loop */\n%s   {\n", spc, OUTMAT, spc);
      spc -= 3;
      if (prefA2)
         DoPrefA_lda0(fpout, spc, pre, nprefA, 1);
   }
   if (InnerLoop)
   {
      fprintf(fpout, "%s   do /* %c-loop */\n%s   {\n", spc, INNMAT, spc);
      spc -= 3;
   }

/*
 * If beta = 0, or we are doing load-at-bottom gemm, we set AsgC1, indicating
 * first iteration of C assignment will be of form Cij = rather than Cij +=
 * NOTE: presently not supported for combined muladd when K is unknown;
 *       to avoid code bloat, we don't do it if ku > MAX_CASG_KU
 */
   LdBott = LD_AT_BOTTOM;
   AsgC1 = 0;
   if (!beta || LdBott)
      AsgC1 = (!muladd || K) && (ku == K || (ku <= MAX_CASG_KU));

   if (prefA1)
      DoPrefA(fpout, spc, nprefA);
   sprintf(ln, "%s0", rA);
   fetchC(fpout, spc, LoopOrder, ForceFetch, mu, nu, 0, pC, rC, mulC, ldc, 
           alpha, (LdBott && !AsgC1) ? 0 : beta, !AsgC1, ln);
/*
 * If prefetch is on, prefetch cols of C if we don't access them at top-of-loop
 * NOTE: need to time and see if this slows more people down than it speeds
 *       up, maybe make tuning parameter.
 */
   if (prefA && AsgC1)
   {
      for (j=0; j < nu; j++)
      {
         if (ldc)
            fprintf(fpout, "%s   ATL_pfl1W(%s0+%d);\n", spc, pC, j*ldc*mulC);
         else
            fprintf(fpout, "%s   ATL_pfl1W(%s%d);\n", spc, pC, j);
      }
   }
   kloop(fpout, spc, LoopOrder, TA, TB, AsgC1, M, N, K, ifetch, nfetch, lat, 
         rA, rB, rC, pA, pB, mu, nu, ku, lda, ldb, mulA, mulB, incpA, incpB, 
         incAk, incBk);
   sprintf(ln, "incC%c", innmat);
   Cass(fpout, spc, LoopOrder, LdBott, mu, nu, alpha, beta, 0, 
        rA, rB, pC, rC, mulC, ldc, ln);
/*
 * Must inc innerloop pointers if either loop exists, so indexing remains
 * as expected
 */
   if (InnerLoop || OuterLoop)
   {
      if (ldc != 0) IncPtrs(fpout, spc, 1, 'C', innmat);
      else IncPtrs(fpout, spc, nu, 'C', innmat);
      if (Aptrs) IncPtrs(fpout, spc, mu, 'A', innmat);
      else IncPtrs(fpout, spc, 1, 'A', innmat);
      if (Bptrs) IncPtrs(fpout, spc, nu, 'B', innmat);
      else IncPtrs(fpout, spc, 1, 'B', innmat);
   }
   if (InnerLoop)
   {
      spc += 3;
      fprintf(fpout, "%s   }\n%s   while(%s0 != st%c);\n",spc, spc, ip, INNMAT);
   }
   if (OuterLoop)
   {
      if (ldc != 0) IncPtrs(fpout, spc, 1, 'C', outmat);
      else IncPtrs(fpout, spc, nu, 'C', outmat);
      if (Aptrs) IncPtrs(fpout, spc, mu, 'A', outmat);
      else IncPtrs(fpout, spc, 1, 'A', outmat);
      if (Bptrs) IncPtrs(fpout, spc, nu, 'B', outmat);
      else IncPtrs(fpout, spc, 1, 'B', outmat);
      if (prefA2)
         DoPrefA_lda0(fpout, spc, pre, nprefA, 0);

      spc += 3;
      fprintf(fpout, "%s   }\n%s   while(%s0 != st%c);\n",spc, spc, op, OUTMAT);
      if (OuterTest)
      {
         spc += 3;
         fprintf(fpout, "%s   }\n", spc);
      }
   }
   if (InnerLoop && InnerTest)
   {
      spc += 3;
      fprintf(fpout, "%s   }\n", spc);
   }
/*
 * For loop cleanup, reuse matrix already in L1, if possible
 */
   k = 0;
   for (i=0; i < 2; i++)
   {
      if ( (LoopOrder == AtlasJIK && i == 0) || 
           (LoopOrder == AtlasIJK && i == 1 ) )
      {  /* A is in L1, clean N-loop first, else clean it second */
         if (N)
         {
            if (N%nu) /* there is cleanup to do */
            {
               if (ldc) sprintf(cC, "cc + %d", ldc*Nb*mulC);
               else sprintf(cC, "cc + %s", GetInc(Nb*mulC, "ldc"));
               if (TB == AtlasNoTrans)
               {
                  if (ldb) sprintf(cB, "cb + %d", ldb*Nb*mulB);
                  else sprintf(cB, "cb + %s", GetInc(Nb*mulB, "ldb"));
               }
               else sprintf(cB, "cb + %d", Nb*mulB);
               CallMM(fpout, spc, pre, lstr[LoopOrder], 1, TA, TB, M, N%nu, K, 
                      mu, N%nu, ku, alpha, beta, lda, ldb, ldc, Mb, Nb, Kb0,
                      "ca", cB, cC, "M", "N", "K");
            }
         }
         else if (nu > 1 && CleaningN)
         {
            if (ldc) sprintf(cC, "cc + %s", GetInc(ldc*mulC, "Nb"));
            else sprintf(cC, "cc + %s", GetInc(mulC, "Nb*ldc"));
            if (TB == AtlasNoTrans)
            {
               if (ldb) sprintf(cB, "cb + %s", GetInc(ldb*mulB, "Nb"));
               else sprintf(cB, "cb + %s", GetInc(mulB, "Nb*ldb"));
            }
            else sprintf(cB, "cb + %s", GetInc(mulB, "Nb"));
            if (!k)
            {
               fprintf(fpout, "%s   if (k=N-Nb)\n", spc);
               CallMM(fpout, spc-3, pre, lstr[LoopOrder], 1, TA, TB, M, 0, K, 
                      mu, 1, ku, alpha, beta, lda, ldb, ldc, M, Nb, Kb0,
                      "ca", cB, cC, "M", "k", "K");
            }
            else
            {
               fprintf(fpout, "%s   if ((k=N-Nb) && Nb)\n", spc);
               CallMM(fpout, spc-3, pre, lstr[LoopOrder], 1, TA, TB, M, 0, K, 
                      mu, 1, ku, alpha, beta, lda, ldb, ldc, M, Nb, Kb0,
                      "ca", cB, cC, "Mb", "k", "K");
            }
            k = 1;
         }
      }
      else if ( (LoopOrder == AtlasIJK && i == 0) ||
                (LoopOrder == AtlasJIK && i == 1) )
      {  /* if B is in L1, clean M-loop first, else clean it second */
         if (CleanN)
         {
            j = N - N%nu;
            sprintf(ctmp, "Nb");
         }
         else
         {
            j = N;
            sprintf(ctmp, "N");
         }
         if (M)
         {
            sprintf(cC, "cc + %d", Mb*mulC);
            if (TA == AtlasNoTrans) sprintf(cA, "ca + %d", Mb*mulA);
            else
            {
               if (lda) sprintf(cA, "ca + %d", mulA*Mb*lda);
               else sprintf(cA, "ca + %s", GetInc(mulA*Mb, "lda"));
            }
            if (M%mu)
            {
               if (CleanN && !N)
               {
                  fprintf(fpout, "%s   if (Nb)\n\n", spc);
                  spc -= 3;
               }
               CallMM(fpout, spc, pre, lstr[LoopOrder], 1, TA, TB, M%mu, j, K, 
                      M%mu, nu, ku, alpha, beta, lda, ldb, ldc, Mb, Nb, Kb0,
                      cA, "cb", cC, "M", ctmp, "K");
               if (CleanN && !N) spc += 3;
            }
         }
         else if (mu > 1 && CleaningM)
         {
            sprintf(cC, "cc + %s", GetInc(mulC, "Mb"));
            if (TA == AtlasNoTrans) sprintf(cA, "ca + %s", GetInc(mulA, "Mb"));
            else
            {
               if (lda) sprintf(cA, "ca + %s", GetInc(mulA*lda, "Mb"));
               else sprintf(cA, "ca + %s", GetInc(mulA, "Mb*lda"));
            }
            if (!k)
            {
               fprintf(fpout, "%s   if (k=M-Mb)\n", spc);
               CallMM(fpout, spc-3, pre, lstr[LoopOrder], 1, TA, TB, 0, j, K, 
                      1, nu, ku, alpha, beta, lda, ldb, ldc, Mb, Nb, Kb0,
                      cA, "cb", cC, "k", "N", "K");
            }
            else
            {
               fprintf(fpout, "%s   if (Nb && (k=M-Mb))\n", spc);
               CallMM(fpout, spc-3, pre, lstr[LoopOrder], 1, TA, TB, 0, j, K, 
                      1, nu, ku, alpha, beta, lda, ldb, ldc, Mb, Nb, Kb0,
                      cA, "cb", cC, "k", "Nb", "K");
            }
            k = 1;
         }
      }
   }
   fprintf(fpout, "}\n");
   fprintf(fpout, "#ifdef incAm\n   #undef incAm\n#endif\n");
   fprintf(fpout, "#ifdef incAn\n   #undef incAn\n#endif\n");
   fprintf(fpout, "#ifdef incAk\n   #undef incAk\n#endif\n");
   fprintf(fpout, "#ifdef incBm\n   #undef incBm\n#endif\n");
   fprintf(fpout, "#ifdef incBn\n   #undef incBn\n#endif\n");
   fprintf(fpout, "#ifdef incBk\n   #undef incBk\n#endif\n");
   fprintf(fpout, "#ifdef incCm\n   #undef incCm\n#endif\n");
   fprintf(fpout, "#ifdef incCn\n   #undef incCn\n#endif\n");
   fprintf(fpout, "#ifdef incCk\n   #undef incCk\n#endif\n");
   fprintf(fpout, "#ifdef Mb\n   #undef Mb\n#endif\n");
   fprintf(fpout, "#ifdef Nb\n   #undef Nb\n#endif\n");
   fprintf(fpout, "#ifdef Kb\n   #undef Kb\n#endif\n");
}

void GenMakefile(char pre, int nb, int nb0, int nbetas, char *betas,
                 CLEANNODE **cp)
{
   const int nalpha=2;
   char fnam[64], trans[2] = {'N', 'T'}, cal[2] = {'1', 'X'};
   char cwh[3] = {'M', 'N', 'K'};
   int i, j, k, p;
   char UPR;
   FILE *fp;
   CLEANNODE *wp;

   UPR = (pre == 's' || pre == 'c') ? 'S' : 'D';
   sprintf(fnam, "KERNEL/%cMakefile", pre);
   fp = fopen(fnam, "w");
   assert(fp);

   fprintf(fp, "include ../Make.inc\n\n");
   fprintf(fp, "CDEFS2 = $(CDEFS)");
   for (i=0; i < 3; i++) 
      if (cp[i]) fprintf(fp, " -DATL_UCLEAN%c", cwh[i]);
   fprintf(fp, "\n");
   fprintf(fp, "obj = \\\n");
   for (i=0; i < nbetas; i++)
      fprintf(fp, "      ATL_%cNBmm_b%c.o \\\n", pre, betas[i]);
   for (j=0; j < 2; j++)
   {
      for (i=0; i < 2; i++)
      {
         fprintf(fp, "      ATL_%cNCCUmm%c%c.o \\\n", pre, trans[j], trans[i]);
         fprintf(fp, "      ATL_%cNCCUmm%c%c_K.o \\\n",pre, trans[j], trans[i]);
         for (k=0; k < nbetas; k++)
         {
            for (p=0; p < nalpha; p++)
            {
               fprintf(fp, "      ATL_%cNCmm%c%c_a%c_b%c.o \\\n",
                       pre, trans[j], trans[i], cal[p], betas[k]);
               
            }
         }
      }
   }
   for (i=0; i < 3; i++)
   {
      if (cp[i])
      {
         for (j=0; j < nbetas; j++)
         {
            fprintf(fp, "      ATL_%cup%cBmm_b%c.o \\\n", pre,cwh[i], betas[j]);
            for (wp=cp[i]; wp; wp = wp->next)
            {
               for(k=0; k < wp->ncomps; k++)
                  fprintf(fp, "      ATL_%cup%cBmm%d_%d_%d_b%c.o \\\n", pre,
                          cwh[i], wp->NBs[k], wp->imult, wp->fixed, betas[j]);

            }
         }
      }
   }
   for (i=0; i < nbetas; i++)
   {
      fprintf(fp, "      ATL_%cgpMBmm_b%c.o \\\n", pre, betas[i]);
      fprintf(fp, "      ATL_%cgpNBmm_b%c.o \\\n", pre, betas[i]);
   }
   if (nb0 != 0) fprintf(fp, "      ATL_%cgpKBmm0.o \\\n", pre);
   for (i=nb0+1; i <= nb; i++)
   {
      fprintf(fp, "      ATL_%cgpKBmm%d.o \\\n", pre, i);
   }
   fprintf(fp, "      ATL_%cgpKBmm.o \n\n", pre);

   fprintf(fp, "%cclean : clean\n", pre);
   fprintf(fp, "clean : \n\trm -f $(obj) %clib.grd\n\n", pre);

   fprintf(fp, "all : lib\n");
   fprintf(fp, "lib : %clib\n", pre);
   fprintf(fp, "%clib : %clib.grd\n", pre, pre);
   fprintf(fp, "%clib.grd : $(obj)\n", pre);
   fprintf(fp, "\t $(ARCHIVER) $(ARFLAGS) $(ATLASlib) $(obj)\n");
   fprintf(fp, "\t $(RANLIB) $(ATLASlib)\n");
   fprintf(fp, "\t touch %clib.grd\n", pre);

   for (i=0; i < 4; i++)
   {
      for (wp=cp[i]; wp; wp = wp->next)
      {
         if (wp->CC[0])  /* need non-default compilation rule */
         {
            char *comp = (wp->CC[0] == 'g' && wp->CC[1] == 'c' 
                          && wp->CC[2] == 'c' && 
                          (wp->CC[3] == '\0' || wp->CC[3] == ' ')) 
                         ? "$(GOODGCC)" : wp->CC;
            for (j=0; j < nbetas; j++)
            {
               for(k=0; k < wp->ncomps; k++)
               {
                  if (i < 3)
                     sprintf(fnam, "ATL_%cup%cBmm%d_%d_%d_b%c", pre, cwh[i],
                             wp->NBs[k], wp->imult, wp->fixed, betas[j]);
                  else sprintf(fnam, "ATL_%cNBmm_b%c", pre, betas[j]);
                     fprintf(fp, "%s.o : %s.c \n", fnam, fnam);
                  fprintf(fp, "\t%s $(CDEFS2) -DATL_BETA=%c -c %s %s.c\n",
                          comp, betas[j], wp->CCFLAGS, fnam);
               }
            }
         }
      }
   }

   fprintf(fp, "\n.c.o:\n\t$(%cMC) $(CDEFS2) $(%cMCFLAGS) -c $<\n", UPR, UPR);
   fclose(fp);
}

void ComplexWrap(FILE *fpout, char *type, char *caller, char *callee, int beta)
{
   char bnam0[8], bnam0N[8];

   if (beta == 1)
   {
      sprintf(bnam0N, "_bX");
      sprintf(bnam0, "_b1");
   }
   else if (beta == 0)
   {
      sprintf(bnam0N, "_b0");
      sprintf(bnam0, "_b0");
   }
   else
   {
      sprintf(bnam0N, "_bX");
      sprintf(bnam0, "_bX");
   }

   fprintf(fpout, "#ifdef ATL_UCLEAN%c\n", toupper(caller[6]));
   fprintf(fpout, "#define %s ATL_%cg%s\n", caller, caller[4], caller+5);
   fprintf(fpout, "#endif\n\n");

   fprintf(fpout, "void %s%s(const int M, const int N, const int K, const %s alpha, const %s *A, const int lda, const %s *B, const int ldb, const %s beta, %s *C, const int ldc);\n", callee, bnam0N, type, type, type, type, type);
   fprintf(fpout, "void %s%s(const int M, const int N, const int K, const %s alpha, const %s *A, const int lda, const %s *B, const int ldb, const %s beta, %s *C, const int ldc);\n", callee, "_bX", type, type, type, type, type);
   fprintf(fpout, "void %s%s(const int M, const int N, const int K, const %s alpha, const %s *A, const int lda, const %s *B, const int ldb, const %s beta, %s *C, const int ldc);\n", callee, "_b1", type, type, type, type, type);
   fprintf(fpout, "\n");

   fprintf(fpout, "void %s(const int M, const int N, const int K, const %s alpha, const %s *A, const int lda, const %s *B, const int ldb, const %s beta, %s *C, const int ldc)\n", caller, type, type, type, type, type);
   fprintf(fpout, "{\n");
   fprintf(fpout, "   %s%s(M, N, K, alpha, A, lda, B, ldb, -beta, C, ldc);\n", callee, bnam0N);
   fprintf(fpout, "   %s%s(M, N, K, alpha, A, lda, B+N*ldb, ldb, beta, C+1, ldc);\n", callee, bnam0N);
   fprintf(fpout, "   %s%s(M, N, K, alpha, A+M*lda, lda, B+N*ldb, ldb, -1.0, C, ldc);\n", callee, "_bX");
   fprintf(fpout, "   %s%s(M, N, K, alpha, A+M*lda, lda, B, ldb, 1.0, C+1, ldc);\n", callee, "_b1");
   fprintf(fpout, "}\n");

}

void GetInstLogFile(char *nam, int pre, int *muladd, int *pfA, int *lat, 
                    int *nb, int *mu, int *nu, int *ku, int *ForceFetch,
                    int *ifetch, int *nfetch, double *mflop)
{
   char ln[128];
   FILE *fp;

   fp = fopen(nam, "r");
   if (fp == NULL) fprintf(stderr, "file %s not found!!\n\n", nam);
   assert(fp);
   fgets(ln, 128, fp);
   fscanf(fp, " %d %d %d %d %d %d %d %d %d %d %lf\n",
          muladd, lat, pfA, nb, mu, nu, ku, ForceFetch, ifetch, nfetch, mflop);
   fclose(fp);
}

void GenKBcases(char *spc, char pre, char *type, int *kb0, int *nb0)
{
   char fnam[128];
   char *bnams[3] = {"_b1", "_b0", "_bX"};
   int kb, muladd, lat, nb, mu, nu, ku, FFetch, ifetch, nfetch, i, pfA;
   int mulC=1;
   double specmf, genmf;
   FILE *fpin, *fpout;

   if (pre == 'c' || pre == 'z') mulC = 2;
   sprintf(fnam, "res/%cCleanK", pre);
   fpin = fopen(fnam, "r");
   assert(fpin);
   fgets(fnam, 128, fpin);
   i = 0;
   do
   {
      fscanf(fpin, " %d %d %d %d %d %d %d %d %d %d %d %lf %lf\n",
             &kb, &muladd, &lat, &pfA, &nb, &mu, &nu, &ku, &FFetch, 
             &ifetch, &nfetch, &specmf, &genmf);
      ncucases = 0;
      sprintf(fnam, "KERNEL/ATL_%cgpKBmm%d.c", pre, kb);
      fpout = fopen(fnam, "w");
      assert(fpout);
      emit_mm(fpout, spc, pre, type, "", AtlasJIK, AtlasTrans, AtlasNoTrans,
              1, muladd, pfA, lat, FFetch, ifetch, nfetch, 0, 0, kb, mu, nu, ku,
              1, 1, mulC, kb, kb, 0, 1, 8);
      fclose(fpout);
      if (kb) i++;
   }
   while (kb && i < nb);
   fclose(fpin);
   *kb0 = nb - i;
@skip   GenMakefile(pre, nb, *kb0, 3, bnams);
   *nb0 = nb;
}

int GenKBmm(char *spc, char pre, char *type)
/*
 * Generate KBmm cases, and return kb0
 */
{
   char fnam[128];
   char *betnam = "_bX";
   char ba[3] = {'0', '1', 'X'};
   const int COMPLEX = (pre == 'c' || pre == 'z');
   int i, kb0, nb;
   FILE *fp;

   GenKBcases(spc, pre, type, &kb0, &nb);

   sprintf(fnam, "KERNEL/ATL_%cgpKBmm.c", pre);
   fp = fopen(fnam, "w");
   assert(fp);

   fprintf(fp, "#ifndef ATL_UCLEANK\n");
   fprintf(fp, "   #define ATL_%cgpKBmm ATL_%cpKBmm\n#endif\n\n", pre, pre);
   for (i=kb0+1; i <= nb; i++)
   {
      fprintf(fp, "void ATL_%cJIK0x0x%dTN%dx%dx0_a1%s(const int M, const int N, const int K, const %s alpha, const %s *A, const int lda, const %s *B, const int ldb, const %s beta, %s *C, const int ldc);\n", pre, i, i, i, betnam, type, type, type, type, type);

   }
   if (kb0 != 0)
      fprintf(fp, "void ATL_%cJIK0x0x0TN0x0x0_a1%s(const int M, const int N, const int K, const %s alpha, const %s *A, const int lda, const %s *B, const int ldb, const %s beta, %s *C, const int ldc);\n", pre, betnam, type, type, type, type, type);

   fprintf(fp, "typedef void (*MMfunc)(const int M, const int N, const int K, const %s alpha, const %s *A, const int lda, const %s *B, const int ldb, const %s beta, %s *C, const int ldc);\n\n", type, type, type, type, type);

   fprintf(fp, "void ATL_%cgpKBmm(const int M, const int N, const int K, const %s alpha, const %s *A, const int lda, const %s *B, const int ldb, const %s beta, %s *C, const int ldc)\n{\n", pre, type, type, type, type, type);

   if (kb0 >= nb)
   {
@beginskip
      fprintf(fp, "   #ifdef ATL_UCLEANK\n");
      fprintf(fp, "      if (M == NB && N == NB)\n      {\n");
      fprintf(fp, 
      "         %cupKBmm(M, N, K, alpha, A, lda, B, ldb, -beta, C, ldc);\n",
              pre);
      fprintf(fp, "         return;\n      }\n");
      fprintf(fp, "   #endif\n\n");
@endskip
      if (COMPLEX)
      {
         fprintf(fp, "   ATL_%cJIK0x0x0TN0x0x0_a1_bX(M, N, K, alpha, A, lda, B, ldb, -beta, C, ldc);\n", pre);
         fprintf(fp, "   ATL_%cJIK0x0x0TN0x0x0_a1_bX(M, N, K, alpha, A, lda, B+N*ldb, ldb, beta, C+1, ldc);\n", pre);
         fprintf(fp, "   ATL_%cJIK0x0x0TN0x0x0_a1_bX(M, N, K, alpha, A+M*lda, lda, B+N*ldb, ldb, -1.0, C, ldc);\n", pre);
         fprintf(fp, "   ATL_%cJIK0x0x0TN0x0x0_a1_bX(M, N, K, alpha, A+M*lda, lda, B, ldb, 1.0, C+1, ldc);\n", pre);
      }
      else
      {
         fprintf(fp, "   ATL_%cJIK0x0x0TN0x0x0_a1%s(M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);\n", pre, betnam);
      }
   }
   else
   {
      fprintf(fp, "   static MMfunc mmfunc[%3d] = {\n", nb-kb0);
      for (i=kb0+1; i < nb; i++)
         fprintf(fp, 
                 "                         ATL_%cJIK0x0x%dTN%dx%dx0_a1%s,\n",
                 pre, i, i, i, betnam);
      fprintf(fp, "                         ATL_%cJIK0x0x%dTN%dx%dx0_a1%s,\n",
              pre, i, i, i, betnam);
      fprintf(fp, "                        };\n");
      if (COMPLEX) fprintf(fp, "   MMfunc mm;\n");
      fprintf(fp, "\n");

@beginskip
      fprintf(fp, "   #ifdef ATL_UCLEANK\n");
      fprintf(fp, "      if (M == NB && N == NB)\n      {\n");
      fprintf(fp, 
      "         %cpuKBmm(M, N, K, alpha, A, lda, B, ldb, -beta, C, ldc);\n",
              pre);
      fprintf(fp, "         return;\n      }\n");
      fprintf(fp, "   #endif\n\n");

@endskip
      if (kb0)
      {
         if (COMPLEX)
         {
            fprintf(fp, "   if (K <= %d)\n   {\n", kb0);
            fprintf(fp, "      ATL_%cJIK0x0x0TN0x0x0_a1_bX(M, N, K, alpha, A, lda, B, ldb, -beta, C, ldc);\n", pre);
            fprintf(fp, "      ATL_%cJIK0x0x0TN0x0x0_a1_bX(M, N, K, alpha, A, lda, B+N*ldb, ldb, beta, C+1, ldc);\n", pre);
            fprintf(fp, "      ATL_%cJIK0x0x0TN0x0x0_a1_bX(M, N, K, alpha, A+M*lda, lda, B+N*ldb, ldb, -1.0, C, ldc);\n", pre);
            fprintf(fp, "      ATL_%cJIK0x0x0TN0x0x0_a1_bX(M, N, K, alpha, A+M*lda, lda, B, ldb, 1.0, C+1, ldc);\n", pre);
            fprintf(fp, "   }\n   else\n   {\n");
            fprintf(fp, "      mm = mmfunc[K-%d];\n", kb0+1);
            fprintf(fp, "      mm(M, N, K, alpha, A, lda, B, ldb, -beta, C, ldc);\n");
            fprintf(fp, "      mm(M, N, K, alpha, A, lda, B+N*ldb, ldb, beta, C+1, ldc);\n");
            fprintf(fp, "      mm(M, N, K, alpha, A+M*lda, lda, B+N*ldb, ldb, -1.0, C, ldc);\n");
            fprintf(fp, "      mm(M, N, K, alpha, A+M*lda, lda, B, ldb, 1.0, C+1, ldc);\n");
            fprintf(fp, "   }\n");
         }
         else
         {
            fprintf(fp, "   if (K <= %d) ATL_%cJIK0x0x0TN0x0x0_a1%s(M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);\n", kb0, pre, betnam);
            fprintf(fp, "   else mmfunc[K-%d](M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);\n", kb0+1);
         }
      }
      else if (COMPLEX)
      {
         fprintf(fp, "      mm = mmfunc[K-1];\n");
         fprintf(fp, "      mm(M, N, K, alpha, A, lda, B, ldb, -beta, C, ldc);\n");
         fprintf(fp, "      mm(M, N, K, alpha, A, lda, B+N*ldb, ldb, beta, C+1, ldc);\n");
         fprintf(fp, "      mm(M, N, K, alpha, A+M*lda, lda, B+N*ldb, ldb, -1.0, C, ldc);\n");
         fprintf(fp, "      mm(M, N, K, alpha, A+M*lda, lda, B, ldb, 1.0, C+1, ldc);\n");
      }
      else fprintf(fp, "   mmfunc[K-1](M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);\n");
   }
   fprintf(fp, "}\n");
   fprintf(fp, "#ifndef ATL_UCLEANK\n");
   for (i=0; i < 3; i++)
   {
      fprintf(fp, "void ATL_%cpKBmm_b%c(const int M, const int N, const int K, const %s alpha, const %s *A, const int lda, const %s *B, const int ldb, const %s beta, %s *C, const int ldc)\n", pre, ba[i], type, type, type, type, type);
      fprintf(fp,
      "{\n   ATL_%cgpKBmm(M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);\n}\n",
              pre);
   }
   fprintf(fp, "#endif\n");
   fclose(fp);
   return(kb0);
}

void GenMNBcase(char *spc, char MN, char pre, char *type, int beta, char *bnam)
{
   const int COMPLEX = (pre == 'c' || pre == 'z');
   const int csA=1, csB=1, csC = ( COMPLEX ? 2 : 1 );
   char fnam[128], callee[128], caller[128];
   int muladd, lat, mb, nb, kb, mu, nu, ku, ffetch, ifetch, nfetch, pfA;
   double mflop;
   FILE *fpout;

   sprintf(fnam, "res/%cClean%c", pre, MN);
   GetInstLogFile(fnam, pre, &muladd, &pfA, &lat, &nb, &mu, &nu, &ku, 
                  &ffetch, &ifetch, &nfetch, &mflop);
   mb = kb = nb;
   if (MN == 'M') mb = 0;
   else nb = 0;

   sprintf(fnam, "KERNEL/ATL_%cgp%cBmm%s.c", pre, MN, bnam);
   fpout = fopen(fnam, "w");
   assert(fpout);
   if (!COMPLEX)
   {
      fprintf(fpout, "#ifdef ATL_UCLEAN%c\n", MN);
      fprintf(fpout,
              "#define ATL_%cJIK%dx%dx%dTN%dx%dx%d_a1%s ATL_%cgp%cBmm%s\n",
              pre, mb, nb, kb, kb, kb, 0, bnam, pre, MN, bnam);
      fprintf(fpout, "#else\n");
      fprintf(fpout,"#define ATL_%cJIK%dx%dx%dTN%dx%dx%d_a1%s ATL_%cp%cBmm%s\n",
              pre, mb, nb, kb, kb, kb, 0, bnam, pre, MN, bnam);
      fprintf(fpout, "#endif\n\n");
   }
   ncucases = 0;
   emit_mm(fpout, spc, pre, type, "", AtlasJIK, AtlasTrans, AtlasNoTrans,
           1, muladd, pfA, lat, ffetch, ifetch, nfetch, mb, nb, kb, mu, nu, ku,
           csA, csB, csC, kb, kb, 0, 1, beta);
   if (COMPLEX)
   {
      sprintf(caller, "ATL_%cp%cBmm%s", pre, MN, bnam);
      sprintf(callee, "ATL_%cJIK%dx%dx%dTN%dx%dx%d_a1", 
              pre, mb, nb, kb, kb, kb, 0);
      ComplexWrap(fpout, type, caller, callee, beta);
   }
   fclose(fpout);
}

void GenMNClean(char *spc, char pre, char *type)
{
   char *bnams[3] = {"_b1", "_b0", "_bX"};
   int betas[3] = {1, 0, 8};
   int i;

   for (i=0; i < 3; i++)
   {
      GenMNBcase(spc, 'M', pre, type, betas[i], bnams[i]);
      GenMNBcase(spc, 'N', pre, type, betas[i], bnams[i]);
   }
}

@extract -b @(basd)/atlas.base rout=usercase

void PrintCleanNodes(CLEANNODE *cp)
{
   int NumUCleanRout(CLEANNODE *cp);
   fprintf(stdout, "\nncases=%d\n", NumUCleanRout(cp));
   for (; cp; cp = cp->next)
      fprintf(stdout, 
      "icase=%d, imult=%d, nb=%d, fixed=%d, ncomps=%d, *NBs=%d, rout=%s\n",
              cp->icase, cp->nb, cp->imult, cp->fixed, cp->ncomps, *cp->NBs, cp->rout);
   fprintf(stdout, "\n");
}


void KillCleanNodes(CLEANNODE *cp0)
{
   CLEANNODE *cp;
   while (cp0)
   {
      if (cp0->NBs) free(cp0->NBs);
      cp = cp0->next;
      free(cp0);
      cp0 = cp;
   }
}

int CompMultHandled(CLEANNODE *cp, int nb)
/*
 * Returns 1 if nb is handled by succeeding case, 0 otherwise
 */
{
   for (; cp; cp = cp->next) 
   {
      if (cp->fixed == 2)
      {
         if (cp->imult == nb)
            return(1);
      }
      else if (nb % cp->imult == 0)
         return(1);
   }
   return(0);
}

int *GetCompNBs(enum CW which, CLEANNODE *cp0, int *N)
/*
 * Get number NBs to compile cleanup cp0 with
 * NOTE: assumes CLEANNODEs are sorted in ascending imult order.
 */
{
   int *NBs, *ip;
   int i, n=1, istop;
   CLEANNODE *cp;

   if (!cp0)
   {
      *N = 0;
      return(NULL);
   }

   NBs = malloc(cp0->nb*sizeof(int));
   assert(NBs);
   if (cp0->fixed == 1)
   {
      NBs[0] = cp0->imult;
      istop = cp0->nb;
      while (istop % cp0->imult) istop--;
      if (istop == cp0->nb) istop -= cp0->imult;
@beginskip
/*
 *    As far as I can tell (RCW, 01/29/10), this loop was a logic error
 *    from the first.  No higher mult factor can handle all cases of a
 *    lower imult!  I may have just started thinking of it as N, rather
 *    that imult.  I leave this section in the code in case later bugs
 *    convince me there was a purpose to this code
 */
      for (cp=cp0->next; cp; cp = cp->next)
      {
         if (cp->imult % cp0->imult == 0 && cp->fixed != 2)
         {
            istop = cp->imult;
            break;
         }
      }
@endskip

      for (i=2*cp0->imult; i <= istop; i += cp0->imult)
      {
         if (!CompMultHandled(cp0->next, i)) NBs[n++] = i;
      }
   }
   else if (cp0->fixed) NBs[0] = cp0->imult;
   else NBs[0] = 0;

   ip = malloc(n * sizeof(int));
   assert(ip);
   for (i=0; i < n; i++) ip[i] = NBs[i];

   free(NBs);
   *N = n;

   return(ip);
}

CLEANNODE *GetUCleanInfo(char pre, enum CW which)
{
   char cwh[3] = {'M', 'N', 'K'};
   FILE *fp;
   CLEANNODE *cp, *cp0;
   char *MCC, *MMFLAGS;
   int i, j, n;
   char ln[256];

   sprintf(ln, "res/%cuClean%cF", pre, cwh[which]);
   fp = fopen(ln, "r");
   assert(fp);
   assert(fgets(ln, 256, fp));
   assert(fgets(ln, 256, fp));
   assert(sscanf(ln, " %d", &n) == 1);
   if (n < 1) return(NULL);
   cp = cp0 = malloc(sizeof(CLEANNODE));
   for (i=0; i < n; i++)
   {
      assert(fgets(ln, 256, fp));
      assert(sscanf(ln, " %d %d %d %d", 
             &cp->imult, &cp->icase, &cp->fixed, &cp->nb) == 4);
      GetUserCase(pre, cp->icase, &j, &j, &j, &j, &j, &j, &j, &j, &j, cp->rout,
                  ln, &MCC, &MMFLAGS);

      if (MCC) strcpy(cp->CC, MCC);
      else cp->CC[0] = '\0';
      if (MMFLAGS) strcpy(cp->CCFLAGS, MMFLAGS);
      else cp->CCFLAGS[0] = '\0';

      if (i != n-1) cp->next = malloc(sizeof(CLEANNODE));
      else cp->next = NULL;
      cp = cp->next;
   }
   fclose(fp);
   for (cp=cp0; cp; cp=cp->next) cp->NBs = GetCompNBs(which, cp, &cp->ncomps);
   return(cp0);
}

int NumUCleanRout(CLEANNODE *cp)
{
   int i;
   for (i=0; cp; cp = cp->next) i++;
   return(i);
}

int NumUCleanRoutFixed(CLEANNODE *cp, int fix)
{
   int i;
   for (i=0; cp; cp = cp->next) if (cp->fixed == fix) i++;
   return(i);
}

CLEANNODE *GetCaseNode(CLEANNODE *cp, int icase)
{
   int i;
   for (i=0; cp && i+cp->ncomps < icase; cp = cp->next, i += cp->ncomps);
   return(cp);
}

CLEANNODE *GetFixedCaseNode(CLEANNODE *cp, int irout, int ifix)
{
   int i;

   for(i=0; cp; cp = cp->next);
   {
      if (cp->fixed == ifix)
      {
         i += cp->ncomps;
         if (i >= irout) return(cp);
      }
   }
   return(NULL);
}

char *GetZCleanNam(char *nam)
/*
 * For complex, upcases <pre> in name
 */
{
   static char znam[128];

   strcpy(znam, nam);
   if (znam[4] == 'c') znam[4] = 'C';
   else if (znam[4] == 'z') znam[4] = 'Z';
   return(znam);
}

char *GetNoBetaNam(char *nam)
/*
 * chops the beta suffix from name
 */
{
   static char bnam[128];
   char *sp;

   strcpy(bnam, nam);
   sp = strstr(bnam, "_b");
   *sp = '\0';
   return(bnam);
}

char *GetUCleanNam(char pre, CLEANNODE *cp, int inam, char cwh, char cbeta)
{
   static char fnam[128];
   int i;

   for (i=0; cp && i+cp->ncomps <= inam; cp = cp->next) i += cp->ncomps;
   assert(cp);
   inam -= i;
   sprintf(fnam, "ATL_%cup%cBmm%d_%d_%d_b%c",
           pre, cwh, cp->NBs[inam], cp->imult, cp->fixed, cbeta);
   return(fnam);
}
@beginskip
char *GetUCleanNam(char pre, CLEANNODE *cp, int inam, char cwh, char cbeta)
{
   static char fnam[128];
   strcpy(fnam, GetZCleanNam(GetUCleanNam0(pre, cp, inam, cwh, cbeta)));
   return(fnam);
}
@endskip

int NumUCompsFixed(CLEANNODE *cp, int fix)
{
   int i;

   for(i=0; cp; cp = cp->next)
      if (cp->fixed == fix) i += cp->ncomps;
   return(i);
}
int NumUComps(CLEANNODE *cp)
{
   int i;

   for(i=0; cp; cp = cp->next) i += cp->ncomps;
   return(i);
}

void PrintUHeaders(char pre, FILE *fp, CLEANNODE *cp, char cwh, char cbeta,
                   int FuncPtrs)
{
   int i, n, j, nbet=1;
   char cbe[3] = {'0', '1', 'X'}, cbeta0=cbeta;
   char *reg, *mac, *nob, *typ;
   const char *pargs = "M_, N_, K_, al_, A_, lda_, B_, ldb_";

   if (pre == 's') fprintf(fp, "#define SREAL\n");
   else if (pre == 'd') fprintf(fp, "#define DREAL\n");
   else if (pre == 'c') fprintf(fp, "#define SCPLX\n");
   else if (pre == 'z') fprintf(fp, "#define DCPLX\n");
   fprintf(fp, "#include \"atlas_misc.h\"\n");

   if (pre == 'c' || pre == 'z') nbet = 3;
   else cbe[0] = cbeta0;
   n = NumUComps(cp);

   if (pre == 'c' || pre == 's') typ = "float";
   else typ = "double";

   for (j=0; j < nbet; j++)
   {
      cbeta = cbe[j];
      for (i=0; i < n; i++)
      {
         fprintf(fp, "void %s\n", GetUCleanNam(pre, cp, i, cwh, cbeta));
         fprintf(fp, 
      "   (const int M, const int N, const int K, const %s alpha,\n", typ);
         fprintf(fp, 
      "    const %s *A, const int lda, const %s *B, const int ldb,\n",
                 typ, typ);
         fprintf(fp, 
      "    const %s beta, %s *C, const int ldc);\n", typ, typ);
      }
      if (cwh == 'K') fprintf(fp, "void ATL_%cpKBmm_b%c\n", pre, cbeta);
      else fprintf(fp, "void ATL_%cgp%cBmm_b%c\n", pre, cwh, cbeta);
      fprintf(fp, 
         "   (const int M, const int N, const int K, const %s alpha,\n", typ);
      fprintf(fp, 
      "    const %s *A, const int lda, const %s *B, const int ldb,\n",
              typ, typ);
      fprintf(fp, 
         "    const %s beta, %s *C, const int ldc);\n", typ, typ);
   }
   if (cwh == 'K')
   {
      fprintf(fp, "void ATL_%cgpKBmm\n", pre);
      fprintf(fp, 
      "   (const int M, const int N, const int K, const %s alpha,\n", typ);
      fprintf(fp, 
      "    const %s *A, const int lda, const %s *B, const int ldb,\n",
              typ, typ);
      fprintf(fp, 
      "    const %s beta, %s *C, const int ldc);\n", typ, typ);
   }
/*
 * For complex, create macros for handling complex arithmetic
 */
   if (pre == 'c' || pre == 'z')
   {
      fprintf(fp, "\n");
      cbeta = cbeta0;
      for (i=0; i < n; i++)
      {
         reg = GetUCleanNam(pre, cp, i, cwh, cbeta);
         nob = GetNoBetaNam(reg);
         mac = GetZCleanNam(reg);
         if (FuncPtrs)
         {
            pargs = "M, N, K, alpha, A, lda, B, ldb";
            fprintf(fp, "static void %s\n", mac);
            fprintf(fp, 
         "   (const int M, const int N, const int K, const %s alpha,\n", typ);
            fprintf(fp, 
      "    const %s *A, const int lda, const %s *B, const int ldb,\n", 
                    typ, typ);
            fprintf(fp, 
         "    const %s beta, %s *C, const int ldc)\n{\n", typ, typ);
            fprintf(fp, "   const %s *rA = A + lda*M, *rB = B + ldb*N;\n", typ);
            if (cbeta == '0')
               fprintf(fp, "   %s_b0(%s, ATL_rzero, C, ldc); \n", nob, pargs);
            else if (cbeta == '1')
               fprintf(fp, "   %s_bX(%s, ATL_rnone, C, ldc); \n", nob, pargs);
            else fprintf(fp, "   %s_bX(%s, -beta, C, ldc); \n", nob, pargs);
            fprintf(fp, "   %s_b%c", nob, cbeta);
            fprintf(fp, 
   "(M, N, K, alpha, A, lda, rB, ldb, beta, C+1, ldc); \n");
            fprintf(fp, "   %s_bX", nob, pargs);
            fprintf(fp, 
   "(M, N, K, alpha, rA, lda, rB, ldb, ATL_rnone, C, ldc); \n");
            fprintf(fp, "   %s_b1", nob, pargs);
            fprintf(fp, 
   "(M, N, K, alpha, rA, lda, B, ldb, ATL_rone, C+1, ldc); \n");
         }
         else
         {
            fprintf(fp, 
         "#define %s(M_, N_, K_, al_, A_, lda_, B_, ldb_, be_, C_, ldc_) \\\n",
                    mac);
            fprintf(fp, "{ \\\n");
            if (cbeta == '0')
               fprintf(fp, "   %s_b0(%s, ATL_rzero, C_, ldc_); \\\n",
                       nob, pargs);
            else if (cbeta == '1')
               fprintf(fp, "   %s_bX(%s, ATL_rnone, C_, ldc_); \\\n",
                       nob, pargs);
            else
               fprintf(fp, "   %s_bX(%s, -(be_), C_, ldc_); \\\n",
                       nob, pargs);
            fprintf(fp, "   %s_b%c", nob, cbeta);
            fprintf(fp, 
"(M_, N_, K_, al_, A_, lda_, (B_)+(ldb_)*(N_), ldb_, be_, (C_)+1, ldc_); \\\n");
            fprintf(fp, "   %s_bX", nob, pargs);
            fprintf(fp, "(M_, N_, K_, al_, (A_)+(lda_)*(M_), lda_, (B_)+(ldb_)*(N_), ldb_, ATL_rnone, C_, ldc); \\\n");
            fprintf(fp, "   %s_b1", nob, pargs);
            fprintf(fp, "(M_, N_, K_, al_, (A_)+(lda_)*(M_), lda_, B_, ldb_, ATL_rone, (C_)+1, ldc_); \\\n");
         }
         fprintf(fp, "}\n");
      }
   }
}

CLEANNODE *ReverseNodeList(CLEANNODE *cp0)
/*
 * reverses order of node list
 */
{
   CLEANNODE *cp, *cpR;
   cpR = cp0;
   if (cp0 && cp0->next)
   {
      cp0 = cp0->next;
      cpR->next = NULL;
      while(cp0)
      {
         cp = cp0->next;
         cp0->next = cpR;
         cpR = cp0;
         cp0 = cp;
      }
   }
   return(cpR);
}

const char *MMARGS="(M, N, K, alpha, A, lda, B, ldb, beta, C, ldc)";

void GenUpNB_ap(char pre, enum CW which, CLEANNODE *cp, char cbeta)
/*
 * Generates top-level user cleanup code, using array of function ptrs
 */
{
   CLEANNODE *wp, *cp0;
   FILE *fp;
   int i, j, nb;
   char **funcp;
   const char cwh[3] = {'M', 'N', 'K'};
   char ln[128], st[2], cw;

   nb = cp->nb;
   cw = cwh[which];

   st[0] = cwh[which];
   st[1] = '\0';

   cp0 = ReverseNodeList(cp); /* Reverse order so it's greatest to least */

   if (pre == 'c') pre = 'C';
   else if (pre == 'z') pre = 'Z';
/*
 * Setup func ptr array
 */
   funcp = malloc(nb * sizeof(char *));
   assert(funcp);
   for (i=0; i < nb; i++)
   {
      funcp[i] = malloc(64*sizeof(char));
      assert(funcp[i]);
      funcp[i][0] = '\0';
   }

   for (cp=cp0; cp; cp = cp->next)  /* handle fixed = 2 cases */
   {
      if (cp->fixed == 2)
      {
         i = cp->imult;
         if (funcp[i][0] == '\0')
            sprintf(funcp[i], "ATL_%cup%cBmm%d_%d_%d_b%c",
                    pre, cw, cp->imult, cp->imult, cp->fixed, cbeta);
      }
   }

   for (cp=cp0; cp; cp = cp->next)  /* fixed = 1 cases */
   {
      if (cp->fixed == 1)
      {
         for (i=cp->ncomps-1; i >= 0; i--)
         {
            j = cp->NBs[i];
            if (funcp[j][0] == '\0')
               sprintf(funcp[j], "ATL_%cup%cBmm%d_%d_%d_b%c",
                    pre, cw, cp->NBs[i], cp->imult, cp->fixed, cbeta);
         }
      }
   }
   for (cp=cp0; cp; cp = cp->next)  /* fixed = 0 cases */
   {
      if (cp->fixed == 0)
      {
         for (i=cp->imult; i < nb; i += cp->imult)
         {
            if (funcp[i][0] == '\0')
               sprintf(funcp[i], "ATL_%cup%cBmm0_%d_%d_b%c",
                       pre, cw, cp->imult, cp->fixed, cbeta);
         }
      }
   }
   for (i=0; i < nb; i++) /* point remainder at generated code */
   {
      if (funcp[i][0] == '\0')
      {
         if (which != CleanK)
            sprintf(funcp[i], "ATL_%cgp%cBmm_b%c", tolower(pre), cw, cbeta);
         else sprintf(funcp[i], "ATL_%cgp%cBmm", tolower(pre), cw);
      }
   }

   sprintf(ln, "KERNEL/ATL_%cup%cBmm_b%c.c", tolower(pre), cw, cbeta);
   fp = fopen(ln, "w");
   assert(fp);
   PrintUHeaders(tolower(pre), fp, cp0, cw, cbeta, 1);
   if (which == CleanK && cbeta == '1')
      fprintf(fp, "#include \"%cmm.h\"\n", tolower(pre));
   fprintf(fp, "\n");

   fprintf(fp, 
"typedef void (*MMfunc)(const int, const int, const int, const TYPE,\n");
   fprintf(fp, "                       const TYPE *, const int, const TYPE *, const int,\n");
   fprintf(fp, 
           "                       const TYPE, TYPE *, const int);\n\n");

   fprintf(fp, "void ATL_%cp%cBmm_b%c\n", tolower(pre), cw, cbeta);
   fprintf(fp, 
      "   (const int M, const int N, const int K, const TYPE alpha,\n");
   fprintf(fp, 
      "    const TYPE *A, const int lda, const TYPE *B, const int ldb,\n");
   fprintf(fp, 
      "    const TYPE beta, TYPE *C, const int ldc)\n{\n");
   fprintf(fp, "\n");

   fprintf(fp, "   static MMfunc mmfunc[%d] = \n", nb);
   fprintf(fp, "   {\n");
   fprintf(fp, "      NULL,\n");
   for (i=1; i < nb-1; i++)
   {
      fprintf(fp, "      %s,\n", funcp[i]);
      free(funcp[i]);
   }
   fprintf(fp, "      %s\n   };\n\n", funcp[nb-1]);
   free(funcp[nb-1]);
   free(funcp);

   fprintf(fp, "   mmfunc[%c]%s;\n", cw, MMARGS);

   fprintf(fp, "}\n");

   if (which == CleanK && cbeta == '1')
   {
      fprintf(fp, "void ATL_%cpKBmm_b0\n", tolower(pre));
      fprintf(fp, 
         "   (const int M, const int N, const int K, const TYPE alpha,\n");
      fprintf(fp, 
      "    const TYPE *A, const int lda, const TYPE *B, const int ldb,\n");
      fprintf(fp, 
         "    const TYPE beta, TYPE *C, const int ldc);\n");
      fprintf(fp, "void ATL_%cpKBmm_bX\n", tolower(pre));
      fprintf(fp, 
         "   (const int M, const int N, const int K, const TYPE alpha,\n");
      fprintf(fp, 
      "    const TYPE *A, const int lda, const TYPE *B, const int ldb,\n");
      fprintf(fp, 
         "    const TYPE beta, TYPE *C, const int ldc);\n");
      fprintf(fp, "\n");

      fprintf(fp, "void ATL_%cp%cBmm\n", tolower(pre), cw);
      fprintf(fp, 
         "   (const int M, const int N, const int K, const TYPE alpha,\n");
      fprintf(fp, 
      "    const TYPE *A, const int lda, const TYPE *B, const int ldb,\n");
      fprintf(fp, 
         "    const TYPE beta, TYPE *C, const int ldc)\n{\n");
      fprintf(fp, "   if (M != NB || N != NB)\n");
      fprintf(fp, "      ATL_%cgpKBmm%s;\n", tolower(pre), MMARGS);
      fprintf(fp, "   else if (beta == ATL_rone)\n");
      fprintf(fp, "      ATL_%cpKBmm_b1%s;\n", tolower(pre), MMARGS);
      fprintf(fp, "   else if (beta == ATL_rzero)\n");
      fprintf(fp, "      ATL_%cpKBmm_b0%s;\n", tolower(pre), MMARGS);
      fprintf(fp, "   else\n");
      fprintf(fp, "      ATL_%cpKBmm_bX%s;\n", tolower(pre), MMARGS);

      fprintf(fp, "}\n");
   }
   fclose(fp);
   ReverseNodeList(cp0); /* put order back to ascending */
}

@beginskip
CLEANNODE *MaxCNMult(CLEANNODE *cb)
/*
 * RETURNS: pointer to CLEANNODE with maximum imult value
 */
{
   CLEANNODE *cp, *mcp;
   int maxmult;

   maxmult = cb->imult;
   mcp = cb;
   for (cp=cp->next; cp; cp = cp->next)
   {
      if (cp->imult > maxmult)
      {
         maxmult = cp->imult;
         mcp = cp;
      }
      else
         assert(cp->imult != maxmult);
   }
}

void MoveCUQs(CLEANNODE *cm, CLEANNODE **CB0, CLEANNODE **CB1)
/*
 * Moves cm from queue cb0 to cb1, updating cb0/cb1 as necessary
 */
{
   CLEANNODE *cp, *cb0=(*CB0), *cb1=(*CB1), *prev;

   prev = NULL;
   for (cp=cb0; cp != cm; cp = cp->next)
      prev = cp;
/*
 * Remove cm from cb0
 */
   if (prev)
      prev->next = cm->next;
   else
      cb0 = cb0->next;
   cm->next = NULL;
/*
 * Add cm to cb1
 */
   if (cb1)
   {
      for (cp=cb1; cp->next; cp = cp->next);
      cp->next = cm;
   }
   else
      cb1 = cm;

   *CB0 = cb0;
   *CB1 = cb1;
}

CLEANNODE *SortCNByMult(CLEANNODE *cb)
/*
 * Sorts CLEANNODE queue from largest imult to smallest
 */
{
   CLEANNODE *sb=NULL, *cp, *maxcp;

   while (cb)
   {
      maxcp = MaxCNMult(cb);
      MoveCUQs(maxcp, &cb, &sb);
   }
}
@endskip

void GenUpNB_if(char pre, enum CW which, CLEANNODE *cp, char cbeta)
/*
 * Generates top-level user cleanup code, using ifs to determine who to call
 */
{
   CLEANNODE *wp, *cp0;
   FILE *fp;
   int i;
   const char *ifs = "else if", *ifp, *sp;
   const char cwh[3] = {'M', 'N', 'K'};
   char ln[128], st[2], *typ;

   if (pre == 's' || pre == 'c') typ = "float";
   else typ = "double";

   sprintf(ln, "KERNEL/ATL_%cup%cBmm_b%c.c", pre, cwh[which], cbeta);
   fp = fopen(ln, "w");
   assert(fp);
   st[0] = cwh[which];
   st[1] = '\0';
   PrintUHeaders(pre, fp, cp, cwh[which], cbeta, 0);
   if (which == CleanK && cbeta == '1')
      fprintf(fp, "#include \"%cmm.h\"\n", pre);
   fprintf(fp, "\n");
   cp0 = ReverseNodeList(cp); /* Reverse order so it's greatest to least */
   ifp = ifs + 5;

   fprintf(fp, "void ATL_%cp%cBmm_b%c\n", pre, cwh[which], cbeta);
   fprintf(fp, 
      "   (const int M, const int N, const int K, const %s alpha,\n", typ);
   fprintf(fp, 
      "    const %s *A, const int lda, const %s *B, const int ldb,\n",
           typ, typ);
   fprintf(fp, 
      "    const %s beta, %s *C, const int ldc)\n{\n", typ, typ);
   fprintf(fp, "\n");

   if (pre == 'c') pre = 'C';
   else if (pre == 'z') pre = 'Z';
/*
 * fixed=2 means a kernel specialized for that exact N.  They will have not
 * survived pruning if they weren't better than all the general algorithms,
 * so we can test for them all up front
 */
   for (cp=cp0; cp; cp = cp->next)  /* handle fixed = 2 cases */
   {
      if (cp->fixed == 2)
      {
         fprintf(fp, "   %s (%c == %d)\n", ifp, cwh[which], cp->imult);
         fprintf(fp, "   {\n      ATL_%cup%cBmm%d_%d_%d_b%c%s;\n   }\n",
                 pre, cwh[which], cp->imult, cp->imult, cp->fixed,
                 cbeta, MMARGS);
         ifp = ifs;
      }
   }
/*
 * All remaining kernels are selected by being a multiple of imult;
 * fixed=0 will be called directly, while fixed=1 will have a nested
 * if to find the right compiled version to call
 */
   for (cp=cp0; cp; cp = cp->next)  /* fixed = 0/1 cases */
   {
      if (cp->fixed != 1 && cp->fixed != 0)
         continue;
      if (cp->imult > 1)
         fprintf(fp, "   %s (%c == %s)\n", ifp, cwh[which],
                 GetInc(cp->imult, GetDiv(cp->imult, st)));
      else if (ifp == ifs) fprintf(fp, "   else\n");
      if (cp->fixed == 0)
      {
         fprintf(fp, "   {\n      ATL_%cup%cBmm0_%d_%d_b%c%s;\n   }\n",
                 pre, cwh[which], cp->imult, cp->fixed, cbeta, MMARGS);
         ifp = ifs;
      }
      else if (cp->fixed == 1)
      {
         fprintf(fp, "   {\n");
         if (cp->ncomps == 1)
            fprintf(fp, "      ATL_%cup%cBmm%d_%d_%d_b%c%s;\n",
                    pre, cwh[which], cp->NBs[0], cp->imult, cp->fixed,
                    cbeta, MMARGS);
         else  /* must select kernel by NB[i] */
         {
            sp = "if";
            for (i=cp->ncomps-1; i >= 0; i--)
            {
               fprintf(fp, "      %s (%c == %d)\n", sp, cwh[which], cp->NBs[i]);
               fprintf(fp, 
               "      {\n         ATL_%cup%cBmm%d_%d_%d_b%c%s;\n      }\n",
                       pre, cwh[which], cp->NBs[i], cp->imult, cp->fixed,
                       cbeta, MMARGS);
               sp = "else if";
            }
         }
         fprintf(fp, "   }\n");
      }
   }

   for (cp=cp0; cp && cp->imult != 1; cp = cp->next);
   if (!cp)
   {
      if (which == CleanK)
         fprintf(fp, "   else ATL_%cgp%cBmm%s;\n", tolower(pre), cwh[which],
                 MMARGS);
      else fprintf(fp, "   else ATL_%cgp%cBmm_b%c%s;\n",
                   tolower(pre), cwh[which], cbeta, MMARGS);
   }
   fprintf(fp, "}\n");
   if (which == CleanK && cbeta == '1')
   {
      fprintf(fp, "void ATL_%cpKBmm_b0\n", tolower(pre));
      fprintf(fp, 
         "   (const int M, const int N, const int K, const TYPE alpha,\n");
      fprintf(fp, 
      "    const TYPE *A, const int lda, const TYPE *B, const int ldb,\n");
      fprintf(fp, 
         "    const TYPE beta, TYPE *C, const int ldc);\n");
      fprintf(fp, "void ATL_%cpKBmm_bX\n", tolower(pre));
      fprintf(fp, 
         "   (const int M, const int N, const int K, const TYPE alpha,\n");
      fprintf(fp, 
      "    const TYPE *A, const int lda, const TYPE *B, const int ldb,\n");
      fprintf(fp, 
         "    const TYPE beta, TYPE *C, const int ldc);\n");
      fprintf(fp, "\n");

      fprintf(fp, "void ATL_%cp%cBmm\n", tolower(pre), cwh[which]);
      fprintf(fp, 
         "   (const int M, const int N, const int K, const %s alpha,\n", typ);
      fprintf(fp, 
      "    const %s *A, const int lda, const %s *B, const int ldb,\n",
              typ, typ);
      fprintf(fp, 
         "    const %s beta, %s *C, const int ldc)\n{\n", typ, typ);
      fprintf(fp, "   if (M != NB || N != NB)\n");
      fprintf(fp, "      ATL_%cgpKBmm%s;\n", tolower(pre), MMARGS);
      fprintf(fp, "   else if (beta == ATL_rone)\n");
      fprintf(fp, "      ATL_%cpKBmm_b1%s;\n", tolower(pre), MMARGS);
      fprintf(fp, "   else if (beta == ATL_rzero)\n");
      fprintf(fp, "      ATL_%cpKBmm_b0%s;\n", tolower(pre), MMARGS);
      fprintf(fp, "   else\n");
      fprintf(fp, "      ATL_%cpKBmm_bX%s;\n", tolower(pre), MMARGS);

      fprintf(fp, "}\n");
   }
   fclose(fp);
   ReverseNodeList(cp0); /* put order back to ascending */
}

void GenAllUNBCases(char pre, enum CW which, CLEANNODE *cp)
{
   char cwh[3] = {'M', 'N', 'K'};
   char cbeta[3] = {'0', '1', 'X'};
   char ln[128];
   int i, j, n, *NBs, NB[3];
   FILE *fp;

   NB[0] = NB[1] = NB[2] = cp->nb;
   n = cp->ncomps;
   assert(n);
   NBs = cp->NBs;

   for (j=0; j < n; j++)
   {
      NB[which] = NBs[j];
      for (i=0; i < 3; i++)
      {
         sprintf(ln, "KERNEL/ATL_%cup%cBmm%d_%d_%d_b%c.c", 
                 pre, cwh[which], NBs[j], cp->imult, cp->fixed, cbeta[i]);
         fp = fopen(ln, "w");
         assert(fp);
         emit_uhead(fp, pre, which, NB[0], NB[1], NB[2], cp->imult, cp->fixed,
                    cp->NBs[j], i);
         fclose(fp);
         sprintf(ln, "cat CASES/%s >> KERNEL/ATL_%cup%cBmm%d_%d_%d_b%c.c\n",
                 cp->rout, pre, cwh[which], NBs[j], cp->imult, cp->fixed,
                 cbeta[i]);
         if (system(ln))
         {
            fprintf(stderr, "\nFAILED: %s\n\n", ln);
            assert(0);
         }
      }
   }
}

CLEANNODE *GenUCleanX(char pre, enum CW which)
{
   CLEANNODE *cp, *cp0;

   for (cp0=cp=GetUCleanInfo(pre, which); cp; cp = cp->next)
      GenAllUNBCases(pre, which, cp);
   if (cp0)
   {
      if (NumUComps(cp0) > 3)
      {
         GenUpNB_ap(pre, which, cp0, '0');
         GenUpNB_ap(pre, which, cp0, '1');
         GenUpNB_ap(pre, which, cp0, 'X');
      }
      else
      {
         GenUpNB_if(pre, which, cp0, '0');
         GenUpNB_if(pre, which, cp0, '1');
         GenUpNB_if(pre, which, cp0, 'X');
      }
   }

   return(cp0);
}

int DoClean(char *spc, char pre, char *type, CLEANNODE **cp)
{
   int i, kb;
fprintf(stderr, "line %d of %s\n", __LINE__, __FILE__);
   kb = GenKBmm(spc, pre, type);
fprintf(stderr, "line %d of %s\n", __LINE__, __FILE__);
   GenMNClean(spc, pre, type);
fprintf(stderr, "line %d of %s\n", __LINE__, __FILE__);
   for (i=0; i < 3; i++) cp[i] = GenUCleanX(pre, i);
   return(kb);
}

void GetGenRes(char pre, int *muladd, int *pref, int *lat, int *nb, 
               int *mu, int *nu, int *ku, int *ffetch, int *ifetch, 
               int *nfetch, double *mf)
{
   ATL_mmnode_t *mmp;

   mmp = ReadMMFileWithPath(pre, "res", "MMRES.sum");
   assert(mmp);
   *muladd = mmp->muladd;
   *pref = mmp->pref;
   *lat = mmp->lat;
   *nb = mmp->nbB;
   *mu = mmp->mu;
   *nu = mmp->nu;
   *ku = mmp->ku;
   *ffetch = mmp->fftch;
   *ifetch = mmp->iftch;
   *nfetch = mmp->nftch;
   *mf = mmp->mflop[0];
   KillAllMMNodes(mmp);
}
int DoNocopyTT(char *spc, char pre, char *type, char cTA, char cTB)
{
   char fnam[128];
   const int COMPLEX = (pre == 'c' || pre == 'z');
   char *bnams[3] = {"_b0", "_b1", "_bX"}, *anams[2] = {"_a1", "_aX"};
   int betas[3] = {0, 1, 8}, alphas[2] = {1, 8};
   int NB, muladd, lat, mb, nb, kb, mu, nu, ku, ffetch, ifetch, nfetch;
   int mul=1, i, j, pfA;
   enum ATLAS_TRANS TA, TB;
   double mflop;
   FILE *fp;

   if (cTA == 'N') TA = AtlasNoTrans;
   else TA = AtlasTrans;
   if (cTB == 'N') TB = AtlasNoTrans;
   else TB = AtlasTrans;

   if (COMPLEX) mul = 2;
   sprintf(fnam, "res/%cNCNB", pre);
   fp = fopen(fnam, "r");
   assert(fp);
   fscanf(fp, " %d", &NB);
   fclose(fp);

   sprintf(fnam, "res/%cbest%c%c_%dx%dx%d", pre, cTA, cTB, NB, NB, NB);
   GetInstLogFile(fnam, pre, &muladd, &pfA, &lat, &nb, &mu, &nu, &ku, 
                  &ffetch, &ifetch, &nfetch, &mflop);
   mb = kb = nb;
   for (j=0; j < 2; j++)
   {
      for (i=0; i < 3; i++)
      {
         sprintf(fnam, "KERNEL/ATL_%cNCmm%c%c%s%s.c", pre, cTA, cTB, 
                  anams[j], bnams[i]);
         fp = fopen(fnam, "w");
         assert(fp);
         ncucases = 0;
         emit_mm(fp, spc, pre, type, "", AtlasJIK, TA, TB, 1, muladd, pfA, lat,
                 ffetch, ifetch, nfetch, mb, nb, kb, mu, nu, ku, mul, mul, mul,
                 0, 0, 0, alphas[j], betas[i]);
         fclose(fp);
      }
   }

   sprintf(fnam, "res/%cbest%c%c_0x0x%d", pre, cTA, cTB, NB);
   GetInstLogFile(fnam, pre, &muladd, &pfA, &lat, &nb, &mu, &nu, &ku, 
                  &ffetch, &ifetch, &nfetch, &mflop);
   kb = nb;
   mb = nb = 0;
   sprintf(fnam, "KERNEL/ATL_%cNCCUmm%c%c_K.c", pre, cTA, cTB);
   fp = fopen(fnam, "w");
   assert(fp);
   ncucases = 0;
   emit_mm(fp, spc, pre, type, "", AtlasJIK, TA, TB, 1, muladd, pfA, lat, 
           ffetch, ifetch, nfetch, mb, nb, kb, mu, nu, ku, mul, mul, mul, 
           0, 0, 0, 8, 8);
   fclose(fp);

   sprintf(fnam, "res/%cbest%c%c_0x0x0", pre, cTA, cTB);
   GetInstLogFile(fnam, pre, &muladd, &pfA, &lat, &nb, &mu, &nu, &ku, 
                  &ffetch, &ifetch, &nfetch, &mflop);
   kb = mb = nb = 0;
   sprintf(fnam, "KERNEL/ATL_%cNCCUmm%c%c.c", pre, cTA, cTB);
   fp = fopen(fnam, "w");
   assert(fp);
   ncucases = 0;
   emit_mm(fp, spc, pre, type, "", AtlasJIK, TA, TB, 1, muladd, pfA, lat, 
           ffetch, ifetch, nfetch, mb, nb, kb, mu, nu, ku, mul, mul, mul, 
           0, 0, 0, 8, 8);
   fclose(fp);
   return(NB);
}

void DoNocopy(char *spc, char pre, char *type)
{
   char fnam[128];
   int muladd, lat, NB, nb, mu, nu, ku, ffetch, ifetch, nfetch, pfA;
   double mflop;
   FILE *fp;

   DoNocopyTT(spc, pre, type, 'N', 'N');
   DoNocopyTT(spc, pre, type, 'N', 'T');
   DoNocopyTT(spc, pre, type, 'T', 'N');
   NB = DoNocopyTT(spc, pre, type, 'T', 'T');

@beginskip
   sprintf(fnam, "res/%cMMRES", pre);
   GetInstLogFile(fnam, pre, &muladd, &pfA, &lat, &nb, &mu, &nu, &ku, 
                  &ffetch, &ifetch, &nfetch, &mflop);
@endskip
   GetGenRes(pre, &muladd, &pfA, &lat, &nb, &mu, &nu, &ku,
             &ffetch, &ifetch, &nfetch, &mflop);

   sprintf(fnam, "atlas_%cNCmm.h", pre);
   fp = fopen(fnam, "w");
   assert(fp);
   emit_head(1, fp, pre, NB, muladd, lat, mu, nu, ku);
   fclose(fp);
}

void GetMMRES(char pre, int *muladd, int *lat, int *nb,
              int *mu, int *nu, int *ku, int *ff, int *iff, int *nf,
              double *mf, int *icase, char *ufile, char *auth, double *umf)
{
   int h, i, j, k;
   char ln[256];
   FILE *fp;
   ATL_mmnode_t *mmp;

   #if VERB > 0
      fprintf(stderr, "%d of %s\n", __LINE__, __FILE__);
   #endif
   GetGenRes(pre, muladd, &h, lat, nb, mu, nu, ku, ff, iff, nf, mf);
   mmp = ReadMMFileWithPath(pre, "res", "MMRES.sum");
   assert(mmp);
   if (mmp->next)
   {
      strcpy(ufile, mmp->next->rout);
      strcpy(auth, mmp->next->auth ? mmp->next->auth : "R. Clint Whaley");
      *icase = mmp->next->ID;
      *umf = mmp->next->mflop[0];
   }
   else
   {
      ufile[0] = auth[0] = '\0';
      *umf = 0.0;
      *icase = -1;
   }
   KillAllMMNodes(mmp);
   #if VERB > 0
      fprintf(stderr, "%d of %s\n", __LINE__, __FILE__);
   #endif
@beginskip
   sprintf(ln, "INSTALL_LOG/%cMMRES", pre);
   fp = fopen(ln, "r");
   assert(fp);
   fgets(ln, 256, fp);
   fgets(ln, 256, fp);
   assert(sscanf(ln, " %d %d %d %d %d %d %d %d %d %lf", muladd, lat, nb,
                 mu, nu, ku, ff, iff, nf, mf) == 10);
   fgets(ln, 256, fp);
   if ( fgets(ln, 256, fp) )  /* user-supplied GEMM was best */
   {
      assert(fscanf(fp, " %d %d %lf \"%[^\"]\" \"%[^\"]", 
                    &icase, &i, umf, ufile, auth) == 5);
   }
   else
   {
      ufile[0] = auth[0] = '\0';
      *umf = 0.0;
      *icase = -1;
   }
   fclose(fp);
@endskip
}

@beginskip
CLEANNODE *GetUNBmmInfo(char pre, double gmf, double *umf)
{
   double mf;
   CLEANNODE *cp=NULL;
   FILE *fp;
   char *MCC, *MMFLAGS;
   int j, icase, nb;
   char ln[128];

   sprintf(ln, "res/%cuMMRES", pre);
   fp = fopen(ln, "r");
   assert(fp);
   assert(fgets(ln, 128, fp));
   assert(fgets(ln, 128, fp));
   fclose(fp);
   assert(sscanf(ln, " %d %d %lf", &icase, &nb, &mf) == 3);
   if (mf > 1.02*gmf)
   {
      cp = malloc(sizeof(CLEANNODE));
      assert(cp);
      cp->nb = cp->imult = nb;
      cp->icase = icase;
      cp->fixed = 2;
      GetUserCase(pre, icase, &j, &j, &j, &j, &j, &j, &j, &j, &j, cp->rout, ln,
                  &MCC, &MMFLAGS);
      if (MCC) strcpy(cp->CC, MCC);
      else cp->CC[0] = '\0';
      if (MMFLAGS) strcpy(cp->CCFLAGS, MMFLAGS);
      else cp->CCFLAGS[0] = '\0';
      cp->NBs = malloc(sizeof(int));
      assert(cp->NBs);
      cp->ncomps = 1;
      cp->next = NULL;
   }
   if (umf) *umf = mf;
   return(cp);
}
@endskip

ATL_mmnode_t *DoUNBmm(char pre, double gmf)
{
   char ln[256];
   ATL_mmnode_t *mmp, *umm;
   FILE *fp;
   int nb, i;
   char beta[3] = {'0', '1', 'X'};

   #if VERB > 0
      fprintf(stderr, "%d of %s\n", __LINE__, __FILE__);
   #endif
   mmp = ReadMMFileWithPath(pre, "res", "MMRES.sum");
   assert(mmp);
   umm = KillMMNode(mmp);
   if (umm)  /* generate the files into the KERNEL/ if using user-contrib */
   {
      nb = umm->nbB;
      for (i=0; i < 3; i++)
      {
         sprintf(ln, "KERNEL/ATL_%cNBmm_b%c.c", pre, beta[i]);
         fp = fopen(ln, "w");
         assert(fp);
         emit_uhead(fp, pre, CleanNot, nb, nb, nb, nb, nb, 0, i);
         fclose(fp);
         sprintf(ln, "cat %s >> KERNEL/ATL_%cNBmm_b%c.c",
                 umm->rout, pre, beta[i]);
         assert(!system(ln));
      }
   }
   #if VERB > 0
      fprintf(stderr, "%d of %s\n", __LINE__, __FILE__);
   #endif
   return(umm);
@beginskip
   CLEANNODE *cp;
   FILE *fp;
   int i, nb;
   char ln[256];
   char beta[3] = {'0', '1', 'X'};
   
   cp = GetUNBmmInfo(pre, gmf, NULL);
   if (cp)
   {
      nb = cp->nb;
      for (i=0; i < 3; i++)
      {
         sprintf(ln, "KERNEL/ATL_%cNBmm_b%c.c", pre, beta[i]);
         fp = fopen(ln, "w");
         assert(fp);
         emit_uhead(fp, pre, CleanNot, nb, nb, nb, nb, nb, 0, i);
         fclose(fp);
         sprintf(ln, "cat CASES/%s >> KERNEL/ATL_%cNBmm_b%c.c",
                 cp->rout, pre, beta[i]);
         assert(system(ln) == 0);
      }
   }
   return(cp);
@endskip
}

CLEANNODE *DoNBmm(char *spc, char pre, char *type, int *nb0)
{
   char fnam[128], ln[256];
   char *bnams[3] = {"_b0", "_b1", "_bX"};
   int betas[3] = {0, 1, 8};
   int i, muladd, lat, mb, nb, kb, mu, nu, ku, ffetch, ifetch, nfetch;
   int nreg, maU, latU, muU, nuU, kuU, pfA;
   int mulC = 1;
   double mflop, mfU;
   FILE *fp;
   CLEANNODE *cp=NULL;
   ATL_mmnode_t *umm;

   if (pre == 'c' || pre == 'z') mulC = 2;

   #if VERB > 0
      fprintf(stderr, "%d of %s\n", __LINE__, __FILE__);
   #endif
@beginskip
   sprintf(ln, "res/%cMMRES", pre);
   GetInstLogFile(ln, pre, &muladd, &pfA, &lat, &nb, &mu, &nu, &ku, 
                  &ffetch, &ifetch, 
            &nfetch, &mflop);
@endskip
   GetGenRes(pre, &muladd, &pfA, &lat, &nb, &mu, &nu, &ku, 
             &ffetch, &ifetch, &nfetch, &mflop);
   *nb0 = nb;

   umm = DoUNBmm(pre, mflop);

   if (!umm) /* using generated code */
   {
      kb = mb = nb;
      for (i=0; i < 3; i++)
      {
         sprintf(ln, "KERNEL/ATL_%cNBmm%s.c", pre, bnams[i]);
         fp = fopen(ln, "w");
         assert(fp);
         ncucases = 0;
         emit_mm(fp, spc, pre, type, "", AtlasJIK, AtlasTrans, AtlasNoTrans, 0,
                 muladd, pfA, lat, ffetch, ifetch, nfetch, mb, nb, kb, 
                 mu, nu, ku, 1, 1, mulC, kb, kb, 0, 1, betas[i]);
         fclose(fp);
      }
      ncucases = 0;
   }
   else
   {
/*
 *    Translate external MM stored in ATL_mmnode_t to CLEANNODE
 */
      *nb0 = nb = umm->nbB;
      cp = malloc(sizeof(CLEANNODE));
      assert(cp);
      cp->nb = cp->imult = nb;
      cp->icase = umm->ID;
      cp->fixed = 2;
      cp->CC[0] = cp->CCFLAGS[0] = '\0';
      if (umm->comp)
         strcpy(cp->CC, umm->comp);
      if (umm->cflags)
         strcpy(cp->CCFLAGS, umm->cflags);
      cp->NBs = malloc(sizeof(int));
      assert(cp->NBs);
      cp->ncomps = 1;
      cp->next = NULL;
   }
   sprintf(fnam, "%cmm.h", pre);
   fp = fopen(fnam, "w");
   assert(fp);
   #if VERB > 0
      fprintf(stderr, "%d of %s\n", __LINE__, __FILE__);
   #endif
/*
 * If using the user kernel, make sure MU and NU match the user params,
 * not the generated.  Use generated lat, muladd, since this info may
 * be bogus from user, and can't affect user cases
 */
   if (umm)
   {
      emit_head(0, fp, pre, nb, muladd, lat, umm->mu, umm->nu, umm->ku);
      KillAllMMNodes(umm);
   }
   else
      emit_head(0, fp, pre, nb, muladd, lat, mu, nu, ku);
   fclose(fp);
   #if VERB > 0
      fprintf(stderr, "%d of %s\n", __LINE__, __FILE__);
   #endif
   return(cp);
}

void DoInstall(char *spc, char pre, char *type)
{
   CLEANNODE *cp[4];
   char cbeta[3] = {'0', '1', 'X'};
   int i, nb, kb;

   assert(!system("make xummsearch"));  /* create .dsc files indexing */
   #if VERB > 0
      fprintf(stderr, "%d of %s\n", __LINE__, __FILE__);
   #endif
   cp[3] = DoNBmm(spc, pre, type, &nb);
   #if VERB > 0
      fprintf(stderr, "%d of %s\n", __LINE__, __FILE__);
   #endif
   DoNocopy(spc, pre, type);
   #if VERB > 0
      fprintf(stderr, "%d of %s\n", __LINE__, __FILE__);
   #endif
   #if VERB > 0
      fprintf(stderr, "%d of %s\n", __LINE__, __FILE__);
   #endif
   kb = DoClean(spc, pre, type, cp);
   #if VERB > 0
      fprintf(stderr, "%d of %s\n", __LINE__, __FILE__);
   #endif
   GenMakefile(pre, nb, kb, 3, cbeta, cp);
   for (i=0; i < 3; i++) KillCleanNodes(cp[i]);
}
void PrintUsage(char *nam)
{
   fprintf(stderr, "USAGE: %s <flags>; flags include:\n", nam);
   fprintf(stderr, "   -p <pre> : choices [s,c,d,z]\n");
   fprintf(stderr, 
           "   -muladd 0/1 : 1 - combined MACC, 0 - separate mul & add\n");
   fprintf(stderr, "   -ta <n/t> : A's transpose setting\n");
   fprintf(stderr, "   -tb <n/t> : B's transpose setting\n");
   fprintf(stderr, "   -l <lat>  : latency between multiply and add\n");
   fprintf(stderr, "   -m <mu>   : M-loop unrolling\n");
   fprintf(stderr, "   -n <nu>   : N-loop unrolling\n");
   fprintf(stderr, "   -k <ku>   : K-loop unrolling\n");
   fprintf(stderr, "   -[M,N,K] <lim> : 0 - loop limit is runtime variable\n");
   fprintf(stderr, 
           "                    else - int is compile-time loop limit\n");
   fprintf(stderr, "   -ld[a,b,c]: 0 - leading dim is runtime variable\n");
   fprintf(stderr, "               else - leading dim is provided constant\n");
   fprintf(stderr, "   -cs[A,B,C]: col stride of array\n");
   fprintf(stderr, "   -alpha <int>: alpha to generate (1,other)\n");
   fprintf(stderr, "   -beta  <int>: beta  to generate (1,-1,0,other)\n");
   fprintf(stderr, "   -L IJK/JIK  : loop order to use\n");
   fprintf(stderr, "   -f <file>   : file to output genned routine to\n");
   fprintf(stderr, 
           "   -F0 <int>   : # of reg fetches to perf before 1st flop\n");
   fprintf(stderr, 
           "   -FN <int>   : # of reg fetches to perf after each flop\n");
   fprintf(stderr, "   -FF 0/1 : don't/do useless load of C at top\n");
   fprintf(stderr, "   -Cleanup 0/1 : don't/do gen cleanup code\n");
   fprintf(stderr, "   -Z 0/1 : don't/do gen all complex kernel cases\n");
   fprintf(stderr, "   -R <int> : what do you want emitted:\n");
   fprintf(stderr, "     -2 : gen all files necessary for install\n");
   fprintf(stderr, "     -3 : emit header for use with user-supplied kernel\n");
   fprintf(stderr, "     else : emit usual generated gemm kernel\n");
   fprintf(stderr, "   -pfA <int> : type of prefetch to do, OR together:\n");
   fprintf(stderr, "      0: no prefetch performed\n");
   fprintf(stderr,"      1: pref next blk of A during this iter computation\n");
   fprintf(stderr, "      2: pref C at top of M-loop\n");
   fprintf(stderr, "    -Si <what> <int> : special instructions:\n");
   fprintf(stderr, 
   "    -Si temp 0/1/2 : store all temp results as TYPE/double/long double\n");
   exit(-1);
}
void GetFlags(int nargs, char **args, FILE **fpout, char *pre, int *CleanUp,
              int *muladd, int *ForceFetch, int *ifetch, int *nfetch, 
              enum ATLAS_LOOP_ORDER *LoopOrder, 
              enum ATLAS_TRANS *TA, enum ATLAS_TRANS *TB, int *pfA, int *lat, 
              int *mu, int *nu, int *ku, int *M, int *N, int *K, 
              int *lda, int *ldb, int *ldc, int *csA, int *csB, int *csC, 
              int *alpha, int *beta, int *CplxTst, int *rout)
{
   int i;

/*
 * Defaults
 */
   *muladd = 0;
   *ForceFetch = 0;
   *CleanUp = 0;
   *pre = 'd';
   *fpout = stdout;
   *LoopOrder = AtlasJIK;
   *ifetch = *nfetch = -1;
   *TA = AtlasTrans;
   *TB = AtlasNoTrans;
   *lat = 4;
   *mu = 4;
   *nu = 4;
   *ku = 1;
   *M = *N = *K = 0;
   *lda = *ldb = *ldc = 0;
   *csA = *csB = *csC = 1;
   *alpha = *beta = 1;
   *CplxTst = 0;
   *rout = -1;
   *pfA = 0;

   for (i=1; i < nargs; i++)
   {
      if (args[i][0] != '-') PrintUsage(args[0]);
      switch(args[i][1])
      {
      case 'R':
         *rout = atoi(args[++i]);
         break;
      case 'C':
         *CleanUp = atoi(args[++i]);
         break;
      case 'Z':
         *CplxTst = atoi(args[++i]);
         break;
      case 'p':
         if (args[i][2] == 'f' && args[i][3] == 'A')
         {
            *pfA = atoi(args[++i]);
            if (*pfA & 512)  /* pfA cheesily used as flag for ld@bottom */
            {
               *pfA ^= 512;
               LD_AT_BOTTOM = 1;
            }
         }
         else
         {
            *pre = tolower(args[++i][0]);
            if (*pre != 'd' && *pre != 's' && *pre != 'c' && *pre != 'z')
               PrintUsage(args[0]);
         }
         break;
      case 'S':
         if (!strcmp(args[++i], "temp"))
            TEMP_TYPE = atoi(args[++i]);
         else
            PrintUsage(args[0]);
      case 'L':
         i++;
         if (tolower(args[i][0]) == 'i') *LoopOrder = AtlasIJK;
         else if (tolower(args[i][0]) == 'j') *LoopOrder = AtlasJIK;
         else PrintUsage(args[0]);
         if ( (tolower(args[i][1]) != 'i' && tolower(args[i][1]) != 'j') ||
              (tolower(args[i][2]) != 'k') )
            PrintUsage(args[0]);
         break;
      case 'f':
         *fpout = fopen(args[++i], "w");
         assert(*fpout);
         break;
      case 'F':
         switch(tolower(args[i][2]))
         {
         case '0':
            *ifetch = atoi(args[++i]);
            break;
         case 'n':
            *nfetch = atoi(args[++i]);
            break;
         case 'f':
            *ForceFetch = atoi(args[++i]);
            break;
         default:
            fprintf(stderr, "What the heck: flag=%s %s???\n", 
                    args[i], args[i+1]);
            PrintUsage(args[0]);
         }
         break;
      case 'a':
         *alpha = atoi(args[++i]);
         break;
      case 'b':
         *beta  = atoi(args[++i]);
         break;
      case 'm':
         if (args[i][2] == 'u') *muladd = atoi(args[++i]);
         else *mu = atoi(args[++i]);
         break;
      case 't':
         if (args[i][2] == 'a' || args[i][2] == 'A')
         {
            i++;
            if (args[i][0] == 'n' || args[i][0] == 'N') *TA = AtlasNoTrans;
            else if (args[i][0] == 't' || args[i][0] == 'T') *TA = AtlasTrans;
            else
            {
               fprintf(stderr, "What the hell: TA = ???%s???\n", args[i]);
               PrintUsage(args[0]);
            }
         }
         else if (args[i][2] == 'b' || args[i][2] == 'B')
         {
            i++;
            if (args[i][0] == 'n' || args[i][0] == 'N') *TB = AtlasNoTrans;
            else if (args[i][0] == 't' || args[i][0] == 'T') *TB = AtlasTrans;
            else
            {
               fprintf(stderr, "What the hell: TB = ???%s???\n", args[i]);
               PrintUsage(args[0]);
            }
         }
         else PrintUsage(args[0]);
         break;
      case 'l':
         if (args[i][2] == '\0') *lat = atoi(args[++i]);
         else if (tolower(args[i][2]) != 'd') PrintUsage(args[0]);
         else
         {
            switch(tolower(args[i][3]))
            {
            case 'a': 
               *lda = atoi(args[++i]);
               break;
            case 'b':
               *ldb = atoi(args[++i]);
               break;
            case 'c':
               *ldc = atoi(args[++i]);
               break;
            default:
               fprintf(stderr, "What the heck: flag=%s %s???\n", 
                       args[i], args[i+1]);
               PrintUsage(args[0]);
            }
         }
         break;
      case 'n':
         *nu = atoi(args[++i]);
         break;
      case 'k':
         *ku = atoi(args[++i]);
         break;
      case 'M':
         *M = atoi(args[++i]);
         break;
      case 'N':
         *N = atoi(args[++i]);
         break;
      case 'K':
         *K = atoi(args[++i]);
         break;
      case 'c':
         if (args[i][2] != 's') PrintUsage(args[0]);
         switch (tolower(args[i][3]))
         {
         case 'a':
            *csA = atoi(args[++i]);
            break;
         case 'b':
            *csB = atoi(args[++i]);
            break;
         case 'c':
            *csC = atoi(args[++i]);
            break;
         default:
            fprintf(stderr, "What the heck: flag=%s %s???\n", 
                    args[i], args[i+1]);
            PrintUsage(args[0]);
         }
         break;
      }
   }
}

int main(int nargs, char **args)
{
   char *spcs = "                                                            ";
   char *spc = spcs+60;
   char pre, *type;
   FILE *fpout;
   enum ATLAS_TRANS TA, TB;
   enum ATLAS_LOOP_ORDER LoopOrder;
   int muladd, lat, mu, nu, ku, M, N, K, lda, ldb, ldc, csA, csB, csC, pfA;
   int alpha, beta, ifetch, nfetch, CleanUp, ForceFetch, CplxTst, rout;

   GetFlags(nargs, args, &fpout, &pre, &CleanUp, &muladd, &ForceFetch, 
            &ifetch, &nfetch, &LoopOrder, &TA, &TB, &pfA, &lat, &mu, &nu, &ku, 
            &M, &N, &K, &lda, &ldb, &ldc, &csA, &csB, &csC, &alpha, &beta,
            &CplxTst, &rout);
   if (mu == 1 && nu == 1 && ku == 1 && K == 0 && muladd == 0) muladd = 1;
   if (CleanUp && K == 0) /* don't let K-cleanup get too large */
   {
      while(ku > 1 && mu*nu*ku*ku > 4096) ku--;
      if (!muladd) while (lat > 1 && mu*nu*ku % lat) lat--;
   }
   fprintf(stderr, "pre=%c, CU=%d, ma=%d, ff=%d, if=%d, nf=%d, lo=%d, ta=%d, tb=%d, lat=%d, mu=%d, nu=%d, ku=%d, m=%d, n=%d, k=%d, lda=%d, ldb=%d, ldc=%d, csA=%d, csB=%d, csC=%d, alpha=%d, beta=%d\n\n", 
           pre, CleanUp, muladd, ForceFetch, ifetch, nfetch, LoopOrder, TA, TB,
           lat, mu, nu, ku, M, N, K, lda, ldb, ldc, csA, csB, csC, alpha, beta);
   switch (pre)
   {
      case 'd':
      case 'z':
         type = "double";
         break;
      case 's':
      case 'c':
         type = "float";
         break;
   }
   if (ifetch == -1) ifetch = mu + nu;
   if (rout == -2) DoInstall(spc, pre, type);
   else if (rout == -3)
      emit_uhead(fpout, pre, CleanNot, M, N, K, lda, ldb, ldc, beta);
   else
   {
      emit_mm(fpout, spc, pre, type, "", LoopOrder, TA, TB, CleanUp, muladd,
              pfA, lat, ForceFetch, ifetch, nfetch, M, N, K, mu, nu, ku, 
              csA, csB, csC, lda, ldb, ldc, alpha, beta);
/*      if (CplxTst && (pre == 'c' || pre == 'z') && M && N && K) */
      if (CplxTst && (pre == 'c' || pre == 'z'))
      {
         ncucases=0;
         if (beta == 1 || beta == 0)
            emit_mm(fpout, spc, pre, type, "", LoopOrder, TA, TB, CleanUp, 
                    muladd, pfA, lat, ForceFetch, ifetch, nfetch, M, N, K, 
                    mu, nu, ku, csA, csB, csC, lda, ldb, ldc, alpha, 8);
         ncucases=0;
         if (beta != 1)
            emit_mm(fpout, spc, pre, type, "", LoopOrder, TA, TB, CleanUp,
                    muladd, pfA, lat, ForceFetch, ifetch, nfetch, M, N, K,
                    mu, nu, ku, csA, csB, csC, lda, ldb, ldc, alpha, 1);
@beginskip
         if (beta == 1)
            emit_mm(fpout, spc, pre, type, "", LoopOrder, TA, TB, CleanUp, 
                    muladd, pfA, lat, ForceFetch, ifetch, nfetch, M, N, K, 
                    mu, nu, ku, csA, csB, csC, lda, ldb, ldc, alpha, -1);
         else if (beta == -1)
            emit_mm(fpout, spc, pre, type, "", LoopOrder, TA, TB, CleanUp, 
                    muladd, pfA, lat, ForceFetch, ifetch, nfetch, M, N, K, 
                    mu, nu, ku, csA, csB, csC, lda, ldb, ldc, alpha, 1);
   
         if (beta != 1 && beta != -1)
         {
            emit_mm(fpout, spc, pre, type, "", LoopOrder, TA, TB, CleanUp,
                    muladd, pfA, lat, ForceFetch, ifetch, nfetch, M, N, K,
                    mu, nu, ku, csA, csB, csC, lda, ldb, ldc, alpha, -1);
            ncucases=0;
            emit_mm(fpout, spc, pre, type, "", LoopOrder, TA, TB, CleanUp,
                    muladd, pfA, lat, ForceFetch, ifetch, nfetch, M, N, K,
                    mu, nu, ku, csA, csB, csC, lda, ldb, ldc, alpha, 1);
         }
@endskip
      }
   }
   return(0);
}
@ROUT emit_fmm
@extract -b @(topd)/gen.inc what=cw

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#define Mmin(x, y) ( (x) > (y) ? (y) : (x) )
#define Mmax(x, y) ( (x) > (y) ? (x) : (y) )

FILE *fpout=NULL;

void emit_pre2(int nb)
{
   fprintf(fpout, "#define NB %d\n", nb);
   fprintf(fpout, "#define NBNB %d\n\n", nb*nb);
}

void emit_f77CleanupMake(char PRE, int nb)
{
   char fnam[80];
   int i, j;

   sprintf(fnam, "KERNEL/%cMakefile", PRE);
   fpout = fopen(fnam, "w");
   assert(fpout != NULL);
   
   fprintf(fpout, "include ../Make.inc\n\n");

   fprintf(fpout, "%cobj = \\\n", PRE);
   for (j=1; j != nb; j++)
   {
      fprintf(fpout, "       %cf77pMBmm%d.o \\\n", PRE, j);
      fprintf(fpout, "       %cf77pNBmm%d.o \\\n", PRE, j);
      fprintf(fpout, "       %cf77pKBmm%d.o \\\n", PRE, j);
   }
   fprintf(fpout, "       %cf77pKBmm.o  \\\n", PRE);
   fprintf(fpout, "       %cf77IBNBmm.o \\\n", PRE);
   fprintf(fpout, "       %cf77NBJBmm.o \\\n", PRE);
   fprintf(fpout, "       %cf77GEmm.o\n", PRE);

   fprintf(fpout, "\n%clib : $(%cobj)\n", PRE, PRE);
   fprintf(fpout, "\t ar r $(ATLASlib) $(%cobj)\n",PRE);
   fprintf(fpout, "\t $(RANLIB) $(ATLASlib)\n");
   fprintf(fpout, "\t touch %clib\n", PRE);
   fprintf(fpout, "\n.f.o:\n\t$(F77) -c $(CDEFS) $(MMFLAGS) $<\n");
   fclose(fpout);
   fpout = stdout;
}

void f77_ijunroll(char *spc, int mu, int nu, int k)
{
   char kexp[32], iexp[32], jexp[32];
   int i, j;

   if (mu < 0)
   {
      sprintf(kexp, "%d", k+1);
      mu = -mu;
   }
   else
   {
      if (k) sprintf(kexp, "k+%d", k);
      else sprintf(kexp, "k");
   }
   for (j=0; j < nu; j++)
   {
      if (j) sprintf(jexp, "j+%d", j);
      else sprintf(jexp, "j");
      for (i=0; i < mu; i++)
      {
         if (i) sprintf(iexp, "i+%d", i);
         else sprintf(iexp, "i");
         fprintf(fpout, "%s c%d%d = c%d%d + A(%s,%s) * B(%s, %s)\n",
                 spc, i, j, i, j, kexp, iexp, kexp, jexp);
      }
   }
}

void emit_f77Kloop(char *spc, int kb, int mu, int nu, int ku)
{
   int i, j, k, k0=kb-kb%ku;

   for (j=0; j < nu; j++)
      for (i=0; i < mu; i++)
         fprintf(fpout, "%s c%d%d = ZERO\n", spc, i, j);
   if (ku < kb)
   {
      fprintf(fpout, "%s do k = 1, K0, KU\n", spc);
      spc -= 3;
   }
   if (ku >= kb) for (k=0; k < ku; k++) f77_ijunroll(spc, -mu, nu, k);
   else for (k=0; k < ku; k++) f77_ijunroll(spc, mu, nu, k);
   if (ku < kb)
   {
      spc += 3;
      fprintf(fpout, "%s end do\n", spc);
      if (k0 != kb) /* k-loop cleanup */
      {
         fprintf(fpout, "!\n!%sK-loop cleanup\n!\n", spc);
         fprintf(fpout, "%s do k = K0, KB\n", spc);
         spc -= 3;
         f77_ijunroll(spc, mu, nu, 0);
         spc += 3;
         fprintf(fpout, "%s end do\n", spc);
      }
   }
}

void f77_ijunroll_lat(char *spc, int mu, int nu, int k)
{
   char kexp[32], iexp[32], jexp[32];
   int i, j;

   if (mu < 0)
   {
      sprintf(kexp, "%d", k+1);
      mu = -mu;
   }
   else if (k) sprintf(kexp, "k+%d", k);
   else sprintf(kexp, "k");
   for (j=0; j < nu; j++)
   {
      if (j) sprintf(jexp, "j+%d", j);
      else sprintf(jexp, "j");
      for (i=0; i < mu; i++)
      {
         if (i) sprintf(iexp, "i+%d", i);
         else sprintf(iexp, "i");
         fprintf(fpout, "%s c%d%d = c%d%d + m%d%d\n", spc, i, j, i, j, i, j);
         fprintf(fpout, "%s m%d%d = A(%s,%s) * B(%s, %s)\n",
                 spc, i, j, kexp, iexp, kexp, jexp);
      }
   }
}

void emit_f77Kloop_lat(char *spc, int kb, int mu, int nu, int ku)
/*
 * latency hiding of mu*nu
 */
{
   int i, j, k, k0=kb-kb%ku;

   for (j=0; j < nu; j++)
   {
      for (i=0; i < mu; i++)
      {
         fprintf(fpout, "%s c%d%d = ZERO\n", spc, i, j);
         fprintf(fpout, "%s m%d%d = ZERO\n", spc, i, j);
      }
   }
   if (ku >= kb) for (k=0; k < ku; k++) f77_ijunroll_lat(spc, -mu, nu, k);
   else
   {
      fprintf(fpout, "%s do k = 1, K0, KU\n", spc);
      spc -= 3;
      for (k=0; k < ku; k++) f77_ijunroll_lat(spc, mu, nu, k);
      spc += 3;
      fprintf(fpout, "%s end do\n", spc);
      if (k0 != kb) /* k-loop cleanup */
      {
         fprintf(fpout, "!\n!%sK-loop cleanup\n!\n", spc);
         fprintf(fpout, "%s do k = K0, KB\n", spc);
         spc -= 3;
         f77_ijunroll_lat(spc, mu, nu, 0);
         spc += 3;
         fprintf(fpout, "%s end do\n", spc);
      }
   }
/*   fprintf(fpout, "!\n!%sDrain k-loop latency hiding pipe\n!\n", spc); */
   for (j=0; j < nu; j++)
      for (i=0; i < mu; i++)
         fprintf(fpout, "%s c%d%d = c%d%d + m%d%d\n", spc, i, j, i, j, i, j);
}

void f77_CAss(char *spc, int mu, int nu)
{
   char iexp[32], jexp[32];
   int i, j;

   for (j=0; j < nu; j++)
   {
      if (j) sprintf(jexp, "j+%d", j);
      else sprintf(jexp, "j");
      for (i=0; i < mu; i++)
      {
         if (i) sprintf(iexp, "i+%d", i);
         else sprintf(iexp, "i");
         fprintf(fpout, "%s C(%s,%s) = C(%s,%s) + c%d%d\n",
                 spc, iexp, jexp, iexp, jexp, i, j);
      }
   }
}

void PrintZeroPara(char *spc, char *type, char pre)
{
   fprintf(fpout, "%s %s ZERO\n", spc, type);
   if (pre == 's') fprintf(fpout, "%s parameter (ZERO = 0.0E0)\n", spc);
   else if (pre == 'd') fprintf(fpout, "%s parameter (ZERO = 0.0D0)\n", spc);
   else if (pre == 'c')
      fprintf(fpout, "%s parameter ( ZERO = (0.0E0, 0.0E0) )\n", spc);
   else if (pre == 'z')
      fprintf(fpout, "%s parameter ( ZERO = (0.0E0, 0.0E0) )\n", spc);
}
void emit_f77nbmm(char *rout, char *type, char pre, int mb, int nb, int kb,
                  int mu, int nu, int ku, int lat)
{
   char *spcs = "                    ";
   char *spc = spcs + 15;
   int i, m0, n0, k0;
   void (*f77Kloop)(char *spc, int kb, int mu, int nu, int ku);

   if ( (lat) && (ku != kb) && (mu*nu != lat) )
   {
      fprintf(stderr, "\n\n WARNING: latency/K-loop unroll conflict.  Setting to unroll to %d\n\n", kb);
      ku = kb;
   }
   if (lat) f77Kloop = emit_f77Kloop_lat;
   else f77Kloop = emit_f77Kloop;

   m0 = mb - mb%mu;
   n0 = nb - nb%nu;
   k0 = kb - kb%ku;

   fprintf(fpout, "%s subroutine %c%s(A, B, C)\n", spc, pre, rout);
   fprintf(fpout, "%s integer MB, NB, KB, MU, NU, KU, M0, N0, K0\n", spc);
   fprintf(fpout, "%s parameter (MB=%d, NB=%d, KB=%d)\n", spc, mb, nb, kb);
   fprintf(fpout, "%s parameter (MU=%d, NU=%d, KU=%d)\n", spc, mu, nu, ku);
   fprintf(fpout, "%s parameter (M0=%d, N0=%d, K0=%d)\n", spc, m0, n0, k0);
   fprintf(fpout, "%s %s A(KB,MB), B(KB,NB), C(MB,NB)\n", spc, type);

   PrintZeroPara(spc, type, pre);
   fprintf(fpout, "%s %s c00", spc, type);
   for (i=1; i != mu*nu; i++)
   {
      fprintf(fpout, ", ");
      if (!(i%5)) fprintf(fpout, "\n     $                 ");
      fprintf(fpout, "c%d%d",i%mu,i/mu);
   }
   fprintf(fpout, "\n\n");

   if (nb > nu)
   {
      fprintf(fpout, "%s do j = 1, N0, NU\n", spc);
      spc -= 3;
      if (mb > mu)
      {
         fprintf(fpout, "%s do i = 1, M0, MU\n", spc);
         spc -= 3;
         f77Kloop(spc, kb, mu, nu, ku);
         f77_CAss(spc, mu, nu);
         spc += 3;
         fprintf(fpout, "%s end do\n", spc);
      }
      if (m0 != mb) /* M-loop cleanup */
      {
         fprintf(fpout, "!\n!%sM-loop cleanup\n!\n", spc);
         f77Kloop(spc, kb, mb-m0, nu, ku);
         f77_CAss(spc, mb-m0, nu);
      }
      spc += 3;
      fprintf(fpout, "%s end do\n", spc);
   }
   if (n0 != nb) /* N-loop cleanup */
   {
      fprintf(fpout, "!\n!%sN-loop cleanup\n!\n", spc);
      if (mb > mu)
      {
         fprintf(fpout, "%s do i = 1, M0, MU\n", spc);
         spc -= 3;
         f77Kloop(spc, kb, mu, nb-n0, ku);
         f77_CAss(spc, mu, nb-n0);
         spc += 3;
         fprintf(fpout, "%s end do\n", spc);
      }
      if (m0 != mb) /* M-loop cleanup */
      {
         fprintf(fpout, "!\n!%sM-loop cleanup\n!\n", spc);
#if 0
         fprintf(fpout, "%s do i = M0, MB\n", spc);
         spc -= 3;
         f77Kloop(spc, kb, mb-m0, nb-n0, ku);
         f77_CAss(spc, mb-m0, nb-n0);
         spc += 3;
         fprintf(fpout, "%s end do\n", spc);
#else
         f77Kloop(spc, kb, mb-m0, nb-n0, ku);
         f77_CAss(spc, mb-m0, nb-n0);
#endif
      }
   }
   fprintf(fpout, "\n%s return\n%s end\n",spc, spc);
}

void emit_f77XXmm(char *type, char pre, int mb, int nb, int kb, 
                  int mu, int nu, int ku, int lat)
/*
 * Produce matmul for mbxnbxkb matmul
 */
{
   char rout[80], fnam[80];

   if (mb == nb) sprintf(rout, "%cf77pKBmm%d", pre, kb);
   else if (nb == kb) sprintf(rout, "%cf77pMBmm%d", pre, mb);
   else if (mb == kb) sprintf(rout, "%cf77pNBmm%d", pre, nb);

   sprintf(fnam, "KERNEL/%s.f", rout);
   fpout = fopen(fnam, "w");
   assert(fpout != NULL);

   emit_f77nbmm(rout, type, pre, mb, nb, kb, mu, nu, ku, lat);

   fclose(fpout);
   fpout = stdout;
}

void PrintComputedGoto(int n, char *iexp)
{
   const int MaxCols=71, lablen=5, indent=12;
   int i, j, m; 

   m = (MaxCols - indent) / lablen;
   fprintf(fpout, "      goto(");
   i = 1;
   while (i < n)
   {
      for (j=0; j < m && i < n; j++, i++)
      {
         fprintf(fpout, "%3d", i);
         if (i < n-1) fprintf(fpout, ", ");
      }
      if (i != n) fprintf(fpout, "\n     $     ");
   }
   fprintf(fpout, "\n     $    ) %s\n", iexp);
}

void emit_f77kbmm(char *type, char pre, int mb, int nb, int kb,
                  int mu, int nu, int ku, int lat)
{
   int k;
   char rout[128];

   for (k=1; k != kb; k++)
      emit_f77XXmm(type, pre, mb, nb, k, mu, nu, Mmin(ku,k), lat);

   sprintf(rout, "KERNEL/%cf77pKBmm.f",pre);
   fpout = fopen(rout, "w");
   assert(fpout != NULL);
   fprintf(fpout, "      subroutine %cf77pKBmm(K, A, B, C)\n", pre);
   fprintf(fpout, "      integer K\n");
   fprintf(fpout, "      %s A(*), B(*), C(*)\n\n", type);

   PrintComputedGoto(kb, "K");
   fprintf(fpout, "\n");

   for (k=1; k < kb; k++)
   {
      fprintf(fpout, "%5d  continue\n", k);
      fprintf(fpout, "         call %cf77pKBmm%d(A, B, C)\n", pre, k);
      fprintf(fpout, "         return\n", k);
   }

   fprintf(fpout, "\n      end\n");
   fclose(fpout);
   fpout = stdout;
}

void emit_f77ibnbmm(char *type, char pre, int mb, int nb, int kb,
                    int mu, int nu, int ku, int lat)
{
   int k;
   char rout[128];

   for (k=1; k != mb; k++)
      emit_f77XXmm(type, pre, k, nb, kb, Mmin(mu,k), nu, ku, lat);

   sprintf(rout, "KERNEL/%cf77IBNBmm.f",pre);
   fpout = fopen(rout, "w");
   assert(fpout != NULL);
   fprintf(fpout, "      subroutine %cf77IBNBmm(M, K, A, B, C)\n", pre);
   fprintf(fpout, "      integer M, K\n");
   fprintf(fpout, "      %s A(M, *), B(%d, *), C(*)\n\n", type, kb*nb);
   fprintf(fpout, "      integer j\n");
   fprintf(fpout, "      j = 0\n");

   PrintComputedGoto(mb, "M");
   fprintf(fpout, "\n");

   for (k=1; k < mb; k++)
   {
      fprintf(fpout, "%5d  continue\n", k);
      fprintf(fpout, "         if (K .gt. %d) then\n", mb);
      fprintf(fpout, "            do j = 1, K, %d\n", mb);
      fprintf(fpout, "               call %cf77pMBmm%d(A(1,j), B(1,j), C)\n", pre, k);
      fprintf(fpout, "            end do\n");
      fprintf(fpout, "         endif\n", mb);
      fprintf(fpout, "         if (j .lt. K) then\n", mb);
      fprintf(fpout, "            call df77GEmm(M, %d, K-j, A(1,j), B(1,j), C)\n", mb);
      fprintf(fpout, "         endif\n");
      fprintf(fpout, "         return\n");
   }

   fprintf(fpout, "\n      end\n");
   fclose(fpout);
   fpout = stdout;
}

void emit_f77nbjbmm(char *type, char pre, int mb, int nb, int kb,
                    int mu, int nu, int ku, int lat)
{
   int k;
   char rout[128];

   for (k=1; k != nb; k++)
      emit_f77XXmm(type, pre, mb, k, kb, mu, Mmin(k, nu), ku, lat);
   sprintf(rout, "KERNEL/%cf77NBJBmm.f",pre);
   fpout = fopen(rout, "w");
   assert(fpout != NULL);
   fprintf(fpout, "      subroutine %cf77NBJBmm(M, K, A, B, C)\n", pre);
   fprintf(fpout, "      integer N, K\n");
   fprintf(fpout, "      %s A(%d, *), B(N, *), C(*)\n\n", type, mb*kb);
   fprintf(fpout, "      integer j\n");
   fprintf(fpout, "      j = 0\n");

   PrintComputedGoto(nb, "N");
   fprintf(fpout, "\n");

   for (k=1; k < nb; k++)
   {
      fprintf(fpout, "%5d  continue\n", k);
      fprintf(fpout, "         if (K .gt. %d) then\n", nb);
      fprintf(fpout, "            do j = 1, K, %d\n", nb);
      fprintf(fpout, "               call %cf77pMBmm%d(A(1,j), B(1,j), C)\n", pre, k);
      fprintf(fpout, "            end do\n");
      fprintf(fpout, "         endif\n");
      fprintf(fpout, "         if (j .lt. K) then\n", nb);
      fprintf(fpout, "            call df77GEmm(M, %d, K-j, A(1,j), B(1,j), C)\n", nb);
      fprintf(fpout, "         endif\n");
      fprintf(fpout, "         return\n");
   }

   fprintf(fpout, "\n      end\n");
   fclose(fpout);
   fpout = stdout;
}

void emit_f77GEmm(char *type, char pre, int mb, int nb, int kb,
                  int mu, int nu, int ku, int lat)
{
   char fnam[128];

   sprintf(fnam, "KERNEL/%cf77GEmm.f", pre);
   fpout = fopen(fnam, "w");
   assert(fpout != NULL);

   fprintf(fpout, "      subroutine %cf77GEmm(M, N, K, A, B, C)\n", pre);
   fprintf(fpout, "      integer M, N, K\n");
   fprintf(fpout, "      %s A(K, M), B(K, N), C(M, N)", type);
   PrintZeroPara("      ", type, pre);
   fprintf(fpout, "      integer i, j, h\n");
   fprintf(fpout, "      %s tmp\n\n", type);

   fprintf(fpout, "      do j = 1, N\n");
   fprintf(fpout, "         do i = 1, M\n");
   fprintf(fpout, "            tmp = ZERO\n");
   fprintf(fpout, "            do h = 1, K\n");
   fprintf(fpout, "               tmp = tmp + A(h, i) * B(h, j)\n");
   fprintf(fpout, "            end do\n");
   fprintf(fpout, "            C(i, j) = C(i, j) + tmp\n");
   fprintf(fpout, "         end do\n");
   fprintf(fpout, "      end do\n\n");

   fprintf(fpout, "      return\n");
   fprintf(fpout, "      end\n");

   fclose(fpout);
   fpout = stdout;
}

int main(int nargs, char *args[])
{
   char *TYPE, PRE;
   int nb, mu, nu, ku, lat;

   fpout = stdout;
   if (nargs == 8)
   {
      PRE = *args[1];
      lat = atoi(args[3]);
      nb = atoi(args[4]);
      mu = atoi(args[5]);
      nu = atoi(args[6]);
      ku = atoi(args[7]);
   }
   else
   {
      fprintf(stderr, "USAGE: %s <s/d/c/z> <F/M/N/K/G/A> <lat> NB MU NU KU\n",
              args[0]);
      exit(-1);
   }
   switch (PRE)
   {
      case 's':
         TYPE = "real";
         break;
      case 'd':
         TYPE = "double precision";
         break;
      case 'c':
         TYPE = "complex";
         break;
      case 'z':
         TYPE = "double complex";
         break;
   }
   if (*args[2] == 'F')
      emit_f77nbmm("f77nbmm", TYPE, PRE, nb, nb, nb, mu, nu, ku, lat);
   else if (*args[2] == 'G') emit_f77GEmm(TYPE, PRE, nb, nb, nb, mu, nu, ku, lat);
   else if (*args[2] == 'M') emit_f77ibnbmm(TYPE, PRE, nb, nb, nb, mu, nu, ku, lat);
   else if (*args[2] == 'N') emit_f77nbjbmm(TYPE, PRE, nb, nb, nb, mu, nu, ku, lat);
   else if (*args[2] == 'K') emit_f77kbmm(TYPE, PRE, nb, nb, nb, mu, nu, ku, lat);
   else if (*args[2] == 'M') emit_f77CleanupMake(PRE, nb);
   else if (*args[2] == 'a') emit_pre2(nb);
   else if (*args[2] == 'A') 
   {
      emit_f77GEmm(TYPE, PRE, nb, nb, nb, mu, nu, ku, lat);
      emit_f77ibnbmm(TYPE, PRE, nb, nb, nb, mu, nu, ku, lat);
      emit_f77nbjbmm(TYPE, PRE, nb, nb, nb, mu, nu, ku, lat);
      emit_f77kbmm(TYPE, PRE, nb, nb, nb, mu, nu, ku, lat);
      emit_f77CleanupMake(PRE, nb);
   }
   return(0);
}
@ROUT emit_cmm
@extract -b @(topd)/gen.inc what=cw

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#define Mmin(x, y) ( (x) > (y) ? (y) : (x) )
#define Mmax(x, y) ( (x) > (y) ? (x) : (y) )

FILE *fpout=NULL;
char PRE='X';
char *TYPE=NULL;

void emit_pre2(int nb)
{
   fprintf(fpout, "#define NB %d\n", nb);
   fprintf(fpout, "#define NBNB %d\n\n", nb*nb);
}

void emit_mmij(char *spc, int k, int kb, int mu, int nu)
{
   int i, j;

   for (j=0; j < nu; j++)
   {
      for (i=0; i < mu; i++)
      {
         if (i*kb+k == 0)
         {
            if (j*kb+k == 0) fprintf(fpout, "%s   t00 += *a * *b;\n", spc);
            else fprintf(fpout, "%s   t0%d += *a * b[%d];\n", spc, j, j*kb+k);
         }
         else if (j*kb+k == 0)
            fprintf(fpout, "%s   t%d0 += a[%d] * *b;\n", spc, i, i*kb+k);
         else fprintf(fpout, "%s   t%d%d += a[%d] * b[%d];\n", spc, i, j, 
                      i*kb+k, j*kb+k);
      }
   }
}

void mmKloop(char *spc, int mb, int nb, int kb, int mu, int nu, int ku, int LAST)
{
   int i, j, k;
   char *stB;
 
   if (kb % ku) stB = "stb";
   else stB = "stB";

   fprintf(fpout, "%s   ", spc);
   for (j=0; j < nu; j++) for (i=0; i < mu; i++) fprintf(fpout, "t%d%d = ", i, j);
   fprintf(fpout, "0.0;\n");

   fprintf(fpout, "%s   b = B;\n", spc);
   if (ku == 1)
      fprintf(fpout, 
"%s   for (k=%d; k; k--, a++, b++) /* easy loop to unroll */\n", spc, kb);
   else fprintf(fpout, "%s   do\n", spc);
   fprintf(fpout, "%s   {\n", spc);
   spc -= 3;
   for (k=0; k < ku; k++) emit_mmij(spc, k, kb, mu, nu);
   if (ku != 1)
   {
      fprintf(fpout, "%s   a += %d;\n", spc, ku);
      fprintf(fpout, "%s   b += %d;\n", spc, ku);
   }
   spc += 3;
   fprintf(fpout, "%s   }\n", spc);
   if (ku != 1) fprintf(fpout, "\n%s   while(b != %s);\n", spc, stB);
   if (kb % ku)
   {
      fprintf(fpout, "/*\n *%s K-loop cleanup\n */\n", spc);
      for (k=0; k < kb%ku; k++) emit_mmij(spc, k, kb, mu, nu);
#if 0
      if (!LAST)
      {
         if (kb%ku == 1) fprintf(fpout, "%s   a++;\n", spc);
         else if (kb%ku) fprintf(fpout, "%s   a += %d;\n", spc, kb%ku);
      }
#endif
   }
   fprintf(fpout, "%s   a += %d;\n", spc, kb*(mu-1)+kb%ku);
/*
 * Update C
 */
   if ( (mu == 1) && (nu == 1) )
   {
      if (!LAST) fprintf(fpout, "%s   *C++ += t00;\n", spc);
      else fprintf(fpout, "%s   *C += t00;\n", spc);
   }
   else
   {
      for (j=0; j != nu; j++)
      {
         for (i=0; i != mu; i++)
         {
            if (i+j*mb == 0) fprintf(fpout, "%s   *C += t%d%d;\n", spc, i, j);
            else fprintf(fpout, "%s   C[%d] += t%d%d;\n", spc, i+j*mb, i, j);
         }
      }
      if (!LAST)
      {
         if (mu == 1) fprintf(fpout, "%s   C++;\n", spc);
         else fprintf(fpout, "%s   C += %d;\n", spc, mu);
      }
   }
}

void innloopMNK(int mb, int nb, int kb, int mu, int nu, int LAST,
                char *spc)
/*
 * produce inner (K) loop for mbxnbxkb matmul, where M (N) loop is unrolled by
 * a mu (nu) factor
 */
{
   int i, j, I;

   for (j=0; j != nu; j++)
   {
      if (j) fprintf(fpout, "%s   t0%d = *a * B[%d];\n", spc, j, j*kb);
      else fprintf(fpout, "%s   t00 = *a * *B;\n", spc);
      for (i=1; i != mu; i++)
      {
         if (j) fprintf(fpout, "%s   t%d%d = a[%d] * B[%d];\n", spc, i, j, i*kb, j*kb);
         else   fprintf(fpout, "%s   t%d0 = a[%d] * *B;\n", spc, i, i*kb);
      }
   }
   fprintf(fpout, "\n");
   for (I=1; I < kb; I++)
   {
      for (j=0; j != nu; j++)
      {
         for (i=0; i != mu; i++)
         {
            if (i*kb+I == 0)
            {
               if (j*kb+I == 0) fprintf(fpout, "%s   t00 += *a * *B;\n", spc);
               else fprintf(fpout, "%s   t0%d += *a * B[%d];\n", spc, j, j*kb+I);
            }
            else if (j*kb+I == 0)
               fprintf(fpout, "%s   t%d0 += a[%d] * *B;\n", spc,
                       i, i*kb+I);
            else
               fprintf(fpout, "%s   t%d%d += a[%d] * B[%d];\n", spc,
                       i, j, i*kb+I, j*kb+I);
         }
      }
      fprintf(fpout, "\n");
   }
   if (!LAST) fprintf(fpout, "%s   a += %d;\n", spc, kb*mu);
   if ( (mu == 1) && (nu == 1) ) fprintf(fpout, "%s   *C++ += t00;\n", spc);
   else
   {
      for (j=0; j != nu; j++)
      {
         for (i=0; i != mu; i++)
         {
            if (i+j*mb == 0) fprintf(fpout, "%s   *C += t%d%d;\n", spc, i, j);
            else fprintf(fpout, "%s   C[%d] += t%d%d;\n", spc, i+j*mb, i, j);
         }
      }
      if (!LAST)
      {
         if (mu == 1) fprintf(fpout, "%s   C++;\n", spc);
         else fprintf(fpout, "%s   C += %d;\n", spc, mu);
      }
   }
}

void innloop(int nkit, int nM, int nN, int nb, char *spc, int LAST)
{
   if (nkit == nb) innloopMNK(nb, nb, nb, nM, nN, LAST, spc);
   else mmKloop(spc, nb, nb, nb, nM, nN, nkit, LAST);
}

void latfunc(char *t, char *a, char *b, int *li, int lat, char *prev[],
             char *spc)
{
   int n, k, i = *li;
#ifdef PlusEqual
   static int PlusEq=0;
   static char first[32];
#endif

   if (a)
   {
#ifdef PlusEqual
      if (!PlusEq)
      {
         if (i == 0) strcpy(first, t);
         else if (i > lat) PlusEq = !strcmp(prev[i%lat], first);
      }
#endif
      if (i >= lat)
      {
#ifdef PlusEqual
         if (PlusEq)
            fprintf(fpout, "%s   %s += m%d;\n", spc, prev[i%lat], i%lat);
         else fprintf(fpout, "%s   %s = m%d;\n", spc, prev[i%lat], i%lat);
#else
         fprintf(fpout, "%s   %s += m%d;\n", spc, prev[i%lat], i%lat);
#endif
      }
      prev[i%lat] = t;
      fprintf(fpout, "%s   m%d = %s * %s;\n", spc, i%lat, a, b);
      (*li)++;
   }
   else
   {
      if (lat < i)
         for (k=0; k != lat; k++)
            fprintf(fpout, "%s   %s += m%d;\n", spc, prev[(k+i)%lat],
                    (k+i)%lat);
      else
         for (k=0; k != i; k++)
            fprintf(fpout, "%s   %s += m%d;\n", spc, prev[k], k);
#ifdef PlusEqual
      PlusEq = *li = 0;
#endif
   }
}


void lat_innloopMNK(int lat, int mb, int nb, int kb, int mu, int nu, int LAST,
                    char *spc)
/*
 * produce inner (K) loop for mbxnbxkb matmul, where M (N) loop is unrolled by
 * a mu (nu) factor; do this with latency hiding with latency factor lat
 */
{
   char **prev, **t, a[30], b[30];
   int i, j, I, ll=0;

   prev = malloc((lat+mu*nu) * sizeof(char*));
   t = prev + lat;
   fprintf(fpout, "%s   ", spc);
   for (j=0; j != nu; j++)
      for (i=0; i != mu; i++)
         fprintf(fpout, "t%d%d = ", i, j);
   fprintf(fpout, "0.0;\n");
   for (j=0; j != nu; j++)
   {
      for (i=0; i != mu; i++)
      {
         t[ll] = malloc(20);
         sprintf(t[ll], "t%d%d", i, j);
         if (i*kb) sprintf(a, "a[%d]", i*kb);
         else sprintf(a, "*a");
         if (j*kb) sprintf(b, "B[%d]", j*kb);
         else sprintf(b, "*B");
         latfunc(t[ll], a, b, &ll, lat, prev, spc);
      }
   }
   fprintf(fpout, "\n");
   for (I=1; I < kb; I++)
   {
      for (j=0; j != nu; j++)
      {
         for (i=0; i != mu; i++)
         {
            if (i*kb+I) sprintf(a, "a[%d]", i*kb+I);
            else sprintf(a, "*a");
            if (j*kb+I) sprintf(b, "B[%d]", j*kb+I);
            else sprintf(b, "*B", j*kb+I);
            latfunc(t[i+j*mu], a, b, &ll, lat, prev, spc);
         }
      }
      fprintf(fpout, "\n");
   }
   latfunc(t[0], NULL, NULL, &ll, lat, prev, spc);
   
   if (!LAST) fprintf(fpout, "%s   a += %d;\n", spc, kb*mu);
   if ( (mu == 1) && (nu == 1) ) fprintf(fpout, "%s   *C++ += t00;\n", spc);
   else
   {
      for (j=0; j != nu; j++)
      {
         for (i=0; i != mu; i++)
         {
            if (i+j*mb)
               fprintf(fpout, "%s   C[%d] += t%d%d;\n", spc, i+j*mb, i, j);
            else fprintf(fpout, "%s   *C += t%d%d;\n", spc, i, j);
         }
      }
      if (!LAST)
      {
         if (mu == 1) fprintf(fpout, "%s   C++;\n", spc);
         else fprintf(fpout, "%s   C += %d;\n", spc, mu);
      }
   }
   for (i=0; i != mu*nu; i++) free(t[i]);
   free(prev);
}

void lat_innloop(int lat, int nM, int nN, int nb, char *spc, int LAST)
{
   lat_innloopMNK(lat, nb, nb, nb, nM, nN, LAST, spc);
}


void emit_XXmm(int mb, int nb, int kb, int mu, int nu, int lat)
/*
 * Produce matmul for mbxnbxkb matmul
 */
{
   char rout[80], fnam[80];
   int i, j, nr, nc;

   nc = nb - (nb/nu)*nu; /* # of leftover columns */
   nr = mb - (mb/mu)*mu; /* # of leftover rows */
   if (mb == nb) sprintf(rout, "ATL_%cpKBmm%d", PRE, kb);
   else if (nb == kb) sprintf(rout, "ATL_%cpMBmm%d", PRE, mb);
   else if (mb == kb) sprintf(rout, "ATL_%cpNBmm%d", PRE, nb);
   sprintf(fnam, "KERNEL/%s.c", rout);
   fpout = fopen(fnam, "w");
   assert(fpout != NULL);
   fprintf(fpout, "void %s(const %s *A, const %s *B, %s *C)\n{\n",
           rout, TYPE, TYPE, TYPE);
   fprintf(fpout, "   const %s *a, *st0=B+%d, *st1=A+%d, *st3;\n", TYPE,
           kb*(nb/nu)*nu, kb*(mb/mu)*mu);
   fprintf(fpout, "   %s ", TYPE);
   for (j=0; j != nu; j++)
   {
      for (i=0; i != mu; i++)
      {
         fprintf(fpout, "t%d%d", i, j);
         if (i == mu-1) if (j == nu-1) break;
         fprintf(fpout, ", ");
      }
   }
   if (lat) for (i=0; i != lat; i++) fprintf(fpout, ", m%d",i);
   fprintf(fpout, ";\n\n");

   if (nc < nb)
   {
      fprintf(fpout, "   do\n   {\n");
      fprintf(fpout, "      a = A;\n      st3 = B + %d;\n", nu*kb);
      if (nr < mb) /* don't need inner loop if we don't have full mu */
      {
         fprintf(fpout, "      do\n      {\n");
   
         if (lat) lat_innloopMNK(lat, mb, nb, kb, mu, nu, 0, "      ");
         else innloopMNK(mb, nb, kb, mu, nu, 0, "      ");
   
         fprintf(fpout, "      }\n      while(a != st1);\n\n");
      }
      if (nr) /* M loop cleanup */
      {
         fprintf(fpout, "/*\n *    M loop cleanup\n */\n");
         if (lat) lat_innloopMNK(lat, mb, nb, kb, nr, nu, 0, "   ");
         else innloopMNK(mb, nb, kb, nr, nu, 0, "   ");
      }
      fprintf(fpout, "      B = st3;\n");
      if (nu > 1) fprintf(fpout, "      C += %d;\n",mb*(nu-1));
      fprintf(fpout, "   }\n   while(B != st0);\n");
   }
   if (nc) /* N loop cleanup */
   {
      fprintf(fpout, "/*\n * N loop cleanup\n */\n");
      fprintf(fpout, "   a = A;\n");

      if (nr < mb) /* don't need inner loop if we don't have full mu */
      {
         fprintf(fpout, "   do\n   {\n");
         if (lat) lat_innloopMNK(lat, mb, nb, kb, mu, nc, 0, "   ");
         else innloopMNK(mb, nb, kb, mu, nc, 0, "   ");
         fprintf(fpout, "   }\n   while(a != st1);\n");
      }
      if (nr)  /* M loop cleanup */
      {
         fprintf(fpout, "/*\n * M loop cleanup\n */\n");
         if (lat) lat_innloopMNK(lat, mb, nb, kb, nr, nc, 1, "");
         else innloopMNK(mb, nb, kb, nr, nc, 1, "");
      }
   }
   fprintf(fpout, "}\n");
   fclose(fpout);
   fpout = stdout;
}

void emit_cmm(int nM, int nN, int nK, int nb, int lat)
{
   char *spcs = "               ";
   char *spc = spcs + 15;
   int i, j, nr, nc, nkit, K, I;

   if ( (lat) && (nK != nb) && (nM*nN != lat) )
   {
      fprintf(stderr, "\n\n WARNING: latency/K-loop unroll conflict.  Setting to unroll to %d\n\n", nb);
      nK = nb;
   }
   nc = nb - (nb/nN)*nN; /* # of leftover columns */
   fprintf(stderr, "nM=%d, nN=%d, nK=%d, nb=%d\n",nM, nN, nK, nb);
   fprintf(fpout, "void ATL_%cNBmm(const %s *A, const %s *B, %s *C)\n{\n",
           PRE, TYPE, TYPE, TYPE);
   if (nK == 1) fprintf(fpout, "   int k;\n");
   fprintf(fpout, "   const %s *a, *st0=B+%d, *st1=A+%d, *st3;\n", TYPE,
           nb*((nb/nN)*nN), nb*((nb/nM)*nM));
   if (nK != nb && nK != 1) fprintf(fpout, "   const %s *stB;\n", TYPE);
   fprintf(fpout, "   const %s *b;\n", TYPE);
   if (nb % nK) fprintf(fpout, "   const %s *stb;\n", TYPE);
   fprintf(fpout, "   %s ", TYPE);
   for (j=0; j != nN; j++)
   {
      for (i=0; i != nM; i++)
      {
         fprintf(fpout, "t%d%d", i, j);
         if (i == nM-1) if (j == nN-1) break;
         fprintf(fpout, ", ");
      }
   }
   if (lat) for (i=0; i != lat; i++) fprintf(fpout, ", m%d",i);
   fprintf(fpout, ";\n\n");
/*   if (nK % nb) nK = nb; */
   nr = nb;
/*   nkit = nK / nb; */
   nkit = nK;

   fprintf(fpout, "   do\n   {\n      a = A;\n      st3 = B + %d;\n", nN*nb);
   if (nb % nK) fprintf(fpout, "      stb = B + %d;\n", (nb / nK)*nK);
   if (nK != nb && nK != 1) fprintf(fpout, "      stB = B + %d;\n", nb);
   fprintf(fpout, "      do\n      {\n");

   spc -= 6;
   if (lat) lat_innloop(lat, nM, nN, nb, spc, 0);
   else innloop(nkit, nM, nN, nb, spc, 0);
   fprintf(fpout, "      }\n      while(a != st1);\n\n");
   spc += 3;
   if ( (nr = nb-(nb/nM)*nM) )  /* M loop cleanup */
   {
      fprintf(fpout, "/*\n *    M loop cleanup\n */\n");
      if (lat) lat_innloop(lat, nr, nN, nb, spc, 1);
      else innloop(nkit, nr, nN, nb, spc, 1);
      fprintf(fpout, "      a += %d;\n", nr*nb);
      fprintf(fpout, "      C += %d;\n", nr+nb*(nN-1));
   }
   else if (nN > 1) fprintf(fpout, "      C += %d;\n",nb*(nN-1));
   fprintf(fpout, "      B = st3;\n");
   fprintf(fpout, "   }\n   while(B != st0);\n");
   spc += 3;
   if ( (I = nb - (nb/nN)*nN) ) /* N loop cleanup */
   {
      fprintf(fpout, "/*\n * N loop cleanup\n */\n");
      fprintf(fpout, "   a = A;\n");
      if (nb % nK) fprintf(fpout, "      stb = B + %d;\n", (nb / nK)*nK);
      if (nK != nb && nK != 1) fprintf(fpout, "      stB = B + %d;\n", nb);
      fprintf(fpout, "   do\n   {\n");
      spc -= 3;

      if (lat) lat_innloop(lat, nM, I, nb, spc, 0);
      else innloop(nkit, nM, I, nb, spc, 0);
      fprintf(fpout, "   }\n   while(a != st1);\n");
      spc += 3;
      if ( (nr = nb-(nb/nM)*nM) )  /* M loop cleanup */
      {
         fprintf(fpout, "/*\n * M loop cleanup\n */\n");
         if (lat) lat_innloop(lat, nr, I, nb, spc, 1);
         else innloop(nkit, nr, I, nb, spc, 1);
      }
   }
   fprintf(fpout, "}\n");
}

void KBinnloop(int nM, int nN, int nb, char *spc, int LAST)
/*
 * produce inner (K) loop for MxNxnb matmul, where M (N) loop is unrolled by
 * a nM (nN) factor
 */
{
   int K, i, j, I;

   for (j=0; j != nN; j++)
      for (i=0; i != nM; i++)
         fprintf(fpout, "%s   t%d%d = *a%d * *b%d;\n", spc, i, j, i, j);
   fprintf(fpout, "\n");
   for (I=1; I < nb; I++)
   {
      for (j=0; j != nN; j++)
      {
         for (i=0; i != nM; i++)
         {
            if (I) fprintf(fpout, "%s   t%d%d += a%d[%d] * b%d[%d];\n", spc,
                           i, j, i, I, j, I);
            else fprintf(fpout, "%s   t%d%d += *a%d * *b%d;\n", spc,
                         i, j, i, j);
         }
      }
      fprintf(fpout, "\n");
   }
   for (i=0; i != nM; i++) fprintf(fpout, "%s   a%d += %d;\n", spc, i, nM*nb);
   if ( (nM == 1) && (nN == 1) ) fprintf(fpout, "%s   *C++ += t00;\n", spc);
   else
   {
      for (j=0; j != nN; j++)
      {
         for (i=0; i != nM; i++)
         {
            if ( !(j || i)) fprintf(fpout, "%s   *C += t00;\n", spc);
            else if (!j) fprintf(fpout, "%s   C[%d] += t%d%d;\n", spc, i, i, j);
            else if (!i)
            {   
               if (j == 1) fprintf(fpout,"%s   C[M] += t%d%d;\n", spc, i, j);
               else fprintf(fpout,"%s   C[M*%d] += t%d%d;\n", spc, j, i, j);
            }
            else
            {
               if (j == 1)
                  fprintf(fpout, "%s   C[%d+M] += t%d%d;\n", spc, i, i, j);
               else fprintf(fpout, "%s   C[%d+M*%d] += t%d%d;\n", spc,
                            i, j, i, j);
            }
         }
      }
      if (!LAST)
      {
         if (nM == 1) fprintf(fpout, "%s   C++;\n", spc);
         else fprintf(fpout, "%s   C += %d;\n", spc, nM);
      }
   }
   fprintf(fpout, "\n");
}

void lat_KBinnloop(int lat, int nM, int nN, int nb, char *spc, int LAST)
/*
 * produce inner (K) loop for MxNxnb matmul, where M (N) loop is unrolled by
 * a nM (nN) factor, and we have a latency factor of lat
 */
{
   int K, i, j, I, ll=0;
   char **prev, **t, a[30], b[30];

   prev = malloc((lat+nM*nN) * sizeof(char*));
   t = prev + lat;
   fprintf(fpout, "%s   ", spc);
   for (j=0; j != nN; j++)
      for (i=0; i != nM; i++)
         fprintf(fpout, "t%d%d = ", i, j);
   fprintf(fpout, "0.0;\n");

   for (j=0; j != nN; j++)
   {
      for (i=0; i != nM; i++)
      {
         t[ll] = malloc(20);
         sprintf(t[ll], "t%d%d", i, j);
         sprintf(a, "*a%d", i);
         sprintf(b, "*b%d", j);
         latfunc(t[ll], a, b, &ll, lat, prev, spc);
      }
   }
   fprintf(fpout, "\n");

   for (I=1; I < nb; I++)
   {
      for (j=0; j != nN; j++)
      {
         for (i=0; i != nM; i++)
         {
            if (I) sprintf(a, "a%d[%d]", i, I);
            else sprintf(a, "*a%d", i);
            if (I) sprintf(b, "b%d[%d]", j, I);
            else sprintf(b, "*b%d", j);
            latfunc(t[i+j*nM], a, b, &ll, lat, prev, spc);
         }
      }
      fprintf(fpout, "\n");
   }
   latfunc(t[0], NULL, NULL, &ll, lat, prev, spc);

   for (i=0; i != nM; i++) fprintf(fpout, "%s   a%d += %d;\n", spc, i, nM*nb);
   if ( (nM == 1) && (nN == 1) ) fprintf(fpout, "%s   *C++ += t00;\n", spc);
   else
   {
      for (j=0; j != nN; j++)
      {
         for (i=0; i != nM; i++)
         {
            if ( !(j || i)) fprintf(fpout, "%s   *C += t00;\n", spc);
            else if (!j) fprintf(fpout, "%s   C[%d] += t%d%d;\n", spc, i, i, j);
            else if (!i)
            {   
               if (j == 1) fprintf(fpout,"%s   C[M] += t%d%d;\n", spc, i, j);
               else fprintf(fpout,"%s   C[M*%d] += t%d%d;\n", spc, j, i, j);
            }
            else
            {
               if (j == 1)
                  fprintf(fpout, "%s   C[%d+M] += t%d%d;\n", spc, i, i, j);
               else fprintf(fpout, "%s   C[%d+M*%d] += t%d%d;\n", spc,
                            i, j, i, j);
            }
         }
      }
      if (!LAST)
      {
         if (nM == 1) fprintf(fpout, "%s   C++;\n", spc);
         else fprintf(fpout, "%s   C += %d;\n", spc, nM);
      }
   }
   fprintf(fpout, "\n");
   for (i=0; i != nN*nM; i++) free(t[i]);
   free(prev);
}

void emit_KBmmN(int lat, int nM, int nN, int nK, int nb)
{
   char rout[80];
   int i, j, nr, nkit, K, I;

   sprintf(rout, "KERNEL/ATL_%cKBmm%d.c",PRE, nb);
   fpout = fopen(rout, "w");
   assert(fpout != NULL);
   fprintf(fpout, "void ATL_%cKBmm%d(const int M, const int N, const %s *A, const %s *B, %s *C)\n{\n", PRE, nb, TYPE, TYPE, TYPE);
   fprintf(fpout,
       "   const %s *st0=B+(N/%d)*%d*%d, *st1=A+(M/%d)*%d*%d, *st2=A+M*%d;\n",
           TYPE, nN, nN, nb, nM, nM, nb, nb);
   fprintf(fpout, "   const %s *a0", TYPE);
   for (i=1; i < nM; i++) fprintf(fpout, ", *a%d", i);
   fprintf(fpout, ", *b0");
   for (j=1; j < nN; j++) fprintf(fpout, ", *b%d", j);
   fprintf(fpout, ";\n");
   fprintf(fpout, "   %s ", TYPE);
   for (j=0; j != nN; j++)
   {
      for (i=0; i != nM; i++)
      {
         fprintf(fpout, "t%d%d", i, j);
         if (i == nM-1) if (j == nN-1) break;
         fprintf(fpout, ", ");
      }
   }
   if (lat) for (i=0; i != lat; i++) fprintf(fpout, ", m%d",i);
   fprintf(fpout, ";\n\n");

#if 0
   fprintf(fpout, "   if (M/%d) st1 = A + ( (M/%d)*%d + 1 - %d ) * %d;\n",
           nM, nM, nM, nM, nb);
   fprintf(fpout, "   else st1 = A;\n");
#endif
   fprintf(fpout, "   while(B != st0)\n   {\n");
   fprintf(fpout, "      a0 = A;");
   for (i=1; i < nM; i++) fprintf(fpout, "  a%d = A + %d;",i, i*nb);
   fprintf(fpout, "\n      b0 = B;");
   for (j=1; j < nN; j++) fprintf(fpout, "  b%d = B + %d;",j, j*nb);
   fprintf(fpout, "\n\n");

   fprintf(fpout, "      while(a0 != st1)\n      {\n");
   if (lat) lat_KBinnloop(lat, nM, nN, nb, "      ", 0);
   else KBinnloop(nM, nN, nb, "      ", 0);
   fprintf(fpout, "      }\n");

   if (nM != 1)  /* M loop cleanup */
   {
      fprintf(fpout, "/*\n *    M-loop cleanup\n */\n");
      fprintf(fpout, "      a0 = st1;\n");
      fprintf(fpout, "      while (a0 != st2)\n      {\n");
      if (lat) lat_KBinnloop(lat, 1, nN, nb, "      ", 0);
      else KBinnloop(1, nN, nb, "      ", 0);
      fprintf(fpout, "      }\n");
   }
   fprintf(fpout, "      B += %d;\n", nN*nb);
   if (nN > 1) fprintf(fpout, "      C += M*%d;\n",nN-1);
   fprintf(fpout, "   }\n");
   if (nN != 1)  /* N loop cleanup */
   {
      fprintf(fpout, "/*\n * N-loop cleanup\n */\n");
      fprintf(fpout, "   b0 = st0;\n");
      fprintf(fpout, "   st0 += (N - (N/%d)*%d) * %d;\n", nN, nN, nb);
      fprintf(fpout, "   while(b0 != st0)\n   {\n");
      fprintf(fpout, "      a0 = A;");
      for (i=1; i < nM; i++) fprintf(fpout, "  a%d = A + %d;", i, i*nb);
      fprintf(fpout, "\n");
      fprintf(fpout, "      while(a0 != st1)\n      {\n");
      if (lat) lat_KBinnloop(lat, nM, 1, nb, "      ", 0);
      else KBinnloop(nM, 1, nb, "      ", 0);
      fprintf(fpout, "      }\n");

      if (nM != 1)  /* M loop cleanup */
      {
         fprintf(fpout, "/*\n *    M-loop cleanup\n */\n");
         fprintf(fpout, "      a0 = st1;\n");
         fprintf(fpout, "      while (a0 != st2)\n      {\n");
         if (lat) lat_KBinnloop(lat, 1, 1, nb, "      ", 0);
         else KBinnloop(1, 1, nb, "      ", 0);
         fprintf(fpout, "      }\n");
      }
      fprintf(fpout, "      b0 += %d;\n", nb);
      fprintf(fpout, "   }\n");
   }
   fprintf(fpout, "}\n");
   fclose(fpout);
   fpout = stdout;
}

void emit_CleanupMake(int nb)
{
   char fnam[80];
   int i, j;

   sprintf(fnam, "KERNEL/%cMakefile", PRE);
   fpout = fopen(fnam, "w");
   assert(fpout != NULL);
   
   fprintf(fpout, "include ../Make.inc\n\n");

   fprintf(fpout, "%cobj = \\\n", PRE);
   for (j=0; j != nb; j++)
   {
      fprintf(fpout, "       ATL_%cpMBmm%d.o \\\n", PRE, j);
      fprintf(fpout, "       ATL_%cpNBmm%d.o \\\n", PRE, j);
      fprintf(fpout, "       ATL_%cpKBmm%d.o \\\n", PRE, j);
      if (j) fprintf(fpout, "       ATL_%cKBmm%d.o  \\\n", PRE, j);
   }
   fprintf(fpout,    "       ATL_%cKBmm%d.o  \\\n", PRE, nb);
   fprintf(fpout, "       ATL_%cpKBmm.o  \\\n", PRE);
   fprintf(fpout, "       ATL_%cIBNBmm.o \\\n", PRE);
   fprintf(fpout, "       ATL_%cNBJBmm.o \\\n", PRE);
   fprintf(fpout, "       ATL_%cGEmm.o\n", PRE);

   fprintf(fpout, "\n%clib : $(%cobj)\n", PRE, PRE);
   fprintf(fpout, "\t ar r $(ATLASlib) $(%cobj)\n",PRE);
   fprintf(fpout, "\t $(RANLIB) $(ATLASlib)\n");
   fprintf(fpout, "\t touch %clib\n", PRE);
   fprintf(fpout, "\n.c.o:\n\t$(MCC) -c $(CDEFS) $(MMFLAGS) $<\n");
   fclose(fpout);
   fpout = stdout;
}

void emit_KBmm(int lat, int nM, int nN, int nK, int nb)
{
   char rout[80];
   int i;

   for (i=1; i <= nb; i++) emit_KBmmN(lat, nM, nN, nK, i);
   sprintf(rout, "KERNEL/ATL_%cGEmm.c",PRE);
   fpout = fopen(rout, "w");
   assert(fpout != NULL);

   for(i=1; i <= nb; i++)
      fprintf(fpout, "void ATL_%cKBmm%d(const int, const int, const %s*, const %s*, %s*);\n",
              PRE, i, TYPE, TYPE, TYPE);

   fprintf(fpout, "void ATL_%cGEmm(const int M, const int N, const int K, const %s *A, const %s *B, %s *C)\n{\n", PRE, TYPE, TYPE, TYPE);
   fprintf(fpout, "   static void (*KBmmX[%d])(const int, const int, const %s*, const %s*, %s*) =\n", nb, TYPE, TYPE, TYPE);
   fprintf(fpout, "   {ATL_%cKBmm1", PRE);
   for(i=2; i <= nb; i++) fprintf(fpout, ", ATL_%cKBmm%d", PRE, i);
   fprintf(fpout, "};\n");
   fprintf(fpout, "   KBmmX[K-1](M, N, A, B, C);\n");
   fprintf(fpout, "}\n");
   fclose(fpout);
   fpout = stdout;
}

void emit_pKBmm(int lat, int mu, int nu, int nb)
{
   char rout[80];
   int i;

   for (i=1; i != nb; i++) emit_XXmm(nb, nb, i, mu, nu, lat);
   sprintf(rout, "KERNEL/ATL_%cpKBmm.c",PRE);
   fpout = fopen(rout, "w");
   assert(fpout != NULL);

   for(i=1; i < nb; i++)
      fprintf(fpout, "void ATL_%cpKBmm%d(const %s*, const %s*, %s*);\n",
              PRE, i, TYPE, TYPE, TYPE);

   fprintf(fpout, "\nvoid ATL_%cpKBmm(const int K, const %s *A, const %s *B, %s *C)\n{\n", PRE, TYPE, TYPE, TYPE);
   fprintf(fpout, "   static void (*KBmmX[%d])(const %s*, const %s*, %s*) =\n", nb, TYPE, TYPE, TYPE);
   fprintf(fpout, "   {ATL_%cpKBmm1", PRE);
   for(i=2; i < nb; i++) fprintf(fpout, ", ATL_%cpKBmm%d", PRE, i);
   fprintf(fpout, "};\n");
   fprintf(fpout, "   KBmmX[K-1](A, B, C);\n");
   fprintf(fpout, "}\n");
   fclose(fpout);
   fpout = stdout;
}

void emit_pMBmm(int lat, int mu, int nu, int nb)
{
   char rout[80];
   int i;

   for (i=1; i != nb; i++) emit_XXmm(i, nb, nb, mu, nu, lat);
   sprintf(rout, "KERNEL/ATL_%cIBNBmm.c",PRE);
   fpout = fopen(rout, "w");
   assert(fpout != NULL);

   for(i=1; i < nb; i++)
      fprintf(fpout, "void ATL_%cpMBmm%d(const %s*, const %s*, %s*);\n", 
              PRE, i, TYPE, TYPE, TYPE);

   fprintf(fpout, "\nvoid ATL_%cIBNBmm(const int M, const int K, const %s *A, const %s *B, %s *C)\n{\n", PRE, TYPE, TYPE, TYPE);
   fprintf(fpout, "   int nKb, k;\n");
   fprintf(fpout, "   static void (*MBmmX[%d])(const %s*, const %s*, %s*) =\n", nb, TYPE, TYPE, TYPE);
   fprintf(fpout, "   {ATL_%cpMBmm1", PRE);
   for(i=2; i < nb; i++) fprintf(fpout, ", ATL_%cpMBmm%d", PRE, i);
   fprintf(fpout, "};\n");
   fprintf(fpout, "   for (k = nKb = K / %d; k; k--)\n   {\n", nb);
   fprintf(fpout, "      MBmmX[M-1](A, B, C);\n");
   fprintf(fpout, "      B += %d;\n", nb*nb);
   fprintf(fpout, "      A += M*%d;\n   }\n", nb);
   fprintf(fpout, "   if ( (k = K - nKb*%d) ) ATL_%cGEmm(M, %d, k, A, B, C);\n", 
           nb, PRE, nb);
   fprintf(fpout, "}\n");
   fclose(fpout);
   fpout = stdout;
}

void emit_pNBmm(int lat, int mu, int nu, int nb)
{
   char rout[80];
   int i;

   for (i=1; i != nb; i++) emit_XXmm(nb, i, nb, mu, nu, lat);
   sprintf(rout, "KERNEL/ATL_%cNBJBmm.c",PRE);
   fpout = fopen(rout, "w");
   assert(fpout != NULL);

   for(i=1; i < nb; i++)
      fprintf(fpout, "void ATL_%cpNBmm%d(const %s*, const %s*, %s*);\n", 
              PRE, i, TYPE, TYPE, TYPE);

   fprintf(fpout, "void ATL_%cNBJBmm(const int N, const int K, const %s *A, const %s *B, %s *C)\n{\n", PRE, TYPE, TYPE, TYPE);
   fprintf(fpout, "   int nKb, k;\n");
   fprintf(fpout, "   static void (*NBmmX[%d])(const %s*, const %s*, %s*) =\n", nb, TYPE, TYPE, TYPE);
   fprintf(fpout, "   {ATL_%cpNBmm1", PRE);
   for(i=2; i < nb; i++) fprintf(fpout, ", ATL_%cpNBmm%d", PRE, i);
   fprintf(fpout, "};\n");
   fprintf(fpout, "   for (k = nKb = K / %d; k; k--)\n   {\n", nb);
   fprintf(fpout, "      NBmmX[N-1](A, B, C);\n");
   fprintf(fpout, "      B += N*%d;\n", nb);
   fprintf(fpout, "      A += %d;\n   }\n", nb*nb);
   fprintf(fpout, "   if ( (k = K - nKb*%d) ) ATL_%cGEmm(%d, N, k, A, B, C);\n", 
           nb, PRE, nb);
   fprintf(fpout, "}\n");
   fclose(fpout);
   fpout = stdout;
}

int main(int nargs, char *args[])
{
   int nb, mu, nu, ku, lat;

   fpout = stdout;
   if (nargs == 8)
   {
      PRE = *args[1];
      lat = atoi(args[3]);
      nb = atoi(args[4]);
      mu = atoi(args[5]);
      nu = atoi(args[6]);
      ku = atoi(args[7]);
   }
   else
   {
      fprintf(stderr, "USAGE: %s <s/d/c/z> <C/M/N/K/A/h> <lat> NB MU NU KU\n",
              args[0]);
      exit(-1);
   }
   switch (PRE)
   {
      case 's':
         TYPE = "float";
         break;
      case 'd':
         TYPE = "double";
         break;
      case 'c':
         TYPE = "float";
         break;
      case 'z':
         TYPE = "double";
         break;
   }
   if (*args[2] == 'a') emit_pre2(nb);
   else if (*args[2] == 'G') emit_KBmm(lat, mu, nu, ku, nb);
   else if (*args[2] == 'C') emit_cmm(mu, nu, ku, nb, lat);
   else if (*args[2] == 'M') emit_pMBmm(lat, mu, nu, nb);
   else if (*args[2] == 'N') emit_pNBmm(lat, mu, nu, nb);
   else if (*args[2] == 'K') emit_pKBmm(lat, mu, nu, nb);
   else if (*args[2] == 'm') emit_CleanupMake(nb);
   else if (*args[2] == '1' || *args[2] == 'A') 
   {
      emit_KBmm(lat, mu, nu, ku, nb);
      emit_pMBmm(lat, mu, nu, nb);
      emit_pNBmm(lat, mu, nu, nb);
      emit_pKBmm(lat, mu, nu, nb);
      emit_CleanupMake(nb);
   }
   return(0);
}
@ROUT atlas_pthread.h
#ifndef ATLAS_PTHREAD_H
#define ATLAS_PTHREAD_H

#ifndef ATL_NTHREADS
   #define ATL_NTHREADS 0
#endif

#if ATL_NTHREADS > 1

#include <pthread.h>
#if (ATL_NTHREADS == 2)
   #define ATL_NTHREADS_1 1
   #define ATL_MulByNT(N_) ((N_) << 1)
   #define ATL_DivByNT(N_) ((N_) >> 1)
#elif (ATL_NTHREADS == 4)
   #define ATL_NTHREADS_1 3
   #define ATL_MulByNT(N_) ((N_) << 2)
   #define ATL_DivByNT(N_) ((N_) >> 2)
#elif (ATL_NTHREADS == 8)
   #define ATL_NTHREADS_1 7
   #define ATL_MulByNT(N_) ((N_) << 3)
   #define ATL_DivByNT(N_) ((N_) >> 3)
#elif (ATL_NTHREADS == 16)
   #define ATL_NTHREADS_1 15
   #define ATL_MulByNT(N_) ((N_) << 4)
   #define ATL_DivByNT(N_) ((N_) >> 4)
#elif (ATL_NTHREADS == 32)
   #define ATL_NTHREADS_1 31
   #define ATL_MulByNT(N_) ((N_) << 5)
   #define ATL_DivByNT(N_) ((N_) >> 5)
#else
   #define ATL_NTHREADS_1 (ATL_NTHREADS-1)
   #define ATL_MulByNT(N_) ((N_) * ATL_NTHREADS)
   #define ATL_DivByNT(N_) ((N_) / ATL_NTHREADS)
#endif

#endif

#endif
@ROUT atlas_f77.h
@extract -b @(topd)/gen.inc what=cw
#ifndef ATLAS_F77_H
#define ATLAS_F77_H

   #ifndef ATL_F77_SUBROUTINE
      #define ATL_F77_SUBROUTINE void
   #endif
   #ifndef F77_INTEGER
      #define F77_INTEGER int
   #endif
   #if defined(CRAY)
      #define UseTransChar 1
      #include <fortran.h>
      #define F77_CHAR _fcd
      #define ATL_F2C_TransChar(c) (*(_fcdtocp(c) ))
      #define ATL_C2F_TransChar(c) (_cptofcd(&(c), 1))
   #elif defined(StringStructVal)
      typedef struct {char *cp; F77_INTEGER len;} F77_CHAR;
      #define ATL_F2C_TransChar(c) (*(c.cp))
      #define UseTransChar 2
   #elif defined(StringStructPtr)
      typedef struct {char *cp; F77_INTEGER len;} F77_CHAR;
      #define ATL_F2C_TransChar(c) (*(c->cp))
      #define UseTransChar 3
   #else
      #define ATL_DeclareSlens
      #define F77_CHAR char *
      #define ATL_F2C_TransChar(c) (*(c))
      #define ATL_C2F_TransChar(c) (&(c))
      #define ATL_STRLEN_1 ,F77_INTEGER ATL_Slen1
      #define ATL_STRLEN_2 ,F77_INTEGER ATL_Slen1, F77_INTEGER ATL_Slen2
      #define ATL_STRLEN_3 ,F77_INTEGER ATL_Slen1, F77_INTEGER ATL_Slen2, \
                           F77_INTEGER ATL_Slen3
      #define ATL_STRLEN_4 ,F77_INTEGER ATL_Slen1, F77_INTEGER ATL_Slen2, \
                           F77_INTEGER ATL_Slen3, F77_INTEGER ATL_Slen4
      #define ATL_STRLEN_1_para ,ATL_Slen1
      #define ATL_STRLEN_2_para ,ATL_Slen1, ATL_Slen2
      #define ATL_STRLEN_3_para ,ATL_Slen1, ATL_Slen2, ATL_Slen3
      #define ATL_STRLEN_4_para ,ATL_Slen1, ATL_Slen2, ATL_Slen3, ATL_Slen4
   #endif

   #ifndef ATL_STRLEN_1
      #define ATL_STRLEN_1
      #define ATL_STRLEN_2
      #define ATL_STRLEN_3
      #define ATL_STRLEN_4
      #define ATL_STRLEN_1_para
      #define ATL_STRLEN_2_para
      #define ATL_STRLEN_3_para
      #define ATL_STRLEN_4_para
   #endif

#endif
@ROUT ATL_C2F_TransChar
#if (UseTransChar == 2)
   F77_CHAR ATL_C2F_TransChar(char c)
   {
      F77_CHAR fc;
      fc.cp = &c;
      fc.len = 1;
      return(fc);
   }
#elif (UseTransChar == 3)
   #include <stdlib.h>
   F77_CHAR ATL_C2F_TransChar(char c)  /* need to free fcp and fcp->cp */
   {
      F77_CHAR fcp;
      fcp = malloc(sizeof(F77_CHAR));
      fcp->cp = malloc(1);
      *fcp->cp = c;
      fcp->len = 1;
      return(fcp);
   }
#endif
@ROUT atlas_fblas.h
#ifndef ATLAS_FBLAS_H
   #define ATLAS_FBLAS_H

#if defined(UpCase)

@whiledef pre z c d s
   @whiledef nm gemm symm syrk syr2k trmm trsm
   #define f77_@(pre)@6l@(nm) @up@(pre)@up@(nm)
   @endwhile
@endwhile
@whiledef pre z c
   @whiledef nm hemm herk her2k
   #define f77_@(pre)@6l@(nm) @up@(pre)@up@(nm)
   @endwhile
@endwhile

#elif defined(NoChange)

@whiledef pre z c d s
   @whiledef nm gemm symm syrk syr2k trmm trsm
   #define f77_@(pre)@6l@(nm) @(pre)@(nm)
   @endwhile
@endwhile
@whiledef pre z c
   @whiledef nm hemm herk her2k
   #define f77_@(pre)@6l@(nm) @(pre)@(nm)
   @endwhile
@endwhile

#else

@whiledef pre z c d s
   @whiledef nm gemm symm syrk syr2k trmm trsm
   #define f77_@(pre)@6l@(nm) @(pre)@(nm)_
   @endwhile
@endwhile
@whiledef pre z c
   @whiledef nm hemm herk her2k
   #define f77_@(pre)@6l@(nm) @(pre)@(nm)_
   @endwhile
@endwhile

#endif

@whiledef nm gemm symm syrk syr2k trmm trsm
#define f77_@6l@(nm) Mjoin(Mjoin(f77_,PRE),@(nm))
@endwhile

#ifdef TCPLX
@whiledef nm hemm herk her2k
   #define f77_@6l@(nm) Mjoin(Mjoin(f77_,PRE),@(nm))
@endwhile
#endif

#endif
@ROUT cblas.h
#ifndef CBLAS_H

#ifndef CBLAS_ENUM_DEFINED_H
   #define CBLAS_ENUM_DEFINED_H
   enum CBLAS_ORDER {CblasRowMajor=101, CblasColMajor=102 };
   enum CBLAS_TRANSPOSE {CblasNoTrans=111, CblasTrans=112, CblasConjTrans=113,
                         AtlasConj=114};
   enum CBLAS_UPLO  {CblasUpper=121, CblasLower=122};
   enum CBLAS_DIAG  {CblasNonUnit=131, CblasUnit=132};
   enum CBLAS_SIDE  {CblasLeft=141, CblasRight=142};
#endif

#ifndef CBLAS_ENUM_ONLY
#define CBLAS_H
#define CBLAS_INDEX int

@beginskip
#define CBLAS_ORDER ATLAS_ORDER
   #define CblasRowMajor AtlasRowMajor
   #define CblasColMajor AtlasColMajor
#define CBLAS_TRANSPOSE ATLAS_TRANS
   #define CblasNoTrans AtlasNoTrans
   #define CblasTrans AtlasTrans
   #define CblasConjTrans AtlasConjTrans
#define CBLAS_UPLO ATLAS_UPLO
   #define CblasUpper AtlasUpper
   #define CblasLower AtlasLower
#define CBLAS_DIAG ATLAS_DIAG
   #define CblasNonUnit AtlasNonUnit
   #define CblasUnit AtlasUnit
#define CBLAS_SIDE ATLAS_SIDE
   #define CblasLeft  AtlasLeft
   #define CblasRight AtlasRight

@endskip
int cblas_errprn(int ierr, int info, char *form, ...);
void cblas_xerbla(int p, const char *rout, const char *form, ...);

/*
 * ===========================================================================
 * Prototypes for level 1 BLAS functions (complex are recast as routines)
 * ===========================================================================
 */
float  cblas_sdsdot(const int N, const float alpha, const float *X,
                    const int incX, const float *Y, const int incY);
double cblas_dsdot(const int N, const float *X, const int incX, const float *Y,
                   const int incY);
@multidef typ double float@^
@whiledef pre d s
@(typ) cblas_@(pre)dot(const int N, const @(typ) *X, const int incX,
                  const @(typ) *Y, const int incY);
   @undef typ
@endwhile
/*
 * Functions having prefixes Z and C only
 */
@whiledef pre z c
void   cblas_@(pre)dotu_sub(const int N, const void *X, const int incX,
                       const void *Y, const int incY, void *dotu);
void   cblas_@(pre)dotc_sub(const int N, const void *X, const int incX,
                       const void *Y, const int incY, void *dotc);

@endwhile

/*
 * Functions having prefixes S D SC DZ
 */
@multidef typ void void double float
@multidef uty double   float@^ double float@^
@whiledef pre dz sc d s
@(uty) cblas_@(pre)nrm2(const int N, const @(typ) *X, const int incX);
@(uty) cblas_@(pre)asum(const int N, const @(typ) *X, const int incX);
   @undef typ
   @undef uty

@endwhile
@multidef typ void@^@^ void@^@^ double float@^

/*
 * Functions having standard 4 prefixes (S D C Z)
 */
@whiledef pre z c d s
CBLAS_INDEX cblas_i@(pre)amax(const int N, const @(typ) *X, const int incX);
   @undef typ
@endwhile

@define typdef @@multidef typ void void double float@
@define stydef @@multidef sty void@^* void@^* double@^ float@^@
/*
 * ===========================================================================
 * Prototypes for level 1 BLAS routines
 * ===========================================================================
 */
@(typdef)
@(stydef)

/*
 * Routines with standard 4 prefixes (s, d, c, z)
 */
@whiledef pre z c d s
void cblas_@(pre)swap(const int N, @(typ) *X, const int incX,
                 @(typ) *Y, const int incY);
void cblas_@(pre)copy(const int N, const @(typ) *X, const int incX,
                 @(typ) *Y, const int incY);
void cblas_@(pre)axpy(const int N, const @(sty)alpha, const @(typ) *X,
                 const int incX, @(typ) *Y, const int incY);
void catlas_@(pre)axpby(const int N, const @(sty)alpha, const @(typ) *X,
                  const int incX, const @(sty)beta, @(typ) *Y, const int incY);
void catlas_@(pre)set
   (const int N, const @(sty)alpha, @(typ) *X, const int incX);
   @undef typ
   @undef sty

@endwhile

/*
 * Routines with S and D prefix only
 */
@multidef typ double float
@whiledef pre d s
void cblas_@(pre)rotg(@(typ) *a, @(typ) *b, @(typ) *c, @(typ) *s);
void cblas_@(pre)rotmg(@(typ) *d1, @(typ) *d2, @(typ) *b1, const @(typ) b2, @(typ) *P);
void cblas_@(pre)rot(const int N, @(typ) *X, const int incX,
                @(typ) *Y, const int incY, const @(typ) c, const @(typ) s);
void cblas_@(pre)rotm(const int N, @(typ) *X, const int incX,
                @(typ) *Y, const int incY, const @(typ) *P);
   @undef typ

@endwhile
@multidef typ void void void void double float
@multidef sty double@^ float@^ void@^* void@^* double@^ float@^

/*
 * Routines with S D C Z CS and ZD prefixes
 */
@whiledef pre zd cs z c d s
void cblas_@(pre)scal(const int N, const @(sty)alpha, @(typ) *X, const int incX);
   @undef typ
   @undef sty
@endwhile

/*
 * Extra reference routines provided by ATLAS, but not mandated by the standard
 */
void cblas_crotg(void *a, void *b, void *c, void *s);
void cblas_zrotg(void *a, void *b, void *c, void *s);
void cblas_csrot(const int N, void *X, const int incX, void *Y, const int incY,
                 const float c, const float s);
void cblas_zdrot(const int N, void *X, const int incX, void *Y, const int incY,
                 const double c, const double s);

/*
 * ===========================================================================
 * Prototypes for level 2 BLAS
 * ===========================================================================
 */

/*
 * Routines with standard 4 prefixes (S, D, C, Z)
 */
@(typdef)
@(stydef)
@whiledef pre z c d s
void cblas_@(pre)gemv(const enum CBLAS_ORDER Order,
                 const enum CBLAS_TRANSPOSE TransA, const int M, const int N,
                 const @(sty)alpha, const @(typ) *A, const int lda,
                 const @(typ) *X, const int incX, const @(sty)beta,
                 @(typ) *Y, const int incY);
void cblas_@(pre)gbmv(const enum CBLAS_ORDER Order,
                 const enum CBLAS_TRANSPOSE TransA, const int M, const int N,
                 const int KL, const int KU, const @(sty)alpha,
                 const @(typ) *A, const int lda, const @(typ) *X,
                 const int incX, const @(sty)beta, @(typ) *Y, const int incY);
void cblas_@(pre)trmv(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
                 const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag,
                 const int N, const @(typ) *A, const int lda,
                 @(typ) *X, const int incX);
void cblas_@(pre)tbmv(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
                 const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag,
                 const int N, const int K, const @(typ) *A, const int lda,
                 @(typ) *X, const int incX);
void cblas_@(pre)tpmv(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
                 const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag,
                 const int N, const @(typ) *Ap, @(typ) *X, const int incX);
void cblas_@(pre)trsv(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
                 const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag,
                 const int N, const @(typ) *A, const int lda, @(typ) *X,
                 const int incX);
void cblas_@(pre)tbsv(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
                 const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag,
                 const int N, const int K, const @(typ) *A, const int lda,
                 @(typ) *X, const int incX);
void cblas_@(pre)tpsv(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
                 const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag,
                 const int N, const @(typ) *Ap, @(typ) *X, const int incX);
   @undef typ
   @undef sty

@endwhile

/*
 * Routines with S and D prefixes only
 */
@multidef typ double float
@whiledef pre d s
void cblas_@(pre)symv(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
                 const int N, const @(typ) alpha, const @(typ) *A,
                 const int lda, const @(typ) *X, const int incX,
                 const @(typ) beta, @(typ) *Y, const int incY);
void cblas_@(pre)sbmv(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
                 const int N, const int K, const @(typ) alpha, const @(typ) *A,
                 const int lda, const @(typ) *X, const int incX,
                 const @(typ) beta, @(typ) *Y, const int incY);
void cblas_@(pre)spmv(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
                 const int N, const @(typ) alpha, const @(typ) *Ap,
                 const @(typ) *X, const int incX,
                 const @(typ) beta, @(typ) *Y, const int incY);
void cblas_@(pre)ger(const enum CBLAS_ORDER Order, const int M, const int N,
                const @(typ) alpha, const @(typ) *X, const int incX,
                const @(typ) *Y, const int incY, @(typ) *A, const int lda);
void cblas_@(pre)syr(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
                const int N, const @(typ) alpha, const @(typ) *X,
                const int incX, @(typ) *A, const int lda);
void cblas_@(pre)spr(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
                const int N, const @(typ) alpha, const @(typ) *X,
                const int incX, @(typ) *Ap);
void cblas_@(pre)syr2(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
                const int N, const @(typ) alpha, const @(typ) *X,
                const int incX, const @(typ) *Y, const int incY, @(typ) *A,
                const int lda);
void cblas_@(pre)spr2(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
                const int N, const @(typ) alpha, const @(typ) *X,
                const int incX, const @(typ) *Y, const int incY, @(typ) *A);
   @undef typ

@endwhile

/*
 * Routines with C and Z prefixes only
 */
@multidef uty double float
@whiledef pre z c
void cblas_@(pre)hemv(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
                 const int N, const void *alpha, const void *A,
                 const int lda, const void *X, const int incX,
                 const void *beta, void *Y, const int incY);
void cblas_@(pre)hbmv(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
                 const int N, const int K, const void *alpha, const void *A,
                 const int lda, const void *X, const int incX,
                 const void *beta, void *Y, const int incY);
void cblas_@(pre)hpmv(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
                 const int N, const void *alpha, const void *Ap,
                 const void *X, const int incX,
                 const void *beta, void *Y, const int incY);
void cblas_@(pre)geru(const enum CBLAS_ORDER Order, const int M, const int N,
                 const void *alpha, const void *X, const int incX,
                 const void *Y, const int incY, void *A, const int lda);
void cblas_@(pre)gerc(const enum CBLAS_ORDER Order, const int M, const int N,
                 const void *alpha, const void *X, const int incX,
                 const void *Y, const int incY, void *A, const int lda);
void cblas_@(pre)her(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
                const int N, const @(uty) alpha, const void *X, const int incX,
                void *A, const int lda);
void cblas_@(pre)hpr(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
                const int N, const @(uty) alpha, const void *X,
                const int incX, void *A);
void cblas_@(pre)her2(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const int N,
                const void *alpha, const void *X, const int incX,
                const void *Y, const int incY, void *A, const int lda);
void cblas_@(pre)hpr2(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const int N,
                const void *alpha, const void *X, const int incX,
                const void *Y, const int incY, void *Ap);
   @undef uty

@endwhile
/*
 * ===========================================================================
 * Prototypes for level 3 BLAS
 * ===========================================================================
 */

/*
 * Routines with standard 4 prefixes (S, D, C, Z)
 */
@(typdef)
@(stydef)
@whiledef pre z c d s
void cblas_@(pre)gemm(const enum CBLAS_ORDER Order, const enum CBLAS_TRANSPOSE TransA,
                 const enum CBLAS_TRANSPOSE TransB, const int M, const int N,
                 const int K, const @(sty)alpha, const @(typ) *A,
                 const int lda, const @(typ) *B, const int ldb,
                 const @(sty)beta, @(typ) *C, const int ldc);
void cblas_@(pre)symm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side,
                 const enum CBLAS_UPLO Uplo, const int M, const int N,
                 const @(sty)alpha, const @(typ) *A, const int lda,
                 const @(typ) *B, const int ldb, const @(sty)beta,
                 @(typ) *C, const int ldc);
void cblas_@(pre)syrk(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
                 const enum CBLAS_TRANSPOSE Trans, const int N, const int K,
                 const @(sty)alpha, const @(typ) *A, const int lda,
                 const @(sty)beta, @(typ) *C, const int ldc);
void cblas_@(pre)syr2k(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
                  const enum CBLAS_TRANSPOSE Trans, const int N, const int K,
                  const @(sty)alpha, const @(typ) *A, const int lda,
                  const @(typ) *B, const int ldb, const @(sty)beta,
                  @(typ) *C, const int ldc);
void cblas_@(pre)trmm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side,
                 const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA,
                 const enum CBLAS_DIAG Diag, const int M, const int N,
                 const @(sty)alpha, const @(typ) *A, const int lda,
                 @(typ) *B, const int ldb);
void cblas_@(pre)trsm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side,
                 const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA,
                 const enum CBLAS_DIAG Diag, const int M, const int N,
                 const @(sty)alpha, const @(typ) *A, const int lda,
                 @(typ) *B, const int ldb);
   @undef typ
   @undef sty

@endwhile

/*
 * Routines with prefixes C and Z only
 */
@multidef uty double float
@whiledef pre z c
void cblas_@(pre)hemm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side,
                 const enum CBLAS_UPLO Uplo, const int M, const int N,
                 const void *alpha, const void *A, const int lda,
                 const void *B, const int ldb, const void *beta,
                 void *C, const int ldc);
void cblas_@(pre)herk(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
                 const enum CBLAS_TRANSPOSE Trans, const int N, const int K,
                 const @(uty) alpha, const void *A, const int lda,
                 const @(uty) beta, void *C, const int ldc);
void cblas_@(pre)her2k(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
                  const enum CBLAS_TRANSPOSE Trans, const int N, const int K,
                  const void *alpha, const void *A, const int lda,
                  const void *B, const int ldb, const @(uty) beta,
                  void *C, const int ldc);
   @undef uty
@endwhile

int cblas_errprn(int ierr, int info, char *form, ...);

#endif  /* end #ifdef CBLAS_ENUM_ONLY */
#endif
@ROUT atlas_enum.h
@extract -b @(topd)/gen.inc what=cw
#ifndef ATLAS_ENUM_H
   #define ATLAS_ENUM_H

   #define CBLAS_ENUM_ONLY
   #include "cblas.h"
   #undef CBLAS_ENUM_ONLY

   #define ATLAS_ORDER CBLAS_ORDER
      #define AtlasRowMajor CblasRowMajor
      #define AtlasColMajor CblasColMajor
   #define ATLAS_TRANS CBLAS_TRANSPOSE
      #define AtlasNoTrans CblasNoTrans
      #define AtlasTrans CblasTrans
      #define AtlasConjTrans CblasConjTrans
   #define ATLAS_UPLO CBLAS_UPLO
      #define AtlasUpper CblasUpper
      #define AtlasLower CblasLower
   #define ATLAS_DIAG CBLAS_DIAG
      #define AtlasNonUnit CblasNonUnit
      #define AtlasUnit CblasUnit
   #define ATLAS_SIDE CBLAS_SIDE
      #define AtlasLeft  CblasLeft
      #define AtlasRight CblasRight

#endif

@ROUT atlas_misc.h
@extract -b @(topd)/gen.inc what=cw

#include <stdio.h>
#include <stdlib.h>
#include "atlas_enum.h"

#ifndef ATLAS_MISC_H
#define ATLAS_MISC_H
#include "atlas_type.h"
#ifdef ATL_PROFILE
   extern int ATL_ProfGemmCameFrom;
#endif
/*
 * If using a C99 compiler, define the restrict attribute, which says that
 * this is the only pointer referencing the given section of memory
 */
#if defined(__STDC_VERSION__) && (__STDC_VERSION__/100 >= 1999)
   #define ATL_RESTRICT restrict
#else
   #define ATL_RESTRICT
#endif

/*
 * Some useful macro functions
 */
#if (defined(PentiumCPS) || defined(@(usept))) && !defined(WALL)
   #define WALL
#endif
#ifndef time00
   #if defined(CPUTIME)
      #define time00 ATL_cputime
   #else
      #define time00 ATL_walltime
   #endif
#endif
#define Mabs(x) ( (x) >= 0 ? (x) : -(x) )
#define Mmax(x, y) ( (x) > (y) ? (x) : (y) )
#define Mmin(x, y) ( (x) > (y) ? (y) : (x) )
#define Mlowcase(C) ( ((C) > 64 && (C) < 91) ? (C) | 32 : (C) )
#define Mupcase(C) ( ((C) > 96 && (C) < 123) ? (C) & 0xDF : (C) )
/*
 * packed indexing functions (upper & lower)
 */
@beginskip
#define MindexPL(I_, J_, lda_) ( ((((lda_)+(lda_)-(J_)+1)*(J_))>>1) + (I_) )
#define MindexPU(I_, J_, gap_) ( ((((gap_)+(gap_)+(J_)+1)*(J_))>>1) + (I_) )
#define MindexPL(I,J,lda) ( (((lda+lda+1-J)*J)>>1) + I )
#define MindexPU(I,J,lda) ( J*lda + (((J-1)*J)>>1) + I )
#define MindexP(Uplo_, I_, J_, gap_) \
   ( ((Uplo_) == AtlasUpper) ? MindexPU(I_,J_, gap_) : MindexPL(I_,J_,gap_) )
@endskip

#define Mjoin(pre, nam) my_join(pre, nam)
#define my_join(pre, nam) pre ## nam
#define Mstr2(m) # m
#define Mstr(m) Mstr2(m)

#define ATL_assert(n_) \
{ \
   if (!(n_)) \
   { \
      ATL_xerbla(0, __FILE__, "assertion %s failed, line %d of file %s\n", \
                 Mstr(n_), __LINE__, __FILE__); \
   } \
}

/*
 * Define some C99 features that we use when we know the compiler supports them
 */
#if defined(__STDC_VERSION__) && (__STDC_VERSION__/100 >= 1999)
   #define INLINE inline
   #define RESTRICT restrict
#else
   #define INLINE
   #define RESTRICT
#endif

#ifdef ATL_LONG_INT
   #define ATL_INT long
   #define ATL_CINT const long
#else
   #define ATL_INT int
   #define ATL_CINT const int
#endif
#define ATL_SZT size_t
#define ATL_CSZT const size_t
#define ATL_UINT unsigned ATL_INT
#define ATL_CUINT const unsigned ATL_INT


#define ATL_QTYPE long double
#if defined(SREAL)
   #define EPS 5.0e-7
   #define TYPE float
   #define PRE s
   #define UPR s
   #define PREU S
   #define PATL ATL_s
   #define PATU ATLU_s
   #define UATL ATLU_s
   #define CBLA cblas_s
   #define PATLU ATL_s
   #define ATL_rone   1.0f
   #define ATL_rnone -1.0f
   #define ATL_rzero   0.0f
   #define ATL_typify(m_) Mjoin(m_,f)
   #include "atlas_ssysinfo.h"
#elif defined(DREAL)
   #define EPS 1.0e-15
   #define TYPE double
   #define PRE d
   #define UPR d
   #define PREU D
   #define PATL ATL_d
   #define PATU ATLU_d
   #define UATL ATLU_d
   #define CBLA cblas_d
   #define PATLU ATL_d
   #define ATL_rone   1.0
   #define ATL_rnone -1.0
   #define ATL_rzero   0.0
   #define ATL_typify(m_) m_
   #include "atlas_dsysinfo.h"
#elif defined (QREAL)
   #define EPS 1.9259299443872358530559779425849273E-34L
   #define TYPE long double
   #define PRE q
   #define UPR q
   #define PREU Q
   #define PATL ATL_q
   #define PATU ATLU_q
   #define CBLA cblas_q
   #define ATL_rone 1.0
   #define ATL_rnone -1.0
   #define ATL_rzero 0.0
#elif defined(SCPLX)
   #define EPS 5.0e-7
   #define TYPE float
   #define PRE c
   #define UPR s
   #define PREU C
   #define PATL ATL_c
   #define PATLU ATL_s
   #define PATU ATLU_c
   #define UATL ATLU_s
   #define ATL_rone  1.0f
   #define ATL_rnone -1.0f
   #define ATL_rzero   0.0f
   #define ATL_typify(m_) Mjoin(m_,f)
   #define CBLA cblas_c
   #include "atlas_csysinfo.h"
#elif defined(DCPLX)
   #define TYPE double
   #define PRE z
   #define UPR d
   #define PREU Z
   #define PATL ATL_z
   #define PATLU ATL_d
   #define PATU ATLU_z
   #define UATL ATLU_d
   #define EPS 1.0e-15
   #define ATL_rone   1.0
   #define ATL_rnone -1.0
   #define ATL_rzero   0.0
   #define ATL_typify(m_) m_
   #define CBLA cblas_z
   #include "atlas_zsysinfo.h"
#elif defined(QCPLX)
   #define TYPE ATL_QTYPE
   #define PRE e
   #define UPR q
   #define PREU E
   #define PATL ATL_e
   #define PATLU ATL_q
   #define UATL ATLU_q
   #define EPS 1.9259299443872358530559779425849273E-34L
   #define ATL_rone 1.0
   #define ATL_rnone -1.0
   #define ATL_rzero 0.0
   #define CBLA cblas_e
#elif defined(SINT)
   #define TYPE int
   #define PRE i
   #define PATL ATL_i
#elif defined(DINT)
   #define TYPE long long
   #define PRE l
   #define PATL ATL_l
#endif

#if defined (SREAL) || defined (DREAL) || defined (SCPLX) || defined (DCPLX) \
    || defined(SINT)
   #define ATL_sizeof Mjoin(PATL,size)
   #define ATL_MulBySize Mjoin(PATL,MulBySize)
   #define ATL_DivBySize Mjoin(PATL,DivBySize)
#else
   #define ATL_sizeof sizeof(TYPE)
   #define ATL_MulBySize Mjoin(Mjoin(ATL_,PRE),MulBySize)(N_) \
      ((N_)*sizeof(TYPE))
   #define ATL_DivBySize Mjoin(Mjoin(ATL_,PRE),DivBySize)(N_) \
      ((N_)/sizeof(TYPE))
#endif

#if defined(SREAL) || defined(DREAL) || defined(QREAL) || \
    defined(SINT) || defined(DINT)
   #define TREAL
   #define SHIFT
   #define SCALAR TYPE
   #define SADD &
   #define SVAL
   #define SVVAL *
   #define IS_COLMAJ(T_) ((T_) == AtlasNoTrans)
   #if defined(SINT) || defined(DINT)
      #define SCALAR_IS_ONE(M_scalar) ((M_scalar) == 1)
      #define SCALAR_IS_NONE(M_scalar) ((M_scalar) == -1)
      #define SCALAR_IS_ZERO(M_scalar) ((M_scalar) == 0)
   #else
      #define SCALAR_IS_ONE(M_scalar) ((M_scalar) == ATL_rone)
      #define SCALAR_IS_NONE(M_scalar) ((M_scalar) == ATL_rnone)
      #define SCALAR_IS_ZERO(M_scalar) ((M_scalar) == ATL_rzero)
   #endif
#elif defined(SCPLX) || defined(DCPLX) || defined(QCPLX)
   #define TCPLX
   #define IS_COLMAJ(T_) ((T_) == AtlasNoTrans || (T_) == AtlasConj)
/*
 * c = b*c + v;
 */
   #define CMULT2(v, a, b, tmp) \
   { \
      tmp = *(a) * *(b) - *(a+1) * *(b+1); \
      *(b+1) = *(a) * *(b+1) + *(a+1) * *(b) + *(v+1); \
      *(b) = tmp + *v; \
   }
   #define SHIFT << 1
   #define SCALAR TYPE *
   #define SADD
   #define SVAL *
   #define SVVAL
   #define SCALAR_IS_ONE(M_scalar) \
      ( (*(M_scalar) == ATL_rone) && ((M_scalar)[1] == ATL_rzero) )
   #define SCALAR_IS_NONE(M_scalar) \
      ( (*(M_scalar) == ATL_rnone) && ((M_scalar)[1] == ATL_rzero) )
   #define SCALAR_IS_ZERO(M_scalar) \
      ( (*(M_scalar) == ATL_rzero) && ((M_scalar)[1] == ATL_rzero) )
#endif
#define ATLAS_PRE Mjoin(atlas_,PRE)
#define ATLAS_UPR Mjoin(atlas_,UPR)
#define AMM_PRE Mjoin(ATLAS_PRE,geamm)
#define AMM_UPR Mjoin(ATLAS_UPR,geamm)

#if defined(ALPHA1)
   #define ATL_MulByALPHA(x_) (x_)
   #define NM _a1
#elif defined (ALPHA0)
   #define ATL_MulByALPHA(x_) ATL_rzero
   #define NM _a0
#elif defined (ALPHAN1)
   #define ATL_MulByALPHA(x_) (-(x_))
   #define NM _an1
#elif defined (ALPHAXI0)
   #define ATL_MulByALPHA(x_) (ralpha*(x_))
   #define NM _aXi0
#elif defined (ALPHA1C)
   #define NM _a1c
#elif defined (ALPHAN1C)
   #define NM _an1c
#elif defined (ALPHAXI0C)
   #define NM _aXi0c
#elif defined (ALPHAXC)
   #define NM _aXc
#elif defined (ALPHAX)
   #define ATL_MulByALPHA(x_) (alpha*(x_))
   #define NM _aX
#endif

#if defined(BETA1)
   #define ATL_MulByBETA(x_) (x_)
   #define MSTAT A[i] += v[i]
   #define BNM _b1
#elif defined(BETA1C)
   #define BNM _b1c
#elif defined(BETAN1)
   #define ATL_MulByBETA(x_) (-(x_))
   #define MSTAT A[i] = v[i] - A[i]
   #define BNM _bn1
#elif defined(BETAN1C)
   #define BNM _bn1c
#elif defined(BETA0)
   #define ATL_MulByBETA(x_) ATL_rzero
   #define MSTAT A[i] = v[i]
   #define BNM _b0
#elif defined (BETAXI0)
   #define BNM _bXi0
   #define ATL_MulByBETA(x_) (rbeta*(x_))
#elif defined (BETAXI0C)
   #define BNM _bXi0c
#elif defined (BETAX)
   #define ATL_MulByBETA(x_) (beta*(x_))
   #define MSTAT A[i] = beta*A[i] + v[i]
   #define BNM _bX
#elif defined (BETAXC)
   #define BNM _bXc
#endif

/* any alignment below this forces data copy in gemm */
#ifndef ATL_MinMMAlign
   #if defined (ATL_AVXZ)
      #define ATL_MinMMAlign 64
   #elif defined (ATL_AVX)
      #define ATL_MinMMAlign 32
   #else
      #define ATL_MinMMAlign 16
   #endif
#endif
#if (ATL_MinMMAlign == 1 || ATL_MinMMAlign == 0)
   #define ATL_DataIsMinAligned(ptr) 1
#elif (ATL_MinMMAlign == 2)
   #define ATL_DataIsMinAligned(ptr) \
      ( (((size_t) (ptr))>>1)<<1 == (size_t) (ptr) )
#elif (ATL_MinMMAlign == 4)
   #define ATL_DataIsMinAligned(ptr) \
      ( (((size_t) (ptr))>>2)<<2 == (size_t) (ptr) )
#elif (ATL_MinMMAlign == 8)
   #define ATL_DataIsMinAligned(ptr) \
      ( (((size_t) (ptr))>>3)<<3 == (size_t) (ptr) )
#elif (ATL_MinMMAlign == 16)
   #define ATL_DataIsMinAligned(ptr) \
      ( (((size_t) (ptr))>>4)<<4 == (size_t) (ptr) )
#elif (ATL_MinMMAlign == 32)
   #define ATL_DataIsMinAligned(ptr) \
      ( (((size_t) (ptr))>>5)<<5 == (size_t) (ptr) )
#elif (ATL_MinMMAlign == 64)
   #define ATL_DataIsMinAligned(ptr) \
      ( (((size_t) (ptr))>>6)<<6 == (size_t) (ptr) )
#elif (ATL_MinMMAlign == 128)
   #define ATL_DataIsMinAligned(ptr) \
      ( (((size_t) (ptr))>>7)<<7 == (size_t) (ptr) )
#else
   #define ATL_DataIsMinAligned(ptr) \
      ( (((size_t) (ptr))/ATL_MinMMAlign)*ATL_MinMMAlign == (size_t) (ptr) )
#endif

#if ATL_MinMMAlign > 64
   #define ATL_Cachelen ATL_MinMMAlign
#else
   #define ATL_Cachelen 64
#endif
#if (ATL_Cachelen == 4)
   #define ATL_MulByCachelen(N_) ( (N_) << 2 )
   #define ATL_DivByCachelen(N_) ( (N_) >> 2 )
#elif (ATL_Cachelen == 8)
   #define ATL_MulByCachelen(N_) ( (N_) << 3 )
   #define ATL_DivByCachelen(N_) ( (N_) >> 3 )
#elif (ATL_Cachelen == 16)
   #define ATL_MulByCachelen(N_) ( (N_) << 4 )
   #define ATL_DivByCachelen(N_) ( (N_) >> 4 )
#elif (ATL_Cachelen == 32)
   #define ATL_MulByCachelen(N_) ( (N_) << 5 )
   #define ATL_DivByCachelen(N_) ( (N_) >> 5 )
#elif (ATL_Cachelen == 64)
   #define ATL_MulByCachelen(N_) ( (N_) << 6 )
   #define ATL_DivByCachelen(N_) ( (N_) >> 6 )
#elif (ATL_Cachelen == 128)
   #define ATL_MulByCachelen(N_) ( (N_) << 7 )
   #define ATL_DivByCachelen(N_) ( (N_) >> 7 )
#elif (ATL_Cachelen == 256)
   #define ATL_MulByCachelen(N_) ( (N_) << 8 )
   #define ATL_DivByCachelen(N_) ( (N_) >> 8 )
#else
   #define ATL_MulByCachelen(N_) ( (N_) * ATL_Cachelen )
   #define ATL_DivByCachelen(N_) ( (N_) / ATL_Cachelen )
#endif

#if (ATL_Cachelen < ATL_MinMMAlign)
   Force a compilation error if our required alignment is at least the
   minimum!!@^
#endif

#define ATL_AlignPtr(vp) (void*) \
        ATL_MulByCachelen(ATL_DivByCachelen((((size_t)(vp))+ATL_Cachelen-1)))
@skip   (ATL_Cachelen + ATL_MulByCachelen(ATL_DivByCachelen((size_t) (vp))))

#define ATL_FindPtrAdjust(vp, iadj_) \
{ \
   (iadj_) = ((size_t)(vp))-ATL_MulByCachelen(ATL_DivByCachelen((size_t)(vp)));\
   if (iadj_) \
   { \
      if ( (iadj_) == ATL_MulBySize(ATL_DivBySize(iadj_)) ) \
         (iadj_) = ATL_DivBySize(iadj_); \
      else (iadj_) = 0; \
   }\
}
#define ATL_FindMatAdjust(vp_, lda_, iadj_) \
{ \
   if (ATL_MulByCachelen(ATL_DivByCachelen(ATL_MulBySize(lda_))) \
       == ATL_MulBySize(lda_)) \
   { \
      ATL_FindPtrAdjust(vp_, iadj_); \
   } \
   else (iadj_) = 0; \
}

#define ATL_sqrtLL(x, res) \
   asm ("fsqrt" : "=t" (res) : "0" (x));

/*
 * Find N necessary for alignment.  Written as function for optimization,
 * declared static to encourage inlining
 */
static int ATL_AlignOffset
(const int N,       /* max return value */
 const void *vp,    /* pointer to be aligned */
 const int inc,     /* size of each elt, in bytes */
 const int align)   /* required alignment, in bytes */
{
   const int p = align/inc;
   const size_t k=(size_t)vp, j=k/inc;
   int iret;
   if (k == (j)*inc && p*inc == align)
   {
      iret = ((j+p-1) / p)*p - j;
      if (iret <= N) return(iret);
   }
   return(N);
}
static void *ATL_Align2Ptr(const void *pu, const void *pA)
/*
 * Aligns pu%ATL_Cachelen to pA%ATL_Cachelen by adding at most ATL_Cachlen
 * to pu
 * RETURNS: pu possibly incremented so that it has same alignment as pA
 */
{
   size_t urem = (size_t) pu, arem = (size_t) pA;
   const size_t au = ATL_MulByCachelen(ATL_DivByCachelen(urem));

   urem -= au;
   arem -= ATL_MulByCachelen(ATL_DivByCachelen(arem));
   if (urem <= arem)
      return((void*)(au+arem));
   return((void*)(au + ATL_Cachelen+arem));
}


/*
 * Gcc links in crap that MSVC++ and DVF can't handle if you use stdout
 * or stderr, so use this beautiful kludge to avoid this problem -- RCW
 */
#ifdef GCCWIN

#include <stdarg.h>
static int WINFPRINTF(FILE *fpout, char *form, ...)
{
   int ierr=0;
   va_list argptr;

   va_start(argptr, form);
   if (fpout == NULL) ierr = vprintf(form, argptr);
   else ierr = vfprintf(fpout, form, argptr);
   va_end(argptr);

   return(ierr);
}

#ifdef stdout
   #undef stdout
#endif
#ifdef stderr
   #undef stderr
#endif
#ifdef assert
   #undef assert
#endif

#define stdout NULL
#define stderr NULL
#define fprintf WINFPRINTF
#define assert WINASSERT
#define WINASSERT(n_) \
{ \
   if (!(n_)) \
   { \
      printf("assertion %s failed, line %d of file %s\n", \
             Mstr(n_), __LINE__, __FILE__); \
      exit(1); \
   } \
}

#endif

#include "atlas_aux.h"

#endif
@ROUT atlas_level3.h
@extract -b @(topd)/gen.inc what=cw
/*
 * ===========================================================================
 * Prototypes for level 3 BLAS
 * ===========================================================================
 */
#ifndef ATLAS_LEVEL3_H
   #define ATLAS_LEVEL3_H

/* 
 * Routines with standard 4 prefixes (S, D, C, Z)
 */
@multidef typ double float double float
@multidef sty double@^* float@^* double@^ float@^
@whiledef pre z c d s
int ATL_@(pre)GetNB(void);
int ATL_@(pre)GetNCNB(void);
void ATL_@(pre)ammm
   (enum ATLAS_TRANS,enum ATLAS_TRANS,ATL_CSZT,ATL_CSZT,ATL_CSZT, 
    const @(sty), const @(typ)*,ATL_CSZT,const @(typ)*,ATL_CSZT,
    const @(sty),@(typ)*,ATL_CSZT);

void ATL_@(pre)gemm(const enum ATLAS_TRANS, const enum ATLAS_TRANS,
               const int M, const int N, const int K, const @(sty)alpha,
               const @(typ) *A, const int lda, const @(typ) *B, const int ldb,
               const @(sty)beta, @(typ) *C, const int ldc);
void ATL_@(pre)symm(const enum ATLAS_SIDE Side, const enum ATLAS_UPLO Uplo,
               const int M, const int N, const @(sty)alpha, 
               const @(typ) *A, const int lda, const @(typ) *B, const int ldb,
               const @(sty)beta, @(typ) *C, const int ldc);
void ATL_@(pre)syrk(const enum ATLAS_UPLO Uplo, const enum ATLAS_TRANS Trans,
               const int N, const int K, const @(sty)alpha,
               const @(typ) *A, const int lda, const @(sty)beta,
               @(typ) *C, const int ldc);
void ATL_@(pre)syr2k(const enum ATLAS_UPLO Uplo, const enum ATLAS_TRANS Trans,
                const int N, const int K, const @(sty)alpha,
                const @(typ) *A, const int lda, const @(typ) *B, const int ldb,
                const @(sty)beta, @(typ) *C, const int ldc);
void ATL_@(pre)trmm(const enum ATLAS_SIDE Side, const enum ATLAS_UPLO Uplo,
               const enum ATLAS_TRANS TransA, const enum ATLAS_DIAG Diag,
               const int M, const int N, const @(sty)alpha,
               const @(typ) *A, const int lda, @(typ) *B, const int ldb);
void ATL_@(pre)trsm(const enum ATLAS_SIDE Side, const enum ATLAS_UPLO Uplo,
               const enum ATLAS_TRANS TransA, const enum ATLAS_DIAG Diag,
               const int M, const int N, const @(sty)alpha,
               const @(typ) *A, const int lda, @(typ) *B, const int ldb);
   @undef typ
   @undef sty

@endwhile

/* 
 * Routines with prefixes C and Z only
 */
@multidef uty double float
@whiledef pre z c
void ATL_@(pre)hemm(const enum ATLAS_SIDE Side, const enum ATLAS_UPLO Uplo,
               const int M, const int N, const @(uty) *alpha,
               const @(uty) *A, const int lda, const @(uty) *B, const int ldb,
               const @(uty) *beta, @(uty) *C, const int ldc);
void ATL_@(pre)herk(const enum ATLAS_UPLO Uplo, const enum ATLAS_TRANS Trans,
               const int N, const int K, const @(uty) alpha,
               const @(uty) *A, const int lda, const @(uty) beta,
               @(uty) *C, const int ldc);
void ATL_@(pre)her2k(const enum ATLAS_UPLO Uplo, const enum ATLAS_TRANS Trans,
                const int N, const int K, const @(uty) *alpha,
                const @(uty) *A, const int lda, const @(uty) *B, const int ldb,
                const @(uty) beta, @(uty) *C, const int ldc);
   @undef uty

@endwhile

#endif
@ROUT atlas_lvl3.h
@extract -b @(topd)/gen.inc what=cw

#ifndef ATLAS_LVL3_H
#define ATLAS_LVL3_H

#include "atlas_misc.h"
#include "atlas_amm.h"
#include "atlas_f77.h"
#include "atlas_level3.h"
#ifndef ATL_NOAMM
   #define NOPERF 1
   #define NOK1RATIO 1
   #define NOTIME 1
   #if defined(SREAL)
      #include "atlas_samm_sum.h"
      #include "atlas_ssqamm_perf.h"
   #elif defined(DREAL)
      #include "atlas_damm_sum.h"
      #include "atlas_dsqamm_perf.h"
   #elif defined(QREAL)
      #include "atlas_qamm_sum.h"
      #include "atlas_qsqamm_perf.h"
   #elif defined(SCPLX)
      #include "atlas_camm_sum.h"
      #include "atlas_csqamm_perf.h"
   #elif defined(DCPLX)
      #include "atlas_zamm_sum.h"
      #include "atlas_zsqamm_perf.h"
   #endif
   #undef NOPERF
   #undef NOK1RATIO
   #undef NOTIME
#endif
#define CPAT Mjoin(C_ATL_, PRE);

#endif
@ROUT second
double time00(void);
float second(void) { return((float)time00()); }
float second_(void) { return((float)time00()); }
float SECOND(void) { return((float)time00()); }
@ROUT time
#include "ATL_walltime.c"
#include "ATL_cputime.c"
@ROUT ATL_walltime
@extract -b @(topd)/cw.inc lang=C -def cwdate 2015 -def cwdate 1997

/*
 * Cycle-accurate timers not quite thread safe, but all cores should
 * almost always be the same in upper 11 bits, which we need to mask
 * of to avoid losing precision going from long long -> double
 */
#ifdef PentiumCPS
   #include <assert.h>
   #ifdef __LP64__
      #define ATL_GetCycleCount(ll_) __asm__ __volatile__ \
      ("xorq %%rax, %%rax ; .byte 0x0f ; .byte 0x31 ; " \
       "shlq $32, %%rdx ; orq %%rdx, %%rax " \
       : "=a"(ll_)      /* output */ \
       :                /* no input params */ \
       : "%rdx"  /* clobber list */ \
      );
      #define MASK11 (((long long)0xFFE0)<<48)
      double ATL_walltime(void)
      {
         const static double mul=1.0e-6 / ((double)PentiumCPS);
         static long long top11bits=1, t11;
         long long cycnt;

         ATL_GetCycleCount(cycnt)
         t11 = cycnt & MASK11;
         if (top11bits != t11)
         {
            assert(top11bits == 1);
            top11bits = t11;
         }
         cycnt &= ~MASK11;
         return(mul*cycnt);
      }
   #else
      #define ATL_GetCycleCount(hi_, lo_) __asm__ __volatile__ \
      (".byte 0x0f ; .byte 0x31 ; " \
       : "=a"(lo_), "=d"(hi_)     /* output */ \
       :                          /* no input params */ \
       :                          /* clobber list */ \
      );
      #define MASK11 (0xFFE0<<16)
      double ATL_walltime(void)
      {
         const static double mul=1.0e-6 / ((double)PentiumCPS);
         static unsigned int top11bits=1, t11;
         unsigned long long cyc;
         unsigned int hi, lo;
         ATL_GetCycleCount(hi, lo);
         t11 = hi & MASK11;
         if (t11 != top11bits)
         {
            assert(top11bits == 1);
            top11bits = t11;
         }
         cyc = hi & (~MASK11);
         cyc = (cyc << 32) | lo;
         return(mul*cyc);
      }
   #endif
#elif defined(ATL_OS_WinNT) /* special code for windows */
   #include <windows.h>
   double ATL_walltime(void)
   {
      static double freqRecip = 0.0;
      LARGE_INTEGER msout;
      unsigned long long myout;
/*
 *    Not thread-safe, but shouldn't cause problems, since all cores
 *    should hopefully get the same answer
 */
      if (freqRecip == 0.0)
      {
         QueryPerformanceFrequency(&msout);
         myout = msout.HighPart;
         myout = (myout<<32) | msout.LowPart;
         freqRecip = 1.0/((double) myout);
      }
      QueryPerformanceCounter(&msout);
      myout = msout.HighPart;
      myout = (myout<<32) | msout.LowPart;
      return(myout*freqRecip);
   }
#elif defined(UseTimes)
   #include <stdlib.h>
   #include <sys/times.h>
   #include <unistd.h>
   double ATL_walltime(void)
   {
      struct tms ts;
      static double ClockTick=0.0;
   
      if (ClockTick == 0.0) ClockTick = 1.0 / ((double) sysconf(_SC_CLK_TCK));
      return( ((double) times(&ts)) * ClockTick);
   }
#elif defined(SUN_HR) /* use sun high resolution timers */
   #include <sys/time.h>
   double ATL_walltime(void)
   {
      return(gethrtime()*1.0e-9);
   }
#elif defined(POSIX_HR) /* use the POSIX HR timers */
   #include <time.h>
   double ATL_walltime(void)
   {
      struct timespec ts;
      double res;

      clock_gettime(CLOCK_REALTIME, &ts);
      res = ts.tv_sec + 1.0e-9 * ts.tv_nsec;
      return(res);
   }
/*
 * Without gcc, I know no standard Windows wall-timer, so use cputime
 */
#elif (!defined(__GNUC__) && (defined(ATL_OS_Win9x) || defined(ATL_OS_WinNT))) \
      || defined(__MINGW32__)
   #include <time.h>
   double ATL_walltime(void)
   {
      static const double CPS = 1.0 / (1.0*CLOCKS_PER_SEC);
   
      return(clock() * CPS);
   }
#else
   #include <stdlib.h>
   #include <sys/time.h>
   #include <sys/resource.h>
   double ATL_walltime(void)
   {
      struct timeval tp;
      gettimeofday(&tp, NULL);
      return( ((double) tp.tv_sec) + (tp.tv_usec*1.0e-6) );
   }
#endif

@ROUT ATL_cputime
@extract -b @(topd)/gen.inc what=cw


#if defined(ATL_ARCH_TI_C66_BM) && (!defined(ATL_USING_XCC))
   /* The following code is used because ATL_ARCH_TI_C66_BM is defined.    */
   /* Note: timer overhead has been measured; it is 2 cycles. TSCH, TSCL   */
   /* are C66 registers we access directly; TSCL=0 restarts timer. It is   */
   /* C66 specific; it cannot be used when compiling for the host, e.g.    */
   /* ATL_Xwalltime. Also, their time.h file has the wrong CLOCKS_PER_SEC. */
   #include <c6x.h>
   double ATL_cputime(void)
   {
      static int INIT=0;                  /* First time in, reset timer. */
      long long unsigned int now;
      static const double CPS = 1.0 / (1000000000.0);
      double d;

      if (INIT==0)                        /* Reset timer if first run. */
      {
         INIT = 1;                        /* Remember we did it. */
         TSCL = 0;                        /* Ensure hardware time is running. */
      }

      now = _itoll(TSCH, TSCL);           /* Convert timer regs to long long. */
      d = (double) (now);                 /* get as a double. */
      d *= CPS;                           /* Convert to seconds. */
      return(d);                          /* Exit with answer.  */
   } /* END ATL_cputime */
#elif defined(UseClock)
   #include <time.h>
   double ATL_cputime(void)
   {
      clock_t t1;
      static int INIT=0;
      static clock_t t0;
      static const double CPS = 1.0 / (1.0*CLOCKS_PER_SEC);
      double d;
   
      if (INIT)
      {
         t1 = clock() - t0;
         d = t1 * CPS;
         return(d);
      }
      INIT = 1;
      t0 = clock();
      return(0.0);
   }
#elif defined(POSIX_HR) /* use the POSIX HR timers */
   #include <time.h>
   double ATL_cputime(void)
   {
      struct timespec ts;
      static double t0;
      double res;
      static int INIT = 0;

      if (INIT)
      {
         clock_gettime(CLOCK_PROCESS_CPUTIME_ID, &ts);
         res = ts.tv_sec + 1.0e-9 * ts.tv_nsec;
         return(res - t0);
      }
      clock_gettime(CLOCK_PROCESS_CPUTIME_ID,&ts);
      t0 = ts.tv_sec + 1.0e-9 * ts.tv_nsec;
      INIT = 1;
      return(0.0);
   }
#elif defined(UseTimes)
   #include <stdlib.h>
   #include <sys/times.h>
   #include <unistd.h>
   double ATL_cputime(void)
   {
      struct tms ts;
      static double ClockTick=0.0;
   
      if (ClockTick == 0.0) ClockTick = 1.0 / ((double) sysconf(_SC_CLK_TCK));
      times(&ts);
      return( ((double) ts.tms_utime) * ClockTick );
   }
#elif defined(SUN_HR) /* use sun high resolution timers */
   #include <sys/time.h>
   double ATL_cputime(void)
   {
      return(gethrvtime()*1.0e-9);
   }
#else
   #include <stdlib.h>
   #include <sys/time.h>
   #include <sys/resource.h>
   double ATL_cputime(void)
   {
      struct rusage ruse;
      getrusage(RUSAGE_SELF, &ruse);
      return( (double)(ruse.ru_utime.tv_sec+ruse.ru_utime.tv_usec/1000000.0) );
   }
#endif

@ROUT time00
#if defined(ATL_ARCH_TI_C66_BM) && (!defined(ATL_USING_XCC))
   /* The following code is used because ATL_ARCH_TI_C66_BM is defined.    */
   /* Note: timer overhead has been measured; it is 2 cycles. TSCH, TSCL   */
   /* are C66 registers we access directly; TSCL=0 restarts timer. It is   */
   /* C66 specific; it cannot be used when compiling for the host, e.g.    */
   /* ATL_Xwalltime. Also, their time.h has wrong CLOCKS_PER_SEC.          */
   #include <c6x.h>
   double ATL_walltime(void)
   {
      static int INIT=0;                  /* First time in, reset timer. */
      long long unsigned int now;
      static const double CPS = 1.0 / (1000000000.0);
      double d;

      if (INIT==0)                        /* Reset timer if first run. */
      {
         INIT = 1;                        /* Remember we did it. */
         TSCL = 0;                        /* Ensure hardware timer running. */
      }

      now = _itoll(TSCH, TSCL);           /* Convert timer regs to long long. */
      d = (double) (now);                 /* get as a double. */
      d *= CPS;                           /* Convert to seconds. */
      return(d);                          /* Exit with answer.  */
   } /* END ATL_walltime */
#elif defined(PentiumCPS)
#include <sys/time.h>
#include <sys/types.h>
#include <stdlib.h>
#include <stdio.h>

#define CPS (PentiumCPS*1E6)

static unsigned usec, sec;
static unsigned tusec, tsec;
static unsigned start=0, startu;
static long long foo;

static inline void microtime(unsigned *lo, unsigned *hi)
{
  __asm __volatile (
        ".byte 0x0f; .byte 0x31   # RDTSC instruction
        movl    %%edx,%0          # High order 32 bits
        movl    %%eax,%1          # Low order 32 bits"
                : "=g" (*hi), "=g" (*lo) :: "eax", "edx");
}

@beginskip
double time00(void)
{
again:
  microtime(&tusec, &tsec);
  microtime(&usec, &sec);
  if (tsec != sec) goto again;

  foo = sec;
  foo = foo << 32;
  foo |= usec;
  return ((double)foo/(double)CPS);
}
@endskip
double time00(void)
{
  if (!start)
  {
     microtime(&startu, &start);
     return(0.0);
  }
  microtime(&usec, &sec);

  foo = sec;
  foo -= start;
  foo = (foo << 32) + usec;
  foo -= startu;
  return(((double)foo)/(double)CPS);
}
#elif defined(UseClock)

#include <time.h>
double time00(void)
{
   clock_t t1;
   static clock_t t0=0;
   static double CPS = CLOCKS_PER_SEC;
   double d;

   if (t0 == 0) t0 = clock();
   t1 = clock() - t0;
   d = t1 / CPS;
   return(d);
}

#elif defined(WALL)

#include <stdlib.h>
#include <sys/time.h>
#include <sys/resource.h>
double time00(void)
{
   struct timeval tp;
   static long start=0, startu;
   if (!start)
   {
      gettimeofday(&tp, NULL);
      start = tp.tv_sec;
      startu = tp.tv_usec;
      return(0.0);
   }
   gettimeofday(&tp, NULL);
   return( ((double) (tp.tv_sec - start)) + (tp.tv_usec-startu)/1000000.0 );
}

#elif defined(UseTimes)

#include <stdlib.h>
#include <sys/times.h>
#include <unistd.h>
double time00(void)
{
   struct tms ts;
   static double ClockTick=0.0;

   if (ClockTick == 0.0) ClockTick = (double) sysconf(_SC_CLK_TCK);
   times(&ts);
   return( (double) ts.tms_utime / ClockTick );
}

#else

#include <stdlib.h>
#include <sys/time.h>
#include <sys/resource.h>
double time00(void)
{
   struct rusage ruse;
   getrusage(RUSAGE_SELF, &ruse);
   return( (double)(ruse.ru_utime.tv_sec+ruse.ru_utime.tv_usec / 1000000.0) );
}

#endif
@ROUT GEMMTST
@extract -b @(topd)/gen.inc what=cw
#if defined(ATL_AFFINITY) || defined(ATL_NOAFFINITY)
   #ifndef ATL_USEPTHREADS
      #define ATL_USEPTHREADS
   #endif
#endif

/* #define TEST_RKKM 1 */
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>

#include "atlas_misc.h"
#include "atlas_lvl3.h"
#include "atlas_tst.h"
#include "cblas.h"
#include "atlas_bitvec.h"
#ifdef ATL_USEPTHREADS
   #include "atlas_tlvl3.h"
#endif
#ifdef TRUST_REF
   #include "atlas_reflevel3.h"
#endif
#if defined(ATL_RKXOVER) || defined(TEST_RANKK)
   #define TRUST_BIGNORK
   void Mjoin(PATL,bignork_mm)
      (const enum ATLAS_TRANS TA, const enum ATLAS_TRANS TB,
       const int M, const int N, const int K, const SCALAR alpha,
       const TYPE *A, const int lda, const TYPE *B, const int ldb,
       const SCALAR beta, TYPE *C, const int ldc);
   #ifdef TCPLX
      #error "ATLAS's rank-K update does not yet support complex types!"
   #endif
#endif
#if defined(ATL_RKXOVER) && !defined(TEST_RANKK)
   #define TEST_RANKK
#endif
#ifdef TEST_GPMM
   #include "atlas_pkblas.h"
#endif
#ifdef TEST_RANKK
   #include Mstr(Mjoin(Mjoin(atlas_,PRE),vkbmms.h))
int Mjoin(PATL,vrankK)(const enum ATLAS_TRANS TA, const enum ATLAS_TRANS TB,
                       ATL_CINT M, ATL_CINT N, ATL_CINT K, const SCALAR alpha,
                       const TYPE *A, ATL_CINT lda, const TYPE *B,
                       ATL_CINT ldb, const SCALAR beta, TYPE *C, ATL_CINT ldc);
   #ifdef ATL_RKXOVER
      FILE *fprk=NULL;
      int speedup_rk[ATL_vMAX_KB+1], speedup_rk_b0[ATL_vMAX_KB+1];
      int MAX_vKB = ATL_vMAX_KB;
   #endif
#elif defined(TEST_GEMM_RK)
int Mjoin(PATL,gemm_rK)(const enum ATLAS_TRANS TA, const enum ATLAS_TRANS TB,
                        ATL_CINT M, ATL_CINT N, ATL_CINT K, const SCALAR alpha,
                        const TYPE *A, ATL_CINT lda, const TYPE *B,
                        ATL_CINT ldb, const SCALAR beta, TYPE *C, ATL_CINT ldc);
#endif

#ifndef L2SIZE
   #define L2SIZE 4194304
#endif

#ifdef ATL_DeclareSlens
F77_INTEGER ATL_Slen1, ATL_Slen2;
#endif
double time00(void);

void printmat(char *mat, int M, int N, TYPE *A, int lda)
{
   int i, j;

#ifdef TCPLX
   lda *= 2;
#endif
   printf("\n%s = \n",mat);
   for (i=0; i != M; i++)
   {
#ifdef TREAL
      for (j=0; j != N; j++) printf("%f  ",A[i+j*lda]);
#else
      for (j=0; j != N; j++) printf("(%f,%f)  ",A[2*i+j*lda], A[1+2*i+j*lda]);
#endif
      printf("\n");
   }
}

void matgen(int M, int N, TYPE *A, int lda, int seed)
{
   int i, j;

#ifdef TCPLX
   M *= 2;
   lda *= 2;
#endif
   dumb_seed(seed);
   for (j=N; j; j--)
   {
      for (i=0; i != M; i++) A[i] = dumb_rand();
      for (; i < lda; i++) A[i] = -9e27;
      A += lda;
   }
}

#ifdef ATL_NANC
void matnan(int M, int N, TYPE *C, int ldc, int seed)
/*
 * Fills matrix with NaNs
 */
{
   int i, j;
   unsigned int *ip;
   TYPE MyNaN;
   #ifdef TCPLX
      const int m=M+M, ldC=ldc+ldc;
   #else
      const int m=M, ldC=ldc;
   #endif
#if 0
   ip = (unsigned int*) &MyNaN;
   ip[0] = 1;
   ip[1] = 2047 << (31-11);
#else
   MyNaN = 0.0/0.0;
#endif
   for (j=0; j < N; j++, C += ldC)
   {
      for (i=0; i < m; i++)
         C[i] = MyNaN;
   }
}
#endif

static int IK0=0, IKN=0, incIK=1, IIK=0;

#if defined(TRUST_C)
   #define trusted_gemm(TA, TB, m, n, k, al, A, lda, B, ldb, be, C, ldc) \
      Mjoin(Mjoin(cblas_,PRE),gemm) \
         (CblasColMajor, TA, TB, m, n, k, al, A, lda, B, ldb, be, C, ldc)
#elif defined(TRUST_REF)
   #define trusted_gemm(TA, TB, m, n, k, al, A, lda, B, ldb, be, C, ldc) \
      Mjoin(PATL,refgemm)(TA, TB, m, n, k, al, A, lda, B, ldb, be, C, ldc)
#elif defined(ATL_NOAFFINITY) || defined(ATL_AFFINITY)
   #define trusted_gemm(TA, TB, m, n, k, al, A, lda, B, ldb, be, C, ldc) \
      Mjoin(PATL,tgemm)(TA, TB, m, n, k, al, A, lda, B, ldb, be, C, ldc)
#elif defined(TRUST_SMALL)
   #define trusted_gemm(TA, TB, m, n, k, al, A, lda, B, ldb, be, C, ldc) \
      Mjoin(PATL,small_mm)(TA, TB, m, n, k, al, A, lda, B, ldb, be, C, ldc)
#elif defined(TRUST_BIGNORK)
   #define trusted_gemm(TA, TB, m, n, k, al, A, lda, B, ldb, be, C, ldc) \
      Mjoin(PATL,bignork_mm)(TA, TB, m, n, k, al, A, lda, B, ldb, be, C, ldc)
#elif defined(TRUST_BIG)
   #define trusted_gemm(TA, TB, m, n, k, al, A, lda, B, ldb, be, C, ldc) \
      Mjoin(PATL,big_mm)(TA, TB, m, n, k, al, A, lda, B, ldb, be, C, ldc)
#elif defined(TRUST_BPP)
   #define trusted_gemm(TA, TB, m, n, k, al, A, lda, B, ldb, be, C, ldc) \
      Mjoin(PATL,mmBPP)(TA, TB, m, n, k, al, A, lda, B, ldb, be, C, ldc)
#elif defined(TRUST_JIT)
   #define trusted_gemm(TA, TB, m, n, k, al, A, lda, B, ldb, be, C, ldc) \
      Mjoin(PATL,mmJITcp)(TA, TB, m, n, k, al, A, lda, B, ldb, be, C, ldc)
#elif (defined(ATL_USEPTHREADS) && !defined(TEST_F77))
   #define trusted_gemm(TA, TB, m, n, k, al, A, lda, B, ldb, be, C, ldc) \
      Mjoin(PATL,gemm)(TA, TB, m, n, k, al, A, lda, B, ldb, be, C, ldc)
#else
   #define trusted_gemm(TA, TB, m, n, k, al, A, lda, B, ldb, be, C, ldc) \
      Mjoin(PATL,f77gemm)(TA, TB, m, n, k, al, A, lda, B, ldb, be, C, ldc)
#endif

#ifdef TEST_GPMM
   #define test_gemm(TA, TB, m, n, k, al, A, lda, B, ldb, be, C, ldc) \
      Mjoin(PATL,gpmm)(PackGen, TA, PackGen, TB, PackGen, m, n, k, al, \
                       A, 0, 0, lda, B, 0, 0, ldb, be, C, 0, 0, ldc)
#elif defined(TEST_AMMREC)
   #define test_gemm(TA, TB, m, n, k, al, A, lda, B, ldb, be, C, ldc) \
      Mjoin(PATL,ammmREC)(TA, TB, m, n, k, al, A, lda, B, ldb, be, C, ldc)
#elif defined(TEST_RKKM)
   #define test_gemm(TA, TB, m, n, k, al, A, lda, B, ldb, be, C, ldc) \
      Mjoin(PATL,ammm_rkKm)(TA, TB, m, n, k, al, A, lda, B, ldb, be, C, ldc)
#elif defined(TEST_AMMNKM)
   #define test_gemm(TA, TB, m, n, k, al, A, lda, B, ldb, be, C, ldc) \
      Mjoin(PATL,ammmNKM)(TA, TB, m, n, k, al, A, lda, B, ldb, be, C, ldc)
#elif defined(TEST_AMM2)
   #define test_gemm(TA, TB, m, n, k, al, A, lda, B, ldb, be, C, ldc) \
      TEST_MM(TA, TB, m, n, k, al, A, lda, B, ldb, be, C, ldc)
#elif defined(TEST_AMMM)
   #define test_gemm(TA, TB, m, n, k, al, A, lda, B, ldb, be, C, ldc) \
      Mjoin(PATL,ammmNMK)(IIK,TA, TB, m, n, k, al, A, lda, B, ldb, be, C, ldc)
#elif defined(ATL_NOAFFINITY) || defined(ATL_AFFINITY)
   #define test_gemm(TA, TB, m, n, k, al, A, lda, B, ldb, be, C, ldc) \
      Mjoin(PATL,tgemm)(TA, TB, m, n, k, al, A, lda, B, ldb, be, C, ldc)
#elif defined(TEST_F77)
   #define test_gemm(TA, TB, m, n, k, al, A, lda, B, ldb, be, C, ldc) \
      Mjoin(PATL,f77gemm)(TA, TB, m, n, k, al, A, lda, B, ldb, be, C, ldc)
#elif defined(TEST_BIG)
   #define test_gemm(TA, TB, m, n, k, al, A, lda, B, ldb, be, C, ldc) \
      Mjoin(PATL,big_mm)(TA, TB, m, n, k, al, A, lda, B, ldb, be, C, ldc)
#elif defined(TEST_SMALLK)
   #define test_gemm(TA, TB, m, n, k, al, A, lda, B, ldb, be, C, ldc) \
      Mjoin(PATL,smallK_mm)(TA, TB, m, n, k, al, A, lda, B, ldb, be, C, ldc)
#elif defined(TEST_SMALL)
   #define test_gemm(TA, TB, m, n, k, al, A, lda, B, ldb, be, C, ldc) \
      Mjoin(PATL,small_mm)(TA, TB, m, n, k, al, A, lda, B, ldb, be, C, ldc)
#elif defined(TEST_BPP)
   #define test_gemm(TA, TB, m, n, k, al, A, lda, B, ldb, be, C, ldc) \
      Mjoin(PATL,mmBPP)(TA, TB, m, n, k, al, A, lda, B, ldb, be, C, ldc)
#elif defined(TEST_JIT)
   #define test_gemm(TA, TB, m, n, k, al, A, lda, B, ldb, be, C, ldc) \
      Mjoin(PATL,mmJITcp)(TA, TB, m, n, k, al, A, lda, B, ldb, be, C, ldc)
#elif defined(TEST_RANKK)
   #define test_gemm(TA, TB, m, n, k, al, A, lda, B, ldb, be, C, ldc) \
   { \
      if (k <= ATL_vMAX_KB) \
      { \
         ATL_assert(!Mjoin(PATL,vrankK)(TA, TB, m, n, k, al, A, lda, B, ldb, \
                                        be, C, ldc));\
      } \
      else \
      { \
         fprintf(stderr, "maxK exceeded at %d\n", k); \
         exit(k); \
      } \
   }
#elif defined(TEST_GEMM_RK)
   #define test_gemm(TA, TB, m, n, k, al, A, lda, B, ldb, be, C, ldc) \
      ATL_assert(!Mjoin(PATL,gemm_rK)(TA, TB, m, n, k, al, A, lda, B, ldb, be, C, ldc))
#elif defined(TEST_ALIASED)
   #define test_gemm(TA, TB, m, n, k, al, A, lda, B, ldb, be, C, ldc) \
      Mjoin(PATL,aliased_gemm)(TA, TB, m, n, k, al, A, lda, B, ldb, be, C, ldc)
#elif defined(ATL_USEPTHREADS)
   #define test_gemm(TA, TB, m, n, k, al, A, lda, B, ldb, be, C, ldc) \
      Mjoin(PATL,tgemm)(TA, TB, m, n, k, al, A, lda, B, ldb, be, C, ldc)
#else
   #define test_gemm(TA, TB, m, n, k, al, A, lda, B, ldb, be, C, ldc) \
      Mjoin(PATL,gemm)(TA, TB, m, n, k, al, A, lda, B, ldb, be, C, ldc)
#endif

int mmcase(int TEST, int CACHESIZE, char TA, char TB, int M, int N, int K,
	   SCALAR alpha, TYPE *A, size_t lda, TYPE *B, size_t ldb, SCALAR beta,
	   TYPE *C, size_t ldc, TYPE *D, size_t ldd)
{
   char *pc;
#ifdef TREAL
   char *form="%4d   %c   %c %4d %4d %4d  %5.1f  %5.1f  %6.2f %5.1f %5.2f   %3s\n";
   #define MALPH alpha
   #define MBETA beta
#else
   #define MALPH *alpha, alpha[1]
   #define MBETA *beta, beta[1]
   char *form="%4d   %c   %c %4d %4d %4d  %5.1f %5.1f  %5.1f %5.1f  %6.2f %6.1f %4.2f   %3s\n";
#endif
   ATL_BV_t *errBV=NULL;
   int ii, jj, i, j=0, PASSED, nerrs, Na, Nb, ibad=(-1), jbad=(-1);
   double t0, t1, t2, t3, mflop;
   TYPE maxval, f1, ferr;
   static TYPE feps=0.0;
   static int itst=1;
   /*int *L2, nL2=(1.3*L2SIZE)/sizeof(int);*/
   enum ATLAS_TRANS TAc, TBc;
   double l2ret;

   if (!TEST) D = C;
   /*if (nL2) L2 = malloc(nL2*sizeof(int));*/
   #if !ATL_LINEFLUSH
      l2ret = ATL_flushcache( CACHESIZE );
   #endif
   if (TA == 'n' || TA == 'N') 
   {
      matgen(M, K, A, lda, K*1112);
      TAc = AtlasNoTrans;
      Na = K;
   }
   else
   {
      matgen(K, M, A, lda, K*1112);
      if (TA == 'c' || TA == 'C') TAc = AtlasConjTrans;
      else TAc = AtlasTrans;
      Na = M;
   }
   if (TB == 'n' || TB == 'N')
   {
      matgen(K, N, B, ldb, N*2238);
      TBc = AtlasNoTrans;
      Nb = N;
   }
   else
   {
      matgen(N, K, B, ldb, N*2238);
      if (TB == 'c' || TB == 'C') TBc = AtlasConjTrans;
      else TBc = AtlasTrans;
      Nb = K;
   }
#ifdef ATL_NANC
   matnan(M, N, C, ldc, M*N);
#else
   matgen(M, N, C, ldc, M*N);
#endif

#ifdef DEBUG
   printmat("A0", M, K, A, lda);
   printmat("B0", K, N, B, ldb);
   printmat("C0", M, N, C, ldc);
#endif

   /*
     if (L2)
     {
     for (i=0; i != nL2; i++) L2[i] = 0.0; 
     for (i=0; i != nL2; i++) j += L2[i];
     }*/
   
   if (CACHESIZE > 0)
   {
      /* invalidate L2 cache */
      #if !ATL_LINEFLUSH
         l2ret = ATL_flushcache( -1 );
      #else
         ATL_flushCacheByAddr(ldc*N, C);
         ATL_flushCacheByAddr(ldb*Nb, B);
         ATL_flushCacheByAddr(lda*Na, A);
      #endif
   }

   t0 = time00();
   trusted_gemm(TAc, TBc, M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
   t1 = time00() - t0;
   if (t1 <= 0.0) mflop = t1 = 0.0;
   else   /* flop rates actually 8MNK+12MN & 2MNK + 2MN, resp */
      #ifdef TCPLX
         mflop = ( ((8.0*M)*N)*K ) / (t1*1000000.0);
      #else
         mflop = ( ((2.0*M)*N)*K ) / (t1*1000000.0);
      #endif
   printf(form, itst, TA, TB, M, N, K, MALPH, MBETA, t1, mflop, 1.0, "---");

#ifdef DEBUG
   printmat("C", M, N, C, ldc);
#endif

#ifndef TIMEONLY
   #ifdef ATL_NANC
      matnan(M, N, D, ldd, M*N);
   #else 
      matgen(M, N, D, ldd, M*N);
   #endif

   if (CACHESIZE > 0)
   {
      /* invalidate L2 cache */
      #if !ATL_LINEFLUSH
         l2ret = ATL_flushcache( -1 );
      #else
         ATL_flushCacheByAddr(ldc*N, D);
         ATL_flushCacheByAddr(ldb*Nb, B);
         ATL_flushCacheByAddr(lda*Na, A);
      #endif
   }
   t0 = time00();
   test_gemm(TAc, TBc, M, N, K, alpha, A, lda, B, ldb, beta, D, ldd);
   
   t2 = time00() - t0;
   if (t2 <= 0.0) t2 = mflop = 0.0;
   else 
      #ifdef TCPLX
         mflop = ( ((8.0*M)*N)*K ) / (t2*1000000.0);
      #else
         mflop = ( ((2.0*M)*N)*K ) / (t2*1000000.0);
      #endif
#ifdef DEBUG
   printmat("D", M, N, D, ldd);
#endif
   if (TEST)
   {
      if (feps == 0.0)
      {
#if 0
         f1 = feps = 0.5;
         do
         {
            feps = f1;
            f1 *= 0.5;
            maxval = 1.0 + f1;
         }
         while (maxval != 1.0);
         printf("feps=%e\n",feps);
#else
         feps = EPS;
#endif
#ifdef DEBUG
         printf("feps=%e\n",feps);
#endif
      }
#ifdef TREAL
      ferr = 2.0 * (Mabs(alpha) * 2.0*K*feps + Mabs(beta) * feps) + feps;
#else
      f1 = Mabs(*alpha) + Mabs(alpha[1]);
      maxval = Mabs(*beta) + Mabs(beta[1]);
      ferr = 2.0 * (f1*8.0*K*feps + maxval*feps) + feps;
#endif
      PASSED = 1;
      maxval = 0.0;
      pc = "YES";
      nerrs = ii = jj = 0;
      for (j=0; j != N; j++)
      {
         for (i=0; i != M SHIFT; i++)
         {
            int eltbad=0;
            #ifdef ATL_NANC
               if (D[i] != D[i])
               {
                  eltbad=1;
                  nerrs++;
                  PASSED = 0;
                  printf("NaN in test_gemm at C(%d,%d)\n", i, j);
               }
               if (C[i] != C[i])
               {
                  eltbad=1;
                  nerrs++;
                  PASSED = 0;
                  printf("NaN in trusted_gemm at C(%d,%d)\n", i, j);
               }
            #endif
            f1 = D[i] - C[i];
            if (f1 < 0.0) f1 = -f1;
            if (f1 > ferr)
            {
               eltbad=1;
               if (ibad == -1)
                  ibad = i+1;
               if (jbad == -1)
                  jbad = j+1;
               nerrs++;
               PASSED = 0;
               pc = "NO!";
               if (f1 > maxval)
               {
                  maxval=f1;
                  ii = i+1;
                  jj = j+1;
               }
            }
            else if (D[i] != D[i])
            {   
               eltbad=1;
               nerrs++;
               PASSED = 0;
               pc = "NaN";
               maxval = D[i];
            }
            if (eltbad && N < 80 && (M SHIFT) < 80) 
            {
               if (!errBV)
                  errBV = ATL_NewBV((M SHIFT)*N);
               ATL_SetBitBV(errBV, i*N+j);
            }
         }
         D += ldd SHIFT;
         C += ldc SHIFT;
      }
      if (maxval != 0.0)
         fprintf(stderr, "ERROR: nerr=%d, first(%d,%d), maxval(%d,%d)=%e\n", 
                 nerrs, ibad, jbad, ii,jj, maxval);
   }
   else pc = "---";
   if (t1 == t2) t3 = 1.0;
   else if (t2 != 0.0) t3 = t1/t2;
   else t3 = 0.0;
   #ifdef ATL_RKXOVER
      if (K <= ATL_vMAX_KB)
      {
         if (SCALAR_IS_ZERO(beta))
            speedup_rk_b0[K] = (t3 >= 1.0) ? t3*100 : 0;
         else
            speedup_rk[K] = (t3 >= 1.0) ? t3*100 : 0;
      }
   #endif
   #ifdef TEST_AMMM
   printf(form, IIK, TA, TB, M, N, K, MALPH, MBETA, t2, mflop, t3, pc);
   itst++;
   #else
   printf(form, itst++, TA, TB, M, N, K, MALPH, MBETA, t2, mflop, t3, pc);
   #endif
#else
   itst++;
   PASSED = 1;
#endif
   /*free(L2);*/
   #if !ATL_LINEFLUSH
      l2ret = ATL_flushcache( 0 );
   #endif
   if (errBV)
   {
      ATL_print2dBV(M SHIFT, N, errBV);
      ATL_FreeBV(errBV);
   }
   return(PASSED);
}

int mmcase0(int MFLOP, size_t CACHESIZE, char TA, char TB, int M, int N, int K,
	    SCALAR alpha, size_t lda, size_t ldb, SCALAR beta, size_t ldc)
{
   char *pc;
#ifdef TREAL
   char *form="%4d   %c   %c %4d %4d %4d  %5.1f  %5.1f  %6.2f %5.1f %5.2f   %3s\n";
   #define MALPH alpha
   #define MBETA beta
   TYPE betinv, bet=beta;
#else
   #define MALPH *alpha, alpha[1]
   #define MBETA *beta, beta[1]
   char *form="%4d   %c   %c %4d %4d %4d  %5.1f %5.1f  %5.1f %5.1f  %6.2f %6.1f %4.2f   %3s\n";
   TYPE betinv[2], *bet=beta;
#endif
   #ifdef ATL_USETHREADS
      const size_t cs=ATL_NTHREADS *
                      ATL_MulBySize(ATL_DivBySize(CACHESIZE+ATL_sizeof-1));
   #else
      const size_t cs=ATL_MulBySize(ATL_DivBySize(CACHESIZE+ATL_sizeof-1));
   #endif
   const size_t setsz = M*N + M*K + N*K;
   size_t nset; 
   size_t i, incA, incB, incC, inc, k;
   TYPE *c, *C, *a, *A, *b, *B, *st;
   int nreps, ii, jj, j=0, PASSED, nerrs;
   double t0, t1, t2, t3, mflop, mf, mops;
   TYPE maxval, f1, ferr;
   static TYPE feps=0.0;
   static int itst=1;
   enum ATLAS_TRANS TAc, TBc;
   void *vp;
   #ifdef TCPLX
      if (*beta == 0.0 && beta[1] == 0.0) betinv[0] = betinv[1] = 0.0;
      else if (beta[1] == 0.0) { betinv[0] = 1 / *beta;  betinv[1] = 0.0; }
      else
      {
         t0 = *beta;
         t1 = beta[1];
         if (Mabs(t1) <= Mabs(t0))
         {
            t2 = t1 / t0;
            betinv[0] = t0 = 1.0 / (t0 + t1*t2);
            betinv[1] = -t0 * t2;
         }
         else
         {
            t2 = t0 / t1;
            betinv[1] = t0 = -1.0 / (t1 + t0*t2);
            betinv[0] = -t2 * t0;
         }
      }
      mops = ( ((8.0*M)*N)*K ) / 1000000.0;
   #else
      if (beta != 0.0) betinv = 1.0 / beta;
      else betinv = beta;
      mops = ( ((2.0*M)*N)*K ) / 1000000.0;
   #endif
   nreps = MFLOP / mops;
   if (nreps < 1) nreps = 1;
   if (TA == 'n' || TA == 'N') 
   {
      TAc = AtlasNoTrans;
      incA = lda * K;
   }
   else
   {
      if (TA == 'c' || TA == 'C') TAc = AtlasConjTrans;
      else TAc = AtlasTrans;
      incA = lda * M;
   }
   if (TB == 'n' || TB == 'N')
   {
      incB = ldb * N;
      TBc = AtlasNoTrans;
   }
   else
   {
      incB = ldb * K;
      if (TB == 'c' || TB == 'C') TBc = AtlasConjTrans;
      else TBc = AtlasTrans;
   }
   incC = ldc*N;
   inc = incA + incB + incC;   /* amount actually allocated */
   nset = (cs+setsz-1)/setsz;
   if (nset < 2)
      nset = 2;
   vp = malloc(ATL_MulBySize(nset*inc)+ATL_Cachelen);
   ATL_assert(vp);
   #if defined(ATL_USEPTHREADS) && !defined(ATL_NONUMATOUCH)
      ATL_NumaTouchSpread(ATL_MulBySize(nset*inc)+ATL_Cachelen, vp);
   #endif
   C = c = ATL_AlignPtr(vp);
   a = A = C + incC;
   b = B = A + incA;
   st = C + nset*inc;
   #ifdef ATL_NANC
      matnan(inc, nset, C, inc, M*N);
   #else 
      matgen(inc, nset, C, inc, M*N);
   #endif

#ifdef DEBUG
   printmat("A0", M, K, A, lda);
   printmat("B0", K, N, B, ldb);
   printmat("C0", M, N, C, ldc);
#endif

   t0 = time00();
   for (k=nreps; k; k--)
   {
      trusted_gemm(TAc, TBc, M, N, K, alpha, a, lda, b, ldb, bet, c, ldc);
      c += inc; a += inc; b += inc;
      if (c == st) 
      { 
         c = C; a = A; b = B; 
         if (bet == beta) bet = betinv;
         else bet = beta;
      }
   }
   t1 = time00() - t0;
   t1 /= nreps;
   if (t1 <= 0.0) mflop = t1 = 0.0;
   else   /* flop rates actually 8MNK+12MN & 2MNK + 2MN, resp */
      mflop = mops / t1;
   printf(form, itst, TA, TB, M, N, K, MALPH, MBETA, t1, mflop, 1.0, "---");

#ifdef DEBUG
   printmat("C", M, N, C, ldc);
#endif

   matgen(inc, nset, C, inc, M*N);
   t0 = time00();
   for (k=nreps; k; k--)
   {
      test_gemm(TAc, TBc, M, N, K, alpha, a, lda, b, ldb, bet, c, ldc);
      c += inc; a += inc; b += inc;
      if (c == st) 
      { 
         c = C; a = A; b = B; 
         if (bet == beta) bet = betinv;
         else bet = beta;
      }
   }
   
   t2 = time00() - t0;
   t2 /= nreps;
   if (t2 <= 0.0) t2 = mflop = 0.0;
   else mflop = mops / t2;

   pc = "---";
   if (t1 == t2) t3 = 1.0;
   else if (t2 != 0.0) t3 = t1/t2;
   else t3 = 0.0;
   #ifdef ATL_RKXOVER
      if (K <= ATL_vMAX_KB)
      {
         if (SCALAR_IS_ZERO(beta))
            speedup_rk_b0[K] = (t3 >= 1.0) ? t3*100 : 0;
         else
            speedup_rk[K] = (t3 >= 1.0) ? t3*100 : 0;
      }
   #endif
   #ifdef TEST_AMMM
   printf(form, IIK, TA, TB, M, N, K, MALPH, MBETA, t2, mflop, t3, pc);
   #else
   printf(form, itst-4, TA, TB, M, N, K, MALPH, MBETA, t2, mflop, t3, pc);
   #endif
   itst++;
   free(vp);
   return(1);
}

void PrintUsage(char *nam)
{
   fprintf(stderr, "USAGE: %s -Side <nsides> L/R -Uplo <nuplo> L/U -Atrans <ntrans> n/t/c -Btrans <ntrans> n/t/c -Diag <ndiags> N/U -M <m1> <mN> <minc> -N <n1> <nN> <ninc> <k1> <kN> <kinc> -n <n> -m <m> -k <k> -a <nalphas> <alpha1> ... <alphaN> -b <nbetas> <beta1> ... <betaN> -Test <0/1> -F <mflops> -i <IKERN> -I <IK1> <IKN> <incIK> -C <cachesize> -W <warmup> \n", nam);
   exit(-1);
}

void GetFlags(int nargs, char *args[], int *TEST, int *nside,
              enum ATLAS_SIDE **Side, int *nuplo, enum ATLAS_UPLO **Uplo, 
              int *nta, enum ATLAS_TRANS **TransA, 
              int *ntb, enum ATLAS_TRANS **TransB, int *ndiag,
              enum ATLAS_DIAG **Diag, int *M0, int *MN, int *Minc, 
              int *N0, int *NN, int *Ninc, int *K0, int *KN, int *Kinc,
              int *nalphas, TYPE **alphas, int *nbetas, TYPE **betas,
              int *LDA_IS_M, int *MFLOP, int *CACHESIZE, int *nrep,
              int *WARM)

{
   char ch;
   int i, j;
   char *outfile=NULL;
/*
 * Set up defaults
 */
   *nrep = 1;
   *TEST = 1;
   *M0 = *N0 = *K0 = -1;
   *nuplo = *nta = *ntb = *nside = *ndiag = *nalphas = *nbetas = -1;
   *MFLOP = *LDA_IS_M = 0;
   *WARM = 1;
#ifdef L2SIZE
   *CACHESIZE = L2SIZE;               /* Size of largest cache to flush */
#else
   *CACHESIZE = 4*1024*1024;
#endif

   for (i=1; i < nargs; i++)
   {
      switch(args[i][1])
      {
      case 'W':
         *WARM = atoi(args[++i]);
         break;
      case '#':
         *nrep = atoi(args[++i]);
         break;
      case 'F':
         *MFLOP = atoi(args[++i]);
         break;
      #ifdef TEST_AMMM
      case 'i':
         IK0 = IKN = atoi(args[++i]);
         break;
      case 'I':
         IK0 = atoi(args[++i]);
         IKN = atoi(args[++i]);
         incIK = atoi(args[++i]);
         break;
      #endif
      case 'C':
            if( args[i+1] == NULL ) PrintUsage( args[0] );
	    *CACHESIZE = 1024*atoi(args[++i]);
            break;
      case 'S':
         *nside = atoi(args[++i]);
         *Side = malloc(*nside * sizeof(int));
         assert(*Side);
         for (j=0; j != *nside; j++)
         {
            ch = *args[++i];
            if (ch == 'r' || ch == 'R') (*Side)[j] = AtlasRight;
            else if (ch == 'l' || ch == 'L') (*Side)[j] = AtlasLeft;
            else PrintUsage(args[0]);
         }
         break;
      case 'U':
         *nuplo = atoi(args[++i]);
         *Uplo = malloc(*nuplo * sizeof(int));
         assert(*Uplo);
         for (j=0; j != *nuplo; j++)
         {
            ch = *args[++i];
            if (ch == 'u' || ch == 'U') (*Uplo)[j] = AtlasUpper;
            else if (ch == 'l' || ch == 'L') (*Uplo)[j] = AtlasLower;
            else PrintUsage(args[0]);
         }
         break;
      case 'D':
         *ndiag = atoi(args[++i]);
         *Diag = malloc(*ndiag * sizeof(int));
         assert(*Diag);
         for (j=0; j != *ndiag; j++)
         {
            ch = *args[++i];
            if (ch == 'u' || ch == 'U') (*Diag)[j] = AtlasUnit;
            else if (ch == 'n' || ch == 'N') (*Diag)[j] = AtlasNonUnit;
            else PrintUsage(args[0]);
         }
         break;
      case 'A':
         *nta   = atoi(args[++i]);
         *TransA = malloc(*nta * sizeof(int));
         assert(*TransA);
         for (j=0; j != *nta; j++)
         {
            ch = *args[++i];
            if (ch == 'n' || ch == 'N') (*TransA)[j] = AtlasNoTrans;
            else if (ch == 't' || ch == 'T') (*TransA)[j] = AtlasTrans;
            else if (ch == 'c' || ch == 'C') (*TransA)[j] = AtlasConjTrans;
            else PrintUsage(args[0]);
         }
         break;
      case 'B':
         *ntb   = atoi(args[++i]);
         *TransB = malloc(*ntb * sizeof(int));
         assert(*TransB);
         for (j=0; j != *ntb; j++)
         {
            ch = *args[++i];
            if (ch == 'n' || ch == 'N') (*TransB)[j] = AtlasNoTrans;
            else if (ch == 't' || ch == 'T') (*TransB)[j] = AtlasTrans;
            else if (ch == 'c' || ch == 'C') (*TransB)[j] = AtlasConjTrans;
            else PrintUsage(args[0]);
         }
         break;
      case 'M':
         *M0 = atoi(args[++i]);
         *MN = atoi(args[++i]);
         *Minc = atoi(args[++i]);
         break;
      case 'N':
         *N0 = atoi(args[++i]);
         *NN = atoi(args[++i]);
         *Ninc = atoi(args[++i]);
         break;
      case 'K':
         *K0 = atoi(args[++i]);
         *KN = atoi(args[++i]);
         *Kinc = atoi(args[++i]);
         break;
      case 'T':
         *TEST = atoi(args[++i]);
         break;
      case 'm':
         *M0 = *MN = *Minc = atoi(args[++i]);
         break;
      case 'n':
         *N0 = *NN = *Ninc = atoi(args[++i]);
         break;
      case 'k':
         *K0 = *KN = *Kinc = atoi(args[++i]);
         break;
      case 'a':
         *nalphas = atoi(args[++i]);
         *alphas = malloc(ATL_MulBySize(*nalphas));
         assert(*alphas);
         for (j=0; j < *nalphas SHIFT; j++) (*alphas)[j] = atof(args[++i]);
         break;
      case 'b':
         *nbetas  = atoi(args[++i]);
         *betas  = malloc(ATL_MulBySize(*nbetas ));
         assert(*betas );
         for (j=0; j < *nbetas SHIFT; j++) (*betas)[j] = atof(args[++i]);
         break;
      case 'd':
         *LDA_IS_M  = atoi(args[++i]);
         break;
      #ifdef ATL_RKXOVER
      case 'o':
         outfile = args[++i];
         break;
      #endif
      default:
         PrintUsage(args[0]);
         break;
      }
   }
/*
 * Finish setting up defaults if the user has not selected
 */
   if (*N0 == -1)
   {
      #ifdef ATL_RKXOVER
         #ifdef SCPLX
            *N0 = *NN = *Ninc = 3000;
         #elif defined(DCPLX)
            *N0 = *NN = *Ninc = 2000;
         #elif defined(SREAL)
            *N0 = *NN = *Ninc = 4000;
         #else
            *N0 = *NN = *Ninc = 3000;
         #endif
      #else
         *N0 = 100;
         *NN = 1000;
         *Ninc = 100;
      #endif
   }
#ifdef ATL_RKXOVER
   *K0 = 1;
   *KN = ATL_vMAX_KB;
   *Kinc = 1;
   if (!outfile)
      outfile = Mstr(Mjoin(Mjoin(atlas_,PRE),rkXover.h));
   fprk = fopen(outfile, "w");
   assert(fprk);
   *nbetas  = 2;
   *betas  = malloc(ATL_MulBySize(1));
   assert(*betas );
   #ifdef TREAL
      **betas  = 1.0;
      (*betas)[1] = 0.0;
   #else
      **betas  = 1.0;
      (*betas)[2] = (*betas)[3] = (*betas)[1] = 0.0;
   #endif
   *TEST = 0;
#endif
   if (*nside == -1)
   {
      *nside = 1;
      *Side = malloc(sizeof(int));
      assert(*Side);
      **Side = AtlasLeft;
   }
   if (*nuplo == -1)
   {
      *nuplo = 1;
      *Uplo = malloc(sizeof(int));
      assert(*Uplo);
      **Uplo = AtlasLower;
   }
   if (*nta == -1)
   {
      *nta = 1;
      *TransA = malloc(sizeof(int));
      assert(*TransA);
      **TransA = AtlasNoTrans;
   }
   if (*ntb == -1)
   {
      *ntb = 1;
      *TransB = malloc(sizeof(int));
      assert(*TransB);
      **TransB = AtlasNoTrans;
   }
   if (*ndiag == -1)
   {
      *ndiag = 1;
      *Diag = malloc(sizeof(int));
      assert(*Diag);
      **Diag = AtlasNonUnit;
   }
   if (*nalphas == -1)
   {
      *nalphas = 1;
      *alphas = malloc(ATL_MulBySize(1));
      assert(*alphas);
      #ifdef TREAL
         **alphas = 1.0;
      #else
         **alphas = 1.0;
         (*alphas)[1] = 0.0;
      #endif
   }
   if (*nbetas  == -1)
   {
      *nbetas  = 1;
      *betas  = malloc(ATL_MulBySize(1));
      assert(*betas );
      #ifdef TREAL
         **betas  = 1.0;
      #else
         **betas  = 1.0;
         (*betas)[1] = 0.0;
      #endif
      #ifdef ATL_NANC
         **betas = 0.0;
      #endif
   }
}
int ___main(){return(-1);}   /* this nonsense helps */
int __main(){return(-1);}    /* when you link with certain */
int MAIN__(){return(-1);}    /* fortran compilers */
int _MAIN_(){return(-1);}

int main(int nargs, char *args[])
/*
 *  tst <tst> <# TA> <TA's> <# TB's> <TB's> <M0> <MN> <incM> <N0> <NN> <incN>
 *      <K0> <KN> <incK> <# alphas> <alphas> <# betas> <betas>
 *          
 */
{
   int M0, MN, incM, N0, NN, incN, K0, KN, incK, lda, ldb, ldc, MFLOP; 
   int i, k, m, n, im, in, ik, ita, itb, ia, ib, nTA, nTB, nalph, nbeta;
   int itst=0, ipass=0, TEST, LDA_IS_M, MSAME=0, KSAME=0, r;
   int ndiag, nuplo, nside, nrep;
   TYPE *alph, *beta, *A, *B, *C, *D=NULL;
   #ifdef TREAL
      TYPE bet1 = 1.0, alp1 = -1.0;
   #else
      TYPE bet1[2] = {1.0, 0.0}, alp1[2] = {-1.0, 0.0};
   #endif
   char TA, TB;
   enum ATLAS_SIDE *Side; 
   enum ATLAS_UPLO *Uplo;
   enum ATLAS_TRANS *TransA, *TransB, TAc, TBc;
   enum ATLAS_DIAG *Diag;
   int CACHESIZE, WARM;

   GetFlags(nargs, args, &TEST, &nside, &Side, &nuplo, &Uplo, 
            &nTA, &TransA, &nTB, &TransB, &ndiag, &Diag, 
            &M0, &MN, &incM, &N0, &NN, &incN, &K0, &KN, &incK,
            &nalph, &alph, &nbeta, &beta, &LDA_IS_M, &MFLOP,&CACHESIZE, &nrep,
            &WARM);

   if (M0 == -1)
   {
      MSAME = 1;
      M0 = MN = incM = NN;
   }
   if (K0 == -1)
   {
      KSAME = 1;
      K0 = KN = incK = NN;
   }

   if (!MFLOP)
   {
      A = malloc(MN*KN*ATL_sizeof);
      B = malloc(NN*KN*ATL_sizeof);
      C = malloc(MN*NN*ATL_sizeof);
      if (TEST) D = malloc(MN*NN*ATL_sizeof);
      else D = NULL;
      if (!A || !B || !C || (TEST && !D))
      {
         fprintf(stderr, "Not enough memory to run tests!!\n");
         exit(-1);
      }
      #if defined(ATL_USEPTHREADS) && !defined(ATL_NONUMATOUCH)
         ATL_NumaTouchSpread(MN*KN*ATL_sizeof, A);
         ATL_NumaTouchSpread(NN*KN*ATL_sizeof, B);
         ATL_NumaTouchSpread(MN*NN*ATL_sizeof, C);
         ATL_NumaTouchSpread(MN*NN*ATL_sizeof, D);
      #endif
   }
/*
 * Page the code in from disk, so first timing doesn't blow
 */
   if (MFLOP)
   {
      #ifdef ATL_RKXOVER
         k = Mmin(100, KN);
      #else
         k = 100;
      #endif
      if (WARM)
      {
         mmcase0(10, 1, 'n', 'n', 100, 100, k, alp1, 100, 100, bet1, 100);
         mmcase0(10, 1, 'n', 't', 100, 100, k, alp1, 100, 100, bet1, 100);
         mmcase0(10, 1, 't', 'n', 100, 100, k, alp1, 100, 100, bet1, 100);
         mmcase0(10, 1, 't', 't', 100, 100, k, alp1, 100, 100, bet1, 100);
      }
   }
   else
   {
      m = Mmin(100, MN);
      k = Mmin(100, KN);
      n = Mmin(100, NN);
      matgen(m, k, A, m, m*k);
      matgen(k, n, B, k, n*k);
      matgen(m, n, C, m, m*n);
      TA = TB = 'N';
      TAc = TBc = AtlasNoTrans;
      if (WARM)
      {
         trusted_gemm(TAc, TBc, m, n, k, alp1, A, m, B, k, bet1, C, m);
         test_gemm(TAc, TBc, m, n, k, alp1, A, m, B, k, bet1, C, m);
      }
   }

#ifdef TREAL
   printf("\nTEST  TA  TB    M    N    K  alpha   beta    Time  Mflop  SpUp  PASS\n");
   printf("====  ==  ==  ===  ===  ===  =====  =====  ======  =====  ====  ====\n\n");
#else
   printf("\nTEST  TA  TB    M    N    K  ralph ialph  rbeta ibeta    Time  Mflop  SpUp  PASS\n");
   printf("====  ==  ==  ===  ===  ===  ===== =====  ===== =====  ======  =====  ====  ====\n\n");
#endif
   for (im=M0; im <= MN; im += incM)
   {
      for (n=N0; n <= NN; n += incN)
      {
         if (MSAME) m = n;
         else m = im;
         for (ik=K0; ik <= KN; ik += incK)
         {
            if (KSAME) k = n;
            else k = ik;
            for (ita=0; ita != nTA; ita++)
            {
               if (TransA[ita] == AtlasNoTrans) TA = 'N';
               else if (TransA[ita] == AtlasTrans) TA = 'T';
               else if (TransA[ita] == AtlasConjTrans) TA = 'C';

               for (itb=0; itb != nTB; itb++)
               {
                  if (TransB[itb] == AtlasNoTrans) TB = 'N';
                  else if (TransB[itb] == AtlasTrans) TB = 'T';
                  else if (TransB[itb] == AtlasConjTrans) TB = 'C';
                  for (ia=0; ia != nalph; ia++)
                  {
                     for (ib=0; ib != nbeta; ib++)
                     {
                        if (LDA_IS_M)
                        {
                           if (TA == 'n' || TA == 'N') lda = m;
                           else lda = k;
                           if (TB == 'n' || TB == 'N') ldb = k;
                           else ldb = n;
                           ldc = m;
                        }
                        else
                        {
                           if (TA == 'n' || TA == 'N') lda = MN;
                           else lda = KN;
                           if (TB == 'n' || TB == 'N') ldb = KN;
                           else ldb = NN;
                           ldc = MN;
                        }
                        #ifdef TEST_AMMM
                        for (IIK=IK0; IIK <= IKN; IIK += incIK)
                        {
                        #endif
                        itst++;
                        for (r=0; r < nrep; r++)
                        {
                           if (MFLOP)
                           {
                              ipass++;
#ifdef TREAL
                                 mmcase0(MFLOP, CACHESIZE, TA, TB, m, n, k,
				         alph[ia], lda, ldb, beta[ib], ldc);
#else
                                 mmcase0(MFLOP, CACHESIZE, TA, TB, m, n, k,
				         alph+(ia SHIFT), lda, ldb,
				         beta+(ib SHIFT), ldc);
#endif
                           }
                           else
                           {
#ifdef TREAL
                                 ipass += mmcase(TEST, CACHESIZE, TA, TB, m,
					         n, k, alph[ia], A, lda, B, ldb,
                                                 beta[ib], C, ldc, D,ldc);
#else
                                 ipass += mmcase(TEST, CACHESIZE, TA, TB, m,
					         n, k, alph+(ia SHIFT), A,
					         lda, B, ldb, beta+(ib SHIFT),
					         C, ldc, D,ldc);
#endif
                           }
/*
 *                         If we lose 5 times in a row, quit search 
 */
                           #ifdef ATL_RKXOVER
                              if (k > 16 &&    /* don't quit too early */
                                  !(speedup_rk_b0[k] | speedup_rk_b0[k-1] |
                                    speedup_rk_b0[k-2] | speedup_rk_b0[k-3] |
                                    speedup_rk_b0[k-4] | speedup_rk[k] |
                                    speedup_rk_b0[k-1] | speedup_rk_b0[k-2] |
                                    speedup_rk_b0[k-3] | speedup_rk[k-4] |
                                    speedup_rk_b0[k-6] | speedup_rk[k-7] |
                                    speedup_rk_b0[k-8] | speedup_rk[k-9] |
                                    speedup_rk_b0[k-10] | speedup_rk[k-11]
                                   )
                                 )
                              {
                                 MAX_vKB = k-5;
                                 goto RANK_K;
                              }
                              #endif
                        }
                        #ifdef TEST_AMMM
                        }
                        #endif
                     }
                  }
               }
            }
         }
      }
   }
   #ifdef ATL_RKXOVER
RANK_K:
      fprintf(fprk, "#ifndef ATLAS_RKXOVER\n   #define ATLAS_RKXOVER\n\n");

/*
 *    First, find last size where we got speedup.  Then, if KB > 80, demand
 *    at > 3% speedup before declaring it worth the extra code
 */
      for (speedup_rk_b0[0]=0, n=MAX_vKB; !speedup_rk_b0[n]; n--);
      while(n > 80 && speedup_rk_b0[n] < 104) n--;
      fprintf(fprk, "#define ATL_RK_MAXK_B0 %d\n", n);
      fprintf(fprk, "static int ATL_rkXover_b0[%d] = {0", n+1);
      for (i=1; i <= n; i++)
         fprintf(fprk, ",%d", speedup_rk_b0[i]);
      fprintf(fprk, "};\n");

      for (speedup_rk[0]=0, m=MAX_vKB; !speedup_rk[m]; m--);
      while(m > 80 && speedup_rk[m] < 104) m--;
      fprintf(fprk, "#define ATL_RK_MAXK_BX %d\n", m);
      fprintf(fprk, "static int ATL_rkXover_bX[%d] = {0", m+1);
      for (i=1; i <= m; i++)
         fprintf(fprk, ",%d", speedup_rk[i]);
      fprintf(fprk, "};\n");
      fprintf(fprk, "#define ATL_RK_MAXK %d\n", m >= n ? m : n);

      fprintf(fprk, "\n#endif\n");
      fclose(fprk);
   #endif
   if (TEST && !MFLOP)
      printf("\nNTEST=%d, NUMBER PASSED=%d, NUMBER FAILURES=%d\n",
             itst, ipass, itst-ipass);
   else printf("\nDone with %d timing runs\n",itst);
   free(Side);
   free(Uplo);
   free(TransA);
   free(TransB);
   free(Diag);
   free(alph);
   free(beta);
   if (!MFLOP)
   {
      free(A);
      free(B);
      free(C);
      if (D) free(D);
   }
   return(0);
}
@ROUT ATL_ger0
#include <Mjoin(Mjoin(ATLAS_,PRE),ger.h)>
void Mjoin(PATL,ger0)(const int M, const int N, const SCALAR alpha,
                      const TYPE *X, const TYPE *Y, const int incY, 
                      TYPE *A, const int lda)
{
   int k;
#if (ATL_GER_MU == 1)
   #define m M
#else
   const int m = ATL_GER_MulByMU(ATL_GER_DivByMU(M));
#endif
#if (ATL_GER_NU == 1)
   #define n N
#else
   const int n = ATL_GER_MulByNU(ATL_GER_DivByNU(N));
#endif
   const TYPE *stX = X+m, *stY = incY*n;

   Mjoin(PATL,ger_full)(alpha, X, stX, Y, incY, stY, A, lda);

#if (ATL_GER_MU != 1)
   if (k = M-m)
   {
      Mjoin(PATL,ger_mu)(k, alpha, stX, stX, Y, incY, stY, A+m, lda);
      #if (ATL_GER_NU != 1)
         if (N-n)
            Mjoin(PATL,ger1)(k, N-n, alpha, stX, 1, stY, incY, A+m+n*lda, lda);
      #endif
   }
#endif
#if (ATL_GER_NU != 1)
   if (N-n)
      Mjoin(PATL,ger_nu)(N-n, alpha, X, stX, stY, incY, stY, A+n*lda, lda);
#endif
}
@ROUT GER
#ifdef ATLGER
   #define Cger Mjoin(Mjoin(PATL,C),ger2)
   #define F77gemv Mjoin(PATL,ger)
#else
   #define Cgemv Mjoin(Mjoin(PATL,C),ger)
   #define F77gemv Mjoin(PRE,ger)
#endif

void Cger(const int M, const int N, const SCALAR alpha0, const TYPE *X,
          const int incX, const TYPE *Y, int incY, TYPE *A, int lda)
{

   int incy=incY, incx=incX;
   void *vx=NULL, *vy=NULL;
   TYPE *x = X, *stX;
#ifdef TREAL
   #define ONE 1.0
   TYPE alpha = alpha0;
#else
   TYPE ONE[2] = {1.0, 0.0};
   TYPE *alpha = alpha0;
#endif
   static const int maxM = (((ATL_DivBySize(ATL_L1CacheSize)-ATL_GER_NU)/(ATL_GER_NU+1))/ATL_GER_MU)*ATL_GER_MU;
#ifndef ATL_NoDebug
   int info = 2000;
   if (M < 0) info = 2;
   if (N < 0) info = Mmin(3,info);
   if ( (lda < M) || (lda < 1) ) info = Mmin(6, info);
   if (!incX) info = Mmin(8, info);
   if (!incY) info = Mmin(11, info);
   if (info != 2000)
   {
      ATL_xerbla(info, Mstr(Mjoin(PRE,gemv)), "");
      return;
   }
#endif
   if ( !M || !N || SCALAR_IS_ZERO(alpha) ) return;

   if (Mabs(alpha) != 1.0)  /* need to scale X or Y */
   {
      if (incY != 1)
      {
         vy = malloc(ATL_Cachelen + (N*ATL_sizeof));
         if (!vy)
         {
            Mjoin(PATL,ger1)(M, N, alpha, X, incX, Y, incY, A, lda);
            return;
         }
         y = ATL_AlignPtr(vy);
         Mjoin(PATL,axy_X_1)(N, alpha, Y, incY, y, 1);
         incy = 1;
      }
      else if (incX != 1)
      {
         vx = malloc(ATL_Cachelen+(N*ATL_sizeof));
         if (!vx)
         {
            Mjoin(PATL,ger1)(M, N, alpha, X, incX, Y, incY, A, lda);
            return;
         }
         x = ATL_AlignPtr(vx);
         Mjoin(PATL,axy_X_1)(N, alpha, X, incX, x, 1);
         incx = 1;
         alpha = 1.0;
      }
   }
   if (incy != 1)
   {
      vy = malloc(ATL_Cachelen+(N*ATL_sizeof));
      if (!vy)
      {
         Mjoin(PATL,ger1)(M, N, alpha, X, incX, Y, incY, A, lda);
         return;
      }
      y = ATL_AlignPtr(vy);
      Mjoin(PATL,copy_X_1)(N, alpha, Y, incY, y, 1);
      incy = 1;
   }
   if (incx != 1)
   {
      vx = malloc(ATL_Cachelen+(N*ATL_sizeof));
      if (!x)
      {
         if (y != Y) free(y);
         Mjoin(PATL,ger1)(M, N, alpha, X, incX, Y, incY, A, lda);
         return;
      }
      x = ATL_AlignPtr(vx);
      Mjoin(PATL,copy_X_1)(N, alpha, X, incX, x, 1);
      incx = 1;
   }
   if (maxM) m = Mmin(M, maxM);
   else m = M;

   do
   {
      Mjoin(PATL,ger0)(m, N, alpha, x, incx, y, incy, A, lda);
      x += m;
      A += m;
      M -= m;
      m = Mmin(M, maxM);
   }
   while (M);

   if (vx) free(vx);
   if (vy) free(vy);
}

@ROUT ATL_GER1
void Mjoin(PATL,ger1)(int m, int n, SCALAR alpha, TYPE *X, int incX, TYPE *Y, int incY,
              TYPE *A, int lda)
{
   const TYPE *stX = X + m*incX, *stY = Y + n*incY, *x=X;
   register TYPE y0;

   do
   {
      y0 = beta * *Y;
      do
      {
         *A++ += *x * y0;
         x += incX;
      }
      while(x != stX);
      x = X;
      Y += incY;
   }
   while (Y != stY);
}
@ROUT emit_ger
@extract -b @(topd)/gen.inc what=cw
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include "atlas_misc.h"

FILE *fpout;

@ROUT emit_ger
#define Mlowcase(C) ( ((C) > 64 && (C) < 91) ? (C) | 32 : (C) )
#define Mupcase(C) ( ((C) > 96 && (C) < 123) ? (C) & 0xDF : (C) )

void emit_ger_h(char pre, int mu, int nu)
{
   int i, pwr2_mu, pwr2_nu;

   fprintf(fpout, "#define ATL_GER_MU %d\n", mu);
   fprintf(fpout, "#define ATL_GER_NU %d\n", nu);
   for (pwr2_mu=0, i=1; i < mu; i <<= 1, pwr2_mu++);
   if (i != mu) pwr2_mu = 0;
   for (pwr2_nu=0, i=1; i < nu; i <<= 1, pwr2_nu++);
   if (i != nu) pwr2_nu = 0;
   if (mu == 1)
   {
      fprintf(fpout, "#define ATL_GER_MulByMU(K) (K)
      fprintf(fpout, "#define ATL_GER_DivByMU(K) (K)
   }
   else if (pwr2_mu)
   {
      fprintf(fpout, "#define ATL_GER_MulByMU(K) ((K) << %d)\n", pwr2_mu);
      fprintf(fpout, "#define ATL_GER_DivByMU(K) ((K) >> %d)\n", pwr2_mu);
   }
   else
   {
      fprintf(fpout, "#define ATL_GER_MulByMU(K) ((K) * %d)\n", mu);
      fprintf(fpout, "#define ATL_GER_DivByMU(K) ((K) / %d)\n", mu);
   }
   if (nu == 1)
   {
      fprintf(fpout, "#define ATL_GER_MulByNU(K) (K)
      fprintf(fpout, "#define ATL_GER_DivByNU(K) (K)
   }
   else if (pwr2_nu)
   {
      fprintf(fpout, "#define ATL_GER_MulByNU(K) ((K) << %d)\n", pwr2_nu);
      fprintf(fpout, "#define ATL_GER_DivByNU(K) ((K) >> %d)\n", pwr2_nu);
   }
   else
   {
      fprintf(fpout, "#define ATL_GER_MulByNU(K) ((K) * %d)\n", nu);
      fprintf(fpout, "#define ATL_GER_DivByNU(K) ((K) / %d)\n", nu);
   }
}

void emit_ger_mu(char pre, char *type, char *styp, int mu, int nu)
{
   mu--;
   for (i=1; i < mu; i++)
      fprintf(fpout, "void ATL_%cger_row_%dx%d(const %s alpha, const %s *x, const %s *stX, const %s *y, const int incY, const %s *stY, %s *A, const int lda);\n", pre, i, nu, styp, type, type, type, type, type);
   fprintf(fpout, "ATL_%cger_mu(const int M, %s alpha, const %s *X, const %s *stX, const %s *Y, const int incY, const %s *stY, %s *A, const int lda);\n", pre, styp, type, type, type, type, type);
   fprintf(fpout, "{\n");
   fprintf(fpout, "   switch(M)\n   {\n");
   for (i=1; i < mu; i++)
   {
      fprintf(fpout, "   case %d:\n", i);
      fprintf(fpout, "      ATL_%cger_mu;\n");
      fprintf(fpout, "      break;\n");
   }
   
}
@beginskip
void emit_ger0(char pre, char *type, char *styp, int mu, int nu)
{
   int i, j, pwr2_mu, pwr2_nu;
   char *spcs="                                 ";
   char *spc = spcs+33;


   fprintf(fpout, "void ATL_%cger0(const int M, const int N, const %s alpha, const %s *X, const %s *Y, const int incY, %s *A, const int lda)\n{\n", pre, styp, type, type, type);
   
   for (pwr2_mu=0, i=1; i < mu; i <<= 1, pwr2_mu++);
   if (i != mu) pwr2_mu = 0;
   for (pwr2_nu=0, i=1; i < nu; i <<= 1, pwr2_nu++);
   if (i != nu) pwr2_nu = 0;
   if (mu == 1) fprintf(fpout, "   #define m M\n");
   else if (pwr2_mu) fprintf(fpout, "   const int m = ( (M >> %d) << %d );\n",
                             pwr2_mu, pwr2_mu);
   else fprintf(fpout, "   const int m = (M/%d)*%d;\n", mu, mu);

   if (nu == 1) fprintf(fpout, "   #define n N\n");
   else if (pwr2_nu) fprintf(fpout, "   const int n = ( (M >> %d) << %d );\n",
                             pwr2_nu, pwr2_nu);
   else fprintf(fpout, "   const int n = (M/%d)*%d;\n", nu, nu);
   fprintf(fpout, "   const %s *stX = X+m, *stY = Y + incY*n;\n", type);
   fprintf(fpout, "   const %s *x, *y, *a;\n", type);
   fprintf(fpout, "   int k;\n");
   
   fprintf(fpout, "   ATL_%cger_full(alpha, X, stX, Y, incY, stY, A, lda);",
           pre);
   if (mu > 1)
   {
      fprintf(fpout, "   if (k = M - m);\n   {");
      spc -= 3;
      fprintf(fpout, "%s   x = stX;\n", spc);
      fprintf(fpout, "%s   a = A+m;\n", spc);
      fprintf(fpout, "   ATL_%cger_mu(alpha, stX, stX, Y, incY, stY, A+m, lda);",
              pre, mu, nu);
@beginskip
      for (i = (mu>>1); i > 0; i >>= 1)
      {
         fprintf(fpout, "   if (k >= %d)\n   {\n", i);
         spc -= 3;
         fprintf(fpout, "%s   ATL_%cger_%dx%d(alpha, x, x+%d, Y, incY, stY, a, lda);", spc, pre, i, nu, i);
         fprintf(fpout, "%s   a += %d\n", i);
         fprintf(fpout, "%s   x += %d\n", i);
         fprintf(fpout, "%s   k -= %d;\n", i);
         spc += 3;
         fprintf(fpout, "%s   }\n");
      }
@endskip
      spc += 3;
      if (nu > 1)
      {
         fprintf(fpout, "%s   if (N-n)\n%s   {\n", spc, spc);
         spc -= 3;
         fprintf(fpout, "%s   ATL_%cger1(M-n, N-n, alpha, stX, 1, stY, incY, A+m+n*lda, lda);\n");
         spc += 3;
         fprintf(fpout, "%s   }\n");
      }
      fprintf(fpout, "%s   }\n");
   }

   if (nu > 1)
   {
      fprintf(fpout, "   if (k = N - n);\n   {");
      spc -= 3;
      fprintf(fpout, "%s   y = stY;\n", spc);
      fprintf(fpout, "%s   a = A+n*lda;\n", spc);
      fprintf(fpout, "   ATL_%cger_nu(alpha, X, stX, stY, incY, stY, A+n*lda, lda);",
              pre);
@beginskip
      for (i = (nu>>1); i > 0; i >>= 1)
      {
         fprintf(fpout, "   if (k >= %d)\n   {\n", i);
         spc -= 3;
         fprintf(fpout, "%s   ATL_%cger_%dx%d(alpha, X, stX, y, incY, y+%d*incY, a, lda);", spc, pre, mu, i, i);
         fprintf(fpout, "%s   a += %d*lda\n", i);
         fprintf(fpout, "%s   y += %d*incY\n", i);
         fprintf(fpout, "%s   k -= %d;\n", i);
         spc += 3;
         fprintf(fpout, "%s   }\n");
      }
@endskip
      spc += 3;
      fprintf(fpout, "%s   }\n");
   }
}
@endskip

@ROUT emit_ger

void cu_getV(char *spc, char *reg, char *vec, char *inc, int nu, int incV)
{
   int j;
   char incZ[5] = {'i', 'n', 'c', 'Y', '\0'};

   incZ[3] = Mupcase(*vec);
   if (incV == 1)
   {
      fprintf(fpout, "%s   %s0 = *%s;\n", spc, reg, vec);
      for (j=1; j < nu; j++)
         fprintf(fpout, "%s   %s%d = %s[%d];\n", spc, reg, j, vec, j);
   }
   else if (incV == -1)
   {
      fprintf(fpout, "%s   %s%d = *%s;\n", spc, reg, nu-1, vec);
      for (j=1; j < nu; j++)
         fprintf(fpout, "%s   %s%d = %s[%d];\n", spc, reg, nu-j-1, vec, j);
   }
   else
   {
      if (inc)
      {
         for (j=0; j < nu; j++)
         {
            fprintf(fpout, "%s   %s%d = *%s%d;\n", spc, reg, j, vec, j);
            fprintf(fpout, "%s   %s%d += %s;\n", spc, vec, j, inc);
         }
      }
      else
      {
         fprintf(fpout, "%s   %s0 = (*%s);\n", spc, reg, vec);
         for (j=1; j < nu; j++)
            fprintf(fpout, "%s   %s%d = %s[%s];\n", spc, reg, j, vec, 
                    GetInc(j, incZ));
      }
   }
}

void cu_getscalV(char *spc, char *reg, char *vec, char *inc, int nu, int incV, int alpha)
{
   int j;
   char incZ[5] = {'i', 'n', 'c', 'Y', '\0'};

   incZ[3] = Mupcase(*vec);
   if (alpha == 1) cu_getV(spc, reg, vec, inc, nu, incV);
   else if (alpha == -1)
   {
      if (incV == 1)
      {
         fprintf(fpout, "%s   %s0 = -(*%s);\n", spc, reg, vec);
         for (j=1; j < nu; j++)
            fprintf(fpout, "%s   %s%d = -%s[%d];\n", spc, reg, j, vec, j);
      }
      else if (incV == -1)
      {
         fprintf(fpout, "%s   %s%d = -(*%s);\n", spc, reg, nu-1, vec);
         for (j=1; j < nu; j++)
            fprintf(fpout, "%s   %s%d = -%s[%d];\n", spc, reg, nu-j-1, vec, j);
      }
      else
      {
         if (inc)
         {
            for (j=0; j < nu; j++)
            {
               fprintf(fpout, "%s   %s%d = -(*%s%d);\n", spc, reg, j, vec, j);
               fprintf(fpout, "%s   %s%d += -%s;\n", spc, vec, j, inc);
            }
         }
         else
         {
            fprintf(fpout, "%s   %s0 = -(*%s);\n", spc, reg, vec);
            for (j=1; j < nu; j++)
               fprintf(fpout, "%s   %s%d = -%s[%s];\n", spc, reg, j, vec, 
                       GetInc(j, incZ));
         }
      }
   }
   else
   {
      if (incV == 1)
      {
         fprintf(fpout, "%s   %s%d = alpha;\n", spc, reg, nu-1);
         fprintf(fpout, "%s   %s0 = *%s * %s%d;\n", spc, reg, vec, reg, nu-1);
         for (j=1; j < nu-1; j++)
            fprintf(fpout, "%s   %s%d = %s[%d] * %s%d;\n", 
                    spc, reg, j, vec, j, reg, nu-1);
         fprintf(fpout, "%s   %s%d *= %s[%d];\n", spc, reg, nu-1, vec, j);
      }
      else if (incV == -1)
      {
         fprintf(fpout, "%s   %s0 = alpha;\n", spc, reg);
         fprintf(fpout, "%s   %s%d = *%s * %s0;\n", spc, reg, nu-1, vec, reg);
         for (j=1; j < nu-1; j++)
            fprintf(fpout, "%s   %s%d = %s[%d] * %s0;\n", 
                    spc, reg, nu-j-1, vec, j, reg);
         fprintf(fpout, "%s   %s0 *= %s[%d];\n", spc, reg, vec, j);
      }
      else
      {
         fprintf(fpout, "%s   %s%d = alpha;\n", spc, reg, nu-1);
         if (inc)
         {
            for (j=0; j < nu-1; j++)
            {
               fprintf(fpout, "%s   %s%d = *%s%d * %s%d;\n",
                       spc, reg, j, vec, j, reg, nu-1);
               fprintf(fpout, "%s   %s%d += %s;\n", spc, vec, j, inc);
            }
            fprintf(fpout, "%s   %s%d *= *%s%d;\n", spc, reg, nu-1, vec, nu-1);
            fprintf(fpout, "%s   %s%d += %s;\n", spc, vec, j, inc);
         }
         else
         {
            fprintf(fpout, "%s   %s0 = -(*%s);\n", spc, reg, vec);
            for (j=1; j < nu-1; j++)
               fprintf(fpout, "%s   %s%d = %s[%s] * %s%d;\n", spc, reg, j, vec, 
                       GetInc(j, incZ), reg, nu-1);
            fprintf(fpout, "%s   %s%d *= %s[%s];\n", spc, reg, nu-1, vec, 
                    GetInc(nu-1, incZ));
         }
      }
   }
}


void XYstart(char *spc, char xy, int K)
{
   int j;

   fprintf(fpout, "%s   if (AlphaIsNegOne)\n%s   {\n", spc, spc);
   spc -= 3;
   for (j=0; j < K; j++)
   {
      fprintf(fpout, "%s   %c%d = -(*%c%d);\n", spc, xy, j, Mupcase(xy), j);
      fprintf(fpout, "%s   %c%d += inc%c;\n", spc, Mupcase(xy), j, xy);
   }
   spc += 3;

   fprintf(fpout, "%s   }\n%s   else if (AlphaIsOne)\n%s   {\n", 
           spc, spc, spc);
   spc -= 3;
   for (j=0; j < K; j++)
   {
      fprintf(fpout, "%s   %c%d = *%c%d;\n", spc, xy, j, Mupcase(xy), j);
      fprintf(fpout, "%s   %c%d += inc%c;\n", spc, Mupcase(xy), j, xy);
   }
   spc += 3;

   fprintf(fpout, "%s   }\n%s   else\n%s   {\n", spc, spc, spc);
   spc -= 3;
   fprintf(fpout, "%s   %c%d = alpha;\n", spc, xy, K-1);
   for (j=0; j < K-1; j++)
   {
      fprintf(fpout, "%s   %c%d = *%c%d * %c%d;\n", spc, xy, j, Mupcase(xy), j,
              xy, K-1);
      fprintf(fpout, "%s   %c%d += inc%c;\n", spc, Mupcase(xy), j, xy);
   }
   fprintf(fpout, "%s   %c%d *= *%c%d;\n", spc, xy, K-1, Mupcase(xy), K-1);
   fprintf(fpout, "%s   %c%d += inc%c;\n", spc, Mupcase(xy), K-1, xy);
   spc += 3;
   fprintf(fpout, "%s   }\n", spc);
}

void emit_muXnu_ma(char *spc, int ROWMAJOR, int mu, int nu)
{
   int i, j;

   if (ROWMAJOR)
   {
      for (i=0; i < mu; i++)
      {
         for (j=0; j < nu; j++)
         {
            if (i == 0)
            {
               if (mu == 1)
                  fprintf(fpout, "%s   *A%d++ += y%d * x0;\n", spc, j, j);
               else fprintf(fpout, "%s   *A%d += y%d * x0;\n", spc, j, j);
            }
            else fprintf(fpout, "%s   A%d[%d] += y%d * x%d;\n",
                         spc, j, i, j, i);
         }
      }
   }
   else
   {
      for (j=0; j < nu; j++)
      {
         if (mu == 1) fprintf(fpout, "%s   *A%d++ += y%d * x0;\n", spc, j, j);
         else fprintf(fpout, "%s   *A%d += y%d * x0;\n", spc, j, j);
         for (i=1; i < mu; i++)
            fprintf(fpout, "%s   A%d[%d] += y%d * x%d;\n", spc, j, i, j, i);
      }
   }
}

void emit_muXnu(char *spc, int ROWMAJOR, int IncByLDA, int mu, int nu, int lat,
                int *ic0, int *jc0, int *k0)
{
   int k=(*k0), ic=(*ic0), jc=(*jc0);
   int N = k + mu*nu;

   if (ROWMAJOR)
   {
      if (!k)
      {
         for (k=0; k < lat; k++)
            fprintf(fpout, "%s   m%d = x%d * y%d;\n", spc, k, (k/nu)%mu, k%nu);
      }
      do
      {
         if (!ic) fprintf(fpout, "%s   *A%d += m%d;\n", spc, jc, (k-lat)%lat);
         else fprintf(fpout, "%s   A%d[%d] += m%d;\n", 
                      spc, jc, ic, (k-lat)%lat);
         if (ic == mu-1)
         {
            if (IncByLDA == 1)
            {
               fprintf(fpout, "%s   A%d += incA2;\n", spc, jc);
               if (jc == nu-1) IncByLDA = 0;
            }
            else if (IncByLDA == 2)
               fprintf(fpout, "%s   A%d += incA;\n", spc, jc);
            else if (mu == 1) fprintf(fpout, "%s   A%d++;\n", spc, jc);
            else fprintf(fpout, "%s   A%d += %d;\n", spc, jc, mu);
         }
         if (++jc == nu)
         {
            jc = 0;
            if (++ic == mu) ic = 0;
         }
         fprintf(fpout, "%s   m%d = x%d * y%d;\n", 
                 spc, (k-lat)%lat, (k/nu)%mu, k%nu);
      }
      while (++k < N);
   }
   else
   {
      if (!k)
      {
         for (k=0; k < lat; k++)
            fprintf(fpout, "%s   m%d = x%d * y%d;\n", spc, k, k%mu, (k/mu)%nu);
      }
      do
      {
         if (!ic) fprintf(fpout, "%s   *A%d += m%d;\n", spc, jc, (k-lat)%lat);
         else fprintf(fpout, "%s   A%d[%d] += m%d;\n", 
                      spc, jc, ic, (k-lat)%lat);
         if (++ic == mu)
         {
            if (IncByLDA == 1) fprintf(fpout, "%s   A%d += incA2;\n", spc, jc);
            else if (IncByLDA == 2)
               fprintf(fpout, "%s   A%d += incA;\n", spc, jc);
            else if (mu == 1) fprintf(fpout, "%s   A%d++;\n", spc, jc);
            else fprintf(fpout, "%s   A%d += %d;\n", spc, jc, mu);
            ic = 0;
            if (++jc == nu)
            {
               jc = 0;
               if (IncByLDA == 1) IncByLDA = 0;
            }
         }
         fprintf(fpout, "%s   m%d = x%d * y%d;\n", 
                 spc, (k-lat)%lat, k%mu, (k/mu)%nu);
      }
      while (++k < N);
   }

   *k0 = k;
   *jc0 = jc;
   *ic0 = ic;
}

void DrainPipe(char *spc, int ROWMAJOR, int mu, int nu, int lat, 
               int ic, int jc, int k)
{
   int i;

   for (i=k+lat; k < i; k++)
   {
      if (!ic) fprintf(fpout, "%s   *A%d += m%d;\n", spc, jc, (k-lat)%lat);
      else fprintf(fpout, "%s   A%d[%d] += m%d;\n", spc, jc, ic, (k-lat)%lat);
      if (ROWMAJOR)
      {
         if (++jc == nu)
         {
            jc = 0;
            if (++ic == mu) ic = 0;
         }
      }
      else
      {
         if (++ic == mu)
         {
            ic = 0;
            if (++jc == nu) jc = 0;
         }
      }
   }
}
void emit_InnLoopX(char *spc, int ROWMAJOR, int mu, int nu, int lat)
{
   int i, k=0, ic=0, jc=0, N=mu*nu;

   assert( ((mu*nu)/lat)*lat == (mu*nu) );
   XYstart(spc, 'y', nu);
   fprintf(fpout, "%s   x0 = *x;\n", spc);
   for (i=1; i < mu; i++) fprintf(fpout, "%s   x%d = x[%d];\n", spc, i, i);

   emit_muXnu(spc, ROWMAJOR, 0, mu, nu, lat, &ic, &jc, &k);
   if (mu == 1) fprintf(fpout, "%s   if (++x == stX) goto XloopEnd;\n", spc);
   else
   {
      fprintf(fpout, "%s   x += %d;\n", spc, mu);
      fprintf(fpout, "%s   if (x == stX) goto XloopEnd;\n", spc);
   }
@beginskip
   spc -= 3;
   for (i=0; i < jc; i++) fprintf(fpout, "%s   A%d += incA;\n", spc, i);
   fprintf(fpout, "%s   goto XloopEnd;\n", spc);
   spc += 3;
   fprintf(fpout, "%s   }\n", spc);
   fprintf(fpout, "%s   else goto XloopStart;\n", spc);
@endskip
   fprintf(fpout, "\n%s   YloopStart:\n", spc);
   spc -= 3;

@skip   fprintf(fpout, "%s   XloopStart:\n", spc);
   fprintf(fpout, "%s   do\n%s   {\n", spc, spc);
   spc -= 3;
   fprintf(fpout, "%s   x0 = *x;\n", spc);
   for (i=1; i < mu; i++) fprintf(fpout, "%s   x%d = x[%d];\n", spc, i, i);
   emit_muXnu(spc, ROWMAJOR, 0, mu, nu, lat, &ic, &jc, &k);
   if (mu > 1)
   {
      fprintf(fpout, "%s   x += %d;\n", spc, mu);
      spc += 3;
      fprintf(fpout, "%s   }\n%s   while(x != stX);\n", spc, spc);
   }
   else
   {
      spc += 3;
      fprintf(fpout, "%s   }\n%s   while(++x != stX);\n", spc, spc);
   }
   fprintf(fpout, "%s   XloopEnd:\n", spc);

   spc += 3;
   fprintf(fpout, "%s   if (Y0 != stY)\n%s   {\n", spc, spc);
   spc -= 3;
   for (i=0; i < jc; i++) fprintf(fpout, "%s   A%d += incA;\n", spc, i);
   fprintf(fpout, "%s   x = X;\n", spc);
   XYstart(spc, 'y', nu);
   emit_muXnu(spc, ROWMAJOR, 1, mu, nu, lat, &ic, &jc, &k);
   if (mu == 1) fprintf(fpout, "%s   if (++x == stX) goto XloopEnd;\n", spc);
   else
   {
      fprintf(fpout, "%s   x += %d;\n", spc, mu);
      fprintf(fpout, "%s   if (x == stX) goto XloopEnd;\n", spc);
   }
   fprintf(fpout, "%s   goto YloopStart;\n", spc);
   spc += 3;
   fprintf(fpout, "%s   }\n", spc);
   DrainPipe(spc, ROWMAJOR, mu, nu, lat, ic, jc, k);
}


void emit_InnLoopX_ma(char *spc, int ROWMAJOR, int mu, int nu)
{
   int i, j;

   fprintf(fpout, "%s   do\n%s   {\n", spc, spc);
   spc -= 3;
   XYstart(spc, 'y', nu);
   fprintf(fpout, "%s   do\n%s   {\n", spc, spc);
   spc -= 3;
   fprintf(fpout, "%s   x0 = *x;\n", spc);
   for (i=1; i < mu; i++) fprintf(fpout, "%s   x%d = x[%d];\n", spc, i, i);
   emit_muXnu_ma(spc, ROWMAJOR, mu, nu);
   if (mu > 1) 
   {
      fprintf(fpout, "%s   A%d += %d;\n", spc, mu);
      fprintf(fpout, "%s   x += %d;\n", spc, mu);
      spc += 3;
      fprintf(fpout, "%s   }\n%s   while(x != stX);\n", spc, spc);
   }
   else
   {
      spc += 3;
      fprintf(fpout, "%s   }\n%s   while(++x != stX);\n", spc, spc);
   }
   for (i=0; i < nu; i++) fprintf(fpout, "%s   A%d += incA;\n", spc, i);
   spc += 3;
   fprintf(fpout, "%s   }\n%s   while(Y0 != stY);\n", spc, spc);
}

void emit_Xloop_rout(char pre, char *type, char *styp, char XY, int MULADD,
                     int ROWMAJOR, int mu, int nu, int lat)
{
   char *spcs = "               ";
   char *spc = spcs+15;
   int j;

   fprintf(fpout, "void ATL_%cger_%dx%d(const %s alpha, const %s *X, const %s *stX, const %s *y, const int incY, const %s *stY, %s *A, const int lda)\n{\n", pre, mu, nu, styp, type, type, type, type, type);
   fprintf(fpout, "   const int AlphaIsOne=(alpha == 1.0), AlphaIsNegOne=(alpha == -1.0);\n");
   fprintf(fpout, "   register %s x0", type);
   for (j=1; j < mu; j++) fprintf(fpout, ", x%d", j);
   for (j=0; j < nu; j++) fprintf(fpout, ", y%d", j);
   if (!MULADD) for (j=0; j < lat; j++) fprintf(fpout, ", m%d", j);
   fprintf(fpout, ";\n");
   fprintf(fpout, "   const %s *x=X;\n", type);
   fprintf(fpout, "   %s *A0=A", type);
   for (j=1; j < nu; j++) fprintf(fpout, ", *A%d=A%d+lda", j, j-1);
   fprintf(fpout, ";\n");
   fprintf(fpout, "   const %s *Y0=y", type);
   for (j=1; j < nu; j++) fprintf(fpout, ", *Y%d=Y%d+incY", j, j-1);
   fprintf(fpout, ";\n");
   fprintf(fpout, "   const int incA=(%s)-(stX-x)", GetInc(nu, "lda"));
   fprintf(fpout, ", incy=%s;\n", GetInc(nu, "incY"));
   if (!MULADD) fprintf(fpout, "   const int incA2=incA+%d;\n", mu);
   fprintf(fpout, "\n");

   if (MULADD) emit_InnLoopX_ma(spc, ROWMAJOR, mu, nu);
   else emit_InnLoopX(spc, ROWMAJOR, mu, nu, lat);
   fprintf(fpout, "}\n");
}

void emit_mu_cleanup(char pre, char *type, char *styp, int MULADD,
                     int ROWMAJOR, int incX, int incY, int alpha, 
                     int mu, int nu, int lat)
{
   char *Y, *Y0;
   char *spcs = "                           ";
   char *spc=spcs+27;
   int j, ic=0, jc=0, k=0;
   fprintf(fpout, "void ATL_%cger_row_%dx%d(const %s alpha, const %s *x, const %s *stX, const %s *y, const int incY, const %s *stY, %s *A, const int lda)\n{\n", pre, mu, nu, styp, type, type, type, type, type);
   fprintf(fpout, "   register %s x0", type);
   for (j=1; j < mu; j++) fprintf(fpout, ", x%d", j);
   for (j=0; j < nu; j++) fprintf(fpout, ", y%d", j);
   if (!MULADD) for (j=0; j < lat; j++) fprintf(fpout, ", m%d", j);
   fprintf(fpout, ";\n");
   fprintf(fpout, "   %s *A0=A", type);
   for (j=1; j < nu; j++) fprintf(fpout, ", *A%d=A%d+lda", j, j-1);
   fprintf(fpout, ";\n");
   if ( (incY != 1) && (incY != -1) && (nu > 1) )
   {
      fprintf(fpout, "   const %s *Y0=y", type);
      for (j=1; j < nu; j++) fprintf(fpout, ", *Y%d=Y%d+incY", j, j-1);
      fprintf(fpout, ";\n");
      Y = "Y";
      Y0 = "Y0";
   }
   else Y0 = Y = "y";
   fprintf(fpout, "   const int incA=%s", GetInc(nu, "lda"));
   fprintf(fpout, ", incy=%s;\n", GetInc(nu, "incY"));
   fprintf(fpout, "\n");

   cu_getscalV(spc, "x", "x", NULL, mu, incX, alpha);

   if (MULADD)
   {
      fprintf(fpout, "%s   do\n%s   {\n", spc, spc);
      spc -= 3;
      cu_getV(spc, "y", Y, "incy", nu, incY);
      emit_muXnu_ma(spc, ROWMAJOR, mu, nu);
      for (j=0; j < nu; j++) fprintf(fpout, "%s   A%d += incA;\n", spc, j);
      if (nu > 1 && incY == 1) fprintf(fpout, "%s   y += %d;\n", spc, nu);
      else if (nu > 1 && incY == -1) fprintf(fpout, "%s   y -= %d;\n", spc, nu);
      spc += 3;
      if (nu == 1 && incY == 1)
         fprintf(fpout, "%s   }\n%s   while(++y != stY);\n", spc, spc);
      if (nu == 1 && incY == -1)
         fprintf(fpout, "%s   }\n%s   while(--y != stY);\n", spc, spc);
      else fprintf(fpout, "%s   }\n%s   while(%s != stY);\n", spc, spc, Y0);
   }
   else
   {
      cu_getV(spc, "y", Y, "incy", nu, incY);
      emit_muXnu(spc, ROWMAJOR, 2, mu, nu, lat, &ic, &jc, &k);
      fprintf(fpout, "\n");
   
      fprintf(fpout, "%s   if (%s != stY)\n%s   {\n", spc, Y0, spc);
      spc -= 3;
      fprintf(fpout, "%s   do\n%s   {\n", spc, spc);
      spc -= 3;
      cu_getV(spc, "y", Y, "incy", nu, incY);
      emit_muXnu(spc, ROWMAJOR, 2, mu, nu, lat, &ic, &jc, &k);
      spc += 3;
      fprintf(fpout, "%s   }\n%s   while(%s != stY);\n", spc, spc, Y0);
      spc += 3;
      fprintf(fpout, "%s   }\n", spc);
      DrainPipe(spc, ROWMAJOR, mu, nu, lat, ic, jc, k);
   }
   fprintf(fpout, "}\n");
}

void emit_nu_cleanup(char pre, char *type, char *styp, int MULADD,
                     int ROWMAJOR, int incX, int incY, int alpha,
                     int mu, int nu, int lat)
{
   char *spcs = "                           ";
   char *spc=spcs+27;
   int j, ic=0, jc=0, k=0;

   fprintf(fpout, "void ATL_%cger_col_%dx%d(const %s alpha, const %s *x, const %s *stX, const %s *y, const int incY, const %s *stY, %s *A, const int lda)\n{\n", pre, mu, nu, styp, type, type, type, type, type);
   fprintf(fpout, "   register %s x0", type);
   for (j=1; j < mu; j++) fprintf(fpout, ", x%d", j);
   for (j=0; j < nu; j++) fprintf(fpout, ", y%d", j);
   if (!MULADD) for (j=0; j < lat; j++) fprintf(fpout, ", m%d", j);
   fprintf(fpout, ";\n");
   fprintf(fpout, "   %s *A0=A", type);
   for (j=1; j < nu; j++) fprintf(fpout, ", *A%d=A%d+lda", j, j-1);
   fprintf(fpout, ";\n\n");

   cu_getscalV(spc, "y", "y", NULL, nu, incY, alpha);
   fprintf(fpout, "\n");

   if (MULADD)
   {
      fprintf(fpout, "%s   do\n%s   {\n", spc, spc);
      spc -= 3;
      cu_getV(spc, "x", "x", NULL, mu, incX);
      emit_muXnu_ma(spc, ROWMAJOR, mu, nu);
      if (mu > 1)
      {
         for (j=0; j < nu; j++) fprintf(fpout, "%s   A%d += %d;\n", spc, j, mu);
         fprintf(fpout, "%s   x += %d;\n", spc, mu);
      }
      else for (j=0; j < nu; j++) fprintf(fpout, "%s   A%d++;\n", spc, j, mu);
      spc += 3;
      if (mu > 1) fprintf(fpout, "%s   }\n%s   while(x != stX);\n", spc, spc);
      else fprintf(fpout, "%s   }\n%s   while(++x != stX);\n", spc, spc);
   }
   else
   {
      cu_getV(spc, "x", "x", NULL, mu, incX);
      emit_muXnu(spc, ROWMAJOR, 0, mu, nu, lat, &ic, &jc, &k);
      if (mu > 1) fprintf(fpout, "%s   x += %d;\n", spc, mu);
      else fprintf(fpout, "%s   x++;\n", spc);
      fprintf(fpout, "\n");
   
      fprintf(fpout, "%s   if (x != stX)\n%s   {\n", spc, spc);
      spc -= 3;
      fprintf(fpout, "%s   do\n%s   {\n", spc, spc);
      spc -= 3;
      cu_getV(spc, "x", "x", NULL, mu, incX);
      emit_muXnu(spc, ROWMAJOR, 0, mu, nu, lat, &ic, &jc, &k);
      if (mu > 1) fprintf(fpout, "%s   x += %d;\n", spc, mu);
      spc += 3;
      if (mu > 1) fprintf(fpout, "%s   }\n%s   while(x != stX);\n", spc, spc);
      else fprintf(fpout, "%s   }\n%s   while(++x != stX);\n", spc, spc);
      spc += 3;
      fprintf(fpout, "%s   }\n", spc);
      DrainPipe(spc, ROWMAJOR, mu, nu, lat, ic, jc, k);
   }
   fprintf(fpout, "}\n");
}

void emit_Xloop_Cleanup(char pre, char *type, char *styp, char XY, int MULADD,
                        int ROWMAJOR, int mu, int nu, int lat)
{
   int i;
   char fnam[128];
   for (i=1; i < mu; i <<= 1)
   {
      sprintf(fnam, "CLEANUP/ATL_%cger_%dx%d.c", pre, i, nu);
      fpout = fopen(fnam, "w");
      assert(fpout);
      emit_Xloop_rout(pre, type, styp, XY, MULADD, ROWMAJOR, i, nu, lat);
   }
   for (i=1; i < nu; i <<= 1)
   {
      sprintf(fnam, "CLEANUP/ATL_%cger_%dx%d.c", pre, mu, i);
      fpout = fopen(fnam, "w");
      assert(fpout);
      emit_Xloop_rout(pre, type, styp, XY, MULADD, ROWMAJOR, mu, i, lat);
   }
   fpout = stdout;
}

int main(int nargs, char *args[])
{
   char what, pre;
   char *styp, *type;
   int muladd, mu, nu, lat;
   int incX=1, incY=0, ROWMAJOR=1, alpha=1;

   fpout = stdout;
   if (nargs < 11)
   {
      fprintf(stderr, "USAGE: %s <r/c> <pre> <muladd> <mu> <nu> <lat> <ROWMAJOR> <incX> <incY> <alpha>\n", args[0]);
      exit(-1);
   }
   what   = *args[1];
   pre    = *args[2];
   muladd = atoi(args[3]);
   mu     = atoi(args[4]);
   nu     = atoi(args[5]);
   lat    = atoi(args[6]);
   ROWMAJOR = atoi(args[7]);
   incX   = atoi(args[8]);
   incY   = atoi(args[9]);
   alpha  = atoi(args[10]);
   switch (pre)
   {
   case 's':
      styp = type = "float";
      break;
   case 'd':
      styp = type = "double";
      break;
   case 'c':
      type = "float";
      styp = "float *";
      break;
   case 'z':
      type = "double";
      styp = "double *";
      break;
   }
   if (what == 'g')
      emit_Xloop_rout(pre, type, styp, 'X', muladd, ROWMAJOR, mu, nu, lat);
   else if (what == '0') emit_ger0(pre, type, styp, mu, nu);
   else if (what == 'r')
      emit_mu_cleanup(pre, type, styp, muladd, ROWMAJOR, incX, incY, alpha,
                      mu, nu, lat);
   else if (what == 'c')
      emit_nu_cleanup(pre, type, styp, muladd, ROWMAJOR, incX, incY, alpha,
                      mu, nu, lat);
   else emit_Xloop_Cleanup(pre, type, styp, 'X', muladd, ROWMAJOR, mu, nu, lat);
   return(0);
}
@ROUT PrintTypeHead
void PrintTypeHead(FILE *fpout)
{
   int pwr2;

   fprintf(fpout, "#ifndef ATLAS_TYPE_H\n");
   fprintf(fpout, "#define ATLAS_TYPE_H\n\n");
   fprintf(fpout, "#define ATL_LSIZE %d\n", (int) sizeof(long));
   fprintf(fpout, "#define ATL_ISIZE %d\n", (int) sizeof(int));
   fprintf(fpout, "#define ATL_SSIZE %d\n", (int) sizeof(float));
   fprintf(fpout, "#define ATL_DSIZE %d\n", (int) sizeof(double));
   fprintf(fpout, "#define ATL_CSIZE %d\n", (int) (2*sizeof(float)));
   fprintf(fpout, "#define ATL_ZSIZE %d\n", (int) (2*sizeof(double)));
   fprintf(fpout, "#define ATL_lsize ((size_t)%d)\n", (int) sizeof(long));
   fprintf(fpout, "#define ATL_isize ((size_t)%d)\n", (int) sizeof(int));
   fprintf(fpout, "#define ATL_ssize ((size_t)%d)\n", (int) sizeof(float));
   fprintf(fpout, "#define ATL_dsize ((size_t)%d)\n", (int) sizeof(double));
   fprintf(fpout, "#define ATL_csize ((size_t)%d)\n", (int) (2*sizeof(float)));
   fprintf(fpout, "#define ATL_zsize ((size_t)%d)\n", (int) (2*sizeof(double)));
   fprintf(fpout, "#define ATL_%cMulBySize(N_) %s\n", 'l', 
           GetInc(sizeof(long), "((size_t)(N_))"));
   fprintf(fpout, "#define ATL_%cMulBySize(N_) %s\n", 'i', 
           GetInc(sizeof(int), "((size_t)(N_))"));
   fprintf(fpout, "#define ATL_%cMulBySize(N_) %s\n", 's', 
           GetInc(sizeof(float), "((size_t)(N_))"));
   fprintf(fpout, "#define ATL_%cMulBySize(N_) %s\n", 'd', 
           GetInc(sizeof(double), "((size_t)(N_))"));
   fprintf(fpout, "#define ATL_%cMulBySize(N_) %s\n", 'c', 
           GetInc(2*sizeof(float), "((size_t)(N_))"));
   fprintf(fpout, "#define ATL_%cMulBySize(N_) %s\n", 'z', 
           GetInc(2*sizeof(double), "((size_t)(N_))"));

   @multidef ty long int
   @whiledef pr l i
   pwr2 = GetPower2(sizeof(@(ty)));
   if (pwr2)
   {
      fprintf(fpout, "#define ATL_@(pr)shift %d\n", pwr2);
      fprintf(fpout, "#define ATL_@(pr)DivBySize(N_) ((N_) >> %d)\n", pwr2);
   }
   else
      fprintf(fpout, "#define ATL_@(pr)DivBySize(N_) ((N_) / %d)\n", 
              sizeof(@(ty)));
      @undef ty
   @endwhile
   @multidef ty double float
   @multidef p2 z c
   @whiledef pr d s
   pwr2 = GetPower2(sizeof(@(ty)));
   if (pwr2)
   {
      fprintf(fpout, "#define ATL_@(pr)shift %d\n", pwr2);
      fprintf(fpout, "#define ATL_@(pr)DivBySize(N_) ((N_) >> %d)\n", pwr2);
      fprintf(fpout, "#define ATL_@(p2)shift %d\n", pwr2+1);
      fprintf(fpout, "#define ATL_@(p2)DivBySize(N_) ((N_) >> %d)\n", pwr2+1);
   }
   else
   {
      fprintf(fpout, "#define ATL_@(pr)DivBySize(N_) ((N_) / %d)\n", 
              sizeof(@(ty)));
      fprintf(fpout, "#define ATL_@(p2)DivBySize(N_) ((N_) / %d)\n", 
              2*sizeof(@(ty)));
   }
      @undef p2
      @undef ty
   @endwhile
@beginskip
   pwr2 = GetPower2(sizeof(int));
   if (pwr2)
   {
      fprintf(fpout, "#define ATL_ishift %d\n", pwr2);
      fprintf(fpout, "#define ATL_iDivBySize(N_) ((N_) >> %d)\n", pwr2);
   }
   else
      fprintf(fpout, "#define ATL_iDivBySize(N_) ((N_) / sizeof(int))\n");
   pwr2 = GetPower2(sizeof(float));
   if (pwr2) 
   {
      fprintf(fpout, "#define ATL_sshift %d\n", pwr2);
      fprintf(fpout, "#define ATL_cshift %d\n", pwr2+1);
      fprintf(fpout, "#define ATL_%cDivBySize(N_) ((N_) >> %d)\n", 's', pwr2);
      fprintf(fpout, "#define ATL_%cDivBySize(N_) ((N_) >> %d)\n", 'c', pwr2+1);
   }
   else
   {
      fprintf(fpout, "#define ATL_sDivBySize(N_) ((N_) / sizeof(float))\n");
      fprintf(fpout, "#define ATL_cDivBySize(N_) ((N_) / %d)\n", 
              (int)(2*sizeof(float)));
   }
   pwr2 = GetPower2(sizeof(double));
   if (pwr2) 
   {
      fprintf(fpout, "#define ATL_dshift %d\n", pwr2);
      fprintf(fpout, "#define ATL_zshift %d\n", pwr2+1);
      fprintf(fpout, "#define ATL_%cDivBySize(N_) ((N_) >> %d)\n", 'd', pwr2);
      fprintf(fpout, "#define ATL_%cDivBySize(N_) ((N_) >> %d)\n", 'z', pwr2+1);
   }
   else
   {
      fprintf(fpout, "#define ATL_dDivBySize(N_) ((N_) / sizeof(double))\n");
      fprintf(fpout, "#define ATL_zDivBySize(N_) ((N_) / %d)\n", 
              (int)(2*sizeof(double)));
   }
@endskip
   fprintf(fpout, "\n#endif\n");
}
int main(int nargs, char *args[])
{
   FILE *fpout=NULL;
   if (nargs == 1) fpout = stdout;
   else if (nargs != 2)
   {
      fprintf(stderr, "usage: %s <file out>\n", args[0]);
      exit(-1);
   }
   if (fpout == NULL)
   {
      fpout = fopen(args[1], "w");
      assert(fpout != NULL);
   }
   PrintTypeHead(fpout);
   if (fpout != stdout) fclose(fpout);
   return(0);
}
@ROUT emitmv
typedef void (*MUXNU)(char *spc, int mu, int nu, int Xregs, int Ydup, int maxM);
void mvmuXnu_N_ma(char *spc, int mu, int nu, int Xregs, int Ydup, int maxM)
{
   int i, J, j, jj, GETX=1;

   if (Xregs < 0)
   {
      GETX = 0;
      Xregs = -Xregs;
   }
   if (Ydup > nu) Ydup = nu;
   if (Ydup > Xregs) Xregs = Ydup;
   else while (Xregs % Ydup) Xregs--;

   if (GETX) fprintf(fpout, "%s   x0 = *x;\n", spc);
   for (J=0; J < nu; J += Ydup)
   {
      if (J % Xregs == 0 && GETX)
         for (j=0; j < Xregs; j++) 
            if (J+j) fprintf(fpout, "%s   x%d = x[%d];\n", spc, j, J+j);
      for (i=0; i < mu; i++)
      {
         for (jj=0; jj < Ydup; jj++)
         {
            j = jj + J;
            if (i) fprintf(fpout, "%s   y%d_%d += pA%d[%d] * x%d;\n",
                           spc, i, jj, j, i, j%Xregs);
            else fprintf(fpout, "%s   y0_%d += *pA%d * x%d;\n", spc, jj, j, j%Xregs);
         }
      }
   }
@beginskip
   int i, j;

   if (mu < 0) /* do col-major ops */
   {
      mu = -mu;
      fprintf(fpout, "%s   x0 = *x;\n", spc);
      for (j=0; j < nu; j++)
      {
         if (j % Xregs == 0)
         {
            for (k=0; k < Xregs; k++)
               if (j) fprintf(fpout, "%s   x%d = x[%d];\n", spc, k, j);
         }
      }
   }
   fprintf(fpout, "%s   x0 = *x;\n", spc);
   for (j=1; j < nu; j++) fprintf(fpout, "%s   x%d = x[%d];\n", spc, j, j);

   for (i=0; i < mu; i++)
   {
      for (j=0; j < nu; j++)
      {
         if (i) fprintf(fpout, "%s   y%d_%d += pA%d[%d] * x%d;\n",spc, i,j%Ydup, j, i, j);
         else fprintf(fpout, "%s   y0_%d += *pA%d * x%d;\n", spc, j%Ydup, j, j);
      }
   }
   int i, jj, j=0, k;

   assert(nu % Xregs == 0);
   assert(nu >= Ydup);
   fprintf(fpout, "%s   x0 = *x;\n", spc);
   do
   {
      for (i=0; i < mu; i++)
      {
         for (jj=0; jj < Ydup; jj++, j++)
         {
            if (j % Xregs == 0) 
            {
               for (k=0; k < Xregs; k++) 
                  if (!j) fprintf(fpout, "%s   x%d = x[%d];\n", spc, k, j+k);
            }
            if (i) fprintf(fpout, "%s   y%d_%d += pA%d[%d] * x%d;\n", 
                           spc, i, j%Ydup, j, i, j%Xregs);
            else  fprintf(fpout, "%s   y0_%d += *pA%d * x%d;\n", 
                           spc, j%Ydup, j, j%Xregs);
         }
      }
   }
   while(j < nu);
@endskip
}

void mvmuXnu_T_ma(char *spc, int mu, int nu, int Xregs, int Ydup, int maxM)
{
   int I, ii, i, j, k, GETX=1;

   if (Xregs < 0)
   {
      GETX = 0;
      Xregs = -Xregs;
   }
   assert(nu % Xregs == 0);
   assert(nu >= Ydup);
   assert(mu % maxM == 0);
   if (maxM < mu) assert(Xregs == nu);
   for (I=0; I < mu; I += maxM)
   {
      for (j=0; j < nu; j++)
      {
         if (I == 0 && j%Xregs == 0 && GETX)
         {
            for (k=0; k < Xregs; k++) 
            {
               if (k+j) fprintf(fpout, "%s   x%d = x[%d];\n", spc, k, k+j);
               else fprintf(fpout, "%s   x0 = *x;\n", spc);
            }
         }
   
         for (ii=0; ii < maxM; ii++)
         {
            i = I + ii;
            if (j) fprintf(fpout, "%s   y%d_%d += pA%d[%d] * x%d;\n", 
                           spc, i, j%Ydup, i, j, j%Xregs);
            else fprintf(fpout, "%s   y%d_0 += *pA%d * x0;\n", spc, i, i);
         }
      }
   }
}

void mvXclean(char *spc, MUXNU mvmuXnu, int mu, int nu, int Xregs, int Ydup, 
              int maxM)
{
   int j, k;

   if (nu < 2) return;
   if (nu == 2) mvmuXnu(spc, mu, 1, 1, 1, maxM);
   else
   {
      fprintf(fpout, "%s   switch(nr)\n%s   {\n", spc, spc);
      for (j=1; j < nu; j++)
      {
         k = Xregs;
         while (j%k) k--;
         fprintf(fpout, "%s   case %d:\n", spc, j);
         mvmuXnu(spc-3, mu, j, k, Mmin(Ydup, j), maxM);
         fprintf(fpout, "%s      break;\n", spc);
      }
      fprintf(fpout, "%s   case 0:\n", spc);
@skip      fprintf(fpout, "%s      break;\n", spc);
      fprintf(fpout, "%s   }\n", spc);
   }
}

void mvmuXnu_N(char *spc, int mu, int nu, int Ydup, int lat, int Xregs, int K, 
               int DRAIN, int *i, int *J, int *jj, int *xc)
{
   int j, jx, k;
   int MUL=1;

   for (k=0; k < K; k++)
   {
      j = (*J)*Ydup+(*jj);
      jx = j % Xregs;
      if (K == mu*nu) fprintf(fpout, "%s   y%d_%d += m%d;\n",
                              spc, (k/Ydup)%mu, k%Ydup, k%lat);
      if (MUL)
      {
         if (*i) fprintf(fpout, "%s   m%d = pA%d[%d] * x%d;\n", spc, 
                         k%lat, j, *i, jx);
         else fprintf(fpout, "%s   m%d = *pA%d * x%d;\n", spc, k%lat, j, jx);
      }
      if (++xc[jx] == mu)
      {
         xc[jx] = 0;
         fprintf(fpout, "%s   pA%d += incAn;\n", spc, j);
         if (jx == 0)
         {
            if (Xregs == 1) fprintf(fpout, "%s   x++;\n", spc);
            else fprintf(fpout, "%s   x += %d;\n", spc, Xregs);
            if (!DRAIN) fprintf(fpout, "%s   x0 = *x;\n", spc);
         }
         else if (!DRAIN) fprintf(fpout, "%s   x%d = x[%d];\n", spc, jx, jx);
      }
      if (++(*jj) == Ydup)
      {
         *jj = 0;
         if (++(*i) == mu)
         {
            *i = 0;
            *J += Ydup;
            if (*J == nu) 
            {
               *J = 0;
               if (DRAIN) MUL = 0;
            }
         }
      }
   }
}

void mvXloop(char *spc, int mu, int nu, int Xregs, int Ydup, int lat, 
             int TRANS, int maxM)
{
   int i, j, J, jj, k;
   int *xc;

   xc = malloc(Xregs*sizeof(int));
   for (k=0; k < Xregs; k++) xc[k] = 0;
   fprintf(fpout, "%s   x0 = *x;\n", spc);
   for (k=1; k < Xregs; k++) fprintf(fpout, "%s   x%d = x[%d];\n", spc, k, k);

   i = j = J = jj = 0;
   mvmuXnu_N(spc, mu, nu, Ydup, lat, Xregs, lat, 0, &i, &J, &jj, xc);
   fprintf(fpout, "%s   do\n%s   {\n", spc, spc);
   spc -= 3;
   mvmuXnu_N(spc, mu, nu, Ydup, lat, Xregs, mu*nu, 0, &i, &J, &jj, xc);
   spc += 3;
   fprintf(fpout, "%s   }\n%s   while(x != stX0);\n", spc, spc);
   fprintf(fpout, "/*\n *%s Drain the pipe\n */\n", spc);
   mvmuXnu_N(spc, mu, nu, Ydup, lat, Xregs, mu*nu, 1, &i, &J, &jj, xc);
}

void mvXloop_ma(char *spc, int mu, int nu, int Xregs, int Ydup, int lat,
                int TRANS, int maxM)
{
   int j, nuA;
   MUXNU mvmuXnu;

   if (TRANS)
   {
      mvmuXnu = mvmuXnu_T_ma;
      nuA = mu;
   }
   else
   {
      mvmuXnu = mvmuXnu_N_ma;
      nuA = nu;
   }
   fprintf(fpout, "%s   do\n%s   {\n", spc, spc);
   spc -= 3;
   mvmuXnu(spc, mu, nu, Xregs, Ydup, maxM);
   for (j=0; j < nuA; j++) fprintf(fpout, "%s   pA%d += incAn;\n", spc, j);
   if (nu != 1) fprintf(fpout, "%s   x += %d;\n", spc, nu);
   spc += 3;
   if (nu == 1) fprintf(fpout, "%s   }\n%s   while(++x != stX0);\n", spc, spc);
   else fprintf(fpout, "%s   }\n%s   while(x != stX0);\n", spc, spc);
}

char **GetYs(int mu, int Yinc1)
{
   char **Ys;
   int k;

   Ys = malloc(mu*sizeof(char*));
   assert(Ys);
   for (k=0; k < mu; k++) 
   {
      Ys[k] = malloc(64*sizeof(char));
      assert(Ys[k]);
   }
   if (Yinc1)
   {
      sprintf(Ys[0], "*pY0");
      for (k=1; k < mu; k++) sprintf(Ys[k], "pY0[%d]", k);
   }
   else for (k=0; k < mu; k++) sprintf(Ys[k], "*pY%d", k);
   return(Ys);
}
void FreeYs(char **Ys, int mu)
{
   int k;
   for (k=0; k < mu; k++) free(Ys[k]);
   free(Ys);
}

void mvRegYass(char *spc, int alpha, int beta, int mu, int Yinc1, int Ydup)
{
   char **Ys;
   int i, j, k;

   Ys = GetYs(mu, Yinc1);
   if (alpha == 1 && beta != 0)
   {
      for (i=0; i < mu; i++)
      {
         fprintf(fpout, "%s   y%d_0 = %s;\n", spc, i, Ys[i]);
         if (beta == -1) fprintf(fpout, "%s   y%d_0 = -y%d_0;\n", spc, i, i);
         else if (beta != 1) fprintf(fpout, "%s   y%d_0 *= beta;\n", spc, i);
      }
      j = 1;
   }
   else j = 0;
   if (Ydup > j)
   {
      fprintf(fpout, "%s   ", spc);
      for (i=0; i < mu; i++)
         for (k=j; k < Ydup; k++)
            fprintf(fpout, "y%d_%d = ", i, k);
      fprintf(fpout, "0.0;\n");
   }
   FreeYs(Ys, mu);
}

void mvYass(char *spc, int TA, int alpha, int beta, int mu, int nu, int Yinc1,
            int muladd, int lat, int Ydup, int Xregs)
{
   char **Ys, op[32], al[8];
   int j, k, betaX=0;

   Ys = GetYs(mu, Yinc1);
   if (alpha == 1) /* al[0] = '\0'; */
   {
      for (j=0; j < mu; j++) 
      {
         fprintf(fpout, "%s   %s = ", spc, Ys[j]);
         fprintf(fpout, "y%d_0", j);
         for (k=1; k < Ydup; k++) fprintf(fpout, " + y%d_%d", j, k);
         fprintf(fpout, ";\n");
      }
      FreeYs(Ys, mu);
      return;
   }
   else if (alpha == -1) { al[0] = '-'; al[1] = '\0'; }
   else sprintf(al, "alpha*");

   for (j=0; j < mu; j++)
   {
      if (beta == 1) sprintf(op, "+=");
      else if (beta == -1) sprintf(op, " = -%s +", Ys[j]);
      else sprintf(op, " = beta * %s +", Ys[j]);
      fprintf(fpout, "%s   %s %s %s", spc, Ys[j], op, al);
      if (Ydup == 1) fprintf(fpout, "y%d_0", j);
      else
      {
         fprintf(fpout, "(y%d_0", j);
         for (k=1; k < Ydup; k++) fprintf(fpout, " + y%d_%d", j, k);
         fprintf(fpout, ")");
      }
      fprintf(fpout, ";\n");
   }
   FreeYs(Ys, mu);
}

void mvYinc(char *spc, int TA, int mu, int nu, int Yinc1, int Ydup)
{
   int i, nuA;
   if (TA) nuA = mu;
   else nuA = nu;
   for (i=0; i < nuA; i++) fprintf(fpout, "%s   pA%d += incAm;\n", spc, i);
   fprintf(fpout, "%s   x = X;\n", spc);
   if (mu == 1 && Yinc1) fprintf(fpout, "%s   pY0++;\n", spc);
   else
   {
      if (!Yinc1)
         for (i=1; i < mu; i++) fprintf(fpout, "%s   pY%d += incY;\n", spc, i);
      fprintf(fpout, "%s   pY0 += incY;\n", spc);
   }
}

void Yloop(char *spc, int CLEANUP, int TA, int alpha, int beta, int mu, int nu,
           int Yinc1, int muladd, int lat, int Ydup, int Xregs, int maxM)
{
   void (*mvxloop)(char *spc, int mu, int nu, int Xregs, int Ydup, int lat,
                   int TRANS, int maxM);
   if (muladd) mvxloop = mvXloop_ma;
   else mvxloop = mvXloop;
   fprintf(fpout, "%s   do /* Y-loop */\n%s   {\n", spc, spc);
   spc -= 3;
   mvRegYass(spc, alpha, beta, mu, Yinc1, Ydup);
   mvxloop(spc, mu, nu, Xregs, Ydup, lat, TA, maxM);
   if (CLEANUP)
   {
      if (TA) mvXclean(spc, mvmuXnu_T_ma, mu, nu, Xregs, Ydup, maxM);
      else mvXclean(spc, mvmuXnu_N_ma, mu, nu, Xregs, Ydup, maxM);
   }
   mvYass(spc, TA, alpha, beta, mu, nu, Yinc1, muladd, lat, Ydup, Xregs);
   mvYinc(spc, TA, mu, nu, Yinc1, Ydup);
   spc += 3;
   fprintf(fpout, "%s   }\n%s   while(pY0 != stY0);\n", spc, spc);
}

void mvYclean(char *type, char *scal, char pre, int TA, int alpha, int beta,
              int mu, int nu, int Yinc1, int muladd, int lat, int Ydup, 
              int Xregs, int maxM)
{
   char *spcs="                              ";
   char *spc = spcs+30;
   char ct='N';
   int i, j, pwr2_n, nuA;
   void (*mvxloop)(char *spc, int mu, int nu, int Xregs, int Ydup, int lat,
                   int TRANS, int maxM);

   if (muladd) mvxloop = mvXloop_ma;
   else mvxloop = mvXloop;
   if (TA) ct = 'T';
   fprintf(fpout, "void ATL_%cmvY_%c_%d(const int N, const %s *A, const int lda, const %s *X, %s *pY0)", pre, ct, mu, type, type, type);
   fprintf(fpout, "/*\n * Cleanup code for last %d elements of Y\n */\n", mu);
   fprintf(fpout, "{\n");

   pwr2_n = GetPower2(nu);
   if (pwr2_n) fprintf(fpout, "   const int n = ( (N >> %d) << %d );\n",
                       pwr2_n, pwr2_n);
   else if (nu > 1) fprintf(fpout, "   const int n = (N/%d)*%d;\n", nu, nu);
   else fprintf(fpout, "   #define n N\n");
   if (nu > 1) fprintf(fpout, "   const int nr = N - n;\n");
   if (TA)
   {
      nuA = mu;
      fprintf(fpout, "   #define incAn %d\n", nu);
   }
   else
   {
      nuA = nu;
      if (nu == 1) fprintf(fpout, "   #define incAn lda\n");
      else if (pwr2_n) fprintf(fpout, "   const int incAn=(lda<<%d);\n", pwr2_n);
      else fprintf(fpout, "   const int incAn=(lda*%d);\n", nu);
   }
   if (muladd) fprintf(fpout, "   const %s *x=X, *stX0 = X + n;\n", type);
   else fprintf(fpout, "   const %s *x=X, *stX0 = X + n-%d;\n", type, nu);
   fprintf(fpout, "   const %s *pA0=A", type);
      for (j=1; j < nuA; j++) fprintf(fpout, ", *pA%d = pA%d+lda", j, j-1);
   fprintf(fpout, ";\n");
   fprintf(fpout, "   register %s y0_0", type);
   for (j=1; j < Ydup; j++) fprintf(fpout, ", y0_%d", j);
   for (i=1; i < mu; i++) 
      for (j=0; j < Ydup; j++) fprintf(fpout, ", y%d_%d", i, j);
   for (i=0; i < Xregs; i++) fprintf(fpout, ", x%d", i);
   if (!muladd) for (i=0; i < lat; i++) fprintf(fpout, ", m%d", i);
   fprintf(fpout, ";\n\n");
   mvRegYass(spc, alpha, beta, mu, Yinc1, Ydup);
   if (nu > 1)
   {
      fprintf(fpout, "   if (n)\n   {\n");
      spc -= 3;
   }
   mvxloop(spc, mu, nu, Xregs, Ydup, lat, TA, maxM);
   if (nu > 1)
   {
      spc += 3;
      fprintf(fpout, "   }\n");
      if (TA) mvXclean(spc, mvmuXnu_T_ma, mu, nu, Xregs, Ydup, maxM);
      else mvXclean(spc, mvmuXnu_N_ma, mu, nu, Xregs, Ydup, maxM);
   }
   mvYass(spc, TA, 1, 1, mu, nu, 1, muladd, lat, Ydup, Xregs);
   fprintf(fpout, "}\n");
}

@beginskip
void mvXrclean(char *type, char *scal, char pre, int TA, int alpha, int beta,
               int mu, int nu, int Xinc1, int Yinc1, int muladd, int lat, 
               int Ydup, int maxM)
{
   char *spcs="                              ";
   char *spc = spcs+30;
   char ct='N';
   int i, j, pwr2_m, muA;
   MUXNU mvmuXnu;

   if (TA) ct = 'T';
   fprintf(fpout, "void ATL_%cmvX_%c_%d(const int N, const %s *A, const int lda, const %s *X, %s *pY0)", pre, ct, nu, type, type, type);
   fprintf(fpout, "/*\n * Cleanup code for %d elements of X\n */\n", nu);
   fprintf(fpout, "{\n");

   pwr2_m = GetPower2(mu);
   if (pwr2_m) fprintf(fpout, "   const int m = ( (M >> %d) << %d );\n",
                       pwr2_m, pwr2_m);
   else if (mu > 1) fprintf(fpout, "   const int m = (N/%d)*%d;\n", mu, mu);
   else fprintf(fpout, "   #define m M\n");
   if (nu > 1) fprintf(fpout, "   const int mr = M - m;\n");
   if (TA)
   {
      nuA = mu;
      if (mu == 1) fprintf(fpout, "   #define incA lda\n");
      else if (pwr2_m) fprintf(fpout, "   const int incA=(lda<<%d);\n", pwr2_m);
      else fprintf(fpout, "   const int incA=(lda*%d);\n", mu);
      mvmuXnu = mvmuXnu_T;
   }
   else
   {
      nuA = nu;
      fprintf(fpout, "   #define incAn %d\n", nu);
      mvmuXnu = mvmuXnu_N;
   }
   fprintf(fpout, "   const %s *y=Y, *stY0 = Y + m;\n", type);
   fprintf(fpout, "   const %s *pA0=A", type);
      for (j=1; j < nuA; j++) fprintf(fpout, ", *pA%d = pA%d+lda", j, j-1);
   fprintf(fpout, ";\n");
   fprintf(fpout, "   register %s y0_0", type);
   for (j=1; j < Ydup; j++) fprintf(fpout, ", y0_%d", j);
   for (i=1; i < mu; i++) 
      for (j=0; j < Ydup; j++) fprintf(fpout, ", y%d_%d", i, j);
   for (i=0; i < nu; i++) fprintf(fpout, ", x%d", i);
   if (!muladd) for (i=0; i < lat; i++) fprintf(fpout, ", m%d", i);
   fprintf(fpout, ";\n\n");

   fprintf(fpout, "   x0 = *x;\n");
   if (Xinc1) for(i=1; i < nu; i++) fprintf(fpout, "   x%d = x[%d];\n", i);
   else for (i=1; i < nu; i++)
           fprintf(fpout, "   x%d = x[%s];\n", i, GetInc(i, "incX"));
   mvRegYass(spc, alpha, beta, mu, Yinc1, Ydup);
   if (mu > 1)
   {
      fprintf(fpout, "   if (m)\n   {\n");
      spc -= 3;
   }
   fprintf(fpout, "%s   do   /* Y-loop */\n%s   {\n", spc, spc);
   spc -= 3;
   mvmuXnu(spc, mu, nu, -nu, Ydup, maxM);
   mvYass(spc, TA, 1, 1, mu, nu, 1, muladd, lat, Ydup, Xregs);
   mvYinc(spc, TA, mu, nu, Yinc1, Ydup);
   spc += 3;
   fprintf(fpout, "%s   }\n%s   while(pY0 != stY0);\n", spc, spc);
   if (mu > 1)
   {
/* HERE HERE HERE */
      spc += 3;
      fprintf(fpout, "   }\n");
      fprintf(fpout, "   if (mr)\n   {\n");
      spc -= 3;
      fprintf(fpout, "%s   switch(mr)\n%s   {\n", spc, spc);
      for (i=1; i < mu; i++)
      {
         fprintf(fpout, "%s   case %d:\n", spc, i);
         fprintf(fpout, "%s      break\n", spc);
      }
      fprintf(fpout, "%s   }\n", spc);
      spc += 3;
      fprintf(fpout, "   }\n");
   }
   fprintf(fpout, "}\n");
}
@endskip

void Ycleanup(char *spc, char pre, int TA, char *remainder, int beta, int mu, 
              int nu, int Yinc1, int Ydup)
{
   char *sp;
   char ct='N';
   int i, j;

   if (TA) ct = 'T';
   fprintf(fpout, "%s   if (%s)\n%s   {\n", spc, remainder, spc);
   spc -= 3;
   fprintf(fpout, "%s   switch(%s)\n%s   {\n", spc, remainder, spc);
   for (i=1; i < mu; i++)
   {
      fprintf(fpout, "%s   case %d:\n", spc, i);
      if (Yinc1)
      {
         if (beta == 0)
         {
            fprintf(fpout, "%s      *pY0 = ", spc);
            for (j=1; j < i; j++) fprintf(fpout, "pY0[%d] = ", j);
            fprintf(fpout, " 0.0;\n");
         }
         else if (beta == -1)
         {
               fprintf(fpout, "%s      *pY0 = -(*pY0);\n", spc);
               for (j=1; j < i; j++)
                  fprintf(fpout, "%s   pY0[%d] = -pY0[%d];\n", spc, j);
         }
         else if (beta != 1)
         {
            fprintf(fpout, "%s      *pY0 *= beta;\n", spc);
            for (j=1; j < i; j++)
               fprintf(fpout, "%s   pY0[%d] *= beta;\n", spc, j);
         }
         fprintf(fpout, "%s      ATL_%cmvY_%c_%d(N, pA0, lda, X, pY0);\n",
                 spc, pre, ct, i);
      }
      else
      {
         fprintf(fpout, "%s      ATL_%cmvY_%c_%d(N, pA0, lda, X, yy);\n",
                 spc, pre, ct, i);
         if (beta == 0)
         {
            fprintf(fpout, "%s      *pY0 = *yy;\n", spc);
            for (j=1; j < i; j++)
               fprintf(fpout, "%s   pY0[%s] = yy[%d];\n", spc, 
                       GetInc(j, "incY1"), j);
         }
         else if (beta == 1)
         {
            fprintf(fpout, "%s      *pY0 += *yy;\n", spc);
            for (j=1; j < i; j++)
               fprintf(fpout, "%s   pY0[%s] += yy[%d];\n", spc, 
                       GetInc(j, "incY1"), j);
         }
         else if (beta == -1)
         {
            fprintf(fpout, "%s      *pY0 = *yy - *pY0;\n", spc);
            for (j=1; j < i; j++)
            {
               sp = GetInc(j, "incY1");
               fprintf(fpout, "%s      pY0[%s] = yy[%d] - pY0[%s];\n", 
                       spc, sp, j, sp);
            }
         }
         else
         {
            fprintf(fpout, "%s      *pY0 = beta * *pY0 + *yy;\n", spc);
            for (j=1; j < i; j++)
            {
               sp = GetInc(j, "incY1");
               fprintf(fpout, "%s      pY0[%s] = beta * pY0[%s] + yy[%d];\n", 
                       spc, sp, sp, j);
            }
         }
      }
      fprintf(fpout, "%s      break;\n", spc);
   }
   fprintf(fpout, "%s   }\n", spc);
   
   if (!TA)
   {
      for (i=0; i < nu; i++) fprintf(fpout, "%s   pA%d += align;\n", spc, i);
      if (!Yinc1) 
      {
         for (i=0; i < mu; i++) 
            fprintf(fpout, "%s   pY%d += align*incY1;\n", spc, i);
      }
      else fprintf(fpout, "%s   pY0 += align;\n", spc);
      fprintf(fpout, "%s   stY0 += align;\n", spc);
   }
   spc += 3;
   fprintf(fpout, "%s   }\n", spc);
}
void emitmv(char *type, char *scal, char pre, int TA, int alpha, int beta,
            int mu, int nu, int Yinc1, int muladd, int lat, int Ydup, 
            int Xregs, int maxM)
{
   char *spcs = "                              ";
   char *spc = spcs+30;
   char trans='N';
   int i, j, muA, nuA, pwr2_m, pwr2_n;
   int BETAX;
   MUXNU mvmuXnu;

   if (TA)
   {
      trans='T';
      muA = nu;
      nuA = mu;
      mvmuXnu = mvmuXnu_T_ma;
   }
   else
   {
      muA = mu;
      nuA = nu;
      mvmuXnu = mvmuXnu_N_ma;
   }
   pwr2_m = GetPower2(mu);
   pwr2_n = GetPower2(nu);
   fprintf(fpout, "#include \"atlas_misc.h\"\n");
   fprintf(fpout, "void ATL_%cgemv_%c_", pre, trans);
   if (alpha == 1)  fprintf(fpout, "a1_");
   else if (alpha == -1)  fprintf(fpout, "an1_");
   else fprintf(fpout, "aX_");
   fprintf(fpout, "x1_");
   if ( (beta == 1) || (!beta) ) fprintf(fpout, "b%d_", beta);
   else if (beta == -1) fprintf(fpout, "bn1_");
   else
   {
      BETAX = 1;
      fprintf(fpout, "bX_");
   }
   if (Yinc1) fprintf(fpout, "y1");
   else fprintf(fpout, "yX");
   fprintf(fpout, "(const int M, const int N, const %s alpha, const %s *A, const int lda, const %s *X, const %s beta, %s *Y, const int incY1)\n{\n",
           scal, type, type, scal, type);
   if (TA || mu == 1)
   {
      if (pwr2_m) fprintf(fpout, "   const int m = ( (M >> %d) << %d );\n", 
                          pwr2_m, pwr2_m);
      else if (mu > 1) fprintf(fpout, "   const int m = ( (M/%d)*%d );\n", 
                               mu, mu);
      else fprintf(fpout, "   #define m M\n");
      if (mu > 1) fprintf(fpout, "   const int mr = M - m;\n");
   }
   else
   {
      fprintf(fpout, "   #if(ATL_%cMulBySize(%d) == ATL_MulByCachelen(ATL_DivByCachelen(ATL_%cMulBySize(%d))))\n", pre, mu, pre, mu);
      fprintf(fpout, "      const int align=Mmin(M,ATL_DivBySize((((size_t)A) - ATL_MulByCachelen(ATL_DivByCachelen((size_t)A)))));\n");
      fprintf(fpout, "   #else\n");
      fprintf(fpout, "      #define align 0\n");
      fprintf(fpout, "   #endif\n");
      if (pwr2_m) 
         fprintf(fpout, "   const int m = ( ((M-align) >> %d) << %d );\n", 
                 pwr2_m, pwr2_m);
      else if (mu > 1) 
         fprintf(fpout, "   const int m = ( ((M-align)/%d)*%d );\n", mu, mu);
      else fprintf(fpout, "   const int m = M - align;\n");
      if (mu > 1) fprintf(fpout, "   const int mr = M - m - align;\n");
   }

   if (pwr2_n) fprintf(fpout, "   const int n = ( (N >> %d) << %d );\n",
                       pwr2_n, pwr2_n);
   else if (nu > 1) fprintf(fpout, "   const int n = (N/%d)*%d;\n", nu, nu);
   else fprintf(fpout, "   #define n N\n");
   if (nu > 1) fprintf(fpout, "   const int nr = N - n;\n");

   if (!Yinc1)
   {
      if (mu == 1) fprintf(fpout, "   #define incY incY1\n");
      else
      {
         if (pwr2_m) fprintf(fpout, "   const int incY=(incY1<<%d);\n", pwr2_m);
         else fprintf(fpout, "   const int incY=(incY1*%d);\n", mu);
      }
   }
   else fprintf(fpout, "   #define incY %d\n", mu);
   
   if (muladd) fprintf(fpout, "   const %s *x=X, *stX0 = X + n;\n", type);
   else fprintf(fpout, "   const %s *x=X, *stX0 = X + n-%d;\n", type, mu);
   if (nu > 1) fprintf(fpout, "   const %s *stX = X + N;\n", type);

   if (Yinc1)
   {
      fprintf(fpout, "   %s *stY0 = Y + m;\n", type);
      if (mu > 1) fprintf(fpout, "   %s *stY = Y + M;\n", type);
   }
   else
   {
      if (pwr2_m) fprintf(fpout, "   %s *stY0 = Y + m*incY0;\n", type);
      if (mu > 1) fprintf(fpout, "   %s *stY = Y + M*incY0;\n", type);
   }

   fprintf(fpout, "   %s *pY0 = Y", type);
   if (!Yinc1)
      for (i=1; i < mu; i++) fprintf(fpout, ", pY%d = pY%d+incY1", i, i-1);
   fprintf(fpout, ";\n");
   if (!Yinc1)
   {
      fprintf(fpout, "   %s yy[%d] = {0.0", type, mu);
      for(i=1; i < mu; i++) fprintf(fpout, ", 0.0");
      fprintf(fpout, "}\n");
   }

   fprintf(fpout, "   const %s *pA0=A", type);
      for (j=1; j < nuA; j++) fprintf(fpout, ", *pA%d = pA%d+lda", j, j-1);
   fprintf(fpout, ";\n");
   if (TA)
   {
      fprintf(fpout, "   #define incAn %d\n", nu);
      if (mu == 1) fprintf(fpout, "   const int incAm = lda - n;\n");
      else if (pwr2_m)
         fprintf(fpout, "   const int incAm = (lda<<%d) - n;\n", pwr2_m);
      else fprintf(fpout, "   const int incAm = %d*lda - n;\n", mu);
   }
   else
   {
      if (nu == 1) fprintf(fpout, "   #define incAn lda\n");
      else if (pwr2_n) fprintf(fpout, "   const int incAn=(lda<<%d);\n", pwr2_n);
      else fprintf(fpout, "   const int incAn=(lda*%d);\n", nu);
      fprintf(fpout, "   const int incAm=(%d - n*lda);\n", mu);
   }
   fprintf(fpout, "   register %s y0_0", type);
   for (j=1; j < Ydup; j++) fprintf(fpout, ", y0_%d", j);
   for (i=1; i < mu; i++) 
      for (j=0; j < Ydup; j++) fprintf(fpout, ", y%d_%d", i, j);
   for (i=0; i < Xregs; i++) fprintf(fpout, ", x%d", i);
   if (!muladd) for (i=0; i < lat; i++) fprintf(fpout, ", m%d", i);
   fprintf(fpout, ";\n");

   fprintf(fpout, "\n");
   if (mu > 1)
   {
      if (!TA && mu > 1) 
      {
      fprintf(fpout, "%s   #if(ATL_%cMulBySize(%d) == ATL_MulByCachelen(ATL_DivByCachelen(ATL_%cMulBySize(%d))))\n", spc, pre, mu, pre, mu);
         Ycleanup(spc-3, pre, 0, "align", beta, mu, nu, Yinc1, Ydup);
         fprintf(fpout, "%s   #endif\n", spc);
      }
      fprintf(fpout, "%s   if (m)\n%s   {\n",spc, spc);
      spc -= 3;
   }
   if (nu > 1)
   {
      fprintf(fpout, "%s   if (!nr) /* No N-loop cleanup required */\n%s   {\n",
              spc, spc);
      spc -= 3;
   }
   Yloop(spc, 0, TA, alpha, beta, mu, nu, Yinc1, muladd, lat, Ydup, Xregs,maxM);
   if (nu > 1)
   {
      spc += 3;
      fprintf(fpout, "%s   }\n", spc);
      fprintf(fpout, "%s   else if (n) /* if we have a X loop & cleanup case */\n", spc);
      fprintf(fpout, "%s   {\n", spc);
      spc -= 3;

      Yloop(spc, 1, TA, alpha, beta, mu, nu, Yinc1, muladd, lat, Ydup,
            Xregs, maxM);

      spc += 3;
      fprintf(fpout, "%s   }%s\n%s   else /* only X cleanup */\n%s   {\n", 
              spc, spc, spc, spc);

      spc -= 3;
      fprintf(fpout, "%s   do /* Y-loop */\n%s   {\n", spc, spc);
      spc -= 3;
      mvRegYass(spc, alpha, beta, mu, Yinc1, Ydup);
      mvXclean(spc, mvmuXnu, mu, nu, Xregs, Ydup, maxM);
      mvYass(spc, TA, alpha, beta, mu, nu, Yinc1, muladd, lat, Ydup, Xregs);
      mvYinc(spc, TA, mu, nu, Yinc1, Ydup);
      spc += 3;
      fprintf(fpout, "%s   }\n%s   while(pY0 != stY0);\n", spc, spc);

      spc += 3;
      fprintf(fpout, "%s   }  /* end X-loop cleanup possibilities */\n", spc);
   }
   if (mu > 1)
   {
      spc += 3;
      fprintf(fpout, "%s   } /* end if (m) */\n", spc);
      Ycleanup(spc, pre, TA, "mr", beta, mu, nu, Yinc1, Ydup);
   }
   fprintf(fpout, "}\n");
}
void PrintUsage(char *xnam)
{
   fprintf(stderr, "\n\nUsage: %s [-p <s/d/c/z>] [-t <n/t/c>] [-a <1,-1,0,X> [-b <1,-1,0,X>] [-m <mu>] [-n <nu>] [ -y <1,0>] -M <muladd> -d <Ydup> -r <Xregs> [-f <filename>] [-l <lat>] -A <maxM> [-h] [-H[-]]\n", xnam);
   exit(-1);
}

void GetFlags(int nargs, char *args[], char **type, char **scal, char *pre,
              int *TA, int *alpha, int *beta, int *muladd, int *Xregs, int *mu,
              int *nu, int *Ydup, int *Yinc1, int *lat, int *maxM,
              int *EmitMainHeader, int *EmitHeader, int *EmitClean)
{
   int i;

/*
 * set defaults 
 */
   *maxM = (-1);
   *Xregs = 1;
   *muladd = 1;
   *Ydup = 1;
   *lat = 1;
   *EmitMainHeader = 0;
   *EmitHeader = 0;
   *EmitClean = 0;
   *type = malloc(16);
   *scal = *type + 7;

   *pre = 'd';
   *TA = 0;
   *alpha = 1.0;
   *beta = 1.0;
   *mu = 1;
   *nu = 1;
   *Yinc1 = 1;
   fpout = stdout;

/*
 * Find user settings
 */
   for (i=1; i < nargs; i++)
   {
      if (*args[i] != '-') PrintUsage(args[0]);
      switch(args[i][1])
      {
         case 'A':
            *maxM = atoi(args[++i]);
            break;
         case 'C':
            *EmitClean = 1;
            break;
         case 'H':
            if (args[i][2] == '-') *EmitMainHeader = 1;
            else *EmitHeader = 1;
            break;
         case 'f':
            fpout = fopen(args[++i], "w");
            assert(fpout != NULL);
            break;
         case 'p':
            *pre = *args[++i];
            break;
         case 't':
            switch(*args[++i])
            {
            case 't':
            case 'T':
               *TA = 1;
               break;
            case 'c':
            case 'C':
               *TA = -1;
               break;
            case 'n':
            case 'N':
               *TA = 0;
               break;
            default:
               fprintf(stderr, "nonsensical TRANS setting '%c', setting to 'n'\n", *args[i]);
               *TA = 0;
            }
            break;
         case 'r':
            *Xregs = atoi(args[++i]);
            break;
         case 'd':
            *Ydup = atoi(args[++i]);
            break;
         case 'M':
            *muladd = atoi(args[++i]);
            break;
         case 'l':
            *lat = atoi(args[++i]);
            break;
         case 'a':
            *alpha = atoi(args[++i]);
            break;
         case 'b':
            *beta = atoi(args[++i]);
            break;
         case 'm':
            *mu = atoi(args[++i]);
            break;
         case 'n':
            *nu = atoi(args[++i]);
            break;
         case 'y':
            *Yinc1 = atoi(args[++i]);
            break;
         default:
         case 'h':
            PrintUsage(args[0]);
      }
   }

   if (*maxM == -1) *maxM = *mu;
   switch(*pre)
   {
   case 's':
      sprintf(*type, "float");
      sprintf(*scal, "float");
      break;
   default:
      fprintf(stderr, "nonsensical PRE setting '%c'; setting to 'd'\n", *pre);
      *pre = 'd';
   case 'd':
      sprintf(*type, "double");
      sprintf(*scal, "double");
      break;
   case 'c':
      sprintf(*type, "float");
      sprintf(*scal, "float *");
      break;
   case 'z':
      sprintf(*type, "double");
      sprintf(*scal, "double *");
      break;
   }
}

int GetL1CacheSize()
{
   FILE *L1f;
   char ln[80];
   int L1Size;

   L1f = fopen("res/L1CacheSize", "r");
   if (!L1f)
   {
      fprintf(stderr, "No file res/L1CacheSize!!\n");
      fprintf(stderr, "  You must run xmvsearch before installation can proceed.  Aborting.\n");
      exit(-1);
   }
   fscanf(L1f, "%d", &L1Size);
   fclose(L1f);
   fprintf(stderr, "\n      Read in L1 Cache size as = %dKB.\n",L1Size);
   return(L1Size);
}

void GetTLBinfo(int *N, int *pgsz)
{
   FILE *L1f;
   char ln[80];
   int L1Size;

   L1f = fopen("res/TLB", "r");
   if (!L1f)
   {
      sprintf(ln, "make RunTLB\n");
      assert(system(ln) == 0);
      L1f = fopen("res/TLB", "r");
      assert(L1f != NULL);
   }
   fscanf(L1f, "%d", N);
   fscanf(L1f, "%d", pgsz);
   fclose(L1f);
   fprintf(stderr, "\n      Read in # TLB entries=%d, page size=%dbytes.\n",
           *N, *pgsz);
}

void emit_mhead(char pre)
{
   int i, N, pgsz;

   switch(pre)
   {
   case 's':
      i = sizeof(float);
      break;
   case 'd':
      i = sizeof(double);
      break;
   case 'c':
      i = 2*sizeof(float);
      break;
   case 'z':
      i = 2*sizeof(double);
      break;
   }
   GetTLBinfo(&N, &pgsz);

   fprintf(fpout, "#include \"dmv_N.h\"\n");
   fprintf(fpout, "#include \"dmv_T.h\"\n");
   fprintf(fpout, "#define ATL_nTLB %d\n", N);
   fprintf(fpout, "#define ATL_PageSize %d\n", pgsz/i);
}

void emit_head(char pre, int TA, int mu, int nu)
{
   char trans;
   int i, n, isize, cl=mu;

   switch(pre)
   {
   case 's':
      isize = sizeof(float);
      if (cl < 8) cl = 8;
      break;
   case 'd':
      isize = sizeof(double);
      if (cl < 4) cl = 4;
      break;
   case 'q':
      isize = sizeof(long double);
      if (cl < 4) cl = 4;
      break;
   case 'c':
      isize = 2*sizeof(float);
      if (cl < 4) cl = 4;
      break;
   case 'z':
      isize = 2*sizeof(double);
      if (cl < 2) cl = 2;
      break;
   }
   i = (GetL1CacheSize()*1024) / isize;
   if (TA)
   {
      n = (11*i) / (12*(2*mu + 1));  /* fill cache 11/12 full */
      i = n - n % mu;
      if (!i) i = n = mu;
      fprintf(fpout, "#define MV_T_MAXN    %d\n", n);
      fprintf(fpout, "#define MV_T_MAXN_MU %d\n", i);
      trans = 'T';
   }
   else
   {
      if (cl < mu) cl = mu;
      n = (11*i) / (12*(2*cl + 1));  /* fill cache 11/12 full */
      i = n - n % mu;
      fprintf(fpout, "#define MV_N_MAXN    %d\n", n);
      fprintf(fpout, "#define MV_N_MAXN_MU %d\n", i);
      trans = 'N';
   }
   fprintf(fpout, "#define MV_%c_MU %d\n", trans, mu);
   fprintf(fpout, "#define MV_%c_NU %d\n", trans, nu);
}

int FindGoodLat(int UR, int lat)
{
  int k, biglat=UR, smlat=1;

  if (lat == 0) return(1);
  if (UR % lat == 0) return(lat);
  if (lat > UR) return(UR);
  for (k=lat; k < UR; k++) if (UR%k == 0 && k < biglat) biglat = k;
  for (k=lat-1; k >= 2; k--) if (UR%k == 0 && k > smlat) smlat = k;
  if (biglat-lat > lat-smlat) return(smlat);
  else return(biglat);
}

int main(int nargs, char *args[])
{
   char *type, *scal, pre;
   int TA, alpha, beta, mu, nu, Yinc1, EmitHeader, EmitMainHeader, lat;
   int Xregs, Ydup, muladd, EmitClean, maxM;
   int i, k;

   GetFlags(nargs, args, &type, &scal, &pre, &TA, &alpha, &beta, &muladd, 
            &Xregs, &mu, &nu, &Ydup, &Yinc1, &lat, &maxM,
            &EmitMainHeader, &EmitHeader, &EmitClean);
   assert(mu > 0);
   assert(nu > 0);
   assert(Xregs > 0);
   assert(Ydup > 0);
   assert(maxM > 0);
   if (Ydup > nu) Ydup = nu;
   else while (nu%Ydup) Ydup--;
   if (Xregs < Ydup) Xregs = Ydup;
   if (EmitMainHeader) emit_mhead(pre);
   else if (EmitHeader) emit_head(pre, TA, mu, nu);
   else if (EmitClean) mvYclean(type, scal, pre, TA, alpha, beta, mu, nu, Yinc1,
                                muladd, lat, Ydup, Xregs, maxM);
   else
   {
      if (beta == 1 && Yinc1 == 1)
      {
         for (i=1; i < mu; i++)
         {
            k = FindGoodLat(i*nu, lat);
            mvYclean(type, scal, pre, TA, alpha, beta, i, nu, Yinc1,
                     muladd, k, Ydup, Xregs, Mmin(i,maxM));
         }
      }
      emitmv(type, scal, pre, TA, alpha, beta, mu, nu, Yinc1, muladd, lat, 
             Ydup, Xregs, maxM);
   }
   if ( (fpout != stderr) && (fpout != stdout) ) fclose(fpout);
   free(type);
   return(0);
}

@ROUT mvfc
@extract -b @(topd)/gen.inc what=cw
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include "atlas_misc.h"

#define dumb_seed(iseed_) srand(iseed_)
#ifndef RAND_MAX  /* rather dangerous non-ansi workaround */
   #define RAND_MAX ((unsigned long)(1<<30))
#endif
#define dumb_rand() ( 0.5 - ((double)rand())/((double)RAND_MAX) )

void PrintUsage(char *xnam)
{
   fprintf(stderr, "\n\nUsage: %s [-F <mflops>] [-N <N>] [-M <M>] [-f <filename>]\n",xnam);
   exit(-1);
}
void GetFlags(int nargs, char *args[], int *M, int *N, int *mflops, 
              FILE **fpout)
{
   int Nset=0, i;
/*
 * set defaults
 */
   *M = *N = 100;
   *mflops = 55;
   *fpout = stdout;

   for (i=1; i < nargs; i++)
   {
      if (*args[i] != '-') PrintUsage(args[0]);
      switch(args[i][1])
      {
         case 'F':
            *mflops = atoi(args[++i]);
            break;
         case 'f':
            *fpout = fopen(args[++i], "w");
            assert(*fpout != NULL);
            break;
         case 'M':
            *M = atoi(args[++i]);
            if (!Nset) *N = *M;
            break;
         case 'N':
            Nset = 1;
            *N = atoi(args[++i]);
            break;
         default:
         case 'h':
            PrintUsage(args[0]);
      }
   }
}

int main(int nargs, char *args[])
{
   char TA;
   int M, N, mflops, reps, incA, incX, incY, inc;
   int i, j, k;
   void *vp;
   TYPE *A, *a, *x, *y, *Y, *X, *st;
   FILE *fpout;
   double t0, t1, mvflops, mf;
   double time00(void);

   GetFlags(nargs, args, &M, &N, &mflops, &fpout);
   mvflops = 2.0 * M * N + M + N;
   t0 = (mflops * 1000000.0) / mvflops;
   if (t0 < 1.0) reps = 1;
   else reps = t0;
   i = ATL_DivBySize(L2SIZE);
   j = M + N + M*N;
   if (reps == 1) k = (i+j-1) / j;
   else k = i / j + 1;
   if (ATL_sizeof >= ATL_Cachelen) i = 1;
   else i = ATL_DivBySize(ATL_Cachelen);
   incA = M * N;
   incX = N;
   incY = M;
   if (incA % i) incA += i - incA%i;
   if (incX % i) incX += i - incX%i;
   if (incY % i) incY += i - incY%i;
   inc = incA + incX + incY;
   k *= inc;
   vp = malloc(ATL_MulBySize(k));
   assert(vp != NULL);
   a = A = ATL_AlignPtr(vp);
   X = x = A + incA;
   Y = y = x + incX;
   st = A + k;
#ifdef TRANSA_
   TA = 'T';
#else
   TA = 'N';
#endif

   dumb_seed(M+N);
   for (i=0; i != k; i++) A[i] = dumb_rand();

   for (k=0; k != 3; k++)
   {
      i = reps;
      t0 = time00();
      do
      {
         ATL_gemv(M, N, 1.0, A, M, x, 1.0, y, 1);
         A += inc;
         x += inc;
         y += inc;
         if (A == st) {A = a; x = X; y = Y; }
      }
      while (--i);
      t1 = time00() - t0;

      if (t1 > 0.0) mf = (mvflops * reps) / (t1 * 1000000.0);
      else t1 = 0.0;
      fprintf(stderr, "reps=%d, TA=%c, pre=%s, mu=%d, nu=%d, Xregs=%d, Ydup=%d, maxM=%d, lat=%d, muladd=%d, time=%f, mflop=%f\n",
              reps, TA, Mstr(PRE), MU, NU, XREGS, YDUP, MAXM, LAT, MULADD, t1, mf);
      fprintf(fpout, "%lf\n", mf);
      A = a;
      x = X;
      y = Y;
   }
   free(vp);
   if (fpout != stdout && fpout != stderr) fclose(fpout);
   return(0);
}
@ROUT ptgemv
#include "atlas_misc.h"
#include "dmv.h"
struct t_gemv
{
   enum ATLAS_TRANS TA;
   int M, N, lda, incX, incY;
   SCALAR alpha;
   SCALAR beta;
   TYPE *A, *X, *Y;
};

void Cptgemv(enum ATLAS_TRANS TA, int M, int N, const SCALAR alpha, 
             const TYPE *A, int lda, const TYPE *X, int incX,
             const SCALAR beta, TYPE *Y, int incY)
{
   int Np = ATL_MAXPROC;
   static struct t_gemvATL_MAXPROC];
   static pthread_t tp[ATL_MAXPROC];
   static pthread_attr_t attr;

   if (TA == AtlasNoTrans)
   {
/*
 *    Find biggest problem that will fit into L1 cache, and not cause TLB misses
 */
      k = (ATL_PageSize / lda) * ATL_nTLB;
      if (k > MV_N_MAXN) k = MV_N_MAXN_MU;
      else if (!k) k = ATL_nTLB;
/*
 *    If gemv is going to partition X anyway, see if doing so here will avoid
 *    the need later
 */
      if (k < N)
      {
         nblock = N / MV_N_MU;
         nblock1 = N / Np;
         neb = nblock - nblock1*Np;
         if (neb) n = (nblock1+1)*MV_N_MU;
         else n = nblock1*MV_N_MU + N - nblock*MV_N_MU;

         if (n <= k) /* threading keeps X in L1 cache */
         {
            return;
         }
      }
}
@ROUT GEMV
@extract -b @(topd)/gen.inc what=cw
#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <assert.h>
#include "atlas_misc.h"
#include "atlas_f77.h"
#include "dmv.h"

/*
 * Prototypes for gemv primitives
 */
@whiledef TR T N
  @whiledef YY 1
    @whiledef be 1 0
      @whiledef al 1
         @declare "void Mjoin(PATL,gemv_@(TR)_a@(al)_x1_b@(be)_y@(YY))(" y n ");"
            const@^int@^M, const@^int@^N, const@^SCALAR@^alpha, const@^TYPE@^*A, 
            const@^int@^lda, const@^TYPE@^*X, const@^SCALAR@^beta, 
            TYPE@^*Y, const@^int@^incY
         @enddeclare
      @endwhile
    @endwhile
  @endwhile
@endwhile

#ifdef ATLGEMV
   #define Cgemv Mjoin(Mjoin(PATL,C),gemv2)
   #define F77gemv Mjoin(PATL,gemv)
#else
   #define Cgemv Mjoin(Mjoin(PATL,C),gemv)
   #define F77gemv Mjoin(PRE,gemv)
#endif

void Mjoin(PATL,copy)(const int N, const TYPE *X, const int incX, 
                      TYPE *Y, const int incY)
/*
 * y <- x
 */
{
   int incx=incX, incy=incY;
   register int i, j, n=N;

   if (incx < 0)
   {
      i = N - 1;
      X += i * incx;
      Y += i * incy;
      incx = -incx;
      incy = -incy;
   }
   if (incx == 1)
   {
      if (incy == 1) for(i=0; i != n; i++) Y[i] = X[i];
      else for(j=i=0; i != n; i++, j += incy) Y[j] = X[i];
   }
   else
   {
      if (incy == 1) for(j=i=0; i != n; i++, j += incx) Y[i] = X[j];
      else for(j=i=0, n *= incx; i != n; i += incx, j += incy) Y[j] = X[i];
   }
}

void Mjoin(PATL,xpy)(const int N, const TYPE *X, const int incX, 
                     TYPE *Y, const int incY)
/*
 * y <- x + y
 */
{
   int incx=incX, incy=incY;
   register int i, j, n=N;

   if (incx < 0)
   {
      i = N - 1;
      X += i * incx;
      Y += i * incy;
      incx = -incx;
      incy = -incy;
   }
   if (incx == 1)
   {
      if (incy == 1) for(i=0; i != n; i++) Y[i] += X[i];
      else for(j=i=0; i != n; i++, j += incy) Y[j] += X[i];
   }
   else
   {
      if (incy == 1) for(j=i=0; i != n; i++, j += incx) Y[i] += X[j];
      else for(j=i=0, n *= incx; i != n; i += incx, j += incy) Y[j] += X[i];
   }
}

void Mjoin(PATL,xpby)(const int N, const TYPE *X, const int incX, 
                      const SCALAR beta0, TYPE *Y, const int incY)
/*
 * y <- x + beta*y
 */
{
   const register TYPE beta=beta0;
   int incx=incX, incy=incY;
   register int i, j, n=N;

   if (beta == 0.0) 
   {
      Mjoin(PATL,copy)(N, X, incX, Y, incY);
      return;
   }
   if (beta == 1.0)
   {
      Mjoin(PATL,xpy)(N, X, incX, Y, incY);
      return;
   }
   if (incX < 0)
   {
      i = N - 1;
      X += i * incx;
      Y += i * incy;
      incx = -incx;
      incy = -incy;
   }
   if (incx == 1)
   {
      if (incy == 1) for(i=0; i != n; i++) Y[i] = beta*Y[i] + X[i];
      else for(j=i=0; i != n; i++, j += incy) Y[j] = beta*Y[j] + X[i];
   }
   else
   {
      if (incy == 1) for(j=i=0; i != n; i++, j += incx) Y[i] = beta*Y[i] + X[j];
      else for(j=i=0, n *= incx; i != n; i += incx, j += incy) 
              Y[j] = beta*Y[j] + X[i];
   }
}

void Mjoin(PATL,ax_a1_x1_y1)(const int N, const SCALAR alpha0, const TYPE *X, 
                             const int incX, TYPE *Y, const int incY)
{
   register int i;
   for (i=0; i != N; i++) Y[i] = X[i];
}

void Mjoin(PATL,ax_aX_x1_y1)(const int N, const SCALAR alpha0, const TYPE *X, 
                             const int incX, TYPE *Y, const int incY)
{
   register int i, n=N;
   register TYPE alpha=alpha0;
   for (i=0; i < n; i++) Y[i] = alpha * X[i];
}

void Mjoin(PATL,ax_aX_xX_y1)(const int N, const SCALAR alpha0, const TYPE *X, 
                             const int incX, TYPE *Y, const int incY)
{
   register int i, j;
   const register int n=N;
   register TYPE alpha=alpha0;
   if (incX == -1)
   {
      i = N - 1;
      X -= i;
      Y += i;
      for (i=0; i != n; i++) *(Y-i) = alpha * X[i];
   }
   else for (i=j=0; i != n; i++, j += incX) Y[i] = alpha * X[j];
}

void Mjoin(PATL,ax_a1_xX_y1)(const int N, const SCALAR alpha0, const TYPE *X, 
                             const int incX, TYPE *Y, const int incY)
{
   Mjoin(PATL,copy)(N, X, incX, Y, 1);
}

void Mjoin(PATL,ax)(const int N, const SCALAR alpha0, const TYPE *X, 
                    const int incX, TYPE *Y, const int incY)
/*
 * y <- alpha*x
 */
{
   int incx=incX, incy=incY;
   register int i, j, n=N;
   const register SCALAR alpha=alpha0;

   if (incX < 0)
   {
      i = N - 1;
      X += i * incx;
      Y += i * incy;
      incx = -incx;
      incy = -incy;
   }
   if (incx == 1)
   {
      if (incy == 1) for(i=0; i != n; i++) Y[i] = alpha*X[i];
      else for(j=i=0; i != n; i++, j += incy) Y[j] = alpha*X[i];
   }
   else
   {
      if (incy == 1) for(j=i=0; i != n; i++, j += incx) Y[i] = alpha*X[j];
      else for(j=i=0, n *= incx; i != n; i += incx, j += incy) 
              Y[j] = alpha*X[i];
   }
}

void Mjoin(PATL,mxpby)(const int N, const TYPE *X, const int incX, 
                       const SCALAR beta0, TYPE *Y, const int incY)
/*
 * y <- beta*y - x, no special case for beta == 1.0, or -1.0
 */
{
   const register TYPE beta=beta0;
   int incx=incX, incy=incY;
   register int i, j, n=N;

   if (beta == 0.0)
   {
      Mjoin(PATL,ax)(N, -1.0, X, incX, Y, incY);
      return;
   }
   if (incX < 0)
   {
      i = N - 1;
      X += i * incx;
      Y += i * incy;
      incx = -incx;
      incy = -incy;
   }
   if (incx == 1)
   {
      if (incy == 1) for(i=0; i != n; i++) Y[i] = beta*Y[i] - X[i];
      else for(j=i=0; i != n; i++, j += incy) Y[j] = beta*Y[j] - X[i];
   }
   else
   {
      if (incy == 1) for(j=i=0; i != n; i++, j += incx) Y[i] = beta*Y[i] - X[j];
      else for(j=i=0, n *= incx; i != n; i += incx, j += incy) 
              Y[j] = beta*Y[j] - X[i];
   }
}

void Mjoin(PATL,axpy)(const int N, const SCALAR alpha0, const TYPE *X, 
                      const int incX, TYPE *Y, const int incY)
/*
 * y <- alpha*x + y
 */
{
   int incx=incX, incy=incY;
   register int i, j, n=N;
   const register SCALAR alpha=alpha0;

   if (incx < 0)
   {
      i = N - 1;
      X += i * incx;
      Y += i * incy;
      incx = -incx;
      incy = -incy;
   }
   if (incx == 1)
   {
      if (incy == 1) for(i=0; i != n; i++) Y[i] += alpha*X[i];
      else for(j=i=0; i != n; i++, j += incy) Y[j] += alpha*X[i];
   }
   else
   {
      if (incy == 1) for(j=i=0; i != n; i++, j += incx) Y[i] += alpha*X[j];
      else for(j=i=0, n *= incx; i != n; i += incx, j += incy) 
              Y[j] += alpha*X[i];
   }
}

void Mjoin(PATL,axpby)(const int N, const SCALAR alpha0, const TYPE *X, 
                       const int incX, const SCALAR beta0, 
                       TYPE *Y, const int incY)
/*
 * y <- beta*y + alpha * x
 */
{
   const register TYPE alpha = alpha0, beta = beta0;
   int incx=incX, incy=incY;
   register int i, j, n=N;

   if (alpha == 0.0)
   {
      Mjoin(PATL,scal)(N, beta, Y, incY);
      return;
   }
   if (alpha == 1.0)
   {
      Mjoin(PATL,xpby)(N, X, incX, beta, Y, incY);
      return;
   }
   if (alpha == -1.0)
   {
      Mjoin(PATL,mxpby)(N, X, incX, beta, Y, incY);
      return;
   }
   if (beta == 0.0)
   {
      Mjoin(PATL,ax)(N, alpha, X, incX, Y, incY);
      return;
   }
   if (beta == 1.0)
   {
      Mjoin(PATL,axpy)(N, alpha, X, incX, Y, incY);
      return;
   }
@skip   if (beta == -1.0) Mjoin(PATL,axmy)(N, alpha, X, incX, Y, incY);
   if (incX < 0)
   {
      i = N - 1;
      X += i * incx;
      Y += i * incy;
      incx = -incx;
      incy = -incy;
   }
   if (incx == 1)
   {
      if (incy == 1) for (i=0; i != n; i++) Y[i] = beta*Y[i] + alpha*X[i];
      else for (j=i=0; i != n; j += incy, i++) Y[j] = beta*Y[j] + alpha*X[i];
   }
   else /* incx == X */
   {
      if (incy == 1) 
         for (j=i=0; i != n; i++, j += incx) Y[i] = beta*Y[i] + alpha*X[j];
      else 
         for (n *= incx, j=i=0; i != n; j += incy, i += incx) 
            Y[j] = beta*Y[j] + alpha*X[i];
   }
}

typedef void (*GEMV_NB)(const int M, const SCALAR alpha, const TYPE *A, 
                        const int lda, const TYPE *x, 
                        const SCALAR beta, TYPE *Y);
void ATL_gemvN(const int M, const int N, const SCALAR alpha, const TYPE *A,
               const int lda, const TYPE *X, const int incX, const SCALAR beta,
               TYPE *Y, int incY)
{
   int i=0, n = N, nb=32, incA=lda<<5;
   static GEMV_NB gemv_bX[5] = {Mjoin(PATL,gemvN32_a1_bX), Mjoin(PATL,gemvN16_a1_bX), 
                                Mjoin(PATL,gemvN8_a1_bX), Mjoin(PATL,gemvN4_a1_bX), 
                                Mjoin(PATL,gemvN2_a1_bX), Mjoin(PATL,gemvN1_a1_bX)}
   static GEMV_NB gemv_b1[5] = {Mjoin(PATL,gemvN32_a1_b1), Mjoin(PATL,gemvN16_a1_b1), 
                                Mjoin(PATL,gemvN8_a1_b1), Mjoin(PATL,gemvN4_a1_b1), 
                                Mjoin(PATL,gemvN2_a1_b1), Mjoin(PATL,gemvN1_a1_b1)}
   static GEMV_NB gemv_b0[5] = {Mjoin(PATL,gemvN32_a1_b0), Mjoin(PATL,gemvN16_a1_b0), 
                                Mjoin(PATL,gemvN8_a1_b0), Mjoin(PATL,gemvN4_a1_b0), 
                                Mjoin(PATL,gemvN2_a1_b0), Mjoin(PATL,gemvN1_a1_b0)}
   GEMV_NB gemv;

   if (incY == 1)
   {
      if (beta == 1.0) gemv = gemv_b1;
      else if (beta == 0.0) gemv = *gemv_b0;
      else if (beta != 1.0) gemv = *gemv_bX;
   }
   else
   {
      y = malloc
   }

   do
   {
      while(n >= nb)
      {
         gemv(M, alpha, A, lda, X, beta, Y);
         X += nb;
         A += incA;
         n -= nb;
         gemv = gemv_b1[i];
      }
      nb >>= 1;
      incA >>= 1;
      i++;
      gemv++;
   }
   while(n);
}

void Cgemv(const enum ATLAS_TRANS TA, int M, int N, const SCALAR alpha, 
           const TYPE *A, int lda, const TYPE *X, int incX, 
           const SCALAR beta, TYPE *Y, int incY)
/*
 *  Note:  M = length of Y
 *         N = length of X
 */
{
   int PUT_Y;
   const int BETA0 = (beta == 0.0);
   const int NOBETA = ( (BETA0) || (beta == 1.0) );
   int incx;
   int align=0, i=2000, k;
   void *vx=NULL, *vy=NULL;
   TYPE *st, *x, *y0, *y;
   SCALAR Yalpha=alpha;
   void (*ATL_getX)(const int N, const SCALAR alpha, const TYPE *X, 
                   const int incX, TYPE *Y, const int incY);
   void (*ATL_gemv0)(const int M, const int N, const SCALAR alpha,
                     const TYPE *A, const int lda, const TYPE *X, 
                     const SCALAR beta, TYPE *Y, const int incY);
   #define ATL_gemv1_N Mjoin(PATL,gemv_N_a1_x1_b1_y1)
   #define ATL_gemv1_T Mjoin(PATL,gemv_T_a1_x1_b1_y1)
/*
 * Error Checks
 */
#ifndef ATL_NoDebug
   if (M < 0) i = 2;
   if (N < 0) i = Mmin(3,i);
   if (TA == AtlasNoTrans) { if ( (lda < M) || (lda < 1) ) i = Mmin(6, i); }
   else if ( (lda < N) || (lda < 1) ) i = Mmin(6, i);
   if (!incX) i = Mmin(8, i);
   if (!incY) i = Mmin(11, i);
   if (i != 2000)
   {
      ATL_xerbla(i, Mstr(Mjoin(PRE,gemv)), "");
      return;
   }
#endif

   if ( !M || !N ) return;
   if ( SCALAR_IS_ZERO(alpha) )
   {
      if ( SCALAR_IS_ONE(beta) ) return;
      Mjoin(PATL, scal)(M, beta, Y, incY);
      return;
   }

   if (TA == AtlasNoTrans)
   {
      Mjoin(PATL,gemvN)(M, N, alpha, A, lda, X, incX, beta, Y, incY);
      return;
   }
   if ( (incY == 1) && NOBETA )   /* no put to Y at end */
   {
      y = Y;
      if (BETA0)
      {
         if (TA == AtlasNoTrans) ATL_gemv0 = Mjoin(PATL,gemv_N_a1_x1_b0_y1);
         else ATL_gemv0 = Mjoin(PATL,gemv_T_a1_x1_b0_y1);
      }
      else
      {
         if (TA == AtlasNoTrans) ATL_gemv0 = Mjoin(PATL,gemv_N_a1_x1_b1_y1);
         else ATL_gemv0 = Mjoin(PATL,gemv_T_a1_x1_b1_y1);
      }
      if (incX == 1) /* only copy X if we must scal */
      {
         if (alpha == 1.0) ATL_getX = NULL;
@skip         else if (alpha == -1.0) ATL_getX = Mjoin(PATL,ax_an1_x1_y1);
         else 
         {
            Yalpha = 1.0;
            ATL_getX = Mjoin(PATL,ax_aX_x1_y1);
         }
      }
      else           /* must copy X */
      {
         Yalpha = 1.0;
         if (alpha == 1.0) ATL_getX = Mjoin(PATL,ax_a1_xX_y1);
@skip         else if (alpha == -1.0) ATL_getX = Mjoin(PATL,ax_an1_xX_y1);
         else ATL_getX = Mjoin(PATL,ax_aX_xX_y1);
      }
   }
   else /* use workspace, then write back to Y after gemv */
   {
      if (TA == AtlasNoTrans) 
      {
         ATL_gemv0 = Mjoin(PATL,gemv_N_a1_x1_b0_y1);
         align = ATL_DivBySize(
                 ((size_t)A - ATL_MulByCachelen(ATL_DivByCachelen((size_t)A))));
      }
      else ATL_gemv0 = Mjoin(PATL,gemv_T_a1_x1_b0_y1);
/*
 *    Malloc space for Y, and align it with A
 */
      vy = malloc(ATL_MulBySize(M+align)+ATL_Cachelen);
      assert(vy != NULL);
      y0 = y = ATL_AlignPtr(vy);
      if (incX == 1) ATL_getX = NULL;
      else /* must copy X */
      {
         if (NOBETA) /* don't save flops for later */
         {
            Yalpha = 1.0;
            if (alpha == 1.0) ATL_getX = Mjoin(PATL,ax_a1_xX_y1);
@skip            else if (alpha == -1.0) ATL_getX = Mjoin(PATL,ax_an1_xX_y1);
            else ATL_getX = Mjoin(PATL,ax_aX_xX_y1);
         }
         else ATL_getX = Mjoin(PATL,ax_a1_xX_y1);
      }
   }
   if (ATL_getX)  /* malloc space for X, cachelen aligned */
   {
      vx = malloc(ATL_MulBySize(N)+ATL_Cachelen);
      assert(vx != NULL);
      x = ATL_AlignPtr(vx);
   }
   else x = (TYPE *) X;

   if (incX < 0) X -= (N-1)*incX;
   if (incY < 0) Y -= (M-1)*incY;
   if (TA == AtlasNoTrans)
   {
/*
 *    Find biggest problem that will fit into L1 cache, and not cause TLB misses
 */
      k = (ATL_PageSize / lda) * ATL_nTLB;
      if (k > MV_N_MAXN) k = MV_N_MAXN_MU;
      else if (!k) k = ATL_nTLB;
      if (k > N) k = N;
      if (ATL_getX) ATL_getX(k, alpha, X, incX, x, 1);
      ATL_gemv0(M, k, 1.0, A, lda, x, 1.0, y, 1);
      if (k != N)
      {
         if (ATL_getX) incx = k * incX;
         else incx = k;
         i = lda * k;
         do
         {
            N -= k;
            A += i;
            if (k > N) k = N;
            if (ATL_getX) 
            {
               X += incx;
               ATL_getX(k, alpha, X, incX, x, 1);
            }
            else x += incx;
            ATL_gemv1_N(M, k, 1.0, A, lda, x, 1.0, y, 1);
         }
         while (N != k);
      }
   }
   else
   {
/*
 *    Find how many elements of X will fit in L1 cache, and block operation
 *    so that we keep it there
 */
      if (MV_T_MAXN >= N) k = N;
      else k = MV_T_MAXN_MU;

      if (ATL_getX) ATL_getX(k, alpha, X, incX, x, 1);
      ATL_gemv0(M, k, 1.0, A, lda, x, 1.0, y, 1);
      if (k != N)
      {
         if (ATL_getX) incx = k * incX;
         else incx = k;
         do
         {
            N -= k;
            A += k;
            if (k > N) k = N;
            if (ATL_getX) 
            {
               X += incx;
               ATL_getX(k, alpha, X, incX, x, 1);
            }
            else x += incx;
            ATL_gemv1_T(M, k, 1.0, A, lda, x, 1.0, y, 1);
         }
         while (N != k);
      }
   }
   if (vx) free(vx);
   if (vy) /* need to store info back to original Y */
   {
      Mjoin(PATL,axpby)(M, Yalpha, y0, 1, beta, Y, incY);
      free(vy);
   }
}

#include "atlas_f77gemv.h"
@ROUT fc fc1 mmtst
@extract -b @(topd)/gen.inc what=cw
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <string.h>
@ROUT mmtst `#include "atlas_misc.h"`

#define dumb_seed(iseed_) srand(iseed_)
#ifndef RAND_MAX  /* rather dangerous non-ansi workaround */
   #define RAND_MAX ((unsigned long)(1<<30))
#endif
#define dumb_rand() ( 0.5 - ((double)rand())/((double)RAND_MAX) )
#if defined(PentiumCPS) && !defined(WALL)
   #define WALL
#endif
#if defined(WALL)
   #define time00 ATL_walltime
#else
   #define time00 ATL_cputime
#endif

@ROUT fc mmtst
#define SAFE_ALPHA -3
#ifndef REPS
   #define REPS 1500
#endif

#ifndef L2SIZE
   #define L2SIZE 4194304
#endif

#define Mjoin(pre, nam) my_join(pre, nam)
#define my_join(pre, nam) pre ## nam
#define Mjoin(pre, nam) my_join(pre, nam)
#define my_join(pre, nam) pre ## nam
#define Mstr2(m) # m
#define Mstr(m) Mstr2(m)
#define Mmin(x, y) ( (x) > (y) ? (y) : (x) )

#ifdef FULLMM
   #define LANG 'M'
#elif !defined(LangF77)
   #define LANG 'C'
#else
   #define LANG 'F'
#endif
@ROUT fc fc1 mmtst
#if defined(sREAL)
   #include "atlas_ssysinfo.h"
   #define PRE 's'
   #define pre s
   #define TYPE float
   #define SCALAR float
   #define ATL_sizeof sizeof(TYPE)
   #define TREAL
   #define SHIFT
   #define EPS 1.0e-7
#elif defined(dREAL)
   #include "atlas_dsysinfo.h"
   #define PRE 'd'
   #define pre d
   #define TYPE double
   #define SCALAR double
   #define ATL_sizeof sizeof(TYPE)
   #define TREAL
   #define SHIFT
   #define EPS 1.0e-16
#elif defined (qREAL)
   #include "atlas_qsysinfo.h"
   #define PRE 'q'
   #define pre q
   #define TYPE long double
   #define SCALAR long double
   #define ATL_sizeof sizeof(TYPE)
   #define TREAL
   #define SHIFT
#elif defined(sCPLX) || defined(cCPLX) || defined(cREAL)
   #include "atlas_csysinfo.h"
   #define PRE 'c'
   #define pre c
   #define TYPE float
   #define ATL_sizeof (sizeof(TYPE)<<1)
   #define SCALAR float *
   #define TCPLX
   #define SHIFT <<1
   #define EPS 1.0e-7
#else
   #include "atlas_zsysinfo.h"
   #define PRE 'z'
   #define pre z
   #define TYPE double
   #define ATL_sizeof (sizeof(TYPE)<<1)
   #define SCALAR double*
   #define TCPLX
   #define SHIFT <<1
   #define EPS 1.0e-16
#endif

@ROUT fc
#if !defined(ATL_NEWTIME) || DUPB == 0
   #ifdef DUPB
      #undef DUPB
   #endif
   #define DUPB 1
#elif !defined(DUPB)
   #ifndef DUPB
      #define DUPB 1
   #elif DUPB == 0
      #undef DUPB
      #define DUPB 1
   #endif
#endif
@ROUT fc mmtst
#ifdef TCPLX
   #define bn1 bX  /* don't use bn1 case anymore */
#endif
@ROUT fc `#define Mabs(x) ( (x) < 0 ? (x) * -1 : (x) )`
#ifndef MB
   #define MB NB
#endif
#ifndef KB
   #define KB NB
#endif

#ifndef csA
   #define csA 2
#endif
#ifndef csB
   #define csB 2
#endif

#if defined(tranAt) || defined(tranAT)
   #define TransA
#elif defined(tranAc) || defined(tranAC)
   #define ConjTransA
#else
   #define NoTransA
#endif
#if defined(tranBt) || defined(tranBT)
   #define TransB
#elif defined(tranBc) || defined(tranBC)
   #define ConjTransB
#else
   #define NoTransB
#endif
#ifdef NoTransA
   #define Ma MB
   #define Na KB
#else
   #define Ma KB
   #define Na MB
#endif
#ifdef NoTransB
   #define Mb KB
   #define Nb NB
#else
   #define Mb NB
   #define Nb KB
#endif

#ifdef IJK
   #undef IJK
   #define LOOPO IJK
#else
   #undef JIK
   #define  LOOPO JIK
#endif

#ifdef LDA2
   #if (LDA2 <= 0)
      #undef LDA2
   #endif
#endif
#ifdef LDB2
   #if (LDB2 <= 0)
      #undef LDB2
   #endif
#endif
#ifdef LDC2
   #if (LDC2 <= 0)
      #undef LDC2
   #endif
#endif

#ifdef TransA
   #define TA T
   #ifndef LDA2
      #define LDA2 KB
   #endif
#elif defined(ConjTransA)
   #define TA C
   #ifndef LDA2
      #define LDA2 KB
   #endif
#else
   #define TA N
   #ifndef LDA2
      #define LDA2 MB
   #endif
#endif
#ifdef TransB
   #define TB T
   #ifndef LDB2
      #define LDB2 NB
   #endif
#elif defined(ConjTransB)
   #define TB C
   #ifndef LDB2
      #define LDB2 NB
   #endif
#else
   #define TB N
   #ifndef LDB2
      #define LDB2 KB
   #endif
#endif

#ifndef LDC2
   #define LDC2 MB
#endif
#if (ALPHA == 1)
   #define ALPHAnam _a1
#elif (ALPHA == -1)
   #define ALPHAnam _an1
#elif (ALPHA == SAFE_ALPHA)
   #define ALPHAnam _aXX
#else
   #define ALPHAnam _aX
#endif
#if (BETA == 1)
   #define BETAnam _b1
   #define NBETAnam _bn1
#elif (BETA == 0)
   #define BETAnam _b0
   #define NBETAnam _b0
#elif (BETA == -1)
   #define BETAnam _bn1
   #define NBETAnam _b1
#else
   #define BETAnam _bX
   #define NBETAnam _bX
#endif


#define ppre Mjoin(Mjoin(ATL_,pre),LOOPO)
#define MNKnam Mjoin(Mjoin(Mjoin(Mjoin(MB0,x),NB0),x),KB0)
#define TRnam Mjoin(TA, TB)
#define ldnam Mjoin(Mjoin(Mjoin(Mjoin(LDA,x),LDB),x),LDC)

#ifdef TREAL
   #define NBmm Mjoin(Mjoin(Mjoin(Mjoin(Mjoin(ppre,MNKnam), TRnam),ldnam), ALPHAnam), BETAnam)

#ifdef ATL_NEWTIME
   #ifndef ATL_CSZT
      #define ATL_CSZT const size_t
   #endif
   void NBmm(ATL_CSZT mblks, ATL_CSZT nblks, ATL_CSZT K, const TYPE *A, 
             const TYPE *B, TYPE *C, const TYPE *pAn, const TYPE *pBn, 
             const TYPE *pCn);
#else
   void NBmm(const int, const int, const int, const SCALAR, const TYPE*, 
             const int, const TYPE*, const int, const SCALAR, TYPE*, const int);
#endif
#else
   #define NBmm0 Mjoin(Mjoin(Mjoin(Mjoin(ppre,MNKnam), TRnam),ldnam), ALPHAnam)
   #define _bn1 _bX

   void Mjoin(NBmm0,BETAnam)(const int, const int, const int, const TYPE,
                             const TYPE*, const int, const TYPE*, const int, 
                             const TYPE, TYPE*, const int);
   void Mjoin(NBmm0,_bn1)(const int, const int, const int, const TYPE, 
                        const TYPE*, const int, const TYPE*, const int, 
                        const TYPE, TYPE*, const int);
   void Mjoin(NBmm0,_b1)(const int, const int, const int, const TYPE, 
                       const TYPE*, const int, const TYPE*, const int, 
                       const TYPE, TYPE*, const int);
#if csA == 1 && csB == 1
   #if csC == 2
      #define NBmm(m_, n_, k_, alp_, a_, lda_, b_, ldb_, bet_, c_, ldc_) \
      { \
         Mjoin(NBmm0,NBETAnam)(m_, n_, k_, *(alp_), (a_), lda_, (b_), \
                               ldb_, -(*(bet_)), c_, ldc_); \
         Mjoin(NBmm0,BETAnam)(m_, n_, k_, *(alp_), a_, lda_, (b_)+incb, ldb_, \
                              *(bet_), (c_)+1, ldc_); \
         Mjoin(NBmm0,_bn1)(m_, n_, k_, *(alp_), (a_)+inca, lda_, (b_)+incb, \
                           ldb_, rnone, c_, ldc_); \
         Mjoin(NBmm0,_b1)(m_, n_, k_, *(alp_), (a_)+inca, lda_, (b_), ldb_, \
                          rone, (c_)+1, ldc_); \
      }
   #elif csC == 1
      #define NBmm(m_, n_, k_, alp_, a_, lda_, b_, ldb_, bet_, c_, ldc_) \
      { \
         Mjoin(NBmm0,NBETAnam)(m_, n_, k_, *(alp_), (a_), lda_, (b_), \
                               ldb_, -(*(bet_)), c_, ldc_); \
         Mjoin(NBmm0,BETAnam)(m_, n_, k_, *(alp_), a_, lda_, (b_)+incb, ldb_, \
                              *(bet_), (c_)+incc, ldc_); \
         Mjoin(NBmm0,_bn1)(m_, n_, k_, *(alp_), (a_)+inca, lda_, (b_)+incb, \
                           ldb_, rnone, c_, ldc_); \
         Mjoin(NBmm0,_b1)(m_, n_, k_, *(alp_), (a_)+inca, lda_, (b_), ldb_, \
                          rone, (c_)+incc, ldc_); \
      }
   #endif
#else /* csA == 2 && csB == 2 && csC == 2 */
   #define NBmm(m_, n_, k_, alp_, a_, lda_, b_, ldb_, bet_, c_, ldc_) \
   { \
      Mjoin(NBmm0,NBETAnam)(m_, n_, k_, *(alp_), (a_)+1, lda_, (b_)+1, ldb_, \
                            -(*(bet_)), c_, ldc_); \
      Mjoin(NBmm0,BETAnam)(m_, n_, k_, *(alp_), (a_)+1, lda_, b_, ldb_, \
                           *(bet_), (c_)+1, ldc_); \
      Mjoin(NBmm0,_bn1)(m_, n_, k_, *(alp_), a_, lda_, b_, ldb_, \
                        rnone, c_, ldc_); \
      Mjoin(NBmm0,_b1)(m_, n_, k_, *(alp_), a_, lda_, (b_)+1, ldb_, \
                       rone, (c_)+1, ldc_); \
   }
#endif
#if 0
   #undef NBmm
   #define NBmm(m_, n_, k_, alp_, a_, lda_, b_, ldb_, bet_, c_, ldc_) \
   { \
      zgemm_("T", "N", &(m_), &(n_), &(k_), alp_, a_, &(lda_), b_, \
             &(ldb_), bet_, c_, &(ldc_)); \
   }
#endif
#endif

@ROUT mmtst
void tst_mm(const int M, const int N, const int K, const SCALAR alpha, 
            const TYPE *A, const int lda0, const TYPE *B, const int ldb0,
            const SCALAR beta, TYPE *C, const int ldc0)
{
   int i, j, k;
   int lda = lda0 SHIFT, ldb = ldb0 SHIFT, ldc = ldc0 SHIFT;
   register TYPE c0;
   #ifdef TREAL
      for (j=0; j < N; j++)
      {
         for (i=0; i < M; i++)
         {
            c0 = 0.0;
            for (k=0; k < K; k++)
            {
               #if defined(NoTransA) && defined(NoTransB)
                  c0 += A[i+k*lda] * B[j*ldb+k];
               #elif defined(NoTransA) && defined(TransB)
                  c0 += A[i+k*lda] * B[j+k*ldb];
               #elif defined(TransA) && defined(NoTransB)
                  c0 += A[i*lda+k] * B[j*ldb+k];
               #elif defined(TransA) && defined(TransB)
                  c0 += A[i*lda+k] * B[j+k*ldb];
               #endif
            }
            C[i+j*ldc] = beta*C[i+j*ldc] + alpha*c0;
         }
      }
   #else
      register TYPE cr, ci, ar, ai, br, bi;
/*
 *    If matrix is stored split into real & imaginary parts, allocate some
 *    matrices and intermix them for f77-like imaginary matrices
 */
      #if csA == 1 && csB == 1
         int inc, ldaa, ldbb, lda2=lda/2, ldb2=ldb/2;
         TYPE *aa, *bb;
         aa = malloc(M*K*sizeof(TYPE)*2);
         bb = malloc(K*N*sizeof(TYPE)*2);
         assert(aa && bb);
         #ifdef NoTransA
            ldaa = M*2;
            inc = K*lda2;
            for (k=0; k < K; k++)
            {
               j = k*lda;
               for (i=0; i < M; i++) 
               {
                  aa[k*ldaa+2*i]   = A[inc+k*lda2+i];
                  aa[k*ldaa+2*i+1] = A[k*lda2+i];
               }
            }
         #else
            ldaa = K*2;
            inc = M*lda2;
            for (i=0; i < M; i++) 
            {
               for (k=0; k < K; k++)
               {
                  aa[i*ldaa+2*k]   = A[inc+i*lda2+k];
                  aa[i*ldaa+2*k+1] = A[i*lda2+k];
               }
            }
         #endif
         #ifdef NoTransB
            inc = N*ldb2;
            ldbb = K*2;
            for (j=0; j < N; j++) 
            {
               for (k=0; k < K; k++)
               {
                  bb[j*ldbb+2*k]   = B[inc+j*ldb2+k];
                  bb[j*ldbb+2*k+1] = B[j*ldb2+k];
               }
            }
         #else
            inc = K*ldb2;
            ldbb = N*2;
            for (k=0; k < K; k++)
            {
               for (j=0; j < N; j++) 
               {
                  bb[k*ldbb+2*j]   = B[inc+k*lda2+j];
                  bb[k*ldbb+2*j+1] = B[k*lda2+j];
               }
            }
         #endif
         A = (const TYPE *) aa;
         B = (const TYPE *) bb;
         lda = ldaa;
         ldb = ldbb;
      #endif

      for (j=0; j < N; j++)
      {
         for (i=0; i < M; i++)
         {
            cr = ci = 0.0;
            for (k=0; k < K; k++)
            {
               #if defined(NoTransA) && defined(NoTransB)
                  ar = A[2*i+k*lda];
                  ai = A[2*i+k*lda+1];
                  br = B[j*ldb+2*k];
                  bi = B[j*ldb+2*k+1];
               #elif defined(NoTransA) && !defined(NoTransB)
                  ar = A[2*i+k*lda] ;
                  ai = A[2*i+k*lda+1];
                  br = B[2*j+k*ldb];
                  bi = B[2*j+k*ldb+1];
               #elif !defined(NoTransA) && defined(NoTransB)
                  ar = A[i*lda+k*2];
                  ai = A[i*lda+k*2+1];
                  br = B[j*ldb+k*2];
                  bi = B[j*ldb+k*2+1];
               #elif !defined(NoTransA) && !defined(NoTransB)
                  ar = A[i*lda+k*2];
                  ai = A[i*lda+k*2+1];
                  br = B[2*j+k*ldb];
                  bi = B[2*j+k*ldb+1];
               #endif
               #ifdef ConjTransA
                  ai = -ai;
               #endif
               #ifdef ConjTransB
                  bi = -bi;
               #endif
               cr += ar * br - ai * bi;
               ci += ar * bi + ai * br;
            }
/*
 *          Scale by alpha
 */
            ar = *alpha;
            ai = alpha[1];
            br = cr;
            bi = ci;
            cr =  br * ar;
            ci =  bi * ar;
            cr -= bi * ai;
            ci += br * ai;
/*
 *          Scale C by beta
 */
            br = *beta;
            bi = beta[1];
            ar = C[2*i+j*ldc];
            ai = C[2*i+j*ldc+1];
            C[2*i+j*ldc]   = ar*br - ai * bi;
            C[2*i+j*ldc+1] = ai*br + ar * bi;
/*
 *          Store answer back to C
 */
            C[2*i+j*ldc]   += cr;
            C[2*i+j*ldc+1] += ci;

         }
      }
      #if csA == 1 && csB == 1
         free(aa);
         free(bb);
      #endif
   #endif
}
@ROUT fc
void SortDoubles(int N, double *X)
/*
 * Simple selection sort on X
 */
{
   double small;
   int ismall, i, j;
   for (i=0; i < N; i++)
   {
      ismall = i;
      small = X[i];
      for (j=i+1; j < N; j++)
      {
         if (X[j] < small)
         {
            ismall = j;
            small = X[j];
         }
      }
     if (ismall != i)
      {
         X[ismall] = X[i];
         X[i] = small;
      }
   }
}

#ifndef NSAMPLE
   #define NSAMPLE 3
#endif
@define ldmul @@
void time_mm(char *fnam0)
@ROUT mmtst
@define ldmul @2*@
int mmtst(void)
@ROUT mmtst fc
{
   #ifdef ATL_Cachelen
      #define ATL_AS (ATL_Cachelen/ATL_sizeof)
   #else
      #define ATL_AS (32/ATL_sizeof)
   #endif
   char fnam[80];
#if defined(LDA) && LDA != 0
      const int lda=LDA;
#else
      const int lda=@(ldmul)LDA2;
#endif
#if defined(LDB) && LDB != 0
   const int ldb=LDB;
#else
   const int ldb=@(ldmul)LDB2;
#endif
#if defined(LDC) && LDC != 0
   const int ldc=LDC;
#else
   const int ldc=@(ldmul)LDC2;
#endif
   int nA, nB;
@ROUT fc
   int restarts=0;
   int i, j, k, reps, len;
   int incA, incB, incC, nmov;
   double t0, t1, mflop;
   double times[NSAMPLE];
   void *va=NULL, *vb=NULL, *vc=NULL, *vp=NULL;
   TYPE *A, *B, *C, *a, *b, *c, *stA, *stB, *stC;
@ROUT fc mmtst
   #ifdef TCPLX
      int inca, incb, incc;
      const TYPE one=1.0, none=(-1.0);
      #if (ALPHA == 1)
         TYPE alpha[2] = {1.0, 0.0};
      #elif (ALPHA == -1)
         TYPE alpha[2] = {-1.0, 0.0};
      #else
@skip         const TYPE alpha[2] = {2.3, -3.0};
         TYPE alpha[2] = {2.3, 0.0};
      #endif
      #if (BETA == 1)
         TYPE beta[2] = {1.0, 0.0};
      #elif (BETA == -1)
         TYPE beta[2] = {-1.0, 0.0};
      #elif (BETA == 0)
         TYPE beta[2] = {0.0, 0.0};
      #else
@skip         const TYPE beta[2] = {2.3, -3.0};
         TYPE beta[2] = {1.3, 0.0};
      #endif
   #else
      #ifdef ALPHA
         TYPE alpha=ALPHA;
      #else
         TYPE alpha=1.0;
      #endif
      #ifdef BETA
         TYPE beta=BETA;
      #else
         TYPE beta=1.0;
      #endif
   #endif
   const TYPE rone=1.0, rnone=(-1.0);
@ROUT fc
   FILE *fpout;
   double time00(void);
   #ifdef ATL_NEWTIME
      const size_t nmu=(MB/MU), nnu=(NB/NU);
   #endif

   #ifdef NoTransA
      nA = KB;
   #else
      nA = MB;
   #endif
   #ifdef NoTransB
      nB = NB;
   #else
      nB = KB;
   #endif
   #ifdef ATL_nkflop
      #ifdef TCPLX
         t0 = 8.0*MB;
      #else
         t0 = 2.0*MB;
      #endif
      t0 *= NB;
      t0 *= KB;
      t1 = ATL_nkflop * 1000.0;
      reps = t1 / t0;
   #else
      reps = REPS * ( (40.0/MB) * (40.0/NB) * (40.0/KB) );
      #ifdef TCPLX
         reps /= 4;
      #endif
   #endif
   if (reps < 1) reps = 1;

   incA = incB = incC = nmov = 0;
   #ifdef MoveA
      incA = lda*nA;
      incA = ((incA+ATL_AS-1)/ATL_AS)*ATL_AS;
      nmov++;
   #else
      #ifdef ATL_NEWTIME
         va = malloc(128+ATL_sizeof*(lda*nA+MB*KB));
      #else
         va = malloc(128+ATL_sizeof*lda*nA);
      #endif
      assert(va);
      a = A = (void*) ( 128 + ((((size_t)va)>>7)<<7) );
      stA = A + (lda*nA SHIFT);
   #endif
   #ifdef MoveB
      incB = DUPB*ldb*nB;
      incB = ((incB+ATL_AS-1)/ATL_AS)*ATL_AS;
      nmov++;
   #else
      #ifdef ATL_NEWTIME
         vb = malloc(128+DUPB*ATL_sizeof*(ldb*nB+NB*KB));
      #else
         vb = malloc(128+ATL_sizeof*ldb*nB);
      #endif
      assert(vb);
      b = B = (void*) ( 128 + ((((size_t)vb)>>7)<<7) );
      stB = B + DUPB*(ldb*nB SHIFT);
   #endif
   #ifdef MoveC
      assert(ldc == MB);
      incC = ldc*NB;
      incC = ((incC+ATL_AS-1)/ATL_AS)*ATL_AS;
      nmov++;
   #else
      #ifdef ATL_NEWTIME
         vc = malloc(128+ATL_sizeof*(ldc*NB+MB*NB));
      #else
         vc = malloc(128+ATL_sizeof*ldc*NB);
      #endif
      assert(vc);
      c = C = (void*) ( 128 + ((((size_t)vc)>>7)<<7) );
      stC = C + (ldc * NB SHIFT);
   #endif

/*   sprintf(fnam, "res/%s", Mstr(NBmm)); */
   if (fnam0) strcpy(fnam, fnam0);
   else
      sprintf(fnam, 
              "res/%c%smm%s%s%d_%dx%dx%d_%dx%dx%d_%dx%dx%d%s%s_%dx%d_%d_pf%d",
              PRE, Mstr(LOOPO), Mstr(TA), Mstr(TB), NB, MB0, NB0, KB0, 
              LDA, LDB, LDC, MU, NU, KU, Mstr(ALPHAnam), Mstr(BETAnam), 
              MULADD, LAT, CLEANUP, PREFA);
   fpout = fopen(fnam, "w");
   #if 1 /* def ATL_NEWTIME */
      #ifdef WALL
         fprintf(fpout, "%d %d\n", NSAMPLE, 1);
      #else
         fprintf(fpout, "%d %d\n", NSAMPLE, 0);
      #endif
   #endif

   if (nmov != 0)  /* need to allocate space */
   {
      len = (1.2*L2SIZE) / ATL_sizeof;
      /* total moving length */
      i = Mmin(incA, MB*KB) + Mmin(incB, NB*KB) + Mmin(incC, MB*NB);
      j = (len+i-1) / i;       /* number of reps to cause flush */
      len = (incA+incB+incC) * j;
      #ifdef ATL_NEWTIME
      {
         #if MB >= NB && MB >= NB
            #define EXTRA MB*MB
         #elif NB >= MB && NB >= KB
            #define EXTRA NB*NB
         #else
            #define EXTRA KB*KB
         #endif
         vp = malloc(128+(len+EXTRA)*ATL_sizeof);
         #undef EXTRA
      }
      #else
         vp = malloc(128+len*ATL_sizeof);
      #endif
      assert(vp);
      #ifdef TCPLX
         inca = incA;
         incb = incB;
         incc = incC;
         incA *= 2;
         incB *= 2;
         incC *= 2;
      #endif
      a = (void*) ( 128 + ((((size_t)vp)>>7)<<7) );
      if (incA)
      {
         A = a;
         stA = a + incA * j;
      }
      if (incB)
      {
         b = B = a + j * incA;
         stB = b + j * incB;
         if (incC)
         {
            c = C = stB;
            stC = C + j * incC;
         }
      }
      else if (incC)
      {
         c = C = a + j * incA;
         stC = C + j * incC;
      }
      a = A;
   }
   #ifdef TCPLX
   else
   {
         inca = incA;
         incb = incB;
         incc = incC;
         incA *= 2;
         incB *= 2;
         incC *= 2;
   }
   #endif

   while (a != stA) *a++ = dumb_rand();  a = A;
   while (b != stB) *b++ = dumb_rand();  b = B;
   while (c != stC) *c++ = 0.0;          c = C;

   for (i=0; i != NSAMPLE; i++)
   {
      t0 = time00();
      for (k=reps; k; k--)
      {
         #ifdef ATL_NEWTIME
            NBmm(nmu, nnu, KB, a, b, c, a+incA, b+incB, c+incC);
         #else
            NBmm(MB, NB, KB, alpha, a, lda, b, ldb, beta, c, ldc);
         #endif
         #ifdef MoveA
            a += incA;
            if (a == stA) a = A;
         #endif
         #ifdef MoveB
            b += incB;
            if (b == stB) b = B;
         #endif
         #ifdef MoveC
            c += incC;
            if (c == stC)
            {
               c = C;
            #ifdef TREAL
               if (beta != 0.0) beta = 1.0 / beta;
               if (alpha != 0.0) alpha = -alpha;
            #else
               if (*beta != 0.0) *beta = 1.0 / (*beta);
               if (*alpha != 0.0) *alpha = -(*alpha);
            #endif
            }
         #else
            #ifdef TREAL
               if (beta != 0.0) beta = 1.0 / beta;
               if (alpha != 0.0) alpha = -alpha;
            #else
               if (*beta != 0.0) *beta = 1.0 / (*beta);
               if (*alpha != 0.0) *alpha = -(*alpha);
            #endif
@beginskip
            if (beta == 1.0) beta = -1.0;
            else if (beta == -1.0) beta = 1.0;
            else if (beta != 0.0) beta = 1.0 / beta;
@endskip
         #endif
      }
      t1 = time00() - t0;
/*
 *    Workaround for mystery prob Windows/icc, where first return val is
 *    always 0
 */
#if defined(ATL_ARCH_TI_C66_BM) && (!defined(ATL_USING_XCC))
      if (t1 != 0.0)
#else
      if (t1 >= 0.005)
#endif
      {
         mflop = ( (((2.0*MB)*NB)*KB)*reps ) / (t1 * 1000000.0);
         #ifdef TCPLX
            mflop *= 4.0;
         #endif
         fprintf(stderr, 
   "%cNB=%d, ld=%d,%d,%d, mu=%d, nu=%d, ku=%d, lat=%d, pf=%d: time=%.3f, mflop=%.2f\n",
                 PRE, NB, lda, ldb, ldc, MU, NU, KU, LAT, PREFA, t1, mflop);
         #if 1 /* def ATL_NEWTIME */
            if (fpout) fprintf(fpout, "%le\n",mflop);
         #else
            if (fpout) fprintf(fpout, "%lf\n",mflop);
         #endif
         times[i] = t1;
      }
      else
      {
         if (++restarts > 5)
         {
            fclose(fpout);
            remove(fnam);
            fprintf(stderr, "Too many zero-time values, dying\n");
            exit(-1);
         }
         fprintf(stderr, "Near-zero time %e rejected\n", t0);
         i--;
      }
   }
   SortDoubles(NSAMPLE, times);
   #ifdef WALL
      t1 = times[0];
   #else
      t1 = times[NSAMPLE/2];
   #endif
   mflop = ( (((2.0*MB)*NB)*KB)*reps ) / (t1 * 1000000.0);
   #ifdef TCPLX
      mflop *= 4.0;
   #endif
   fprintf(stdout, "%cNB=%d, time=%.3f, mflop=%.2f\n", PRE, NB, t1, mflop);
   if (fpout) fclose(fpout);
   if (vp) free(vp);
   if (va) free(va);
   if (vb) free(vb);
   if (vc) free(vc);
}

int main(int nargs, char **args)
{
   char *fnam;
   if (nargs > 1) fnam = args[1];
   else fnam = NULL;
   time_mm(fnam);
   exit(0);
}
@ROUT mmtst
   void *va=NULL, *vb=NULL, *vc=NULL;
   TYPE *C0, *C1, *A, *B;
   TYPE diff, tmp;
   int i, j, k, n, nerr;
   int M=MB, N=NB, K=KB;
   TYPE ErrBound;

   if (!M) M = MB0;
   if (!N) N = NB0;
   if (!K) K = KB0;
   #ifdef TREAL
      ErrBound = 2.0 * (Mabs(alpha) * 2.0*K*EPS + Mabs(beta) * EPS) + EPS;
   #else
      diff = Mabs(*alpha) + Mabs(alpha[1]);
      tmp = Mabs(*beta) + Mabs(beta[1]);
      ErrBound =  2.0 * (diff*8.0*K*EPS + tmp*EPS) + EPS;
   #endif
   #ifdef NoTransA
      nA = K;
   #else
      nA = M;
   #endif
   #ifdef NoTransB
      nB = N;
   #else
      nB = K;
   #endif
   #ifdef TCPLX
      inca = lda*nA;
      incb = ldb*nB;
   #endif
   #ifdef ATL_MinMMAlign
      va = malloc(ATL_MinMMAlign + lda*nA*ATL_sizeof);
      vb = malloc(ATL_MinMMAlign + ldb*nB*ATL_sizeof);
      vc = C0 = malloc(2*ldc*N*ATL_sizeof);
      assert(va && vb && C0);
      A = (TYPE *) ( ( ((size_t) va)/ATL_MinMMAlign ) * ATL_MinMMAlign
                     + ATL_MinMMAlign );
      B = (TYPE *) ( ( ((size_t) vb)/ATL_MinMMAlign ) * ATL_MinMMAlign
                     + ATL_MinMMAlign );
   #else
      C0 = vc = malloc( (2*ldc*N + lda*nA + ldb*nB) * ATL_sizeof);
      assert(vc);
      A = C1 + (ldc * N SHIFT);
      B = A + (lda * nA SHIFT);
   #endif
   C1 = C0 + (ldc * N SHIFT);
   for (n=lda*nA SHIFT, i=0; i < n; i++) A[i] = dumb_rand();
   for (n=ldb*nB SHIFT, i=0; i < n; i++) B[i] = dumb_rand();
   for (n=ldc*N SHIFT, i=0; i < n; i++) C0[i] = C1[i] = dumb_rand();
   tst_mm(M, N, K, alpha, A, lda, B, ldb, beta, C0, ldc);
   NBmm(M, N, K, alpha, A, lda, B, ldb, beta, C1, ldc);
   nerr = 0;
   for (j=0; j < N; j++)
   {
      for (i=0; i < M SHIFT; i++)
      {
         k = i + j*(ldc SHIFT);
         diff = C0[k] - C1[k];
         if (diff < 0.0) diff = -diff;
         if (diff > ErrBound) 
         {
            fprintf(stderr, "C(%d,%d) : expected=%f, got=%f\n", 
                    i, j, C0[k], C1[k]);
            nerr++;
         }
         else if (C1[k] != C1[k])   /* test for NaNs in test answer */
         {
            fprintf(stderr, "C(%d,%d) : expected=%f, got=%f\n", 
                    i, j, C0[k], C1[k]);
            nerr++;
         }
      }
   }
   free(vc);
   if (va) free(va);
   if (vb) free(vb);
   return(nerr);
}

int main()
{
   int ierr;
   ierr = mmtst();
   if (!ierr) fprintf(stdout, "PASSED TEST\n");
   return(ierr);
}

@ROUT fc1
#ifdef FULLMM
   void NBmm(const int, const int, const int, SCALAR, TYPE*, const int, TYPE*, 
             const int, SCALAR, TYPE*, const int);
#elif defined (TCPLX)
   void Mjoin(NBmm,_bn1)(const TYPE *A, const TYPE *B, const TYPE beta, 
                         TYPE *C, const int ldc);
   void Mjoin(NBmm,_b1)(const TYPE *A, const TYPE *B, const TYPE beta, 
                        TYPE *C, const int ldc);
#endif

#include "atlas_misc.h"
#include <assert.h>
double time00(void);
#ifndef L2SIZE
#define L2SIZE 262144
#endif
#define TIME_SCAL
#ifdef TIME_AX
   #define USE_Y;
   #define FLOPCNT 1
   #define ATL_lvl1(N_, ALPHA_, X_, INCX_, BETA_, Y_, INCY_) \
      Mjoin(PATL,ax)(N_, ALPHA_, X_, INCX_, Y_, INCY_);
#elif defined(TIME_XPBY)
   #define USE_Y;
   #define FLOPCNT 2
   #define ATL_lvl1(N_, ALPHA_, X_, INCX_, BETA_, Y_, INCY_) \
      Mjoin(PATL,axpby)(N_, X_, INCX_, BETA_, Y_, INCY_);
#elif defined(TIME_SCAL)
   void ATL_scalT(const int N, const TYPE alpha, TYPE *X, const int incX);
   #define FLOPCNT 1
   #define ATL_lvl1(N_, ALPHA_, X_, INCX_, BETA_, Y_, INCY_) \
      ATL_scalT(N_, ALPHA_, X_, INCX_);
#endif
void time_lvl1(int what, int mflops, int n, int incX0, int incY, TYPE alpha)
{
   char fnam[128];
   int i, j, nn;
   long reps;
   int incX=incX0, incx, incy;
   void *vx, *vy;
   TYPE *X, *x, *stX, *Y, *y;
   TYPE alpinv=0.0, alp, beta=3.1;
   char calp;
   double t0, t1, dmflops;
   #define NREP 3
   FILE *fpout;

   if (alpha != 0.0) alpinv = 1.0 / alpha;
   if (incX0 == 0) incX = 4;
   if (alpha == 1.0) calp = '1';
   else if (alpha == 0.0) calp = '0';
   else if (alpha == -1.0) calp = 'n';
   else calp = 'X';
   sprintf(fnam, "res/%cscal%d_%dx%d_X%d_A%c_%d", PRE, n, NU, NUMUL, incX0, 
           calp, LAT);
   fpout = fopen(fnam, "w");
   assert(fpout);
   i = n * ATL_sizeof;
   nn = (L2SIZE+i-1) / i;
   if (nn < 2) nn = 2;
   else if (nn % 2) nn++;
   vx = malloc(ATL_Cachelen+nn*i*Mabs(incX));
   assert(vx != NULL);
   x = X = ATL_AlignPtr(vx);
   stX = x + nn * n * incX;
   #ifdef USE_Y
      vy = malloc(ATL_Cachelen+nn*i*Mabs(incY));
      assert(vy != NULL);
      y = Y = ATL_AlignPtr(vy);
      while (y != stY) *y++ = dumb_rand();
      y = Y;
   #else
      vy = y = Y = NULL;
      incY = 0;
   #endif
   i = n * FLOPCNT;
   reps = mflops * (1000000 / i);
   if (reps < 2) reps = 2;
   else if (reps%2) reps++;
   incx = incX * n;
   incy = incY * n;

   for (j=0; j < NREP; j++)
   {
      dumb_seed(reps);
      x = X;
      y = Y;
      while (x != stX) *x++ = dumb_rand();
      #ifdef USE_Y
         while (y != stY) *y++ = dumb_rand();
      #endif
      x = X;
      y = Y;
      alp = alpha;
      t0 = time00();
      for (i=reps; i; i--)
      {
         ATL_lvl1(n, alp, x, incX, beta, y, incY);
         x += incx;
         y += incy;
         if (x == stX) 
         { 
            x = X; 
            y = Y;
            if (alp == alpha) alp = alpinv;
            else alp = alpha;
         }
      }
      t1 = time00() - t0;
      dmflops = (((1.0*n) * FLOPCNT) * reps) / (1000000.0*t1);
      printf("pre=%c, N=%d, NU=%d, NUMUL=%d, incX=%d, alpha=%f, lat=%d: mflop=%f\n",
             PRE, n, NU, NUMUL, incX, alpha, LAT, dmflops);
@skip      fprintf(stdout, "reps=%d, N=%d, cumtime=%f, mflop=%f\n", reps, n, 
@skip              t1, dmflops);
      fprintf(fpout, "%lf\n", dmflops);
   }
   free(vx);
   if (vy) free(vy);
   fclose(fpout);
}
MAIN__(){}
int main(int nargs, char *args[])
{
   int n = 300, mflops=27, what=1, incX=1, incY=1;
   TYPE alpha=2.0;
/*   fprintf(stderr, "USAGE: %s <op> <mflops> <N> <incX> <incY> */
   if (nargs > 1)
   {
      what = atoi(args[1]);
      if (nargs > 2) mflops = atoi(args[2]);
      if (nargs > 3) n = atoi(args[3]);
      if (nargs > 4) incX = atoi(args[4]);
      if (nargs > 5) incY = atoi(args[5]);
      if (nargs > 6) alpha = atof(args[6]);
   }
   time_lvl1(what, mflops, n, incX, incY, alpha);
   return(0);
}
@ROUT emit_lvl1
int *GetPattern(int nu, int numul)
{
   int i, j, k, *pat;
   pat = malloc(nu*numul*sizeof(int));
   assert(pat);
   for (i=k=0; i < nu; i++)
      for (j=0; j < numul; j++) pat[k++] = j*nu+i;
   return(pat);
}

void emit_axpy_lat(FILE *fpout, char *spc, int nu, int numul, int lat,
                   int incX, int incY)
{
   int *pat;
   int k, i, T, t, tmax, NU=nu*numul;
   pat = GetPattern(nu, numul);

   for (T=0; T < 3; T++)
   {
      if (T == 1)
      {
         tmax = 1;
         fprintf(fpout, "%s   do\n%s   {\n", spc, spc);
         spc -= 3;
      }
      else
      {
         if (2*lat > NU) tmax = (2*lat) / NU;
         else tmax = 1;
      }
      for (t=0; t < tmax; t++)
      {
         for (i=0; i < NU; i++)
         {
            k = i % lat;
            iy = pat[(i+lat)%NU];
            if (i + lat >= NU) iy += NU;
            if (T > 0 || i > 2*lat)
            {
               if (i) fprintf(fpout, "%s   y[%d] = a%d;\n", spc, i, i)
               else fprintf(fpout, "%s   *y = a0;\n", spc)
            }
            if ( (T==0 && i > lat) || (T==1) || (T==2 && NU-i > lat) )
            {
               if (iy) fprintf(fpout, "%s   a%d = y[%d];\n", spc, k, iy);
               else fprintf(fpout, "%s   a%d = *y;\n", spc, k);
            }
            if ( (T < 2) || (NU-i > 2*lat) )
            {
               if (i) fprintf(fpout, "%s   m%d = x[%d];\n", spc, k, i);
               else fprintf(fpout, "%s   m0 = *x;\n", spc);
               fprintf(fpout, "%s   m%d *= alpha;\n", k);
            }
         }
      }
      if (T == 0) if (incX != inc_X) fprintf(fpout, "%s   x += %d;\n", spc, NU);
      if (T == 1)
      {
         if (incY != inc_X) fprintf(fpout, "%s   y += %d;\n", spc, NU);
         if (incX != inc_X) fprintf(fpout, "%s   x += %d;\n", spc, NU);
         spc += 3;
         if (incX != inc_X)
            fprintf(fpout, "%s   }\n%s   while(x != stX0);\n", spc, spc);
         else fprintf(fpout, "%s   }\n%s   while(xr0 != stX0);\n", spc, spc);
      }
   }
}

void emit_axpy_lat_prefetch(FILE *fpout, char *spc, int nu, int numul, int lat,
                            int incX, int incY, int Xregs, int Yregs)
{
   int *pat;
   int i, T, t, maxt, NU=nu*numul;
   pat = GetPattern(nu, numul);

   if (incX != INCX_X)
   {
      for (i=0; i < Xregs; i++) 
      {
         if (pat[i]) fprintf(fpout, "%s   x%d = x[%d];\n", spc, i, incX*pat[i]);
         else fprintf(fpout, "%s   x%d = *x;\n", spc, i);
      }
      if (Xregs == NU) fprintf(fpout, "%s   x += %d;\n", spc, incX*NU);
   }
   else
   {
      for (i=0; i < Xregs; i++) 
      {
         fprintf(fpout, "%s   x%d = *xr%d;\n", spc, i, pat[i]);
         fprintf(fpout, "%s   xr%d += incX;\n", spc, pat[i]);
      }
   }
   if (incY != INC_X)
   {
      for (i=0; i < Yregs; i++) 
      {
         if (pat[i]) fprintf(fpout, "%s   y%d = y[%d];\n", spc, i, pat[i]);
         else fprintf(fpout, "%s   y%d = *y;\n", spc, i);
      }
   }
   else
   {
      for (i=0; i < Yregs; i++) 
      {
         fprintf(fpout, "%s   y%d = *yr%d;\n", spc, i, pat[i]);
         else fprintf(fpout, "%s   yr%d += incY;\n", spc, pat[i]);
      }
   }

   for (T=0; T < 3; T++)
   {
      maxt = 1;
      if (T == 1)
      {
         fprintf(fpout, "%s   do\n%s   {\n", spc, spc);
         spc -= 3;
         maxt = 1;
      }
      else if (2*lat > NU) maxt = (2*lat) / NU;
      for (t=0; t < maxt; t++)
      {
         for (i=0; i < NU; i++)
         {
            if (incY != INC_X)
            {
               if (i+Yregs > NU) iy = NU + pat[(i+Yregs)%NU];
               else iy = pat[(i+Yregs)%NU];
            }
            else iy = (i + Yregs) % NU;
            if (incX != INC_X)
            {
               if (NU == Xregs) ix = pat[i];
               else if (i+Xregs > NU) ix = NU + pat[(i+Xregs)%NU];
               else ix = pat[(i+Xregs)%NU];
            }
            else ix = (i + Xregs) % NU;
            if (i >= 2*lat || T)
            {
               if (incY != INC_X)
               {
                  if (pat[i])
                     fprintf(fpout, "%s   y[%d] = a%d;\n", spc, incY*pat[i], i);
                  else fprintf(fpout, "%s   *y = a%d;\n", spc, i);
               }
               else
               {
                  fprintf(fpout, "%s   *yw%d = a%d;\n", spc, pat[i], i);
                  fprintf(fpout, "%s   yw += incY;\n", spc);
               }
            }
            if ( (T==0 && i >= lat) || (T==1) || (T==2 && NU-i > lat) )
            {
               fprintf(fpout, "%s   a%d = m%d = y%d;\n", spc, 
                       i%lat, i%lat, i%Yregs);
               if ( (T < 2) || (NU-i > Yregs+lat) )
               {
                  if (incY != INC_X)
                  {
                     if (iy) fprintf(fpout, "%s   y%d = y[%d];\n", spc, i%Yregs,
                                     iy*incY);
                     else fprintf(fpout, "%s   y%d = *y;\n", spc, i%Yregs);
                  }
                  else
                  {
                     fprintf(fpout, "%s   y%d = *ry%d;\n", spc, i%Yregs, iy);
                     fprintf(fpout, "%s   ry%d += incY;\n", spc, iy);
                  }
               }
            }
            if ( (T < 2) || (NU-i > 2*lat) )
            {
               fprintf(fpout, "%s   m%d = x%d * alpha;\n", spc, i%lat, x%Xregs);
               if ( (T < 2) || (NU-i > Xregs+2*lat) )
               {
                  if (incX != INC_X)
                  {
                     if (ix) fprintf(fpout, "%s   x%d = x[%d];\n", spc, i%Xregs,
                                     incX*ix);
                     else fprintf(fpout, "%s   x%d = *x;\n", spc, i%Xregs);
                  }
                  else
                  {
                     fprintf(fpout, "%s   x%d = *xr%d;\n", spc, i%Xregs, ix);
                     fprintf(fpout, "%s   *xr%d += incX;\n", spc, ix);
                  }
               }
            }
         }
      }
      if (T == 1)
      {
         if (incY != inc_X) fprintf(fpout, "%s   y += %d;\n", spc, NU);
         if (incX != inc_X) fprintf(fpout, "%s   x += %d;\n", spc, NU);
         spc += 3;
         if (incX != inc_X)
            fprintf(fpout, "%s   }\n%s   while(x != stX0);\n", spc, spc);
         else fprintf(fpout, "%s   }\n%s   while(xr0 != stX0);\n", spc, spc);
      }
   }
}

void emit_scal_latX(FILE *fpout, char *spc, int nu, int numul, int lat,int incX)
{
   int rk, wk, k, rr;
   int NU=nu*numul;
   int *patt;

   patt = GetPattern(nu, numul);

   if (incX != INCX_X)
   {
      fprintf(fpout, "%s   m0 = *x;\n", spc);
      fprintf(fpout, "%s   m0 *= alpha;\n", spc);
      for (rk=1; rk < lat; rk++)
      {
         fprintf(fpout, "%s   m%d = x[%d];\n", spc, rk, patt[rk]*incX);
         fprintf(fpout, "%s   m%d *= alpha;\n", spc, rk);
      }
      for (wk=0; rk < NU; rk++, wk++)
      {
         if (patt[wk]) 
            fprintf(fpout, "%s   x[%d] = m%d;\n", spc, patt[wk]*incX, wk%lat);
         else fprintf(fpout, "%s   *x = m%d;\n", spc, wk%lat);
         fprintf(fpout, "%s   m%d = x[%d];\n", spc, wk%lat, patt[rk]*incX);
         fprintf(fpout, "%s   m%d *= alpha;\n", spc, wk%lat);
      }

      fprintf(fpout, "%s   if (n != %d)\n%s   {\n", spc, NU, spc);
      spc -= 3;
      fprintf(fpout, "%s   do\n%s   {\n", spc, spc);
      spc -= 3;
      rr = NU;
      for (rk=0; rk < NU; rk++)
      {
         if (patt[wk])
            fprintf(fpout, "%s   x[%d] = m%d;\n", spc, patt[wk]*incX, rk%lat);
         else fprintf(fpout, "%s   *x = m%d;\n", spc, rk%lat);
         if (patt[rk]+rr) fprintf(fpout, "%s   m%d = x[%d];\n", spc, rk%lat, 
                                  (patt[rk]+rr)*incX);
         else fprintf(fpout, "%s   m%d = *x;\n", spc, rk%lat);
         fprintf(fpout, "%s   m%d *= alpha;\n", spc, rk%lat);
         if (++wk == NU)
         {
            wk = rr = 0;
            fprintf(fpout, "%s   x += %d;\n", spc, incX*NU);
         }
      }
      spc += 3;
      fprintf(fpout, "%s   }\n%s   while(x != stX);\n", spc, spc);
      spc += 3;
      fprintf(fpout, "%s   }\n", spc);
      for (rk=0; wk < NU; wk++)
         fprintf(fpout, "%s   x[%d] = m%d;\n", spc, patt[wk]*incX, rk++);
      fprintf(fpout, "%s   x += %d;\n", spc, incX*NU);
   }
   else
   {
   }
   free(patt);
}
void emit_scal_latn1(FILE *fpout, char *spc, int nu, int numul, int lat, 
                     int incX)
{
   int rk, wk, k, rr;
   int NU=nu*numul;
   int *patt;

   patt = malloc(NU*sizeof(int));
   assert(patt);
   for (k=rk=0; rk < nu; rk++)
      for (wk=0; wk < numul; wk++) patt[k++] = wk*nu+rk;

   if (incX != INCX_X)
   {
      fprintf(fpout, "%s   m0 = -(*x);\n", spc);
      for (rk=1; rk < lat; rk++)
         fprintf(fpout, "%s   m%d = -x[%d];\n", spc, rk, patt[rk]*incX);
      for (wk=0; rk < NU; rk++, wk++)
      {
         if (patt[wk]) 
            fprintf(fpout, "%s   x[%d] = m%d;\n", spc, patt[wk]*incX, wk%lat);
         else fprintf(fpout, "%s   *x = m%d;\n", spc, wk%lat);
         fprintf(fpout, "%s   m%d = -x[%d];\n", spc, wk%lat, patt[rk]*incX);
      }

      fprintf(fpout, "%s   if (n != %d)\n%s   {\n", spc, NU, spc);
      spc -= 3;
      fprintf(fpout, "%s   do\n%s   {\n", spc, spc);
      spc -= 3;
      rr = NU;
      for (rk=0; rk < NU; rk++)
      {
         if (patt[wk])
            fprintf(fpout, "%s   x[%d] = m%d;\n", spc, patt[wk]*incX, rk%lat);
         else fprintf(fpout, "%s   *x = m%d;\n", spc, rk%lat);
         if (patt[rk]+rr) fprintf(fpout, "%s   m%d = -x[%d];\n", spc, rk%lat, 
                                  (patt[rk]+rr)*incX);
         else fprintf(fpout, "%s   m%d = -(*x);\n", spc, rk%lat);
         if (++wk == NU)
         {
            wk = rr = 0;
            fprintf(fpout, "%s   x += %d;\n", spc, incX*NU);
         }
      }
      spc += 3;
      fprintf(fpout, "%s   }\n%s   while(x != stX);\n", spc, spc);
      spc += 3;
      fprintf(fpout, "%s   }\n", spc);
      for (rk=0; wk < NU; wk++)
         fprintf(fpout, "%s   x[%d] = m%d;\n", spc, patt[wk]*incX, rk++);
      fprintf(fpout, "%s   x += %d;\n", spc, incX*NU);
   }
   else
   {
   }
}

void emit_XY_NU1(FILE *fpout, int timing, char pre, char *type,
                 int alpha, int incX, int beta, int incY)
{
   char ctst='X', cx='i', cy='i';
   if (incX == 1) fprintf(fpout, "   const register n = N;\n");
   else if (incY == 1)
   {
      fprintf(fpout, "   const register n = N;\n");
      ctst = 'Y';
   }
   else if (incX != INC_X)
      fprintf(fpout, "   const register n = %s;\n", GetInc(incX, "N"));
   else if (incY != INC_X)
      fprintf(fpout, "   const register n = %s;\n", GetInc(incY, "N"));
   else fprintf(fpout, "   const register n = N*incX;\n");
   fprintf(fpout, "   register int i");
   if (incX != incY || incX == INC_X || incY == INC_X)
   {
      fprintf(fpout, ", j");
      cy = 'j';
   }
   fprintf(fpout, ";\n");

   if (incX == INCX_X)
   {
      if (incY == INCX_X)
         fprintf(fpout, "   for (i=j=0; i != n; i += incX, j += incY)\n");
      else if (incY == 1)
         fprintf(fpout, "   for (i=j=0; j != n; i += incX, j++)\n");
      else fprintf(fpout, "   for (i=j=0; j != n; i += incX, j += %d)\n", incY);
   }
   else if (incX == 1)
   {
      if (incY == INC_X) 
         fprintf(fpout, "   for (i=j=0; i != n; i++, j += incY)\n");
      else if (incY == 1) fprintf(fpout, "   for (i=0; i != n; i++)\n");
      else fprintf(fpout, "   for (i=j=0; i != n; i++, j += %d)\n", incY);
   }
   else
   {
      if (incY == INC_X)
         fprintf(fpout, "   for (i=j=0; i != n; i += %d, j += incY)\n", incX);
      else if (incY == 1)
         fprintf(fpout, "   for (i=j=0; j != n; i += %d, j++)\n", incX);
      else 
      {
         if (incX != incY)
            fprintf(fpout, "   for (i=j=0; i != n; i += %d, j += %d)\n", 
                    incX, incY);
         else
            fprintf(fpout, "   for (i; i != n; i += %d)\n", incX);
      }
   }

   switch(Rout)
   {
   case Swap:
      fprintf(fpout, "   {\n");
      fprintf(fpout, "      tmp = y[%c];\n", cy);
      fprintf(fpout, "      y[%c] = x[%c];\n", cy, cx);
      fprintf(fpout, "      x[%c] = tmp;\n", cx);
      fprintf(fpout, "   }\n");
      break;
   case Copy:
      fprintf(fpout, "      y[%c] = x[%c];\n", cy, cx);
      break;
   case Axpy:
      if (alpha == 1) fprintf(fpout, "      y[%c] += x[%c];\n", cy, cx);
      else if (alpha == -1) fprintf(fpout, "      y[%c] -= x[%c];\n", cy, cx);
      else fprintf(fpout, "      y[%c] += alpha*x[%c];\n", cy, cx);
      break;
   case Dot :
      fprintf(fpout, "      dot += x[%c] * y[%c];\n", cx, cy);
      break;
   case Axpby:
      if (beta == -1) fprintf(fpout, "      y[%c] = x[%c] - y[%c];\n",cy,cx,cy);
      else fprintf(fpout, "      y[%c] = alpha*x[%c] + beta*y[%c];\n",cy,cx,cy);
      break;
   case Ax  :
      if (alpha == -1) fprintf(fpout, "      y[%c] = -x[%c];\n", cy, cx);
      else fprintf(fpout, "      y[%c] = alpha*x[%c];\n", cy, cx);
      break;
   }
}
void emit_XY(FILE *fpout, int timing, char pre, char *type, int nu, int numul,
             int lat, int alpha, int incX, int beta, int incY)
{

      switch(Rout)
      {
      case Swap:
         break;
      case Scal:
         break;
      case Copy:
         break;
      case Axpy:
         break;
      case Dot :
         break;
      case Nrm :
         break;
      case Amax:
         break;
      case Axpby:
         break;
      case Ax  :
         break;
      }
}
void emit_scal(FILE *fpout, int timing, char pre, char *type, int nu, int numul,
               int lat, int alpha, int incX)
{
   char *spcs = "                        ";
   char *spc = spcs+24;
   char ln[128];
   int pwr2_nu = GetPower2(nu*numul);
   int i, j, k, NU = nu*numul;
   void (*emit_scal_lat)(FILE *fpout, char *spc, int nu, int numul, int lat, 
                         int incX);

   if (incX == INCX_X || alpha == 0) lat = 0;  /* might want to nix this */

   if (timing) fprintf(fpout, "#include<stdlib.h>\n");
   if (NU > 1)
   {
      fprintf(fpout, "#define ATL_MulByCachelen(N_) ((N_)<<5)\n");
      fprintf(fpout, "#define ATL_DivByCachelen(N_) ((N_)>>5)\n");
      if (pwr2_nu)
      {
         fprintf(fpout, "#define ATL_MulByNU_(N_) ((N_)<<%d)\n", pwr2_nu);
         fprintf(fpout, "#define ATL_DivByNU_(N_) ((N_)>>%d)\n", pwr2_nu);
      }
      else
      {
         fprintf(fpout, "#define ATL_MulByNU_(N_) ((N_)*%d)\n", nu*numul);
         fprintf(fpout, "#define ATL_DivByNU_(N_) ((N_)/%d)\n", nu*numul);
      }
   }
   if (!timing)
   {
      if (alpha == 0 || alpha == 1)
         fprintf(fpout, "void ATL_%cscal_a%d_", pre, alpha);
      else if (alpha == -1)
         fprintf(fpout, "void ATL_%cscal_an1_", pre);
      else fprintf(fpout, "void ATL_%cscal_aX_", pre);
      if (incX == INCX_X) fprintf(fpout, "X");
      else fprintf(fpout, "%d", incX);
   }
   else fprintf(fpout, "void ATL_scalT");
   fprintf(fpout, "(const int N, const %s alph0, %s *X, const int incX)\n",
           type, type);
   fprintf(fpout, "{\n");
   if (alpha != 0 && alpha != -1)
      fprintf(fpout, "   const register %s alpha=alph0;\n", type);
   if (NU == 1)
   {
      fprintf(fpout, "   register int i;\n");
      if (incX == 1)
      {
         fprintf(fpout, "   const register int n=N;\n");
         if (alpha == 0)
            fprintf(fpout, "   for(i=0; i != n; i++) X[i] = 0.0;\n");
         else if (alpha == -1)
            fprintf(fpout, "   for(i=0; i != n; i++) X[i] = -X[i];\n");
         else fprintf(fpout, "   for(i=0; i != n; i++) X[i] *= alpha;\n");
      }
      else if (incX == INCX_X)
      {
         fprintf(fpout, "   const register int n=N*incX;\n");
         if (alpha == 0)
            fprintf(fpout, "   for(i=0; i != n; i += incX) X[i] = 0.0;\n");
         else if (alpha == -1)
            fprintf(fpout, "   for(i=0; i != n; i += incX) X[i] = -X[i];\n");
         else fprintf(fpout, "   for(i=0; i != n; i += incX) X[i] *= alpha;\n");
      }
      else
      {
         fprintf(fpout, "   const register int n=%s;\n", GetInc(incX, "N"));
         if (alpha == 0)
            fprintf(fpout, "   for(i=0; i != n; i += %d) X[i] = 0.0;\n", incX);
         else if (alpha == -1)
            fprintf(fpout, "   for(i=0; i != n; i += %d) X[i] = -X[i];\n", 
                    incX);
         else fprintf(fpout, "   for(i=0; i != n; i += %d) X[i] *= alpha;\n",
                      incX);
      }
      fprintf(fpout, "}\n");
      return;
   }
   else
   {
      if (incX == INCX_X)
      {
         fprintf(fpout, "   const int n = ATL_MulByNU_(ATL_DivByNU_(N));\n");
         fprintf(fpout, "   const int incx=ATL_MulByNU_(incX);\n");
         fprintf(fpout, "   %s *stX=X+incX*n, *x0=X", type);
         for (i=1; i < NU; i++) fprintf(fpout, ", *x%d=x%d+incX", i, i-1);
         fprintf(fpout, ";\n");
         fprintf(fpout, "   #define x x0\n");
      }
      else
      {
         fprintf(fpout, "   const int align = ( ((size_t) X) - (ATL_MulByCachelen(ATL_DivByCachelen((size_t)X))) )/sizeof(%s);\n", type);
         fprintf(fpout, "   const int n = ATL_MulByNU_(ATL_DivByNU_(N-align));\n");
         fprintf(fpout, "   %s *x=X, *stX;\n", type);
      }
   }
   if (lat)
   {
      if (alpha == -1) emit_scal_lat = emit_scal_latn1;
      else emit_scal_lat = emit_scal_latX;
      if (lat > NU) lat = NU;
      while (NU % lat) lat--;
      fprintf(fpout, "   register %s m0", type);
      for (i=1; i < lat; i++) fprintf(fpout, ", m%d", i);
      fprintf(fpout, ";\n");
   }
   fprintf(fpout, "\n");
   if (NU > 1 && incX != INCX_X)
   {
      fprintf(fpout, "   if (!align) /* already on cache line boundary */\n");
      if (!lat)
      {
         if (incX == 1) fprintf(fpout, "      stX = X + n;\n");
         else if (incX != INCX_X)
            fprintf(fpout, "      stX = X + %s;\n", GetInc(incX, "n"));
         else fprintf(fpout, "      stX = X + n*incX;\n");
      }
      else
      {
         if (incX == 1) fprintf(fpout, "      stX = X + n - %d;\n", NU);
         else if (incX != INCX_X)
         {
            sprintf(ln, "(n - %d)", NU);
            fprintf(fpout, "      stX = X + %s;\n", GetInc(incX, ln));
         }
         else fprintf(fpout, "      stX = X + (n - %d)*incX;\n", NU);
      }
      fprintf(fpout, "   else        /* adjust op to cache line boundary */\n");
      fprintf(fpout, "   {\n");
      if (incX == 1)
      {
         fprintf(fpout, "      stX = X + ((align > N) ? N : align);\n");
         if (alpha == -1)
            fprintf(fpout, "      do *x = -(*x); while (++x != stX);\n");
         else if (alpha == 0)
            fprintf(fpout, "      do *x = 0.0; while (++x != stX);\n");
         else fprintf(fpout, "      do *x *= alpha; while (++x != stX);\n");
         fprintf(fpout, "      if (align >= N) return;\n");
         if (!lat) fprintf(fpout, "      stX += n;\n");
         else fprintf(fpout, "      stX += n - %d;\n", NU);
      }
      else
      {
         fprintf(fpout, "      if (align <= N) stX = X + %s;\n", 
                 GetInc(incX, "align"));
         fprintf(fpout, "      else stX = X + %s;\n", GetInc(incX, "N"));
         fprintf(fpout, "      do\n      {\n");
         if (alpha == -1) fprintf(fpout, "         *x = -(*x);\n");
         else if (alpha == 0) fprintf(fpout, "         *x = 0.0;\n");
         else fprintf(fpout, "         *x *= alpha;\n");
         if (incX == 2) fprintf(fpout, "         x += 2;\n");
         else fprintf(fpout, "         x += incX;\n");
         fprintf(fpout, "      }\n      while(x != stX);\n");
         fprintf(fpout, "      if (align >= N) return;\n");
         if (!lat)
         {
            if (incX == 1) fprintf(fpout, "      stX += n;\n");
            else if (incX != INCX_X)
               fprintf(fpout, "      stX += %s;\n", GetInc(incX, "n"));
            else fprintf(fpout, "      stX += n*incX;\n");
         }
         else
         {
            if (incX == 1) fprintf(fpout, "      stX += n - %d;\n", NU);
            else if (incX != INCX_X)
            {
               sprintf(ln, "(n - %d)", NU);
               fprintf(fpout, "      stX += %s;\n", GetInc(incX, ln), incX*NU);
            }
            else fprintf(fpout, "      stX += (n - %d)*incX;\n", NU);
         }
      }
      fprintf(fpout, "   }\n");
   }
   fprintf(fpout, "   if (n)\n   {\n");
   spc -= 3;
   if (alpha == 0 || lat == 0)
   {
      fprintf(fpout, "%s   do /* while (x != stX) */\n%s   {\n", spc, spc);
      spc -= 3;
      if (incX != INCX_X)
      {
         if (alpha == -1)
         {
            fprintf(fpout, "%s   *x = -(*x);\n", spc);
            for (i=0; i < nu; i++)
               for (j=0; j < numul; j++)
                  if (i || j) fprintf(fpout, "%s   x[%d] = -x[%d];\n", spc, 
                                      (j*nu+i)*incX, (j*nu+i)*incX);
         }
         else if (alpha == 0)
         {
            fprintf(fpout, "%s   *x =", spc);
            for (i=0; i < nu; i++)
               for (j=0; j < numul; j++)
                  if (i || j) fprintf(fpout, " x[%d] =", (j*nu+i)*incX);
            fprintf(fpout, " 0.0;\n");
         }
         else
         {
            fprintf(fpout, "%s   *x *= alpha;\n", spc);
            for (i=0; i < nu; i++)
               for (j=0; j < numul; j++)
                  if (i || j) fprintf(fpout, "%s   x[%d] *= alpha;\n", spc, 
                                      (j*nu+i)*incX);
         }
         fprintf(fpout, "%s   x += %d;\n", spc, NU*incX);
      }
      else
      {
         if (alpha == -1)
         {
            for (i=0; i < nu; i++)
            {
               for (j=0; j < numul; j++)
               {
                  fprintf(fpout, "%s   *x%d = -(*x%d);\n", spc, 
                                      j*nu+i, j*nu+i);
                  fprintf(fpout, "%s   x%d += incx;\n", spc, j*nu+i);
               }
            }
         }
         else if (alpha == 0)
         {
            fprintf(fpout, "%s   *x =", spc);
            for (i=0; i < nu; i++)
               for (j=0; j < numul; j++)
                  if (i || j) fprintf(fpout, " *x%d =", j*nu+i);
            fprintf(fpout, " 0.0;\n");
            for (i=0; i < nu; i++)
               for (j=0; j < numul; j++)
                  fprintf(fpout, "%s   x%d += incx;\n", spc, j*nu+i);
         }
         else
         {
            for (i=0; i < nu; i++)
            {
               for (j=0; j < numul; j++)
               {
                  fprintf(fpout, "%s   *x%d *= alpha;\n", spc, j*nu+i);
                  fprintf(fpout, "%s   x%d += incx;\n", spc, j*nu+i);
               }
            }
         }
      }
      spc += 3;
      fprintf(fpout, "%s   }\n%s   while(x != stX);\n", spc, spc);
   }
   else  /* need to do latency hiding */
      emit_scal_lat(fpout, spc, nu, numul, lat, incX);
   spc += 3;
   fprintf(fpout, "   }\n");

   if (NU > 1)
   {
      if (incX == 1) fprintf(fpout, "   stX = X + N;\n");
      else if (incX == INCX_X) fprintf(fpout, "   stX = X + N*incX;\n");
      else fprintf(fpout, "   stX = X + %s;\n", GetInc(incX, "N"));
      if (alpha == 0)
      {
         if (incX == 1)
            fprintf(fpout, 
                    "   if (x != stX) do *x = 0.0; while (++x != stX);\n");
         else
         {
            fprintf(fpout, "   if (x != stX)\n   {\n");
            spc -= 3;
            fprintf(fpout, "%s   do\n%s   {\n", spc, spc);
            spc -= 3;
            fprintf(fpout, "%s   *x = 0.0;\n", spc);
            if (incX == INCX_X) fprintf(fpout, "%s   x += incX;\n", spc);
            else fprintf(fpout, "%s   x += %d;\n", spc, incX);
            spc += 3;
            fprintf(fpout, "%s   }\n%s   while(x != stX);\n", spc, spc);
            spc += 3;
            fprintf(fpout, "%s   }\n", spc);
         }
      }
      else if (alpha == -1)
      {
         if (incX == 1)
            fprintf(fpout, 
                    "   if (x != stX) do *x = -(*x); while (++x != stX);\n");
         else
         {
            fprintf(fpout, "   if (x != stX)\n   {\n");
            spc -= 3;
            fprintf(fpout, "%s   do\n%s   {\n", spc, spc);
            spc -= 3;
            fprintf(fpout, "%s   *x = -(*x);\n", spc);
            if (incX == INCX_X) fprintf(fpout, "%s   x += incX;\n", spc);
            else fprintf(fpout, "%s   x += %d;\n", spc, incX);
            spc += 3;
            fprintf(fpout, "%s   }\n%s   while(x != stX);\n", spc, spc);
            spc += 3;
            fprintf(fpout, "%s   }\n", spc);
         }
      }
      else
      {
         if (incX == 1)
            fprintf(fpout, 
                    "   if (x != stX) do *x *= alpha; while (++x != stX);\n");
         else
         {
            fprintf(fpout, "   if (x != stX)\n   {\n");
            spc -= 3;
            fprintf(fpout, "%s   do\n%s   {\n", spc, spc);
            spc -= 3;
            fprintf(fpout, "%s   *x *= alpha;\n", spc);
            if (incX == INCX_X) fprintf(fpout, "%s   x += incX;\n", spc);
            else fprintf(fpout, "%s   x += %d;\n", spc, incX);
            spc += 3;
            fprintf(fpout, "%s   }\n%s   while(x != stX);\n", spc, spc);
            spc += 3;
            fprintf(fpout, "%s   }\n", spc);
         }
      }
   }
   fprintf(fpout, "}\n");
   fprintf(fpout, "#undef ATL_MulByNU_\n#undef ATL_DivByNU_\n");
   fprintf(fpout, "#undef ATL_MulByCachelen\n");
   fprintf(fpout, "#undef ATL_DivByCachelen\n");
}

void PrintUsage(char *nam)
{
   fprintf(stderr, "USAGE: %s -R <rout> -p <s/d> -n <nu> -M <nu multiplier> -l <latency> -m <muladd(0/1) -a <alpha> -b <beta> -X <incX> -Y <incY> -f <file> -t <using timer>\n", nam);
   exit(-1);
}

void GetFlags(int nargs, char *args[], char *pre, int *nu, int *numul, int *lat,
              int *muladd, int *alpha, int *beta, int *incX, int *incY, 
              int *TIMING, FILE **fpout)
{
   int i;
/*
 * Set defaults
 */
   *pre = 'd';
   *nu = 1;
   *numul = 1;
   *lat = 0;
   *muladd = 1;
   *incX = 1;
   *incY = 1;
   *alpha = *beta = INCX_X;
   *fpout = stdout;
   *TIMING = 0;

   for (i=1; i < nargs; i++)
   {
      if (*args[i] != '-') PrintUsage(args[0]);
      switch(args[i][1])
      {
      case 't':
         *TIMING = 1;
         break;
      case 'p':
         *pre = *args[++i];
         break;
      case 'f':
         *fpout = fopen(args[++i], "w");
         assert(*fpout != NULL);
         break;
      case 'a':
         *alpha = atoi(args[++i]);
         break;
      case 'b':
         *beta = atoi(args[++i]);
         break;
      case 'n':
         *nu = atoi(args[++i]);
         break;
      case 'M':
         *numul = atoi(args[++i]);
         break;
      case 'l':
         *lat = atoi(args[++i]);
         break;
      case 'm':
         *muladd = atoi(args[++i]);
         break;
      case 'X':
         *incX = atoi(args[++i]);
         break;
      case 'Y':
         *incY = atoi(args[++i]);
         break;
      case 'R':
          Rout = atoi(args[++i]);
          break;
      case 'h':
         PrintUsage(args[0]);
      default :
         fprintf(stderr, "Unknown flag '%s'!!\n", args[i]);
         PrintUsage(args[0]);
      }
   }
}

int main(int nargs, char *args[])
{
   char pre, *TYPE;
   int nu, numul, muladd, lat, incX, incY, alpha, beta, timing;
   FILE *fpout;

   GetFlags(nargs, args, &pre, &nu, &numul, &lat, &muladd, &alpha, &beta,
            &incX, &incY, &timing, &fpout);
   switch(pre)
   {
   case 's':
      TYPE = "float";
      break;
   case 'd':
      TYPE = "double";
      break;
   case 'c':
      TYPE = "float";
      break;
   case 'z':
      TYPE = "double";
   case 'q':
      TYPE = "long double";
      break;
   }
   if (incX == 0) incX = INCX_X;
   if (incY == 0) incY = INCX_X;

   if (incX == INCX_X) sprintf(ixs, "xX");
   else if (incX < 0) sprintf(ixs, "xn%d", -incX);
   else sprintf(ixs, "x%d", incX);

   if (incY == INCX_X) sprintf(iys, "yX");
   else if (incY < 0) sprintf(iys, "yn%d", -incY);
   else sprintf(iys, "y%d", incY);

   if (alpha = -1) sprintf(as, "an1");
   else if (alpha == 1 || alpha == 0) sprintf(as, "a%d", alpha);
   else sprintf(as, "aX");

   if (alpha = -1) sprintf(bs, "bn1");
   else if (alpha == 1 || alpha == 0) sprintf(bs, "b%d", alpha);
   else sprintf(bs, "bX");

   fprintf(stderr, "pre=%c, nu=%d, numul=%d, lat=%d, alpha=%d, incX=%d\n",
           pre, nu, numul, lat, alpha, incX);
   emit_scal(fpout, timing, pre, TYPE, nu, numul, lat, alpha, incX);
   if (fpout != stdout && fpout != stderr) fclose(fpout);
   return(0);
}
@ROUT scaltst
@extract -b @(topd)/gen.inc what=cw
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include "atlas_misc.h"
#include "atlas_tst.h"

void MAIN_(){}
void MAIN__(){}
double time00(void);
void Mjoin(PATL,scal0)(const int, const SCALAR, TYPE*, const int);
#define trusted_scal(N_, alp_, x_, incX_) \
    Mjoin(PRE,scal_)(&(N_), &(alp_), (x_), &(incX_));
#define test_scal(N_, alp_, x_, incX_) \
    Mjoin(PATL,scal0)((N_), (alp_), (x_), (incX_));

int scalcase(int misalign, int mflops, int N, SCALAR alpha, int incX)
{
   char *form="%4d   %6d   %8d   %6.2f   %4d   %8.4f   %8.2f   %7.2f   %4s\n";
   static int itst=0;
   SCALAR alp, alpinv = 0.0;
   void *vx;
   TYPE *X, *x, *stX;
   int incx = N*incX;
   int i, nn, reps, PASSED;
   double t0, t1, t2, fmflop;
   char *spass;

   if (alpha != 0.0) alpinv = 1.0 / alpha;
   reps = (mflops * 1000000) / N;
   if (reps < 1) reps = 1;
   nn = (ATL_DivBySize(L2SIZE)+N-1) / N;
   if (nn < 2) nn = 2;
   else if (nn%2) nn++;
   i = ATL_DivBySize(ATL_Cachelen);
   incx = N;
   while (incx%i) incx++;
   incx *= incX;
   vx = malloc((nn*incx+misalign)*ATL_sizeof+ATL_Cachelen);
   assert(vx);
   x = ATL_AlignPtr(vx);
   x += misalign;
   X = x;
   stX = x + nn * incx;
   dumb_seed(N);
   while (x != stX) *x++ = dumb_rand();
   x = X;
   alp = alpha;

   t0 = time00();
   for (i=reps; i; i--)
   {
      trusted_scal(N, alp, x, incX);
      x += incx;
      if (x == stX) 
      {
         x = X;
         if (alp == alpha) alp = alpinv;
         else alp = alpha;
      }
   }
   t1 = time00() - t0;
   t1 /= (1.0*reps);
   if (t1 != 0.0) fmflop = (1.0*N) / (1000000.0*t1);
   else fmflop = 0.0;
   printf(form, ++itst, N, misalign, alpha, incX, t1, fmflop, 1.0, "----");

   dumb_seed(N);
   x = X;
   while (x != stX) *x++ = dumb_rand();
   x = X;
   alp = alpha;
   t0 = time00();
   for (i=reps; i; i--)
   {
      test_scal(N, alp, x, incX);
      x += incx;
      if (x == stX)
      {
         x = X;
         if (alp == alpha) alp = alpinv;
         else alp = alpha;
      }
   }
   t2 = time00() - t0;

   x = X + incx;
   for (i=0; i != N; i++) x[i*incX] = X[i*incX] = dumb_rand();
   trusted_scal(N, alpha, X, incX);
   test_scal(N, alpha, x, incX);
   PASSED = 1;
   spass = "PASS";
   for (i=0; i != N; i++)
   {
      if (x[i*incX] != X[i*incX])
      {
         PASSED = 0;
         spass = "FAIL";
         fprintf(stdout, "  Error: X[%d]=%f, Xtest=%f;", i*incX, 
                 X[i*incX], x[i*incX]);
      }
   }
   if (!PASSED) fprintf(stdout, "\n");
   free(vx);
   t2 /= (1.0*reps);
   if (t2 != 0.0)
   {
      fmflop = (1.0*N) / (1000000.0*t2);
      t0 = t1 / t2;
   }
   else t0 = fmflop = 0.0;
   printf(form, itst, N, misalign, alpha, incX, t2, fmflop, t0, spass);
   return(PASSED);
}
void PrintUsage(char *nam)
{
   fprintf(stderr, "USAGE: %s -n <N> -m <misalign> -a <alpha> -x <incX> -N <N0> <NN> <Ninc> -M <#> <align1> ... <align#> -A <#> <alpha1> ... <alpha#> -X <#> <incX1> ... <incX#> -F <mflops>\n", nam);
   exit(-1);
}
int main(int nargs, char *args[])
{
   
   int mflops=50;
   int n0=100, nN=1000, ninc = 100;
   int nmisalign=0, nalpha=0, nincX=0;
   int *misaligns, *incXs, ali=0, iX=1;
   int i, n, in, im, ia, ix;
   int npassed=0, ntests=0;
   TYPE *alphas, alp=3.8;

   for (i=1; i < nargs; i++)
   {
      if (*args[i] != '-') PrintUsage(args[0]);
      switch(args[i][1])
      {
      case 'h':
         PrintUsage(args[0]);
         break;
      case 'F':
         mflops = atoi(args[++i]);
         break;
      case 'n':
         n0 = nN = ninc = atoi(args[++i]);
         break;
      case 'N':
         n0 = atoi(args[++i]);
         nN = atoi(args[++i]);
         ninc = atoi(args[++i]);
         break;
      case 'm':
         ali = atoi(args[++i]);
         break;
      case 'M':
         nmisalign = atoi(args[++i]);
         misaligns = malloc(nmisalign*sizeof(int));
         assert(misaligns);
         for (im=0; im < nmisalign; im++) misaligns[im] = atoi(args[++i]);
         break;
      case 'x':
         iX = atoi(args[++i]);
         break;
      case 'X':
         nincX = atoi(args[++i]);
         incXs = malloc(nincX*sizeof(int));
         assert(incXs);
         for (im=0; im < nincX; im++) incXs[im] = atoi(args[++i]);
         break;
      case 'a':
         alp = atof(args[++i]);
         break;
      case 'A':
         nalpha = atoi(args[++i]);
         alphas = malloc(nalpha*ATL_sizeof);
         assert(alphas);
         for (im=0; im < nalpha; im++) alphas[im] = atof(args[++i]);
         break;
      }
   }
   if (nmisalign == 0)
   {
      nmisalign = 1;
      misaligns = &ali;
   }
   if (nincX == 0)
   {
      nincX = 1;
      incXs = &iX;
   }
   if (nalpha == 0)
   {
      nalpha = 1;
      alphas = &alp;
   }
   printf( "ITST        N   MISALIGN    ALPHA   INCX   TIME (s)     MFLOPS   SPEEDUP   PASS\n");
   printf("====   ======   ========   ======   ====   ========   ========   =======   ====\n");
   for (n=n0; n <= nN; n += ninc)
   {
      for (im=0; im < nmisalign; im++)
      {
         for (ia=0; ia < nalpha; ia++)
         {
            for (ix=0; ix < nincX; ix++)
            {
               ntests++;
               npassed += scalcase(misaligns[im], mflops, n, alphas[ia], 
                                   incXs[ix]);
            }
         }
      }
   }
   if (misaligns != &ali) free(misaligns);
   if (incXs != &iX) free(incXs);
   if (alphas != &alp) free(alphas);
   printf("***** Completed %d tests: %d passed, %d failed\n", 
          ntests, npassed, ntests-npassed);
   return(npassed == ntests);
}
@ROUT ATL_scal
@extract -b @(topd)/gen.inc what=cw
#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <assert.h>
#include "atlas_misc.h"
#include "atlas_f77.h"

#ifndef ATLSCAL
   #define Cscal Mjoin(PATL,scal)
   #define F77scal Mjoin(PRE,scal_)
#else
   #define Cscal Mjoin(PATL,scal0)
   #define F77scal Mjoin(PRE,scal0_)
#endif

#include Mstr(Mjoin(PATL,scal_an1_1.c))
#include Mstr(Mjoin(PATL,scal_a0_1.c))
#include Mstr(Mjoin(PATL,scal_aX_1.c))

#include Mstr(Mjoin(PATL,scal_an1_2.c))
#include Mstr(Mjoin(PATL,scal_a0_2.c))
#include Mstr(Mjoin(PATL,scal_aX_2.c))

#include Mstr(Mjoin(PATL,scal_an1_X.c))
#include Mstr(Mjoin(PATL,scal_a0_X.c))
#include Mstr(Mjoin(PATL,scal_aX_X.c))

@beginskip
void Mjoin(PATL,scal_an1_1)(const int, const SCALAR, TYPE *, const int);
void Mjoin(PATL,scal_a0_1)(const int, const SCALAR, TYPE *, const int);
void Mjoin(PATL,scal_aX_1)(const int, const SCALAR, TYPE *, const int);

void Mjoin(PATL,scal_an1_2)(const int, const SCALAR, TYPE *, const int);
void Mjoin(PATL,scal_a0_2)(const int, const SCALAR, TYPE *, const int);
void Mjoin(PATL,scal_aX_2)(const int, const SCALAR, TYPE *, const int);

void Mjoin(PATL,scal_an1_X)(const int, const SCALAR, TYPE *, const int);
void Mjoin(PATL,scal_a0_X)(const int, const SCALAR, TYPE *, const int);
void Mjoin(PATL,scal_aX_X)(const int, const SCALAR, TYPE *, const int);

@endskip
void Cscal(const int N, const SCALAR alpha, TYPE *X, const int incX)
{
   int i, n, incx=incX;
   if ( !N || SCALAR_IS_ONE(alpha) ) return;
   if (incX < 0) incx = -incX;
   if (incx == 1)
   {
      if ( SCALAR_IS_NONE(alpha) )
      {
#ifdef ATL_MINSCAL1_N
         if (N < ATL_MINSCAL1_N)
         {
            for (i=0; i != N; i++) X[i] = -X[i];
            return;
         }
#endif
         Mjoin(PATL, scal_an1_1)(N, alpha, X, 1);
      }
      else if ( SCALAR_IS_ZERO(alpha) )
      {
#ifdef ATL_MINSCAL1_N
         if (N < ATL_MINSCAL1_N)
         {
            for (i=0; i != N; i++) X[i] = 0.0;
            return;
         }
#endif
         Mjoin(PATL, scal_a0_1)(N, alpha, X, 1);
      }
      else
      {
#ifdef ATL_MINSCAL1_N
         if (N < ATL_MINSCAL1_N)
         {
            for (i=0; i != N; i++) X[i] *= alpha;
            return;
         }
#endif
         Mjoin(PATL, scal_aX_1)(N, alpha, X, 1);
      }
   }
   else if (incx == 2)
   {
      if ( SCALAR_IS_NONE(alpha) )
      {
#ifdef ATL_MINSCAL2_N
         if (N < ATL_MINSCAL2_N)
         {
            n = N << 1;
            for (i=0; i != n; i += 2) X[i] = -X[i];
            return;
         }
#endif
         Mjoin(PATL, scal_an1_2)(N, alpha, X, 1);
      }
      else if ( SCALAR_IS_ZERO(alpha) )
      {
#ifdef ATL_MINSCAL2_N
         if (N < ATL_MINSCAL2_N)
         {
            n = N << 1;
            for (i=0; i != n; i += 2) X[i] = 0.0;
            return;
         }
#endif
         Mjoin(PATL, scal_a0_2)(N, alpha, X, 1);
      }
      else
      {
#ifdef ATL_MINSCAL2_N
         if (N < ATL_MINSCAL2_N)
         {
            n = N << 1;
            for (i=0; i != n; i += 2) X[i] *= alpha;
            return;
         }
#endif
         Mjoin(PATL, scal_aX_2)(N, alpha, X, 1);
      }
   }
   else
   {
      if ( SCALAR_IS_NONE(alpha) )
      {
#ifdef ATL_MINSCALX_N
         if (N < ATL_MINSCALX_N)
         {
            n = N * incx;
            for (i=0; i != n; i += incx) X[i] = -X[i];
            return;
         }
#endif
         Mjoin(PATL, scal_an1_X)(N, alpha, X, incX);
      }
      else if ( SCALAR_IS_ZERO(alpha) )
      {
#ifdef ATL_MINSCALX_N
         if (N < ATL_MINSCALX_N)
         {
            n = N * incx;
            for (i=0; i != n; i += incx) X[i] = 0.0;
            return;
         }
#endif
         Mjoin(PATL, scal_a0_X)(N, alpha, X, incX);
      }
      else
      {
#ifdef ATL_MINSCALX_N
         if (N < ATL_MINSCALX_N)
         {
            n = N * incx;
            for (i=0; i != n; i += incx) X[i] *= alpha;
            return;
         }
#endif
         Mjoin(PATL, scal_aX_X)(N, alpha, X, incX);
      }
   }
}
#ifndef ATLSCAL
#include "atlas_f77scal.h"
#endif
@rout tsmfc
@extract -b @(topd)/gen.inc what=cw
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <math.h>
#include "atlas_misc.h"
#include "atlas_lvl3.h"
#include Mstr(Mjoin(Mjoin(atlas_,PRE),sysinfo.h))

#define dumb_seed(iseed_) srand(iseed_)
#ifndef RAND_MAX  /* rather dangerous non-ansi workaround */
   #define RAND_MAX ((unsigned long)(1<<30))
#endif
#define dumb_rand() ( 0.5 - ((double)rand())/((double)RAND_MAX) )

double time00(void);

#ifndef DENMAT
   #define DENMAT 200
#endif

#ifdef Right_
   char Side = 'R';
#else
   char Side = 'L';
#endif
#ifdef Upper_
   char Uplo = 'U';
#else
   char Uplo = 'L';
#endif
#ifdef Transpose_
   char Tran = 'T';
#else
   char Tran = 'N';
#endif
#ifdef UnitDiag_
   char Diag = 'U';
#else
   char Diag = 'N';
#endif

@beginskip
#ifdef TREAL
void ATL_big_trsm(const int M, const int N, const void *valpha, const void *A,
                  const int lda, void *C, const int ldc);
void ATL_small_trsm(const int M, const int N, const void *valpha, const void *A,
                  const int lda, void *C, const int ldc);
#endif

void SetDiag(int N, SCALAR alpha, TYPE *A, int lda)
{
   int i;
   const int ldap1 = lda+1;

   for (i=0; i != N; i++)
   {
      *A = alpha;
      A += ldap1;
   }
}

void matgen(int M, int N, TYPE *A, int lda, int seed)
{
   int i, j;

   dumb_seed(seed);
   for (j=N; j; j--)
   {
      for (i=0; i != M SHIFT; i++) A[i] = dumb_rand();
      A += lda SHIFT;
   }
}


double smcase(int M, int N, SCALAR alpha)
{
   const char *form="   %c     %c     %c %5d %5d  %7.2f  %14.4f  %11.2f  %7.2f\n";
   const int lda=2*M, ldb=2*M;
   const int incA=lda*M, incB=ldb*N;
   int i, la, lb, reps;
   TYPE *a, *A, *b, *B, *ast, *bst;
   double t0, t1, t2, mf, mflop;

   i = M*M;
   la = ((ATL_DivBySize((2*L2SIZE)/3) + i-1) / i)*incA;
   a = A = malloc(ATL_MulBySize(la));
   assert(a != NULL);
   ast = A + la;

   i = M*N;
   lb = ((ATL_DivBySize((2*L2SIZE)/3) + i-1) / i)*incB;
   b = B = malloc(ATL_MulBySize(lb));
   assert(b != NULL);
   bst = B + lb;
/*
 * Set A to identity, so we can solve multiple times without overflowing
 */
   for (i=0; i != la; i++) a[i] = 0.0;
   while (a != ast)
   {
      SetDiag(M, 1.0, a, lda);
      a += incA;
   }
   a = A;
   matgen(lb, 1, B, lb, M*1245);
/*
 * preload instructions from disk
 */
   ATL_big_trsm(M, N, SADD alpha, A, lda, B, ldb);
   ATL_small_trsm(M, N, SADD alpha, A, lda, B, ldb);
   matgen(lb, 1, B, lb, M*1245);
/*
 * Insist we have as many flops as doing a matmul of order DENMAT
 */
   #ifdef Right_
      mf = (((double)M)*N)*N;
   #else
      mf = (((double)M)*M)*N;
   #endif
   #ifdef ATL_nkflop
      t0 = 1000.0 * ATL_nkflop;
   #else
      t0 = DENMAT;
      t0 *= t0*t0;
      t0 *= 2.0;
   #endif
   t0 /= mf;
   reps = t0 + 0.99;
   if (!reps) reps = 1;

   i = reps;
   t0 = time00();
   do
   {
      ATL_small_trsm(M, N, SADD alpha, a, lda, b, ldb);
      a += incA;
      b += incB;
      if (a == ast) a = A;
      if (b == bst) b = B;
   }
   while(--i);
   t1 = time00() - t0;
   if (t1 <= 0.0) mflop = t1 = 0.0;
   else mflop = (mf * reps) / (t1*1000000.0);
   fprintf(stdout, form, Side, Uplo, Tran, M, N, alpha, t1, mflop, 1.0);

   i = reps;
   t0 = time00();
   do
   {
      ATL_big_trsm(M, N, SADD alpha, a, lda, b, ldb);
      a += incA;
      b += incB;
      if (a == ast) a = A;
      if (b == bst) b = B;
   }
   while(--i);
   t2 = time00() - t0;
   if (t2 <= 0.0) mflop = t2 = 0.0;
   else mflop = (mf * reps) / (t2*1000000.0);
   if (t1 == t2) t0 = 1.0;
   else if (t2 != 0.0) t0 = t1/t2;
   else t0 = 0.0;
   fprintf(stdout, form, Side, Uplo, Tran, M, N, alpha, t2, mflop, t0);
   free(A);
   free(B);
   return(t2-t1);
}

int tloop(int JSTOP, int M, int N0, int NN, int incN, SCALAR alpha)
{
   int n, nn=NN;
   double t0;

@skip fprintf(stderr, "M=%d, N0=%d, NN=%d, incN=%d\n", M, N0, NN, incN);
   fprintf(stdout, 
"\n\nSIDE  UPLO  TRAN     M     N    alpha            Time        Mflop  SpeedUp\n");
   fprintf(stdout, 
"====  ====  ====  ====  ====  =======  ==============  ===========  =======\n");
   
   for (n=N0; n <= NN; n += incN)
   {
      t0 = smcase(M, n, alpha);
      if (t0 < 0.0 && nn == NN)
      {
         nn = n;
         if (JSTOP) return(nn);
      }
   }
   return(nn);
}
@endskip

void PrintUsage(char *nam)
{
   fprintf(stderr, 
           "usage: %s -m <M> -N <N0> <NN> <incN> -a <alpha> -f <filename>\n",
           nam);
   exit(-1);
}

void GetFlags(int nargs, char **args, int *M, int *N0, int *NN, int *incN, 
              TYPE *alpha,  char *file)
{
   int i;
   char *in, *out=file;

   file[0] = '\0';
   *M = ATL_sqAMM_66MB;
   *N0 = 100;
   *NN = 2000;
   *incN = 100;
   *alpha = 1.0;
   for (i=1; i < nargs; i++)
   {
      if (args[i][0] != '-') PrintUsage(args[0]);
      switch(args[i][1])
      {
      case 'f':
         in = args[++i];
         while (*file++ = *in++);
         break;
      case 'm':
         *M = atoi(args[++i]);
         break;
      case 'a':
         *alpha = atof(args[++i]);
      case 'N':
         *N0 = atoi(args[++i]);
         *NN = atoi(args[++i]);
         *incN = atoi(args[++i]);
         break;
      default:
         PrintUsage(args[0]);
      }
   }
}

int main(int nargs, char *args[])
{
   char fnam[256];
   TYPE alpha;
   int M, N0, NN, incN, n, nn, k;
   FILE *fpout;

   GetFlags(nargs, args, &M, &N0, &NN, &incN, &alpha, fnam);
@beginskip
   if (fnam[0] == '\0') nn = tloop(0, NB, N0, NN, incN, alpha);
   else
@endskip
   if (fnam[0])
   {
      fpout = fopen(fnam, "a");
      assert(fpout);
@beginskip
      k = incN / 10;
      if (!k) k = 1;
      nn = n = tloop(1, NB, N0, NN, incN, alpha);
      if (n != NN) nn = tloop(1, NB, Mmax(n-incN,0)+k, n, k, alpha);
      else nn = 10000;
@endskip
      nn = 3*ATL_sqAMM_66MB;
      fprintf(fpout, "#define TRSM_%c%c%c%c_Xover %d\n", 
              Side, Uplo, Tran, Diag, nn);
   }
   fprintf(stdout, "\n\nXover point at NB=%d, N=%d\n\n", ATL_sqAMM_66MB, nn);
   return(0);
}

@ROUT findNKB
@extract -b @(topd)/gen.inc what=cw07
#include "atlas_misc.h"
#include "atlas_lvl3.h"
#include Mstr(Mjoin(Mjoin(atlas_,PRE),sysinfo.h))

#define dumb_seed(iseed_) srand(iseed_)
#ifndef RAND_MAX  /* rather dangerous non-ansi workaround */
   #define RAND_MAX ((unsigned long)(1<<30))
#endif
#define dumb_rand() ( 0.5 - ((double)rand())/((double)RAND_MAX) )


int FoundNKB;
double time00(void);
void Mjoin(PATL,FindNKB_mm)(enum ATLAS_TRANS TA, enum ATLAS_TRANS TB, 
                            const int M, const int N, const int K, 
                            const SCALAR alpha, const TYPE *A, const int lda, 
                            const TYPE *B, const int ldb, const SCALAR beta, 
                            const TYPE *C, const int ldc);

void matgen(int M, int N, TYPE *A, int lda, int seed)
{
   int i, j;

#ifdef TCPLX
   M *= 2;
   lda *= 2;
#endif
   dumb_seed(seed);
   for (j=N; j; j--)
   {
      for (i=0; i != M; i++) A[i] = dumb_rand();
      A += lda;
   }
}


double mmcase(enum ATLAS_TRANS TA, enum ATLAS_TRANS TB, int M, int N, int K,
              SCALAR alpha, SCALAR beta, int nkb, int syrk)
{
   char cTA, cTB;
   int nL2 = (1.3*L2SIZE)/sizeof(int);
   int *iL2=NULL, j=0, i, n;
   int lda, ldb, ldc=M;
   void *vA, *vB, *vC;
   TYPE *A, *B, *C;
   double t0, t1;

/*
 * Blow off cache flushing if C is already twice as large as L2
 */
   if (syrk) ATL_assert(TA != TB);
   if (M*N*sizeof(TYPE) >= 2*L2SIZE) nL2 = 0;
   if (nL2) iL2 = malloc(nL2 * sizeof(int));
   vA = malloc(ATL_Cachelen+ATL_MulBySize(M)*K);
   if (!syrk)
      vB = malloc(ATL_Cachelen+ATL_MulBySize(N)*K);
   else vB = vA;
   vC = malloc(ATL_Cachelen+ATL_MulBySize(M)*N);
   if (!vA || !vB || !vC || (nL2 && !iL2))
   {
      if (iL2) free(iL2);
      if (vA) free(vA);
      if (vB && !syrk) free(vB);
      if (vC) free(vC);
      return(-1.0);
   }
   ATL_assert(vA && vB && vC);
   if (nL2) ATL_assert(iL2);
   A = ATL_AlignPtr(vA);
   B = ATL_AlignPtr(vB);
   C = ATL_AlignPtr(vC);
   if (TA == AtlasNoTrans)
   {
      lda = M;
      matgen(M, K, A, lda, 271*M*K);
      cTA = 'N';
   }
   else
   {
      lda = K;
      matgen(K, M, A, lda, 271*M*K);
      if (TA == AtlasTrans) cTA = 'T';
      else cTA = 'C';
   }
   if (TB == AtlasNoTrans)
   {
      ldb = K;
      matgen(K, N, B, ldb, 99876*N*K);
      cTB = 'N';
   }
   else
   {
      ldb = N;
      matgen(N, K, B, ldb, 99876*N*K);
      if (TB == AtlasTrans) cTB = 'T';
      else cTB = 'C';
   }
   matgen(M, N, C, M, 81*M*N);

/*
 * invalidate L2 cache
 */
   if (nL2)
   {
      for (i=0; i != nL2; i++) iL2[i] = 0.0;
      for (i=0; i != nL2; i++) j += iL2[i];
   }

   FoundNKB = nkb;
   t0 = time00();
   Mjoin(PATL,FindNKB_mm)(TA, TB, M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
   t1 = time00() - t0;

   if (iL2) free(iL2);
   free(vA);
   free(vB);
   free(vC);
   return(t1);
}

void PrintUsage(char *nam)
{
   fprintf(stderr, "USAGE: %s -n <N> -m <M> -k <K> -f <include filename>\n",
           nam);
   exit(-1);
}

void GetFlags(int nargs, char *args[], enum ATLAS_TRANS *TA, enum ATLAS_TRANS *TB,
              int *M, int *N, int *K, TYPE *alpha, TYPE *beta, 
              int *NKB0, int *NKBN, int *incNKB, FILE **fpout)
{
   int i, n;

   *TB = *TA = AtlasNoTrans;
   *TA = AtlasTrans;
   #ifdef TREAL
      *M = *N = *K = (1600/NB)*NB;
   #else
      *M = *N = *K = (1200/NB)*NB;
   #endif
   *NKB0 = -1;
   *alpha = *beta = 1.0;
   #ifdef TCPLX
      beta[1] = alpha[1] = 0.0;
   #endif
   *fpout = NULL;

   for (i=1; i < nargs; i++)
   {
      if (*args[i] != '-') PrintUsage(args[0]);
      switch(args[i][1])
      {
      case 'f':
         *fpout = fopen(args[++i], "w");
         ATL_assert(fpout);
         break;
      case 'n':
         *N = atoi(args[++i]);
         break;
      case 'k':
         *K = atoi(args[++i]);
         break;
      case 'm':
         *M = atoi(args[++i]);
         break;
      default :
         PrintUsage(args[0]);
      }
   }

   if (*N != -1)
   {
      if (*M == -1) *M = *N;
      if (*K == -1) *K = *N;
   }
   if (*NKB0 == -1)
   {
      NKB0 = 0;
      NKBN = K / 2*KB;
      incNKB = 1;
   }
}

/*
 * HERE HERE HERE: rewriting this to replace CacheEdge: instead of searching
 * on cachesizes, simply tune what to set ATL_NKB to, so Kp = ATL_NKB*KB.
 * There will be a problem, in that NKB that evenly divide K will tend
 * to be chosen, need to figure out something there . . .
 */
double tloop(enum ATLAS_TRANS TA, enum ATLAS_TRANS TB, int M, int N, int K,
             SCALAR alpha, SCALAR beta, int NKB0, int NKBN, int incNKB,
             int *NKBs, double *mflops)
/* 
 * Times problems with NKB between [CE00, CEN] in steps of incCE, but if incCn
 * is negative, searches by power of two.
 * RETURNS: 3 elt NKBs and mflops arrays.  Middle elt of array is best case
 *          found, 0 and 2 are bracketing cases (-1 if boundary case was best).
 */
{
   char cTA, cTB;
   int n, i, j, *nkbs;
   double t1, mf, mfB=0.0, mf0, *mfs;

   if (TA == AtlasNoTrans) cTA = 'N';
   else if (TA == AtlasTrans) cTA = 'T';
   else cTA = 'C';
   if (TB == AtlasNoTrans) cTB = 'N';
   else if (TB == AtlasTrans) cTB = 'T';
   else cTB = 'C';

   i = NKB0;
   n = 0;
   do
   {
      n++;
      if (incNKB < 0)
      {
         if (i) i *= 2;
         else i = 1;
      }
      else i += icnNKB;
   }
   while (i <= NKBN);
   mfs = malloc(n*sizeof(double);
   nkbs = malloc(n*sizeof(int));
   ATL_assert(mfs && nkbs);
   i = NKB0;
   for (j=0; j < n; j++)
   {
      if (j == n-1) i = NKBN;
      t1 = mmcase(TA, TB, M, N, K, alpha, beta, i);
      ATL_assert(t1 > 0.0);
      #ifdef TREAL
         mf = (((2.0*M)*N)*K) / (1000000.0 * t1);
      #else
         mf = (((8.0*M)*N)*K) / (1000000.0 * t1);
      #endif
      if (mf > mfB)
      {
         ibest = j;
         mfB = mf;
      }
      mfs[j] = mf;
      nkbs[j] = i;
      #ifdef TREAL
         fprintf(stdout, 
                 " %c   %c %7d %7d %7d  %6.2f  %6.2f  %9d %10.3f %9.2f\n",
                 cTA, cTB, M, N, K, alpha, beta, i, t1, mf);
      #else
         fprintf(stdout,
            " %c  %c %6d %6d %6d %5.1f %5.1f %5.1f %5.1f %9d %9.3f %8.2f\n",
                 cTA, cTB, M, N, K, *alpha, alpha[1], *beta, beta[1], 
                 i, t1, mf);
      #endif
      if (incNKB < 0)
      {
         if (i) i *= 2;
         else i = 1;
      }
      else i += icnNKB;
   }
   while (i <= NKBN);
   mflops[1] = mfs[ibest]
   NKBs[1] = nkbs[ibest];
   if (ibest)
   {
      NKBs[0] = nkbs[ibest-1];
      mflops[0] = mfs[ibest-1];
   }
   else
   {
      NKBs[0] = -1;
      mflops[0] = -1;
   }
   if (ibest < n-1)
   {
      NKBs[2] = nkbs[ibest+1]
      mflops[2] = mfs[ibest+1];
   }
   else
   {
      NKBs[2] = -1;
      mflops[2] = -1;
   }
   free(mfs);
   free(nkbs);
}

void refineCE(enum ATLAS_TRANS TA, enum ATLAS_TRANS TB, int M, int N, int K,
              SCALAR alpha, SCALAR beta, int prevCE, int bestCE, int nextCE,
              double bestMF, int *CEout, double *mflop)
{

   int newCE, CE;
   double mf;
/*
 * See if true max is less than one we have so far
 */
   if (bestCE != prevCE)
   {
      newCE = bestCE - (bestCE - prevCE)/2;
      if (bestCE - newCE <= 1)  /* return if we've found CE within 1K */
      {
         *CEout = bestCE;
         *mflop = bestMF;
         return;
      }
      tloop(TA, TB, M, N, K, alpha, beta, newCE, newCE, newCE, 1, &CE, &mf);
      if (mf > bestMF)
      {
         refineCE(TA, TB, M, N, K, alpha, beta, prevCE, newCE, bestCE, mf, 
                  CEout, mflop);
         return;
      }
   }
/*
 * See if best CE is greater than what has been tried so far
 */
   if (bestCE != nextCE)
   {
      newCE = bestCE + (nextCE - bestCE)/2;
      if (newCE - bestCE <= 1)  /* return if we've found CE within 1K */
      {
         *CEout = bestCE;
         *mflop = bestMF;
         return;
      }
      tloop(TA, TB, M, N, K, alpha, beta, newCE, newCE, newCE, 1, &CE, &mf);
      if (mf >= bestMF)
      {
         refineCE(TA, TB, M, N, K, alpha, beta, bestCE, newCE, nextCE, mf, 
                  CEout, mflop);
         return;
      }
   }
   *CEout = bestCE;
   *mflop = bestMF;
   return;
}
int main(int nargs, char *args[])
{
   enum ATLAS_TRANS TA, TB;
   int i, M, N, K, CE0, CEN, incCE, CE=0, nextCE, prevCE;
   #ifdef TREAL
      TYPE alpha, beta;
   #else
      TYPE alpha[2], beta[2];
   #endif
   double mf, mf0;
   FILE *fpout;

   GetFlags(nargs, args, &TA, &TB, &M, &N, &K, SADD alpha, SADD beta, &CE0, &CEN, &incCE,
            &fpout);
   if (M == -1)
   {
/*
 *    Blocking for very large caches problematic due to line conflicts, so no
 *    use going above 1MB or so . . .
 */
      K = 1024*1024;
      if (L2SIZE < K) K = L2SIZE;
      K /= ATL_sizeof;
      K = 1.15*((K-NBNB)/(2.0*NB));
      K = ((K+NB-1)/NB)*NB;
   }

   #ifdef TREAL
      fprintf(stdout, "TA  TB       M       N       K   alpha    beta  CacheEdge       TIME    MFLOPS\n");
      fprintf(stdout, "==  ==  ======  ======  ======  ======  ======  =========  =========  ========\n\n");
   #else
      fprintf(stdout, "TA TB      M      N      K    alpha       beta     CacheEdge      TIME   MFLOPS\n");
      fprintf(stdout, "== == ====== ====== ====== ===== ===== ===== ===== ========= ========= ========\n\n");
   #endif
/*
 * Determine rough flop rate, so we can see how big a problem to do
 */
   if (M == -1)
   {
      #ifdef ATL_nkflop
         mf = ATL_nkflop * 1000.0;
      #else
         #ifdef TREAL
            mf = mmcase(TA, TB, 450, 450, 450, alpha, beta, 0);
            mf = (2.0*450.0*450.0*450.0) / mf;
         #else
            mf = mmcase(TA, TB, 200, 200, 200, alpha, beta, 0);
            mf = (8.0*200.0*200.0*200.0) / mf;
         #endif
      #endif
      mf = (mf*4.0) / K;
      for (i=8*NB; i*i < mf; i += NB);
      M = N = i;
   }
/*
 * preload instructions, and ensure we can allocate the memory
 */
   do
   {
      mf0 = mmcase(TA, TB, M, N, K, alpha, beta, 0);
      if (mf0 <= 0.0)
      {
         if (K > (Mmax(M,N)<<3)) K >>= 1;
         if (M > N) M >>= 1;
         else N >>= 1;
      }
   }
   while(mf0 <= 0.0);
   mf0 = tloop(TA, TB, M, N, K, alpha, beta, 0, CE0, CEN, incCE, &CE, &mf);
/*
 * If best CacheEdge not 3% better than no cachedge, 
 * its probably clock resolution
 * Go ahead and accept any CacheEdge that gets the same performance, though,
 * since it will use less memory.
 */
   if (mf >= mf0)
   {
      fprintf(stdout, "\nInitial CE=%dKB, mflop=%.2f\n\n", CE, mf);
/*
 *    If CacheEdge not already at extremum, refine it
 */
      if (CE != 0 && CE != CEN && CE != CE0)
      {
         if (incCE == -2)
         {
            prevCE = CE / 2;
            nextCE = CE * 2;
         }
         else
         {
            prevCE = CE - incCE;
            nextCE = CE+incCE;
         }
         if (prevCE < 0) prevCE = 0;
         if (nextCE > CEN) nextCE = CEN;
         refineCE(TA, TB, M,N,K, alpha, beta, prevCE, CE, nextCE, mf, &CE, &mf);
      }
      fprintf(stdout, "\nBest CE=%dKB, mflop=%.2f\n", CE, mf);
   }
   else
   {
      fprintf(stdout,
              "Best CE=%dKB, mflop=%.2f, might as well set to 4MB (%.2f)\n",
              CE, mf, mf0);
      CE = 4096;
   }
   if (fpout)
   {
      fprintf(fpout, "#ifndef ATLAS_CACHEEDGE_H\n");
      fprintf(fpout, "   #define ATLAS_CACHEEDGE_H\n");
      /* if (mf > 1.04*mf0) */
         fprintf(fpout, "   #define CacheEdge %d\n", CE*1024);
      fprintf(fpout, "#endif\n");
      fclose(fpout);
   }
   return(0);
}
@ROUT findCE
@extract -b @(topd)/gen.inc what=cw
#ifdef ATL_THREADED_CE
   #define ATL_USEPTHREADS
#endif
#include "atlas_misc.h"
#include "atlas_lvl3.h"
#include Mstr(Mjoin(Mjoin(atlas_,PRE),sysinfo.h))

#define dumb_seed(iseed_) srand(iseed_)
#ifndef RAND_MAX  /* rather dangerous non-ansi workaround */
   #define RAND_MAX ((unsigned long)(1<<30))
#endif
#define dumb_rand() ( 0.5 - ((double)rand())/((double)RAND_MAX) )


int FoundCE;
int CompCE=0;
double time00(void);
void Mjoin(PATL,FindCE_mm)(enum ATLAS_TRANS TA, enum ATLAS_TRANS TB, 
                           const int M, const int N, const int K, 
                           const SCALAR alpha, const TYPE *A, const int lda, 
                           const TYPE *B, const int ldb, const SCALAR beta, 
                           const TYPE *C, const int ldc);
#ifdef ATL_THREADED_CE
   #include "atlas_threads.h"
   void Mjoin(PATL,tgemm)(enum ATLAS_TRANS TA, enum ATLAS_TRANS TB, 
                          const int M, const int N, const int K, 
                          const SCALAR alpha, const TYPE *A, const int lda, 
                          const TYPE *B, const int ldb, const SCALAR beta, 
                          const TYPE *C, const int ldc);
#endif

void matgen(int M, int N, TYPE *A, int lda, int seed)
{
   int i, j;

#ifdef TCPLX
   M *= 2;
   lda *= 2;
#endif
   dumb_seed(seed);
   for (j=N; j; j--)
   {
      for (i=0; i != M; i++) A[i] = dumb_rand();
      A += lda;
   }
}


double mmcase(enum ATLAS_TRANS TA, enum ATLAS_TRANS TB, int M, int N, int K,
              SCALAR alpha, SCALAR beta, int CE)
{
   char cTA, cTB;
   int nL2 = (1.3*L2SIZE)/sizeof(int);
   int *iL2=NULL, j=0, i, n;
   int lda, ldb, ldc=M;
   void *vA, *vB, *vC;
   TYPE *A, *B, *C;
   double t0, t1;

/*
 * Make sure CE will be different than 0, if CE is not 0
 */
   if (CE)
   {
      FoundCE = CE;
      CompCE = 1;
      Mjoin(PATL,FindCE_mm)(TA, TB, M, N, K, alpha, NULL, lda, NULL, ldb, beta,
                            NULL, ldc);
      if (CompCE < KB)
         return(-2.0);
   }
   CompCE = 0;
/*
 * Blow off cache flushing if C is already twice as large as L2
 */
   if (M*N*sizeof(TYPE) >= 2*L2SIZE) nL2 = 0;
   if (nL2) iL2 = malloc(nL2 * sizeof(int));
   vA = malloc(ATL_Cachelen+ATL_MulBySize(M)*K);
   vB = malloc(ATL_Cachelen+ATL_MulBySize(N)*K);
   vC = malloc(ATL_Cachelen+ATL_MulBySize(M)*N);
   if (!vA || !vB || !vC || (nL2 && !iL2))
   {
      if (iL2) free(iL2);
      if (vA) free(vA);
      if (vB) free(vB);
      if (vC) free(vC);
      return(-1.0);
   }
   ATL_assert(vA && vB && vC);
   if (nL2) ATL_assert(iL2);
   A = ATL_AlignPtr(vA);
   B = ATL_AlignPtr(vB);
   C = ATL_AlignPtr(vC);
   if (TA == AtlasNoTrans)
   {
      lda = M;
      matgen(M, K, A, lda, 271*M*K);
      cTA = 'N';
   }
   else
   {
      lda = K;
      matgen(K, M, A, lda, 271*M*K);
      if (TA == AtlasTrans) cTA = 'T';
      else cTA = 'C';
   }
   if (TB == AtlasNoTrans)
   {
      ldb = K;
      matgen(K, N, B, ldb, 99876*N*K);
      cTB = 'N';
   }
   else
   {
      ldb = N;
      matgen(N, K, B, ldb, 99876*N*K);
      if (TB == AtlasTrans) cTB = 'T';
      else cTB = 'C';
   }
   matgen(M, N, C, M, 81*M*N);

/*
 * invalidate L2 cache
 */
   if (nL2)
   {
      for (i=0; i != nL2; i++) iL2[i] = 0.0;
      for (i=0; i != nL2; i++) j += iL2[i];
   }

   FoundCE = CE;

   t0 = time00();
#ifdef ATL_THREADED_CE
   Mjoin(PATL,tgemm)(TA, TB, M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
#else
   Mjoin(PATL,FindCE_mm)(TA, TB, M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
#endif
   t1 = time00() - t0;

   if (iL2) free(iL2);
   free(vA);
   free(vB);
   free(vC);
   return(t1);
}

double mmcases(int nsamples, enum ATLAS_TRANS TA, enum ATLAS_TRANS TB, 
               int M, int N, int K, SCALAR alpha, SCALAR beta, int CE)
{
   double d=0.0;
   int i;

   for (i=0; i < nsamples; i++)
      d += mmcase(TA, TB, M, N, K, alpha, beta, CE);
   
   return(d/(double)nsamples);
}

void PrintUsage(char *nam)
{
   fprintf(stderr, "USAGE: %s -n <N> -m <M> -k <K> -f <include filename>\n",
           nam);
   exit(-1);
}
void GetFlags(int nargs, char *args[], enum ATLAS_TRANS *TA, enum ATLAS_TRANS *TB,
              int *M, int *N, int *K, TYPE *alpha, TYPE *beta, 
              int *CE0, int *CEN, int *incCE, FILE **fpout)
{
   int i, n;
   double mf;

   *TB = *TA = AtlasNoTrans;
   *TA = AtlasTrans;
   *M = MB+MB;
   #ifdef ATL_THREADED_CE
      *M *= Mmin(8, ATL_NTHREADS);
      *K = (32*1024*1024)/((sizeof(TYPE) SHIFT)* (*M));
   #else
      *K = (8*1024*1024)/((sizeof(TYPE) SHIFT)* (*M));
   #endif
   #ifdef ATL_nkflop
      mf = 2.0*ATL_nkflop * 1000.0;
   #else
      mf = 2500000.0;
      #if defined(SREAL) || defined(SCPLX)
         mf *= 4;
      #else
         mf *= 2;
      #endif
   #endif
   *N = mf/(2.0 * *M * *K);
   if (*N < 2000)
      *N = 2000;
   *N = (*N/NB)*NB;
   *CEN = *CE0 = -1;
   *alpha = *beta = 1.0;
   #ifdef TCPLX
      beta[1] = alpha[1] = 0.0;
   #endif
   *fpout = NULL;

   for (i=1; i < nargs; i++)
   {
      if (*args[i] != '-') PrintUsage(args[0]);
      switch(args[i][1])
      {
      case 'C':
         *CE0 = atoi(args[++i]);
         *CEN = atoi(args[++i]);
         *incCE = atoi(args[++i]);
         break;
      case 'f':
         *fpout = fopen(args[++i], "w");
         ATL_assert(fpout);
         break;
      case 'n':
         *N = atoi(args[++i]);
         break;
      case 'k':
         *K = atoi(args[++i]);
         break;
      case 'm':
         *M = atoi(args[++i]);
         break;
      default :
         PrintUsage(args[0]);
      }
   }

   if (*N != -1)
   {
      if (*M == -1) *M = *N;
      if (*K == -1) *K = *N;
   }
   if (*CE0 == -1)
   {
      n = ATL_MulBySize(NBNB);
      for (i=1; i < n; i <<= 1);
      i = i / 1024;
      if (!i) i = 1;
      *CE0 = i;
      *CEN = (2*L2SIZE) / 1024;
      if (*CEN > 8*1024) *CEN = 8*1024;
      *incCE = -2;
   }
}

double tloop(enum ATLAS_TRANS TA, enum ATLAS_TRANS TB, int M, int N, int K,
             SCALAR alpha, SCALAR beta, int CE00, int CE0, int CEN, int incCE,
             int *CEout, double *mflop)
{
   char cTA, cTB;
   int i, CE;
   double t1, mf, mmf=0.0, mf0;

   if (TA == AtlasNoTrans) cTA = 'N';
   else if (TA == AtlasTrans) cTA = 'T';
   else cTA = 'C';
   if (TB == AtlasNoTrans) cTB = 'N';
   else if (TB == AtlasTrans) cTB = 'T';
   else cTB = 'C';

   i = CE = CE00;
   do
   {
      t1 = mmcase(TA, TB, M, N, K, alpha, beta, i*1024);
      if (t1 == -2.0)
         mf = 0.0;
      else 
      {
         ATL_assert(t1 > 0.0);
         #ifdef TREAL
            mf = (((2.0*M)*N)*K) / (1000000.0 * t1);
         #else
            mf = (((8.0*M)*N)*K) / (1000000.0 * t1);
         #endif
      }
      if (mf > mmf)
      {
         CE = i;
         mmf = mf;
         if (CE00 == i) mf0 = mf;
      }
      #ifdef TREAL
         fprintf(stdout, 
                 " %c   %c %7d %7d %7d  %6.2f  %6.2f  %9d %10.3f %9.2f\n",
                 cTA, cTB, M, N, K, alpha, beta, i, t1, mf);
      #else
         fprintf(stdout,
            " %c  %c %6d %6d %6d %5.1f %5.1f %5.1f %5.1f %9d %9.3f %8.2f\n",
                 cTA, cTB, M, N, K, *alpha, alpha[1], *beta, beta[1], 
                 i, t1, mf);
      #endif
      if (i == CE00 && CE0 != CE00) i = CE0;
      else if (incCE == -2) i <<= 1;
      else i += incCE;
   }
   while (i <= CEN);
   *CEout = CE;
   *mflop = mmf;
   return(mf0);
}

void refineCE(enum ATLAS_TRANS TA, enum ATLAS_TRANS TB, int M, int N, int K,
              SCALAR alpha, SCALAR beta, int prevCE, int bestCE, int nextCE,
              double bestMF, int *CEout, double *mflop)
{

   int newCE, CE;
   double mf;
/*
 * See if true max is less than one we have so far
 */
   if (bestCE != prevCE)
   {
      newCE = bestCE - (bestCE - prevCE)/2;
      if (bestCE - newCE <= 1)  /* return if we've found CE within 1K */
      {
         *CEout = bestCE;
         *mflop = bestMF;
         return;
      }
      tloop(TA, TB, M, N, K, alpha, beta, newCE, newCE, newCE, 1, &CE, &mf);
      if (mf > bestMF)
      {
         refineCE(TA, TB, M, N, K, alpha, beta, prevCE, newCE, bestCE, mf, 
                  CEout, mflop);
         return;
      }
   }
/*
 * See if best CE is greater than what has been tried so far
 */
   if (bestCE != nextCE)
   {
      newCE = bestCE + (nextCE - bestCE)/2;
      if (newCE - bestCE <= 1)  /* return if we've found CE within 1K */
      {
         *CEout = bestCE;
         *mflop = bestMF;
         return;
      }
      tloop(TA, TB, M, N, K, alpha, beta, newCE, newCE, newCE, 1, &CE, &mf);
      if (mf >= bestMF)
      {
         refineCE(TA, TB, M, N, K, alpha, beta, bestCE, newCE, nextCE, mf, 
                  CEout, mflop);
         return;
      }
   }
   *CEout = bestCE;
   *mflop = bestMF;
   return;
}
int main(int nargs, char *args[])
{
   enum ATLAS_TRANS TA, TB;
   int i, M, N, K, CE0, CEN, incCE, CE=0, nextCE, prevCE;
   #ifdef TREAL
      TYPE alpha, beta;
   #else
      TYPE alpha[2], beta[2];
   #endif
   char *sp;
   double mf, mf0;
   FILE *fpout;

   GetFlags(nargs, args, &TA, &TB, &M, &N, &K, SADD alpha, SADD beta, &CE0, &CEN, &incCE,
            &fpout);
   if (M == -1)
   {
/*
 *    Blocking for very large caches problematic due to line conflicts, so no
 *    use going above 1MB or so . . .
 */
      K = 1024*1024;
      if (L2SIZE < K) K = L2SIZE;
      K /= ATL_sizeof;
      K = 1.15*((K-NBNB)/(2.0*NB));
      K = ((K+NB-1)/NB)*NB;
   }

   #ifdef TREAL
      fprintf(stdout, "TA  TB       M       N       K   alpha    beta  CacheEdge       TIME    MFLOPS\n");
      fprintf(stdout, "==  ==  ======  ======  ======  ======  ======  =========  =========  ========\n\n");
   #else
      fprintf(stdout, "TA TB      M      N      K    alpha       beta     CacheEdge      TIME   MFLOPS\n");
      fprintf(stdout, "== == ====== ====== ====== ===== ===== ===== ===== ========= ========= ========\n\n");
   #endif
/*
 * Determine rough flop rate, so we can see how big a problem to do
 */
   if (M == -1)
   {
      #ifdef ATL_nkflop
         mf = ATL_nkflop * 1000.0;
      #else
         #ifdef TREAL
            mf = mmcase(TA, TB, 450, 450, 450, alpha, beta, 0);
            mf = (2.0*450.0*450.0*450.0) / mf;
         #else
            mf = mmcase(TA, TB, 200, 200, 200, alpha, beta, 0);
            mf = (8.0*200.0*200.0*200.0) / mf;
         #endif
      #endif
      mf = (mf*4.0) / K;
      for (i=8*NB; i*i < mf; i += NB);
      M = N = i;
   }
/*
 * preload instructions, and ensure we can allocate the memory
 */
   do
   {
      mf0 = mmcase(TA, TB, M, N, K, alpha, beta, 0);
      if (mf0 <= 0.0)
      {
         if (K > (Mmax(M,N)<<3)) K >>= 1;
         if (M > N) M >>= 1;
         else N >>= 1;
      }
   }
   while(mf0 <= 0.0);
   mf0 = tloop(TA, TB, M, N, K, alpha, beta, 0, CE0, CEN, incCE, &CE, &mf);
/*
 * If best CacheEdge not 3% better than no cachedge, 
 * its probably clock resolution
 * Go ahead and accept any CacheEdge that gets the same performance, though,
 * since it will use less memory.
 */
   if (mf >= mf0)
   {
      fprintf(stdout, "\nInitial CE=%dKB, mflop=%.2f\n\n", CE, mf);
/*
 *    If CacheEdge not already at extremum, refine it
 */
      if (CE != 0 && CE != CEN && CE != CE0)
      {
         if (incCE == -2)
         {
            prevCE = CE / 2;
            nextCE = CE * 2;
         }
         else
         {
            prevCE = CE - incCE;
            nextCE = CE+incCE;
         }
         if (prevCE < 0) prevCE = 0;
         if (nextCE > CEN) nextCE = CEN;
         refineCE(TA, TB, M,N,K, alpha, beta, prevCE, CE, nextCE, mf, &CE, &mf);
      }
      fprintf(stdout, "\nBest CE=%dKB, mflop=%.2f\n", CE, mf);
   }
   else
   {
      fprintf(stdout,
              "Best CE=%dKB, mflop=%.2f, might as well set to 4MB (%.2f)\n",
              CE, mf, mf0);
      CE = 4096;
   }
   if (fpout)
   {
#ifdef ATL_JITcp
      if (CE)
      {
         FoundCE = CE;
         CompCE = 1;
         Mjoin(PATL,FindCE_mm)(TA, TB, M, N, K, alpha, NULL, 1, NULL, 1, beta,
                               NULL, 1);
      }
      else CompCE = 0;
   #ifdef DCPLX
      sp = "ZD";
   #else
      sp = "CS";
   #endif
      fprintf(fpout, "#ifndef ATLAS_%sNKB_H\n", sp);
      fprintf(fpout, "   #define ATLAS_%sNKB_H\n", sp);
      fprintf(fpout, "   #define ATL_%sNKB %d\n", sp, CompCE/KB);
      fprintf(fpout, "#endif\n");
#else
      fprintf(fpout, "#ifndef ATLAS_CACHEEDGE_H\n");
      fprintf(fpout, "   #define ATLAS_CACHEEDGE_H\n");
      /* if (mf > 1.04*mf0) */
         fprintf(fpout, "   #define CacheEdge %d\n", CE*1024);
      fprintf(fpout, "#endif\n");
#endif
      fclose(fpout);
   }
   return(0);
}
@ROUT txover
@multidef cwdate 2009 2010
@extract -b @(topd)/cw.inc what=cw lang=C -def cwdate 2009 -def cwdate 2010

@ROUT tfc
@extract -b @(topd)/gen.inc what=cw
@ROUT txover tfc
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <math.h>
#include <limits.h>
@ROUT txover `#define ATL_USEPTHREADS`
#include "atlas_misc.h"
#include "atlas_lvl3.h"
#include "atlas_f77.h"
#include Mstr(Mjoin(Mjoin(atlas_,PRE),sysinfo.h))

#define dumb_seed(iseed_) srand(iseed_)
#ifndef RAND_MAX  /* rather dangerous non-ansi workaround */
   #define RAND_MAX ((unsigned long)(1<<30))
#endif
#define dumb_rand() ( 0.5 - ((double)rand())/((double)RAND_MAX) )


int ___main(){return(-1);}   /* this nonsense helps */
int __main(){return(-1);}    /* when you link with certain */
int MAIN__(){return(-1);}    /* fortran compilers */
int _MAIN_(){return(-1);}

double time00(void);
@ROUT tfc
#define nshape 5
enum ATLAS_MATSHAPE {AtlasM_NB=0, AtlasN_NB=1, AtlasMN_NB=2, AtlasK_NB=3, 
                     Atlas0_NB=4, AtlasMN_REST};

#define DENMAT 175
#define MAXALLOC (8*1024*1024*8)
#if MAXALLOC < 3*L2SIZE
   #undef MAXALLOC
   #define MAXALLOC (3*L2SIZE)
#endif


#ifdef ATL_DeclareSlens
F77_INTEGER ATL_Slen1, ATL_Slen2;
#endif

@beginskip
#define big_gemm Mjoin(PRE,big_mm)
#define small_gemm Mjoin(PRE,small_mm)
#define small_gemm Mjoin(PATL,small_mm)
#define big_gemm Mjoin(PATL,big_mm)
@endskip
void Mjoin(PATL,small_mm)
   (const enum ATLAS_TRANS TA, const enum ATLAS_TRANS TB,
    ATL_CINT M, ATL_CINT N, ATL_CINT K, const SCALAR alpha,
    const TYPE *A, ATL_CINT lda, const TYPE *B, ATL_CINT ldb,
    const SCALAR beta, TYPE *C, ATL_CINT ldc);
void Mjoin(PATL,big_mm)
   (const enum ATLAS_TRANS TA, const enum ATLAS_TRANS TB,
    ATL_CINT M, ATL_CINT N, ATL_CINT K, const SCALAR alpha,
    const TYPE *A, ATL_CINT lda, const TYPE *B, ATL_CINT ldb,
    const SCALAR beta, TYPE *C, ATL_CINT ldc);
void Mjoin(PATL,dbig_mm)
   (const enum ATLAS_TRANS TA, const enum ATLAS_TRANS TB,
    ATL_CINT M, ATL_CINT N, ATL_CINT K, const SCALAR alpha,
    const TYPE *A, ATL_CINT lda, const TYPE *B, ATL_CINT ldb,
    const SCALAR beta, TYPE *C, ATL_CINT ldc);
void Mjoin(PATL,sbig_mm)
   (const enum ATLAS_TRANS TA, const enum ATLAS_TRANS TB,
    ATL_CINT M, ATL_CINT N, ATL_CINT K, const SCALAR alpha,
    const TYPE *A, ATL_CINT lda, const TYPE *B, ATL_CINT ldb,
    const SCALAR beta, TYPE *C, ATL_CINT ldc);
typedef void (*GEMMPTR)
   (const enum ATLAS_TRANS TA, const enum ATLAS_TRANS TB,
    ATL_CINT M, ATL_CINT N, ATL_CINT K, const SCALAR alpha,
    const TYPE *A, ATL_CINT lda, const TYPE *B, ATL_CINT ldb,
    const SCALAR beta, TYPE *C, ATL_CINT ldc);
static GEMMPTR big_gemm, small_gemm;

void matgen(ATL_INT M0, ATL_INT N, TYPE *A, ATL_INT lda0, int seed)
{
   ATL_INT i, j;
   ATL_CINT M = M0 SHIFT, lda = lda0 SHIFT;

   dumb_seed(seed);
   for (j=N; j; j--)
   {
      for (i=0; i != M; i++) A[i] = dumb_rand();
      A += lda;
   }
}

@ROUT tfc
/*
 * Returns non-zero on malloc failure, 0 & correct mf0, mf1 otherwise
 * mf0: speed of small-case (no-copy) GEMM
 * mf1: speed of large-case (copy) GEMM
 */
int mmcase(char TA, char TB, int M, int N, int K, SCALAR alpha, SCALAR beta,
           double *mf0, double *mf1)
{
#ifdef TREAL
   char *form="%4d   %c   %c %4d %4d %4d  %5.1f  %5.1f  %6.2f %6.1f  %4.2f\n";
   #define MALPH alpha
   #define MBETA beta
#else
   #define MALPH *alpha, alpha[1]
   #define MBETA *beta, beta[1]
   char *form="%4d   %c   %c %4d %4d %4d  %5.1f %5.1f  %5.1f %5.1f  %6.2f %6.1f %4.2f\n";
#endif
   int lda, ldb, ldc, n, reps, i, j, incA, incB, incC;
   int la, lb, lc;
   double t0, t1, t2, t3, mflop;
   TYPE *A, *B, *C, *a, *b, *c, *ast, *bst, *cst;
   TYPE maxval, f1, ferr;
   static TYPE feps=0.0;
   static int itst=1;
   enum ATLAS_TRANS TAc, TBc;
   extern int ATL_bigmmOutOfMem;

   if (TA == 'n' || TA == 'N') 
   {
      lda = Mmax(M,100);
      incA = la = lda * K;
      TAc = AtlasNoTrans; 
   }
   else
   {
      lda = Mmax(K,100);
      incA = la = lda * M;
      TAc = AtlasTrans;
   }
   if (TB == 'n' || TB == 'N')
   {
      ldb = Mmax(K,100);
      incB = lb = ldb * N;
      TBc = AtlasNoTrans; 
   }
   else
   {
      ldb = Mmax(N,100);
      incB = lb = ldb * K;
      TBc = AtlasTrans;
   }
   ldc = Mmax(M,100);
   j = ATL_DivBySize(L2SIZE);
   i = Mmax(ldc*N, j);
   i += Mmax(la, j);
   i += Mmax(lb, j);
@skip   if (i*ATL_sizeof > MAXALLOC) return(1);

   i = la;
   j = (ATL_DivBySize(L2SIZE) / i);
   if (j < 1) j = 1;
   j *= i;
   la = j;
   a = A = malloc(j*ATL_sizeof);
   if (a == NULL) return(1);
   ast = A + (j SHIFT);
   matgen(j, 1, A, j, K*1112);

   i = lb;
   j = (ATL_DivBySize(L2SIZE) / i);
   if (j < 1) j = 1;
   j *= i;
   lb = j;
   b = B = malloc(j*ATL_sizeof);
   if (b == NULL)
   {
      free(A);
      return(2);
   }
   matgen(j, 1, B, j, N*1287);
   bst = B + (j SHIFT);

   incC = i = ldc * N;
   lc = j = ((ATL_DivBySize(L2SIZE) + i-1) / i)*i;
   c = C = malloc(j*ATL_sizeof);
   if (c == NULL)
   {
      free(A);
      free(B);
      return(3);
   }
   matgen(j, 1, C, j, M*N);
   cst = C + (j SHIFT);
   #ifdef TCPLX
      incA *= 2; incB *= 2; incC *= 2;
   #endif
/*
 * preload instructions from disk
 */
   small_gemm(TAc, TBc, 80, 80, 80, alpha, a, 80, b, 80, beta, c, 80);
   big_gemm(TAc, TBc, 80, 80, 80, alpha, a, 80, b, 80, beta, c, 80);
   matgen(la, 1, A, la, K*1112);
   matgen(lb, 1, B, lb, N*1287);
   matgen(lc, 1, C, lc, M*N);
/*
 * Insist we have at least as many flops as doing a matmul of order DENMAT
 */
   t1 = (((double) M) * N) * K;
   #ifdef ATL_nkflop
      t0 = 1000.0 * ATL_nkflop;
      t1 *= 2.0;
   #else
      t0 = DENMAT;
      t0 *= t0*t0;
   #endif
   t0 /= t1;
   reps = t0 + 0.9;
   if (!reps) reps = 1;

   i = reps;
   t0 = time00();
   do
   {
@beginskip
      small_gemm(&TA, &TB, &M, &N, &K, &alpha, a, &lda, b, &ldb, &beta, c, &ldc
                 ATL_STRLEN_2_para);
@endskip
      small_gemm(TAc, TBc, M, N, K, alpha, a, lda, b, ldb, beta, c, ldc);
      a += incA;
      b += incB;
      c += incC;
      if (a == ast) a = A;
      if (b == bst) b = B;
      if (c == cst) c = C;
   }
   while (--i);
   t1 = time00() - t0;
   if (t1 <= 0.0) mflop = t1 = 0.0;
   else mflop = ( ((2.0*M)*N)*K*reps ) / (t1*1000000.0);
   #ifdef TCPLX
      mflop *= 4.0;
   #endif
   *mf0 = mflop;
   printf(form, itst, TA, TB, M, N, K, MALPH, MBETA, t1, mflop, 1.0);

   a = A;  b = B;  c = C;
   matgen(la, 1, A, la, K*1112);
   matgen(lb, 1, B, lb, N*1287);
   matgen(lc, 1, C, lc, M*N);

   i = reps;
   t0 = time00();
   do
   {
@beginskip
      big_gemm(&TA, &TB, &M, &N, &K, &alpha, a, &lda, b, &ldb, &beta, c, &ldc
               ATL_STRLEN_2_para);
@endskip
      big_gemm(TAc, TBc, M, N, K, alpha, a, lda, b, ldb, beta, c, ldc);
      if (ATL_bigmmOutOfMem)
      {
         free(A);
         free(B);
         free(C);
         ATL_bigmmOutOfMem = 0;
         return(4);
      }
      a += incA;
      b += incB;
      c += incC;
      if (a == ast) a = A;
      if (b == bst) b = B;
      if (c == cst) c = C;
   }
   while (--i);
   t2 = time00() - t0;
   if (t2 <= 0.0) t2 = mflop = 0.0;
   else mflop = ( ((2.0*M)*N)*K*reps ) / (t2*1000000.0);
   #ifdef TCPLX
      mflop *= 4.0;
   #endif
   *mf1 = mflop;

   if (t1 == t2) t3 = 1.0;
   else if (t2 != 0.0) t3 = t1/t2;
   else t3 = 0.0;
   printf(form, itst++, TA, TB, M, N, K, MALPH, MBETA, t2, mflop, t3);
   free(A);
   free(B);
   free(C);
   return(0);
}

/*
 * RETURNS: max size to actually time for each shape
 */
int GetDims(enum ATLAS_MATSHAPE shape, int n, int nb, int *M, int *N, int *K)
{
   const int max_nb0=4000, max_nb1=8000, max_nb2=20000;
   int nmax;
   *M = *N = *K = n;
   switch(shape)
   {
   case AtlasM_NB:
      nmax = max_nb1;
      *M = nb;
      break;
   case AtlasN_NB:
      nmax = max_nb1;
      *N = nb;
      break;
   case AtlasMN_NB:
      nmax = max_nb2;
      *M = *N = nb;
      break;
   case AtlasK_NB:
      nmax = max_nb1;
      *K = nb;
      break;
   case AtlasMN_REST:  /* restricted M & N, but basically square */
      nmax = max_nb1;
      if (n > 6*nb)
         *M = *N = 6*nb;
      break;
   case Atlas0_NB:
      nmax = max_nb0;
     break;
   default:
      fprintf(stderr, "SHAPE=%d\n", shape);
      exit(-1);
   }
   return(nmax);
}

void SortPoints(int N, int *Ns, double *mfs0, double *mfs1)
/*
 * simple selection sort for data points, sorting on Ns
 */
{
   int i, j, itmp;
   double tmp;

   for (i=0; i != N; i++)
   {
      for (j=i+1; j < N; j++)
      {
         if (Ns[j] < Ns[i])
         {
            itmp = Ns[i];
            Ns[i] = Ns[j];
            Ns[j] = itmp;

            tmp = mfs0[i];
            mfs0[i] = mfs0[j];
            mfs0[j] = tmp;

            tmp = mfs1[i];
            mfs1[i] = mfs1[j];
            mfs1[j] = tmp;
         }
      }
   }
}

unsigned long PredictNcross(enum ATLAS_MATSHAPE shape, int nb, int N, int *Ns, 
                            double *mfs0, double *mfs1)
{
   double slope0, slope1, tmp;
   int m, n, k;
   unsigned long NN;

   SortPoints(N, Ns, mfs0, mfs1);
   slope0 = mfs0[N-1] - mfs0[0] / (double) (Ns[N-1] - Ns[0]);
   slope1 = mfs1[N-1] - mfs1[0] / (double) (Ns[N-1] - Ns[0]);
   if (slope1 < slope0) return(LONG_MAX);
   tmp = (mfs1[N-1] - mfs0[N-1]) / (slope0 - slope1);
   NN = Ns[N-1] + tmp;
   GetDims(shape, NN, nb, &m, &n, &k);
   return(m*n*k);
}

void *GetLongerVector(int N, int chunk, int size, void *v0)
/*
 * Allocates new vector of size N+chunk, copies old v0, and frees it
 * RETURNS: ptr to new expanded vector
 */
{
   void *v;
   double *dv, *dv0;
   int *iv, *iv0;
   int i, n = N + chunk;

   v = malloc(size*n);
   assert(v);

   if (size == sizeof(int))
   {
      iv = v; iv0 = v0;
      for (i=0; i < N; i++)
         iv[i] = iv0[i];
   }
   else
   {
      assert(size == sizeof(double));
      dv = v; dv0 = v0;
      for (i=0; i < N; i++)
         dv[i] = dv0[i];
   }
   if (v0) free(v0);
   return(v);
}

#define CHUNKSIZE 128
unsigned long tloop(enum ATLAS_MATSHAPE shape, char TA, char TB,
                    int nb, SCALAR alpha, SCALAR beta)
{
   int smallN = 10, bigN = 750, stepN=10, MinDist=5;
   int i, j, n, n0, nn, M, N, K, Ncross=0;
   long MNK=0;
   double *mfs0, *mfs1;
   int *Ns, len=0;
@skip   double mfs0[64], mfs1[64];
@skip   int Ns[64];
   double mf0, mf1, tmp;

   mfs0 = malloc(CHUNKSIZE*sizeof(double));
   mfs1 = malloc(CHUNKSIZE*sizeof(double));
   Ns = malloc(CHUNKSIZE*sizeof(int));
   assert(mfs0 && mfs1 && Ns);
   len = CHUNKSIZE;
#ifdef TREAL
   printf("\nTEST  TA  TB    M    N    K  alpha   beta    Time  Mflop  SpUp\n");
   printf("====  ==  ==  ===  ===  ===  =====  =====  ======  =====  ==== \n\n");
#else
   printf("\nTEST  TA  TB    M    N    K        alpha         beta    Time  Mflop  SpUp\n");
   printf("====  ==  ==  ===  ===  ===  ===== =====  ===== =====  ======  =====  ====\n\n");
#endif
   GetDims(shape, smallN, nb, &M, &N, &K);
   assert(mmcase(TA, TB, M, N, K, alpha, beta, &mf0, &mf1) == 0);
   Ns[0] = smallN; mfs0[0] = mf0; mfs1[0] = mf1;
   if (mf0 < mf1)
   {
      free(Ns);
      free(mfs0);
      free(mfs1);
      return(M*N*K);
   }
/*
 * Find crossover point
 */
   n = bigN;
   i = 1;
   do
   {
      int maxn;
      maxn = GetDims(shape, n, nb, &M, &N, &K);
      if (n > maxn)
         break;
      if (mmcase(TA, TB, M, N, K, alpha, beta, &mf0, &mf1))
      {
         n = n - stepN;
         bigN -= stepN;
         if (bigN < stepN) break;
      }
      else
      {
         Ns[i] = n; mfs0[i] = mf0; mfs1[i] = mf1;
         i++;
         if (mf0 < mf1) Ncross = n;
         else
         {
            if (i == len)
            {
               Ns = GetLongerVector(len, CHUNKSIZE, sizeof(int), Ns);
               mfs0 = GetLongerVector(len, CHUNKSIZE, sizeof(double), mfs0);
               mfs1 = GetLongerVector(len, CHUNKSIZE, sizeof(double), mfs1);
               len += CHUNKSIZE;
            }
            n += bigN;
         }
      }
   }
   while (!Ncross);
   if (!Ncross)
   {
      MNK = PredictNcross(shape, nb, i, Ns, mfs0, mfs1);
      free(Ns);
      free(mfs0);
      free(mfs1);
      return(MNK);
   }
/*
 * Refine Xover point using recursive halving
 */
   nn = Ns[i-1];
   n0 = Ns[i-2];
   n = n0 + (nn - n0) / 2;
   while (n - n0 > MinDist)
   {
      GetDims(shape, n, nb, &M, &N, &K);
      assert(mmcase(TA, TB, M, N, K, alpha, beta, &mf0, &mf1) == 0);
      if (mf0 < mf1) nn = n;
      else n0 = n;
      n = n0 + (nn - n0) / 2;
   }
   GetDims(shape, n, nb, &M, &N, &K);
   free(Ns);
   free(mfs0);
   free(mfs1);
   return(shape == AtlasMN_REST ? K : M*N*K);
}


void DoShapes(FILE *fpout, char TA, char TB, int nb, int N0, int NN, int incN, 
              SCALAR alpha, SCALAR beta)
{
   enum ATLAS_MATSHAPE shape;
   unsigned long n, nn;
   int M, N, K;
   static char *nm[nshape] = {"M", "N", "MN", "K", "GE"};

   big_gemm    = Mjoin(PATL,big_mm);
   small_gemm  = Mjoin(PATL,small_mm);
   for (shape=AtlasM_NB; shape <= Atlas0_NB; shape++)
   {
      n = tloop(shape, TA, TB, nb, alpha, beta);
@skip      GetDims(shape, n, nb, &M, &N, &K);
@skip      nn = M * N * K;
      fprintf(fpout, "#define %c%c_MNK_%s (unsigned long)(%ld)\n", 
              TA, TB, nm[shape], n);
   }
}

int main(int nargs, char *args[])
{
   char TA='n', TB='n';
   int nb, N0, NN, incN, jstop=0;
   long icross;
   #ifdef TREAL
      TYPE alpha=1.0, beta=1.0;
   #else
      TYPE alpha[2] = {-1.0, 0.0}, beta[2] = {1.0, 0.0};
   #endif
   FILE *fp;

   big_gemm    = Mjoin(PATL,big_mm);
   small_gemm  = Mjoin(PATL,small_mm);
#ifndef SM_FOUT
   if (nargs < 5)
   {
      fprintf(stderr, "usage: %s <NB> <N0> <NN> <incN> [TA TB alpha beta]\n", args[0]);
      exit(-1);
   }
   nb = atoi(args[1]);
   N0 = atoi(args[2]);
   NN = atoi(args[3]);
   incN = atoi(args[4]);
   if (nargs > 5) TA = *args[5];
   if (nargs > 6) TA = *args[6];
   if (nargs > 7) alpha = atof(args[7]);
   if (nargs > 8) beta  = atof(args[8]);
   tloop(jstop, TA, TB, nb, N0, NN, incN, alpha, beta);
#else
   fprintf(stderr, "\n\nFinding crossover point for small case algorithms:\n");
   fp = fopen(Mstr(SM_FOUT), "w");
   nb = NB;
   N0 = 10;
   NN = 100;
   incN = 5;

   fprintf(fp, "#ifndef %sXOVER_H\n#define %sXOVER_H\n\n", 
           Mstr(PREU), Mstr(PREU));
   fprintf(fp, "#define ATL_3NB %d\n", 3*NB);
   DoShapes(fp, 'N', 'N', nb, N0, NN, incN, alpha, beta);
   DoShapes(fp, 'N', 'T', nb, N0, NN, incN, alpha, beta);
   DoShapes(fp, 'T', 'N', nb, N0, NN, incN, alpha, beta);
   DoShapes(fp, 'T', 'T', nb, N0, NN, incN, alpha, beta);
#ifdef TCPLX
   small_gemm  = Mjoin(PATL,big_mm);
   big_gemm  = Mjoin(PATL,Mjoin(UPR,big_mm));
   icross = tloop(AtlasMN_REST, 'N', 'T', nb, alpha, beta);
   fprintf(fp, "#define C2R_K %ld\n", icross);
#endif
   fprintf(fp, "\n#endif\n");
   fclose(fp);
#endif
   return(0);
}
@ROUT txover
@whiledef rt tgemm tgemm_p
int Mjoin(PATL,@(rt))
   (const enum ATLAS_TRANS TA, const enum ATLAS_TRANS TB,
    ATL_CINT M, ATL_CINT N, ATL_CINT K, const SCALAR alpha,
    const TYPE *A, ATL_CINT lda, const TYPE *B, ATL_CINT ldb,
    const SCALAR beta, TYPE *C, ATL_CINT ldc);
@endwhile
int Mjoin(PATL,gemm_serial)
   (const enum ATLAS_TRANS TA, const enum ATLAS_TRANS TB,
    ATL_CINT M, ATL_CINT N, ATL_CINT K, const SCALAR alpha,
    const TYPE *A, ATL_CINT lda, const TYPE *B, ATL_CINT ldb,
    const SCALAR beta, TYPE *C, ATL_CINT ldc)
{
   Mjoin(PATL,gemm)(TA, TB, M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
   return(1);
}

typedef int (*GEMMPTR)
   (const enum ATLAS_TRANS TA, const enum ATLAS_TRANS TB,
    ATL_CINT M, ATL_CINT N, ATL_CINT K, const SCALAR alpha,
    const TYPE *A, ATL_CINT lda, const TYPE *B, ATL_CINT ldb,
    const SCALAR beta, TYPE *C, ATL_CINT ldc);
#define NSHAPES 7
static char *shapesuff[NSHAPES] = 
   {"SQmnk", "SmnLk", "SmkLn", "SnkLm", "SmLnk", "SnLmk", "SkLmn"};
enum ATLAS_MATSHAPE
{SquareMNK=0,  /* square, including recursive where all dim cut */
 ShortMN_LK=1, ShortMK_LN=2, ShortNK_LM=3,/* recursive shapes, one dim uncut */
 ShortM_LNK=4, ShortN_LMK=5, ShortK_LMN=6};/* 1-D staticly blocked shapes */
int ATL_FINDP = ATL_NCPU;
int ATL_OLDFINDP = 1;
static int *ATL_Ps;
static int ATL_nP;
static double ATL_CONMFLOP, ATL_SHPMFLOP=0;

double mmcase
(
   enum ATLAS_TRANS TA,                 /* Transpose setting for A */
   enum ATLAS_TRANS TB,                 /* Transpose setting for B */
   size_t flushsz,                      /* size of flush area */
   GEMMPTR gemm,                        /* ptr to matmul to time */
   double mflopF,                       /* how many mflops to force */
   ATL_CINT M, ATL_CINT N, ATL_CINT K,  /* matrix dimensions */
   int *np  /* number of procs returned by gemm call */
)
{
   #ifdef TCPLX
      const TYPE alpha[2] = {ATL_rone, ATL_rzero}, 
                 beta[2] = {ATL_rnone, ATL_rzero};
   #else
      const TYPE alpha = ATL_rone, beta = ATL_rnone;
   #endif
   ATL_INT lda, ldb, ldc, asize, bsize;
   size_t setsz, nsets, incsz, nrep, i, j;
   double t0, t1;
   TYPE *A, *B, *C, *mp;
   char *sp;
   static int cnt=0;

   lda = (TA == AtlasNoTrans) ? M : K;
   ldb = (TB == AtlasNoTrans) ? K : N;
   ldc = M;
   lda += 300;
   ldb += 300;
   ldc += 300;
   setsz = M*N + M*K + K*N;
   nsets = (ATL_DivBySize(flushsz)+setsz-1)/setsz;
   if (nsets < 1) 
      nsets = 1;
   asize = (TA == AtlasNoTrans) ? lda*K : lda*M;
   bsize = (TB == AtlasNoTrans) ? ldb*N : ldb*K;
   incsz = ldc*N + asize + bsize;
   do
   {
      mp = malloc(nsets*ATL_MulBySize(incsz));
      if (!mp)
         nsets--;
   }
   while (!mp && nsets > 1);
   assert(mp);
   t0 = (mflopF*1000000.0)/(2.0*M*N*K);
   nrep = t0;
   if (t0-nrep > 0.45)
      nrep++;
   if (nrep < 1) nrep = 1;
   Mjoin(PATL,gegen)(nsets*incsz, 1, mp, nsets*incsz, M*N+lda);

   t0 = time00();
   for (i=0; i < nrep; i++)
   {
      A = ((i/nsets)*nsets == i) ? mp : A + incsz;
      B = A + asize;
      C = B + bsize;
      *np = gemm(TA, TB, M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
   }
   t1 = time00() - t0;
   free(mp);
   if (gemm == Mjoin(PATL,tgemm_p))
   {
      sp = "parall";
      t0 = (*np > 1) ? (2.0*M*N*K*nrep) / (1000000.0*t1) : 0.0;
   }
   else
   {
      sp = "serial";
      t0 = (2.0*M*N*K*nrep) / (1000000.0*t1);
   }
   printf("%6d %6.6s %6d %6d %6d %6d %9.2f\n", ++cnt, sp, *np, M, N, K, t0);
   return(t0);
}

int FindBestNP
(
   enum ATLAS_TRANS TA,                 /* Transpose setting for A */
   enum ATLAS_TRANS TB,                 /* Transpose setting for B */
   size_t flushsz,                      /* size of flush area */
   double mflopF,                       /* how many mflops to force */
   ATL_CINT M, ATL_CINT N, ATL_CINT K,  /* matrix dimensions */
   int P                                /* max # of procs to try */
)
/*
 * This routine tries using a varying number of processors to decompose 
 * the problem.  It tries all powers of 2 between 1 and NP.
 * RETURNS: optimal number of processors to use for this problem
 * NOTE: give serial code 3% advantage, since parallel code should be
 *       noticably better, and is prone to large variance
 */
{
   int j, p, npB;
   double mfB, mf, mfS;

   assert(P > 1);
   npB = ATL_FINDP = P;
   mfB = mmcase(TA, TB, flushsz, Mjoin(PATL,tgemm_p), mflopF, M, N, K, &p);
   mfS = (ATL_SHPMFLOP > 0.0) ? ATL_SHPMFLOP : ATL_CONMFLOP;
   if (p < P || mfB < mfS)
   {
      mf = mmcase(TA, TB, flushsz, Mjoin(PATL,gemm_serial), mflopF, M, N, K, 
                  &p) * 1.03;   /* give serial code 3% advantage */
      ATL_SHPMFLOP = mf;
      if (mf > mfB) { npB = 1; mfB = mf; }
   }
   for (j=2; j < P; j *= 2);
   for (j >>= 1; j >= 2; j >>= 1)
   {
      ATL_FINDP = j;
      mf = mmcase(TA, TB, flushsz, Mjoin(PATL,tgemm_p), mflopF, M, N, K, &p);
      if (mf > mfB) { npB = j; mfB = mf; }
      if (mf > (j>>1)*mfS)
         break;
   }
   return(npB);
}

void GetDims
(
   enum ATLAS_MATSHAPE shape,  /* matrix shape */
   int restS,   /* size for the remaining dimenions to be restricted to */
   int growS,   /* size for the growing dimension(s) to be set to */
   int *M, int *N, int *K
)
{
   switch(shape)
   {
    case ShortMN_LK:
       *M = *N = restS;
       *K = growS;
       return;
    case ShortMK_LN:
       *M = *K = restS;
       *N = growS;
       return;
    case ShortNK_LM:
       *N = *K = restS;
       *M = growS;
       return;
    case ShortM_LNK: 
       *M = restS;
       *N = *K = growS;
       return;
    case ShortN_LMK:
       *N = restS;
       *M = *K = growS;
       return;
    case ShortK_LMN:
       *K = restS;
       *M = *N = growS;
       return;
    default:   /* square */
      *M = *N = *K = growS;
   }
}

int GetXover
(
   size_t flushsz, double mflopF,
   enum ATLAS_TRANS TA,                 /* Transpose setting for A */
   enum ATLAS_TRANS TB,                 /* Transpose setting for B */
   enum ATLAS_MATSHAPE shape, 
   ATL_CINT minN,   /* smallest size for growing dimension(s) */
   ATL_CINT maxN,   /* largest size for growing dimensions(s) */
   ATL_CINT NN,     /* size for non-growing dimension(s) */
   ATL_CINT P       /* max number of processors to use */
)
/*
 * This routine finds point between minN and maxN where the optimal number
 * of processors goes down.  It uses recursive halving, and assumes that a
 * given high value of P will win for all N > i, if it wins for i.
 * RETURNS: size where higher P first beats all other # procs between 
 *          [minN,maxN]; 0 if P processors never wins.
 */
{
   ATL_INT M, N, K, j, mymax, mymin, gap, k;
   int np, itmp;
   
/*
 * If we can't ever use all processors, then no crossover for this P
 */
   GetDims(shape, NN, maxN, &M, &N, &K);
   np = FindBestNP(TA, TB, flushsz, mflopF, M, N, K, P);
   if (np < P)
      return(0);
/*
 * Make sure parallel gemm isn't already faster on smallest case
 */
   GetDims(shape, NN, minN, &M, &N, &K);
   np = FindBestNP(TA, TB, flushsz, mflopF, M, N, K, P);
   if (np == P)
      return(minN);
/*
 * Begin recursive halving search
 */
   mymax = maxN;
   mymin = minN;
   do
   {
      j = ((mymax-mymin)>>1) + mymin;
      GetDims(shape, NN, j, &M, &N, &K);
      np = FindBestNP(TA, TB, flushsz, mflopF, M, N, K, P);
      if (np == P)  /* full P still winning at this size */
         mymax = j;
      else          /* P lost, try larger problems*/
         mymin = j;
      if (j < 100 || shape == SquareMNK)
         gap = 8;
      else if (j < 1000)
         gap = 16;
      else if (j < 2000)
         gap = 32;
      else
         gap = 128;
   }
   while (mymax-mymin > gap);
   return((np == P) ? j : mymax);
}

int *GetXoversForAllP
(
   size_t flushsz, double mflopF,
   enum ATLAS_TRANS TA,                 /* Transpose setting for A */
   enum ATLAS_TRANS TB,                 /* Transpose setting for B */
   enum ATLAS_MATSHAPE shape, 
   ATL_CINT minN,   /* smallest size for growing dimension(s) */
   ATL_CINT maxN0,  /* largest size for growing dimensions(s) */
   ATL_CINT NN      /* size for non-growing dimension(s) */
)
/*
 * RETURNS: a log2(NCPU) length array; each ith entry is the crossover point
 *          where using p=2^i provided better performance than any lesser
 *          amount of parallelism.  A 0 means that this number of processors
 *          was not useful.  The last entry is always NCPU, even if this
 *          is not a power of 2
 */
{
   static int *Ps, *xos;
   static int log2p=0;
   int i, j, maxN=maxN0;

   if (log2p == 0)
   {
      for (log2p=1; (1<<log2p) < ATL_NCPU; log2p++);
      Ps = malloc(sizeof(int)*log2p*2);
      xos = Ps + log2p;
      Ps[log2p-1] = ATL_NCPU;
      for (j=log2p-2; j >= 0; j--)
         Ps[j] = 2<<j;
   }
   for (j=log2p-1; j >= 0; j--)
   {
      if (maxN > minN)
      {
         xos[j] = GetXover(flushsz, mflopF, TA, TB, shape, minN, maxN,NN,Ps[j]);
         if (xos[j])
            maxN = xos[j];
      }
      else
        xos[j] = 0;
   }
   return(xos);
}

int GetShapesMaxN(enum ATLAS_TRANS TA, enum ATLAS_TRANS TB,
                  enum ATLAS_MATSHAPE shape)
   
{
   switch(shape)
   {
    case ShortMN_LK:
       if (TA == AtlasNoTrans || TB == AtlasTrans)
       {
          #ifdef TREAL
             return(8000);
          #elif defined(SCPLX)
             return(8000);
          #else
             return(4000);
          #endif
       }
    case ShortMK_LN:
    case ShortNK_LM:
       #ifdef TREAL
          return(10000);
       #elif defined(SCPLX)
          return(8000);
       #else
          return(6000);
       #endif
    case ShortM_LNK: 
    case ShortN_LMK:
    case ShortK_LMN:
       #ifdef SREAL
          return(6000);
       #elif defined(SCPLX)
          return(4000);
       #elif defined(DCPLX)
          return(4000);
       #else
          return(6000);
       #endif
    default:   /* square */
       return(1000);
   }
   return(2000);
}

ATL_INT *GetXoversByShape
(
   size_t flushsz,              /* size of cache to flush */
   double mflopF,               /* mflops to force for timing resolution */
   enum ATLAS_TRANS TA,         /* Transpose setting for A */
   enum ATLAS_TRANS TB,         /* Transpose setting for B */
   enum ATLAS_MATSHAPE shape    /* shape of the matrix */
)
/*
 * RETURNS: log2(p)*9 array of crossover points for different processor counts.
 *          The contiguous dim is log2(P) crossover points, and tracks the
 *          crossover points for p=2, 4, 8, P (doubling the number of cores
 *          at each step, until the maximum is reached).  The noncontiguous
 *          dimensions gives the size of the restricted dimensions, where
 *          are set to 1<<i, 0 <= i < 9;
 */
{
   ATL_INT *xos, i, k, j, *ix, log2p, minN, maxN, *ip;

   printf("\n\nFINDING XOVERS FOR %s\n", shapesuff[shape]);
   printf(" COUNT  WHICH      P      M      N      K     MFLOP\n");
   printf("====== ====== ====== ====== ====== ====== =========\n");

   minN = Mjoin(PATL,GetNB)();
   maxN = GetShapesMaxN(TA, TB, shape);

   for (log2p=1; (1<<log2p) < ATL_NCPU; log2p++);
   ix = calloc(9*log2p, sizeof(ATL_INT));
   assert(ix);
   for (i=8; i >= 0; i--)
   {
      ATL_SHPMFLOP = 0.0;
/*
 *    Get crossover points for all power-of-2 P
 */
      xos = GetXoversForAllP(flushsz, mflopF, TA, TB, shape, minN, maxN, 1<<i);
      ip = ix + log2p*i;
      j = 0;
      for (k=0; k < log2p; k++)
      {
         if (xos[k])
         {
            if (j)
               j = Mmin(j, xos[k]);
            else
               j = xos[k];
         }
         ip[k] = xos[k];
      }
/*
 *    New minN is the crossover of this time, since we go from biggest to 
 *    smallest on other dims
 */
      if (j)
         minN = j;
      if (!j)       /* if we can't thread this size, can't thread smaller */
         break;
   }
   return(ix);
}

void FindXovers
(
   size_t flushsz,              /* size of cache to flush */
   double mflopF,               /* mflops to force for timing resolution */
   FILE *fpout                  /* file to print output to */
)
{
   int i, k, t, u, l2p;
   ATL_INT *xo;
   enum ATLAS_TRANS tr[2] = {AtlasNoTrans, AtlasTrans}, TA, TB;
   char ctr[2] = {'N', 'T'}, cta, ctb;

   for (l2p=1; (1<<l2p) < ATL_NCPU; l2p++);
   fprintf(fpout, "/* This file generated by %s\n */\n", __FILE__);
   fprintf(fpout, "#ifndef ATL_TXOVER_H\n   #define ATL_TXOVER_H 1\n\n");
   fprintf(fpout, "   #define ATL_PDIM %d\n", l2p);
   for (i=0; i < NSHAPES; i++)
   {
      for (t=0; t < 2; t++)
      {
         TA = tr[t];
         cta = ctr[t];
         for (u=0; u < 2; u++)
         {
            TB = tr[u];
            ctb = ctr[u];
            if (i == ShortMK_LN)
            {
               if (TA == AtlasTrans)
               {
                  fprintf(fpout, 
                          "#define ATL_tmmT%c_%s_XO ATL_tmmN%c_%s_XO\n",
                          ctb, shapesuff[i], ctb, shapesuff[i]);
                  continue;
               }
            }
            else if (i == ShortMK_LN)  /* TA not important */
            {
               if (TA == AtlasTrans)
               {
                  fprintf(fpout, 
                          "#define ATL_tmmT%c_%s_XO ATL_tmmN%c_%s_XO\n",
                          ctb, shapesuff[i], ctb, shapesuff[i]);
                  continue;
               }
            }
            else if (i == ShortNK_LM)  /* TB not important */
            {
               if (TB == AtlasTrans)
               {
                  fprintf(fpout, 
                          "#define ATL_tmm%cT_%s_XO ATL_tmm%cN_%s_XO\n",
                          cta, shapesuff[i], cta, shapesuff[i]);
                  continue;
               }
            }
/*
 *          If M == N, then NN case is roughly equivalent to TT case
 */
            else if (i == SquareMNK || i == ShortMN_LK || i == ShortK_LMN)
            {
               if (TA == AtlasTrans && TB == AtlasTrans)
               {
                  fprintf(fpout, 
                          "#define ATL_tmmTT_%s_XO ATL_tmmNN_%s_XO\n",
                          shapesuff[i], shapesuff[i]);
                  continue;
               }
            }
            if (i == SquareMNK)
            {
               xo = GetXoversForAllP(flushsz, mflopF, TA, TB, i,
                                      Mjoin(PATL,GetNB)(), 
                                      GetShapesMaxN(TA, TB, i), 0);
               fprintf(fpout, "static const int ATL_tmm%c%c_%s_XO[%d] = \n   {",
                       cta, ctb, shapesuff[i], l2p);
               for (k=0; k < l2p-1; k++)
                  fprintf(fpout, "%ld,", xo[k]);
               fprintf(fpout, "%d};\n", xo[l2p-1]);
            }
            else
            {
               xo = GetXoversByShape(flushsz, mflopF, TA, TB, i);
               fprintf(fpout, "static const int ATL_tmm%c%c_%s_XO[%d] = \n   {",
                       cta, ctb, shapesuff[i], l2p*9);
               for (k=0; k < 9*l2p-1; k++)
                  fprintf(fpout, "%ld,", xo[k]);
               fprintf(fpout, "%d};\n", xo[9*l2p-1]);
               free(xo);
            }
         }
      }
      fprintf(fpout, "static const int *ATL_tmm_%s_XO[4] =\n", shapesuff[i]);
      fprintf(fpout, "{ATL_tmmNN_%s_XO, ATL_tmmNT_%s_XO,\n", 
              shapesuff[i], shapesuff[i]);
      fprintf(fpout, " ATL_tmmTN_%s_XO, ATL_tmmTT_%s_XO};\n",
              shapesuff[i], shapesuff[i]);
   }
   fprintf(fpout, "\n#endif /* end ifndef ATL_TXOVER_H */\n");
}

void PrintUsage(char *name, int ierr, char *flag)
{
   if (ierr > 0)
      fprintf(stderr, "Bad argument #%d: '%s'\n",
              ierr, flag ? flag : "Not enough arguments");
   else if (ierr < 0)
      fprintf(stderr, "ERROR: %s\n", flag);
   
   fprintf(stderr, "USAGE: %s [flags]:\n", name);
   fprintf(stderr, "   -F <mflop> : force <mflops> of timed computation\n");
   fprintf(stderr, "   -f <flushKB> : flush at least this mem in LRU timers\n");
   fprintf(stderr, "   -o <file> : write header file to <file>\n");

   exit(ierr ? ierr : -1);
}

FILE *GetFlags(int nargs, char **args, int *flushKB, int *mflopF)
{
   int i;
   char *fout;
   FILE *fpout;
   #ifdef L2SIZE
      *flushKB = L2SIZE;
   #else
      *flushKB = 4*1024;
   #endif
   *mflopF = 1;
   fout = Mstr(Mjoin(res/atlas_,Mjoin(Mjoin(Mjoin(PRE,tXover_),ATL_NCPU),p.h)));
   for (i=1; i < nargs; i++)
   {
      if (args[i][0] != '-')
         PrintUsage(args[0], i, args[i]);
      switch(args[i][1])
      {
      case 'o':   /* -o <file> *f (++i >= nargs) */
         if (++i >= nargs)
            PrintUsage(args[0], i, NULL);
         fout = args[i];
         break;
      case 'f':                         /* -f <flushKB> */
         if (++i >= nargs)
            PrintUsage(args[0], i, NULL);
         *flushKB = atoi(args[i]);
         break;
      case 'F':                         /* -F <mflop> */
         if (++i >= nargs)
            PrintUsage(args[0], i, NULL);
         *mflopF = atoi(args[i]);
         break;
      default:
         PrintUsage(args[0], i, args[i]);
      }
   }
   fpout = fopen(fout, "w");
   assert(fpout);
   return(fpout);
}

int main(int nargs, char **args)
{
   int flushKB = 4*1024, mflopF=1;
   FILE *fpout;
   int i;

#if ATL_NCPU > 1
   fpout = GetFlags(nargs, args, &flushKB, &mflopF);
   for (i=1; (1<<i) < ATL_NCPU; i++);
   ATL_nP = i;
   ATL_Ps = malloc(ATL_nP*sizeof(int));
   assert(ATL_Ps);
   ATL_Ps[ATL_nP-1] = ATL_NCPU;
   for (i=ATL_nP-2; i >= 0; i--)
      ATL_Ps[i] = (2<<i);
   ATL_CONMFLOP = mmcase(AtlasNoTrans, AtlasNoTrans, flushKB, 
                         Mjoin(PATL,gemm_serial), mflopF, 1000, 1000, 1000, &i);
   FindXovers(flushKB*1024, mflopF, fpout);
#endif
   return(0);
}
@ROUT genmv
void genmv(char pre, char *type, int mu, int n, int alpha, int beta)
{
   char *spcs="                              ";
   char *spc=spcs+30;
   char eq[8], al[64], be[64];
   int pwr2_m = GetPower2(mu);
   int i, j, BETAX=0;

   fprintf(fpout, "void ATL_%cgemvN%d(const int M, const %s alpha, const %s *A, const int lda, const %s *x, %s *Y)\n", pre, n, type, type, type, type);
   fprintf(fpout, "{\n");
   if (pwr2_m) fprintf(fpout, "   const int m=(M>>%d)<<%d;\n", pwr2_m, pwr2_m);
   else fprintf(fpout, "   const int m=(M/%d)*%d;\n", mu, mu);
   fprintf(fpout, "   const int mr = M-m;\n");
   fprintf(fpout, "   %s *y=Y, *stY=Y+m;\n", type);
   fprintf(fpout, "   const %s *pA0=A", type);
   for (j=1; j < n; j++) fprintf(fpout, ", *pA%d=pA%d+lda", j, j-1);
   fprintf(fpout, ";\n\n");

   be[0] = '\0';
   if ( (alpha == 1) || (alpha == -1 && beta == 1) ) al[0] = '\0';
   else if (alpha == -1) sprintf(al, "-");
   else sprintf(al, "alpha*");
   if (alpha == -1 && beta == 1) sprintf(eq, "-=");
   else if (beta == 1) sprintf(eq, "+=");
   else if (beta == 0) sprintf(eq, "=");
   else
   {
      BETAX = 1;
      sprintf(eq, "=");
   }
   if (mu > 1)
   {
      fprintf(fpout, "%s   if (m)\n%s   {\n", spc, spc);
      spc -= 3;
   }
   fprintf(fpout, "%s   do\n%s   {\n", spc, spc);
   spc -= 3;
   if (BETAX) sprintf(be, "*y*beta + ");
   fprintf(fpout, "%s   *y %s %s%s(*pA0 * *x", spc, eq, be, al);
   for (j=1; j < n; j++) fprintf(fpout, " + *pA%d*x[%d]", j, j);
   fprintf(fpout, ");\n");
   for (i=1; i < mu; i++)
   {
      if (BETAX) sprintf(be, "y[%d]*beta + ", i);
      fprintf(fpout, "%s   y[%d] %s %s%s(pA0[%d] * *x", spc, i, eq, be, al, i);
      for (j=1; j < n; j++) fprintf(fpout, " + pA%d[%d]*x[%d]", j, i, j);
      fprintf(fpout, ");\n");
   }
   if (mu > 1)
      for (j=0; j < n; j++) fprintf(fpout, "%s   pA%d += %d;\n", spc, j, mu);
   else for (j=0; j < n; j++) fprintf(fpout, "%s   pA%d++;\n", spc, j);
   if (mu > 1) fprintf(fpout, "%s   y += %d;\n", spc, mu);
   spc += 3;
   if (mu > 1)
   {
      fprintf(fpout, "%s   }\n%s   while(y != stY);\n", spc, spc);
      spc += 3;
      fprintf(fpout, "%s   }\n%s   if (mr)\n%s   {\n", spc, spc, spc);
      spc -= 3;
      fprintf(fpout, "%s   stY += mr;\n", spc);
      fprintf(fpout, "%s   do\n%s   {\n", spc, spc);
      spc -= 3;

      if (BETAX) sprintf(be, "*y*beta + ");
      fprintf(fpout, "%s   *y %s %s%s(*pA0++ * *x", spc, eq, be, al);
      for (j=1; j < n; j++) fprintf(fpout, " + *pA%d++ * x[%d]", j, j);
      fprintf(fpout, ");\n");

      spc += 3;
      fprintf(fpout, "%s   }\n%s   while(++y != stY);\n", spc, spc);
      spc += 3;
      fprintf(fpout, "%s   }\n", spc);
   }
   else fprintf(fpout, "%s   }%s   while(++y != stY);\n", spc, spc);
   fprintf(fpout, "}\n");
}

void PrintUsage(char *nam)
{
   fprintf(stderr, "USAGE: %s -p <pre> -m <mu> -n <N> -a <alpha> -b <beta> -f <file>\n", nam);
   exit(-1);
}
int main(int nargs, char *args[])
{
   char pre='d', *type;
   int i, mu=4, n=16, alpha=1, beta=1;

   fpout = stdout;
   for (i=1; i < nargs; i++)
   {
      if (*args[i] != '-') PrintUsage(args[0]);
      switch(args[i][1])
      {
      case 'p':
         pre = *args[++i];
      case 'm':
         mu = atoi(args[++i]);
         break;
      case 'n':
         n = atoi(args[++i]);
         break;
      case 'a':
         alpha = atoi(args[++i]);
         break;
      case 'b':
         beta = atoi(args[++i]);
         break;
      case 'f':
         fpout = fopen(args[++i], "w");
         assert(fpout != NULL);
         break;
      case 'h':
      default:
         PrintUsage(args[0]);
         break;
      }
   }
   switch (pre)
   {
   case 's':
      type = "float";
      break;
   case 'd':
      type = "double";
      break;
   case 'c':
      type = "float";
      break;
   case 'z':
      type = "double";
      break;
   default:
      PrintUsage(args[0]);
   }
   genmv(pre, type, mu, n, alpha, beta);
   if (fpout != stdout && fpout != stderr) fclose(fpout);
   return(0);
}
@ROUT ATL_NCgemm
@extract -b @(topd)/gen.inc what=cw @(cw99)

#include "atlas_misc.h"
#include Mstr(Mjoin(Mjoin(atlas_,PRE)NCmm.h))
#include "atlas_lvl3.h"

void Mjoin(PATL,NCgemmNN_JIK)(const int M, const int N, const int K, 
                             const SCALAR alpha, const TYPE *A, const int lda, 
                             const TYPE *B, const int ldb, const SCALAR beta, 
                             TYPE *C, const int ldc)
/*
 * Blocked Notranspose, Notranspose gemm; J, I, K loop ordering; with no copy
 */
{
   register int k;
   int KB, KB2, incAk, mb, nb=NB, kb, i, j;
   const int KB0 = Mmin(NB, K);
   const int incBn = ATL_MulByNB(ldb), incCn = ATL_MulByNB(ldc)-M;
   const TYPE *a, *b;
   void (*mm_aXbX)(int M, int N, int K, const TYPE alpha,const TYPE *A, int lda,
                   const TYPE *B, int ldb, const TYPE beta, TYPE *C, int ldc);
   void (*mm_aXb1)(int M, int N, int K,const TYPE alpha, const TYPE *A, int lda,
                   const TYPE *B, int ldb, const TYPE beta, TYPE *C, int ldc);

   if ( SCALAR_IS_ONE(alpha) )
   {
      mm_aXb1 = Mjoin(PATL,nn_mm_a1_b1);
      if ( SCALAR_IS_ONE(beta) ) mm_aXbX = Mjoin(PATL,nn_mm_a1_b1);
      else if ( SCALAR_IS_ZERO(beta) ) mm_aXbX = Mjoin(PATL,nn_mm_a1_b0);
      else mm_aXbX = Mjoin(PATL,nn_mm_a1_bX);
   }
   else if ( SCALAR_IS_NONE(alpha) )
   {
      mm_aXb1 = Mjoin(PATL,nn_mm_an1_b1);
      if ( SCALAR_IS_ONE(beta) ) mm_aXbX = Mjoin(PATL,nn_mm_an1_b1);
      else if ( SCALAR_IS_ZERO(beta) ) mm_aXbX = Mjoin(PATL,nn_mm_an1_b0);
      else mm_aXbX = Mjoin(PATL,nn_mm_an1_bX);
   }
   else 
   {
      mm_aXb1 = Mjoin(PATL,nn_mm_aX_b1);
      if ( SCALAR_IS_ONE(beta) ) mm_aXbX = Mjoin(PATL,nn_mm_aX_b1);
      else if ( SCALAR_IS_ZERO(beta) ) mm_aXbX = Mjoin(PATL,nn_mm_aX_b0);
      else mm_aXbX = Mjoin(PATL,nn_mm_aX_bX);
   }
/*
 * Not worth blocking unless at least two dimensions exceed the blocking factor
 */
#if 1
   k = NB+NB;
   if (M < k)
   {
      if (N < k || K < k)
      {
         mm_aXbX(M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
         return;
      }
   }
   else if (N < k)
   {
      if (K < k)
      {
         mm_aXbX(M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
         return;
      }
   }
#endif
/*
 * Find alternative KB for when MB is partial, so A still fills cache
 */
   k = M - ATL_MulByNB(ATL_DivByNB(M));
   if (k) 
   {
      k = NBNB / k;
      KB2 = Mmin(k, K);
   }

/*
 * Do blocked multiplication
 */
   for (j=0; j != N; j += nb)
   {
      if (NB > N-j) nb = N-j;
      mb = NB;
      KB = KB0;
      incAk = ATL_MulByNB(lda);
      for (i=0; i != M; i += mb)
      {
         a = A+i;
         b = B;
/*
 *       For partial blocks, adjust KB in order to fill cache
 */
         if (NB > M-i)
         {
            mb = M-i;
            KB = KB2;
            incAk = KB * lda;
         }

         kb = KB;
         mm_aXbX(mb, nb, KB, alpha, a, lda, b, ldb, beta, C, ldc);
         a += incAk;
         b += KB;

         for (k=KB; k != K; k += kb)
         {
            if (KB > K-k) kb = K-k;
            mm_aXb1(mb, nb, kb, alpha, a, lda, b, ldb, beta, C, ldc);
            a += incAk;
            b += KB;
         }
         C += mb;
      }
      B += incBn;
      C += incCn;
   }
}

void Mjoin(PATL,NCgemmTN_JIK)(const int M, const int N, const int K, 
                             const SCALAR alpha, const TYPE *A, const int lda, 
                             const TYPE *B, const int ldb, const SCALAR beta, 
                             TYPE *C, const int ldc)
/*
 * Blocked Transpose, Notranspose gemm; J, I, K loop ordering; with no copy
 */
{
   register int k;
   int KB, KB2, mb, nb=NB, kb, i, j;
   const int KB0 = Mmin(NB, K);
   const int incAm = ATL_MulByNB(lda);
   const int incBn = ATL_MulByNB(ldb), incCn = ATL_MulByNB(ldc)-M;
   const TYPE *ac, *a, *b;
   void (*mm_aXbX)(int M, int N, int K, const TYPE alpha,const TYPE *A, int lda,
                   const TYPE *B, int ldb, const TYPE beta, TYPE *C, int ldc);
   void (*mm_aXb1)(int M, int N, int K,const TYPE alpha, const TYPE *A, int lda,
                   const TYPE *B, int ldb, const TYPE beta, TYPE *C, int ldc);

   if ( SCALAR_IS_ONE(alpha) )
   {
      mm_aXb1 = Mjoin(PATL,tn_mm_a1_b1);
      if ( SCALAR_IS_ONE(beta) ) mm_aXbX = Mjoin(PATL,tn_mm_a1_b1);
      else if ( SCALAR_IS_ZERO(beta) ) mm_aXbX = Mjoin(PATL,tn_mm_a1_b0);
      else mm_aXbX = Mjoin(PATL,tn_mm_a1_bX);
   }
   else if ( SCALAR_IS_NONE(alpha) )
   {
      mm_aXb1 = Mjoin(PATL,tn_mm_an1_b1);
      if ( SCALAR_IS_ONE(beta) ) mm_aXbX = Mjoin(PATL,tn_mm_an1_b1);
      else if ( SCALAR_IS_ZERO(beta) ) mm_aXbX = Mjoin(PATL,tn_mm_an1_b0);
      else mm_aXbX = Mjoin(PATL,tn_mm_an1_bX);
   }
   else 
   {
      mm_aXb1 = Mjoin(PATL,tn_mm_aX_b1);
      if ( SCALAR_IS_ONE(beta) ) mm_aXbX = Mjoin(PATL,tn_mm_aX_b1);
      else if ( SCALAR_IS_ZERO(beta) ) mm_aXbX = Mjoin(PATL,tn_mm_aX_b0);
      else mm_aXbX = Mjoin(PATL,tn_mm_aX_bX);
   }
/*
 * Not worth blocking unless at least two dimensions exceed the blocking factor
 */
#if 1
   k = NB+NB;
   if (M < k)
   {
      if (N < k || K < k)
      {
         mm_aXbX(M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
         return;
      }
   }
   else if (N < k)
   {
      if (K < k)
      {
         mm_aXbX(M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
         return;
      }
   }
#endif
/*
 * Find alternative KB for when MB is partial, so A still fills cache
 */
   k = M - ATL_MulByNB(ATL_DivByNB(M));
   if (k) 
   {
      k = NBNB / k;
      KB2 = Mmin(k, K);
   }

/*
 * Do blocked multiplication
 */
   for (j=0; j != N; j += nb)
   {
      ac = A;
      if (NB > N-j) nb = N-j;
      mb = NB;
      KB = KB0;
      for (i=0; i != M; i += mb)
      {
         b = B;
         a = ac;
/*
 *       For partial blocks, adjust KB in order to fill cache
 */
         if (NB > M-i)
         {
            mb = M-i;
            KB = KB2;
         }

         kb = KB;
         mm_aXbX(mb, nb, KB, alpha, a, lda, b, ldb, beta, C, ldc);
         a += KB;
         b += KB;

         for (k=KB; k != K; k += kb)
         {
            if (KB > K-k) kb = K-k;
            mm_aXb1(mb, nb, kb, alpha, a, lda, b, ldb, beta, C, ldc);
            a += KB;
            b += KB;
         }
         C += mb;
         ac += incAm;
      }
      B += incBn;
      C += incCn;
   }
}

void Mjoin(PATL,NCgemmNT_JIK)(const int M, const int N, const int K, 
                              const SCALAR alpha, const TYPE *A, const int lda, 
                              const TYPE *B, const int ldb, const SCALAR beta, 
                              TYPE *C, const int ldc)
/*
 * Blocked Notranspose, Transpose gemm; J, I, K loop ordering; with no copy
 */
{
   register int k;
   int KB, KB2, incAk, incBk, mb, nb=NB, kb, i, j;
   const int KB0 = Mmin(NB, K);
   const int incCn = ATL_MulByNB(ldc)-M;
   const TYPE *Ar=A, *a, *b;
   void (*mm_aXbX)(int M, int N, int K, const TYPE alpha,const TYPE *A, int lda,
                   const TYPE *B, int ldb, const TYPE beta, TYPE *C, int ldc);
   void (*mm_aXb1)(int M, int N, int K,const TYPE alpha, const TYPE *A, int lda,
                   const TYPE *B, int ldb, const TYPE beta, TYPE *C, int ldc);

   if ( SCALAR_IS_ONE(alpha) )
   {
      mm_aXb1 = Mjoin(PATL,nt_mm_a1_b1);
      if ( SCALAR_IS_ONE(beta) ) mm_aXbX = Mjoin(PATL,nt_mm_a1_b1);
      else if ( SCALAR_IS_ZERO(beta) ) mm_aXbX = Mjoin(PATL,nt_mm_a1_b0);
      else mm_aXbX = Mjoin(PATL,nt_mm_a1_bX);
   }
   else if ( SCALAR_IS_NONE(alpha) )
   {
      mm_aXb1 = Mjoin(PATL,nt_mm_an1_b1);
      if ( SCALAR_IS_ONE(beta) ) mm_aXbX = Mjoin(PATL,nt_mm_an1_b1);
      else if ( SCALAR_IS_ZERO(beta) ) mm_aXbX = Mjoin(PATL,nt_mm_an1_b0);
      else mm_aXbX = Mjoin(PATL,nt_mm_an1_bX);
   }
   else 
   {
      mm_aXb1 = Mjoin(PATL,nt_mm_aX_b1);
      if ( SCALAR_IS_ONE(beta) ) mm_aXbX = Mjoin(PATL,nt_mm_aX_b1);
      else if ( SCALAR_IS_ZERO(beta) ) mm_aXbX = Mjoin(PATL,nt_mm_aX_b0);
      else mm_aXbX = Mjoin(PATL,nt_mm_aX_bX);
   }
/*
 * Not worth blocking unless at least two dimensions exceed the blocking factor
 */
#if 1
   k = NB+NB;
   if (M < k)
   {
      if (N < k || K < k)
      {
         mm_aXbX(M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
         return;
      }
   }
   else if (N < k)
   {
      if (K < k)
      {
         mm_aXbX(M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
         return;
      }
   }
#endif
/*
 * Find alternative KB for when MB is partial, so A still fills cache
 */
   k = M - ATL_MulByNB(ATL_DivByNB(M));
   if (k) 
   {
      k = NBNB / k;
      KB2 = Mmin(k, K);
   }

/*
 * Do blocked multiplication
 */
   for (j=0; j != N; j += nb)
   {
      if (NB > N-j) nb = N-j;
      mb = NB;
      KB = KB0;
      incAk = ATL_MulByNB(lda);
      incBk = ATL_MulByNB(ldb);
      for (i=0; i != M; i += mb)
      {
         a = A+i;
         b = B;
/*
 *       For partial blocks, adjust KB in order to fill cache
 */
         if (NB > M-i)
         {
            mb = M-i;
            KB = KB2;
            incAk = KB2 * lda;
            incBk = KB2 * ldb;
         }

         kb = KB;
         mm_aXbX(mb, nb, KB, alpha, a, lda, b, ldb, beta, C, ldc);
         a += incAk;
         b += incBk;

         for (k=KB; k != K; k += kb)
         {
            if (KB > K-k) kb = K-k;
            mm_aXb1(mb, nb, kb, alpha, a, lda, b, ldb, beta, C, ldc);
            a += incAk;
            b += incBk;
         }
         C += mb;
      }
      B += NB;
      C += incCn;
   }
}

void Mjoin(PATL,NCgemmTT_JIK)(const int M, const int N, const int K, 
                             const SCALAR alpha, const TYPE *A, const int lda, 
                             const TYPE *B, const int ldb, const SCALAR beta, 
                             TYPE *C, const int ldc)
/*
 * Blocked Transpose, Transpose gemm; J, I, K loop ordering; with no copy
 */
{
   register int k;
   int KB, KB2, incBk, mb, nb=NB, kb, i, j;
   const int KB0 = Mmin(NB, K);
   const int incAm = ATL_MulByNB(lda), incCn = ATL_MulByNB(ldc)-M;
   const TYPE *Ac, *a, *b;
   void (*mm_aXbX)(int M, int N, int K, const TYPE alpha,const TYPE *A, int lda,
                   const TYPE *B, int ldb, const TYPE beta, TYPE *C, int ldc);
   void (*mm_aXb1)(int M, int N, int K,const TYPE alpha, const TYPE *A, int lda,
                   const TYPE *B, int ldb, const TYPE beta, TYPE *C, int ldc);

   if ( SCALAR_IS_ONE(alpha) )
   {
      mm_aXb1 = Mjoin(PATL,tt_mm_a1_b1);
      if ( SCALAR_IS_ONE(beta) ) mm_aXbX = Mjoin(PATL,tt_mm_a1_b1);
      else if ( SCALAR_IS_ZERO(beta) ) mm_aXbX = Mjoin(PATL,tt_mm_a1_b0);
      else mm_aXbX = Mjoin(PATL,tt_mm_a1_bX);
   }
   else if ( SCALAR_IS_NONE(alpha) )
   {
      mm_aXb1 = Mjoin(PATL,tt_mm_an1_b1);
      if ( SCALAR_IS_ONE(beta) ) mm_aXbX = Mjoin(PATL,tt_mm_an1_b1);
      else if ( SCALAR_IS_ZERO(beta) ) mm_aXbX = Mjoin(PATL,tt_mm_an1_b0);
      else mm_aXbX = Mjoin(PATL,tt_mm_an1_bX);
   }
   else 
   {
      mm_aXb1 = Mjoin(PATL,tt_mm_aX_b1);
      if ( SCALAR_IS_ONE(beta) ) mm_aXbX = Mjoin(PATL,tt_mm_aX_b1);
      else if ( SCALAR_IS_ZERO(beta) ) mm_aXbX = Mjoin(PATL,tt_mm_aX_b0);
      else mm_aXbX = Mjoin(PATL,tt_mm_aX_bX);
   }
/*
 * Not worth blocking unless at least two dimensions exceed the blocking factor
 */
#if 1
   k = NB+NB;
   if (M < k)
   {
      if (N < k || K < k)
      {
         mm_aXbX(M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
         return;
      }
   }
   else if (N < k)
   {
      if (K < k)
      {
         mm_aXbX(M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
         return;
      }
   }
#endif
/*
 * Find alternative KB for when MB is partial, so A still fills cache
 */
   k = M - ATL_MulByNB(ATL_DivByNB(M));
   if (k) 
   {
      k = NBNB / k;
      KB2 = Mmin(k, K);
   }

/*
 * Do blocked multiplication
 */
   for (j=0; j != N; j += nb)
   {
      if (NB > N-j) nb = N-j;
      mb = NB;
      KB = KB0;
      incBk = ATL_MulByNB(ldb);
      Ac = A;
      for (i=0; i != M; i += mb)
      {
         a = Ac;
         b = B;
/*
 *       For partial blocks, adjust KB in order to fill cache
 */
         if (NB > M-i)
         {
            mb = M-i;
            KB = KB2;
            incBk = KB * ldb;
         }

         kb = KB;
         mm_aXbX(mb, nb, KB, alpha, a, lda, b, ldb, beta, C, ldc);
         a += KB;
         b += incBk;

         for (k=KB; k != K; k += kb)
         {
            if (KB > K-k) kb = K-k;
            mm_aXb1(mb, nb, kb, alpha, a, lda, b, ldb, beta, C, ldc);
            a += KB;
            b += incBk;
         }
         C += mb;
         Ac += incAm;
      }
      B += NB;
      C += incCn;
   }
}

int Mjoin(PATL,NCgemm)(const enum ATLAS_TRANS TA, const enum ATLAS_TRANS TB,
                       const int M, const int N, const int K, 
                       const SCALAR alpha, const TYPE *A, const int lda, 
                       const TYPE *B, const int ldb, const SCALAR beta, 
                       TYPE *C, const int ldc)
/*
 * blocked gemm without copy
 */
{
   if (!M || !N) return(0);
   if ( !K || SCALAR_IS_ZERO(alpha) )
   {
      if ( SCALAR_IS_ONE(beta) ) return(0);
      if ( SCALAR_IS_ZERO(beta) ) Mjoin(PATL,gezero(M, N, C, ldc);
      else Mjoin(PATL,gescal_bX)(M, N, beta, C, ldc);
      return(0);
   }
   if (TA == AtlasNoTrans)
   {
      if (TB == AtlasNoTrans)
         Mjoin(PATL,NCgemmNN_JIK)(M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
      else /* B is transpose, A notrans */
         Mjoin(PATL,NCgemmNT_JIK)(M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
   }
   else  /* A is transpose */
   {
      if (TB == AtlasNoTrans)
         Mjoin(PATL,NCgemmTN_JIK)(M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
      else /* A & B are transpose */
         Mjoin(PATL,NCgemmTT_JIK)(M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
   }
   return(0);
}
@ROUT ATL_GetNCNB
@extract -b @(topd)/gen.inc what=cw
#include "atlas_misc.h"
#include Mstr(Mjoin(Mjoin(atlas_,PRE),NCmm.h))

int Mjoin(PATL,GetNCNB)()
{
   return(NB);
}
@ROUT ATL_GetNB
@extract -b @(topd)/gen.inc what=cw

#include "atlas_lvl3.h"

int Mjoin(PATL,GetNB)()
{
   return(NB);
}
@ROUT atlas_tee
@extract -b @(topd)/gen.inc what=cw

#include <stdio.h>
#include <stdlib.h>
int main(int nargs, char *args[])
{
   char ln[512];
   FILE *fp;
   int i;

   if (nargs != 2) 
   {
      fprintf(stderr, "USAGE : %s <fnam>\n", args[0]);
      exit(-1);
   }
   fp = fopen(args[1], "a");
   if (fp == NULL)
   {
      fprintf(stderr, "%s: unable to open file %s\n", args[0], args[1]);
      exit(-1);
   }
   while(fgets(ln, 512, stdin))
   {
      fprintf(stdout, "%s", ln);
      fprintf(fp, "%s", ln);
   }
   i = ferror(fp);
   fclose(fp);
   return(i);
}
@ROUT atlas_fopen.h
#ifndef ATLAS_FOPEN_H
#define ATLAS_FOPEN_H

static int FileExists(const char *path)
{
   FILE *fp;
   int iret=0;
   fp = fopen(path, "r");
   if (fp)
   {
      fclose(fp);
      iret = 1;
   }
   return(iret);
}

#ifdef ATL_FOPENDELAY
static FILE *ATL_fopen(const char *path, const char *mode)
/*
 * Overload fopen so it waits for NFS propogation upon first read failure
 */
{
   FILE *fp;
   char ln[256];

   fp = fopen(path, mode);
   if (fp == NULL)
   {
      if (*mode == 'r') /* give NFS time to produce file */
      {
         sprintf(ln, "make waitfile waitfile=%s\n", path);
         if (system(ln) == 0) fp = fopen(path, mode);
      }
   }
   return(fp);
}
#define fopen ATL_fopen
#endif

#endif
@ROUT atlas_install
@extract -b @(topd)/cw.inc lang=C -def cwdate 2015 -def cwdate 1998
@skip @extract -b @(topd)/gen.inc what=cw @(cw98)
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <ctype.h>
#include <string.h>
#include "atlas_fopen.h"
#include "atlas_enum.h"
#include "atlas_r1parse.h"
#include "atlas_mvparse.h"
#include "atlas_mmparse.h"
#ifndef Mmax
   #define Mmax(x, y) ( (x) > (y) ? (x) : (y) )
#endif

char *redir="2>&1 | ./xatlas_tee";
char *fmake="make -f Makefile";
int DOSEARCH=1, REGS=32;
int QUERY=0;
FILE *fpI, *fparch;

#define Mciswspace(C) ( (((C) > 8) && ((C) < 14)) || ((C) == 32) )
#define Mlowcase(C) ( ((C) > 64 && (C) < 91) ? (C) | 32 : (C) )

@extract -b @(basd)/query.inc

void PrintBanner(char *fnam, int START, int sec, int subsec, int subsubsec);
static void ATL_Cassert0(size_t cond, char *exp, char *logfile, int line)
{
   FILE *fperr;

   if (cond) return;

   fperr = fopen("INSTALL_LOG/ERROR.LOG", "a");
   if (logfile)
      ATL_mprintf(2, stderr, fperr, 
                  "ERROR %d DURING %s!!.  CHECK %s FOR DETAILS.\n",
                  line, exp, logfile);
   else ATL_mprintf(2, stderr, fperr, "ERROR %d DURING %s!!.\n", line, exp);
   if (system("make error_report") == 0)
   {
      ATL_mprintf(2, stderr, fperr, 
"Error report error_<ARCH>.tgz has been created in your top-level ATLAS\n");
      ATL_mprintf(2, stderr, fperr,
         "directory.  Be sure to include this file in any help request.\n");
   }
   if (fperr) fclose(fperr);
/*
 * Ignore ifs: fucking gcc/glibc forces me to make code less maintainable
 */
   if(system("cat ../../CONFIG/error.txt >> INSTALL_LOG/ERROR.LOG"));
   if(system("cat ../../CONFIG/error.txt"));
   exit(-1);
}
#define ATL_Cassert(cond_, exp_, logfile_) \
    ATL_Cassert0((size_t)(cond_), exp_, logfile_, __LINE__)
@beginskip
#define ATL_Cassert(cond_, exp_, logfile_) \
{\
if (!(cond_)) \
{ \
   FILE *fPeRoR; \
   if (logfile_) \
      fprintf(stderr, \
              "ERROR %d DURING %s!!  CHECK %s FOR DETAILS.\n", \
              __LINE__, (exp_), (logfile_)); \
   else \
      fprintf(stderr, "ERROR %d DURING %s!!\n", __LINE__, (exp_), (logfile_)); \
   fprintf(stderr, \
      "If you can't figure it out, mail all logfiles and a description\n"); \
   fprintf(stderr, \
      "of your problem (including this error message) to atlas@cs.utk.edu.\n");\
   PrintBanner("INSTALL_LOG/ERROR.LOG", 1, 0, 0, 0); \
   fPeRoR = fopen("INSTALL_LOG/ERROR.LOG", "a"); \
   if (logfile_) \
      fprintf(fPeRoR, \
              "ERROR %d DURING %s!!  CHECK %s FOR DETAILS.\n", \
              __LINE__, (exp_), (logfile_)); \
   else \
      fprintf(fPeRoR, "ERROR %d DURING %s!!\n", __LINE__, (exp_), (logfile_)); \
   fprintf(fPeRoR, \
      "If you can't figure it out, mail all logfiles and a description\n"); \
   fprintf(fPeRoR, \
      "of your problem (including this error message) to atlas@cs.utk.edu.\n");\
      PrintBanner("INSTALL_LOG/ERROR.LOG", 1, 0, 0, 0); \
   fclose(fPeRoR); \
   exit(-1); \
}\
}
@endskip

void GetInstLogFile(char *nam, int pre, int *muladd, int *pf, int *lat, 
                    int *nb, int *mu, int *nu, int *ku, int *ForceFetch,
                    int *ifetch, int *nfetch, double *mflop)
{
   char ln[128];
   FILE *fp;

   fp = fopen(nam, "r");
   if (fp == NULL) fprintf(stderr, "file %s not found!!\n\n", nam);
   assert(fp);
   assert(fgets(ln, 128, fp));
   assert(fscanf(fp, " %d %d %d %d %d %d %d %d %d %d %lf\n",
          muladd, lat, pf, nb, mu, nu, ku, ForceFetch, ifetch, nfetch, mflop)
          == 11);
   fclose(fp);
}

void PrintBanner(char *fnam, int START, int sec, int subsec, int subsubsec)
{
   int month, day, year, hour, min;
   char *sep="*******************************************************************************\n";
   char ln[256];
   FILE *fp;
   
   sprintf(ln, "ERROR OPENING FILE %s\n", fnam);
   fp = fopen(fnam, "a");
   if (fp == NULL) return;
   GetDate(&month, &day, &year, &hour, &min);
   fprintf(fp, "\n%s%s%s", sep, sep, sep);
   if (START)
      fprintf(fp, "*       BEGAN ATLAS@6l@(ver) INSTALL OF SECTION %1d-%1d-%1d ON %02d/%02d/%04d AT %02d:%02d     *\n",
              sec, subsec, subsubsec, month, day, year, hour, min);
   else 
      fprintf(fp, "*      FINISHED ATLAS@6l@(ver) INSTALL OF SECTION %1d-%1d-%1d ON %02d/%02d/%04d AT %02d:%02d   *\n",
                      sec, subsec, subsubsec, month, day, year, hour, min);
   fprintf(fp, "%s%s%s\n\n\n", sep, sep, sep);
   fclose(fp);
}

void PrintStartStop(FILE *fp0, FILE *fp1, int nspc, int START, int sec, 
                    int subsec, int subsubsec, char *stagename)
{
   int i, month, day, year, hour, min;
   char ln[512];
   FILE *fp;
   
   GetDate(&month, &day, &year, &hour, &min);
   for (i=0; i < nspc; i++)
       ln[i] = ' ';
   if (START)
   {
      if (stagename)
         sprintf(ln+i, "BEGIN STAGE %d-%d-%d: %s at %02d:%02d\n", 
                 sec, subsec, subsubsec, stagename, hour, min);
      else
         sprintf(ln+i, "BEGIN STAGE %d-%d-%d at %02d:%02d\n", 
                 sec, subsec, subsubsec, hour, min);
   }
   else 
      sprintf(ln+i, "DONE  STAGE %d-%d-%d at %02d:%02d\n",
              sec, subsec, subsubsec, hour, min);
   if (START)
   {
      if (fp0)
         fprintf(fp0, "\n\n");
      if (fp1)
         fprintf(fp1, "\n\n");
   }
   if (fp0)
      fprintf(fp0, "%s", ln);
   if (fp1)
      fprintf(fp1, "%s", ln);
}

int LnIsCont(char *ln)
/*
 * RETURNS: 1 if last non-whitespace char in ln is '\', and 0 otherwise
 */
{
   int i;
   for (i=0; ln[i]; i++);
   for (i--; Mciswspace(ln[i]) && i > 0; i--);
   return(ln[i] == '\\');
}

void GetuMMRES(char pre, int ID, int *muladd, int *lat,
               int *mu, int *nu, int *ku)
/*
 * Reads the user index file to obtain the settings for user-contributed
 * kernel ID
 */
{
   char ln[1024];
   char fnam[256], auth[256];
   FILE *fp;
   int i, n, itmp, id;

   sprintf(ln, "../tune/blas/gemm/%ccases.dsc", pre);
   fp = fopen(ln, "r");
   assert(fp);
   assert(fgets(ln, 1024, fp));  /* skip comment line */
   assert(fgets(ln, 1024, fp));  /* get number of user cases line */
   assert(sscanf(ln, " %d", &n) == 1);
/*
 * Now search file for ID
 */
   for (i=0; i < n; i++)
   {
      assert(fgets(ln, 1024, fp));
      assert(sscanf(ln, " %d %d %d %d %d %d %d %d %d %d %s \"%[^\"]", &id,
                    &itmp, &itmp, &itmp, &itmp, muladd, lat, mu, nu, ku, 
                    fnam, auth) == 12);
      if (LnIsCont(ln))
      {
         assert(fgets(ln, 1024, fp));
         assert(fgets(ln, 1024, fp));
      }
      if (id == ID)
         break;
   }
   assert(id == ID);
   fclose(fp);
}
void GetMMRES(char pre, int *muladd, int *lat, int *nb, int *pref,
              int *mu, int *nu, int *ku, int *ff, int *iff, int *nf,
              double *mf, int *icase, char *ufile, char *auth, double *umf)
{
   int h, i, j, k;
   char ln[256];
   FILE *fp;

   sprintf(ln, "INSTALL_LOG/%cMMRES", pre);
   fp = fopen(ln, "r");
   assert(fp);
   assert(fgets(ln, 256, fp));
   assert(fgets(ln, 256, fp));
   assert(sscanf(ln, " %d %d %d %d %d %d %d %d %d %d %lf", muladd, lat, pref, 
                 nb, mu, nu, ku, ff, iff, nf, mf) == 11);
   assert(fgets(ln, 256, fp));
   if ( fgets(ln, 256, fp) )  /* user-supplied GEMM was best */
   {
      assert(fscanf(fp, " %d %d %lf \"%[^\"]\" \"%[^\"]", 
                    icase, &i, umf, ufile, auth) == 5);
   }
   else
   {
      ufile[0] = auth[0] = '\0';
      *umf = 0.0;
      *icase = -1;
   }
   fclose(fp);
}
 
void GoToTown(int ARCHDEF, int L1DEF, int TuneLA, int NREG)
{
   const char TR[2] = {'N','T'};
   char prec[4] = {'d', 's', 'z', 'c'}, pre, upre, *typ;
   char ln[1024], tnam[256], ln2[512], ln3[512], fnam[128];
   char *mulinst, *peakstr, *peakstr2;
   int nprec=4;
   int iL1, lat, muladd, maused, latuse, lbnreg;
   int len, i, j, ip, ia, ib, ncnb, pf;
   int FoundCE=0;
   int maxreg, latus, nb, mu, nu, ku;
   int ffetch, ifetch, nfetch;
   int DefInstall=0;
   long imf;
   int idU, maU, latU, muU, nuU, kuU, il1mul, pfA;
   double mfU, mf4x1, mf4x4, mf, mfp, mmmf, mfpeak[2], l1mul;
   FILE *fp, *fpsum, *fpabr;
   ATL_mmnode_t *mmp, *mmb;

   PrintBanner("INSTALL_LOG/SUMMARY.LOG", 1, 0, 0, 0);
   fpsum = fopen("INSTALL_LOG/SUMMARY.LOG", "a");
   ATL_Cassert(fpsum, "OPENING INSTALL_LOG/SUMMARY.LOG", NULL);

   ATL_Cassert(tmpnam(tnam), "GETTING TEMPFILE", NULL);

@beginskip
   if (L1DEF)
   {
      ATL_Cassert(system("make IBozoL1.grd\n")==0, 
                  "USING BOZO L1 DEFAULTS", NULL);
   }
   if (ARCHDEF)
      DefInstall = !system("make IArchDef.grd\n");
@endskip
   DefInstall = !system("make IArchDef.grd\n");
 
   PrintStartStop(stdout, fpsum, 0, 1, 1, 0, 0, "SYSTEM PROBE/AUX COMPILE");

@skip   ATL_mprintf(2, stdout, fpsum, 
@skip               "\n\nIN STAGE 1 INSTALL:  SYSTEM PROBE/AUX COMPILE\n");

   sprintf(ln2, "INSTALL_LOG/Stage1.log");
   PrintBanner("INSTALL_LOG/Stage1.log", 1, 1, 0, 0);
   #if defined(ATL_OS_Win64)
      #if defined(ATL_GAS_ARM64)
         typ = "winARM64";
      #else
         typ = "win64";
      #endif
   #elif defined(ATL_OS_Win9x) || defined(ATL_OS_WinNT)
      typ = "ia32";
   #else
      typ = "mut";
   #endif
   sprintf(ln, "%s IStage1 nreg=%d LOCK=%s %s INSTALL_LOG/Stage1.log\n", 
           fmake, NREG, typ, redir);
   ATL_Cassert(system(ln)==0, "Stage 1 install", ln2);
   fp = fopen("INSTALL_LOG/L1CacheSize", "r");

   ATL_Cassert(fp, "CACHESIZE SEARCH", ln2);
   ATL_Cassert(fscanf(fp, "%d", &i) == 1, "CACHESIZE SEARCH", ln2);
   fclose(fp);
   fprintf(stdout, "\n\n   Level 1 cache size calculated as %dKB\n", i);
   fprintf(fpsum, "   Level 1 cache size calculated as %dKB.\n\n", i);
   iL1 = i;

   for (ip=0; ip < 2; ip++)
   {
      sprintf(ln, "INSTALL_LOG/%cMULADD", prec[ip]);
      fp = fopen(ln, "r");
      ATL_Cassert(fp, "FPU PROBE", NULL);
      ATL_Cassert(fscanf(fp, " %d", &muladd)==1, "FPU PROBE", ln2);
      ATL_Cassert(fscanf(fp, " %d", &lat)==1, "FPU PROBE", ln2);
      ATL_Cassert(fscanf(fp, " %lf", &mfpeak[ip])==1, "FPU PROBE", ln2);
      ATL_Cassert(fscanf(fp, " %d", &lbnreg)==1, "FPU PROBE", ln2);
      fclose(fp);
      if (muladd) mulinst = "Combined muladd instruction";
      else mulinst = "Separate multiply and add instructions";
      ATL_mprintf(2, stdout, fpsum, "   %cFPU: %s with %d cycle pipeline.\n", 
                  prec[ip], mulinst, lat);
      ATL_mprintf(2, stdout, fpsum, 
                  "         Apparent number of registers : %d\n", lbnreg);
      ATL_mprintf(2, stdout, fpsum, 
                  "         Register-register performance=%.2fMFLOPS\n", 
                  mfpeak[ip]);
   }
   PrintStartStop(stdout, fpsum, 0, 0, 1, 0, 0, NULL);

   PrintStartStop(stdout, fpsum, 0, 1, 2, 0, 0, "TYPE-DEPENDENT TUNING");
@skip   fprintf(stdout, "\n\nIN STAGE 2 INSTALL:  TYPE-DEPENDENT TUNING\n");
@skip   fprintf(fpsum , "\n\nIN STAGE 2 INSTALL:  TYPE-DEPENDENT TUNING\n");

   for (ip=0; ip < nprec; ip++)
   {
      sprintf(ln, "INSTALL_LOG/%cPerfSumm.txt", prec[ip]);
      fpabr = fopen(ln, "w");
      ATL_Cassert((fpabr != NULL), "Unable to open abbreviation file", NULL);
      pre = prec[ip];
      switch(pre)
      {
      case 's':
         len = sizeof(float);
         typ = "SREAL";
         upre = 's';
         break;
      case 'd':
         len = sizeof(double);
         typ = "DREAL";
         upre = 'd';
         break;
      case 'c':
         len = sizeof(float);
         typ = "SCPLX";
         upre = 's';
         break;
      case 'z':
         len = sizeof(double);
         typ = "DCPLX";
         upre = 'd';
         break;
      }
      #ifdef ATL_CPUMHZ
         fprintf(fpabr, "Clock_rate=%d Mhz\n", ATL_CPUMHZ);
         mfp = ATL_CPUMHZ;
         peakstr = "of detected clock rate";
         peakstr2 = "clock";
      #else
         fprintf(fpabr, "Clock_rate=0 Mhz\n");
         if (pre == 'd' || pre == 'z') mfp = mfpeak[0];
         else mfp = mfpeak[1];
         peakstr = "of apparent peak";
         peakstr2 = "peak";
      #endif
      fprintf(fpabr, "%% clock      MFLOP  ROUTINE/PROBLEM\n");
      fprintf(fpabr, "=======  =========  ===============\n");

      @iexp ssn 0 0 +
      sprintf(ln, "TUNING PREC=\'%c\' (precision %d of %d)", 
               pre, ip+1, nprec);
      PrintStartStop(stdout, fpsum, 0, 1, 2, ip+1, @(ssn), ln);
      @multidef nu NU NU
      @multidef mu MU MU
      @whiledef tt T N
         @iexp ssn @(ssn) 1 +
      PrintStartStop(stdout, fpsum, 3, 1, 2, ip+1, @(ssn), "GEMV@(tt) TUNE");
      sprintf(fnam, "INSTALL_LOG/%cMV@(tt)K.sum", pre);
      if (!FileExists(fnam))
      {
         sprintf(ln2, "INSTALL_LOG/%cMV@(tt)TUNE.LOG", pre);
         PrintBanner(ln2, 1, 2, ip+1, @(ssn));
         sprintf(ln, "%s %s pre=%c %s %s\n", fmake, fnam, pre, redir, ln2);
         fprintf(stdout, "%s", ln);
         ATL_Cassert(system(ln)==0, "MV@(tt)TUNE", ln2);
         ATL_Cassert(FileIsThere(fnam), "MV@(tt)TUNE", ln2);
         PrintBanner(ln2, 0, 2, ip+1, @(ssn));
      }
      {
         ATL_mvnode_t *kb, *kp;

         kb = ReadMVFile(fnam);
         ATL_Cassert(kb, "MV@(tt)TUNE", NULL);
         ATL_MVSplitContexts(kb, &kb, NULL, NULL, NULL);
         kp = ATL_LastMVNode(kb);
         ATL_mprintf(2, fpsum, stdout,
              "      gemv@(tt) : main kernel %d:%s written by %s\n", kp->ID, 
                     kp->rout?kp->rout : "Generated", 
                     kp->auth?kp->auth : "R. Clint Whaley");
         ATL_mprintf(2, fpsum, stdout,
                     "            mu=%d, nu=%d, using %d Cache Elements\n",
                     kp->@(mu), kp->@(nu), kp->CacheElts);
         mf = Mmax(kp->mflop[0], kp->mflop[1]);
         mf = Mmax(mf, kp->mflop[2]);
         KillAllMVNodes(kb);
         ATL_mprintf(2, fpsum, stdout, 
                     "              Performance = %.2f (%5.2f of %s)\n",
                     mf, (mf / mfp)*100.0, peakstr2);
         fprintf(fpabr, "%7.1f %10.1f  %s\n", (mf/mfp)*100.0, mf, "kgemv@(tt)");
      }
         @undef mu
         @undef nu
      PrintStartStop(stdout, fpsum, 3, 0, 2, ip+1, @(ssn), "GEMV@(tt) TUNE");
      @endwhile
      @iexp ssn @(ssn) 1 +
      PrintStartStop(stdout, fpsum, 3, 1, 2, ip+1, @(ssn), "GER  TUNE");
      sprintf(fnam, "INSTALL_LOG/%cR2K.sum", pre);
      if (!FileExists(fnam))
      {
         sprintf(ln2, "INSTALL_LOG/%cR1TUNE.LOG", pre);
         PrintBanner(ln2, 1, 2, ip+1, 7);
         sprintf(ln, "%s %s pre=%c %s %s\n", fmake, fnam, pre, redir, ln2);
         fprintf(stdout, "%s", ln);
         ATL_Cassert(system(ln)==0, "R1TUNE", ln2);
         ATL_Cassert(FileIsThere(fnam), "R1TUNE", ln2);
         PrintBanner(ln2, 0, 2, ip+1, @(ssn));
      }
      {
         ATL_r1node_t *r1b, *r1B;
         @whiledef rk 2 1
         fnam[14] = '@(rk)';
         r1b = ReadR1File(fnam);
         ATL_Cassert(r1b, "R1TUNE", NULL);
         ATL_R1SplitContexts(r1b, &r1B, NULL, NULL, NULL);
         r1b = r1B;
         r1B = ATL_LastR1Node(r1B);
         ATL_mprintf(2, fpsum, stdout,
              "      ger@(rk) : main kernel %d:%s written by %s\n", r1B->ID, 
                     r1B->rout?r1B->rout : "Generated", 
                     r1B->auth?r1B->auth : "R. Clint Whaley");
         ATL_mprintf(2, fpsum, stdout,
                     "            mu=%d, nu=%d, using %d Cache Elements\n",
                     r1B->MU, r1B->NU, r1B->CacheElts);
         mf = Mmax(r1B->mflop[0], r1B->mflop[1]);
         mf = Mmax(mf, r1B->mflop[2]);
         KillAllR1Nodes(r1b);
         ATL_mprintf(2, fpsum, stdout,
                     "              Performance = %.2f (%5.2f of %s)\n",
                     mf, (mf / mfp)*100.0, peakstr2);
         fprintf(fpabr, "%7.1f %10.1f  %s\n", (mf/mfp)*100.0, mf, "kger@(rk)");
         @endwhile
      }
      PrintStartStop(stdout, fpsum, 3, 0, 2, ip+1, @(ssn), "GER  TUNE");
/*
 *    Detection of CacheEdge currently missing
 */
/*
 *    GEMM install
 */
      @iexp ssn @(ssn) 1 +
      PrintStartStop(stdout, fpsum, 3, 1, 2, ip+1, @(ssn), "GEMM TUNE");
      sprintf(ln2, "INSTALL_LOG/%cAMMTUNE.LOG", pre);
      if (pre == 'd' || pre == 's' || pre == 'q')
         sprintf(ln, "%s AMMinstall pre=%c %s %s\n", fmake, pre, redir, ln2);
      else /* complex */
         sprintf(ln, "%s cAMMinstall pre=%c %s %s\n", fmake, pre, redir, ln2);
      fprintf(stdout, "%s", ln);
      ATL_Cassert(system(ln)==0, "GEMM TUNE", ln2);
      mmb = ReadMMFileWithPath(pre, "INSTALL_LOG", "geAMMRES.sum");
      ATL_Cassert(mmb, "ACCESS-MAJOR MATMUL TUNE", ln2);
      for (mmp=mmb; mmp->next; mmp = mmp->next);
      ATL_mprintf(2, fpsum, stdout, 
         "\n      The best matmul kernel was %s, MB=%d, NB=%d, KB=%d\n",
                     mmp->rout, mmp->mbB, mmp->nbB, mmp->kbB);
      ATL_mprintf(2, fpsum, stdout, "      written %s\n",
                  mmp->auth ? mmp->auth : "G: R. Clint Whaley");
      mf = mmp->mflop[0];
      ATL_mprintf(2, fpsum, stdout,
                  "      Performance: %.2fMFLOPS (%.2f of %s)\n",
                  mf, (mf / mfp)*100.0, peakstr2);
      fprintf(fpabr, "%7.1f %10.1f  %s\n", (mf/mfp)*100.0, mf, "kgemm");
      KillAllMMNodes(mmb);
@beginskip
      else  /* complex types should already be installed during real install */
      {
         sprintf(ln2, "INSTALL_LOG/atlas_%camm_sum.h", pre);
         if (!FileExists(ln2))
         {
            sprintf(ln2, "INSTALL_LOG/%cAMMNBTUNE.LOG", pre);
            sprintf(ln, "%s cAMMinstall pre=%c %s %s\n", fmake, pre, redir,ln2);
            fprintf(stdout, "%s", ln);
            ATL_Cassert(system(ln)==0, "COMPLEX AMM NB REFINEMENT", ln2);
         }
         sprintf(ln, "grep ATL_CAMM_APERF INSTALL_LOG/atlas_%camm_sum.h | "
                 "sed -e \"s/#define //\" -e \"s/ATL_CAMM_APERF //\""
                 ">! INSTALL_LOG/%cGEMM.MFLOP\n", pre, pre);
         mf = 1.0;
         if (system(ln))
         {
            sprintf(ln, "INSTALL_LOG/%cGEMM.MFLOP", pre);
            fp = fopen(ln, "r");
            if (fp)
            {
               if (fscanf(fp, " %le", &mf) != 1)
                  mf = 1.0;
               fclose(fp);
            }
         }
         fprintf(fpabr, "%7.1f %10.1f  %s\n", (mf/mfp)*100.0, mf, "cgemm");
      }
@endskip
      fclose(fpabr);

      fprintf(fpsum, "\n");
      PrintStartStop(stdout, fpsum, 3, 0, 2, ip+1, 1, NULL);
@beginskip
      sprintf(ln, "TUNING PREC=\'%c\' (precision %d of %d)", pre, ip+1, nprec);
      PrintStartStop(stdout, fpsum, 0, 1, 2, ip+1, 0, ln);
      PrintStartStop(stdout, fpsum, 3, 1, 2, ip+1, 1, 
                     "BUILDING BLOCK MATMUL TUNE");
/*
 *    If necessary, install matmul for this type
 */
      sprintf(fnam, "INSTALL_LOG/%cMMRES.sum", pre);
      if (!FileExists(fnam))  /* need to run search or make link */
      {
         sprintf(ln2, "INSTALL_LOG/%cMMSEARCH.LOG", pre);
         PrintBanner(ln2, 1, 2, ip+1, 1);
         if (DefInstall)
         {
            sprintf(ln, "%s IRunMMDef pre=%c nreg=%d %s %s\n", 
                    fmake, pre, NREG, redir, ln2);
            fprintf(stdout, "%s", ln);
            ATL_Cassert(system(ln)==0, "BUILDING BLOCK MATMUL TUNE", ln2);
         }
         sprintf(ln, "%s %s pre=%c %s %s\n", fmake, fnam, pre, redir, ln2);
         fprintf(stdout, "%s", ln);
         ATL_Cassert(system(ln)==0, "BUILDING BLOCK MATMUL TUNE", ln2);
         PrintBanner(ln2, 0, 2, ip+1, 1);
      }
      mmp = ReadMMFileWithPath(pre, "INSTALL_LOG", "MMRES.sum");
      assert(mmp);
      nb = (mmp->next) ? mmp->next->nbB : mmp->nbB;
      #ifdef ATL_CPUMHZ
         fprintf(fpabr, "Clock_rate=%d Mhz\n", ATL_CPUMHZ);
         mfp = ATL_CPUMHZ;
         peakstr = "of detected clock rate";
         peakstr2 = "clock";
      #else
         fprintf(fpabr, "Clock_rate=0 Mhz\n");
         if (pre == 'd' || pre == 'z') mfp = mfpeak[0];
         else mfp = mfpeak[1];
         peakstr = "of apparent peak";
         peakstr2 = "peak";
      #endif
      fprintf(fpabr, "%% clock      MFLOP  ROUTINE/PROBLEM\n");
      fprintf(fpabr, "=======  =========  ===============\n");
      if (mmp->next && mmp->next->mflop[0] > mmp->mflop[0])
      {
         ATL_mprintf(2, fpsum, stdout, 
            "      The best matmul kernel was %s, NB=%d, written by %s\n", 
                    mmp->next->rout, nb, 
                    mmp->next->auth ? mmp->next->auth : "R. Clint Whaley");
         ATL_mprintf(2, fpsum, stdout, 
            "      Performance: %.2fMFLOPS (%5.2f percent of %s)\n",
                     mmp->next->mflop[0], (mmp->next->mflop[0]/mfp)*100.0, 
                     peakstr);
         ATL_mprintf(2, fpsum, stdout, 
                     "        (Gen case got %.2fMFLOPS)\n", mmp->mflop[0]);
         mmmf = mmp->next->mflop[0];
      }
      else
      {
         mmmf = mmp->mflop[0];
         ATL_mprintf(2, fpsum, stdout, 
"      %cL1MATMUL: lat=%d, nb=%d, pf=%d, mu=%d, nu=%d, ku=%d, if=%d, nf=%d;\n",
                 pre, mmp->lat, nb, mmp->pref, mmp->mu, mmp->nu, mmp->ku, 
                 mmp->iftch, mmp->nftch);
         ATL_mprintf(2, fpsum, stdout, 
            "                 Performance: %.2f (%5.2f percent of %s)\n",
                     mmmf, (mmmf/mfp)*100.0, peakstr);
      }
      fprintf(fpabr, "%7.1f %10.1f  %s\n", (mmmf/mfp)*100.0, mmmf,
              "Chosen kgemm");
      fprintf(fpabr, "%7.1f %10.1f  %s\n", (mmp->mflop[0]/mfp)*100.0, 
              mmp->mflop[0], "Generated kgemm");
      KillAllMMNodes(mmp);

      sprintf(fnam, "INSTALL_LOG/%cNCNB", pre);
      if (!FileExists(fnam))
      {
         sprintf(ln, "%s %s pre=%c %s %s", fmake, fnam, pre, redir, ln2);
         fprintf(stdout, "%s", ln);
         ATL_Cassert(system(ln)==0, "BUILDING BLOCK MATMUL TUNE", ln2);
      }
      fp = fopen(fnam, "r");
      ATL_Cassert(fp, "OPENING NCNB", NULL);
      ATL_Cassert(fscanf(fp, " %d", &ncnb) == 1, "READING NCNB", NULL);
      fclose(fp);

      for (ia=0; ia < 2; ia++)
      {
         for (ib=0; ib < 2; ib++)
         {
            sprintf(fnam, "INSTALL_LOG/%cbest%c%c_%dx%dx%d", pre, TR[ia], TR[ib],
                    ncnb, ncnb, ncnb);
            if (!FileExists(fnam))
            {
               sprintf(ln, "%s %s pre=%c nb=%d %s %s", 
                       fmake, fnam, pre, ncnb, redir, ln2);
               fprintf(stdout, "%s", ln);
               ATL_Cassert(system(ln)==0, "BUILDING BLOCK MATMUL TUNE", ln2);
            }
            GetInstLogFile(fnam, pre, &muladd, &pf, &lat, &nb, &mu, &nu, &ku,
                           &ffetch, &ifetch, &nfetch, &mf);
            fprintf(stdout,
   "      NCgemm%c%c : muladd=%d, lat=%d, pf=%d, nb=%d, mu=%d, nu=%d ku=%d,\n",
                    TR[ia], TR[ib], muladd, lat, pf, nb, mu, nu, ku);
            fprintf(stdout,"                 ForceFetch=%d, ifetch=%d nfetch=%d\n",
                    ffetch, ifetch, nfetch);
            fprintf(stdout,
"                 Performance = %.2f (%5.2f of copy matmul, %5.2f of %s)\n",
                    mf, (mf/mmmf)*100.0, (mf / mfp)*100.0, peakstr2);
            fprintf(fpsum,
"      mm%c%c   : ma=%d, lat=%d, nb=%d, mu=%d, nu=%d ku=%d, ff=%d, if=%d, nf=%d\n",
                    TR[ia], TR[ib], muladd, lat, nb, mu, nu, ku, 
                    ffetch, ifetch, nfetch);
            fprintf(fpsum,
"               Performance = %.2f (%5.2f of copy matmul, %5.2f of %s)\n",
                    mf, (mf/mmmf)*100.0, (mf / mfp)*100.0, peakstr2);
            if (ia != ib)
               fprintf(fpabr, "%7.1f %10.1f  kgemm%c%c\n", (mf/mfp)*100.0, mf, 
                       TR[ia], TR[ib]);
         }
      }

      sprintf(ln, "%s MMinstall pre=%c %s %s\n", fmake, pre, redir, ln2);
      fprintf(stdout, "%s", ln);
      ATL_Cassert(system(ln)==0, "BUILDING BLOCK MATMUL TUNE", ln2);

      if (pre == 'd' || pre == 's')
      {

         sprintf(ln, "%s AMMinstall pre=%c %s %s\n", fmake, pre, redir, ln2);
         fprintf(stdout, "%s", ln);
         ATL_Cassert(system(ln)==0, "BUILDING BLOCK AMM TUNE", ln2);
         mmb = ReadMMFileWithPath(pre, "INSTALL_LOG", "geAMMRES.sum");
         ATL_Cassert(mmb, "ACCESS-MAJOR MATMUL TUNE", ln2);
         if (mmb)
         {
            for (mmp=mmb; mmp->next; mmp = mmp->next);
            ATL_mprintf(2, fpsum, stdout, 
    "\n      The best access-major matmul kernel was %s, MB=%d, NB=%d, KB=%d\n",
                        mmp->rout, mmp->mbB, mmp->nbB, mmp->kbB);
            ATL_mprintf(2, fpsum, stdout, "      written %s\n",
                        mmp->auth ? mmp->auth : "R. Clint Whaley");
            mf = mmp->mflop[0];
            ATL_mprintf(2, fpsum, stdout,
               "      Performance: %.2fMFLOPS (%.2f of block-major MM)\n",
                        mf, (mf/mmmf)*100.0);
            if (mf > mmmf)
            {
               sprintf(ln, "%s AMM_use pre=%c", fmake, pre);
               ATL_Cassert(system(ln)==0, "BUILDING BLOCK AMM TUNE", ln2);
            }
            else
            {
               sprintf(ln, "%s AMM_disable pre=%c", fmake, pre);
               ATL_Cassert(system(ln)==0, "BUILDING BLOCK AMM TUNE", ln2);
            }
            KillAllMMNodes(mmb);
         }
         else
         {
            ATL_mprintf(2, fpsum, stdout, 
                        "\n      Access-major matmul install FAILED!\n\n");
            sprintf(ln, "%s AMM_disable pre=%c", fmake, pre);
            ATL_Cassert(system(ln)==0, "BUILDING BLOCK AMM TUNE", ln2);
         }
      }

      fprintf(fpsum, "\n");
      PrintStartStop(stdout, fpsum, 3, 0, 2, ip+1, 1, NULL);
/*
 *    If necessary, find cacheedge
 */
      PrintStartStop(stdout, fpsum, 3, 1, 2, ip+1, 2, "CacheEdge DETECTION");
@skip      ATL_mprintf(2, fpsum, stdout,
@skip                 "\n\n   STAGE 2-%d-2: CacheEdge DETECTION\n", ip+1);
      sprintf(ln2, "INSTALL_LOG/%cMMCACHEEDGE.LOG", pre);
      if (!FileExists("INSTALL_LOG/atlas_cacheedge.h")) 
      {
         PrintBanner(ln2, 1, 2, ip+1, 2);
         sprintf(ln, "%s INSTALL_LOG/atlas_cacheedge.h pre=%c %s %s\n",
                 fmake, pre, redir, ln2);
         fprintf(stdout, "%s", ln);
         ATL_Cassert(system(ln)==0, "CACHEEDGE DETECTION", ln2);
         PrintBanner(ln2, 0, 2, ip+1, 2);
      }
      fp = fopen("INSTALL_LOG/atlas_cacheedge.h", "r");
      ATL_Cassert(fp, "CACHE EDGE DETECTION", NULL);
      ATL_Cassert(fgets(ln, 256, fp), "CACHE EDGE DETECTION", NULL);
      ATL_Cassert(fgets(ln, 256, fp), "CACHE EDGE DETECTION", NULL);
      ATL_Cassert(fgets(ln, 256, fp), "CACHE EDGE DETECTION", NULL);
      if (fgets(ln3, 256, fp))
      {
         ATL_Cassert(sscanf(ln+21, " %d", &i)==1, "CACHE EDGE DETECTION", NULL);
      }
      else i = 0;
      fprintf(fpsum, "      CacheEdge set to %d bytes\n", i);
      fclose(fp);
/*
 *    Determine [ZD,CS]NKB, if necessary
 */
      if (pre == 'z' || pre == 'c')
      {
         sprintf(ln3, "INSTALL_LOG/atlas_%c%cNKB.h", pre, upre);
         if (!FileExists(ln3)) 
         {
            sprintf(ln, "%s %s pre=%c %s %s\n",
                    fmake, ln3, pre, redir, ln2);
            fprintf(stdout, "%s", ln);
            ATL_Cassert(system(ln)==0, "CACHEEDGE DETECTION", ln2);
         }
         fp = fopen(ln3, "r");
         ATL_Cassert(fp, "CACHE EDGE DETECTION", NULL);
         ATL_Cassert(fgets(ln, 256, fp), "CACHE EDGE DETECTION", NULL);
         ATL_Cassert(fgets(ln, 256, fp), "CACHE EDGE DETECTION", NULL);
         ATL_Cassert(fgets(ln, 256, fp), "CACHE EDGE DETECTION", NULL);
         if (fgets(ln3, 256, fp))
         {
            ATL_Cassert(sscanf(ln+21, " %d", &i)==1, 
                               "CACHE EDGE DETECTION", NULL);
         }
         else i = 0;
         fprintf(fpsum, "      %c%cNKB set to %d bytes\n", pre, upre, i);
         fclose(fp);
      }
      PrintStartStop(stdout, fpsum, 3, 0, 2, ip+1, 2, NULL);
/*
 *    If necessary, determine Xover for this data type
 */
      PrintStartStop(stdout, fpsum, 3, 1, 2, ip+1, 3, "SMALL/LARGE CROSSOVER");
@beginskip
      ATL_mprintf(2, fpsum, stdout,
                 "\n\n   STAGE 2-%d-3: LARGE/SMALL CASE CROSSOVER DETECTION\n",
                 ip+1);
@endskip
      sprintf(fnam, "INSTALL_LOG/%cXover.h", pre);
      if (!FileExists(fnam))  /* need to run Xover tests */
      {
         sprintf(ln2, "INSTALL_LOG/%cMMCROSSOVER.LOG", pre);
         PrintBanner(ln2, 1, 2, ip+1, 3);
            fprintf(stdout,
              "\n\n   STAGE 2-%d-3: COPY/NO-COPY CROSSOVER DETECTION\n", ip+1);
         fprintf(fpsum,
              "\n\n   STAGE 2-%d-3: COPY/NO-COPY CROSSOVER DETECTION\n", ip+1);

         sprintf(ln, "%s %s pre=%c %s %s\n", fmake, fnam, pre, redir, ln2);
         fprintf(stdout, "%s", ln);
         ATL_Cassert(system(ln)==0, "COPY/NO-COPY CROSSOVER DETECTION", ln2);
         PrintBanner(ln2, 0, 2, ip+1, 3);
         fprintf(stdout, "      done.\n");
         fprintf(fpsum , "      done.\n");
      }
      PrintStartStop(stdout, fpsum, 3, 0, 2, ip+1, 3, NULL);
@endskip

      sprintf(ln2, "INSTALL_LOG/%cL3TUNE.LOG", pre);
      PrintBanner(ln2, 1, 2, ip+1, 5);
      PrintStartStop(stdout, fpsum, 3, 1, 2, ip+1, 4, "L3BLAS TUNE");
      if (pre == 's' || pre == 'd')
      {
         sprintf(ln, "%s INSTALL_LOG/atlas_%ctrsmXover.h pre=%c %s %s\n", 
                 fmake, pre, pre, redir, ln2);
         fprintf(stdout, "%s", ln);
         ATL_Cassert(system(ln)==0, "L3BLAS TUNING", ln2);
      }
      else
      {
         sprintf(ln, "%s Il3lib pre=%c %s %s\n", fmake, pre, redir, ln2);
         fprintf(stdout, "%s", ln);
         ATL_Cassert(system(ln)==0, "L3BLAS TUNING", ln2);
      }
      sprintf(ln, "%s %ccblaslib %s %s\n", fmake, pre, redir, ln2); /* cblas */
      fprintf(stdout, "%s", ln);
      ATL_Cassert(system(ln)==0, "L3BLAS TUNING", ln2);
      PrintBanner(ln2, 0, 2, ip+1, 5);
      PrintStartStop(stdout, fpsum, 3, 0, 2, ip+1, 4, "L3BLAS TUNE");

@beginskip
      fprintf(stdout,"\n\n   STAGE 2-%d-6: SYSINFO PROBE\n", ip+1);
      fprintf(fpsum, "\n\n   STAGE 2-%d-6: SYSINFO PROBE\n", ip+1);
      sprintf(fnam, "INSTALL_LOG/atlas_%csysinfo.h", pre);
      if (!FileExists(fnam))
      {
         sprintf(ln2, "INSTALL_LOG/%cSYSINFO.LOG", pre);
         PrintBanner(ln2, 1, 2, ip+1, 6);
         sprintf(ln, "%s %s pre=%c %s %s\n", fmake, fnam, pre, redir, ln2);
         fprintf(stdout, "%s", ln);
         ATL_Cassert(system(ln)==0, "SYSINFO PROBE", ln2);
         ATL_Cassert(FileIsThere(fnam), "SYSINFO PROBE", ln2);
         PrintBanner(ln2, 0, 2, ip+1, 6);
      }
      fprintf(stdout, "      done.\n");
      fprintf(fpsum , "      done.\n");

      PrintStartStop(stdout, fpsum, 3, 1, 2, ip+1, 5, "GEMV TUNE");
      @multidef nu NU NU
      @multidef mu MU MU
      @whiledef tt T N
      sprintf(fnam, "INSTALL_LOG/%cMV@(tt)K.sum", pre);
      if (!FileExists(fnam))
      {
         sprintf(ln2, "INSTALL_LOG/%cMV@(tt)TUNE.LOG", pre);
         PrintBanner(ln2, 1, 2, ip+1, 7);
         sprintf(ln, "%s %s pre=%c %s %s\n", fmake, fnam, pre, redir, ln2);
         fprintf(stdout, "%s", ln);
         ATL_Cassert(system(ln)==0, "MV@(tt)TUNE", ln2);
         ATL_Cassert(FileIsThere(fnam), "MV@(tt)TUNE", ln2);
         PrintBanner(ln2, 0, 2, ip+1, 7);
      }
      {
         ATL_mvnode_t *kb, *kp;

         kb = ReadMVFile(fnam);
         ATL_Cassert(kb, "MV@(tt)TUNE", NULL);
         ATL_MVSplitContexts(kb, &kb, NULL, NULL, NULL);
         kp = ATL_LastMVNode(kb);
         ATL_mprintf(2, fpsum, stdout,
              "      gemv@(tt) : main kernel %d:%s written by %s\n", kp->ID, 
                     kp->rout?kp->rout : "Generated", 
                     kp->auth?kp->auth : "R. Clint Whaley");
         ATL_mprintf(2, fpsum, stdout,
                     "            mu=%d, nu=%d, using %d Cache Elements\n",
                     kp->@(mu), kp->@(nu), kp->CacheElts);
         mf = Mmax(kp->mflop[0], kp->mflop[1]);
         mf = Mmax(mf, kp->mflop[2]);
         KillAllMVNodes(kb);
         ATL_mprintf(2, fpsum, stdout,
"              Performance = %.2f (%5.2f of copy matmul, %5.2f of %s)\n",
                 mf, (mf/mmmf)*100.0, (mf / mfp)*100.0, peakstr2);
         fprintf(fpabr, "%7.1f %10.1f  %s\n", (mf/mfp)*100.0, mf, "kgemv@(tt)");
      }
         @undef mu
         @undef nu
      @endwhile
      PrintStartStop(stdout, fpsum, 3, 0, 2, ip+1, 5, "GEMV TUNE");
      PrintStartStop(stdout, fpsum, 3, 1, 2, ip+1, 6, "GER TUNE");
@skip      ATL_mprintf(2, fpsum, stdout,"\n\n   STAGE 2-%d-6: GER TUNE\n", ip+1);
      sprintf(fnam, "INSTALL_LOG/%cR2K.sum", pre);
      if (!FileExists(fnam))
      {
         sprintf(ln2, "INSTALL_LOG/%cR1TUNE.LOG", pre);
         PrintBanner(ln2, 1, 2, ip+1, 7);
         sprintf(ln, "%s %s pre=%c %s %s\n", fmake, fnam, pre, redir, ln2);
         fprintf(stdout, "%s", ln);
         ATL_Cassert(system(ln)==0, "R1TUNE", ln2);
         ATL_Cassert(FileIsThere(fnam), "R1TUNE", ln2);
         PrintBanner(ln2, 0, 2, ip+1, 7);
         fnam[14] = '1';
      }
      {
         ATL_r1node_t *r1b, *r1B;
         r1b = ReadR1File(fnam);
         ATL_Cassert(r1b, "R1TUNE", NULL);
         ATL_R1SplitContexts(r1b, &r1B, NULL, NULL, NULL);
         r1b = r1B;
         r1B = ATL_LastR1Node(r1B);
         ATL_mprintf(2, fpsum, stdout,
              "      ger : main kernel %d:%s written by %s\n", r1B->ID, 
                     r1B->rout?r1B->rout : "Generated", 
                     r1B->auth?r1B->auth : "R. Clint Whaley");
         ATL_mprintf(2, fpsum, stdout,
                     "            mu=%d, nu=%d, using %d Cache Elements\n",
                     r1B->MU, r1B->NU, r1B->CacheElts);
         mf = Mmax(r1B->mflop[0], r1B->mflop[1]);
         mf = Mmax(mf, r1B->mflop[2]);
         KillAllR1Nodes(r1b);
         ATL_mprintf(2, fpsum, stdout,
"              Performance = %.2f (%5.2f of copy matmul, %5.2f of %s)\n",
                 mf, (mf/mmmf)*100.0, (mf / mfp)*100.0, peakstr2);
         fprintf(fpabr, "%7.1f %10.1f  %s\n", (mf/mfp)*100.0, mf, "kger");
         fclose(fpabr);
      }
      PrintStartStop(stdout, fpsum, 3, 0, 2, ip+1, 6, "GER TUNE");
      PrintStartStop(stdout, fpsum, 0, 0, 2, 0, 0, "TYPE-DEPENDENT TUNING");
@endskip
   }
   PrintStartStop(stdout, fpsum, 0, 0, 2, 0, 0, "TYPE-DEPENDENT TUNING");
   PrintStartStop(stdout, fpsum, 0, 1, 3, 0, 0, "GENERAL LIBRARY BUILD");
@skip   ATL_mprintf(2, fpsum, stdout,"\n\nSTAGE 3: GENERAL LIBRARY BUILD\n");

   sprintf(ln2, "INSTALL_LOG/LIBBUILD.LOG");
   PrintBanner(ln2, 1, 3, 1, 1);
   sprintf(ln, "%s IBuildLibs %s %s\n", fmake, redir, ln2);
   fprintf(stdout, "%s", ln);
   ATL_Cassert(system(ln)==0, "LIBRARY BUILD", ln2);
   ATL_Cassert(FileIsThere(fnam), "LIBRARY BUILD", ln2);
   PrintBanner(ln2, 0, 3, 1, 1);
   PrintStartStop(stdout, fpsum, 0, 0, 3, 0, 0, "GENERAL LIBRARY BUILD");

   for (ip=2; ip < 4; ip++)
   {
      char pre=prec[ip];
      PrintStartStop(stdout, fpsum, 3, 1, 3, ip-1, 2, 
                     "COMPLEX AMM NB REFINEMENT");
      sprintf(ln2, "INSTALL_LOG/atlas_%camm_sum.h", pre);
      if (!FileExists(ln2))
      {
         sprintf(ln2, "INSTALL_LOG/%cAMMNBTUNE.LOG", pre);
         PrintBanner(ln2, 1, 3, ip-1, 2);
         sprintf(ln, "%s cAMMinstall pre=%c %s %s\n", fmake, pre, redir, ln2);
         fprintf(stdout, "%s", ln);
         ATL_Cassert(system(ln)==0, "COMPLEX AMM NB REFINEMENT", ln2);
         PrintBanner(ln2, 0, 3, ip-1, 2);
      }
   }
   PrintStartStop(stdout, fpsum, 0, 1, 4, 0, 0, "POST-BUILD TUNING");
@skip   ATL_mprintf(2, fpsum, stdout,"\n\nSTAGE 4: POST-BUILD TUNING\n");
   sprintf(ln2, "INSTALL_LOG/POSTTUNE.LOG");
   PrintBanner(ln2, 1, 4, 1, 1);
   PrintStartStop(stdout, fpsum, 3, 1, 4, 1, 1, "TRSM TUNE");
@skip   ATL_mprintf(2, stdout, fpsum, "\n\nSTAGE 4-1: TRSM tune\n");
   sprintf(ln, "%s IPostTune %s %s\n", fmake, redir, ln2);
   fprintf(stdout, "%s", ln);
   ATL_Cassert(system(ln)==0, "POST-BUILD TUNE", ln2);
   PrintStartStop(stdout, fpsum, 3, 0, 4, 1, 0, NULL);
@skip   fprintf(stdout, "   done.\n");
@skip   fprintf(fpsum,  "   done.\n");
   ATL_Cassert(FileIsThere(fnam), "POST-BUILD TUNE", ln2);
   PrintBanner(ln2, 0, 4, 1, 1);

#ifdef ATL_NCPU
   PrintStartStop(stdout, fpsum, 3, 1, 4, 2, 0, "THREADING TUNE");
   sprintf(ln2, "INSTALL_LOG/PTTUNE.LOG");
   PrintBanner(ln2, 1, 4, 2, 0);
   sprintf(ln, "%s IPTtune %s %s\n", fmake, redir, ln2);
   fprintf(stdout, "%s", ln);
   ATL_Cassert(system(ln)==0, "THREADING TUNE", ln2);
   PrintStartStop(stdout, fpsum, 3, 0, 4, 2, 0, "THREADING TUNE");

   PrintStartStop(stdout, fpsum, 3, 1, 4, 2, 1, "THREADING BUILD");
   sprintf(ln2, "INSTALL_LOG/LIBPTBUILD.LOG");
   PrintBanner(ln2, 1, 4, 2, 1);
   sprintf(ln, "%s IBuildPtlibs %s %s\n", fmake, redir, ln2);
   fprintf(stdout, "%s", ln);
   ATL_Cassert(system(ln)==0, "PTLIBRARY BUILD", ln2);
   PrintBanner(ln2, 0, 4, 2, 1);
@skip   fprintf(stdout, "   done.\n");
@skip   fprintf(fpsum,  "   done.\n");
   PrintStartStop(stdout, fpsum, 3, 0, 4, 2, 1, "THREADING BUILD");
#endif
   if (TuneLA)
   {
      PrintStartStop(stdout, fpsum, 3, 1, 4, 3, 0, "LAPACK TUNING");
@skip      ATL_mprintf(2, stdout, fpsum, "\n\nSTAGE 4-3: LAPACK TUNING\n");
      for (ip=0; ip < nprec; ip++)
      {
         pre = prec[ip];
         sprintf(ln2, "%cLAPACK TUNING", pre);
         PrintStartStop(stdout, fpsum, 6, 1, 4, 3, ip+1, ln2);
@beginskip
         mmp = ReadMMFileWithPath(pre, "INSTALL_LOG", "MMRES.sum");
         assert(mmp);
/*
 *       Have best of generated & external searches, keep only best
 */
         if (mmp->next)
         {
            if (mmp->mflop[0] >= mmp->next->mflop[0])
               mmp->next = KillMMNode(mmp->next);
            else
               mmp = KillMMNode(mmp);
         }
         nb = mmp->nbB;
         mu = mmp->mu;
         nu = mmp->nu;
         KillAllMMNodes(mmp);
@beginskip
         GetMMRES(pre, &muladd, &lat, &nb, &pfA, &mu, &nu, &ku, &ffetch, 
                  &ifetch, &nfetch, &mf, &idU, fnam, ln, &mfU);
         if (mfU > mf)  /* if mu,nu need to be from user kernel */
            GetuMMRES(pre, idU, &maU, &latU, &mu, &nu, &kuU);
@endskip
         mu = ATL_lcm(mu, nu);  /* mu now LCM(mu,nu); use as INC on NB */
/*
 *       ==========================================================
 *       Figure out NBs for lanbtst to try; at end of this section:
 *          ku has number of NBs  & ln3 has NBs to try
 *       ==========================================================
 */
/*       
 *       For small mu, can just inc by small multiple of mu in search
 */
         if (mu <= 8)
         {
            ku = 1;
            j = sprintf(ln3, "1 ");
            nu = (mu < 4) ? (mu+mu) : mu;
         }
/*
 *       For large increment, need to scan by fraction of mu in initial inc
 */
         else
         {
            j = sprintf(ln3, "1 4 8 12 16 %d ", mu);
            ku = 6;
            nu = (mu > 12 && ((mu>>1)<<1)==mu) ? (mu>>1) : mu;
         }
         for (i=nu; i <= 256; i += nu, ku++)
         {

            j += sprintf(ln3+j, "%d ", i);
/*
 *          For large NB, see if should pump up gap for quicker search
 */
            if (i > 64 && nu < 8)
               nu += nu;
            else if (i > 128 && nu < 12)
               nu += nu;
         }
@endskip
         sprintf(ln2, "INSTALL_LOG/%cLATUNE.LOG", pre);
         PrintBanner(ln2, 1, 4, 3, ip+1);
@skip         sprintf(ln, "%s ILATune pre=%c NBs=\"%d %s\" %s %s\n", fmake, pre, 
@skip                 ku, ln3, redir, ln2);
         fprintf(stdout, "%s", ln);
         sprintf(ln, "%s ILATune pre=%c %s %s\n", fmake, pre, redir, ln2);
         ATL_Cassert(system(ln)==0, "LAPACK TUNE", ln2);
         PrintStartStop(stdout, fpsum, 6, 0, 4, 3, ip+1, NULL);
         PrintBanner(ln2, 0, 4, 3, ip+1);
      }
      PrintStartStop(stdout, fpsum, 3, 0, 4, 3, 0, "LAPACK TUNING");
@skip      fprintf(stdout, "   done.\n");
@skip      fprintf(fpsum,  "   done.\n");
   }
   PrintStartStop(stdout, fpsum, 0, 0, 4, 0, 0, "POST-BUILD TUNING");
   PrintStartStop(stdout, fpsum, 0, 1, 5, 0, 0, "FINAL LIBRARY UPDATE");
   PrintStartStop(stdout, fpsum, 3, 1, 5, 1, 0, "FINAL STATIC LIBRARY UPDATE");
@skip   ATL_mprintf(2, fpsum, stdout,"\n\nSTAGE 5: FINAL LIBRARY UPDATE\n");
@skip   ATL_mprintf(2, stdout, fpsum, 
@skip               "\n\nSTAGE 5-1: FINAL STATIC LIBRARY UPDATE\n");
   sprintf(ln2, "INSTALL_LOG/LIBUPDATE.LOG");
   PrintBanner(ln2, 1, 5, 1, 1);
   #if defined(ATL_NCPU) && ATL_NCPU > 1
      sprintf(ln, "%s IBuildLibs IBuildPtlibs0 %s %s\n", fmake, redir, ln2);
   #else
      sprintf(ln, "%s IBuildLibs %s %s\n", fmake, redir, ln2);
   #endif
   fprintf(stdout, "%s", ln);
   ATL_Cassert(system(ln)==0, "STATIC LIBRARY UPDATE", ln2);
   PrintBanner(ln2, 0, 5, 1, 1);
   PrintStartStop(stdout, fpsum, 3, 0, 5, 1, 0, "FINAL STATIC LIBRARY UPDATE");
@skip   fprintf(stdout, "   done.\n");
@skip   fprintf(fpsum,  "   done.\n");
#ifdef ATL_DYLIBS
   PrintStartStop(stdout, fpsum, 3, 1, 5, 2, 0, 
                  "DYNAMIC/SHARED LIBRARY UPDATE");
@skip   ATL_mprintf(2, stdout, fpsum, 
@skip               "\n\nSTAGE 5-2: Dynamic/shared library build\n");
   sprintf(ln2, "INSTALL_LOG/LIBDYBUILD.LOG");
   PrintBanner(ln2, 1, 5, 2, 1);
   sprintf(ln, "%s IBuildDyLibs %s %s\n", fmake, redir, ln2);
   fprintf(stdout, "%s", ln);
   ATL_Cassert(system(ln)==0, "DYLIBRARY BUILD", ln2);
   PrintBanner(ln2, 0, 5, 2, 1);
   PrintStartStop(stdout, fpsum, 3, 0, 5, 2, 0, NULL);
@skip   fprintf(stdout, "   done.\n");
@skip   fprintf(fpsum,  "   done.\n");
#endif

   fprintf(stdout, "\n\n\n\n");
   fprintf(stdout, "ATLAS install complete.  Examine \n");
   fprintf(stdout, "ATLAS/bin/<arch>/INSTALL_LOG/SUMMARY.LOG for details.\n");
@skip   fprintf(fpsum, "\n\nATLAS INSTALL COMPLETE.\n");
   fclose(fpsum);
   PrintBanner("INSTALL_LOG/SUMMARY.LOG", 0, 0, 0, 0);
}

void PrintUsage(char *nam)
{
   fprintf(stderr, "\n\nUSAGE: %s [-a <#(use archdef)> -1 <#(bozoL1)>]\n\n", 
           nam);
   exit(-1);
}

void GetFlags(int nargs, char *args[], int *ARCHDEF, int *L1DEF, int *TuneLA,
              int *NREG)
{
   int i;

   *NREG = *TuneLA = *L1DEF = 0;
   *ARCHDEF = 1;
   for (i=1; i < nargs; i++)
   {
      if (args[i][0] != '-') PrintUsage(args[0]);
      switch(args[i][1])
      {
      case 'a':
         if (++i > nargs)
            PrintUsage(args[0]);
         *ARCHDEF = atoi(args[i]);
         break;
      case 'r':
         if (++i > nargs)
            PrintUsage(args[0]);
         *NREG = atoi(args[i]);
         break;
      case 'l':
         if (++i > nargs)
            PrintUsage(args[0]);
         *TuneLA = atoi(args[i]);
         break;
      case '1':
         if (++i > nargs)
            PrintUsage(args[0]);
         *L1DEF = atoi(args[i]);
         break;
      default: 
         PrintUsage(args[0]);
      }
   }
}

int main(int nargs, char *args[])
{
   int L1DEF, ARCHDEF, TuneLA, NREG;
   GetFlags(nargs, args, &ARCHDEF, &L1DEF, &TuneLA, &NREG);
   GoToTown(ARCHDEF, L1DEF, TuneLA, NREG);
   return(0);
}
@ROUT fname
      program namtst
      external c_routine

      call c_routine()

      stop
      end
@ROUT cname
#include <stdio.h>
void c_routine_(void)  { printf("-DAdd_\n"); }
void c_routine(void)   { printf("-DNoChange\n"); }
void C_ROUTINE(void)  { printf("-DUpCase\n"); }
void c_routine__(void) { printf("-DAdd__\n"); }
@rout ff2cint
       program ff2cint
       integer iarr(8)
       iarr(1) = 1
       iarr(2) = -1
       iarr(3) = -1
       iarr(4) = -1
       iarr(5) = -1
       iarr(6) = -1
       iarr(7) = -1
       iarr(8) = -1
       call c2fint(iarr)
       stop
       end
@rout cf2cint
#if defined(Add_) || defined(Add__)
   #define c2fint c2fint_
#elif defined(UpCase)
   #define c2fint C2FINT
#endif
void c2fint(void *vp)
{
   int *ip=vp;
   long *lp=vp;
   short *sp=vp;

   if ( (sizeof(long) != sizeof(int)) && (*lp == 1) )
      printf("F77 INTEGER -> C long\n");
   else if (*ip == 1) printf("F77 INTEGER -> C int\n");
   else if (*sp == 1) printf("F77 INTEGER -> C short\n");
}
@rout ff2cstr
      program chartst
      external crout

      call crout('123', -1, '12345', -2)

      stop
      end
@rout cf2cstr
#if defined(Add_) || defined(Add__)
   #define crout crout_
#elif defined(UpCase)
   #define crout CROUT
#endif
#ifdef SunStyle

void crout(char *str1, F77_INTEGER *n1, char *str2, F77_INTEGER *n2, 
           F77_INTEGER three, F77_INTEGER five)
{
@skip   printf("n1=%d, n2=%d, 3=%d, 5=%d\n", *n1, *n2, three, five);
@skip   printf("str1=%c%c%c, str2=%c%c%c%c%c\n", str1[0], str1[1], str1[2],
@skip          str2[0], str2[1], str2[2], str2[3], str2[4]);
   if ( (*n1 != -1) || (*n2 != -2) || (three != 3) || (five != 5) ) exit(-1);
   if (str1[0] != '1' || str1[1] != '2' || str1[2] != '3') exit(-1);
   if (str2[0] != '1' || str2[1] != '2' || str2[2] != '3' ||
       str2[3] != '4' || str2[4] != '5') exit(-1);
   printf("-DSunStyle\n");
}

#elif defined(CrayStyle)

#include <fortran.h>
void crout(_fcd str1, F77_INTEGER *n1, _fcd str2, F77_INTEGER *n2)
{
   if ( (*n1 != -1) || (*n2 != -2) ) exit(-1);
   if (*(_fcdtocp(str1)) != '1' || *(_fcdtocp(str2)) != '1' ) exit(-1);
   printf("-DCrayStyle\n");
}

#elif defined(StructVal)

typedef struct {char *cp; F77_INTEGER len;} F77_CHAR;
void crout(F77_CHAR str1, F77_INTEGER *n1, F77_CHAR str2, F77_INTEGER *n2)
{
   if ( (*n1 != -1) || (*n2 != -2) || (str1.len != 3) || (str2.len != 5) )
      exit(-1);
   if (str1.cp[0] != '1' || str1.cp[1] != '2' || str1.cp[2] != '3') exit(-1);
   if (str2.cp[0] != '1' || str2.cp[1] != '2' || str2.cp[2] != '3' ||
       str2.cp[3] != '4' || str2.cp[4] != '5') exit(-1);
   printf("-DStringStructVal\n");
}
#elif defined(StructPtr)
typedef struct {char *cp; F77_INTEGER len;} *F77_CHAR;
void crout(F77_CHAR str1, F77_INTEGER *n1, F77_CHAR str2, F77_INTEGER *n2)
{
   if ( (*n1 != -1) || (*n2 != -2) || (str1->len != 3) || (str2->len != 5) )
      exit(-1);
   if (str1->cp[0] != '1' || str1->cp[1] != '2' || str1->cp[2] != '3') exit(-1);
   if (str2->cp[0] != '1' || str2->cp[1] != '2' || str2->cp[2] != '3' ||
       str2->cp[3] != '4' || str2->cp[4] != '5') exit(-1);
   printf("-DStringStructPtr\n");
}
#endif
@ROUT ATL_NCmmJIK ATL_NCmmJIK_c
   @define lo @JIK@
@ROUT ATL_NCmmIJK ATL_NCmmIJK_c
   @define lo @IJK@
@ROUT ATL_NCmmJIK ATL_NCmmIJK ATL_NCmmJIK_c ATL_NCmmIJK_c
@extract -b @(topd)/gen.inc what=cw @(cw99)
#include "atlas_misc.h"
#include Mstr(Mjoin(Mjoin(atlas_,PRE),NCmm.h))
#include "atlas_lvl3.h"

#ifndef MB
   #define MB NB
#endif
#ifndef KB
   #define KB NB
#endif
#define NBnam Mjoin(Mjoin(Mjoin(Mjoin(MB,x),NB),x),KB)
#define NCmm0 Mjoin(Mjoin(PATL,JIK),NBnam)
#define NCmm00 Mjoin(PATL,JIK)
@whiledef TA T N
   @whiledef TB T N
      @whiledef bet 0 1
void Mjoin(Mjoin(Mjoin(NCmm0,@(TA)@(TB)),0x0x0),_a1_b@(bet))
   (const int M, const int N, const int K, const SCALAR alpha, const TYPE *A, 
    const int lda, const TYPE *B, const int ldb, 
    const SCALAR beta, TYPE *C, const int ldc);
      @endwhile
@ROUT ATL_NCmmJIK ATL_NCmmIJK
      @multidef alp 1 X X
      @whiledef bet X 0 X
void Mjoin(Mjoin(Mjoin(NCmm0,@(TA)@(TB)),0x0x0),_a@(alp)_b@(bet))
   (const int M, const int N, const int K, const SCALAR alpha, const TYPE *A, 
    const int lda, const TYPE *B, const int ldb, 
    const SCALAR beta, TYPE *C, const int ldc);
         @undef alp
      @endwhile
@ROUT ATL_NCmmJIK ATL_NCmmIJK ATL_NCmmJIK_c ATL_NCmmIJK_c
void Mjoin(Mjoin(Mjoin(NCmm00,Mjoin(0x0x,KB)),@(TA)@(TB)),0x0x0_aX_bX)
   (const int M, const int N, const int K, const SCALAR alpha, const TYPE *A, 
    const int lda, const TYPE *B, const int ldb, 
    const SCALAR beta, TYPE *C, const int ldc);
void Mjoin(Mjoin(Mjoin(NCmm00,0x0x0),@(TA)@(TB)),0x0x0_aX_bX)
   (const int M, const int N, const int K, const SCALAR alpha, const TYPE *A, 
    const int lda, const TYPE *B, const int ldb, 
    const SCALAR beta, TYPE *C, const int ldc);

   @endwhile
@endwhile
#ifndef ATL_MaxMMalpha
   #define ATL_MaxMMalpha 3
#endif
@ROUT ATL_NCmmJIK_c ATL_NCmmIJK_c
#define mm_bX Mjoin(NCmm0,_a1_b0)
#define mm_b1 Mjoin(NCmm0,_a1_b1)
@ROUT ATL_NCmmJIK ATL_NCmmIJK ATL_NCmmJIK_c ATL_NCmmIJK_c
#ifndef MB
   #define MB NB
#endif
#ifndef KB
   #define KB NB
#endif

@ROUT ATL_NCmmJIK_c ATL_NCmmIJK_c
   @define cc @cp@
   @define ldc @MB@
   @define alpha @ATL_rone@
   @define beta @ATL_rzero@
int Mjoin(PATL,NCmm@(lo)_c)
@ROUT ATL_NCmmJIK ATL_NCmmIJK
   @define cc @c@
   @define ldc @ldc@
   @define alpha @alpha@
   @define beta @beta@
int Mjoin(PATL,NCmm@(lo))
@ROUT ATL_NCmmJIK ATL_NCmmIJK ATL_NCmmJIK_c ATL_NCmmIJK_c
   (const enum ATLAS_TRANS TA, const enum ATLAS_TRANS TB,
    const int M, const int N, const int K, const SCALAR alpha,
    const TYPE *A, const int lda0, const TYPE *B, const int ldb0,
    const SCALAR beta, TYPE *C, const int ldc0)
/*
 * @(lo) loop-ordered matmul with no matrix copy
 */
{
   size_t incAk, incAm, incAn, incBk, incBm, incBn;
   const size_t lda=lda0, ldb=ldb0, ldc=ldc0;
   const int Mb = M / MB, Nb = N / NB, Kb = K / KB;
   const int mr = M - Mb*MB, nr = N - Nb*NB, kr = K - Kb*KB;
@ROUT ATL_NCmmJIK_c ATL_NCmmJIK
   #define incCm MB
   const size_t incCn = ldc*NB - M + mr;
@ROUT ATL_NCmmIJK_c ATL_NCmmIJK
   const size_t incCn = ldc*NB, incCm = MB - Nb * incCn;
@ROUT ATL_NCmmJIK ATL_NCmmIJK
   const int BetaIsZero = (beta == ATL_rzero);
@ROUT ATL_NCmmJIK ATL_NCmmIJK ATL_NCmmJIK_c ATL_NCmmIJK_c
   int i, j, k;
   const TYPE *a=A, *b=B;
   TYPE *c=C;
   TYPE btmp;
@ROUT ATL_NCmmJIK_c ATL_NCmmIJK_c
   void *vp;
   TYPE *@(cc);
   void (*geadd)(const int M, const int N, const SCALAR scalar, const TYPE *A,
                  const int lda, const SCALAR beta, TYPE *C, const int ldc);
@ROUT ATL_NCmmJIK ATL_NCmmIJK ATL_NCmmJIK_c ATL_NCmmIJK_c
   void (*mm_bX)(const int M, const int N, const int K, const SCALAR alpha,
                 const TYPE *A, const int lda, const TYPE *B, const int ldb, 
                 const SCALAR beta, TYPE *C, const int ldc);
   void (*mm_b1)(const int M, const int N, const int K, const SCALAR alpha,
                 const TYPE *A, const int lda, const TYPE *B, const int ldb, 
                 const SCALAR beta, TYPE *C, const int ldc);
   void (*mmcu) (const int M, const int N, const int K, const SCALAR alpha,
                 const TYPE *A, const int lda, const TYPE *B, const int ldb, 
                 const SCALAR beta, TYPE *C, const int ldc);
   void (*mm_fixedKcu)(const int M, const int N, const int K, 
                       const SCALAR alpha, const TYPE *A, const int lda, 
                       const TYPE *B, const int ldb, const 
                       SCALAR beta, TYPE *C, const int ldc);
@ROUT ATL_NCmmJIK ATL_NCmmIJK ATL_NCmmJIK_c ATL_NCmmIJK_c

   if (TA == AtlasNoTrans)
   {
      if (TB == AtlasNoTrans)
      {
@ROUT ATL_NCmmJIK_c ATL_NCmmIJK_c
         mm_bX = Mjoin(Mjoin(Mjoin(NCmm0,NN),0x0x0),_a1_b0);
         mm_b1 = Mjoin(Mjoin(Mjoin(NCmm0,NN),0x0x0),_a1_b1);
@ROUT ATL_NCmmJIK ATL_NCmmIJK ATL_NCmmJIK_c ATL_NCmmIJK_c
         mm_fixedKcu=Mjoin(Mjoin(Mjoin(NCmm00,Mjoin(0x0x,KB)),NN),0x0x0_aX_bX);
         mmcu = Mjoin(Mjoin(Mjoin(NCmm00,0x0x0),NN),0x0x0_aX_bX);
      }
      else
      {
@ROUT ATL_NCmmJIK_c ATL_NCmmIJK_c
         mm_bX = Mjoin(Mjoin(Mjoin(NCmm0,NT),0x0x0),_a1_b0);
         mm_b1 = Mjoin(Mjoin(Mjoin(NCmm0,NT),0x0x0),_a1_b1);
@ROUT ATL_NCmmJIK ATL_NCmmIJK ATL_NCmmJIK_c ATL_NCmmIJK_c
         mm_fixedKcu=Mjoin(Mjoin(Mjoin(NCmm00,Mjoin(0x0x,KB)),NT),0x0x0_aX_bX);
         mmcu = Mjoin(Mjoin(Mjoin(NCmm00,0x0x0),NT),0x0x0_aX_bX);
      }
      incAk = lda * KB;
@ROUT ATL_NCmmJIK ATL_NCmmJIK_c
      incAm = MB - Kb * incAk;
      incAn = -Mb * MB;
@ROUT ATL_NCmmIJK ATL_NCmmIJK_c
      incAn = -Kb * incAk;
      incAm = MB;
@ROUT ATL_NCmmJIK ATL_NCmmIJK ATL_NCmmJIK_c ATL_NCmmIJK_c
   }
   else
   {
      if (TB == AtlasNoTrans)
      {
@ROUT ATL_NCmmJIK_c ATL_NCmmIJK_c
         mm_bX = Mjoin(Mjoin(Mjoin(NCmm0,TN),0x0x0),_a1_b0);
         mm_b1 = Mjoin(Mjoin(Mjoin(NCmm0,TN),0x0x0),_a1_b1);
@ROUT ATL_NCmmJIK ATL_NCmmIJK ATL_NCmmJIK_c ATL_NCmmIJK_c
         mm_fixedKcu=Mjoin(Mjoin(Mjoin(NCmm00,Mjoin(0x0x,KB)),TN),0x0x0_aX_bX);
         mmcu = Mjoin(Mjoin(Mjoin(NCmm00,0x0x0),TN),0x0x0_aX_bX);
      }
      else
      {
@ROUT ATL_NCmmJIK_c ATL_NCmmIJK_c
         mm_bX = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_a1_b0);
         mm_b1 = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_a1_b1);
@ROUT ATL_NCmmJIK ATL_NCmmIJK ATL_NCmmJIK_c ATL_NCmmIJK_c
         mm_fixedKcu=Mjoin(Mjoin(Mjoin(NCmm00,Mjoin(0x0x,KB)),TT),0x0x0_aX_bX);
         mmcu = Mjoin(Mjoin(Mjoin(NCmm00,0x0x0),TT),0x0x0_aX_bX);
      }
      incAk = KB;
@ROUT ATL_NCmmJIK ATL_NCmmJIK_c
      incAm = lda*MB - Kb*KB;
      incAn = -lda*MB*Mb;
@ROUT ATL_NCmmIJK ATL_NCmmIJK_c
      incAn = -Kb * incAk;
      incAm = MB * lda;
@ROUT ATL_NCmmJIK ATL_NCmmIJK ATL_NCmmJIK_c ATL_NCmmIJK_c
   }
@ROUT ATL_NCmmJIK ATL_NCmmIJK
@beginskip
/*
 * Not worth blocking unless at least two dimensions exceed the blocking
 * factor
 */
#if 0
   if (M < MB)
   {
      if (N < NB || K < KB)
      {
         if (BetaIsZero) Mjoin(PATL,gezero)(M, N, c, ldc);
         mmcu(M, N, K, alpha, A, lda, B, ldb, beta, c, ldc);
         return;
      }
   }
   else if (N < NB)
   {
      if (K < KB)
      {
         if (BetaIsZero) Mjoin(PATL,gezero)(M, N, c, ldc);
         mmcu(M, N, K, alpha, A, lda, B, ldb, beta, c, ldc);
         return;
      }
   }
#endif
@endskip
@ROUT ATL_NCmmJIK ATL_NCmmIJK ATL_NCmmJIK_c ATL_NCmmIJK_c
   if (TB == AtlasNoTrans)
   {
      incBk = KB;
@ROUT ATL_NCmmJIK ATL_NCmmJIK_c
      incBm = -KB*Kb;
      incBn = ldb*NB;
@ROUT ATL_NCmmIJK ATL_NCmmIJK_c
      incBn = ldb*NB - K + kr;
      incBm = -Nb * ldb * NB;
@ROUT ATL_NCmmJIK ATL_NCmmIJK ATL_NCmmJIK_c ATL_NCmmIJK_c
   }
   else
   {
      incBk = KB*ldb;
@ROUT ATL_NCmmJIK ATL_NCmmJIK_c
      incBm = -Kb * incBk;
      incBn = NB;
@ROUT ATL_NCmmIJK ATL_NCmmIJK_c
      incBn = NB - Kb*incBk;
      incBm = -Nb*NB;
@ROUT ATL_NCmmJIK ATL_NCmmIJK ATL_NCmmJIK_c ATL_NCmmIJK_c
   }

@ROUT ATL_NCmmJIK_c ATL_NCmmIJK_c
   if (alpha == ATL_rone)
   {
      if (beta == ATL_rzero) geadd = Mjoin(Mjoin(Mjoin(PATL,geadd),_a1),_b0);
      else if (beta == ATL_rone)
         geadd = Mjoin(Mjoin(Mjoin(PATL,geadd),_a1),_b1);
      else geadd = Mjoin(Mjoin(Mjoin(PATL,geadd),_a1),_bX);
   }
   else if (beta == ATL_rzero)
      geadd = Mjoin(Mjoin(Mjoin(PATL,geadd),_aX),_b0);
   else if (beta == ATL_rone)
      geadd = Mjoin(Mjoin(Mjoin(PATL,geadd),_aX),_b1);
   else geadd = Mjoin(Mjoin(Mjoin(PATL,geadd),_aX),_bX);
   vp = malloc(ATL_Cachelen + ATL_MulBySize(MB * NB));
   ATL_assert(vp);
   @(cc) = ATL_AlignPtr(vp);
   if (mr || nr || kr) for (j=MB*NB, i=0; i != j; i++) @(cc)[i] = ATL_rzero;
@ROUT ATL_NCmmJIK ATL_NCmmIJK
   if (alpha == ATL_rone)
   {
      if (TA == AtlasNoTrans)
      {
         if (TB == AtlasNoTrans)
         {
            mm_b1 = Mjoin(Mjoin(Mjoin(NCmm0,NN),0x0x0),_a1_b1);
            if (beta == ATL_rone) mm_bX = mm_b1;
            else if (beta == ATL_rzero) 
               mm_bX = Mjoin(Mjoin(Mjoin(NCmm0,NN),0x0x0),_a1_b0);
            else mm_bX = Mjoin(Mjoin(Mjoin(NCmm0,NN),0x0x0),_a1_bX);
         }
         else
         {
            mm_b1 = Mjoin(Mjoin(Mjoin(NCmm0,NT),0x0x0),_a1_b1);
            if (beta == ATL_rone) mm_bX = mm_b1;
            else if (beta == ATL_rzero) 
               mm_bX = Mjoin(Mjoin(Mjoin(NCmm0,NT),0x0x0),_a1_b0);
            else mm_bX = Mjoin(Mjoin(Mjoin(NCmm0,NT),0x0x0),_a1_bX);
         }
      }
      else
      {
         if (TB == AtlasNoTrans)
         {
            mm_b1 = Mjoin(Mjoin(Mjoin(NCmm0,TN),0x0x0),_a1_b1);
            if (beta == ATL_rone) mm_bX = mm_b1;
            else if (beta == ATL_rzero) 
               mm_bX = Mjoin(Mjoin(Mjoin(NCmm0,TN),0x0x0),_a1_b0);
            else mm_bX = Mjoin(Mjoin(Mjoin(NCmm0,TN),0x0x0),_a1_bX);
         }
         else
         {
            mm_b1 = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_a1_b1);
            if (beta == ATL_rone) mm_bX = mm_b1;
            else if (beta == ATL_rzero) 
               mm_bX = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_a1_b0);
            else mm_bX = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_a1_bX);
         }
      }
   }
   else  /* non-one alpha */
   {
      btmp = Mabs(beta);
      if (btmp < ATL_rone) btmp = 1.0;
/*
 *    If needed, call version that uses temp C to handle alpha & beta safely
 */
      if (Kb >= ATL_MaxMMalpha || Mabs(alpha) < btmp)
         return(Mjoin(PATL,NCmm@(lo)_c)(TA, TB, M, N, K, alpha, A, lda, B, ldb, 
                                      beta, C, ldc));
      if (TA == AtlasNoTrans)
      {
         if (TB == AtlasNoTrans)
         {
            mm_bX = mm_b1 = Mjoin(Mjoin(Mjoin(NCmm0,NN),0x0x0),_aX_bX);
            if (beta == ATL_rzero) 
               mm_bX = Mjoin(Mjoin(Mjoin(NCmm0,NN),0x0x0),_aX_b0);
         }
         else
         {
            mm_bX = mm_b1 = Mjoin(Mjoin(Mjoin(NCmm0,NT),0x0x0),_aX_bX);
            if (beta == ATL_rzero) 
               mm_bX = Mjoin(Mjoin(Mjoin(NCmm0,NT),0x0x0),_aX_b0);
         }
      }
      else
      {
         if (TB == AtlasNoTrans)
         {
            mm_bX = mm_b1 = Mjoin(Mjoin(Mjoin(NCmm0,TN),0x0x0),_aX_bX);
            if (beta == ATL_rzero) 
               mm_bX = Mjoin(Mjoin(Mjoin(NCmm0,TN),0x0x0),_aX_b0);
         }
         else
         {
            mm_bX = mm_b1 = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_aX_bX);
            if (beta == ATL_rzero) 
               mm_bX = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_aX_b0);
         }
      }
   }
@ROUT ATL_NCmmJIK ATL_NCmmIJK ATL_NCmmJIK_c ATL_NCmmIJK_c

@ROUT ATL_NCmmJIK ATL_NCmmJIK_c
   for (j=Nb; j; j--, a += incAn, b += incBn, c += incCn)
   {
      for (i=Mb; i; i--, a += incAm, b += incBm, c += incCm)
@ROUT ATL_NCmmIJK ATL_NCmmIJK_c
   for (i=Mb; i; i--, a += incAm, b += incBm, c += incCm)
   {
      for (j=Nb; j; j--, a += incAn, b += incBn, c += incCn)
@ROUT ATL_NCmmJIK ATL_NCmmIJK ATL_NCmmJIK_c ATL_NCmmIJK_c
      {
         if (Kb)
         {
            mm_bX(MB, NB, KB, @(alpha), a, lda, b, ldb, @(beta), @(cc), @(ldc));
            a += incAk;  b += incBk;
            for (k=Kb-1; k; k--, a += incAk, b += incBk)
               mm_b1(MB, NB, KB, @(alpha), a, lda, b, ldb, ATL_rone, @(cc), @(ldc));
            if (kr) 
               mmcu(MB, NB, kr, @(alpha), a, lda, b, ldb, ATL_rone, @(cc), @(ldc));
         }
         else if (kr) 
         {
@ROUT ATL_NCmmJIK ATL_NCmmIJK 
            if (BetaIsZero) Mjoin(PATL,gezero)(MB, NB, c, ldc);
@ROUT ATL_NCmmJIK_c ATL_NCmmIJK_c
            Mjoin(PATL,zero)(MB*NB, cp, 1); /* kill NaN/INF from last time */
@ROUT ATL_NCmmJIK ATL_NCmmIJK ATL_NCmmJIK_c ATL_NCmmIJK_c
            mmcu(MB, NB, kr, @(alpha), a, lda, b, ldb, @(beta), @(cc), @(ldc));
         }
@ROUT ATL_NCmmJIK_c ATL_NCmmIJK_c
         geadd(MB, NB, alpha, @(cc), @(ldc), beta, c, ldc);
@ROUT ATL_NCmmJIK ATL_NCmmIJK ATL_NCmmJIK_c ATL_NCmmIJK_c
      }
   }
@ROUT ATL_NCmmJIK ATL_NCmmJIK_c
   if (mr && N != nr)
      ATL_assert(Mjoin(PATL,NCmmIJK)(TA, TB, mr, N-nr, K, alpha, 
                                     A+Mb*(incAm+Kb*incAk), lda, B, ldb, 
                                     beta, C+Mb*MB, ldc) ==0);
   if (nr)
   {
      for (i=Mb; i; i--, a += incAm, b += incBm, c += incCm)
      {
@ROUT ATL_NCmmJIK
      if (BetaIsZero) Mjoin(PATL,gezero)(MB, nr, c, ldc);
@ROUT ATL_NCmmJIK_c
      Mjoin(PATL,zero)(MB*nr, cp, 1); /* kill NaN and INF from last time */
@ROUT ATL_NCmmJIK ATL_NCmmJIK_c
         if (Kb)
         {
            mm_fixedKcu(MB, nr, KB, @(alpha), a, lda, b, ldb, @(beta), 
                        @(cc), @(ldc));
            a += incAk;  b += incBk;
            for (k=Kb-1; k; k--, a += incAk, b += incBk)
               mm_fixedKcu(MB, nr, KB, @(alpha), a, lda, b, ldb, ATL_rone, 
                           @(cc), @(ldc));
            if (kr) 
               mmcu(MB, nr, kr, @(alpha), a, lda, b, ldb, ATL_rone, @(cc), @(ldc));
         }
         else if (kr) 
            mmcu(MB, nr, kr, @(alpha), a, lda, b, ldb, @(beta), @(cc), @(ldc));
@ROUT ATL_NCmmJIK_c
         geadd(MB, nr, alpha, @(cc), @(ldc), beta, c, ldc);
@ROUT ATL_NCmmJIK ATL_NCmmJIK_c
      }
      if (mr)  /* cleanup small mr x nr block of C */
      {
         c = C + Mb*MB + ldc*Nb*NB;
         a = A + Mb*(incAm+Kb*incAk);
         b = B + Nb*( incBn+(Mb*(incBm+Kb*incBk)) );
@ROUT ATL_NCmmJIK 
         if (BetaIsZero) Mjoin(PATL,gezero)(mr, nr, c, ldc);
@ROUT ATL_NCmmJIK_c
         Mjoin(PATL,zero)(MB*nr, cp, 1); /* kill NaN and INF from last time */
@ROUT ATL_NCmmJIK ATL_NCmmJIK_c
         if (Kb)
         {
            mm_fixedKcu(mr, nr, KB, @(alpha), a, lda, b, ldb, @(beta), 
                        @(cc), @(ldc));
            a += incAk;  b += incBk;
            for (k=Kb-1; k; k--, a += incAk, b += incBk)
               mm_fixedKcu(mr, nr, KB, @(alpha), a, lda, b, ldb, ATL_rone, 
                           @(cc), @(ldc));
            if (kr) 
               mmcu(mr, nr, kr, @(alpha), a, lda, b, ldb, ATL_rone, @(cc), @(ldc));
         }
         else if (kr) 
            mmcu(mr, nr, kr, @(alpha), a, lda, b, ldb, @(beta), @(cc), @(ldc));
@ROUT ATL_NCmmJIK_c
         geadd(mr, nr, alpha, @(cc), @(ldc), beta, c, ldc);
@ROUT ATL_NCmmJIK ATL_NCmmJIK_c
      }
   }
@ROUT ATL_NCmmIJK ATL_NCmmIJK_c
   if (mr)  /* M-loop remainder */
   {
      for (j=Nb; j; j--, a += incAn, b += incBn, c += incCn)
      {
@ROUT ATL_NCmmIJK 
         if (BetaIsZero) Mjoin(PATL,gezero)(mr, NB, c, ldc);
@ROUT ATL_NCmmIJK_c
         Mjoin(PATL,zero)(MB*NB, cp, 1); /* kill NaN and INF from last time */
@ROUT ATL_NCmmIJK ATL_NCmmIJK_c
         if (Kb)
         {
            mm_fixedKcu(mr, NB, KB, @(alpha), a, lda, b, ldb, @(beta), 
                        @(cc), @(ldc));
            a += incAk;  b += incBk;
            for (k=Kb-1; k; k--, a += incAk, b += incBk)
               mm_fixedKcu(mr, NB, KB, @(alpha), a, lda, b, ldb, ATL_rone, 
                           @(cc), @(ldc));
            if (kr) 
               mmcu(mr, NB, kr, @(alpha), a, lda, b, ldb, ATL_rone, @(cc), @(ldc));
         }
         else if (kr)
            mmcu(mr, NB, kr, @(alpha), a, lda, b, ldb, @(beta), @(cc), @(ldc));
@ROUT ATL_NCmmIJK_c
         geadd(mr, NB, alpha, @(cc), @(ldc), beta, c, ldc);
@ROUT ATL_NCmmIJK ATL_NCmmIJK_c
      }
   }
   if (nr)
      ATL_assert(Mjoin(PATL,NCmmJIK)(TA, TB, M, nr, K, alpha, A, lda, 
                                     B+Nb*(incBn+Kb*incBk), ldb,
                                     beta, C+Nb*NB*ldc, ldc) == 0);
@ROUT ATL_NCmmJIK_c ATL_NCmmIJK_c
   free(vp);
@ROUT ATL_NCmmJIK ATL_NCmmIJK ATL_NCmmJIK_c ATL_NCmmIJK_c
   return(0);
}
@ROUT ATL_cNCmmJIK ATL_cNCmmJIK_c
   @define lo @JIK@
@ROUT ATL_cNCmmIJK ATL_cNCmmIJK_c
   @define lo @IJK@
@ROUT ATL_cNCmmJIK ATL_cNCmmIJK ATL_cNCmmJIK_c ATL_cNCmmIJK_c
@extract -b @(topd)/gen.inc what=cw @(cw99)

#include "atlas_misc.h"
#ifdef SCPLX
   #include "atlas_cNCmm.h"
#elif defined(DCPLX)
   #include "atlas_zNCmm.h"
#endif
#include "atlas_lvl3.h"

#ifndef MB
   #define MB NB
#endif
#ifndef KB
   #define KB NB
#endif


#define NBnam Mjoin(Mjoin(Mjoin(Mjoin(MB,x),NB),x),KB)
#define NCmm0 Mjoin(Mjoin(PATL,JIK),NBnam)
#define NCmm00 Mjoin(PATL,JIK)
@whiledef TA T N
   @whiledef TB T N
      @whiledef bet 0 1 X
         @whiledef alp 1 X
void Mjoin(Mjoin(Mjoin(NCmm0,@(TA)@(TB)),0x0x0),_a@(alp)_b@(bet))
   (const int M, const int N, const int K, const TYPE alpha, const TYPE *A, 
    const int lda, const TYPE *B, const int ldb, 
    const TYPE beta, TYPE *C, const int ldc);
         @endwhile
      @endwhile
void Mjoin(Mjoin(Mjoin(NCmm00,Mjoin(0x0x,KB)),@(TA)@(TB)),0x0x0_aX_bX)
   (const int M, const int N, const int K, const TYPE alpha, const TYPE *A, 
    const int lda, const TYPE *B, const int ldb, 
    const TYPE beta, TYPE *C, const int ldc);
void Mjoin(Mjoin(Mjoin(NCmm00,0x0x0),@(TA)@(TB)),0x0x0_aX_bX)
   (const int M, const int N, const int K, const TYPE alpha, const TYPE *A, 
    const int lda, const TYPE *B, const int ldb, 
    const TYPE beta, TYPE *C, const int ldc);

   @endwhile
@endwhile

#ifndef ATL_MaxMMalpha
   #define ATL_MaxMMalpha 3
#endif
@ROUT ATL_cNCmmJIK ATL_cNCmmIJK ATL_cNCmmJIK_c ATL_cNCmmIJK_c
#ifndef MB
   #define MB NB
#endif
#ifndef KB
   #define KB NB
#endif

typedef void (*MMPTR)
   (const int M, const int N, const int K, const TYPE alpha, 
    const TYPE *A, const int lda, const TYPE *B, const int ldb, 
    const TYPE beta, TYPE *C, const int ldc);
@ROUT ATL_cNCmmJIK_c ATL_cNCmmIJK_c
   @define cc @cp@
   @define ldc @MB@
   @define alpha @ATL_rone@
   @define beta @ATL_rzero@
int Mjoin(PATL,NCmm@(lo)_c)
@ROUT ATL_cNCmmJIK ATL_cNCmmIJK
   @define cc @c@
   @define ldc @ldc@
   @define alpha @alpha@
   @define beta @beta@
int Mjoin(PATL,NCmm@(lo))
@ROUT ATL_cNCmmJIK ATL_cNCmmIJK ATL_cNCmmJIK_c ATL_cNCmmIJK_c
   (const enum ATLAS_TRANS TA, const enum ATLAS_TRANS TB,
    const int M, const int N, const int K, const SCALAR alpha,
    const TYPE *A, const int lda0, const TYPE *B, const int ldb0,
    const SCALAR beta, TYPE *C, const int ldc0)
/*
 * @(lo) loop-ordered matmul with no matrix copy
 */
{
   const size_t lda=lda0, ldb=ldb0, ldc=ldc0;
   size_t incAk, incAm, incAn, incBk, incBm, incBn;
   const int Mb = M / MB, Nb = N / NB, Kb = K / KB;
   const int mr = M - Mb*MB, nr = N - Nb*NB, kr = K - Kb*KB;
@ROUT ATL_cNCmmJIK_c ATL_cNCmmJIK
   const size_t incCm = (MB<<1), incCn = (ldc*NB - M + mr)<<1;
@ROUT ATL_cNCmmIJK_c ATL_cNCmmIJK
   const size_t incCn = ldc*(NB<<1), incCm = (MB<<1) - Nb * incCn;
@ROUT ATL_cNCmmJIK ATL_cNCmmIJK ATL_cNCmmJIK_c ATL_cNCmmIJK_c
   int i, j, k;
   const TYPE *a=A, *b=B;
   const TYPE ralpha = *alpha, rbeta = *beta;
   const TYPE nrbeta = (rbeta == ATL_rzero) ? ATL_rzero : -rbeta;
   const int AlphaIsReal = (alpha[1] == ATL_rzero);
   const int BetaIsReal = (beta[1] == ATL_rzero);
   const int AlphaIsOne = (AlphaIsReal && ralpha == ATL_rone);
   const int BetaIsOne = (BetaIsReal && rbeta == ATL_rone);
   const int BetaIsZero = (BetaIsReal && rbeta == ATL_rzero);
   TYPE ar0, ai0, ai1;
   TYPE *c=C;
   TYPE btmp;
   TYPE czero[2] = {ATL_rzero, ATL_rzero};
@ROUT ATL_cNCmmJIK_c ATL_cNCmmIJK_c
   void *vp;
   TYPE *@(cc);
   void (*geadd)(const int M, const int N, const SCALAR scalar, const TYPE *A,
                  const int lda, const SCALAR beta, TYPE *C, const int ldc);
@ROUT ATL_cNCmmJIK ATL_cNCmmIJK ATL_cNCmmJIK_c ATL_cNCmmIJK_c
   MMPTR r0mm_bX, i0mm_bX, r0mm_b1, i0mm_b1, r1mm, i1mm;
   MMPTR mmcu, mm_fixedKcu;

@ROUT ATL_cNCmmJIK ATL_cNCmmIJK
/*
 * See if we need to call Separate routine in order to handle alpha & beta
 */
   i = 0;
   if (!AlphaIsReal || !BetaIsReal) i = 1;
   else
   {
      if (Kb > ATL_MaxMMalpha) i = 1;
      else if (!AlphaIsOne || TA == AtlasConjTrans || TB == AtlasConjTrans)
      {
         btmp = Mabs(*beta);
         if (btmp < ATL_rone) btmp = ATL_rone;
         if (Mabs(*alpha) < btmp || ATL_rone < btmp) i = 1;
      }
   }
   if (i)
      return(Mjoin(PATL,NCmm@(lo)_c)(TA, TB, M, N, K, alpha, A, lda, B, ldb, 
                                   beta, C, ldc));

@ROUT ATL_cNCmmJIK ATL_cNCmmIJK ATL_cNCmmJIK_c ATL_cNCmmIJK_c
   if (TA == AtlasNoTrans)
   {
      if (TB == AtlasNoTrans)
      {
@ROUT ATL_cNCmmJIK_c ATL_cNCmmIJK_c
         ar0 = ai0 = ai1 = ATL_rone;
         i0mm_bX = r0mm_bX = Mjoin(Mjoin(Mjoin(NCmm0,NN),0x0x0),_a1_b0);
         i1mm = i0mm_b1 = Mjoin(Mjoin(Mjoin(NCmm0,NN),0x0x0),_a1_b1);
         r0mm_b1 = r1mm = Mjoin(Mjoin(Mjoin(NCmm0,NN),0x0x0),_a1_bX);
@ROUT ATL_cNCmmJIK ATL_cNCmmIJK
         ar0 = ai0 = ai1 = ralpha;
         if (AlphaIsOne)
         {
            r0mm_b1 = Mjoin(Mjoin(Mjoin(NCmm0,NN),0x0x0),_a1_bX);
            i0mm_b1 = Mjoin(Mjoin(Mjoin(NCmm0,NN),0x0x0),_a1_b1);
            if (BetaIsOne)
            {
               r1mm = r0mm_bX = Mjoin(Mjoin(Mjoin(NCmm0,NN),0x0x0),_a1_bX);
               i1mm = i0mm_bX = Mjoin(Mjoin(Mjoin(NCmm0,NN),0x0x0),_a1_b1);
            }
            else if (BetaIsZero)
            {
               i0mm_bX = r0mm_bX = Mjoin(Mjoin(Mjoin(NCmm0,NN),0x0x0),_a1_b0);
               i1mm = Mjoin(Mjoin(Mjoin(NCmm0,NN),0x0x0),_a1_b1);
               r1mm = Mjoin(Mjoin(Mjoin(NCmm0,NN),0x0x0),_a1_bX);
            }
            else
            {
               i0mm_bX=r1mm=r0mm_bX=Mjoin(Mjoin(Mjoin(NCmm0,NN),0x0x0),_a1_bX);
               i1mm = Mjoin(Mjoin(Mjoin(NCmm0,NN),0x0x0),_a1_b1);
            }
         }
         else
         {
            i0mm_b1 = r0mm_b1 = Mjoin(Mjoin(Mjoin(NCmm0,NN),0x0x0),_aX_bX);
            if (BetaIsOne)
            {
               r1mm = r0mm_bX = Mjoin(Mjoin(Mjoin(NCmm0,NN),0x0x0),_aX_bX);
               i1mm = i0mm_bX = Mjoin(Mjoin(Mjoin(NCmm0,NN),0x0x0),_aX_bX);
            }
            else if (BetaIsZero)
            {
               i0mm_bX = r0mm_bX = Mjoin(Mjoin(Mjoin(NCmm0,NN),0x0x0),_aX_b0);
               i1mm = Mjoin(Mjoin(Mjoin(NCmm0,NN),0x0x0),_aX_bX);
               r1mm = Mjoin(Mjoin(Mjoin(NCmm0,NN),0x0x0),_aX_bX);
            }
            else
            {
               i0mm_bX=r1mm=r0mm_bX=Mjoin(Mjoin(Mjoin(NCmm0,NN),0x0x0),_aX_bX);
               i1mm = Mjoin(Mjoin(Mjoin(NCmm0,NN),0x0x0),_aX_bX);
            }
         }
@ROUT ATL_cNCmmJIK ATL_cNCmmIJK ATL_cNCmmJIK_c ATL_cNCmmIJK_c
         mm_fixedKcu=Mjoin(Mjoin(Mjoin(NCmm00,Mjoin(0x0x,KB)),NN),0x0x0_aX_bX);
         mmcu = Mjoin(Mjoin(Mjoin(NCmm00,0x0x0),NN),0x0x0_aX_bX);
      }
      else if (TB == AtlasConjTrans)
      {
@ROUT ATL_cNCmmJIK_c ATL_cNCmmIJK_c
         ai1 = ar0 = ATL_rnone; ai0 = ATL_rone;
         r0mm_bX = Mjoin(Mjoin(Mjoin(NCmm0,NT),0x0x0),_aX_b0);
         r0mm_b1 = Mjoin(Mjoin(Mjoin(NCmm0,NT),0x0x0),_aX_bX);
         r1mm    = Mjoin(Mjoin(Mjoin(NCmm0,NT),0x0x0),_a1_bX);
         i0mm_bX = Mjoin(Mjoin(Mjoin(NCmm0,NT),0x0x0),_a1_b0);
         i0mm_b1 = Mjoin(Mjoin(Mjoin(NCmm0,NT),0x0x0),_a1_b1);
         i1mm    = Mjoin(Mjoin(Mjoin(NCmm0,NT),0x0x0),_aX_bX);
@ROUT ATL_cNCmmJIK ATL_cNCmmIJK
         ai1 = ar0 = -ralpha; ai0 = ralpha;
         if (AlphaIsOne)
         {
            r0mm_b1 = Mjoin(Mjoin(Mjoin(NCmm0,NT),0x0x0),_aX_bX);
            i0mm_b1 = Mjoin(Mjoin(Mjoin(NCmm0,NT),0x0x0),_a1_b1);
            if (BetaIsOne)
            {
               r0mm_bX = Mjoin(Mjoin(Mjoin(NCmm0,NT),0x0x0),_aX_bX);
               r1mm    = Mjoin(Mjoin(Mjoin(NCmm0,NT),0x0x0),_a1_bX);
               i0mm_bX = Mjoin(Mjoin(Mjoin(NCmm0,NT),0x0x0),_a1_b1);
               i1mm    = Mjoin(Mjoin(Mjoin(NCmm0,NT),0x0x0),_aX_bX);
            }
            else if (BetaIsZero)
            {
               r0mm_bX = Mjoin(Mjoin(Mjoin(NCmm0,NT),0x0x0),_aX_b0);
               r1mm    = Mjoin(Mjoin(Mjoin(NCmm0,NT),0x0x0),_a1_bX);
               i0mm_bX = Mjoin(Mjoin(Mjoin(NCmm0,NT),0x0x0),_a1_b0);
               i1mm    = Mjoin(Mjoin(Mjoin(NCmm0,NT),0x0x0),_aX_bX);
            }
            else
            {
               r0mm_bX = Mjoin(Mjoin(Mjoin(NCmm0,NT),0x0x0),_aX_bX);
               r1mm    = Mjoin(Mjoin(Mjoin(NCmm0,NT),0x0x0),_a1_bX);
               i0mm_bX = Mjoin(Mjoin(Mjoin(NCmm0,NT),0x0x0),_a1_bX);
               i1mm    = Mjoin(Mjoin(Mjoin(NCmm0,NT),0x0x0),_aX_bX);
            }
         }
         else
         {
            r0mm_b1 = Mjoin(Mjoin(Mjoin(NCmm0,NT),0x0x0),_aX_bX);
            i0mm_b1 = Mjoin(Mjoin(Mjoin(NCmm0,NT),0x0x0),_aX_bX);
            if (BetaIsOne)
            {
               r0mm_bX = Mjoin(Mjoin(Mjoin(NCmm0,NT),0x0x0),_aX_bX);
               r1mm    = Mjoin(Mjoin(Mjoin(NCmm0,NT),0x0x0),_aX_bX);
               i0mm_bX = Mjoin(Mjoin(Mjoin(NCmm0,NT),0x0x0),_aX_bX);
               i1mm    = Mjoin(Mjoin(Mjoin(NCmm0,NT),0x0x0),_aX_bX);
            }
            else if (BetaIsZero)
            {
               r0mm_bX = Mjoin(Mjoin(Mjoin(NCmm0,NT),0x0x0),_aX_b0);
               r1mm    = Mjoin(Mjoin(Mjoin(NCmm0,NT),0x0x0),_aX_bX);
               i0mm_bX = Mjoin(Mjoin(Mjoin(NCmm0,NT),0x0x0),_aX_b0);
               i1mm    = Mjoin(Mjoin(Mjoin(NCmm0,NT),0x0x0),_aX_bX);
            }
            else
            {
               r0mm_bX = Mjoin(Mjoin(Mjoin(NCmm0,NT),0x0x0),_aX_bX);
               r1mm    = Mjoin(Mjoin(Mjoin(NCmm0,NT),0x0x0),_aX_bX);
               i0mm_bX = Mjoin(Mjoin(Mjoin(NCmm0,NT),0x0x0),_aX_bX);
               i1mm    = Mjoin(Mjoin(Mjoin(NCmm0,NT),0x0x0),_aX_bX);
            }
         }
@ROUT ATL_cNCmmJIK ATL_cNCmmIJK ATL_cNCmmJIK_c ATL_cNCmmIJK_c
         mm_fixedKcu=Mjoin(Mjoin(Mjoin(NCmm00,Mjoin(0x0x,KB)),NT),0x0x0_aX_bX);
         mmcu = Mjoin(Mjoin(Mjoin(NCmm00,0x0x0),NT),0x0x0_aX_bX);
      }
      else
      {
@ROUT ATL_cNCmmJIK_c ATL_cNCmmIJK_c
         ar0 = ai0 = ai1 = ATL_rone;
         i0mm_bX = r0mm_bX = Mjoin(Mjoin(Mjoin(NCmm0,NT),0x0x0),_a1_b0);
         i1mm = i0mm_b1 = Mjoin(Mjoin(Mjoin(NCmm0,NT),0x0x0),_a1_b1);
         r0mm_b1 = r1mm = Mjoin(Mjoin(Mjoin(NCmm0,NT),0x0x0),_a1_bX);
@ROUT ATL_cNCmmJIK ATL_cNCmmIJK
         ar0 = ai0 = ai1 = ralpha;
         if (AlphaIsOne)
         {
            r0mm_b1 = Mjoin(Mjoin(Mjoin(NCmm0,NT),0x0x0),_a1_bX);
            i0mm_b1 = Mjoin(Mjoin(Mjoin(NCmm0,NT),0x0x0),_a1_b1);
            if (BetaIsOne)
            {
               r1mm = r0mm_bX = Mjoin(Mjoin(Mjoin(NCmm0,NT),0x0x0),_a1_bX);
               i1mm = i0mm_bX = Mjoin(Mjoin(Mjoin(NCmm0,NT),0x0x0),_a1_b1);
            }
            else if (BetaIsZero)
            {
               i0mm_bX = r0mm_bX = Mjoin(Mjoin(Mjoin(NCmm0,NT),0x0x0),_a1_b0);
               i1mm = Mjoin(Mjoin(Mjoin(NCmm0,NT),0x0x0),_a1_b1);
               r1mm = Mjoin(Mjoin(Mjoin(NCmm0,NT),0x0x0),_a1_bX);
            }
            else
            {
               i0mm_bX=r1mm=r0mm_bX=Mjoin(Mjoin(Mjoin(NCmm0,NT),0x0x0),_a1_bX);
               i1mm = Mjoin(Mjoin(Mjoin(NCmm0,NT),0x0x0),_a1_b1);
            }
         }
         else
         {
            r0mm_b1 = Mjoin(Mjoin(Mjoin(NCmm0,NT),0x0x0),_aX_bX);
            i0mm_b1 = Mjoin(Mjoin(Mjoin(NCmm0,NT),0x0x0),_aX_bX);
            if (BetaIsOne)
            {
               r1mm = r0mm_bX = Mjoin(Mjoin(Mjoin(NCmm0,NT),0x0x0),_aX_bX);
               i1mm = i0mm_bX = Mjoin(Mjoin(Mjoin(NCmm0,NT),0x0x0),_aX_bX);
            }
            else if (BetaIsZero)
            {
               i0mm_bX = r0mm_bX = Mjoin(Mjoin(Mjoin(NCmm0,NT),0x0x0),_aX_b0);
               i1mm = Mjoin(Mjoin(Mjoin(NCmm0,NT),0x0x0),_aX_bX);
               r1mm = Mjoin(Mjoin(Mjoin(NCmm0,NT),0x0x0),_aX_bX);
            }
            else
            {
               i0mm_bX=r1mm=r0mm_bX=Mjoin(Mjoin(Mjoin(NCmm0,NT),0x0x0),_aX_bX);
               i1mm = Mjoin(Mjoin(Mjoin(NCmm0,NT),0x0x0),_aX_bX);
            }
         }
@ROUT ATL_cNCmmJIK ATL_cNCmmIJK ATL_cNCmmJIK_c ATL_cNCmmIJK_c
         mm_fixedKcu=Mjoin(Mjoin(Mjoin(NCmm00,Mjoin(0x0x,KB)),NT),0x0x0_aX_bX);
         mmcu = Mjoin(Mjoin(Mjoin(NCmm00,0x0x0),NT),0x0x0_aX_bX);
      }
   }
   else if (TA == AtlasConjTrans)
   {
      if (TB == AtlasNoTrans)
      {
@ROUT ATL_cNCmmJIK_c ATL_cNCmmIJK_c
         ai0 = ar0 = ATL_rnone; ai1 = ATL_rone;
         r0mm_bX = Mjoin(Mjoin(Mjoin(NCmm0,TN),0x0x0),_aX_b0);
         r0mm_b1 = Mjoin(Mjoin(Mjoin(NCmm0,TN),0x0x0),_aX_bX);
         r1mm    = Mjoin(Mjoin(Mjoin(NCmm0,TN),0x0x0),_a1_bX);
         i0mm_bX = Mjoin(Mjoin(Mjoin(NCmm0,TN),0x0x0),_aX_b0);
         i0mm_b1 = Mjoin(Mjoin(Mjoin(NCmm0,TN),0x0x0),_aX_bX);
         i1mm    = Mjoin(Mjoin(Mjoin(NCmm0,TN),0x0x0),_a1_b1);
@ROUT ATL_cNCmmJIK ATL_cNCmmIJK
         ai0 = ar0 = -ralpha; ai1 = ralpha;
         if (AlphaIsOne)
         {
            r0mm_b1 = Mjoin(Mjoin(Mjoin(NCmm0,TN),0x0x0),_aX_bX);
            i0mm_b1 = Mjoin(Mjoin(Mjoin(NCmm0,TN),0x0x0),_aX_bX);
            if (BetaIsOne)
            {
               r0mm_bX = Mjoin(Mjoin(Mjoin(NCmm0,TN),0x0x0),_aX_bX);
               r1mm    = Mjoin(Mjoin(Mjoin(NCmm0,TN),0x0x0),_a1_bX);
               i0mm_bX = Mjoin(Mjoin(Mjoin(NCmm0,TN),0x0x0),_aX_bX);
               i1mm    = Mjoin(Mjoin(Mjoin(NCmm0,TN),0x0x0),_a1_b1);
            }
            else if (BetaIsZero)
            {
               r0mm_bX = Mjoin(Mjoin(Mjoin(NCmm0,TN),0x0x0),_aX_b0);
               r1mm    = Mjoin(Mjoin(Mjoin(NCmm0,TN),0x0x0),_a1_bX);
               i0mm_bX = Mjoin(Mjoin(Mjoin(NCmm0,TN),0x0x0),_aX_b0);
               i1mm    = Mjoin(Mjoin(Mjoin(NCmm0,TN),0x0x0),_a1_b1);
            }
            else
            {
               r0mm_bX = Mjoin(Mjoin(Mjoin(NCmm0,TN),0x0x0),_aX_bX);
               r1mm    = Mjoin(Mjoin(Mjoin(NCmm0,TN),0x0x0),_a1_bX);
               i0mm_bX = Mjoin(Mjoin(Mjoin(NCmm0,TN),0x0x0),_aX_bX);
               i1mm    = Mjoin(Mjoin(Mjoin(NCmm0,TN),0x0x0),_a1_b1);
            }
         }
         else
         {
            r0mm_b1 = Mjoin(Mjoin(Mjoin(NCmm0,TN),0x0x0),_aX_bX);
            i0mm_b1 = Mjoin(Mjoin(Mjoin(NCmm0,TN),0x0x0),_aX_bX);
            if (BetaIsOne)
            {
               r0mm_bX = Mjoin(Mjoin(Mjoin(NCmm0,TN),0x0x0),_aX_bX);
               r1mm    = Mjoin(Mjoin(Mjoin(NCmm0,TN),0x0x0),_aX_bX);
               i0mm_bX = Mjoin(Mjoin(Mjoin(NCmm0,TN),0x0x0),_aX_bX);
               i1mm    = Mjoin(Mjoin(Mjoin(NCmm0,TN),0x0x0),_aX_bX);
            }
            else if (BetaIsZero)
            {
               r0mm_bX = Mjoin(Mjoin(Mjoin(NCmm0,TN),0x0x0),_aX_b0);
               r1mm    = Mjoin(Mjoin(Mjoin(NCmm0,TN),0x0x0),_aX_bX);
               i0mm_bX = Mjoin(Mjoin(Mjoin(NCmm0,TN),0x0x0),_aX_b0);
               i1mm    = Mjoin(Mjoin(Mjoin(NCmm0,TN),0x0x0),_aX_bX);
            }
            else
            {
               r0mm_bX = Mjoin(Mjoin(Mjoin(NCmm0,TN),0x0x0),_aX_bX);
               r1mm    = Mjoin(Mjoin(Mjoin(NCmm0,TN),0x0x0),_aX_bX);
               i0mm_bX = Mjoin(Mjoin(Mjoin(NCmm0,TN),0x0x0),_aX_bX);
               i1mm    = Mjoin(Mjoin(Mjoin(NCmm0,TN),0x0x0),_aX_bX);
            }
         }
@ROUT ATL_cNCmmJIK ATL_cNCmmIJK ATL_cNCmmJIK_c ATL_cNCmmIJK_c
         mm_fixedKcu=Mjoin(Mjoin(Mjoin(NCmm00,Mjoin(0x0x,KB)),TN),0x0x0_aX_bX);
         mmcu = Mjoin(Mjoin(Mjoin(NCmm00,0x0x0),TN),0x0x0_aX_bX);
      }
      else if (TB == AtlasConjTrans)
      {
@ROUT ATL_cNCmmJIK_c ATL_cNCmmIJK_c
         ar0 = ATL_rone; ai1 = ai0 = ATL_rnone;
         r0mm_bX = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_a1_b0);
         r0mm_b1 = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_a1_bX);
         r1mm    = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_a1_bX);
         i0mm_bX = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_aX_b0);
         i0mm_b1 = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_aX_bX);
         i1mm    = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_aX_bX);
@ROUT ATL_cNCmmJIK ATL_cNCmmIJK
         ar0 = ralpha; ai1 = ai0 = -ralpha;
         if (AlphaIsOne)
         {
            r0mm_b1 = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_a1_bX);
            i0mm_b1 = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_aX_bX);
            if (BetaIsOne)
            {
               r0mm_bX = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_a1_bX);
               r1mm    = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_a1_bX);
               i0mm_bX = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_aX_bX);
               i1mm    = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_aX_bX);
            }
            else if (BetaIsZero)
            {
               r0mm_bX = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_a1_b0);
               r1mm    = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_a1_bX);
               i0mm_bX = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_aX_b0);
               i1mm    = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_aX_bX);
            }
            else
            {
               r0mm_bX = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_a1_bX);
               r1mm    = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_a1_bX);
               i0mm_bX = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_aX_bX);
               i1mm    = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_aX_bX);
            }
         }
         else
         {
            r0mm_b1 = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_aX_bX);
            i0mm_b1 = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_aX_bX);
            if (BetaIsOne)
            {
               r0mm_bX = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_aX_bX);
               r1mm    = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_aX_bX);
               i0mm_bX = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_aX_bX);
               i1mm    = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_aX_bX);
            }
            else if (BetaIsZero)
            {
               r0mm_bX = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_aX_b0);
               r1mm    = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_aX_bX);
               i0mm_bX = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_aX_b0);
               i1mm    = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_aX_bX);
            }
            else
            {
               r0mm_bX = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_aX_bX);
               r1mm    = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_aX_bX);
               i0mm_bX = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_aX_bX);
               i1mm    = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_aX_bX);
            }
         }
@ROUT ATL_cNCmmJIK ATL_cNCmmIJK ATL_cNCmmJIK_c ATL_cNCmmIJK_c
         mm_fixedKcu=Mjoin(Mjoin(Mjoin(NCmm00,Mjoin(0x0x,KB)),TT),0x0x0_aX_bX);
         mmcu = Mjoin(Mjoin(Mjoin(NCmm00,0x0x0),TT),0x0x0_aX_bX);
      }
      else  /* TA == AtlasConjTrans, TB == AtlasTrans */
      {
@ROUT ATL_cNCmmJIK_c ATL_cNCmmIJK_c
         ai0 = ar0 = ATL_rnone; ai1 = ATL_rone;
         r0mm_bX = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_aX_b0);
         r0mm_b1 = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_aX_bX);
         r1mm    = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_a1_bX);
         i0mm_bX = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_aX_b0);
         i0mm_b1 = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_aX_bX);
         i1mm    = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_a1_b1);
@ROUT ATL_cNCmmJIK ATL_cNCmmIJK
         ai0 = ar0 = -ralpha; ai1 = ralpha;
         if (AlphaIsOne)
         {
            r0mm_b1 = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_aX_bX);
            i0mm_b1 = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_aX_bX);
            if (BetaIsOne)
            {
               r0mm_bX = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_aX_bX);
               r1mm    = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_a1_bX);
               i0mm_bX = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_aX_bX);
               i1mm    = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_a1_b1);
            }
            else if (BetaIsZero)
            {
               r0mm_bX = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_aX_b0);
               r1mm    = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_a1_bX);
               i0mm_bX = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_aX_b0);
               i1mm    = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_a1_b1);
            }
            else
            {
               r0mm_bX = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_aX_bX);
               r1mm    = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_a1_bX);
               i0mm_bX = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_aX_bX);
               i1mm    = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_a1_b1);
            }
         }
         else
         {
            r0mm_b1 = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_aX_bX);
            i0mm_b1 = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_aX_bX);
            if (BetaIsOne)
            {
               r0mm_bX = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_aX_bX);
               r1mm    = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_aX_bX);
               i0mm_bX = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_aX_bX);
               i1mm    = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_aX_bX);
            }
            else if (BetaIsZero)
            {
               r0mm_bX = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_aX_b0);
               r1mm    = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_aX_bX);
               i0mm_bX = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_aX_b0);
               i1mm    = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_aX_bX);
            }
            else
            {
               r0mm_bX = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_aX_bX);
               r1mm    = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_aX_bX);
               i0mm_bX = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_aX_bX);
               i1mm    = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_aX_bX);
            }
         }
@ROUT ATL_cNCmmJIK ATL_cNCmmIJK ATL_cNCmmJIK_c ATL_cNCmmIJK_c
         mm_fixedKcu=Mjoin(Mjoin(Mjoin(NCmm00,Mjoin(0x0x,KB)),TT),0x0x0_aX_bX);
         mmcu = Mjoin(Mjoin(Mjoin(NCmm00,0x0x0),TT),0x0x0_aX_bX);
      }
   }
   else
   {
      if (TB == AtlasNoTrans)
      {
@ROUT ATL_cNCmmJIK_c ATL_cNCmmIJK_c
         ar0 = ai0 = ai1 = ATL_rone;
         i0mm_bX = r0mm_bX = Mjoin(Mjoin(Mjoin(NCmm0,TN),0x0x0),_a1_b0);
         i1mm = i0mm_b1 = Mjoin(Mjoin(Mjoin(NCmm0,TN),0x0x0),_a1_b1);
         r0mm_b1 = r1mm = Mjoin(Mjoin(Mjoin(NCmm0,TN),0x0x0),_a1_bX);
@ROUT ATL_cNCmmJIK ATL_cNCmmIJK
         ar0 = ai0 = ai1 = ralpha;
         if (AlphaIsOne)
         {
            r0mm_b1 = Mjoin(Mjoin(Mjoin(NCmm0,TN),0x0x0),_a1_bX);
            i0mm_b1 = Mjoin(Mjoin(Mjoin(NCmm0,TN),0x0x0),_a1_b1);
            if (BetaIsOne)
            {
               r1mm = r0mm_bX = Mjoin(Mjoin(Mjoin(NCmm0,TN),0x0x0),_a1_bX);
               i1mm = i0mm_bX = Mjoin(Mjoin(Mjoin(NCmm0,TN),0x0x0),_a1_b1);
            }
            else if (BetaIsZero)
            {
               i0mm_bX = r0mm_bX = Mjoin(Mjoin(Mjoin(NCmm0,TN),0x0x0),_a1_b0);
               i1mm = Mjoin(Mjoin(Mjoin(NCmm0,TN),0x0x0),_a1_b1);
               r1mm = Mjoin(Mjoin(Mjoin(NCmm0,TN),0x0x0),_a1_bX);
            }
            else
            {
               i0mm_bX=r1mm=r0mm_bX=Mjoin(Mjoin(Mjoin(NCmm0,TN),0x0x0),_a1_bX);
               i1mm = Mjoin(Mjoin(Mjoin(NCmm0,TN),0x0x0),_a1_b1);
            }
         }
         else
         {
            r0mm_b1 = Mjoin(Mjoin(Mjoin(NCmm0,TN),0x0x0),_aX_bX);
            i0mm_b1 = Mjoin(Mjoin(Mjoin(NCmm0,TN),0x0x0),_aX_bX);
            if (BetaIsOne)
            {
               r1mm = r0mm_bX = Mjoin(Mjoin(Mjoin(NCmm0,TN),0x0x0),_aX_bX);
               i1mm = i0mm_bX = Mjoin(Mjoin(Mjoin(NCmm0,TN),0x0x0),_aX_bX);
            }
            else if (BetaIsZero)
            {
               i0mm_bX = r0mm_bX = Mjoin(Mjoin(Mjoin(NCmm0,TN),0x0x0),_aX_b0);
               i1mm = Mjoin(Mjoin(Mjoin(NCmm0,TN),0x0x0),_aX_bX);
               r1mm = Mjoin(Mjoin(Mjoin(NCmm0,TN),0x0x0),_aX_bX);
            }
            else
            {
               i0mm_bX=r1mm=r0mm_bX=Mjoin(Mjoin(Mjoin(NCmm0,TN),0x0x0),_aX_bX);
               i1mm = Mjoin(Mjoin(Mjoin(NCmm0,TN),0x0x0),_aX_bX);
            }
         }
@ROUT ATL_cNCmmJIK ATL_cNCmmIJK ATL_cNCmmJIK_c ATL_cNCmmIJK_c
         mm_fixedKcu=Mjoin(Mjoin(Mjoin(NCmm00,Mjoin(0x0x,KB)),TN),0x0x0_aX_bX);
         mmcu = Mjoin(Mjoin(Mjoin(NCmm00,0x0x0),TN),0x0x0_aX_bX);
      }
      else if (TB == AtlasConjTrans)
      {
@ROUT ATL_cNCmmJIK_c ATL_cNCmmIJK_c
         ai1 = ar0 = ATL_rnone; ai0 = ATL_rone;
         r0mm_bX = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_aX_b0);
         r0mm_b1 = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_aX_bX);
         r1mm    = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_a1_bX);
         i0mm_bX = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_a1_b0);
         i0mm_b1 = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_a1_b1);
         i1mm    = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_aX_bX);
@ROUT ATL_cNCmmJIK ATL_cNCmmIJK
         ai1 = ar0 = -ralpha; ai0 = ralpha;
         if (AlphaIsOne)
         {
            r0mm_b1 = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_aX_bX);
            i0mm_b1 = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_a1_b1);
            if (BetaIsOne)
            {
               r0mm_bX = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_aX_bX);
               r1mm    = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_a1_bX);
               i0mm_bX = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_a1_b1);
               i1mm    = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_aX_bX);
            }
            else if (BetaIsZero)
            {
               r0mm_bX = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_aX_b0);
               r1mm    = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_a1_bX);
               i0mm_bX = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_a1_b0);
               i1mm    = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_aX_bX);
            }
            else
            {
               r0mm_bX = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_aX_bX);
               r1mm    = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_a1_bX);
               i0mm_bX = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_a1_bX);
               i1mm    = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_aX_bX);
            }
         }
         else
         {
            r0mm_b1 = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_aX_bX);
            i0mm_b1 = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_aX_bX);
            if (BetaIsOne)
            {
               r0mm_bX = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_aX_bX);
               r1mm    = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_aX_bX);
               i0mm_bX = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_aX_bX);
               i1mm    = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_aX_bX);
            }
            else if (BetaIsZero)
            {
               r0mm_bX = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_aX_b0);
               r1mm    = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_aX_bX);
               i0mm_bX = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_aX_b0);
               i1mm    = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_aX_bX);
            }
            else
            {
               r0mm_bX = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_aX_bX);
               r1mm    = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_aX_bX);
               i0mm_bX = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_aX_bX);
               i1mm    = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_aX_bX);
            }
         }
@ROUT ATL_cNCmmJIK ATL_cNCmmIJK ATL_cNCmmJIK_c ATL_cNCmmIJK_c
         mm_fixedKcu=Mjoin(Mjoin(Mjoin(NCmm00,Mjoin(0x0x,KB)),TT),0x0x0_aX_bX);
         mmcu = Mjoin(Mjoin(Mjoin(NCmm00,0x0x0),TT),0x0x0_aX_bX);
      }
      else
      {
@ROUT ATL_cNCmmJIK_c ATL_cNCmmIJK_c
         ar0 = ai0 = ai1 = ATL_rone;
         i0mm_bX = r0mm_bX = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_a1_b0);
         i1mm = i0mm_b1 = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_a1_b1);
         r0mm_b1 = r1mm = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_a1_bX);
@ROUT ATL_cNCmmJIK ATL_cNCmmIJK
         ar0 = ai0 = ai1 = ralpha;
         if (AlphaIsOne)
         {
            r0mm_b1 = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_a1_bX);
            i0mm_b1 = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_a1_b1);
            if (BetaIsOne)
            {
               r1mm = r0mm_bX = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_a1_bX);
               i1mm = i0mm_bX = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_a1_b1);
            }
            else if (BetaIsZero)
            {
               i0mm_bX = r0mm_bX = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_a1_b0);
               i1mm = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_a1_b1);
               r1mm = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_a1_bX);
            }
            else
            {
               i0mm_bX=r1mm=r0mm_bX=Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_a1_bX);
               i1mm = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_a1_b1);
            }
         }
         else
         {
            r0mm_b1 = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_aX_bX);
            i0mm_b1 = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_aX_bX);
            if (BetaIsOne)
            {
               r1mm = r0mm_bX = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_aX_bX);
               i1mm = i0mm_bX = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_aX_bX);
            }
            else if (BetaIsZero)
            {
               i0mm_bX = r0mm_bX = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_aX_b0);
               i1mm = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_aX_bX);
               r1mm = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_aX_bX);
            }
            else
            {
               i0mm_bX=r1mm=r0mm_bX=Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_aX_bX);
               i1mm = Mjoin(Mjoin(Mjoin(NCmm0,TT),0x0x0),_aX_bX);
            }
         }
@ROUT ATL_cNCmmJIK ATL_cNCmmIJK ATL_cNCmmJIK_c ATL_cNCmmIJK_c
         mm_fixedKcu=Mjoin(Mjoin(Mjoin(NCmm00,Mjoin(0x0x,KB)),TT),0x0x0_aX_bX);
         mmcu = Mjoin(Mjoin(Mjoin(NCmm00,0x0x0),TT),0x0x0_aX_bX);
      }
   }

   if (TA == AtlasNoTrans)
   {
      incAk = lda * (KB<<1);
@ROUT ATL_cNCmmJIK ATL_cNCmmJIK_c
      incAm = (MB<<1) - Kb * incAk;
      incAn = -Mb * (MB<<1);
@ROUT ATL_cNCmmIJK ATL_cNCmmIJK_c
      incAn = -Kb * incAk;
      incAm = MB<<1;
@ROUT ATL_cNCmmJIK ATL_cNCmmIJK ATL_cNCmmJIK_c ATL_cNCmmIJK_c
   }
   else
   {
      incAk = KB<<1;
@ROUT ATL_cNCmmJIK ATL_cNCmmJIK_c
      incAm = (lda*MB - Kb*KB)<<1;
      incAn = -lda*(MB<<1)*Mb;
@ROUT ATL_cNCmmIJK ATL_cNCmmIJK_c
      incAn = -Kb * incAk;
      incAm = (MB<<1) * lda;
@ROUT ATL_cNCmmJIK ATL_cNCmmIJK ATL_cNCmmJIK_c ATL_cNCmmIJK_c
   }
   if (TB == AtlasNoTrans)
   {
      incBk = KB<<1;
@ROUT ATL_cNCmmJIK ATL_cNCmmJIK_c
      incBm = -(KB<<1)*Kb;
      incBn = ldb*(NB<<1);
@ROUT ATL_cNCmmIJK ATL_cNCmmIJK_c
      incBn = (ldb*NB - K + kr)<<1;
      incBm = -((Nb * ldb * NB)<<1);
@ROUT ATL_cNCmmJIK ATL_cNCmmIJK ATL_cNCmmJIK_c ATL_cNCmmIJK_c
   }
   else
   {
      incBk = (KB<<1)*ldb;
@ROUT ATL_cNCmmJIK ATL_cNCmmJIK_c
      incBm = -Kb * incBk;
      incBn = NB<<1;
@ROUT ATL_cNCmmIJK ATL_cNCmmIJK_c
      incBn = (NB<<1) - Kb*incBk;
      incBm = -Nb*(NB<<1);
@ROUT ATL_cNCmmJIK ATL_cNCmmIJK ATL_cNCmmJIK_c ATL_cNCmmIJK_c
   }

@ROUT ATL_cNCmmJIK_c ATL_cNCmmIJK_c
   if (AlphaIsOne)
   {
      if (BetaIsOne) geadd = Mjoin(Mjoin(Mjoin(PATL,geadd),_a1),_b1);
      else if (BetaIsZero) geadd = Mjoin(Mjoin(Mjoin(PATL,geadd),_a1),_b0);
      else if (BetaIsReal) geadd = Mjoin(Mjoin(Mjoin(PATL,geadd),_a1),_bXi0);
      else geadd = Mjoin(Mjoin(Mjoin(PATL,geadd),_a1),_bX);
   }
   else if (AlphaIsReal)
   {
      if (BetaIsOne) geadd = Mjoin(Mjoin(Mjoin(PATL,geadd),_aXi0),_b1);
      else if (BetaIsZero) geadd = Mjoin(Mjoin(Mjoin(PATL,geadd),_aXi0),_b0);
      else if (BetaIsReal) geadd=Mjoin(Mjoin(Mjoin(PATL,geadd),_aXi0),_bXi0);
      else geadd = Mjoin(Mjoin(Mjoin(PATL,geadd),_aXi0),_bX);
   }
   else if (BetaIsOne) geadd = Mjoin(Mjoin(Mjoin(PATL,geadd),_aX),_b1);
   else if (BetaIsZero) geadd = Mjoin(Mjoin(Mjoin(PATL,geadd),_aX),_b0);
   else if (BetaIsReal) geadd = Mjoin(Mjoin(Mjoin(PATL,geadd),_aX),_bXi0);
   else geadd = Mjoin(Mjoin(Mjoin(PATL,geadd),_aX),_bX);
   vp = malloc(ATL_Cachelen + ATL_MulBySize(MB * NB));
   ATL_assert(vp);
   @(cc) = ATL_AlignPtr(vp);
@skip if (mr || nr || kr) for (j=MB*NB, i=0; i != j; i++) @(cc)[i] = ATL_rzero;
   if (mr || nr || kr) Mjoin(PATL,gezero)(MB, NB, @(cc), @(ldc));

@ROUT ATL_cNCmmJIK ATL_cNCmmJIK_c
   for (j=Nb; j; j--, a += incAn, b += incBn, c += incCn)
   {
      for (i=Mb; i; i--, a += incAm, b += incBm, c += incCm)
@ROUT ATL_cNCmmIJK ATL_cNCmmIJK_c
   for (i=Mb; i; i--, a += incAm, b += incBm, c += incCm)
   {
      for (j=Nb; j; j--, a += incAn, b += incBn, c += incCn)
@ROUT ATL_cNCmmJIK ATL_cNCmmIJK 
   @define rbe @nrbeta@
   @define ibe @rbeta@
   @define ral @ralpha@
@ROUT ATL_cNCmmJIK_c ATL_cNCmmIJK_c
   @define rbe @ATL_rzero@
   @define ibe @ATL_rzero@
   @define ral @ATL_rone@
@ROUT ATL_cNCmmJIK ATL_cNCmmIJK ATL_cNCmmJIK_c ATL_cNCmmIJK_c
      {
         if (Kb)
         {
            r0mm_bX(MB, NB, KB, ar0, a+1, lda, b+1, ldb, @(rbe), @(cc), @(ldc));
            i0mm_bX(MB, NB, KB, ai0, a+1, lda, b, ldb, @(ibe), @(cc)+1, @(ldc));
            r1mm(MB, NB, KB, @(ral), a, lda, b, ldb, ATL_rnone, @(cc), @(ldc));
            i1mm(MB, NB, KB, ai1, a, lda, b+1, ldb, ATL_rone, @(cc)+1, @(ldc));
            a += incAk;  b += incBk;
            for (k=Kb-1; k; k--, a += incAk, b += incBk)
            {
               r0mm_b1(MB, NB, KB, ar0, a+1, lda, b+1, ldb, ATL_rnone, @(cc), @(ldc));
               i0mm_b1(MB, NB, KB, ai0, a+1, lda, b, ldb, ATL_rone, @(cc)+1, @(ldc));
               r1mm(MB, NB, KB, @(ral), a, lda, b, ldb, ATL_rnone, @(cc), @(ldc));
               i1mm(MB, NB, KB, ai1, a, lda, b+1, ldb, ATL_rone, @(cc)+1, @(ldc));
            }
            if (kr) 
            {
               mmcu(MB, NB, kr, ar0, a+1, lda, b+1, ldb, ATL_rnone, @(cc), @(ldc));
               mmcu(MB, NB, kr, ai0, a+1, lda, b, ldb, ATL_rone, @(cc)+1, @(ldc));
               mmcu(MB, NB, kr, @(ral), a, lda, b, ldb, ATL_rnone, @(cc), @(ldc));
               mmcu(MB, NB, kr, ai1, a, lda, b+1, ldb, ATL_rone, @(cc)+1, @(ldc));
            }
         }
         else if (kr) 
         {
@ROUT ATL_cNCmmJIK ATL_cNCmmIJK 
            if (BetaIsZero) Mjoin(PATL,gezero)(MB, NB, c, ldc);
@ROUT ATL_cNCmmJIK_c ATL_cNCmmIJK_c
            Mjoin(PATL,zero)(MB*NB, cp, 1); /* kill NaN/INF from before */
@ROUT ATL_cNCmmJIK ATL_cNCmmIJK ATL_cNCmmJIK_c ATL_cNCmmIJK_c
            mmcu(MB, NB, kr, ar0, a+1, lda, b+1, ldb, @(rbe), @(cc), @(ldc));
            mmcu(MB, NB, kr, ai0, a+1, lda, b, ldb, @(ibe), @(cc)+1, @(ldc));
            mmcu(MB, NB, kr, @(ral), a, lda, b, ldb, ATL_rnone, @(cc), @(ldc));
            mmcu(MB, NB, kr, ai1, a, lda, b+1, ldb, ATL_rone, @(cc)+1, @(ldc));
         }
@ROUT ATL_cNCmmJIK_c ATL_cNCmmIJK_c
         geadd(MB, NB, alpha, @(cc), @(ldc), beta, c, ldc);
@ROUT ATL_cNCmmJIK ATL_cNCmmIJK ATL_cNCmmJIK_c ATL_cNCmmIJK_c
      }
   }
@ROUT ATL_cNCmmJIK ATL_cNCmmJIK_c
   if (mr && N != nr)
      Mjoin(PATL,NCmmIJK)(TA, TB, mr, N-nr, K, alpha, A+Mb*(incAm+Kb*incAk), 
                          lda, B, ldb, beta, C+Mb*(MB<<1), ldc);
   if (nr)
   {
      for (i=Mb; i; i--, a += incAm, b += incBm, c += incCm)
      {
@ROUT ATL_cNCmmJIK 
         if (BetaIsZero) Mjoin(PATL,gezero)(MB, nr, c, ldc);
@ROUT ATL_cNCmmJIK_c
            Mjoin(PATL,zero)(MB*nr, cp, 1); /* kill NaN/INF from before */
@ROUT ATL_cNCmmJIK ATL_cNCmmJIK_c
         if (Kb)
         {
            mm_fixedKcu(MB, nr, KB, ar0, a+1, lda, b+1, ldb, @(rbe), 
                        @(cc), @(ldc));
            mm_fixedKcu(MB, nr, KB, ai0, a+1, lda, b, ldb, @(ibe), 
                        @(cc)+1, @(ldc));
            mm_fixedKcu(MB, nr, KB, @(ral), a, lda, b, ldb, ATL_rnone, 
                        @(cc), @(ldc));
            mm_fixedKcu(MB, nr, KB, ai1, a, lda, b+1, ldb, ATL_rone, 
                        @(cc)+1, @(ldc));
            a += incAk;  b += incBk;
            for (k=Kb-1; k; k--, a += incAk, b += incBk)
            {
               mm_fixedKcu(MB, nr, KB, ar0, a+1, lda, b+1, ldb, ATL_rnone, 
                           @(cc), @(ldc));
               mm_fixedKcu(MB, nr, KB, ai0, a+1, lda, b, ldb, ATL_rone, 
                           @(cc)+1, @(ldc));
               mm_fixedKcu(MB, nr, KB, @(ral), a, lda, b, ldb, ATL_rnone, 
                           @(cc), @(ldc));
               mm_fixedKcu(MB, nr, KB, ai1, a, lda, b+1, ldb, ATL_rone, 
                           @(cc)+1, @(ldc));
            }
            if (kr) 
            {
               mmcu(MB, nr, kr, ar0, a+1, lda, b+1, ldb, ATL_rnone, @(cc), @(ldc));
               mmcu(MB, nr, kr, ai0, a+1, lda, b, ldb, ATL_rone, @(cc)+1, @(ldc));
               mmcu(MB, nr, kr, @(ral), a, lda, b, ldb, ATL_rnone, @(cc), @(ldc));
               mmcu(MB, nr, kr, ai1, a, lda, b+1, ldb, ATL_rone, @(cc)+1, @(ldc));
            }
         }
         else if (kr) 
         {
            mmcu(MB, nr, kr, ar0, a+1, lda, b+1, ldb, @(rbe), @(cc), @(ldc));
            mmcu(MB, nr, kr, ai0, a+1, lda, b, ldb, @(ibe), @(cc)+1, @(ldc));
            mmcu(MB, nr, kr, @(ral), a, lda, b, ldb, ATL_rnone, @(cc), @(ldc));
            mmcu(MB, nr, kr, ai1, a, lda, b+1, ldb, ATL_rone, @(cc)+1, @(ldc));
         }
@ROUT ATL_cNCmmJIK_c
         geadd(MB, nr, alpha, @(cc), @(ldc), beta, c, ldc);
@ROUT ATL_cNCmmJIK ATL_cNCmmJIK_c
      }
      if (mr)  /* cleanup small mr x nr block of C */
      {
         c = C + ((Mb*MB + ldc*Nb*NB)<<1);
         a = A + Mb*(incAm+Kb*incAk);
         b = B + Nb*( incBn+(Mb*(incBm+Kb*incBk)) );
@ROUT ATL_cNCmmJIK 
         if (BetaIsZero) Mjoin(PATL,gezero)(mr, nr, c, ldc);
@ROUT ATL_cNCmmJIK_c
         Mjoin(PATL,zero)(MB*nr, cp, 1); /* kill NaN/INF from before */
@ROUT ATL_cNCmmJIK ATL_cNCmmJIK_c
         if (Kb)
         {
            mm_fixedKcu(mr, nr, KB, ar0, a+1, lda, b+1, ldb, @(rbe), 
                        @(cc), @(ldc));
            mm_fixedKcu(mr, nr, KB, ai0, a+1, lda, b, ldb, @(ibe), 
                        @(cc)+1, @(ldc));
            mm_fixedKcu(mr, nr, KB, @(ral), a, lda, b, ldb, ATL_rnone, 
                        @(cc), @(ldc));
            mm_fixedKcu(mr, nr, KB, ai1, a, lda, b+1, ldb, ATL_rone, 
                        @(cc)+1, @(ldc));
            a += incAk;  b += incBk;
            for (k=Kb-1; k; k--, a += incAk, b += incBk)
            {
               mm_fixedKcu(mr, nr, KB, ar0, a+1, lda, b+1, ldb, ATL_rnone, 
                           @(cc), @(ldc));
               mm_fixedKcu(mr, nr, KB, ai0, a+1, lda, b, ldb, ATL_rone, 
                           @(cc)+1, @(ldc));
               mm_fixedKcu(mr, nr, KB, @(ral), a, lda, b, ldb, ATL_rnone, 
                           @(cc), @(ldc));
               mm_fixedKcu(mr, nr, KB, ai1, a, lda, b+1, ldb, ATL_rone, 
                           @(cc)+1, @(ldc));
            }
            if (kr) 
            {
               mmcu(mr, nr, kr, ar0, a+1, lda, b+1, ldb, ATL_rnone, @(cc), @(ldc));
               mmcu(mr, nr, kr, ai0, a+1, lda, b, ldb, ATL_rone, @(cc)+1, @(ldc));
               mmcu(mr, nr, kr, @(ral), a, lda, b, ldb, ATL_rnone, @(cc), @(ldc));
               mmcu(mr, nr, kr, ai1, a, lda, b+1, ldb, ATL_rone, @(cc)+1, @(ldc));
            }
         }
         else if (kr) 
         {
            mmcu(mr, nr, kr, ar0, a+1, lda, b+1, ldb, @(rbe), @(cc), @(ldc));
            mmcu(mr, nr, kr, ai0, a+1, lda, b, ldb, @(ibe), @(cc)+1, @(ldc));
            mmcu(mr, nr, kr, @(ral), a, lda, b, ldb, ATL_rnone, @(cc), @(ldc));
            mmcu(mr, nr, kr, ai1, a, lda, b+1, ldb, ATL_rone, @(cc)+1, @(ldc));
         }
@ROUT ATL_cNCmmJIK_c
         geadd(mr, nr, alpha, @(cc), @(ldc), beta, c, ldc);
@ROUT ATL_cNCmmJIK ATL_cNCmmJIK_c
      }
   }
@ROUT ATL_cNCmmIJK ATL_cNCmmIJK_c
   if (mr)  /* M-loop remainder */
   {
      for (j=Nb; j; j--, a += incAn, b += incBn, c += incCn)
      {
@ROUT ATL_cNCmmIJK 
         if (BetaIsZero) Mjoin(PATL,gezero)(mr, NB, c, ldc);
@ROUT ATL_cNCmmIJK_c
         Mjoin(PATL,zero)(MB*NB, cp, 1); /* kill NaN/INF from before */
@ROUT ATL_cNCmmIJK ATL_cNCmmIJK_c
         if (Kb)
         {
            mm_fixedKcu(mr, NB, KB, ar0, a+1, lda, b+1, ldb, @(rbe), 
                        @(cc), @(ldc));
            mm_fixedKcu(mr, NB, KB, ai0, a+1, lda, b, ldb, @(ibe), 
                        @(cc)+1, @(ldc));
            mm_fixedKcu(mr, NB, KB, @(ral), a, lda, b, ldb, ATL_rnone, 
                        @(cc), @(ldc));
            mm_fixedKcu(mr, NB, KB, ai1, a, lda, b+1, ldb, ATL_rone, 
                        @(cc)+1, @(ldc));
            a += incAk;  b += incBk;
            for (k=Kb-1; k; k--, a += incAk, b += incBk)
            {
               mm_fixedKcu(mr, NB, KB, ar0, a+1, lda, b+1, ldb, ATL_rnone, 
                           @(cc), @(ldc));
               mm_fixedKcu(mr, NB, KB, ai0, a+1, lda, b, ldb, ATL_rone, 
                           @(cc)+1, @(ldc));
               mm_fixedKcu(mr, NB, KB, @(ral), a, lda, b, ldb, ATL_rnone, 
                           @(cc), @(ldc));
               mm_fixedKcu(mr, NB, KB, ai1, a, lda, b+1, ldb, ATL_rone, 
                           @(cc)+1, @(ldc));
            }
            if (kr) 
            {
               mmcu(mr, NB, kr, ar0, a+1, lda, b+1, ldb, ATL_rnone, @(cc), @(ldc));
               mmcu(mr, NB, kr, ai0, a+1, lda, b, ldb, ATL_rone, @(cc)+1, @(ldc));
               mmcu(mr, NB, kr, @(ral), a, lda, b, ldb, ATL_rnone, @(cc), @(ldc));
               mmcu(mr, NB, kr, ai1, a, lda, b+1, ldb, ATL_rone, @(cc)+1, @(ldc));
            }
         }
         else if (kr)
         {
            mmcu(mr, NB, kr, ar0, a+1, lda, b+1, ldb, @(rbe), @(cc), @(ldc));
            mmcu(mr, NB, kr, ai0, a+1, lda, b, ldb, @(ibe), @(cc)+1, @(ldc));
            mmcu(mr, NB, kr, @(ral), a, lda, b, ldb, ATL_rnone, @(cc), @(ldc));
            mmcu(mr, NB, kr, ai1, a, lda, b+1, ldb, ATL_rone, @(cc)+1, @(ldc));
         }
@ROUT ATL_cNCmmIJK_c
         geadd(mr, NB, alpha, @(cc), @(ldc), beta, c, ldc);
@ROUT ATL_cNCmmIJK ATL_cNCmmIJK_c
      }
   }
   if (nr) Mjoin(PATL,NCmmJIK)(TA, TB, M, nr, K, alpha, A, lda, 
                               B+Nb*(incBn+Kb*incBk), ldb,
                               beta, C+Nb*(NB<<1)*ldc, ldc);
@ROUT ATL_cNCmmJIK_c ATL_cNCmmIJK_c
   free(vp);
@ROUT ATL_cNCmmJIK ATL_cNCmmIJK ATL_cNCmmJIK_c ATL_cNCmmIJK_c
   return(0);
}
@ROUT ATL_resfind
@extract -b @(topd)/gen.inc what=cw @(cw99)
PrintUsage(char *nam)
{
   fprintf(stderr, "USAGE: %s <resfile1> .... <resfileN>\n", nam);
}
#define NTIM 3 
#define TOLERANCE 1.2
double GetMflop(char *fnam)
{
   int i;
   double mflop[NTIM], t0;
   FILE *fp;

   fp = fopen(fnam, "r");
   assert(fp);
   for (i=0; i != NTIM; i++)
   {
      assert( fscanf(fp, "%lf", &mflop[i]) );
   }
   fclose(fp);

   t0 = GetAvg(NTIM, TOLERANCE, mflop);
   if (t0 == -1.0)
   {
      fprintf(stderr, "file=%s: rerun with higher reps; variation exceeds tolerence\n", fnam);
      exit(-1);
   }
   return(t0);
}

void ATL_resfind(FILE *fpout, int nfiles, char **files)
{
   char c1, pre, ln[64], *spc="           ";
   int i, j, k;
   int nb, mu, nu, ku, lat, muladd;
   double mflop;

   c1  = files[0][0];
   pre = files[0][1];
   fprintf(fpout, "%catlres = [\n", pre);
   for(i=0; i != nfiles; i++)
   {
      mflop = GetMflop(files[i]);
      assert(files[i][0] == c1  &&  files[i][1] == pre);
      assert(files[i][2] == 'N' && files[i][3] == 'B');

      for (j=4; isdigit(files[i][j]); j++) ln[j-4] = files[i][j];
      ln[j-4] = '\0';
      nb = atoi(ln);
      assert(files[i][j] == '_');

      for (j++, k=j; isdigit(files[i][j]); j++) ln[j-k] = files[i][j];
      ln[j-k] = '\0';
      mu = atoi(ln);
      assert(files[i][j] == 'x');

      for (j++, k=j; isdigit(files[i][j]); j++) ln[j-k] = files[i][j];
      ln[j-k] = '\0';
      nu = atoi(ln);
      assert(files[i][j] == 'x');

      for (j++, k=j; isdigit(files[i][j]); j++) ln[j-k] = files[i][j];
      ln[j-k] = '\0';
      ku = atoi(ln);
      assert(files[i][j] == '_');

      for (j++, k=j; isdigit(files[i][j]); j++) ln[j-k] = files[i][j];
      ln[j-k] = '\0';
      muladd = atoi(ln);
      assert(files[i][j] == '-');

      for (j++, k=j; isdigit(files[i][j]); j++) ln[j-k] = files[i][j];
      ln[j-k] = '\0';
      lat = atoi(ln);
      assert(files[i][j] == '.');

      fprintf(fpout, "%s%2d, %2d, %2d, %2d, %2d, %1d, %.2f;\n", 
              spc, nb, mu, nu, ku, lat, muladd, mflop);
   }
   fprintf(fpout, "          ];\n");
}

void GetMesh(FILE *fpout, char pre)
{
   fprintf(fpout, "if (0)\n");
   fprintf(fpout, "   m = 0; n = 0;\n");
   fprintf(fpout, "   for k=1:length(datlres(:,1))\n");
      fprintf(fpout, "   if (datlres(k,2) > m)\n");
         fprintf(fpout, "   m = datlres(k,2);\n");
      fprintf(fpout, "   end\n");
      fprintf(fpout, "   if (datlres(k,3) > n)\n");
         fprintf(fpout, "   n = datlres(k,3);\n");
      fprintf(fpout, "   end\n");
   fprintf(fpout, "   end\n");
   fprintf(fpout, "   \n");
   fprintf(fpout, "   for i=1:m\n");
     fprintf(fpout, "   x(i) = i;\n");
   fprintf(fpout, "   end\n");
   fprintf(fpout, "   for j=1:n\n");
     fprintf(fpout, "   y(j) = j;\n");
   fprintf(fpout, "   end\n");
   fprintf(fpout, "   mf(1:m,1:n) = 0.0;\n");
   fprintf(fpout, "   \n");
   fprintf(fpout, "   ii = 1\n");
   fprintf(fpout, "   jj = 1\n");
   fprintf(fpout, "   for i=1:m\n");
   fprintf(fpout, "      for j=1:n\n");
   fprintf(fpout, "         for k=1:length(datlres(:,1))\n");
   fprintf(fpout, "            ii = datlres(k,2);\n");
   fprintf(fpout, "            jj = datlres(k,3);\n");
   fprintf(fpout, "            if (ii == i && jj == j)\n");
   fprintf(fpout, "               if (datlres(k,7) > mf(i,j))\n");
   fprintf(fpout, "                  mf(i,j) = datlres(k,7);\n");
   fprintf(fpout, "               end\n");
   fprintf(fpout, "            end\n");
   fprintf(fpout, "         end\n");
   fprintf(fpout, "      end\n");
   fprintf(fpout, "      grid \"on\"\n");
   fprintf(fpout, "      mesh(x, y, mf);\n");
   fprintf(fpout, "   end\n");
   fprintf(fpout, "end\n");
}
 
int main(int nargs, char **args)
{
   assert(nargs > 1);
   ATL_resfind(stdout, nargs-1, args+1);
   GetMesh(stdout, args[1][1]);
   return(0);
}
@ROUT printblk
@extract -b @(topd)/gen.inc what=cw @(cw00)
#include "atlas_misc.h"
#include "atlas_lvl3.h"
#include "atlas_mv.h"
#include "atlas_r1.h"

int main(int nargs, char **args)
{
   int m, n, lda=4;
   TYPE a[4];

   printf("\nGEMM: NB=%d, lat=%d, mu=%d, nu=%d, ku=%d\n\n", NB, ATL_mmLAT,
          ATL_mmMU, ATL_mmNU, ATL_mmKU);

   ATL_GetPartMVN(a, lda, &m, &n);
   printf("mvN  block = %d x %d; mu=%d, nu=%d\n", m, n, ATL_mvNMU, ATL_mvNNU);
   ATL_GetPartMVT(a, lda, &m, &n);
   printf("mvT  block = %d x %d; mu=%d, nu=%d\n\n", m, n, ATL_mvTMU, ATL_mvTNU);

   ATL_GetPartSYMV(a, lda, &m, &n);
   printf("symv block = %d x %d\n\n", m, n);

   ATL_GetPartR1(a, lda, m, n);
   printf("ger  block = %d x %d; mu=%d, nu=%d\n\n", m, n, ATL_r1MU, ATL_r1NU);

   return(0);
}
@ROUT findNT
#ifdef ATL_NCPU

#include "atlas_misc.h"
#include "assert.h"

void PrintUsage(char *nam)
{
   fprintf(stderr, "\nUSAGE: %s [-o <outfile>]\n", nam);
   exit(-1);
}

void GetFlags(int nargs, char **args, FILE **fpout)
{
   int i;

   *fpout=stdout;
   for (i=1; i < nargs; i++)
   {
      if (args[i][0] != '-') PrintUsage(args[0]);
      switch(args[i][1])
      {
      case 'o':
         *fpout = fopen(args[++i], "w");
         assert(*fpout);
         break;
      default:
         PrintUsage(args[0]);
      }
   }
}

void getLaunchOrder(int P, int *lo)
{
   int i, j, k, stop, dest;

   for (i=0; (1<<i) < P; i++)
   lo[0] = 0;
   k = 1;
   for (i--; i >= 0; i--)
   {
      stop = k;
      for (j=0; j < stop; j++)
      {
         dest = lo[j] + (1<<i);
         if (dest < P)
            lo[k++] = dest;
         if (k == P)
            return;
      }
   }
}
int main(int nargs, char **args)
{
   FILE *fpout;
   int i, j, k;
   #if ATL_NCPU > 0
      int lo[ATL_NCPU];
   #endif
   GetFlags(nargs, args, &fpout);

   fprintf(fpout, "#ifndef ATLAS_NTHREADS_H\n   #define ATLAS_NTHREADS_H\n\n");
/*
 * I presently build Antoine's pthread implementation even on windows for
 * comparison purposes.  Need to get rid of 00 when this is no longer the
 * case.
 */
   fprintf(fpout, "/* Get rid of 00 if you don't want to build pthreads */\n");
   fprintf(fpout, 
      "   #ifndef ATL_WINTHREADS00\n      #include \"pthread.h\"\n   #endif\n");
   #if ATL_NCPU != 0
      fprintf(fpout, "   #define ATL_NTHREADS %d\n", ATL_NCPU);
      for (i=0; (1<<i) < ATL_NCPU; i++);
      fprintf(fpout, "   #define ATL_NTHRPOW2 %d\n", i);
      getLaunchOrder(ATL_NCPU, lo);
      fprintf(fpout, "   #ifdef ATL_LAUNCHORDER\n");
      fprintf(fpout, "       static int ATL_launchorder[%d] = {0", ATL_NCPU);
      for (i=1; i < ATL_NCPU; i++)
         fprintf(fpout, ",%d", lo[i]);
      fprintf(fpout, "};\n   #endif\n");
   #else
      fprintf(fpout, "   #define ATL_NTHREADS 4\n");
      fprintf(fpout, "   #define ATL_NTHRPOW2 2\n")
      fprintf(fpout, "   #ifdef ATL_LAUNCHORDER\n");
      fprintf(fpout, "       static int ATL_launchorder[4] = {0,2,1,3}\n");
      fprintf(fpout, "   #endif\n");
   #endif
   fprintf(fpout, "\n#endif\n");
   fclose(fpout);
   return(0);
}
#endif
@ROUT userindex
@extract -b @(topd)/gen.inc what=cw @(cw00)
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
void PrintUsage(char *nam)
{
   fprintf(stderr, "USAGE %s -p <pre>\n", nam);
   exit(-1);
}

void GetFlags(int nargs, char **args, char *pre)
{
   char ch;

   *pre = 'd';
   if (nargs > 1)
   {
      if (nargs != 3) PrintUsage(args[0]);
      if (args[1][0] != '-' || args[1][1] != 'p') PrintUsage(args[0]);
      ch = args[2][0];
      if (ch == 'Z') ch = 'z';
      else if (ch == 'C') ch = 'c';
      else if (ch == 'D') ch = 'd';
      else if (ch == 'S') ch = 's';
      else if (ch != 's' && ch != 'd' && ch != 'c' && ch != 'z')
         PrintUsage(args[0]);
      *pre = ch;
   }
}

#ifdef ATL_NOUSERMM
void CreateIndex(char pre)
{
   char fnam[16];
   FILE *fpout;
   sprintf(fnam, "%ccases.dsc", pre);
   fpout = fopen(fnam, "w")
   fprintf(fpout, "DUMMY INDEX FILE TO AVOID USER KERNELS\n0\n");
   fclose(fpout);
}
#else
void CreateIndex(char pre)
{
   char ln[512];
   char fnams[8][256];
   int n=1, i, j, itmp;

   sprintf(fnams[0], "CASES/%ccases.0", pre);
   #ifdef ATL_SSE1
      #ifdef ATL_SSE2
         if (pre == 'd' || pre == 'z')
            sprintf(fnams[n++], "%ccases.SSE", pre);
      #endif
      if (pre == 's' || pre == 'c')
         sprintf(fnams[n++], "%ccases.SSE", pre);
   #elif (defined(ATL_3DNow) && defined(ATL_3DNowFLOPS))
      if (pre == 's' || pre == 'c')
         sprintf(fnams[n++], "%ccases.3DN", pre);
   #endif
   sprintf(fnams[n++], "%ccases.flg", pre);
/*
 * substitute GOODGCC for gcc in compiler lines
 */
   for (i=1; i < n; i++)
   {
      sprintf(ln, "make %s flagfile=%s\n", fnams[i], fnams[i]);
      assert(system(ln) == 0);
   }
@beginskip
   sprintf(ln, "make FindFlagCases pre=%c outfile=%ccases.tmp\n", pre, pre);
   assert(system(ln) == 0);
@endskip
   itmp = n;

   j = sprintf(ln, "./xusercomb -o %ccases.dsc -i %d", pre, n);
   assert(n <= 8);
   for (i=0; i < n; i++) j += sprintf(ln+j, " %s", fnams[i]);
   sprintf(ln+j, "\n");
   fprintf(stdout, "%s", ln);
   assert(system(ln) == 0);
   remove(fnams[itmp]);
}
#endif

int main(int nargs, char **args)
/*
 * Creates system-dependent user matmul index file
 */
{
   char pre;
   GetFlags(nargs, args, &pre);
   CreateIndex(pre);
   return(0);
}

@ROUT usercomb
@extract -b @(topd)/gen.inc what=cw @(cw00)
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <string.h>
#include <ctype.h>

@extract -b @(basd)/atlas.base rout=usercase

void CombineFiles(char *fout, int nfiles, char **fnams)
{
   char tnam[256], ln[512];
   int i, j, n, nn;
   FILE *fpout, *fpin;

   assert(tmpnam(tnam));
   for (n=i=0; i < nfiles; i++) n += NumUserCases0(fnams[i]);

   fpout = fopen(tnam, "w");
   assert(fpout);
   fprintf(fpout, "<ID> <flag> <mb> <nb> <kb> <muladd> <lat> <mu> <nu> <ku> <rout> \"<Contributer>\"\n");
   fprintf(fpout, "%d\n", n);
   for (i=0; i < nfiles; i++)
   {
      fpin = fopen(fnams[i], "r");
      if (fpin)
      {
         assert(fgets(ln, 512, fpin));
         assert(fgets(ln, 512, fpin));
         assert(sscanf(ln, " %d", &nn) == 1);
         for (j=0; j < nn; j++)
         {
            assert(fgets(ln, 512, fpin));
            fputs(ln, fpout);
            if (LineIsCont(ln))
            {
               assert(fgets(ln, 512, fpin));
               fputs(ln, fpout);
               assert(fgets(ln, 512, fpin));
               fputs(ln, fpout);
            }
         }
         fclose(fpin);
      }
      else
      {
         fprintf(stderr, 
                 "COMBFILES WARNING: file %s not found / not readable!!\n",
                 
                 fnams[i]);
      }
   }
   fclose(fpout);
   remove(fout);
   sprintf(ln, "cp %s %s\n", tnam, fout);
   assert(system(ln) == 0);
   remove(tnam);
}

void PrintUsage(char *nam)
{
   fprintf(stderr, "USAGE: %s -o <outfile> -i <Nin> <infile1> ... <infileN>\n",
           nam);
   exit(-1);
}

void GetFlags(int nargs, char **args, char **fout, int *nfiles, char ***fnams0)
{
   int i, j, n;
   char **fnams;

   *nfiles = -1;
   *fout = NULL;
   *fnams0 = NULL;
   for (i=1; i < nargs; i++)
   {
      if (args[i][0] != '-') PrintUsage(args[0]);
      switch(args[i][1])
      {
      case 'o': /* outfile */
         *fout = args[++i];
         break;
      case 'i': /* infiles */
         n = atoi(args[++i]);
         assert(n > 0);
         assert(nargs-i >= n);
         fnams = malloc(n * sizeof(char *));
         assert(fnams);
         for(j=0; j < n; j++) fnams[j] = args[++i];
         *nfiles = n;
         *fnams0 = fnams;
         break;
      default:
         PrintUsage(args[0]);
      }
   }
   assert(*fout);
   assert(*fnams0);
}

int main(int nargs, char **args)
{
   char *fnamout, **fnams;
   int nfiles;

   GetFlags(nargs, args, &fnamout, &nfiles, &fnams);
   CombineFiles(fnamout, nfiles, fnams);
   free(fnams);
   return(0);
}
@ROUT userflag
@extract -b @(topd)/gen.inc what=cw @(cw00)
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <string.h>
#include <ctype.h>
#include <stddef.h>

@extract -b @(basd)/atlas.base rout=usercase

void GoGetThem(char *infile, char *outfile)
{
   char ln[512], ln2[512], tnam[256], MCC[256], MMFLAGS[256];
   char *chkfile = "FlagCheck.c", *sp, *sp2;
   FILE *fpin, *fpout;
   int i, j, n, nmin=0, good;
   int wass;

   fpout = fopen(chkfile, "w");
   assert(fpout);
   fprintf(fpout, "int main(){}\n");
   fclose(fpout);
   n = NumUserCases0(infile);
   fpin = fopen(infile, "r");
   assert(fpin);
   assert(tmpnam(tnam));
   fpout = fopen(tnam, "w");
   assert(fpout);
   assert(fgets(ln, 512, fpin));
   assert(fgets(ln, 512, fpin));
   for (i=0; i < n; i++)
   {
      wass = 0;
      assert(fgets(ln, 512, fpin));
      if (LineIsCont(ln))
      {
         assert(fgets(MCC, 256, fpin));
         assert(fgets(MMFLAGS, 256, fpin));
         sprintf(ln2, "%s %s -c -DATL_BETA=1 %s\n", MCC, MMFLAGS, chkfile);
/*
 *       Substitute -x c for -x assembler or -x assembler-with-cpp
 */
         if (sp = strstr(ln2, "assembler"))
         {
            sp2 = strstr(ln2, "-x");
            if (sp2 && ((ptrdiff_t) sp2) < ((ptrdiff_t) sp))
            {
               for (sp2 += 2; sp2 != sp; sp2++)
                  if (!isspace(*sp2)) break;
               if (sp2 == sp)
               {
                  wass = 1;
                  if (strstr(sp, "assembler-with-cpp"))
                  {
                     wass = 2;
                     for (j=1; j != 18; j++) sp[j] = ' ';
                  }
                  else for (j=1; j != 9; j++) sp[j] = ' ';
                  sp[0] = 'c';
               }
            }
         }
         for (j=0; ln2[j]; j++) if (ln2[j] == '\n') ln2[j] = ' ';
         ln2[j-1] = '\n';
         fprintf(stdout, "%s", ln2);
         if (!system(ln2))
         {
            if (wass)
            {
               sp[ 0] = 'a';
               sp[ 1] = 's';
               sp[ 2] = 's';
               sp[ 3] = 'e';
               sp[ 4] = 'm';
               sp[ 5] = 'b';
               sp[ 6] = 'l';
               sp[ 7] = 'e';
               sp[ 8] = 'r';
               if (wass > 1)
               {
                  sp[ 9] = '-';
                  sp[10] = 'w';
                  sp[11] = 'i';
                  sp[12] = 't';
                  sp[13] = 'h';
                  sp[14] = '-';
                  sp[15] = 'c';
                  sp[16] = 'p';
                  sp[17] = 'p';
               }
            }
            fputs(ln, fpout);
            fputs(MCC, fpout);
            fputs(MMFLAGS, fpout);
         }
         else nmin--;
      }
      else fputs(ln, fpout);
   }
   fclose(fpin);
   fclose(fpout);
/*
 * Now, create standard-style file with surviving routines
 */
   fpin = fopen(tnam, "r");
   assert(fpin);
   fpout = fopen(outfile, "w");
   assert(fpout);
   n += nmin;
   fprintf(fpout, "\n%d\n", n);
   for (i=0; i < n; i++)
   {
      assert(fgets(ln, 512, fpin));
      fputs(ln, fpout);
      if (LineIsCont(ln))
      {
         assert(fgets(ln, 512, fpin));
         fputs(ln, fpout);
         assert(fgets(ln, 512, fpin));
         fputs(ln, fpout);
      }
   }
   fclose(fpin);
   fclose(fpout);
   remove(tnam);
   sprintf(tnam, "%s", chkfile);
   for (i=0; tnam[i]; i++);
   for (i--; i > 0; i--)
   {
      if (tnam[i] == 'c')
      {
         tnam[i] = 'o';
         break;
      }
   }
   remove(tnam);
}
void PrintUsage(char *nam)
{
   fprintf(stderr, "USAGE: %s -o <outfile> -i <infile>\n", nam);
   exit(-1);
}

void GetFlags(int nargs, char **args, char **infile, char **outfile)
{
   int i;

   *infile = "CASES/dcases.flg";
   *outfile = "dcases.gfg";

   for (i=1; i < nargs; i++)
   {
      if (args[i][0] != '-') PrintUsage(args[0]);
      switch(args[i][1])
      {
      case 'o':
         *outfile = args[++i];
         break;
      case 'i':
         *infile = args[++i];
         break;
      default:
         PrintUsage(args[0]);
      }
   }
}

int main(int nargs, char **args)
/*
 * Eliminates compiler/flag combos that don't work, 
 * NOTE: infile & outfile can be same
 */
{
   char *infile, *outfile;
   GetFlags(nargs, args, &infile, &outfile);
   GoGetThem(infile, outfile);
   return(0);
}
@ROUT atlas_waitfile
#include <stdio.h>
#include <stdlib.h>

void PrintUsage(char *nam)
{
   fprintf(stderr, "\n\nUSAGE: %s -f <filename> [-s <nsec>]\n\n", nam);
   exit(-1);
}

void GetFlags(int nargs, char **args, int *nsec, char **fnam)
{
   int i;

   *nsec = 5;
   *fnam = NULL;
   for (i=1; i < nargs; i++)
   {
      if (args[i][0] != '-') PrintUsage(args[0]);
      switch(args[i][1])
      {
      case 'f':
         *fnam = args[++i];
         break;
      case 's':
         *nsec = atoi(args[++i]);
         break;
      default:
         PrintUsage(args[0]);
      }
   }
   if (*fnam == NULL) PrintUsage(args[0]);
}

int WaitForIt(int nsec, char *fnam)
/*
 * only probe for file once every 1/5 of a second to avoid beating the crap
 * out of NFS server 
 */
{
   FILE *fp;
   double t0, t1, dsec=(double)nsec, dwait;
   double ATL_walltime(void);

   fp = fopen(fnam, "r");
   if (!fp)
   {
      t0 = ATL_walltime();
      do
      {
         t1 = ATL_walltime();
         while(ATL_walltime()-t1 < 0.2);
         if (ATL_walltime()-t0 > dsec) return(1);
         fp = fopen(fnam, "r");
      }
      while(!fp);
   }
   fclose(fp);
   return(0);
}

int main(int nargs, char **args)
/*
 * This routine waits at last nsecs for a file to appear; used to get
 * around NFS probs, particularly when cross-compiling
 */
{
   int nsec, i;
   char *fnam;

   GetFlags(nargs, args, &nsec, &fnam);
   i = WaitForIt(nsec, fnam);
   if (i) fprintf(stderr, "\n\nTimeout waiting for file %s!!\n\n", fnam);
   return(0);
}
@ROUT atlas_cblastypealias.h
#ifdef SREAL
   #include "atlas_cblassalias.h"
#elif defined(DREAL)
   #include "atlas_cblasdalias.h"
#elif defined(SCPLX)
   #include "atlas_cblascalias.h"
#elif defined(DCPLX)
   #include "atlas_cblaszalias.h"
#endif
@ROUT dlp1000
cc
cc    This program modified by R. Clint Whaley to call the standard
cc    LAPACK factor & solve, for inclusion in ATLAS 6/05/00
cc
      double precision a(1001,1000),b(1000),x(1000)
      double precision time(6),cray,ops,total,norma,normx
      double precision resid,residn,eps,epslon
      double precision ftime00
      external ftime00
      integer ipvt(1000)
      lda = 1001
c
c     this program was updated on 10/12/92 to correct a
c     problem with the random number generator. The previous
c     random number generator had a short period and produced
c     singular matrices occasionally.
c
      n = 1000
      cray = .056
      write(6,1)
    1 format(' Please send the results of this run to:'//
     $       ' Jack J. Dongarra'/
     $       ' Computer Science Department'/
     $       ' University of Tennessee'/
     $       ' Knoxville, Tennessee 37996-1300'//
     $       ' Fax: 615-974-8296'//
     $       ' Internet: dongarra@cs.utk.edu'/)
      ops = (2.0d0*dfloat(n)**3)/3.0d0 + 2.0d0*dfloat(n)**2
c
         call matgen(a,lda,n,b,norma)
c
c******************************************************************
c******************************************************************
c        you should replace the call to dgefa and dgesl
c        by calls to your linear equation solver.
c******************************************************************
c******************************************************************
c
         t1 = ftime00()
cclint         call dgefa(a,lda,n,ipvt,info)
         call dgetrf(n, n, a, lda, ipvt, info)
         time(1) = ftime00() - t1
         t1 = ftime00()
cclint         call dgesl(a,lda,n,ipvt,b,0)
         call dgetrs('NoTrans', n, 1, A, lda, ipvt, B, max(1,n), info)
         time(2) = ftime00() - t1
         total = time(1) + time(2)
c******************************************************************
c******************************************************************
c
c     compute a residual to verify results.
c
         do 10 i = 1,n
            x(i) = b(i)
   10    continue
         call matgen(a,lda,n,b,norma)
         do 20 i = 1,n
            b(i) = -b(i)
   20    continue
         call dmxpy(n,b,n,lda,x,a)
         resid = 0.0
         normx = 0.0
         do 30 i = 1,n
            resid = dmax1( resid, dabs(b(i)) )
            normx = dmax1( normx, dabs(x(i)) )
   30    continue
         eps = epslon(1.0d0)
         residn = resid/( n*norma*normx*eps )
         write(6,40)
   40    format('     norm. resid      resid           machep',
     $          '         x(1)          x(n)')
         write(6,50) residn,resid,eps,x(1),x(n)
   50    format(1p5e16.8)
c
         write(6,60) n
   60    format(//'    times are reported for matrices of order ',i5)
         write(6,70)
   70    format(6x,'factor',5x,'solve',6x,'total',5x,'mflops',7x,'unit',
     $         6x,'ratio')
c
         time(3) = total
         time(4) = ops/(1.0d6*total)
         time(5) = 2.0d0/time(4)
         time(6) = total/cray
         write(6,80) lda
   80    format(' times for array with leading dimension of',i4)
         write(6,110) (time(i),i=1,6)
  110    format(6(1pe11.3))
         write(6,*)' end of tests -- this version dated 10/12/92'
c
      stop
      end
      subroutine matgen(a,lda,n,b,norma)
      integer lda,n,init(4),i,j
      double precision a(lda,1),b(1),norma,ran
c
      init(1) = 1
      init(2) = 2
      init(3) = 3
      init(4) = 1325
      norma = 0.0
      do 30 j = 1,n
         do 20 i = 1,n
            a(i,j) = ran(init) - .5
            norma = dmax1(dabs(a(i,j)), norma)
   20    continue
   30 continue
      do 35 i = 1,n
          b(i) = 0.0
   35 continue
      do 50 j = 1,n
         do 40 i = 1,n
            b(i) = b(i) + a(i,j)
   40    continue
   50 continue
      return
      end
      subroutine dgefa(a,lda,n,ipvt,info)
      integer lda,n,ipvt(1),info
      double precision a(lda,1)
c
c     dgefa factors a double precision matrix by gaussian elimination.
c
c     dgefa is usually called by dgeco, but it can be called
c     directly with a saving in time if  rcond  is not needed.
c     (time for dgeco) = (1 + 9/n)*(time for dgefa) .
c
c     on entry
c
c        a       double precision(lda, n)
c                the matrix to be factored.
c
c        lda     integer
c                the leading dimension of the array  a .
c
c        n       integer
c                the order of the matrix  a .
c
c     on return
c
c        a       an upper triangular matrix and the multipliers
c                which were used to obtain it.
c                the factorization can be written  a = l*u  where
c                l  is a product of permutation and unit lower
c                triangular matrices and  u  is upper triangular.
c
c        ipvt    integer(n)
c                an integer vector of pivot indices.
c
c        info    integer
c                = 0  normal value.
c                = k  if  u(k,k) .eq. 0.0 .  this is not an error
c                     condition for this subroutine, but it does
c                     indicate that dgesl or dgedi will divide by zero
c                     if called.  use  rcond  in dgeco for a reliable
c                     indication of singularity.
c
c     linpack. this version dated 08/14/78 .
c     cleve moler, university of new mexico, argonne national lab.
c
c     subroutines and functions
c
c     blas daxpy,dscal,idamax
c
c     internal variables
c
      double precision t
      integer idamax,j,k,kp1,l,nm1
c
c
c     gaussian elimination with partial pivoting
c
      info = 0
      nm1 = n - 1
      if (nm1 .lt. 1) go to 70
      do 60 k = 1, nm1
         kp1 = k + 1
c
c        find l = pivot index
c
         l = idamax(n-k+1,a(k,k),1) + k - 1
         ipvt(k) = l
c
c        zero pivot implies this column already triangularized
c
         if (a(l,k) .eq. 0.0d0) go to 40
c
c           interchange if necessary
c
            if (l .eq. k) go to 10
               t = a(l,k)
               a(l,k) = a(k,k)
               a(k,k) = t
   10       continue
c
c           compute multipliers
c
            t = -1.0d0/a(k,k)
            call dscal(n-k,t,a(k+1,k),1)
c
c           row elimination with column indexing
c
            do 30 j = kp1, n
               t = a(l,j)
               if (l .eq. k) go to 20
                  a(l,j) = a(k,j)
                  a(k,j) = t
   20          continue
               call daxpy(n-k,t,a(k+1,k),1,a(k+1,j),1)
   30       continue
         go to 50
   40    continue
            info = k
   50    continue
   60 continue
   70 continue
      ipvt(n) = n
      if (a(n,n) .eq. 0.0d0) info = n
      return
      end
      subroutine dgesl(a,lda,n,ipvt,b,job)
      integer lda,n,ipvt(1),job
      double precision a(lda,1),b(1)
c
c     dgesl solves the double precision system
c     a * x = b  or  trans(a) * x = b
c     using the factors computed by dgeco or dgefa.
c
c     on entry
c
c        a       double precision(lda, n)
c                the output from dgeco or dgefa.
c
c        lda     integer
c                the leading dimension of the array  a .
c
c        n       integer
c                the order of the matrix  a .
c
c        ipvt    integer(n)
c                the pivot vector from dgeco or dgefa.
c
c        b       double precision(n)
c                the right hand side vector.
c
c        job     integer
c                = 0         to solve  a*x = b ,
c                = nonzero   to solve  trans(a)*x = b  where
c                            trans(a)  is the transpose.
c
c     on return
c
c        b       the solution vector  x .
c
c     error condition
c
c        a division by zero will occur if the input factor contains a
c        zero on the diagonal.  technically this indicates singularity
c        but it is often caused by improper arguments or improper
c        setting of lda .  it will not occur if the subroutines are
c        called correctly and if dgeco has set rcond .gt. 0.0
c        or dgefa has set info .eq. 0 .
c
c     to compute  inverse(a) * c  where  c  is a matrix
c     with  p  columns
c           call dgeco(a,lda,n,ipvt,rcond,z)
c           if (rcond is too small) go to ...
c           do 10 j = 1, p
c              call dgesl(a,lda,n,ipvt,c(1,j),0)
c        10 continue
c
c     linpack. this version dated 08/14/78 .
c     cleve moler, university of new mexico, argonne national lab.
c
c     subroutines and functions
c
c     blas daxpy,ddot
c
c     internal variables
c
      double precision ddot,t
      integer k,kb,l,nm1
c
      nm1 = n - 1
      if (job .ne. 0) go to 50
c
c        job = 0 , solve  a * x = b
c        first solve  l*y = b
c
         if (nm1 .lt. 1) go to 30
         do 20 k = 1, nm1
            l = ipvt(k)
            t = b(l)
            if (l .eq. k) go to 10
               b(l) = b(k)
               b(k) = t
   10       continue
            call daxpy(n-k,t,a(k+1,k),1,b(k+1),1)
   20    continue
   30    continue
c
c        now solve  u*x = y
c
         do 40 kb = 1, n
            k = n + 1 - kb
            b(k) = b(k)/a(k,k)
            t = -b(k)
            call daxpy(k-1,t,a(1,k),1,b(1),1)
   40    continue
      go to 100
   50 continue
c
c        job = nonzero, solve  trans(a) * x = b
c        first solve  trans(u)*y = b
c
         do 60 k = 1, n
            t = ddot(k-1,a(1,k),1,b(1),1)
            b(k) = (b(k) - t)/a(k,k)
   60    continue
c
c        now solve trans(l)*x = y
c
         if (nm1 .lt. 1) go to 90
         do 80 kb = 1, nm1
            k = n - kb
            b(k) = b(k) + ddot(n-k,a(k+1,k),1,b(k+1),1)
            l = ipvt(k)
            if (l .eq. k) go to 70
               t = b(l)
               b(l) = b(k)
               b(k) = t
   70       continue
   80    continue
   90    continue
  100 continue
      return
      end
      subroutine daxpy(n,da,dx,incx,dy,incy)
c
c     constant times a vector plus a vector.
c     uses unrolled loops for increments equal to one.
c     jack dongarra, linpack, 3/11/78.
c
      double precision dx(1),dy(1),da
      integer i,incx,incy,ix,iy,m,mp1,n
c
      if(n.le.0)return
      if (da .eq. 0.0d0) return
      if(incx.eq.1.and.incy.eq.1)go to 20
c
c        code for unequal increments or equal increments
c          not equal to 1
c
      ix = 1
      iy = 1
      if(incx.lt.0)ix = (-n+1)*incx + 1
      if(incy.lt.0)iy = (-n+1)*incy + 1
      do 10 i = 1,n
        dy(iy) = dy(iy) + da*dx(ix)
        ix = ix + incx
        iy = iy + incy
   10 continue
      return
c
c        code for both increments equal to 1
c
c
c        clean-up loop
c
   20 m = mod(n,4)
      if( m .eq. 0 ) go to 40
      do 30 i = 1,m
        dy(i) = dy(i) + da*dx(i)
   30 continue
      if( n .lt. 4 ) return
   40 mp1 = m + 1
      do 50 i = mp1,n,4
        dy(i) = dy(i) + da*dx(i)
        dy(i + 1) = dy(i + 1) + da*dx(i + 1)
        dy(i + 2) = dy(i + 2) + da*dx(i + 2)
        dy(i + 3) = dy(i + 3) + da*dx(i + 3)
   50 continue
      return
      end
      double precision function ddot(n,dx,incx,dy,incy)
c
c     forms the dot product of two vectors.
c     uses unrolled loops for increments equal to one.
c     jack dongarra, linpack, 3/11/78.
c
      double precision dx(1),dy(1),dtemp
      integer i,incx,incy,ix,iy,m,mp1,n
c
      ddot = 0.0d0
      dtemp = 0.0d0
      if(n.le.0)return
      if(incx.eq.1.and.incy.eq.1)go to 20
c
c        code for unequal increments or equal increments
c          not equal to 1
c
      ix = 1
      iy = 1
      if(incx.lt.0)ix = (-n+1)*incx + 1
      if(incy.lt.0)iy = (-n+1)*incy + 1
      do 10 i = 1,n
        dtemp = dtemp + dx(ix)*dy(iy)
        ix = ix + incx
        iy = iy + incy
   10 continue
      ddot = dtemp
      return
c
c        code for both increments equal to 1
c
c
c        clean-up loop
c
   20 m = mod(n,5)
      if( m .eq. 0 ) go to 40
      do 30 i = 1,m
        dtemp = dtemp + dx(i)*dy(i)
   30 continue
      if( n .lt. 5 ) go to 60
   40 mp1 = m + 1
      do 50 i = mp1,n,5
        dtemp = dtemp + dx(i)*dy(i) + dx(i + 1)*dy(i + 1) +
     *   dx(i + 2)*dy(i + 2) + dx(i + 3)*dy(i + 3) + dx(i + 4)*dy(i + 4)
   50 continue
   60 ddot = dtemp
      return
      end
      subroutine  dscal(n,da,dx,incx)
c
c     scales a vector by a constant.
c     uses unrolled loops for increment equal to one.
c     jack dongarra, linpack, 3/11/78.
c
      double precision da,dx(1)
      integer i,incx,m,mp1,n,nincx
c
      if(n.le.0)return
      if(incx.eq.1)go to 20
c
c        code for increment not equal to 1
c
      nincx = n*incx
      do 10 i = 1,nincx,incx
        dx(i) = da*dx(i)
   10 continue
      return
c
c        code for increment equal to 1
c
c
c        clean-up loop
c
   20 m = mod(n,5)
      if( m .eq. 0 ) go to 40
      do 30 i = 1,m
        dx(i) = da*dx(i)
   30 continue
      if( n .lt. 5 ) return
   40 mp1 = m + 1
      do 50 i = mp1,n,5
        dx(i) = da*dx(i)
        dx(i + 1) = da*dx(i + 1)
        dx(i + 2) = da*dx(i + 2)
        dx(i + 3) = da*dx(i + 3)
        dx(i + 4) = da*dx(i + 4)
   50 continue
      return
      end
      integer function idamax(n,dx,incx)
c
c     finds the index of element having max. dabsolute value.
c     jack dongarra, linpack, 3/11/78.
c
      double precision dx(1),dmax
      integer i,incx,ix,n
c
      idamax = 0
      if( n .lt. 1 ) return
      idamax = 1
      if(n.eq.1)return
      if(incx.eq.1)go to 20
c
c        code for increment not equal to 1
c
      ix = 1
      dmax = dabs(dx(1))
      ix = ix + incx
      do 10 i = 2,n
         if(dabs(dx(ix)).le.dmax) go to 5
         idamax = i
         dmax = dabs(dx(ix))
    5    ix = ix + incx
   10 continue
      return
c
c        code for increment equal to 1
c
   20 dmax = dabs(dx(1))
      do 30 i = 2,n
         if(dabs(dx(i)).le.dmax) go to 30
         idamax = i
         dmax = dabs(dx(i))
   30 continue
      return
      end
      double precision function epslon (x)
      double precision x
c
c     estimate unit roundoff in quantities of size x.
c
      double precision a,b,c,eps
c
c     this program should function properly on all systems
c     satisfying the following two assumptions,
c        1.  the base used in representing dfloating point
c            numbers is not a power of three.
c        2.  the quantity  a  in statement 10 is represented to 
c            the accuracy used in dfloating point variables
c            that are stored in memory.
c     the statement number 10 and the go to 10 are intended to
c     force optimizing compilers to generate code satisfying 
c     assumption 2.
c     under these assumptions, it should be true that,
c            a  is not exactly equal to four-thirds,
c            b  has a zero for its last bit or digit,
c            c  is not exactly equal to one,
c            eps  measures the separation of 1.0 from
c                 the next larger dfloating point number.
c     the developers of eispack would appreciate being informed
c     about any systems where these assumptions do not hold.
c
c     *****************************************************************
c     this routine is one of the auxiliary routines used by eispack iii
c     to avoid machine dependencies.
c     *****************************************************************
c
c     this version dated 4/6/83.
c
      a = 4.0d0/3.0d0
   10 b = a - 1.0d0
      c = b + b + b
      eps = dabs(c-1.0d0)
      if (eps .eq. 0.0d0) go to 10
      epslon = eps*dabs(x)
      return
      end
      subroutine mm (a, lda, n1, n3, b, ldb, n2, c, ldc)
      double precision a(lda,*), b(ldb,*), c(ldc,*)
c
c   purpose:
c     multiply matrix b times matrix c and store the result in matrix a.
c
c   parameters:
c
c     a double precision(lda,n3), matrix of n1 rows and n3 columns
c
c     lda integer, leading dimension of array a
c
c     n1 integer, number of rows in matrices a and b
c
c     n3 integer, number of columns in matrices a and c
c
c     b double precision(ldb,n2), matrix of n1 rows and n2 columns
c
c     ldb integer, leading dimension of array b
c
c     n2 integer, number of columns in matrix b, and number of rows in
c         matrix c
c
c     c double precision(ldc,n3), matrix of n2 rows and n3 columns
c
c     ldc integer, leading dimension of array c
c
c ----------------------------------------------------------------------
c
      do 20 j = 1, n3
         do 10 i = 1, n1
            a(i,j) = 0.0
   10    continue
         call dmxpy (n2,a(1,j),n1,ldb,c(1,j),b)
   20 continue
c
      return
      end
      subroutine dmxpy (n1, y, n2, ldm, x, m)
      double precision y(*), x(*), m(ldm,*)
c
c   purpose:
c     multiply matrix m times vector x and add the result to vector y.
c
c   parameters:
c
c     n1 integer, number of elements in vector y, and number of rows in
c         matrix m
c
c     y double precision(n1), vector of length n1 to which is added 
c         the product m*x
c
c     n2 integer, number of elements in vector x, and number of columns
c         in matrix m
c
c     ldm integer, leading dimension of array m
c
c     x double precision(n2), vector of length n2
c
c     m double precision(ldm,n2), matrix of n1 rows and n2 columns
c
c ----------------------------------------------------------------------
c
c   cleanup odd vector
c
      j = mod(n2,2)
      if (j .ge. 1) then
         do 10 i = 1, n1
            y(i) = (y(i)) + x(j)*m(i,j)
   10    continue
      endif
c
c   cleanup odd group of two vectors
c
      j = mod(n2,4)
      if (j .ge. 2) then
         do 20 i = 1, n1
            y(i) = ( (y(i))
     $             + x(j-1)*m(i,j-1)) + x(j)*m(i,j)
   20    continue
      endif
c
c   cleanup odd group of four vectors
c
      j = mod(n2,8)
      if (j .ge. 4) then
         do 30 i = 1, n1
            y(i) = ((( (y(i))
     $             + x(j-3)*m(i,j-3)) + x(j-2)*m(i,j-2))
     $             + x(j-1)*m(i,j-1)) + x(j)  *m(i,j)
   30    continue
      endif
c
c   cleanup odd group of eight vectors
c
      j = mod(n2,16)
      if (j .ge. 8) then
         do 40 i = 1, n1
            y(i) = ((((((( (y(i))
     $             + x(j-7)*m(i,j-7)) + x(j-6)*m(i,j-6))
     $             + x(j-5)*m(i,j-5)) + x(j-4)*m(i,j-4))
     $             + x(j-3)*m(i,j-3)) + x(j-2)*m(i,j-2))
     $             + x(j-1)*m(i,j-1)) + x(j)  *m(i,j)
   40    continue
      endif
c
c   main loop - groups of sixteen vectors
c
      jmin = j+16
      do 60 j = jmin, n2, 16
         do 50 i = 1, n1
            y(i) = ((((((((((((((( (y(i))
     $             + x(j-15)*m(i,j-15)) + x(j-14)*m(i,j-14))
     $             + x(j-13)*m(i,j-13)) + x(j-12)*m(i,j-12))
     $             + x(j-11)*m(i,j-11)) + x(j-10)*m(i,j-10))
     $             + x(j- 9)*m(i,j- 9)) + x(j- 8)*m(i,j- 8))
     $             + x(j- 7)*m(i,j- 7)) + x(j- 6)*m(i,j- 6))
     $             + x(j- 5)*m(i,j- 5)) + x(j- 4)*m(i,j- 4))
     $             + x(j- 3)*m(i,j- 3)) + x(j- 2)*m(i,j- 2))
     $             + x(j- 1)*m(i,j- 1)) + x(j)   *m(i,j)
   50    continue
   60 continue
      return
      end
      DOUBLE PRECISION FUNCTION RAN( ISEED )
*
*     modified from the LAPACK auxiliary routine 10/12/92 JD
*  -- LAPACK auxiliary routine (version 1.0) --
*     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
*     Courant Institute, Argonne National Lab, and Rice University
*     February 29, 1992
*
*     .. Array Arguments ..
      INTEGER            ISEED( 4 )
*     ..
*
*  Purpose
*  =======
*
*  DLARAN returns a random real number from a uniform (0,1)
*  distribution.
*
*  Arguments
*  =========
*
*  ISEED   (input/output) INTEGER array, dimension (4)
*          On entry, the seed of the random number generator; the array
*          elements must be between 0 and 4095, and ISEED(4) must be
*          odd.
*          On exit, the seed is updated.
*
*  Further Details
*  ===============
*
*  This routine uses a multiplicative congruential method with modulus
*  2**48 and multiplier 33952834046453 (see G.S.Fishman,
*  'Multiplicative congruential random number generators with modulus
*  2**b: an exhaustive analysis for b = 32 and a partial analysis for
*  b = 48', Math. Comp. 189, pp 331-344, 1990).
*
*  48-bit integers are stored in 4 integer array elements with 12 bits
*  per element. Hence the routine is portable across machines with
*  integers of 32 bits or more.
*
*     .. Parameters ..
      INTEGER            M1, M2, M3, M4
      PARAMETER          ( M1 = 494, M2 = 322, M3 = 2508, M4 = 2549 )
      DOUBLE PRECISION   ONE
      PARAMETER          ( ONE = 1.0D+0 )
      INTEGER            IPW2
      DOUBLE PRECISION   R
      PARAMETER          ( IPW2 = 4096, R = ONE / IPW2 )
*     ..
*     .. Local Scalars ..
      INTEGER            IT1, IT2, IT3, IT4
*     ..
*     .. Intrinsic Functions ..
      INTRINSIC          DBLE, MOD
*     ..
*     .. Executable Statements ..
*
*     multiply the seed by the multiplier modulo 2**48
*
      IT4 = ISEED( 4 )*M4
      IT3 = IT4 / IPW2
      IT4 = IT4 - IPW2*IT3
      IT3 = IT3 + ISEED( 3 )*M4 + ISEED( 4 )*M3
      IT2 = IT3 / IPW2
      IT3 = IT3 - IPW2*IT2
      IT2 = IT2 + ISEED( 2 )*M4 + ISEED( 3 )*M3 + ISEED( 4 )*M2
      IT1 = IT2 / IPW2
      IT2 = IT2 - IPW2*IT1
      IT1 = IT1 + ISEED( 1 )*M4 + ISEED( 2 )*M3 + ISEED( 3 )*M2 +
     $      ISEED( 4 )*M1
      IT1 = MOD( IT1, IPW2 )
*
*     return updated seed
*
      ISEED( 1 ) = IT1
      ISEED( 2 ) = IT2
      ISEED( 3 ) = IT3
      ISEED( 4 ) = IT4
*
*     convert 48-bit integer to a real number in the interval (0,1)
*
      RAN = R*( DBLE( IT1 )+R*( DBLE( IT2 )+R*( DBLE( IT3 )+R*
     $         ( DBLE( IT4 ) ) ) ) )
      RETURN
*
*     End of RAN
*
      END
@ROUT ftime00
double time00(void);
double ftime00(void) { return(time00()); }
double ftime00_(void) { return(time00()); }
double FTIME00(void) { return(time00()); }
@ROUT ATL_asrc2blk_NB
#include "atlas_asm.h"
#include "dmm.h"

#ifdef ATL_GAS_x8664
#ifndef NB
   #error "NB must be compile-time constant"
#elif (NB/8)*8 != NB
   #error "NB must be multiple of 8!!"
#endif

#define NBso (NB*8)

#ifdef ALPHAX
   #define R2B_NB ATL_drow2blkT_NB_aX
   #define C2BN   ATL_dcol2blk_NB_aX
#else
   #define R2B_NB ATL_drow2blkT_NB_a1
   #define C2BN   ATL_dcol2blk_NB_a1
#endif

#define alpha	%xmm0
#define rA0	%xmm1
#define rA1	%xmm2
#define rA2	%xmm3
#define rA3	%xmm4

#define pV	%rdi
#define pA0	%rdx
#define it2	%ebp
#define ii  	%rbp
#define jj	%rax
#define lda	%rbx
#define lda8	%rcx
#define ld_nb	%rsi
#define incA	%r8
#define nn	%r9
#define JJ	%r10
#define nblk	%r11
#define mr	%r12
#define pAn	%r13
#define pVn	%r14

#               %edi   %esi           %rdx     %rcx      %r8       %xmm0
# void col2blk(int M, int N, const TYPE *A, int lda, TYPE *V, SCALAR alpha)
#    NOTE: N is ignored, assumed to be NB
#
.global ATL_asmdecor(C2BN)
ATL_asmdecor(C2BN):
	movq	%rbp, -8(%rsp)
	movq	%rbx, -16(%rsp)
	movq	%r12, -24(%rsp)
	movq	%r13, -32(%rsp)
	movq	%r14, -40(%rsp)
#
#       Convert lda to 64 bit, then figure nblk (both ops require %rax)
#
	movl	%ecx, %eax
	cltq
	movq	%rax, lda
	movl	%edi, %eax
	cltq
	movq	%rdx, %r14   # div overwrites rdx and rax, save pA
	movq	$0, %rdx
	movq	$NB, %rcx
	idivq	%rcx
	movq	%rdx, mr
	movq	%rax, nblk
	movq	%r14, %rdx
#
#       Init pV, and alpha, 
#       lda *= sizeof;  lda8 = 8 * lda;  ld_nb = lda - NB;
#
	movq	%r8, pV
	shl	$3, lda
	movq	lda, lda8
	shl	$3, lda8
	movq	lda, ld_nb
	subq	$NBso, ld_nb
	movq	lda8, incA
	subq	$NBso, incA
	neg	incA
   #ifdef ALPHAX
	unpcklpd	alpha, alpha
   #endif
	cmp	$0, nblk
	je 	CUC2B_chk
#
#	Set pAn = pA, pVn = pV
#
	movq	pA0, pAn
	movq	pV, pVn
#
#	for (JJ=NB/8; JJ; JJ--)
#
	movq	$NB/8, JJ
JJLOOP:
	addq	lda8, pAn
	addq	$8*NBso, pVn
#
#	for (nn=nblk; n; n--)
#
	movq	nblk, nn
NNLOOP:
	
#
#	Burst load 8 cols of A
#
	movq	$8, jj
CBURST:
	movl	NBso-64(pA0), it2
	movl	NBso-128(pA0), it2
   #if NB >= 24
	movl	NBso-192(pA0), it2
   #endif
   #if NB >= 32
	movl	NBso-256(pA0), it2
   #endif
   #if NB >= 40
	movl	NBso-320(pA0), it2
   #endif
   #if NB >= 48
	movl	NBso-384(pA0), it2
   #endif
   #if NB >= 56
	movl	NBso-448(pA0), it2
   #endif
   #if NB >= 64
	movl	NBso-512(pA0), it2
   #endif
   #if NB >= 72
	movl	NBso-576(pA0), it2
   #endif
   #if NB >= 80
	movl	NBso-640(pA0), it2
   #endif
	addq	lda, pA0
#
#       while (jj)
#
	subq	$1, jj
	jnz CBURST
	subq	lda8, pA0

#
#	for (jj=8; jj; jj--)
#
	movq	$8, jj
JILOOP:
#
#       for (ii=NB/8; ii; ii--)
#
	movq	$NB/8, ii
ILOOP:
   #ifdef ALPHAX
	movupd	(pA0), rA0
	mulpd	alpha, rA0
	movupd	16(pA0), rA1
	mulpd	alpha, rA1
	movupd	32(pA0), rA2
	mulpd	alpha, rA2
	movupd	48(pA0), rA3
	mulpd	alpha, rA3
   #else
	movupd	(pA0), rA0
	movupd	16(pA0), rA1
	movupd	32(pA0), rA2
	movupd	48(pA0), rA3
   #endif

	movntpd	rA0, (pV)
	movntpd	rA1, 16(pV)
	movntpd	rA2, 32(pV)
	movntpd	rA3, 48(pV)

	addq	$64, pA0
	addq	$64, pV
#
#	while (ii)
#
	subq	$1, ii
	jnz	ILOOP
#
#	pA0 += lda - NB
#
	addq	ld_nb, pA0
#
#	while(jj)
#
	subq	$1, jj
	jnz	JILOOP
#
#	pA -= (lda*8 - NB);  pV += NBNB - 8*NB;
#	
	addq	incA, pA0
	addq	$(NB-8)*NBso, pV
#
#       while (nn)
#
	subq	$1, nn
	jnz	NNLOOP
#
	movq	pAn, pA0
	movq	pVn, pV
#
#       while (JJ)
#
	subq	$1, JJ
	jnz	JJLOOP
#
#	If we have a partial block, copy it as well
#
	cmp	$0, mr
	je	DONE_C2B
#
#	pV = pV - NBNB + nblk*NBNB
#
	subq	$NB*NBso, pV
	imulq	$NB*NBso, nblk, JJ
	addq	JJ, pV
#
#	pA0 -= NB*lda
#
	imulq	$NB, lda, JJ
	subq	JJ, pA0
	imulq	$NBso, nblk, JJ
	addq	JJ, pA0
CUC2B:
	movq	pA0, pAn
#
#       for (jj=NB; jj; jj--)
#
	movq	$NB, JJ
JJCU:
#
#       for (ii=mr; ii; ii--)
#
	movq	mr, ii
	addq	lda, pAn
IICU:
   #ifdef ALPHAX
	movlpd	(pA0), rA0
	mulsd	alpha, rA0
	movlpd	rA0, -48(%rsp)
	movq	-48(%rsp), pVn
	movnti	pVn, (pV)
   #else
	movq	(pA0), pVn
	movnti	pVn, (pV)
   #endif
	addq	$8, pV
	addq	$8, pA0
	subq	$1, ii
	jnz	IICU
	movq	pAn, pA0
#
#	while(JJ)
#
	subq	$1, JJ
	jnz	JJCU
#
#	Done col2blk
#
DONE_C2B:
	movq	-8(%rsp), %rbp
	movq	-16(%rsp), %rbx
	movq	-24(%rsp), %r12
	movq	-32(%rsp), %r13
	movq	-40(%rsp), %r14
	sfence
	ret
CUC2B_chk:
	cmp	$0, mr
	je	DONE_C2B
	jmp	CUC2B

#undef  pV
#undef  pA0
#undef  it2
#undef  ii  
#undef  jj
#undef  lda
#undef  lda8
#undef  ld_nb
#undef  incA
#undef  nn
#undef  JJ
#undef  nblk
#undef  mr
#undef  pAn
#undef  pVn

#define N	%esi
#define pA0	%rdx
#define lda	%rax
#define pV	%rcx
#define itmp	%edi
#define it2	%ebp
#define ltmp	%rbp
#define pA1	%rbx
#define pA2	%r8
#define pA3	%r9
#define pA4	%r10
#define pA5	%r11
#define pA6	%r12
#define pA7	%r13

#                      %edi   %esi           %rdx     %rcx      %r8       %xmm0
#void ATL_row2blkT_NB(int M, int N, const TYPE *A, int lda, TYPE *V, TYPE alpha)
#
#  NOTE : can ignore M and N: they are NB, a compile-time constant (cpp macro)
.global ATL_asmdecor(R2B_NB)
ATL_asmdecor(R2B_NB):
	movq	%rbp, -8(%rsp)
	movq	%rbx, -16(%rsp)
	movq	%r12, -24(%rsp)
	movq	%r13, -32(%rsp)
#
#	lda = lda * sizeof;  Init pV, and get alpha in both slots of xmm0
#
	movl	%ecx, %eax
	cltq
	shl	$3, lda
	movq	%r8, pV
   #ifdef ALPHAX
	unpcklpd	alpha, alpha
   #endif
#
#	Set pA[1-7]
#
	movq	pA0, pA1
	addq	lda, pA1
	movq	pA1, pA2
	addq	lda, pA2
	movq	pA2, pA3
	addq	lda, pA3
	movq	pA3, pA4
	addq	lda, pA4
	movq	pA4, pA5
	addq	lda, pA5
	movq	pA5, pA6
	addq	lda, pA6
	movq	pA6, pA7
	addq	lda, pA7
NLOOP:
#if 1
#
#	Burst load 8 cols of A
#
	movl	$8, itmp
BURST:
	movl	NBso-64(pA0), it2
	movl	NBso-128(pA0), it2
   #if NB >= 24
	movl	NBso-192(pA0), it2
   #endif
   #if NB >= 32
	movl	NBso-256(pA0), it2
   #endif
   #if NB >= 40
	movl	NBso-320(pA0), it2
   #endif
   #if NB >= 48
	movl	NBso-384(pA0), it2
   #endif
   #if NB >= 56
	movl	NBso-448(pA0), it2
   #endif
   #if NB >= 64
	movl	NBso-512(pA0), it2
   #endif
   #if NB >= 72
	movl	NBso-576(pA0), it2
   #endif
   #if NB >= 80
	movl	NBso-640(pA0), it2
   #endif
	addq	lda, pA0
	subl	$1, itmp
	jnz BURST
	movq	pA1, pA0
	subq	lda, pA0
#endif
#
#       Scale the 8 preloaded cols, and write them as 8 rows of V
#
	movq	$(-NBso), ltmp
COPYLOOP:
	movlpd	NBso(pA0,ltmp), rA0
	movhpd	NBso(pA1,ltmp), rA0
   #ifdef ALPHAX
	mulpd	alpha, rA0
   #endif
	movlpd	NBso(pA2,ltmp), rA1
	movhpd	NBso(pA3,ltmp), rA1
   #ifdef ALPHAX
	mulpd	alpha, rA1
   #endif
	movlpd	NBso(pA4,ltmp), rA2
	movhpd	NBso(pA5,ltmp), rA2
   #ifdef ALPHAX
	mulpd	alpha, rA2
   #endif
	movlpd	NBso(pA6,ltmp), rA3
	movhpd	NBso(pA7,ltmp), rA3
   #ifdef ALPHAX
	mulpd	alpha, rA3
   #endif

	movntpd	rA0, (pV)
	movntpd	rA1, 16(pV)
	movntpd	rA2, 32(pV)
	movntpd	rA3, 48(pV)

	addq	$NBso, pV
	addq	$8, ltmp
	jnz	COPYLOOP

	subq	$NBso*NB-64, pV
	shl	$3, lda
	addq	lda, pA0
	addq	lda, pA1
	addq	lda, pA2
	addq	lda, pA3
	addq	lda, pA4
	addq	lda, pA5
	addq	lda, pA6
	addq	lda, pA7
	shr	$3, lda
	subl	$8, N
	jnz	NLOOP
#
#	All done here
#
	movq	-8(%rsp), %rbp
	movq	-16(%rsp), %rbx
	movq	-24(%rsp), %r12
	movq	-32(%rsp), %r13
	sfence
	ret
#endif
@ROUT ATL_gemmProf
int ATL_ProfGemmCameFrom=0;  /* not thread-safe, but screw it for now */
/*
 * CameFrom should tell where gemm call came from.  Eventually expand to keep
 * track of what ATLAS routine called it, but for now, we have only the
 * following:
 *   0 : Unknown ATLAS call
 *   1 : F77 interface
 *   2 : C interface
 *   4 : ptF77 interface
 *   8 : ptC interface
 */
struct mmProf
{
   double time;
   #ifdef TREAL
      TYPE alpha, beta;
   #else
      TYPE alpha[2], beta[2];
   #endif
   TYPE *A, *B, *C, *dummy;  /* dummy vars keep alignment if ptrs 32 bits */
   int TA, TB, M, N, K, lda, ldb, ldc, CameFrom, idummy;
};
#define PCHUNK 512
void ATL_gemmProf
  (const enum ATLAS_TRANS TA, const enum ATLAS_TRANS TB,
   const int M, const int N, const int K, const SCALAR alpha,
   const TYPE *A, const int lda, const TYPE *B, const int ldb,
   const SCALAR beta, TYPE *C, const int ldc, double time)
{
   static struct mmProf profArr[PCHUNK];
   static int nprof=0;
   static FILE *fpout=NULL;

   if (time != -4.0)  /* flag to close files and stop */
   {
      profArr[nprof].TA = TA;
      profArr[nprof].TB = TB;
      profArr[nprof].M = M;
      profArr[nprof].N = N;
      profArr[nprof].K = K;
      #ifdef TREAL
         profArr[nprof].alpha = alpha;
         profArr[nprof].beta  = beta ;
      #else
         profArr[nprof].alpha[0] = *alpha;
         profArr[nprof].alpha[1] = alpha[1];
         profArr[nprof].beta[0] = *beta;
         profArr[nprof].beta[1] = beta[1];
      #endif
      profArr[nprof].A = A;
      profArr[nprof].lda = lda;
      profArr[nprof].B = B;
      profArr[nprof].ldb = ldb;
      profArr[nprof].C = C;
      profArr[nprof].ldc = ldc;
      profArr[nprof].time = time;
      profArr[nprof].CameFrom = ATL_ProfGemmCameFrom;
      nprof++;
   }
   if (nprof == PCHUNK || time == -4.0)
   {
      if (!fpout)
      {
         fpout = fopen("atlas_profile.out", "wb");
         ATL_assert(fpout);
      }
      fwrite(profArr, sizeof(proffArr[0]), nprof, fpout);
      nprof = 0;
      if (time == -4.0)
      {
         fclose(fpout);
         fpout = NULL;
      }
   }
}
@ROUT ATL_gemm0
@extract -b @(topd)/gen.inc what=cw @(cw07)
gemm(...)
{
   if (M == 1 || N == 1) /* possible gemv */
   else if (K == 1)      /* possible ger */
}
@ROUT mmtime_pt3f
#ifdef ATL_NCPU
   #if ATL_NCPU < 2
      #undef ATL_NCPU
   #endif
#endif
#ifdef ATL_NCPU
   #define _GNU_SOURCE 1 /* what manpage says you need to get CPU_SET */
   #define __USE_GNU   1 /* what you actually need set on linuxes I've seen */
   #include <sched.h>    /* must include this before pthreads */
   #include <pthread.h>
   #define dumb_prand(is_) ( 0.5 - ((double)rand_r(is_))/((double)RAND_MAX) )
#else
   #define dumb_prand(is_) ( 0.5 - ((double)rand())/((double)RAND_MAX) )
#endif
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <string.h>

#define uint unsigned int
#ifndef ATL_SZA
   uint ATL_getszA(uint M, uint K, uint mu, uint ku, uint vlen)
   {
      uint nmu=(M+mu-1)/mu;
      return(nmu*mu*K);
   }
#endif
#ifndef ATL_SZB
   uint ATL_getszB(uint K, uint N, uint ku, uint nu, uint vlen)
   {
      uint nnu=(N+nu-1)/nu;
      return(nnu*nu*K);
   }
#endif
#ifndef ATL_SZC
   uint ATL_getszC(uint M, uint N, uint mu, uint nu, uint vlen)
   {
      uint nmu=(M+mu-1)/mu, nnu=(N+nu-1)/nu, blksz=((mu*nu+vlen-1)/vlen)*vlen;
      return(nmu*nnu*blksz);
   }
#endif
#ifdef TIME_TRMVK
   #include "atlas_misc.h"
#else
   double ATL_walltime(void);
   #define ATL_CSZT const size_t
   #if defined(SREAL) || defined(SCPLX)
      #define TYPE float
   #elif defined(DREAL) || defined(DCPLX)
      #define TYPE double
   #endif
   #ifdef SREAL
      #define ATL_MulBySize(i_) ((i_)<<2)
      #define ATL_DivBySize(i_) ((i_)>>2)
   #elif defined(DREAL) || defined(SCPLX)
      #define ATL_MulBySize(i_) ((i_)<<3)
      #define ATL_DivBySize(i_) ((i_)>>3)
   #else
      #define ATL_MulBySize(i_) ((i_)<<4)
      #define ATL_DivBySize(i_) ((i_)>>4)
   #endif
   #if defined(SCPLX) || defined(DCPLX)
      #define SHIFT << 1
      #define TCPLX 1
   #else
      #define TREAL 1
      #define SHIFT
   #endif
   #define ATL_Cachelen 128
   #define ATL_AlignPtr(vp) \
      (void*) ( ATL_Cachelen + ((((size_t) (vp))>>7)<<7) )
#endif
#define CINT const int

#ifdef TIME_TRMVK
   #ifdef TCPLX
      #error "Complex TRSM kernel timing not yet supported!"
   #else
      #ifdef SD_Right
         #error "Side=Right not yet supported!"
      #else
         #ifdef UDIAG
            #define my_trsmk Mjoin(PATL,ktrsmLLNU_rk4)
         #else
            #define my_trsmk Mjoin(PATL,ktrsmLLN_rk4)
         #endif
      void my_trsmk(ATL_CINT M, ATL_CINT N, const SCALAR alpha,
          const TYPE *T, TYPE *B, ATL_CINT ldb, TYPE *W);
      #endif
   #endif
#elif defined(TCPLX)
   size_t rszA, rszB, rszC;
   void CAMM_b0(ATL_CSZT mblks, ATL_CSZT nblks, ATL_CSZT K, const TYPE *A,
                const TYPE *B, TYPE *C, const TYPE *pAn, const TYPE *pBn,
                const TYPE *pCn);
   void CAMM_b1(ATL_CSZT mblks, ATL_CSZT nblks, ATL_CSZT K, const TYPE *A,
                const TYPE *B, TYPE *C, const TYPE *pAn, const TYPE *pBn,
                const TYPE *pCn);
   void CAMM_bn(ATL_CSZT mblks, ATL_CSZT nblks, ATL_CSZT K, const TYPE *A,
                 const TYPE *B, TYPE *C, const TYPE *pAn, const TYPE *pBn,
                 const TYPE *pCn);
   #ifdef BETA0
      void KMM(ATL_CSZT mblks, ATL_CSZT nblks, ATL_CSZT K, const TYPE *Ai,
               const TYPE *Bi, TYPE *Ci, const TYPE *pAn, const TYPE *pBn,
               const TYPE *pCn)
      {
         extern size_t rszA, rszB, rszC;
         const TYPE *Ar=Ai+rszA, *Br=Bi+rszB;
         TYPE *Cr = Ci + rszC;
         #ifdef CORDER
            CAMM_b0(mblks, nblks, K, Ai, Bi, Cr, Ar, Br, Cr);
            CAMM_bn(mblks, nblks, K, Ar, Br, Cr, Ar, Bi, Ci);
            CAMM_b0(mblks, nblks, K, Ar, Bi, Ci, Ai, Br, Ci);
            CAMM_b1(mblks, nblks, K, Ai, Br, Ci, pAn, pBn, pCn);
         #else
            CAMM_b0(mblks, nblks, K, Ai, Bi, Cr, Ai, Br, Ci);
            CAMM_b0(mblks, nblks, K, Ai, Br, Ci, Ar, Br, Cr);
            CAMM_bn(mblks, nblks, K, Ar, Br, Cr, Ar, Bi, Ci);
            CAMM_b1(mblks, nblks, K, Ar, Bi, Ci, pAn, pBn, pCn);
         #endif
      }
   #elif defined(BETA1)
      void KMM(ATL_CSZT mblks, ATL_CSZT nblks, ATL_CSZT K, const TYPE *Ai,
               const TYPE *Bi, TYPE *Ci, const TYPE *pAn, const TYPE *pBn,
               const TYPE *pCn)
      {
         extern size_t rszA, rszB, rszC;
         const TYPE *Ar=Ai+rszA, *Br=Bi+rszB;
         TYPE *Cr = Ci + rszC;
         #ifdef CORDER
            CAMM_bn(mblks, nblks, K, Ai, Bi, Cr, Ar, Br, Cr);
            CAMM_bn(mblks, nblks, K, Ar, Br, Cr, Ar, Bi, Ci);
            CAMM_b1(mblks, nblks, K, Ar, Bi, Ci, Ai, Br, Ci);
            CAMM_b1(mblks, nblks, K, Ai, Br, Ci, pAn, pBn, pCn);
         #else
            CAMM_bn(mblks, nblks, K, Ai, Bi, Cr, Ai, Br, Ci);
            CAMM_b1(mblks, nblks, K, Ai, Br, Ci, Ar, Br, Cr);
            CAMM_bn(mblks, nblks, K, Ar, Br, Cr, Ar, Bi, Ci);
            CAMM_b1(mblks, nblks, K, Ar, Bi, Ci, pAn, pBn, pCn);
         #endif
      }
   #else
      void KMM(ATL_CSZT mblks, ATL_CSZT nblks, ATL_CSZT K, const TYPE *Ai,
               const TYPE *Bi, TYPE *Ci, const TYPE *pAn, const TYPE *pBn,
               const TYPE *pCn)
      {
         extern size_t rszA, rszB, rszC;
         const TYPE *Ar=Ai+rszA, *Br=Bi+rszB;
         TYPE *Cr = Ci + rszC;
         #ifdef CORDER
            CAMM_b1(mblks, nblks, K, Ai, Bi, Cr, Ar, Br, Cr);
            CAMM_b1(mblks, nblks, K, Ar, Br, Cr, Ar, Bi, Ci);
            CAMM_bn(mblks, nblks, K, Ar, Bi, Ci, Ai, Br, Ci);
            CAMM_bn(mblks, nblks, K, Ai, Br, Ci, pAn, pBn, pCn);
         #else
            CAMM_b1(mblks, nblks, K, Ai, Bi, Cr, Ai, Br, Ci);
            CAMM_bn(mblks, nblks, K, Ai, Br, Ci, Ar, Br, Cr);
            CAMM_b1(mblks, nblks, K, Ar, Br, Cr, Ar, Bi, Ci);
            CAMM_bn(mblks, nblks, K, Ar, Bi, Ci, pAn, pBn, pCn);
         #endif
      }
   #endif
#else
   #ifndef KMM
      #define KMM ATL_USERMM
   #endif
   void KMM(ATL_CSZT mblks, ATL_CSZT nblks, ATL_CSZT K, const TYPE *A,
            const TYPE *B, TYPE *C, const TYPE *pAn, const TYPE *pBn,
            const TYPE *pCn);
#endif

struct kmm_struct{
   int mb, nb, kb;                      /* C: mbxnb, At: kbxmb, B: kbXnb */
   int mu, nu, ku;                      /* needed to compute mblks/nblks */
   int movA, movB, movC;                /* which mat move in flush array? */
   long FLSIZE;                       /* min area to move in in bytes */
   long flA, flB, flC;                /* individual flush sizes in bytes*/
   int reps;                            /* # calls to kmm in one timing */
   int vlen;                            /* vector length */
   int iam;                             /* thread rank */
   int p;                               /* total number of threads */
   int *pids;                           /* IDs of processors for affinity */
   double mf;                           /* mflop returned by timing */
   volatile unsigned char *chkin;       /* P-len array to signal start/done */
};

static double getMflops(double m, double n, double k)
{
   #ifdef TIME_TRMVK
     return(1e-6*m*m*n);
   #elif defined(TIME_SYRKK)
      return(1e-6*n*(n+1)*k);
   #else
      return(1e-6*2.0*m*n*k);
   #endif
}
static size_t getSetSz(int mvA, int mvB, int mvC,
                       size_t szA, size_t szB, size_t szC, size_t *NOMVSZ)
{
   size_t nomvsz=0, setsz=0;
   if (mvA)
      setsz += szA;
   else
      nomvsz += szA;
   if (mvB)
      setsz += szB;
   else
      nomvsz += szB;
   if (mvC)
      setsz += szC;
   else
      nomvsz += szC;
   if (NOMVSZ)
      *NOMVSZ = nomvsz;
   return(setsz);
}

#if 1

double GetKmmMflop
(
   CINT mb, CINT nb, CINT kb,           /* C: mbxnb, At: kbxmb, B: kbXnb */
   CINT mu, CINT nu, CINT ku, CINT vlen,
   int movA, int movB, int movC,        /* which mat move in flush array? */
   long FLSIZE,                         /* min area to move in in bytes */
   long flA, long flB, long flC,        /* min area to move in in bytes */
   CINT reps                            /* # calls to kmm in one timing */
)
/*
 * Returns MFLOP rate of matmul kernel KMM
 */
{
   CINT mblks = mb/mu, nblks = nb/nu;
   const int NOMOVE = !(movA|movB|movC);
   size_t szA, szB, szC, extra, setsz, nsets, tsz, i, j, incA, incB, incC, n;
   TYPE *C, *A, *B, *a, *b, *c;
   TYPE *ep, *sp;  /* extra & set ptrs */
   double t0, t1, mf;
   const TYPE alpha=1.0;
   TYPE beta=1.0;
   void *vp=NULL;
   unsigned int seed = mb*kb + (nb<<14);
   size_t nseta, nsetb, nsetc, ja, jb, jc;
/*
 * Get size for each matrix, and round up to ensure we keep alignment
 */
   szA = ATL_getszA(mb, kb, mu, ku, vlen);
   szB = ATL_getszB(kb, nb, ku, nu, vlen);
   szC = ATL_getszC(mb, nb, mu, nu, vlen);
/*
 * Compute the setsz & extra
 * setsz: size of moving mats, extra: size of stationary mats
 */
   setsz = getSetSz(movA, movB, movC, szA, szB, szC, &extra);
   if (!NOMOVE && FLSIZE)
      nsets = (ATL_DivBySize(FLSIZE)+setsz-1) / setsz;
   else
      movA = movB = movC = nsets = 0;
   extra += (mu+mu)*nu;
   tsz = ATL_Cachelen << 1;
   tsz = ATL_DivBySize(tsz);
   if (flA > 0 || flB > 0 || flC > 0)
   {
      nseta = (ATL_DivBySize(flA)+szA-1) / szA;
      nsetb = (ATL_DivBySize(flA)+szB-1) / szB;
      nsetc = (ATL_DivBySize(flA)+szC-1) / szC;
      if (!movA || nseta < 1) nseta = 1;
      if (!movB || nsetb < 1) nsetb = 1;
      if (!movC || nsetc < 1) nsetc = 1;

      tsz += nseta*szA + nsetb*szB + nsetc*szC + extra;
      vp = malloc(6*ATL_Cachelen + ATL_MulBySize(tsz));
   }
   else
   {
      nseta = nsetb = nsetc = nsets;
      if (!movA || nseta < 1) nseta = 1;
      if (!movB || nsetb < 1) nsetb = 1;
      if (!movC || nsetc < 1) nsetc = 1;
      tsz += nsets*setsz+extra;
      vp = malloc(8*ATL_Cachelen + ATL_MulBySize(tsz));
   }
   assert(vp);
   sp = ATL_AlignPtr(vp);
   if (flA > 0 || flB > 0 || flC > 0)
      ep = sp + nseta*szA + nsetb*szB + nsetc*szC;
   else
      ep = sp + nsets*setsz;
   ep += ATL_DivBySize(3*ATL_Cachelen);
   ep = ATL_AlignPtr(ep);
   if (movA)
   {
      A = sp;
      incA = szA SHIFT;
      sp += incA * nseta;
      sp = ATL_AlignPtr(sp);
   }
   else
   {
      A = ep;
      ep += szA SHIFT;
      ep = ATL_AlignPtr(ep);
      incA = 0;
   }
   if (movB)
   {
      B = sp;
      incB = szB SHIFT;
      sp += incB * nsetb;
      sp = ATL_AlignPtr(sp);
   }
   else
   {
      B = ep;
      ep += szB SHIFT;
      ep = ATL_AlignPtr(ep);
      incB = 0;
   }
   if (movC)
   {
      C = sp;
      incC = szC SHIFT;
   }
   else
   {
      C = ep;
      incC = 0;
   }
   /* OLD Init *//*
   sp = ATL_AlignPtr(vp);
   for (i=0; i < (tsz+ATL_DivBySize(5*ATL_Cachelen)); i++)
      sp[i] = dumb_prand(&seed);
   */
   for (i=0; i<nseta*szA; i++)
      A[i] = dumb_prand(&seed);
   for (i=0; i<nsetb*szB; i++)
      B[i] = dumb_prand(&seed);
   for (i=0; i<nsetc*szC; i++)
      C[i] = dumb_prand(&seed);

   a = A; b = B; c = C;
   t0 = ATL_walltime();
   for (ja=jb=jc=0,i=reps; i; i--)
   {
      TYPE *an, *bn, *cn;
      if (++ja != nseta)
         an = a+incA;
      else
      {
         ja = 0; an = A;
      }
      if (++jb != nsetb)
         bn = b+incB;
      else
      {
         jb = 0; bn = B;
      }
      if (++jc != nsetc)
         cn = c+incC;
      else
      {
         jc = 0; cn = C;
      }
      #ifdef TIME_TRMVK
         my_trsmk(mb, nb, 1.0, a, c, mb, b);
      #elif defined(TIME_SYRKK)
         KMM(mblks, nblks, kb, a, a, c, an, an, cn);
      #else
         KMM(mblks, nblks, kb, a, b, c, an, bn, cn);
      #endif
      a = an;
      b = bn;
      c = cn;
   }
   t1 = ATL_walltime() - t0;
   mf = reps*getMflops(mb, nb, kb) / t1;
   #ifdef TCPLX
      mf *= 4.0;
   #endif
   free(vp);
   return(mf);
}

#else

double GetKmmMflop
(
   CINT mb, CINT nb, CINT kb,           /* C: mbxnb, At: kbxmb, B: kbXnb */
   CINT mu, CINT nu, CINT ku, CINT vlen,
   int movA, int movB, int movC,        /* which mat move in flush array? */
   long FLSIZE,                       /* min area to move in in bytes */
   CINT reps                            /* # calls to kmm in one timing */
)
/*
 * Returns MFLOP rate of matmul kernel KMM
 */
{
   CINT mblks = mb/mu, nblks = nb/nu;
   const int NOMOVE = !(movA|movB|movC);
   size_t szA, szB, szC, extra, setsz, nsets, tsz, i, j, incA, incB, incC, n;
   TYPE *C, *A, *B, *a, *b, *c;
   TYPE *ep, *sp;  /* extra & set ptrs */
   double t0, t1, mf;
   const TYPE alpha=1.0;
   TYPE beta=1.0;
   void *vp=NULL;
   unsigned int seed = mb*kb + (nb<<14);
/*
 * Get size for each matrix, and round up to ensure we keep alignment
 */
   szA = ATL_getszA(mb, kb, mu, ku, vlen);
   szB = ATL_getszB(kb, nb, ku, nu, vlen);
   szC = ATL_getszC(mb, nb, mu, nu, vlen);
/*
 * Compute the setsz & extra
 * setsz: size of moving mats, extra: size of stationary mats
 */
   setsz = getSetSz(movA, movB, movC, szA, szB, szC, &extra);
   if (!NOMOVE && FLSIZE)
      nsets = (ATL_DivBySize(FLSIZE)+setsz-1) / setsz;
   else
      movA = movB = movC = nsets = 0;
   extra += (mu+mu)*nu;
   tsz = ATL_Cachelen << 1;
   tsz = ATL_DivBySize(tsz);
   tsz += nsets*setsz+extra;
   vp = malloc(2*ATL_Cachelen + ATL_MulBySize(tsz));
   assert(vp);
   sp = ATL_AlignPtr(vp);
   ep = sp + nsets*setsz;
   ep = ATL_AlignPtr(ep);
   if (movA)
   {
      A = sp;
      incA = szA SHIFT;
      sp += incA * nsets;
      sp = ATL_AlignPtr(sp);
   }
   else
   {
      A = ep;
      ep += szA SHIFT;
      ep = ATL_AlignPtr(ep);
      incA = 0;
   }
   if (movB)
   {
      B = sp;
      incB = szB SHIFT;
      sp += incB * nsets;
      sp = ATL_AlignPtr(sp);
   }
   else
   {
      B = ep;
      ep += szB SHIFT;
      ep = ATL_AlignPtr(ep);
      incB = 0;
   }
   if (movC)
   {
      C = sp;
      incC = szC SHIFT;
   }
   else
   {
      C = ep;
      incC = 0;
   }
   sp = ATL_AlignPtr(vp);
   for (i=0; i < tsz; i++)
      sp[i] = dumb_prand(&seed);

   a = A; b = B; c = C;
   t0 = ATL_walltime();
   for (j=0,i=reps; i; i--)
   {
      TYPE *an, *bn, *cn;
      if (++j != nsets)
      {
         an = a+incA;
         bn = b+incB;
         cn = c+incC;
      }
      else
      {
         j = 0;
         an = A; bn = B; cn = C;
      }
      #ifdef TIME_TRMVK
         my_trsmk(mb, nb, 1.0, a, c, mb, b);
      #elif defined(TIME_SYRKK)
         KMM(mblks, nblks, kb, a, a, c, an, an, cn);
      #else
         KMM(mblks, nblks, kb, a, b, c, an, bn, cn);
      #endif
      a = an;
      b = bn;
      c = cn;
   }
   t1 = ATL_walltime() - t0;
   mf = reps*getMflops(mb, nb, kb) / t1;
   #ifdef TCPLX
      mf *= 4.0;
   #endif
   free(vp);
   return(mf);
}

#endif

#ifdef PRINT_COREID
   #include <utmpx.h>
#endif
//#define PRINT_NUMAIDS
#ifdef PRINT_NUMAIDS
   #define _GNU_SOURCE 1
   #include <unistd.h>
   #include <sys/syscall.h>
#endif
void *TimeOnCore(void *vp)
{
   struct kmm_struct *kp = vp;
   const int P = kp->p;
   int i;
   volatile unsigned char *chkin = kp->chkin;
   #ifdef PRINT_COREID
      printf("core=%d\n", sched_getcpu());
   #endif
#ifdef PRINT_NUMAIDS
    unsigned cpu, node;
    syscall(SYS_getcpu, &cpu, &node, NULL);
    printf("cpu=%u, node=%u\n", cpu, node);
#endif
/*
 * First we barrier, so that all cores are active.  Otherwise, 1st core to
 * start may run with bus to himself, and not give us a measure of true
 * parallel performance.  Want full-on contention as in perfect parallel code.
 * We wait on chkin array to have all non-zero entries.  Even on weakly-ordered
 * caches this should work, though the delay may be long.
 */
   #ifdef ATL_NCPU
      chkin[kp->iam] = 1;
      for (i=0; i < P; i++)
         while(!chkin[i]);
   #endif
   kp->mf = GetKmmMflop(kp->mb, kp->nb, kp->kb, kp->mu, kp->nu, kp->ku,
                        kp->vlen, kp->movA, kp->movB, kp->movC,
                        kp->FLSIZE, kp->flA, kp->flB, kp->flC, kp->reps);
   return(NULL);
}


#ifndef ATL_NCPU
double *TimeOnCores(struct kmm_struct *kb)
{
   double *mflops;
   int i, p;

   mflops = malloc(sizeof(double));
   assert(mflops);
   p = kb->p;
   kb->iam = 0;
   TimeOnCore(kb);
   free(kb->pids);
   mflops[0] = kb->mf;
   return(mflops);
}
#else
double *TimeOnCores(struct kmm_struct *kb)
{
   struct kmm_struct *kp;
   pthread_t *threads;
   pthread_attr_t *attr;
   cpu_set_t *cpuset;
   double *mflops;
   int i, p;
   unsigned char *chkin;

   p = kb->p;
/*
 * On PowerPC Linux, pthread_attr_setaffinity_np sometimes attempts to
 * realloc the cpuset variable, so it must be malloced not taken from
 * the stack.  This is crazy behaviour, but it is what happens.
 */
   cpuset = malloc(sizeof(cpu_set_t));
   kp = malloc(sizeof(struct kmm_struct)*p);
   threads = malloc(sizeof(pthread_t)*p);
   attr = malloc(sizeof(pthread_attr_t)*p);
   mflops = malloc(sizeof(double)*p);
   chkin = malloc(sizeof(char)*p);
   assert(cpuset && kp && threads && attr && mflops && chkin);
   for (i=0; i < p; i++)   /* init chkin to 0 before starting any threads */
      chkin[i] = 0;        /* when all entries non-zero, all thrds started */
   for (i=0; i < p; i++)
   {
      memcpy(kp+i, kb, sizeof(struct kmm_struct));
      kp[i].chkin = (volatile char*)chkin;
      kp[i].iam = i;
      CPU_ZERO(cpuset);
      CPU_SET(kp->pids[i], cpuset);
      assert(!pthread_attr_init(attr+i));
      assert(!pthread_attr_setaffinity_np(attr+i, sizeof(cpu_set_t), cpuset));
      assert(!pthread_attr_setdetachstate(attr+i, PTHREAD_CREATE_JOINABLE));
      assert(!pthread_create(threads+i, attr+i, TimeOnCore, kp+i));
   }
   for (i=0; i < p; i++)
   {
      pthread_join(threads[i], NULL);
      mflops[i] = kp[i].mf;
   }
   free(cpuset);
   free(kp->pids);
   free(kp);
   free(threads);
   free(attr);
   return(mflops);
}
#endif

void GetStat(int n, double *d, double *min, double *max, double *avg)
{
   int i;
   double dmin, dmax, dsum;

   dmin = dmax = dsum = d[0];
   for (i=1; i < n; i++)
   {
      dmax = (dmax >= d[i]) ? dmax : d[i];
      dmin = (dmin <= d[i]) ? dmin : d[i];
      dsum += d[i];
   }
   *min = dmin;
   *max = dmax;
   *avg = dsum / (double)n;
}

void PrintUsage(char *name, int iarg, char *arg)
{
   fprintf(stderr, "\nERROR around arg %d (%s).\n", iarg, arg ? arg:"unknown");
   fprintf(stderr, "USAGE: %s [flags], where flags are:\n", name);
   fprintf(stderr, "   -p <#> : use # threads (with affinity)\n");
   fprintf(stderr, "   -tl <#> id1 ... id# : spawn # threads to given IDs\n");
   fprintf(stderr, "   -B <#> : mb = nb = kb = #\n");
   fprintf(stderr, "   -m <#> : mb = #\n");
   fprintf(stderr, "   -n <#> : nb = #\n");
   fprintf(stderr, "   -k <#> : kb = #\n");
   fprintf(stderr, "   -V <veclen>\n");
   fprintf(stderr, "   -u[mnk] <#> : M/N/K loop unrolling is #\n");
   fprintf(stderr, "   -r <#> : set the # of times to call KMM\n");
   fprintf(stderr, "   -R <mf>: set # reps to force <mf> MFLOPs\n");
   fprintf(stderr, "   -F <kb> : set flush size in kilobytes\n");
   fprintf(stderr, "   -M[a,b,c] <#> : mov[A,B,C] = #\n");
   fprintf(stderr, "   -F[a,b,c] <kb> : set flush size for [A,B,C]\n");
   exit(iarg ? iarg : -1);
}

struct kmm_struct *GetFlags(int nargs, char **args, FILE **fpout)
{
   FILE *fp;
   struct kmm_struct *kp;
   double mflops=750.0;
   int i, j, IGMF=0;  /* ignore mflops.frc file? */

   *fpout = NULL;
   kp = malloc(sizeof(struct kmm_struct));
   assert(kp);
   kp->pids = NULL;
   kp->p = 1;
   kp->mb = kp->nb = kp->kb = 40;
   kp->mu = kp->nu = 4;
   kp->ku = 1;
   kp->movA = kp->movB = kp->movC = 0;
   kp->FLSIZE = L2SIZE;
   kp->flA = kp->flB = kp->flC = -1;
   kp->reps = 0;
   kp->vlen = 1;
   for (i=1; i < nargs; i++)
   {
      if (args[i][0] != '-')
         PrintUsage(args[0], i, args[i]);
      switch(args[i][1])
      {
      case 'f':
         if (++i >= nargs)
            PrintUsage(args[0], i, "out of arguments");
         *fpout = fopen(args[i], "w");
         break;
      case 'V':
         if (++i >= nargs)
            PrintUsage(args[0], i, "out of arguments");
         kp->vlen = atoi(args[i]);
         break;
      case 'F':
         if (++i >= nargs)
            PrintUsage(args[0], i, "out of arguments");
         switch(args[i-1][2])
         {
         case 'c':
         case 'C':
            kp->flC = atoi(args[i]) * 1024;
            break;
         case 'b':
         case 'B':
            kp->flB = atoi(args[i]) * 1024;
            break;
         case 'a':
         case 'A':
            kp->flA = atoi(args[i]) * 1024;
            break;
         case 0:
            kp->FLSIZE = atoi(args[i]) * 1024;
            break;
         default:
            PrintUsage(args[0], i-1, "unknown flush operand");
         }
         break;
      case 'u':
         if (++i >= nargs)
            PrintUsage(args[0], i, "out of arguments");
         j = atoi(args[i]);
         if (args[i-1][2] == 'k')
            kp->ku = j;
         else if (args[i-1][2] == 'n')
            kp->nu = j;
         else
            kp->mu = j;
         break;
      case 'R':
         if (args[i][2] == 'f')
            IGMF=1;
         if (++i >= nargs)
            PrintUsage(args[0], i, "out of arguments");
         mflops = atof(args[i]);
         break;
      case 'r':
         if (++i >= nargs)
            PrintUsage(args[0], i, "out of arguments");
         kp->reps = atoi(args[i]);
         break;
      case 't':
         if (++i >= nargs)
            PrintUsage(args[0], i, "out of arguments");
         kp->p = atoi(args[i]);
         kp->pids = malloc(sizeof(int)*kp->p);
         assert(kp->pids);
         for (j=0; j < kp->p; j++)
         {
            if (++i >= nargs)
               PrintUsage(args[0], i, "out of arguments");
            kp->pids[j] = atoi(args[i]);
         }
         break;
      case 'p':
         if (++i >= nargs)
            PrintUsage(args[0], i, "out of arguments");
         kp->p = atoi(args[i]);
         break;
      case 'm':
         if (++i >= nargs)
            PrintUsage(args[0], i, "out of arguments");
         kp->mb = atoi(args[i]);
         break;
      case 'n':
         if (++i >= nargs)
            PrintUsage(args[0], i, "out of arguments");
         kp->nb = atoi(args[i]);
         break;
      case 'k':
         if (++i >= nargs)
            PrintUsage(args[0], i, "out of arguments");
         kp->kb = atoi(args[i]);
         break;
      case 'B':
         if (++i >= nargs)
            PrintUsage(args[0], i, "out of arguments");
         kp->mb = kp->nb = kp->kb = atoi(args[i]);
         break;
      case 'M':
         if (++i >= nargs)
            PrintUsage(args[0], i, "out of arguments");
         switch(args[i-1][2])
         {
         case 'c':
         case 'C':
            kp->movC = atoi(args[i]);
            break;
         case 'b':
         case 'B':
            kp->movB = atoi(args[i]);
            break;
         case 'a':
         case 'A':
            kp->movA = atoi(args[i]);
            break;
         default:
            PrintUsage(args[0], i-1, "unknown mov matrix");
         }
         break;
      default:
         PrintUsage(args[0], i, args[i]);
      }
   }
/*
 * If there is a tuned <upr>mflops.frc file, use this in preference to the
 * commandline argument unless the -Rf override flag was used
 */
   if (!IGMF)
   {
      char fn[16] = {'s', 'm', 'f', 'o', 'p', 's', '.', 'f', 'r', 'c', '\0'};
      #if defined(DREAL) || defined(DCPLX)
         fn[0] = 'd';
      #endif
      fp = fopen(fn, "r");
      if (fp)
      {
         assert(fscanf(fp, "%le", &mflops) == 1);
         fclose(fp);
      }
   }
   if (!kp->reps)
   {
      kp->reps = (mflops*1000000.0/((2.0*kp->mb)*kp->nb*kp->kb));
      if (kp->reps < 1)
         kp->reps = 1;
   }
   if (!kp->pids)
   {
      kp->pids = malloc(sizeof(int)*kp->p);
      assert(kp->pids);
      #ifdef ATL_ARCH_XeonPHI
      {
         int n4 = ((kp->p)>>2)<<2, nr = kp->p - n4;
         for (j=0; j < n4; j += 2)
         {
            kp->pids[j] = 2*j;
            kp->pids[j+1] = 2*j+1;
         }
         switch(nr)
         {
         case 3:
            kp->pids[j+2] = 2*(j+2);
         case 2:
            kp->pids[j+1] = 2*j+1;
         case 1:
            kp->pids[j] = 2*j;
            break;
         case 0:;
         }
      }
      #else
         for (j=0; j < kp->p; j++)
             kp->pids[j] = j;
      #endif
   }
   #ifdef TIME_SYRKK
      kp->movB = 0;
   #endif
   if (kp->FLSIZE <= 0)
      kp->FLSIZE = L2SIZE;
   if (kp->flA > 0 || kp->flB > 0 || kp->flC > 0)
   {
      if (kp->flA < 0) kp->flA = kp->FLSIZE;
      if (kp->flB < 0) kp->flB = kp->FLSIZE;
      if (kp->flC < 0) kp->flC = kp->FLSIZE;
   }
   return(kp);
}

int main(int nargs, char **args)
{
   struct kmm_struct *kp;
   int i, p;
   double *dp;
   double min, max, avg;
   FILE *fpout = stdout;

   kp = GetFlags(nargs, args, &fpout);
   p = kp->p;
   #ifndef ATL_NCPU
      assert(p < 2);
   #endif
   dp = TimeOnCores(kp);
   free(kp);
   GetStat(p, dp, &min, &max, &avg);
   printf("PER-CORE: %le", dp[0]);
   for (i=1; i < p; i++)
      printf(", %le", dp[i]);
   printf("\nALL CORES: min=%.2f, max=%.2f, avg=%.2f\n", min, max, avg);
   if (fpout)
   {
      fprintf(fpout, "%d 1\n", p);
      for (i=0; i < p; i++)
         fprintf(fpout, "%e\n", dp[i]);
   }
   free(dp);
   if (fpout && fpout != stdout && fpout != stderr)
      fclose(fpout);
   exit(0);
}
@ROUT mmtime_pt
#ifdef ATL_NCPU
   #if ATL_NCPU < 2
      #undef ATL_NCPU
   #endif
#endif
#ifdef ATL_NCPU
   #define _GNU_SOURCE 1 /* what manpage says you need to get CPU_SET */
   #define __USE_GNU   1 /* what you actually need set on linuxes I've seen */
   #include <sched.h>    /* must include this before pthreads */
   #include <pthread.h>
   #define dumb_prand(is_) ( 0.5 - ((double)rand_r(is_))/((double)RAND_MAX) )
#else
   #define dumb_prand(is_) ( 0.5 - ((double)rand())/((double)RAND_MAX) )
#endif
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <string.h>

#define uint unsigned int
#ifndef ATL_SZA
   uint ATL_getszA(uint M, uint K, uint mu, uint ku, uint vlen)
   {
      uint nmu=(M+mu-1)/mu;
      return(nmu*mu*K);
   }
#endif
#ifndef ATL_SZB
   uint ATL_getszB(uint K, uint N, uint ku, uint nu, uint vlen)
   {
      uint nnu=(N+nu-1)/nu;
      return(nnu*nu*K);
   }
#endif
#ifndef ATL_SZC
   uint ATL_getszC(uint M, uint N, uint mu, uint nu, uint vlen)
   {
      uint nmu=(M+mu-1)/mu, nnu=(N+nu-1)/nu, blksz=((mu*nu+vlen-1)/vlen)*vlen;
      return(nmu*nnu*blksz);
   }
#endif
#ifdef TIME_TRMVK
   #include "atlas_misc.h"
#else
   double ATL_walltime(void);
   #define ATL_CSZT const size_t
   #if defined(SREAL) || defined(SCPLX)
      #define TYPE float
   #elif defined(DREAL) || defined(DCPLX)
      #define TYPE double
   #endif
   #ifdef SREAL
      #define ATL_MulBySize(i_) ((i_)<<2)
      #define ATL_DivBySize(i_) ((i_)>>2)
   #elif defined(DREAL) || defined(SCPLX)
      #define ATL_MulBySize(i_) ((i_)<<3)
      #define ATL_DivBySize(i_) ((i_)>>3)
   #else
      #define ATL_MulBySize(i_) ((i_)<<4)
      #define ATL_DivBySize(i_) ((i_)>>4)
   #endif
   #if defined(SCPLX) || defined(DCPLX)
      #define SHIFT << 1
      #define TCPLX 1
   #else
      #define TREAL 1
      #define SHIFT
   #endif
   #define ATL_Cachelen 128
   #define ATL_AlignPtr(vp) \
      (void*) ( ATL_Cachelen + ((((size_t) (vp))>>7)<<7) ) 
#endif
#define CINT const int

#ifdef TIME_TRMVK
   #ifdef TCPLX
      #error "Complex TRSM kernel timing not yet supported!"
   #else
      #ifdef SD_Right
         #error "Side=Right not yet supported!"
      #else
      void Mjoin(PATL,ktrsmLLN_rk4)
         (ATL_CINT M, ATL_CINT N, const SCALAR alpha, 
          const TYPE *T, TYPE *B, ATL_CINT ldb, TYPE *W);
      #endif
   #endif
#elif defined(TIME_COPY)
   #ifndef COPYK
      #define COPYK ATL_USERCPMM
   #endif
   #ifdef TREAL
      #ifdef COPY_C
         void COPYK(const size_t, const size_t, const TYPE, const TYPE*, 
                    const TYPE, TYPE*, const size_t);
      #else
         void COPYK(const size_t, const size_t, const TYPE,
                    const TYPE*, const size_t, TYPE*);
      #endif
   #else
      #ifdef COPY_C
         void COPYK(const size_t, const size_t, const TYPE*, const TYPE*, 
                    const TYPE*, const TYPE*, TYPE *, const size_t);
      #else
         void COPYK(const size_t, const size_t, const TYPE*,
                    const TYPE*, const size_t, TYPE*, TYPE*);
      #endif
   #endif
#elif defined(TCPLX)
   size_t rszA, rszB, rszC;
   void CAMM_b0(ATL_CSZT mblks, ATL_CSZT nblks, ATL_CSZT K, const TYPE *A,
                const TYPE *B, TYPE *C, const TYPE *pAn, const TYPE *pBn,
                const TYPE *pCn);
   void CAMM_b1(ATL_CSZT mblks, ATL_CSZT nblks, ATL_CSZT K, const TYPE *A,
                const TYPE *B, TYPE *C, const TYPE *pAn, const TYPE *pBn,
                const TYPE *pCn);
   void CAMM_bn(ATL_CSZT mblks, ATL_CSZT nblks, ATL_CSZT K, const TYPE *A,
                 const TYPE *B, TYPE *C, const TYPE *pAn, const TYPE *pBn,
                 const TYPE *pCn);
   #ifdef BETA0
      void KMM(ATL_CSZT mblks, ATL_CSZT nblks, ATL_CSZT K, const TYPE *Ai,
               const TYPE *Bi, TYPE *Ci, const TYPE *pAn, const TYPE *pBn,
               const TYPE *pCn)
      {
         extern size_t rszA, rszB, rszC;
         const TYPE *Ar=Ai+rszA, *Br=Bi+rszB;
         TYPE *Cr = Ci + rszC;
         #ifdef CORDER
            CAMM_b0(mblks, nblks, K, Ai, Bi, Cr, Ar, Br, Cr);
            CAMM_bn(mblks, nblks, K, Ar, Br, Cr, Ar, Bi, Ci);
            CAMM_b0(mblks, nblks, K, Ar, Bi, Ci, Ai, Br, Ci);
            CAMM_b1(mblks, nblks, K, Ai, Br, Ci, pAn, pBn, pCn);
         #else
            CAMM_b0(mblks, nblks, K, Ai, Bi, Cr, Ai, Br, Ci);
            CAMM_b0(mblks, nblks, K, Ai, Br, Ci, Ar, Br, Cr);
            CAMM_bn(mblks, nblks, K, Ar, Br, Cr, Ar, Bi, Ci);
            CAMM_b1(mblks, nblks, K, Ar, Bi, Ci, pAn, pBn, pCn);
         #endif
      }
   #elif defined(BETA1)
      void KMM(ATL_CSZT mblks, ATL_CSZT nblks, ATL_CSZT K, const TYPE *Ai,
               const TYPE *Bi, TYPE *Ci, const TYPE *pAn, const TYPE *pBn,
               const TYPE *pCn)
      {
         extern size_t rszA, rszB, rszC;
         const TYPE *Ar=Ai+rszA, *Br=Bi+rszB;
         TYPE *Cr = Ci + rszC;
         #ifdef CORDER
            CAMM_bn(mblks, nblks, K, Ai, Bi, Cr, Ar, Br, Cr);
            CAMM_bn(mblks, nblks, K, Ar, Br, Cr, Ar, Bi, Ci);
            CAMM_b1(mblks, nblks, K, Ar, Bi, Ci, Ai, Br, Ci);
            CAMM_b1(mblks, nblks, K, Ai, Br, Ci, pAn, pBn, pCn);
         #else
            CAMM_bn(mblks, nblks, K, Ai, Bi, Cr, Ai, Br, Ci);
            CAMM_b1(mblks, nblks, K, Ai, Br, Ci, Ar, Br, Cr);
            CAMM_bn(mblks, nblks, K, Ar, Br, Cr, Ar, Bi, Ci);
            CAMM_b1(mblks, nblks, K, Ar, Bi, Ci, pAn, pBn, pCn);
         #endif
      }
   #else
      void KMM(ATL_CSZT mblks, ATL_CSZT nblks, ATL_CSZT K, const TYPE *Ai,
               const TYPE *Bi, TYPE *Ci, const TYPE *pAn, const TYPE *pBn,
               const TYPE *pCn)
      {
         extern size_t rszA, rszB, rszC;
         const TYPE *Ar=Ai+rszA, *Br=Bi+rszB;
         TYPE *Cr = Ci + rszC;
         #ifdef CORDER
            CAMM_b1(mblks, nblks, K, Ai, Bi, Cr, Ar, Br, Cr);
            CAMM_b1(mblks, nblks, K, Ar, Br, Cr, Ar, Bi, Ci);
            CAMM_bn(mblks, nblks, K, Ar, Bi, Ci, Ai, Br, Ci);
            CAMM_bn(mblks, nblks, K, Ai, Br, Ci, pAn, pBn, pCn);
         #else
            CAMM_b1(mblks, nblks, K, Ai, Bi, Cr, Ai, Br, Ci);
            CAMM_bn(mblks, nblks, K, Ai, Br, Ci, Ar, Br, Cr);
            CAMM_b1(mblks, nblks, K, Ar, Br, Cr, Ar, Bi, Ci);
            CAMM_bn(mblks, nblks, K, Ar, Bi, Ci, pAn, pBn, pCn);
         #endif
      }
   #endif
#else
   #ifndef KMM 
      #define KMM ATL_USERMM
   #endif
   void KMM(ATL_CSZT mblks, ATL_CSZT nblks, ATL_CSZT K, const TYPE *A,
            const TYPE *B, TYPE *C, const TYPE *pAn, const TYPE *pBn,
            const TYPE *pCn);
#endif

struct kmm_struct{
   #ifdef TIME_COPY
      TYPE *A;
      size_t nmblks, nnblks, lda;
      int COLWISE, BM, BN;
   #endif
   int mb, nb, kb;                      /* C: mbxnb, At: kbxmb, B: kbXnb */
   int mu, nu, ku;                      /* needed to compute mblks/nblks */
   int movA, movB, movC;                /* which mat move in flush array? */
   size_t FLSIZE;                       /* min area to move in in bytes */
   int reps;                            /* # calls to kmm in one timing */
   int vlen;                            /* vector length */
   int iam;                             /* thread rank */
   int p;                               /* total number of threads */
   int *pids;                           /* IDs of processors for affinity */
   double mf;                           /* mflop returned by timing */
   volatile unsigned char *chkin;       /* P-len array to signal start/done */
};

#ifdef TIME_COPY
static double getMflops(double m, double n)
#else
static double getMflops(double m, double n, double k)
#endif
{
   #ifdef TIME_TRMVK
     return(1e-6*m*m*n);
   #elif defined(TIME_SYRKK)
      return(1e-6*n*(n+1)*k);
   #elif defined(TIME_COPY)
      return(1e-6*m*n);
   #else
      return(1e-6*2.0*m*n*k);
   #endif
}
static size_t getSetSz(int mvA, int mvB, int mvC, 
                       size_t szA, size_t szB, size_t szC, size_t *NOMVSZ)
{
   size_t nomvsz=0, setsz=0;
   if (mvA)
      setsz += szA;
   else 
      nomvsz += szA;
   if (mvB)
      setsz += szB;
   else 
      nomvsz += szB;
   if (mvC)
      setsz += szC;
   else 
      nomvsz += szC;
   if (NOMVSZ)
      *NOMVSZ = nomvsz;
   return(setsz);
}

double GetKmmMflop
(
   CINT mb, CINT nb, CINT kb,           /* C: mbxnb, At: kbxmb, B: kbXnb */
   CINT mu, CINT nu, CINT ku, CINT vlen,
   int movA, int movB, int movC,        /* which mat move in flush array? */
   struct kmm_struct *pd,               /* problem definition */   
   size_t FLSIZE,                       /* min area to move in in bytes */
   CINT reps                            /* # calls to kmm in one timing */
)
/*
 * Returns MFLOP rate of matmul kernel KMM
 */
{
   void *vp=NULL;
   TYPE *C, *A, *B, *a, *b, *c;
   TYPE *ep, *sp;  /* extra & set ptrs */
   double t0, t1, mf;
   size_t szA, szB, szC, extra, setsz, nsets, tsz, i, j, incA, incB, incC, n;
   #ifdef TIME_COPY
      const size_t lda=pd->lda;
      size_t INCBLK, INCPAN, II, JJ, NN, MM;
      unsigned int B0, B1;
      TYPE *AA=pd->A, *aa;
      #ifdef TCPLX
         TYPE alpha[2] = {0.0, 0.0}, *beta = alpha;
      #else
         TYPE alpha=0.0, beta=0.0;
      #endif
   #else
   const TYPE alpha=1.0;
   TYPE beta=1.0;
   #endif
   CINT mblks = mb/mu, nblks = nb/nu;
   const int NOMOVE = !(movA|movB|movC);
   unsigned int seed = mb*kb + (nb<<14);

   #ifdef TIME_COPY
      if (pd->COLWISE)
      {
         NN = pd->nnblks;
         MM = pd->nmblks;
         INCBLK = mb SHIFT;
         INCPAN = lda*(nb SHIFT); 
         B0 = mb;
         B1 = nb;
      }
      else
      {
         NN = pd->nmblks;
         MM = pd->nnblks;
         INCBLK = lda * (nb SHIFT);
         INCPAN = (mb SHIFT);
         B0 = nb;
         B1 = mb;
      }
      AA += pd->iam * INCPAN;
      INCPAN -= INCBLK*MM;
      II = JJ = 0;
   #endif
/*
 * Get size for each matrix, and round up to ensure we keep alignment
 */
   #ifdef TIME_COPY
      szA = szB = 0;
   #else
      szA = ATL_getszA(mb, kb, mu, ku, vlen);
      szB = ATL_getszB(kb, nb, ku, nu, vlen);
   #endif
   szC = ATL_getszC(mb, nb, mu, nu, vlen);
/*
 * Compute the setsz & extra 
 * setsz: size of moving mats, extra: size of stationary mats
 */
   setsz = getSetSz(movA, movB, movC, szA, szB, szC, &extra);
   if (!NOMOVE && FLSIZE)
      nsets = (ATL_DivBySize(FLSIZE)+setsz-1) / setsz;
   else
      movA = movB = movC = nsets = 0;
   extra += (mu+mu)*nu;
   tsz = ATL_Cachelen << 1;
   tsz = ATL_DivBySize(tsz);
   tsz += nsets*setsz+extra;
   vp = malloc(2*ATL_Cachelen + ATL_MulBySize(tsz));
   assert(vp);
   sp = ATL_AlignPtr(vp);
   ep = sp + nsets*setsz;
   ep = ATL_AlignPtr(ep);
   if (movA)
   {
      A = sp;
      incA = szA SHIFT;
      sp += incA * nsets;
      sp = ATL_AlignPtr(sp);
   }
   else
   {
      A = ep;
      ep += szA SHIFT;
      ep = ATL_AlignPtr(ep);
      incA = 0;
   }
   if (movB)
   {
      B = sp;
      incB = szB SHIFT;
      sp += incB * nsets;
      sp = ATL_AlignPtr(sp);
   }
   else
   {
      B = ep;
      ep += szB SHIFT;
      ep = ATL_AlignPtr(ep);
      incB = 0;
   }
   if (movC)
   {
      C = sp;
      incC = szC SHIFT;
   }
   else
   {
      C = ep;
      incC = 0;
   }
   sp = ATL_AlignPtr(vp);
   for (i=0; i < tsz; i++) 
      sp[i] = dumb_prand(&seed);

   a = A; b = B; c = C;
   t0 = ATL_walltime();
   for (j=0,i=reps; i; i--)
   {
      TYPE *an, *bn, *cn;
      if (++j != nsets)
      {
         an = a+incA;
         bn = b+incB;
         cn = c+incC;
      }
      else
      {
         j = 0;
         an = A; bn = B; cn = C;
      }
      #ifdef TIME_TRMVK
         Mjoin(PATL,ktrsmLLN_rk4)(mb, nb, 1.0, a, c, mb, B);
      #elif defined(TIME_SYRKK)
         KMM(mblks, nblks, kb, a, a, c, an, an, cn);
      #elif defined(TIME_COPY)
         #ifdef COPY_C
            #ifdef TCPLX
               COPYK(mb, nb, alpha, c+szC, c, beta, AA, lda);
            #else
               COPYK(mb, nb, alpha, c, beta, AA, lda);
            #endif
         #else
            #ifdef TREAL
               COPYK(B0, B1, alpha, AA, lda, c);
            #else
               COPYK(B0, B1, alpha, AA, lda, c+szC, c);
            #endif
         #endif
         aa += INCBLK;
         if (++II == MM)
         {
            II = 0;
            aa += INCPAN;
            if (++JJ == NN)
            {
               JJ = 0;
               aa = AA;
            }
         }
      #else
         KMM(mblks, nblks, kb, a, b, c, an, bn, cn);
      #endif
      a = an;
      b = bn;
      c = cn;
   }
   t1 = ATL_walltime() - t0;
   #ifdef TIME_COPY
      #ifdef COPY_C
         mf = reps*getMflops(mb, nb) / t1;
      #else
         mf = reps*getMflops(nb, kb) / t1;  /* need to dist mb/nb eventually */
      #endif
      #ifdef TCPLX
         mf *= 2.0;
      #endif
   #else
      mf = reps*getMflops(mb, nb, kb) / t1;
      #ifdef TCPLX
         mf *= 4.0;
      #endif
   #endif
   free(vp);
   return(mf);
}

@skip #define PRINT_COREID
#ifdef PRINT_COREID
   #include <utmpx.h>
#endif
//#define PRINT_NUMAIDS
#ifdef PRINT_NUMAIDS
   #define _GNU_SOURCE 1
   #include <unistd.h>
   #include <sys/syscall.h>
#endif
void *TimeOnCore(void *vp)
{
   struct kmm_struct *kp = vp;
   const int P = kp->p;
   int i;
   volatile unsigned char *chkin = kp->chkin;
   #ifdef PRINT_COREID
      printf("core=%d\n", sched_getcpu());
   #endif
#ifdef PRINT_NUMAIDS
    unsigned cpu, node;
    syscall(SYS_getcpu, &cpu, &node, NULL);
    printf("cpu=%u, node=%u\n", cpu, node);
#endif
/*
 * First we barrier, so that all cores are active.  Otherwise, 1st core to
 * start may run with bus to himself, and not give us a measure of true
 * parallel performance.  Want full-on contention as in perfect parallel code.
 * We wait on chkin array to have all non-zero entries.  Even on weakly-ordered
 * caches this should work, though the delay may be long.
 */
   #ifdef ATL_NCPU
      chkin[kp->iam] = 1;
      for (i=0; i < P; i++)
         while(!chkin[i]);
   #endif
   kp->mf = GetKmmMflop(kp->mb, kp->nb, kp->kb, kp->mu, kp->nu, kp->ku, 
                        kp->vlen, kp->movA, kp->movB, kp->movC, kp, 
                        kp->FLSIZE, kp->reps);
   return(NULL);
}


#ifndef ATL_NCPU
double *TimeOnCores(struct kmm_struct *kb)
{
   double *mflops;
   int i, p;

   mflops = malloc(sizeof(double));
   assert(mflops);
   p = kb->p;
   kb->iam = 0;
   TimeOnCore(kb);
   free(kb->pids);
   mflops[0] = kb->mf;
   return(mflops);
}
#else
double *TimeOnCores(struct kmm_struct *kb)
{
   struct kmm_struct *kp;
   pthread_t *threads;
   pthread_attr_t *attr;
@skip   unsigned long long cpuset;
   cpu_set_t *cpuset;
   double *mflops;
   int i, p;
   unsigned char *chkin;

   p = kb->p;
/*
 * On PowerPC Linux, pthread_attr_setaffinity_np sometimes attempts to 
 * realloc the cpuset variable, so it must be malloced not taken from
 * the stack.  This is crazy behaviour, but it is what happens.
 */
   cpuset = malloc(sizeof(cpu_set_t));
   kp = malloc(sizeof(struct kmm_struct)*p);
   threads = malloc(sizeof(pthread_t)*p);
   attr = malloc(sizeof(pthread_attr_t)*p);
   mflops = malloc(sizeof(double)*p);
   chkin = malloc(sizeof(char)*p);
   assert(cpuset && kp && threads && attr && mflops && chkin);
   for (i=0; i < p; i++)   /* init chkin to 0 before starting any threads */
      chkin[i] = 0;        /* when all entries non-zero, all thrds started */
   for (i=0; i < p; i++)
   {
      memcpy(kp+i, kb, sizeof(struct kmm_struct));
      kp[i].chkin = (volatile char*)chkin;
      kp[i].iam = i;
      CPU_ZERO(cpuset);
      CPU_SET(kp->pids[i], cpuset);
      assert(!pthread_attr_init(attr+i));
      assert(!pthread_attr_setaffinity_np(attr+i, sizeof(cpu_set_t), cpuset));
      assert(!pthread_attr_setdetachstate(attr+i, PTHREAD_CREATE_JOINABLE));
      assert(!pthread_create(threads+i, attr+i, TimeOnCore, kp+i));
   }
   for (i=0; i < p; i++)
   {
      pthread_join(threads[i], NULL);
      pthread_attr_destroy(attr+i);
      mflops[i] = kp[i].mf;
   }
   free(kp->pids);
   free(kp);
   free(threads);
   free(attr);
   free(cpuset);
   free(chkin);
   return(mflops);
}
#endif

void GetStat(int n, double *d, double *min, double *max, double *avg)
{
   int i;
   double dmin, dmax, dsum;
   
   dmin = dmax = dsum = d[0];
   for (i=1; i < n; i++)
   {
      dmax = (dmax >= d[i]) ? dmax : d[i];
      dmin = (dmin <= d[i]) ? dmin : d[i];
      dsum += d[i];
   }
   *min = dmin;
   *max = dmax;
   *avg = dsum / (double)n;
}

void PrintUsage(char *name, int iarg, char *arg)
{
   fprintf(stderr, "\nERROR around arg %d (%s).\n", iarg, arg ? arg:"unknown");
   fprintf(stderr, "USAGE: %s [flags], where flags are:\n", name);
   fprintf(stderr, "   -p <#> : use # threads (with affinity)\n");
   fprintf(stderr, "   -tl <#> id1 ... id# : spawn # threads to given IDs\n");
   fprintf(stderr, "   -B <#> : mb = nb = kb = #\n");
   fprintf(stderr, "   -m <#> : mb = #\n");
   fprintf(stderr, "   -n <#> : nb = #\n");
   fprintf(stderr, "   -k <#> : kb = #\n");
   fprintf(stderr, "   -V <veclen>\n");
   #ifdef TIME_COPY
      fprintf(stderr, "   -D <M> <lda> <N> <COLWISE>: copy only\n");
      #ifndef COPY_C
      fprintf(stderr, "   -A [a,b]: for A/B copy, set which you are copying\n");
      #endif
   #endif
   fprintf(stderr, "   -u[mnk] <#> : M/N/K loop unrolling is #\n");
   fprintf(stderr, "   -r <#> : set the # of times to call KMM\n");
   fprintf(stderr, "   -R <mf>: set # reps to force <mf> MFLOPs\n");
   fprintf(stderr, "   -F <kb> : set flush size in kilobytes\n");
@skip   fprintf(stderr, "   -C <#> : set ldc; 0 means mb\n");
   fprintf(stderr, "   -M[a,b,c] <#> : mov[A,B,C] = #\n");
   exit(iarg ? iarg : -1);
}

struct kmm_struct *GetFlags(int nargs, char **args, FILE **fpout)
{
   FILE *fp;
   struct kmm_struct *kp;
   double mflops=750.0;
   int i, j, ACPY=1, IGMF=0;  /* ignore mflops.frc file? */
   
   *fpout = NULL;
   kp = malloc(sizeof(struct kmm_struct));
   assert(kp);
   #ifdef TIME_COPY
      kp->nmblks = kp->nnblks = kp->lda = 2000;
      #ifdef COPY_C
         kp->COLWISE = 1;
      #else
         kp->COLWISE = 0;
      #endif
   #endif
   kp->pids = NULL;
   kp->p = 1;
   kp->mb = kp->nb = kp->kb = 40;
   kp->mu = kp->nu = 4;
   kp->ku = 1;
   kp->movA = kp->movB = kp->movC = 0;
   kp->FLSIZE = L2SIZE;
   kp->reps = 0;
   kp->vlen = 1;
   for (i=1; i < nargs; i++)
   {
      if (args[i][0] != '-')
         PrintUsage(args[0], i, args[i]);
      switch(args[i][1])
      {
      #if defined(TIME_COPY) && !defined(COPY_C)
      case 'A':
         if (++i >= nargs)
            PrintUsage(args[0], i, "out of arguments");
         ACPY = (args[i][0] != 'b' && args[i][0] != 'B');
         break;
      #endif
      case 'f':
         if (++i >= nargs)
            PrintUsage(args[0], i, "out of arguments");
         *fpout = fopen(args[i], "w");
         break;
      case 'V':
         if (++i >= nargs)
            PrintUsage(args[0], i, "out of arguments");
         kp->vlen = atoi(args[i]);
         break;
      #ifdef TIME_COPY
      case 'D':  /* -D <M> <lda> <N> <COL> */
         if (i+4 >= nargs)
            PrintUsage(args[0], i, "out of arguments");
         kp->nmblks = atol(args[i+1]);
         kp->lda = atol(args[i+2]);
         kp->nnblks = atol(args[i+3]);
         kp->COLWISE = atoi(args[i+4]);
         i += 4;
         break;
      #endif
      case 'F':
         if (++i >= nargs)
            PrintUsage(args[0], i, "out of arguments");
         kp->FLSIZE = atol(args[i]) * 1024;
         break;
@beginskip
      case 'C':
         if (++i >= nargs)
            PrintUsage(args[0], i, "out of arguments");
         kp->LDC = atoi(args[i]);
         break;
@endskip
      case 'u':
         if (++i >= nargs)
            PrintUsage(args[0], i, "out of arguments");
         j = atoi(args[i]);
         if (args[i-1][2] == 'k')
            kp->ku = j;
         else if (args[i-1][2] == 'n')
            kp->nu = j;
         else
            kp->mu = j;
         break;
      case 'R':
         if (args[i][2] == 'f')
            IGMF=1;
         if (++i >= nargs)
            PrintUsage(args[0], i, "out of arguments");
         mflops = atof(args[i]);
         break;
      case 'r':
         if (++i >= nargs)
            PrintUsage(args[0], i, "out of arguments");
         kp->reps = atoi(args[i]);
         break;
      case 't':
         if (++i >= nargs)
            PrintUsage(args[0], i, "out of arguments");
         kp->p = atoi(args[i]);
         kp->pids = malloc(sizeof(int)*kp->p);
         assert(kp->pids);
         for (j=0; j < kp->p; j++)
         {
            if (++i >= nargs)
               PrintUsage(args[0], i, "out of arguments");
            kp->pids[j] = atoi(args[i]);
         }
         break;
      case 'p':
         if (++i >= nargs)
            PrintUsage(args[0], i, "out of arguments");
         kp->p = atoi(args[i]);
         break;
      case 'm':
         if (++i >= nargs)
            PrintUsage(args[0], i, "out of arguments");
         kp->mb = atoi(args[i]);
         break;
      case 'n':
         if (++i >= nargs)
            PrintUsage(args[0], i, "out of arguments");
         kp->nb = atoi(args[i]);
         break;
      case 'k':
         if (++i >= nargs)
            PrintUsage(args[0], i, "out of arguments");
         kp->kb = atoi(args[i]);
         break;
      case 'B':
         if (++i >= nargs)
            PrintUsage(args[0], i, "out of arguments");
         kp->mb = kp->nb = kp->kb = atoi(args[i]);
         break;
      case 'M':
         if (++i >= nargs)
            PrintUsage(args[0], i, "out of arguments");
         switch(args[i-1][2])
         {
         case 'c':
         case 'C':
            kp->movC = atoi(args[i]);
            break;
         case 'b':
         case 'B':
            kp->movB = atoi(args[i]);
            break;
         case 'a':
         case 'A':
            kp->movA = atoi(args[i]);
            break;
         default:
            PrintUsage(args[0], i-1, "unknown mov matrix");
         }
         break;
      default:
         PrintUsage(args[0], i, args[i]);
      }
   }
/*
 * If there is a tuned <upr>mflops.frc file, use this in preference to the
 * commandline argument unless the -Rf override flag was used
 */
   if (!IGMF)
   {
      char fn[16] = {'s', 'm', 'f', 'o', 'p', 's', '.', 'f', 'r', 'c', '\0'};
      #if defined(DREAL) || defined(DCPLX)
         fn[0] = 'd';
      #endif
      fp = fopen(fn, "r");
      if (fp)
      {
         assert(fscanf(fp, "%le", &mflops) == 1);
         fclose(fp);
      }
   }
   if (!kp->reps)
   {
      kp->reps = (mflops*1000000.0/((2.0*kp->mb)*kp->nb*kp->kb));
      if (kp->reps < 1)
         kp->reps = 1;
   }
   if (!kp->pids)
   {
      kp->pids = malloc(sizeof(int)*kp->p);
      assert(kp->pids);
      #ifdef ATL_ARCH_XeonPHI
      {
         int n4 = ((kp->p)>>2)<<2, nr = kp->p - n4;
         for (j=0; j < n4; j += 2)
         {  
            kp->pids[j] = 2*j;
            kp->pids[j+1] = 2*j+1;
         }
         switch(nr)
         {
         case 3:
            kp->pids[j+2] = 2*(j+2);
         case 2:
            kp->pids[j+1] = 2*j+1;
         case 1:
            kp->pids[j] = 2*j;
            break;
         case 0:;
         }
      }
      #else
         for (j=0; j < kp->p; j++)
             kp->pids[j] = j;
      #endif
   }
   #ifdef TIME_COPY  /* Reduce M/N to nmblks, nnblks, handle P */
   {
      const size_t gap = kp->lda - kp->nmblks;
      unsigned int nb;

      #ifdef TIME_C
      if (ACPY)
      {
         kp->BM = kp->mb;
         kp->BN = kp->kb;
      }
      else
      {
         kp->BM = kp->kb;
         kp->BN = kp->nb;
      }
      #else
         kp->BM = kp->mb;
         kp->BN = kp->nb;
      #endif
      nb = kp->BM;
      kp->nmblks = (kp->nmblks+nb-1)/nb;
      if (!kp->COLWISE)
         kp->nmblks = (kp->nmblks >= kp->p) ? kp->nmblks : kp->p;
      kp->lda = kp->nmblks*nb + gap;
      nb = kp->BN;
      kp->nnblks = (kp->nnblks+nb-1)/nb;
      if (kp->COLWISE)
         kp->nnblks = (kp->nnblks >= kp->p) ? kp->nnblks : kp->p;
      kp->movA = kp->movB = 0;
      kp->movC = 1;
   }
   #endif
   #ifdef TIME_SYRKK
      kp->movB = 0;
   #endif
   return(kp);
}

int main(int nargs, char **args)
{
   struct kmm_struct *kp;
   int i, p;
   double *dp;
   double min, max, avg;
   FILE *fpout = stdout;

   kp = GetFlags(nargs, args, &fpout);
   p = kp->p;
   #ifndef ATL_NCPU
      assert(p < 2);
   #endif
   #ifdef TIME_COPY
   {
      TYPE *A;
      size_t k, N;
      unsigned int seed;

      N = kp->lda * kp->nnblks * kp->nb;
      seed = kp->lda+(kp->nnblks<<8);
      kp->A = A = malloc(ATL_MulBySize(N));
      assert(A);
      for (k=0; k < N; k++)
         A[k] = dumb_prand(&seed);
   }
   #endif
   dp = TimeOnCores(kp);
   free(kp);
   GetStat(p, dp, &min, &max, &avg);
   printf("PER-CORE: %le", dp[0]);
   for (i=1; i < p; i++)
      printf(", %le", dp[i]);
   printf("\nALL CORES: min=%.2f, max=%.2f, avg=%.2f\n", min, max, avg);
   if (fpout)
   {
      fprintf(fpout, "%d 1\n", p);
      for (i=0; i < p; i++)
         fprintf(fpout, "%e\n", dp[i]);
   }
   free(dp);
   if (fpout && fpout != stdout && fpout != stderr)
      fclose(fpout);
   exit(0);
}
@ROUT gmmsearch mmsearchN
void PrintUsage(char *name, int ierr, char *flag)
{
@ROUT mmsearchN
   fprintf(stderr, "%s: GEMM search driver\n", name);
@ROUT gmmsearch 
   fprintf(stderr, 
           "%s searches for the best kernel that emit_mm.c can produce\n",
           name);
@ROUT gmmsearch mmsearchN
   fprintf(stderr, "For all gemm parameters (eg., nb) if they are not specified or\nspecified as 0, then the search determines them,\notherwise they are forced to the commandline specification.\n\n");
           
   if (ierr > 0)
      fprintf(stderr, "Bad argument #%d: '%s'\n",
              ierr, flag ? flag : "Not enough arguments");
   else if (ierr < 0)
      fprintf(stderr, "ERROR: %s\n", flag);
   fprintf(stderr, "USAGE: %s [flags]:\n", name);
   fprintf(stderr, "   -v # : higher numbers print out more\n");
   fprintf(stderr, "   -p [s,d,c,z]: set precision prefix \n");
   fprintf(stderr, "   -b <nb> : blocking factor \n");
   fprintf(stderr, "   -r <nreg> : number of registers to assume\n");
   fprintf(stderr, "   -k <ku> : K unrolling factor \n");
   fprintf(stderr, "   -l <lat> : multiply latency to assume\n");
   fprintf(stderr, "   -M <muladd> : -1: search 0: separate mul&add : else MACC\n");
@ROUT mmsearchN
   fprintf(stderr, "   -o <outfile> : defaults to res/<pre>MMRES.sum\n");
@ROUT gmmsearch mmsearchN
   fprintf(stderr, "   -o <outfile> : defaults to res/<pre>gMMRES.sum\n");
@ROUT gmmsearch mmsearchN
   exit(ierr ? ierr : -1);
}

char GetFlags(int nargs, char **args, int *verb, int *nregs, int *nb, 
              int *ku, int *MACC, int *lat, char **outfile)
{
   char pre, ch;
   int i;

   *outfile = NULL;
   *verb = 1;
   *MACC = -1;
   *lat = *nregs = *nb = *ku = 0;
   pre = 'd';
   for (i=1; i < nargs; i++)
   {
      if (args[i][0] != '-')
         PrintUsage(args[0], i, args[i]);
      switch(args[i][1])
      {
      case 'o':
         if (++i >= nargs)
            PrintUsage(args[0], i, NULL);
         *outfile = DupString(args[i]);
         break;
      case 'p':  /* -p <pre> */
         if (++i >= nargs)
            PrintUsage(args[0], i, NULL);

         ch = tolower(args[i][0]);
         assert(ch == 's' || ch == 'd' || ch == 'c' || ch == 'z');
         pre = ch;
         break;
      case 'M':
         if (++i >= nargs)
            PrintUsage(args[0], i, NULL);
         *MACC = atoi(args[i]);
         break;
      case 'v':
         if (++i >= nargs)
            PrintUsage(args[0], i, NULL);
         *verb = atoi(args[i]);
         break;
      case 'b':
         if (++i >= nargs)
            PrintUsage(args[0], i, NULL);
         *nb = atoi(args[i]);
         break;
      case 'l':
         if (++i >= nargs)
            PrintUsage(args[0], i, NULL);
         *lat = atoi(args[i]);
         break;
      case 'r':
         if (++i >= nargs)
            PrintUsage(args[0], i, NULL);
         *nregs = atoi(args[i]);
         break;
      default:
         PrintUsage(args[0], i, args[i]);
      }
   }
   assert(*nb >= 0);
@ROUT mmsearchN `assert(*nregs >= 0);`
   if (*outfile == NULL)
   {
@ROUT mmsearchN
      *outfile = DupString("res/dMMRES.sum");
@ROUT gmmsearch
      *outfile = DupString("res/dgMMRES.sum");
@ROUT gmmsearch mmsearchN
      (*outfile)[4] = pre;
   }
   return(pre);
}

@ROUT gmmsearch
double TryKUs
(
   ATL_mmnode_t *mmp,
   char pre,                    /* precision */
   int verb,                    /* verbosity level */
   int MACC,                    /* 0 : separate mult&add, else MACC */
   int lat0,                    /* multiply latency */
   int beta,                    /* 0,1 beta, else beta=X */
   int nb,                      /* blocking factor */
   int mu, int nu, int ku,      /* unrolling factors */
   int fftch,                   /* do bogus fetch of C at top of loop? */
   int iftch,                   /* # of initial fetches to do */
   int nftch,                   /* # of fetches to do thereafter */
   int LDTOP,                   /* 1: load C at top, else at bottom */
   int pf                       /* prefetch strategy */
)
/*
 * If ku is set, times only that value, else tries both ku=1 & ku=nb
 * RETURNS: best performance of timed problems, with ku set correctly,
 *          but the generator flags may be bad!
 */
{
   double mf, mf1;
   int lat;

   assert(mu > 0 && nu > 0);
   if (ku)
   {
      mmp->ku = ku;
      lat = GetGoodLat(MACC, nb, mu, nu, ku, lat0);
      mf = TimeGMMKernel(verb, 0, pre, MACC, lat, beta, nb, mu, nu, ku, 
                         fftch, iftch, nftch, LDTOP, pf, -1, -1);
   }
   else
   {
      lat = GetGoodLat(MACC, nb, mu, nu, 1, lat0);
      mf = TimeGMMKernel(verb, 0, pre, MACC, lat, beta, nb, mu, nu, nb, 
                         fftch, iftch, nftch, LDTOP, pf, -1, -1);
      mf1 = TimeGMMKernel(verb, 0, pre, MACC, lat, beta, nb, mu, nu, 1, 
                          fftch, iftch, nftch, LDTOP, pf, -1, -1);
      if (mf1 >= mf)
      {
         mmp->ku = 1;
         mf = mf1;
      }
   }
   return(mf);
}

double TryPFs
(
   ATL_mmnode_t *mmp,
   char pre,                    /* precision */
   int verb,                    /* verbosity level */
   int MACC,                    /* 0 : separate mult&add, else MACC */
   int lat,                     /* multiply latency */
   int beta,                    /* 0,1 beta, else beta=X */
   int nb,                      /* blocking factor */
   int mu, int nu, int ku,      /* unrolling factors */
   int fftch,                   /* do bogus fetch of C at top of loop? */
   int iftch,                   /* # of initial fetches to do */
   int nftch,                   /* # of fetches to do thereafter */
   int LDTOP                    /* 1: load C at top, else at bottom */
)
{
   double mf0, mf1;

   mf0 = TryKUs(mmp, pre, verb, MACC, lat, beta, nb, mu, nu, ku, fftch, 
                iftch, nftch, LDTOP, 0);
   #ifndef ATL_NOPREFETCH
      mf1 = TryKUs(mmp, pre, verb, MACC, lat, beta, nb, mu, nu, ku, fftch, 
                   iftch, nftch, LDTOP, 1);
   #else
      mf1 = 0.0;
   #endif
   mmp->pref = (mf1 > mf0);
   return((mmp->pref) ? mf1 : mf0);
}

void ConfirmMACC(char pre, int verb, int nregs, int nb, int ku,
                 int *MACC, int *lat)
{
   char upr;
   int maccB, latB, latR, mu, nu;
   double mf, mfB;
   ATL_mmnode_t *mmp;

   mmp = GetMMNode();

   if (pre == 'd' || pre == 's')
      upr = pre;
   else if (pre == 'z')
      upr = 'd';
   else 
      upr = 's';
   GetMulAdd(upr, MACC, lat);
   if (verb)
      printf("\nCONFIRMING MACC=%d AND LAT=%d WITH FORCED NREGS=%d\n", 
             *MACC, *lat, nregs);
/*
 * Find performance of present MACC setting
 */
   maccB = *MACC;
   latB = *lat;
   GetSafeMUNU(nregs, maccB, latB, &mu, &nu);
   mfB = TryKUs(mmp, pre, verb, maccB, latB, 1, nb, mu, nu, ku, 0, mu+nu, 1, 
                0, 0);
   if (verb)
      printf("   MACC=%1d, lat=%2d, mu=%2d, nu=%2d, mf=%.2f\n", 
             maccB, latB, mu, nu, mfB);
/*
 * If no MACC, see if latency = 1 is just as good (dynamically scheduled mach)
 */
   if (!maccB)
   {
      GetSafeMUNU(nregs, 0, 1, &mu, &nu);
      mf = TryKUs(mmp, pre, verb, 0, 1, 1, nb, mu, nu, ku, 0, mu+nu, 1, 0, 0);
      if (verb)
         printf("   MACC=%1d, lat=%2d, mu=%2d, nu=%2d, mf=%.2f\n", 
                0, 1, mu, nu, mf);
      if (mf > mfB)
      {
         mfB = mf;
         latB = 1;
      }
   }
/*
 * Find setting of reverse MACC setting, same latency
 */
   GetSafeMUNU(nregs, !maccB, *lat, &mu, &nu);
   mf = TryKUs(mmp, pre, verb, maccB, *lat, 1, nb, mu, nu, ku, 0, mu+nu, 1, 
               0, 0);
   if (verb)
      printf("   MACC=%1d, lat=%2d, mu=%2d, nu=%2d, mf=%.2f\n", 
             !maccB, *lat, mu, nu, mf);
   if (mf > mfB || (!maccB && mf == mfB))
   {
      maccB = !maccB;
      latB = *lat;
      mfB = mf;
   }
/*
 * Try to reverse MACC to 0, lat=1 (dynamically scheduled machines)
 */
   if (*MACC == 1)
   {
      GetSafeMUNU(nregs, 0, 1, &mu, &nu);
      mf = TryKUs(mmp, pre, verb, 0, 1, 1, nb, mu, nu, ku, 0, mu+nu, 1, 0, 0);
      if (verb)
         printf("   MACC=%1d, lat=%2d, mu=%2d, nu=%2d, mf=%.2f\n", 
                0, 1, mu, nu, mf);
      if (mf > mfB)
      {
         mfB = mf;
         latB = 1;
         maccB = 0;
      }
   }
   if (verb)
      printf("CHOSE MACC=%d LAT=%d (%.2f)\n", maccB, latB, mfB);
   *MACC = maccB;
   *lat = latB;
}

double FindNumRegsByMACC(char pre, int verb, int nb, int ku, int MACC, int lat0,
                         int *NREGS, int *MU, int *NU)
{
   int i, mu, nu, muB, nuB, ForceMACC, lat;
   double mf, mfB;
   ATL_mmnode_t *mmp;

   mmp = GetMMNode();
   mfB = 0.0;
   for (i=8; i < 1024; i *= 2)
   {
      if (!MACC)
      {
         lat = i>>1;                       /* don't allow lat to take up */
         lat = (lat > lat0) ? lat0 : lat;  /* more than 1/2 the registers */
      }
      else
         lat = lat0;
      GetSafeMUNU(i, MACC, lat, &mu, &nu);
      mf = TryKUs(mmp, pre, verb, MACC, lat, 1, nb, mu, nu, ku, 0, mu+nu, 1, 
                  0, 0);
      if (verb)
         printf(
 "   nreg=%3d: nb=%2d, mu=%2d, nu=%2d, ku=%2d, MACC=%1d, lat=%2d, mf=%.2f\n", 
                i, nb, mu, nu, mmp->ku, MACC, lat, mf);
      if (mf > mfB)
      {
         mfB = mf;
         muB = mu;
         nuB = nu;
      }
/*    
 *    Call a 8% decline in performance evidence of register overflow
 */

      else if (1.08*mf < mfB)
         break;
   }
   *NREGS = i>>1;
   *MU = muB;
   *NU = nuB;
   return(mfB);
}

int FindNumRegs(char pre, int verb, int nb, int ku, int *MACC, int *lat)
/*
 * Finds an estimate for the number of registers the compiler will let
 * you use in a generated matmul
 */
{
   int nregs, nr, ForceMACC, mu, nu, lat0;
   double mf, mf1, mfmacc;
   FILE *fp;
   char ln[128];

   sprintf(ln, "res/%cfpuMM", pre);
   fp = fopen(ln, "r");
   if (fp)
   {
      if (fgets(ln, 128, fp))  /* skip header */
      {
         if (fscanf(fp, " %d %d %d", &nregs, MACC, lat) == 3)
         {
            fclose(fp);
            if (verb)
               printf(
                  "READ IN NUMBER OF GEMM REGISTERS = %d, MACC=%d, lat=%d:\n", 
                  nregs, *MACC, *lat);
            sprintf(ln, "res/%cnreg", pre);
            fp = fopen(ln, "w");
            fprintf(fp, "%d\n", nregs);
            fclose(fp);
            return(nregs);
         }
      }
      fclose(fp);
   }

   ForceMACC = (*MACC >= 0);
   if (ForceMACC && *MACC && !(*lat))
   {
      fprintf(stderr, 
              "If you force no MACC, then you must also force latency!\n");
      exit(-1);
   }
   if (pre == 'z')
      return(FindNumRegs('d', verb, nb, ku, MACC, lat));
   else if (pre == 'c')
      return(FindNumRegs('s', verb, nb, ku, MACC, lat));
   if (verb)
      printf("\nESTIMATING THE NUMBER OF USEABLE REGISTERS FOR GEMM:\n");
   if (!ForceMACC)
      GetMulAdd(pre, MACC, lat);
   lat0 = *lat;
   mf = FindNumRegsByMACC(pre, verb, nb, ku, *MACC, *lat, &nregs, &mu, &nu);
/*
 * Using separate multiply and add is expensive in terms of registers,
 * and is often messed up by compilers, so let's try lat=1 (for dynamically
 * scheduled machines), and using a MACC, and see what happens
 */
   if (!ForceMACC && *MACC == 0)
   {
      if (*lat > 1)
      {
         printf("\n");
         mf1 = FindNumRegsByMACC(pre, verb, nb, ku, 0, 1, &nr, &mu, &nu);
         if (mf1 >= mf)  /* latency of 1 just as good as longer latency */
         {
            nregs = nr;
            *lat = 1;
         }
      }
      printf("\n");
      mfmacc = FindNumRegsByMACC(pre, verb, nb, ku, 1, lat0, &nr, &mu, &nu);
      if (mfmacc > mf && mfmacc >= mf1) /* MACC is better */
      {
         nregs = nr;
         *MACC = 1;
         *lat = lat0;
      }
   }

   fp = fopen(ln, "w");
   assert(fp);
   fprintf(fp, "NREG  MACC  LAT\n%4d %5d %4d\n", nregs, *MACC, *lat);
   fclose(fp);
/*
 * Write # of registers to <pre>nreg for use by sysinfo tuning
 */
   sprintf(ln, "res/%cnreg", pre);
   fp = fopen(ln, "w");
   fprintf(fp, "%d\n", nregs);
   fclose(fp);

   if (verb)
      printf("NUMBER OF ESTIMATED GEMM REGISTERS = %d, MACC=%d, lat=%d:\n", 
             nregs, *MACC, *lat);
   return(nregs);
}

int GetBigNB(char pre)
{
   int i, L1Elts;
   if (pre == 'd' || pre == 'z')
      L1Elts = 1024/8;
   else 
      L1Elts = 1024/4;
   L1Elts *= GetL1CacheSize();
   for (i=16; i*i < L1Elts; i += 4);
   if (i*i > L1Elts) 
      i -= 4;
   if (i > 80)
      i = 80;
   return(i);
}

int GetSmallNB(char pre)
{
   int i, L1Elts;
   const int imul = (pre == 'c' || pre == 'z') ? 6 : 3;
   if (pre == 'd' || pre == 'z')
      L1Elts = 1024/8;
   else 
      L1Elts = 1024/4;
   L1Elts *= GetL1CacheSize();
   for (i=16; imul*i*i < L1Elts; i += 4);
   if (imul*i*i > L1Elts) 
      i -= 4;
   i = Mmin(i,80);
   i = Mmax(i,16);
   return(i);
}

ATL_mmnode_t *FindBestNB
(
   char pre,   /* precision, one of s,d,c,z */
   int verb,   /* verbosity */
   ATL_mmnode_t *mmp,  /* input/output struct for best case found so far */
   int ku      /* 0: tune ku, else we must use this ku */
)
/*
 * This function tries to find the NB to use.  It varies NB, prefetch,
 * and ku (if allowed, but only between 1 and full unrolling)
 * RETURNS: matmul struct of best found case 
 */
{
   int bN, b0, binc, nbB, muB, nuB, pfB, MACC, lat, KUISKB=0, i;
   double mf, mfB, mf1;

   nbB = mmp->nbB;
   mfB = mmp->mflop[0];
   muB = mmp->mu;
   nuB = mmp->nu;
   pfB = mmp->pref;
   MACC = mmp->muladd;
   lat = mmp->lat;
/*
 * Find largest block factor to tune; Since L1 estimate may be wrong,
 * make sure that larger block factors aren't competitive, but max
 * NB will be 80 regardless to avoid cleanup nightmare
 */
   if (verb)
      printf("\nFINDING UPPER BOUND ON NB:\n");
   bN = GetBigNB(pre);  /* our guess for largest useful NB */
   while (bN < 80)
   {
      mf = TryKUs(mmp, pre, verb, MACC, lat, 1, bN+4, muB, nuB, ku,
                  0, muB+nuB, 1, 0, 0);
      printf("   nb=%3d, mu=%3d, nu=%3d, ku=%3d, MACC=%d, lat=%d, mf=%.2f\n",
             bN+4, muB, nuB, mmp->ku, MACC, lat, mf);
      if (mf > mfB)
      {
         mfB = mf;
         nbB = bN+4;
      }
      else
         break;
      bN += 4;
   }
   if (bN > 80)
      bN = 80;
   if (verb)
      printf("NB UPPER BOUND CHOSEN AS : %d (%.2f)\n", bN, mfB);
/*
 * See if lowering NB past when all matrices should fit is useful
 * (again, L1 detection could be wrong)
 */
   if (verb)
      printf("\nFINDING LOWER BOUND ON NB:\n");
   b0 = GetSmallNB(pre);
   mf1 = TryKUs(mmp, pre, verb, MACC, lat, 1, b0, muB, nuB, ku,
                0, muB+nuB, 1, 0, 0);
   printf("   nb=%3d, mu=%3d, nu=%3d, ku=%3d, MACC=%d, lat=%d, mf=%.2f\n",
          b0, muB, nuB, mmp->ku, MACC, lat, mf1);
   while(b0 > 20)
   {
      mf = TryKUs(mmp, pre, verb, MACC, lat, 1, b0-4, muB, nuB, ku,
                  0, muB+nuB, 1, 0, 0);
      printf("   nb=%3d, mu=%3d, nu=%3d, ku=%3d, MACC=%d, lat=%d, mf=%.2f\n",
             b0-4, muB, nuB, mmp->ku, MACC, lat, mf);
      if (mf < mf1)
         break;
      else if (mf > mfB)
      {
         mfB = mf;
         nbB = b0-4;
      }
      b0 -= 4;
   }
   if (verb)
      printf("NB LOWER BOUND CHOSEN AS : %d\n", b0);

/*
 * Now try all NBs with varying prefetch
 */
   binc = (pre == 's' || pre == 'c') ? 4 : 2;
   KUISKB = (!ku && mmp->ku == mmp->nbB);
   b0 = (b0/binc)*binc;
   bN = (bN/binc)*binc;
   if (verb)
      printf("\nFINDING BEST NB AND PREFETCH SETTING IN RANGE [%d,%d,%d]:\n",
             b0, bN, binc);

   for (i=b0; i <= bN; i += binc)
   {
      mf = TryPFs(mmp, pre, verb, MACC, lat, 1, i, muB, nuB, KUISKB ? i:ku,
                  0, muB+nuB, 1, 0);
      printf(
      "   nb=%3d, pf=%d, mu=%3d, nu=%3d, ku=%3d, MACC=%d, lat=%d, mf=%.2f\n",
             i, mmp->pref, muB, nuB, mmp->ku, MACC, lat, mf);
      if (mf > mfB)
      {
         mfB = mf;
         nbB = i;
         pfB = mmp->pref;
      }
   }
   if (verb)
      printf("BEST NB=%d, BEST PREFETCH=%d (%.2f)\n", nbB, pfB, mfB);
   mmp->mflop[0] = mfB;
   mmp->mbB = mmp->nbB = mmp->kbB = nbB;
   mmp->pref = pfB;
   return(mmp);
}
ATL_mmnode_t *FindBestKU
(
   char pre,   /* precision, one of s,d,c,z */
   int verb,   /* verbosity */
   ATL_mmnode_t *mmp   /* input/output struct for best case found so far */
)
/*
 * Find best K unrolling.  There is no data cache dependence here, so time
 * with in-cache operands for increases speed and accuracy
 */
{
   int k, kuB, latB, kN, incK, lat;
   int nb, LAT, MACC, mu, nu, pf;
   double mf, mfB;

   LAT = mmp->lat;  /* canonical latency */
   MACC = mmp->muladd;
   mu = mmp->mu;
   nu = mmp->nu;
   nb = mmp->nbB;
   pf = mmp->pref;
   if (verb)
      printf("TRYING KUs FOR NB=%d, PF=%d, MU=%d, NU=%d MACC=%d, LAT=%d:\n",
             nb, pf, mu, nu, MACC, LAT);
/*
 * Try ku=1 as default
 */
   kuB = 1;
   latB = lat = GetGoodLat(MACC, nb, mu, nu, 1, LAT);
   mfB = TimeGMMKernel(verb, 0, pre, MACC, lat, 1, nb, mu, nu, 1, 
                       0, mu+nu, 1, 0, pf, -1, -1);
   if (verb)
      printf("   KU=%d, lat=%d, mf=%.2f\n", 1, lat, mfB);
/*
 * Try NB/2 as maximal unrolling that actually has a loop
 */
   k = nb>>1;
   lat = GetGoodLat(MACC, nb, mu, nu, k, LAT);
   mf = TimeGMMKernel(verb, 0, pre, MACC, lat, 1, nb, mu, nu, k, 
                      0, mu+nu, 1, 0, pf, -1, -1);
   if (verb)
      printf("   KU=%d, lat=%d, mf=%.2f\n", k, LAT, mf);
   if (mf > mfB)
   {
      mfB = mf;
      kuB = nb;
      latB = lat;
   }
/*
 * Try fully unrolled, give it .5% bonus since it is easier on lat, etc.
 */
   mf = TimeGMMKernel(verb, 0, pre, MACC, lat, 1, nb, mu, nu, nb, 
                      0, mu+nu, 1, 0, pf, -1, -1);
   mf *= 1.005;
   if (verb)
      printf("   KU=%d, lat=%d, mf=%.2f\n", nb, LAT, mf);
   if (mf > mfB)
   {
      mfB = mf;
      kuB = nb;
      latB = LAT;
   }
/*
 * Have already tried 1 & KB, so now try 2, 4, 6, 8
 */
   for (k=2; k <= 8; k += 2)
   {
      lat = GetGoodLat(MACC, nb, mu, nu, k, LAT);
      mf = TimeGMMKernel(verb, 0, pre, MACC, lat, 1, nb, mu, nu, k, 
                         0, mu+nu, 1, 0, pf, -1, -1);
      if (verb)
         printf("   KU=%d, lat=%d, mf=%.2f\n", k, LAT, mf);
      if (mf > mfB)
      {
         mfB = mf;
         kuB = k;
         latB = lat;
      }
   }
/*
 * Try all cases in range [8,nb/2,4]
 */
   kN = nb>>1;
   if (!mmp->muladd && mmp->lat > 2)
   {
      incK = mmp->lat;
      k = (incK >= 8) ? incK : (8/incK)*incK;
   }
   else
   {
      incK = 4;
      k = 8;
   }
   for (; k < kN; k += incK)
   {
      lat = GetGoodLat(MACC, nb, mu, nu, k, LAT);
      mf = TimeGMMKernel(verb, 0, pre, MACC, lat, 1, nb, mu, nu, k, 
                         0, mu+nu, 1, 0, pf, -1, -1);
      if (verb)
         printf("   KU=%d, lat=%d, mf=%.2f\n", k, LAT, mf);
      if (mf > mfB)
      {
         mfB = mf;
         kuB = k;
         latB = LAT;
      }
   }
/* 
 * Time the best found case out-of-cache so we it can be compared to others
 */
   lat = GetGoodLat(MACC, nb, mu, nu, kuB, LAT);
   mfB = TimeGMMKernel(verb, 0, pre, MACC, lat, 1, nb, mu, nu, kuB,
                       0, mu+nu, 1, 0, pf, -1, -1);
   mmp->ku = kuB;
   mmp->lat = latB;
   mmp->mflop[0] = mfB;
   if (verb)
      printf("BEST KU=%d, lat=%d (%.2f)\n", kuB, latB, mfB);
   return(mmp);
}

ATL_mmnode_t *FindBestRest
(
   char pre,   /* precision, one of s,d,c,z */
   int verb,   /* verbosity */
   ATL_mmnode_t *mmp   /* input/output struct for best case found so far */
)  /* tunes iftch, nftch, fftch, LDTOP, tries opposite muladd  */
{
   int i, j, n, nelts, nb, mu, nu, pf, MACC, lat, ku;
   int ifB, nfB, ffB, ldtopB;
   double mfB, mf, mf0;

   nb = mmp->nbB;
   pf = mmp->pref;
   mu = mmp->mu;
   nu = mmp->nu;
   ldtopB = 0;
   ifB = nelts = mu + nu;
   nfB = 1;
   ffB = 0;
   mfB = 0;
   MACC = mmp->muladd;
   lat = mmp->lat;
   ku = mmp->ku;
   if (verb)
      printf( "FINDING BEST FETCH PATTERN FOR nb=%d, mu=%d, nu=%d, ku=%d\n",
             nb, mu , nu, ku);
   for (i=2; i <= nelts; i++)
   {
      n = nelts - i;
      n = Mmin(i, n);
      if (!n)
         n = 1;
      for (j=1; j <= n; j++)
      {
         mf = TimeGMMKernel(verb, 1, pre, MACC, lat, 1, nb, mu, nu, ku,
                            0, i, j, 0, pf, -1, -1);
         if (verb)
            printf ("   ifetch=%2d, nfetch=%2d, mf=%.2f\n", i, j, mf);
         if (mf > mfB)
         {
            ifB = i;
            nfB = j;
            mfB = mf;
         }
      }
   }
/*
 * overwrite bad ifetch value output file with selected one
 */
   mfB = TimeGMMKernel(verb, 1, pre, MACC, lat, 1, nb, mu, nu, ku,
                       0, ifB, nfB, 0, pf, -1, -1);
   if (verb)
      printf("   best case retimed as mf=%.2f\n", mfB);
   mmp->mflop[0] = mfB;
   mmp->iftch = ifB;
   mmp->nftch = nfB;
   if (verb)
      printf("BEST IFETCH=%d, NFETCH=%d (%.2f)\n", ifB, nfB, mfB);
/*
 * Try force fetch for beta=0
 */
   if (verb > 1)
      printf("TRYING FALSE FETCH FOR BETA=0 CASES:\n");
   mf0 = TimeGMMKernel(verb, 1, pre, MACC, lat, 0, nb, mu, nu, ku,
                       0, ifB, nfB, 0, pf, -1, -1);
   if (verb > 1)
      printf("   noFF=%.2f\n", mf0);
   mf = TimeGMMKernel(verb, 1, pre, MACC, lat, 0, nb, mu, nu, ku,
                      1, ifB, nfB, 0, pf, -1, -1);
   if (verb > 1)
      printf("   yesFF=%.2f\n", mf);
   if (mf > mf0)
      ffB = 1;
   mmp->fftch = ffB;
/*
 * If loading C at top is 2% faster, take it despite error bound hit
 */
   if (verb)
      printf("TRYING LOAD-AT-TOP (load-at-bottom %.2f)\n", mfB);
   mf  = TimeGMMKernel(verb, 0, pre, MACC, lat, 1, nb, mu, nu, ku,
                       ffB, ifB, nfB, 1, pf, -1, -1);
   if (verb)
      printf("   load-at-top, mf=%.2f\n", mf);
   if (mfB*1.02 > mf)
   {
      if (verb)
         printf("STICKING WITH LOAD-AT-BOTTOM\n");
   }
   else
   {
      ldtopB = 1;
      if (verb)
         printf("SWITCHING TO LOAD-AT-TOP\n");
      mmp->flag |= (1<<MMF_LDCTOP);
      mfB = mf;
   }

/*
 * See if reversing muladd setting is helpful
 */
   if (verb)
      printf("TRYING SWAP OF MACC (present, madd=%d, lat=%d, mf=%.2f)\n", 
             MACC, lat, mfB);
   if (MACC)
   {
      i = Mmax(mmp->lat, 4);
      i = GetGoodLat(0, nb, mu, nu, ku, i);
   }
   else 
      i = mmp->lat;
   mf  = TimeGMMKernel(verb, 0, pre, !MACC, i, 1, nb, mu, nu, ku,
                       ffB, ifB, nfB, ldtopB, pf, -1, -1);
   if (verb)
      printf("   macc=%d, lat=%d, mf=%.2f\n", !MACC, i, mf);
   if (mf > mfB)
   {
      mmp->muladd = !MACC;
      mmp->lat = i;
      mfB = mf;
      if (verb)
         printf("SWITCHING TO NEW MACC SETTING!\n");
   }
   else if (verb)
      printf("KEEPING MACC SETTING.\n");
   mmp->mflop[0] = mfB;
   return(mmp);
}

ATL_mmnode_t *FindBestGenGemm
(
   char pre,   /* precision, one of s,d,c,z */
   int verb,   /* verbosity */
   int nregs,  /* max # of registers to use */
   int MACC,   /* 1: machine has multiply & accumulate, else separate */
   int lat,    /* latency on multiply */
   int FNB,    /* is it required to use NB, or can we tune? */
   int NB,     /* suggested nb */
   int ku      /* 0: tune ku, else we must use this ku */
)
/*
 * This routine finds the best copy matmul case that can be generated by
 * emit_mm.c.  It will search over the following parameters:
 *    (nb,pf), (mu,nu), ku, nftch, iftch, fftch, LDTOP
 *
 * pf is currently 1 or 0, and it controls whether the next block of A is
 * prefetched or not.
 *
 * LDTOP determines if we load C values before entering the K loop (TOP)
 * or after.  After gives better error bound, so give it slight advantage
 *
 * nftch,iftch are crude load scheduling parameters, and they tend to
 * have little affect on most machines (the compiler usually reschedules
 * the loads on its own).
 *
 * fftch causes the generator to load C at the top of the loop even
 * when we are don't need the values there, so that C is in cache at
 * the bottom of the loop when we need it.
 *
 * RETURNS: filled structure with best gemm case found
 */
{
   ATL_mmnode_t *mmp;
   int nb, N, Ng, i, j, mu, nu, nbB, muB, nuB;
   int *mus, *nus, *ip;
   double mf, mfB, mf1;
   double *fpls;
   #ifdef ATL_GAS_x8664
      #define NEXMU 5
      int exmu[NEXMU] = {4, 6, 8, 10, 12};
      int exnu[NEXMU] = {1, 1, 1, 1,  1};
   #elif defined(ATL_GAS_x8632)
      #define NEXMU 4
      int exmu[NEXMU] = {3, 4, 6, 2};
      int exnu[NEXMU] = {1, 1, 1, 2};
   #endif
   char upr;
   char ln[128];

/*
 * Use either required nb, or one that is a multiple of a lot of our
 * unrolling factors;  Use a big block factor so that our register blocking
 * matters more (cache is covering less of costs)
 */
   if (FNB)
      nb = NB;
   else
   {
      nb = (GetBigNB(pre)/12)*12;
      if (nb < 24)
         nb = 24;
   }
   if (pre == 'd' || pre == 's')
   {
      mmp = GetMMNode();
      FillInGMMNode(verb, mmp, pre, MACC, lat, 1, nb, 1, 1, 1, 0, 2, 1, 0, 0);

/*
 *    Get all MU/NU unrollings, Ng of them are competitive on flops/load ratio.
 *    For x86, always include extra 1-D blockings in mix, even if they
 *    are not judged competive (because if reg-reg moves aren't free, which
 *    is true for older x86 machines, 2-D register blocks don't really work
 *    due to 2-operand assembly)
 */
      GetMuNus(nregs, MACC, lat, &Ng, &N, &mus, &nus, &fpls);
      free(fpls);
      #ifdef NEXMU
         for (j=0; j < NEXMU; j++)
         {
            mu = exmu[j];
            nu = exnu[j];
            for (i=0; i < Ng; i++)
               if (mus[i] == mu && nus[i] == nu) break;
            if (i == Ng)
            {
               if (Ng >= N)
               {
                  ip = malloc((Ng+1)*sizeof(int));
                  assert(ip);
                  for (i=0; i < Ng; i++)
                     ip[i] = mus[i];
                  free(mus);
                  mus = ip;
                  ip = malloc((Ng+1)*sizeof(int));
                  assert(ip);
                  for (i=0; i < Ng; i++)
                     ip[i] = nus[i];
                  free(nus);
                  nus = ip;
               }
               mus[Ng] = mu;
               nus[Ng] = nu;
               Ng++;
            }
         }
      #endif
      if (verb)
         printf("PROBING FOR M AND N UNROLLING FACTORS:\n");
/*
 *    Try all competitive unrolling factors 
 */
      mfB = 0;
      muB = nuB = 1;
      for (i=0; i < Ng; i++)
      {
         mf = TryKUs(mmp, pre, verb, MACC, lat, 1, nb, mus[i], nus[i], ku,
                     0, mus[i]+nus[i], 1, 0, 0);
         
         printf("   nb=%3d, mu=%3d, nu=%3d, ku=%3d, MACC=%d, lat=%d, mf=%.2f\n",
                nb, mus[i], nus[i], mmp->ku, MACC, lat, mf);
         if (mf > mfB)
         {
            muB = mus[i];
            nuB = nus[i];
            mfB = mf;
         }
      }
      mmp->mu = muB;
      mmp->nu = nuB;
      mmp->iftch = muB+nuB;
      mmp->mflop[0] = mfB;
      printf("SELECTED MU=%d, NU=%d (%.2f)\n", muB, nuB, mfB);
      free(mus);
      free(nus);
      nbB = nb;
   }
   else /* complex types gets their MU & NU from real cases */
   {
      upr = (pre == 'z') ? 'd' : 's';
      mmp = ReadMMFileWithPath(upr, "res", "gMMRES.sum");
      if (!mmp)
      {
         sprintf(ln, "make res/%cgMMRES.sum > /dev/null 2>&1", upr);
         assert(system(ln) == 0);
         mmp = ReadMMFileWithPath(upr, "res", "gMMRES.sum");
         assert(mmp);
      }
      muB = mmp->mu;
      nuB = mmp->nu;
      nbB = nb;
      mfB = TryKUs(mmp, pre, verb, MACC, lat, 1, nb, muB, nuB, ku,
                   0, muB+nuB, 1, 0, 0);
      mmp->mflop[0] = mfB;
      printf("READ IN MU=%d, NU=%d FROM REAL, nb=%d, mf=%.2f\n", 
             muB, nuB, nb, mfB);
   }
/*
 * If we are allowed, try to tune NB
 */
   if (!FNB)
      mmp = FindBestNB(pre, verb, mmp, ku);
   else  /* still need to scope prefetch settings with required NB */
   {
      mmp->nbB = mmp->mbB = mmp->kbB = nb;
      mf = TryPFs(mmp, pre, verb, MACC, lat, 1, nb, muB, nuB, ku,
                  0, muB+nuB, 1, 0);
   }
/*
 * If we are allowed, tune ku
 */
   if (!ku)
      mmp = FindBestKU(pre, verb, mmp); /* tunes ku */
   mmp = FindBestRest(pre, verb, mmp);  /* tunes iftch, nftch, fftch, LDTOP */
   return(mmp);
}

int main(int nargs, char **args)
{
   char pre, *outfile;
   int verb, nregs, FNB, nb, ku, MACC, lat, mu, nu;
   ATL_mmnode_t *mmp, *mm;
   
   pre = GetFlags(nargs, args, &verb, &nregs, &nb, &ku, &MACC, &lat, &outfile);
   if (nregs == -1)  /* run # register probe only */
   {
      nb = GetBigNB(pre);
      nregs = FindNumRegs(pre, verb, nb, ku, &MACC, &lat);
      exit(0);
   }
/*
 * If nregs is positive, user has overridden probe, so just write it out
 */
   else if (nregs > 0)
   {
      char nam[10] = {'r', 'e', 's', '/', 'd', 'n', 'r', 'e', 'g', '\0'};
      FILE *fp;
      if (pre == 's' || pre == 'c')
         nam[4] = 's';
      fp = fopen(nam, "w");
      assert(fp);
      fprintf(fp, "%d\n", nregs);
      fclose(fp);
   }
   mmp = ReadMMFile(outfile);
   if (mmp)
   {
      if (mmp->mflop[0] <= 0)  /* need to retime */
      {
         for (mm=mmp; mm; mm = mm->next)
         {
            mm->mflop[0] = TimeGMMKernel(verb, 0, pre, mm->muladd, mm->lat,
                                         1, mm->nbB, mm->mu, mm->nu, mm->ku,
                                         mm->fftch, mm->iftch, mm->nftch,
                                         FLAG_IS_SET(mm->flag, MMF_LDCTOP),
                                         mm->pref, -1, -1);
         }
         WriteMMFile(outfile, mmp);
      }
      printf("\nSEARCH OUTPUT READ IN AS:\n");
      PrintMMNodes(stdout, mmp);
      exit(0);
   }
   if (nb > 0)
      FNB = 1;
   else
   {
      nb = GetBigNB(pre);
      FNB = 0;
   }
   if (!nregs)
      nregs = FindNumRegs(pre, verb, nb, ku, &MACC, &lat);
   if (MACC < 0)
      ConfirmMACC(pre, verb, nregs, nb, ku, &MACC, &lat);
   mmp = FindBestGenGemm(pre, verb, nregs, MACC, lat, FNB, nb, ku);
   WriteMMFile(outfile, mmp);
   printf("\nSELECTED GENERATED KERNEL:\n");
   PrintMMNodes(stdout, mmp);
   KillMMNode(mmp);
   exit(0);
}
@ROUT mmsearchN
void DoAllSearches(int verb, char pre, int nregs, int MACC, int lat, int nb, 
                   int ku, char *outfile)
{
   char ln[256];
   ATL_mmnode_t *mmg, *mme, *mmp;
   double mf;

@beginskip
/*
 * If outfile already exists, may need to retime
 */
   mmp = ReadMMFile(outfile);
   if (mmp)
   {
      if (mmp->mflop[0] <= 0.0)
         TimeAllMMKernels(0, verb, 0, mmp->next, pre, mmp->kbB, mmp->kbB, 0, 1,
                          -1, -1);
      return;
   }
@endskip
/*
 * First, find best generated (emit_mm) kernel
 */
   printf("\nINVOKING GMMSEARCH.C, PRE='%c'\n", pre);
   sprintf(ln, "make RunGMMSearch pre=%c\n", pre);
   assert(!system(ln));
   mmg = ReadMMFileWithPath(pre, "res", "guMMRES.sum");
   if (mmg)
   {
      if (mmg->mflop[0] <= 0)  /* need to retime */
      {
         mmg->mflop[0] = TimeGMMKernel(verb, 0, pre, mmg->muladd, mmg->lat,
                                       1, mmg->nbB, mmg->mu, mmg->nu, mmg->ku,
                                       mmg->fftch, mmg->iftch, mmg->nftch,
                                       FLAG_IS_SET(mmg->flag, MMF_LDCTOP),
                                       mmg->pref, -1, -1);
      }
      WriteMMFileWithPath(pre, "res", "guMMRES.sum", mmg);
   }
   else
   {
      mmg = ReadMMFileWithPath(pre, "res", "gMMRES.sum");
      assert(mmg);
   }
   printf("\nDONE GMMSEARCH.C, PRE='%c'\n\n", pre);
/*
 * Get results of all external searches
 */
   printf("\nRUNNING EXTERNAL SEARCHES, PRE='%c', NB=%d:\n", pre, mmg->nbB);
   sprintf(ln, "make RunUMMSearch pre=%c nb=%d", pre, mmg->nbB);
   assert(!system(ln));
   mme = ReadMMFileWithPath(pre, "res", "eMMRES.sum");
   assert(mme);
/*
 * If user-written kernel is noticably better than generated, use it;
 * If it changes NB< we will need to retune the generateed case to match new NB!
 */
   if (mme->mflop[0] > 1.03*mmg->mflop[0])
   {
      if (mme->nbB != mmg->nbB)
      {
         printf("\nFORCING NB=%d GMMSEARCH.C, PRE='%c'\n", mme->nbB, pre);
         sprintf(ln, "rm res/%cguMMRES.sum", pre);
         system(ln);
         sprintf(ln, "make res/%cguMMRES.sum pre=%c, nb=%d\n", pre, pre, 
                 mme->nbB);
         assert(!system(ln));
         KillAllMMNodes(mmg);
         mmg = ReadMMFileWithPath(pre, "res", "guMMRES.sum");
         assert(mmg);
         assert(mmg->nbB == mme->nbB);
      }
      else
         WriteMMFileWithPath(pre, "res", "guMMRES.sum", mmg);
   }
   else  /* generated kernel is just as good */
   {
      WriteMMFileWithPath(pre, "res", "guMMRES.sum", mmg);
      KillAllMMNodes(mme);
      mme = NULL;
   }
   mmg->next = mme;
   WriteMMFileWithPath(pre, "res", "MMRES.sum", mmg);
/*
 * Find no-copy code
 */
   sprintf(ln, "./xmmcuncpsearch -p %c -R -6\n", pre);
   assert(!system(ln));
/*
 * Find cleanup code 
 */
   sprintf(ln, "./xmmcuncpsearch -p %c -R -3\n", pre);
   assert(!system(ln));
   if (!mmg->next)
   {
      printf("\n\nFor this run, the best parameters found were MACC=%d, lat=%d, NB=%d, MU=%d, NU=%d, KU=%d\n",
             mmg->muladd, mmg->lat, mmg->nbB, mmg->mu, mmg->nu, mmg->ku);
      mf = mmg->mflop[0];
   }
   else
   {
      mf = mmg->next->mflop[0];
       printf("\n\nFor this run, the best case found was NB=%d user case %d\n",
              mmg->next->nbB, mmg->next->ID);
       if (mmg->next->auth)
          printf("written by %s", mmg->next->auth);
       if (mmg->next->ID > 0 && mmg->next->rout)
          printf(", filename='%s'.\n", mmg->next->rout);
       else if (mmg->next->auth)
          printf("\n");
   }
   printf("This gave a performance = %f MFLOP.\n", mf);
   printf("The necessary files have been created.  If you are happy with\n");
   printf("the above mflops for your system, type 'make %cinstall'.\n\n", pre);
   KillAllMMNodes(mmg);
}

@beginskip
void RetimeMMFile(char pre, char *path, char *file)
{
   ATL_mmnode_t *mmp;
   if (path)
      mmp = ReadMMFileWithPath(pre, path, file);
   else
      mmp = ReadMMFile(file);
   if (mmp)
   {
      TimeAllMMKernels(0, verb, 0, mmp, pre, 0, 0, 0, 1, -1, -1);
      if (path)
         WriteMMFileWithPath(pre, path, file, mmp);
      else
         WriteMMFile(file, mmp);
      KillAllMMNodes(mmp);
   }
}

void RetimeAllMMFiles(char pre)
{
   RetimeMMFile(pre, "res", "gMMRES.sum");
   RetimeMMFile(pre, "res", "guMMRES.sum");
   RetimeMMFile(pre, "res", "eMMRES.sum");
   RetimeMMFile(pre, "res", "MMRES.sum");
}
@endskip

int main(int nargs, char **args)
{
   char *outfile;
   int verb, nregs, nb, ku, MACC, lat;
   char pre;

   pre = GetFlags(nargs, args, &verb, &nregs, &nb, &ku, &MACC, &lat, &outfile);
   DoAllSearches(verb, pre, nregs, MACC, lat, nb, ku, outfile);
   exit(0);
}
@ROUT mmflagsearch
#include "atlas_misc.h"
#include "atlas_mmtesttime.h"

enum SEARCH {Linear=0, GreedyLinear, GreedySquare};
typedef struct flAgnode ATL_flagnode_t;
struct flAgnode
{
   char *flags;
   ATL_flagnode_t *next;
};

ATL_flagnode_t *NewFlagNode(char *flags)
{
    ATL_flagnode_t *fp;
    int n, i;

    fp = malloc(sizeof(ATL_flagnode_t));
    assert(fp);
    if (flags)
    {
       n = strlen(flags)+1;
       fp->flags = malloc(n*sizeof(char));
       assert(fp->flags);
       for (i=0; i < n; i++)
          fp->flags[i] = flags[i];
    }
    else
       fp->flags = NULL;
    fp->next = NULL;
    return(fp);
}

ATL_flagnode_t *KillFlagNode(ATL_flagnode_t *die)
{
   ATL_flagnode_t *next=NULL;
   if (die)
   {
      next = die->next;
      if (die->flags)
         free(die->flags);
      free(die);
   }
   return(next);
}

void KillAllFlagNodes(ATL_flagnode_t *bp)
{
   while(bp)
      bp = KillFlagNode(bp);
}

int CountFlagNodes(ATL_flagnode_t *bp)
{
   int i;
   for (i=0; bp; bp = bp->next, i++);
   return(i);
}

ATL_flagnode_t *GetGccOptFlags(void)
{
   char *gccflags[] = 
{"REPLACE THIS LINE WT ARCH-DEP FLAGS ALWAYS USED (eg, -mfpmath=sse -msse3)",
 "4", "-O2", "-O1", "-O3", "-Os",
 "6",
 "-fschedule-insns", "-fno-schedule-insns",
 "-fschedule-insns2", "-fno-schedule-insns2",
 "-fexpensive-optimizations", "-fno-expensive-optimizations",
 "# Flags to probe once optimization level is selected",
 "-fno-cprop-registers", "-fcprop-registers",
 "-fcrossjumping", "-fno-crossjumping",
 "-fmodulo-sched -fmodulo-sched-allow-regmoves",
 "-fcse-follow-jumps",
 "-free",
 "-fira-algorithm=priority", "-fira-algorithm=CB",
 "-fira-region=all", "-fira-region=mixed", "-fira-region=one",
 "-fira-hoist-pressure", "-fira-loop-pressure",
 "-fselective-scheduling", "-fselective-scheduling2",
 "-fselective-scheduling -fsel-sched-pipelining",
 "-fselective-scheduling2 -fsel-sched-pipelining",
 "-fstrict-overflow",
 "-fmodulo-sched", "-fno-branch-count-reg", "-fno-move-loop-invariants",
 "-fdelayed-branch",
 "-fno-peephole -fno-peephole2", "-fno-peephole", "-fno-peephole2",
 "-faggressive-loop-optimizations", "-funsafe-loop-optimizations", 
 "-fomit-frame-pointer", 
 "-foptimize-register-move", "-fno-optimize-register-move",
 "-fprefetch-loop-arrays", "-fno-prefetch-loop-arrays",
 "-frename-registers", "-fno-rename-registers", 
 "-fno-reorder-blocks", "-fno-sched-interblock", "-fno-sched-spec",
 "-fsched-spec-load", "-fsched2-use-superblocks", "-fsched2-use-traces",
 "-fselective-scheduling -fsel-sched-pipelining", 
 "-fselective-scheduling -fsel-sched-pipelining -fsel-sched-pipelining-outer-loops", 
 "-fsel-sched-pipelining-outer-loops",
 "-fsee", "-freschedule-modulo-scheduled-loops", "-fsingle-precision-constant",
 "-fstrict-aliasing", "-funroll-all-loops", "-funroll-loops",
 "-fno-split-ivs-in-unroller", 
 "-fvariable-expansion-in-unroller", "-fno-variable-expansion-in-unroller",
 "-fno-tree-pre", "-fno-tree-fre", "-fno-tree-loop-optimize",
 "-fno-tree-loop-linear", "-fno-tree-loop-im",
 "-ftree-loop-ivcanon", "-fno-tree-loop-ivcanon", "-fivopts", "-fno-ivopts",
 "-fno-tree-dominator-opts", "-ftree-dse", "-fno-tree-dse",
 "-fno-tree-copyrename", "-fno-tree-sink", "-fno-tree-ch", "-fno-tree-ter",
 "-fno-tree-lrs", "-ftree-vectorize -fno-tree-vect-loop-version", 
 "-ftree-vectorize -ftree-vect-loop-version", "-fno-tree-salias",
 "-fweb", "-fno-web", "-fno-rerun-loop-opt", "-frerun-loop-opt",
 "-falign-functions=64",
 "-falign-loops=4", "-falign-loops=8", "-falign-loops=16", "-falign-loops=32",
 "-falign-jumps=4", "-falign-jumps=8", "-falign-jumps=16",
 NULL
};
   int i;
   ATL_flagnode_t *bp, *pf;

   pf = bp = NewFlagNode(gccflags[0]);
   for (i=1; gccflags[i]; i++)
   {
      pf->next = NewFlagNode(gccflags[i]);
      pf = pf->next;
   }
   return(bp);
}

char *ReadFlagLine0(FILE *fpin)
{
   static char *ln=NULL;
   static int L=0;
   int j, n;

   if (fpin)
   {
      if (!L)
      {
         L = 1024;
         ln = malloc(L*sizeof(char));
         assert(ln);
      }
      if (!fgets(ln, L, fpin))
         return(NULL);
      n = strlen(ln);
/*
 *    If line in file longer than L, reallocate L and read in missing portion
 */
      while (n == L-1 && ln[n-1] != '\n')
      {
         ln = realloc(ln, (L+L)*sizeof(char));
         assert(ln);
         if (fgets(ln+n, L, fpin) == NULL)
            ln[n] = '\0';
         else
            n += strlen(ln+n);
         L += L;
      }
/*
 *    Strip trailing whitespace 
 */
      for (j=n-1; j >= 0 && isspace(ln[j]); j--)
         ln[j] = '\0';     /* strip trailing whitespace */
      if (ln[0] == '\0')   /* treat empty string as comment */
      {
         ln[0] = '#';
         ln[1] = '\n';
      }
   }
   else if (L)
   {
      free(ln);
      L = 0;
      ln = NULL;
   }
   return(ln);
}

char *ReadFlagLine(FILE *fpin)
{
   char *ln;
   ln = ReadFlagLine0(fpin);
   while (ln && (ln[0] == '#' || ln[0] == '\0'))
      ln = ReadFlagLine0(fpin);
   return(ln);
}

char *ReadFlags
(
   FILE *fpin,                /* file pointer to read */
   ATL_flagnode_t **optlvls,  /* -O1, -O2, etc */
   ATL_flagnode_t **optflags, /* flags to try before select optlevel */
   ATL_flagnode_t **flags     /* flags to try after optlvls & optflags set */
)
/*
 * RETURNS: base string to use.
 *
 * Format of file:
 * - Lines beginning with '#' are ignored
 * - 1st line is base flags that all others are added to
 * - 2nd line is an integer, giving the number of optimization flags to
 *   try, with the first such opt flag used as the starting tuning
 * - Next $n$ lines ($n$ given in line above) are the optimization levels
 * - Next line is an integer, giving the number of flag lines to try
 *   *before* trying the variant optimiziation levels
 * - Next $n$ lines give these flags lines
 * - All remaining lines are flaglines to be tuned after selecting opt level
 */
{
   int i, j, n, L=1024;
   char *ln, *baseflags;
   ATL_flagnode_t *lvls, *oflags, *nflags, *bp, *np;
/*
 * Read in base flags
 */
   baseflags = DupString(ReadFlagLine(fpin));
   assert(baseflags);
/*
 * Read in optimization levels
 */
   ln = ReadFlagLine(fpin);
   n = strtol(ln, NULL, 0);
   if (!n)
      lvls = NULL;
   else
   {
      ln = ReadFlagLine(fpin);
      assert(ln);
      lvls = np = NewFlagNode(ln);
      for (i=1; i < n; i++)
      {
         ln = ReadFlagLine(fpin);
         assert(ln);
         np->next = NewFlagNode(ln);
         np = np->next;
      }
   }
/* 
 * Read in flag lines to try before trying all optimization levels
 */
   ln = ReadFlagLine(fpin);
   n = strtol(ln, NULL, 0);
   if (!n || !lvls)
      optflags = NULL;
   else
   {
      ln = ReadFlagLine(fpin);
      assert(ln);
      oflags = np = NewFlagNode(ln);
      for (i=1; i < n; i++)
      {
         ln = ReadFlagLine(fpin);
         assert(ln);
         np->next = NewFlagNode(ln);
         np = np->next;
      }
   }
/*
 * Read in remaining post-lvl flags
 */
   ln = ReadFlagLine(fpin);
   if (ln)
   {
      nflags = np = NewFlagNode(ln);
      while (ln = ReadFlagLine(fpin))
      {
         np->next = NewFlagNode(ln);
         np = np->next;
      }
   }
   else
      nflags = NULL;

   *optlvls = lvls;
   *optflags = oflags;
   *flags = nflags;
   return(baseflags);
}
@beginskip
ATL_flagnode_t *ReadFlags(FILE *fpin)
{
   int j, n;
   char ln[1024];
   ATL_flagnode_t *bf=NULL, *pf;  /* base and pointer to flags */

   while (fgets(ln, 1024, fpin))
   {
      n = strlen(ln);
      for (j=n-1; j >= 0 && isspace(ln[j]); j--)
         ln[j] = '\0';  /* strip trailing whitespace */
//      fprintf(stderr, "line = '%s'\n", ln);
      if (bf)
      {
         pf->next = NewFlagNode(ln);
         pf = pf->next;
      }
      else
         pf = bf = NewFlagNode(ln);
   }
   if (fpin != stderr && fpin != stdin)
      fclose(fpin);
   return(bf);
}
@endskip

char *JoinStrings(char *str0, char *str1)
/*
 * Returns join of two strings (sep by space) in a new string
 */
{
   char *jstr;
   int n, n1, n2, j;

/*
 * Handle degenerate cases
 */
   if (!str0 && !str1)
      return(NULL);
   else if (!str0 || !str1)
   {
      jstr = DupString(str0 ? str0 : str1);
      n = strlen(jstr);
      for (j=n-1; j >= 0 && isspace(jstr[j]); j--)
         jstr[j] = '\0';  /* strip trailing whitespace */
   }
/*
 * Both strings exist, so join them
 */
   else
   {
      n1 = strlen(str0);
      n2 = strlen(str1);
      jstr = malloc(sizeof(char)*(n1+n2+2));
      assert(jstr);

      strcpy(jstr, str0);
      for (j=n1-1; j >= 0 && isspace(jstr[j]); j--)
         jstr[j] = '\0';  /* strip trailing whitespace */
      if (j > 0)
      {
         jstr[j+1] = ' ';
         n1 = j+2;
      }
      else
      {
         n1 = 0;
      }
      strcpy(jstr+n1, str1);
      for (j=n1+n2-1; j >= 0 && isspace(jstr[j]); j--)
         jstr[j] = '\0';  /* strip trailing whitespace */
   }
   return(jstr);
}

void PrintUsage(char *name, int ierr, char *flag)
{
   if (ierr > 0)
      fprintf(stderr, "Bad argument #%d: '%s'\n",
              ierr, flag ? flag : "Not enough arguments");
   else if (ierr < 0)
      fprintf(stderr, "ERROR: %s\n", flag);
   fprintf(stderr, "USAGE: %s [flags]:\n", name);
   fprintf(stderr, "   -p [s,d,c,z]: set precision prefix \n");
   fprintf(stderr, "   -v # : higher numbers print out more\n");
   fprintf(stderr, "   -f <file> : get flags from file (default stdin)\n");
   fprintf(stderr, "      if <file> is gcc, create gccflags.txt, which\n");
   fprintf(stderr, "      contains most machine independent gcc flags\n");
   fprintf(stderr, "      using baseflags as given in next mandatory arg\n");
   fprintf(stderr, 
      "   -m <file> : get mmcase from file (default res/<pre>gMMRES.sum\n");
//   fprintf(stderr, 
//   "   -S [g/G/l] : do O(N) or O(N^2) Gready or O(N) linear search\n");
   exit(-1);
}

char GetFlags(int nargs, char **args, int *verb,
              enum SEARCH *srch, FILE **FPFLAG, char **MMNAME)
{
   FILE *fpflag=stdin;
   char *mmname = NULL;
   char pre = 'd';
   int i;

   *srch = GreedyLinear;
   *verb = 1;
   for (i=1; i < nargs; i++)
   {
      if (args[i][0] != '-')
         PrintUsage(args[0], i, args[i]);
      switch(args[i][1])
      {
      case 'v':  /* verbosity */
         if (++i >= nargs)
            PrintUsage(args[0], i, NULL);
         *verb = atoi(args[i]);
         break;
      case 'p':  /* precision */
         if (++i >= nargs)
            PrintUsage(args[0], i, NULL);
         pre = tolower(args[i][0]);
         assert(pre == 's' || pre == 'd' || pre == 'c' || pre == 'z');
         break;
      case 'f':  /* flag file */
         if (++i >= nargs)
            PrintUsage(args[0], i, NULL);
         if (!strcmp(args[i], "gcc"))
         {
            FILE *fpout;
            ATL_flagnode_t *bp, *fp;
            fpout = fopen("gccflags.txt", "w");
            assert(fpout);
            bp = GetGccOptFlags();
            for (fp=bp; fp; fp = fp->next)
               fprintf(fpout, "%s\n", fp->flags);
            fclose(fpout);
            KillAllFlagNodes(bp);
            exit(0);
         }
         else
         {
            fpflag = fopen(args[i], "r");
            assert(fpflag);
         }
         break;
      case 'S':  /* search algorithm to employ */
         if (++i >= nargs)
            PrintUsage(args[0], i, NULL);
         if (args[i][0] == 'G')
            *srch = GreedySquare;
         else if (args[i][0] == 'g')
            *srch = GreedyLinear;
         else if (args[i][0] == 'l')
            *srch = Linear;
         break;
      case 'm':  /* matmul kernel descriptor file */
         if (++i >= nargs)
            PrintUsage(args[0], i, NULL);
         mmname = DupString(args[i]);
         break;
      default:
         PrintUsage(args[0], i, args[i]);
      }
   }

   if (!mmname)
   {
      mmname = malloc(sizeof(char)*16);
      assert(mmname);
      sprintf(mmname, "res/%cgMMRES.sum", pre);
   }

   *MMNAME = mmname;
   *FPFLAG = fpflag;
   return(pre);
}

ATL_flagnode_t *LinearFlagSearch
(
   char pre,                    /* type/precision prefix */
   int verb,                    /* verbosity */
   char *spc,                   /* indent spaces to print */
   double mulB,                 /* muliplier put on base case */
   ATL_mmnode_t *mmp,           /* gemm kernel to time */
   ATL_flagnode_t *baseflags,   /* NULL, or flags to add to all runs */
   ATL_flagnode_t *bp           /* flags to search */
)
/* 
 * Tries all candidate flags in bp, and prints the best found.  If mulB != 1,
 * then the present case is advantaged (>1) to avoid adding flags that
 * really don't help performance.
 * RETURNS: pointer to flag that produce the best performance
 */
{
   double mfB=0.0, mf;
   ATL_flagnode_t *fp, *fpB;
   char *jstr = (baseflags) ? baseflags->flags : NULL;
   char *flags, *flagsB=NULL;
   int i;

   if (!spc)
      spc = "";
   printf("%sFINDING BEST FLAG SETTINGS FOR THIS MATMUL KERNEL:\n", spc);
   if (jstr)
   {
      printf("%s   All cases using flags: '%s'\n", spc, jstr);
      fp = NewFlagNode(jstr);  /* always test base flags alone! */
      fp->next = bp;           /* so we're sure new flags are an improvement */
      bp = fp;
   }
   for (i=0,fp=bp; fp; i++,fp = fp->next)
   {
      flags = JoinStrings(jstr, fp->flags);
      if (mmp->cflags)
         free(mmp->cflags);
      mmp->cflags = DupString(flags);
      mf = TimeMMKernel(verb, 1, mmp, pre, mmp->mbB, mmp->nbB, mmp->kbB,
                        1, -1, -1);
      if (verb > 0)
         printf("%s%4d. mf=%.2f, newflags='%s'\n", spc, i, mf, fp->flags);
      if (mf > mfB*mulB)
      {
         mfB = mf;
         fpB = fp;
      }
      free(flags);
   }
   mmp->cflags = NULL;
   printf("%sBEST FLAGS (%.2f) ARE:\n", spc, mfB);
   printf("%s   '%s'\n\n", spc, fpB->flags);
   KillFlagNode(bp);
   return((bp == fpB) ? NULL : fpB);
}

char *GreedyLinearFlagSearch
(
   char pre,                    /* type/precision prefix */
   int verb,                    /* verbosity */
   char *spc,                   /* indent spaces to print */
   double mulB,                 /* muliplier put on base case */
   ATL_mmnode_t *mmp,           /* gemm kernel to time */
   char *baseflags,             /* NULL, or flags to add to all runs */
   ATL_flagnode_t *optlvls,     /* optimization levels to try */
   ATL_flagnode_t *lvlflags,    /* flags to try before choosing optlvl */
   ATL_flagnode_t *bp           /* flags to search after choosing optlvl */
)
/* 
 * Tries all the candidate flags in bp, and if anyone of them improves
 * performance, it is added to the default case.
 * RETURNS: string of new base case
 */
{
   double mfB=0.0, mf, mf0=0.0;
   ATL_flagnode_t *fp, *fpB;
   char *jstr = NULL;
   char *flags, *flagsB=NULL, *sp, *lvlB;
   int i=0;

   if (!spc)
      spc = "";
   printf("%sFINDING BEST FLAG SETTINGS FOR THIS MATMUL KERNEL:\n", spc);
/*
 * Scope all optimization levels
 */
   if (optlvls)
   {
      printf("%s...Trying optlvls using base flags: '%s'\n", spc, baseflags);
      for (fp=optlvls; fp; fp = fp->next)
      {
         ATL_flagnode_t *fm;
/*
 *       Try level flags w/o any modifiers
 */
         i++;
         flags = JoinStrings(fp->flags, baseflags);
         if (mmp->cflags)
            free(mmp->cflags);
         mmp->cflags = flags;
         mf = TimeMMKernel(verb, 1, mmp, pre, mmp->mbB, mmp->nbB, mmp->kbB,
                           1, -1, -1);
         if (mf0 == 0.0)
            mf0 = mf;
         if (verb > 0)
            printf("%s%4d. mf=%.2f, flags='%s'\n", spc, i, mf, fp->flags);
         if (mf > mfB*mulB)
         {
            if (verb > 0)
                printf("%s    ---> Opt level '%s' is better!\n", spc, 
                       fp->flags);
            lvlB = fp->flags;
            flagsB = NULL;
            mfB = mf;
         }
/*
 *       Try all level modifier flags, and choose best combination
 */
         jstr = JoinStrings(fp->flags, baseflags);
         for (fm=lvlflags; fm; fm = fm->next)
         {
            i++;
            sp = JoinStrings(jstr, flagsB);
            flags = JoinStrings(sp, fm->flags);
            free(sp);
            if (mmp->cflags)
               free(mmp->cflags);
            mmp->cflags = flags;
            mf = TimeMMKernel(verb, 1, mmp, pre, mmp->mbB, mmp->nbB, mmp->kbB,
                              1, -1, -1);
            if (verb > 0)
            {
               printf("%s%4d. mf=%.2f, flags='%s", spc, i, mf, fp->flags);
               if (flagsB)
                  printf(" %s", flagsB);
               printf(" %s'\n", fm->flags);
            }
            if (mf > mfB*mulB)
            {
               flagsB = JoinStrings(flagsB, fm->flags);
               lvlB = fp->flags;
               if (verb > 0)
                   printf("%s    ---> Opt combo '%s %s' is better!\n", spc, 
                          lvlB, flagsB);
               mfB = mf;
            }
         }
      }
   }
@beginskip
/*
 * Try all lvlflags with first optimization level
 */
   mfB = 0.0;
   if (lvlflags)
   {
      jstr = JoinStrings(optlvls->flags, baseflags);
      printf("%s...Trying lvlflags using base flags: '%s'\n", spc, jstr);
      for (fp=lvlflags; fp; fp = fp->next)
      {
         i++;
         flags = JoinStrings(jstr, fp->flags);
         if (mmp->cflags)
            free(mmp->cflags);
         mmp->cflags = DupString(flags);
         mf = TimeMMKernel(verb, 1, mmp, pre, mmp->mbB, mmp->nbB, mmp->kbB,
                           1, -1, -1);
         if (mf0 == 0.0)
            mf0 = mf;
         if (verb > 0)
            printf("%s%4d. mf=%.2f, flags='%s'\n", spc, i, mf, fp->flags);
         if (mf > mfB*mulB)
         {
            if (verb > 0)
                printf("%s    ---> Adding flag '%s'!\n", spc, fp->flags);
            mfB = mf;
            sp = JoinStrings(flagsB, fp->flags);
            if (flagsB)
               free(flagsB);
            flagsB = sp;
            sp = JoinStrings(jstr, fp->flags);
            if (jstr)
               free(jstr);
            jstr = sp;
         }
         else
            free(flags);
      }
   }
   if (jstr)
      free(jstr);
/*
 * Try all optimization levels with the indicated lvlflags, which are in flagsB
 */
   if (optlvls)
   {
      printf("\n%s...Trying optimization levels wt flags: '%s %s'\n",
             spc, baseflags?baseflags:"", flagsB?flagsB:"");
      lvlB = optlvls->flags;
      for (fp=optlvls->next; fp; fp = fp->next)
      {
         i++;
         sp = JoinStrings(fp->flags, baseflags);
         flags = JoinStrings(sp, flagsB);
         free(sp);
         if (mmp->cflags)
            free(mmp->cflags);
         mmp->cflags = DupString(flags);
         mf = TimeMMKernel(verb, 1, mmp, pre, mmp->mbB, mmp->nbB, mmp->kbB,
                           1, -1, -1);
         if (mf0 == 0.0)
            mf0 = mf;
         if (verb > 0)
            printf("%s%4d. mf=%.2f, flags='%s'\n", spc, i, mf, fp->flags);
         if (mf > mfB*mulB)
         {
            if (verb > 0)
                printf("%s    ---> Opt level '%s' is better!\n", spc, 
                       fp->flags);
            lvlB = fp->flags;
            mfB = mf;
         }
      }
   }
/*
 * From now on, baseflags are <lvlB> <old baseflags> <lvlflags>
 */
   sp = JoinStrings(lvlB, baseflags);
   baseflags = JoinStrings(sp, flagsB);
   if (sp)
      free(sp);
   if (flagsB)
      free(flagsB);
@endskip
   if (lvlB && flagsB)
   {
      char *stmp;
      stmp = JoinStrings(lvlB, baseflags);
      sp = JoinStrings(stmp, flagsB);
      free(stmp);
   }
   else if (lvlB)
      sp = JoinStrings(lvlB, baseflags);
   else if (flagsB)
      sp = JoinStrings(baseflags, flagsB);
   else
      sp = JoinStrings(baseflags, NULL);
   free(baseflags);
   free(flagsB);
   flagsB = NULL;
   baseflags = sp;
   printf("%s...All cases using flags: '%s'\n", spc, baseflags?baseflags:"");
   for (fp=bp; fp; fp = fp->next)
   {
      i++;
      flags = JoinStrings(baseflags, fp->flags);
      if (mmp->cflags)
         free(mmp->cflags);
      mmp->cflags = DupString(flags);
      mf = TimeMMKernel(verb, 1, mmp, pre, mmp->mbB, mmp->nbB, mmp->kbB,
                        1, -1, -1);
      if (mf0 == 0.0)
         mf0 = mf;
      if (verb > 0)
         printf("%s%4d. mf=%.2f, flags='%s'\n", spc, i, mf, fp->flags);
      if (mf > mfB*mulB)
      {
         if (verb > 0)
             printf("%s    ---> Adding flag '%s'!\n", spc, fp->flags);
         mfB = mf;
         if (baseflags)
            free(baseflags);
         baseflags = flags;
      }
      else
         free(flags);
   }
   mmp->cflags = NULL;
   printf(
      "%sBEST FLAGS GIVE MFLOP=%.2f (%.2f%% improvement over first case):\n",
          spc, mfB, 100.0*((mfB/mf0)-1.0));
   printf("%s   '%s'\n\n", spc, baseflags);
   return(baseflags);
}

void GreedyFlagSearch
(
   char pre,                    /* type/precision prefix */
   int verb,                    /* verbosity */
   ATL_mmnode_t *mmp,           /* gemm kernel to time */
   ATL_flagnode_t *baseflags,   /* NULL, or flags to add to all runs */
   ATL_flagnode_t *bp           /* flags to search */
)
/*
 * For each flag in bp, see if it improves performance over present
 * baseline; if so, add to baseline, else reject.  This algorithm is
 * O(N^2), and will not catch two flags that only help when thrown
 * together unless they are given together in bp!
 */
{
   ATL_flagnode_t *fp, *fpp, *fpB;
   char *sp;
   int N, i;

   N = CountFlagNodes(bp);
   if (verb > 0)
      printf("DOING GREEDY SEARCH USING %d COMBINATIONS\n", N);
   i = 0;
   while (fpB = LinearFlagSearch(pre, verb, "      ", 1.02, mmp, baseflags, bp))
   {
      if (verb > 0)
         printf("   Adding '%s' to list of flags!\n", fpB->flags);
/* 
 *    Add new flags to baseflags
 */
      if (!baseflags)
         baseflags = NewFlagNode(fpB->flags);
      else
      {
         sp = JoinStrings(baseflags->flags, fpB->flags);
         free(baseflags->flags);
         baseflags->flags = sp;
      }
/*
 *    Remove selected flags from queue of searched flags
 */
      fpp = NULL;
      for (fp=bp; fp != fpB; fp = fp->next)
         fpp = fp;
      if (fpp)
      {
         fpp->next = KillFlagNode(fpp->next);
      }
      else
         bp = KillFlagNode(bp);
      i++;
      if (verb > 0)
         printf("   GREEDY PASS %d of %d\n", i, N);
   }
}

int main(int nargs, char **args)
{
   ATL_mmnode_t *mmp;
   ATL_flagnode_t *optlvls, *lvlflags, *flags;
   FILE *fpflag;
   char *mmfile, *baseflags;
   enum SEARCH srch;
   int verb;
   char pre;

   pre = GetFlags(nargs, args, &verb, &srch, &fpflag, &mmfile);
   mmp = ReadMMFile(mmfile);
   if (!mmp)
   {
      fprintf(stderr, "CANNOT READ FILE '%s'!\n", mmfile);
      exit(-1);
   }
   MMFillInGenStrings(pre, mmp);
   if (verb > 0)
   {
      printf("\nFINDING BEST FLAGS USING MATMUL KERNEL:\n");
      PrintMMLine(stdout, mmp);
   }
   baseflags = ReadFlags(fpflag, &optlvls, &lvlflags, &flags);
   GreedyLinearFlagSearch(pre, verb, NULL, 1.01, mmp, baseflags, optlvls, 
                          lvlflags, flags);
   KillAllFlagNodes(lvlflags);
   KillAllFlagNodes(optlvls);
   KillAllFlagNodes(flags);
   free(baseflags);
   exit(0);
@beginskip
   bp = ReadFlags(fpflag);
   if (srch == Linear)
      LinearFlagSearch(pre, verb, NULL, 1.0, mmp, jp, bp);
   else if (srch == GreedyLinear)
   {
      GreedyLinearFlagSearch(pre, verb, NULL, 1.01, mmp, jp, bp);
      KillAllFlagNodes(jp);
      exit(0);
   }
   else
      GreedyFlagSearch(pre, verb, mmp, jp, bp);
   KillAllFlagNodes(jp);
   KillAllFlagNodes(bp);
   return(0);
@endskip
}
@ROUT cacheSweep
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#if defined(CPUTIME)
   #define time00 ATL_cputime
#else
   #define time00 ATL_walltime
#endif
double time00(void);

void InitSpace(size_t N, double *dp)
{
   size_t i;
   for (i=0; i < N; i++)
      dp[i] = 0.0;
}

double ReadSpace(size_t N, double *dp)
{
   size_t i, N16 = (N>>4)<<4;
   double d=0.0, d1=0.0, d2=0.0, d3=0.0, d4=0.0, d5=0.0, d6=0.0, d7=0.0;
   for (i=0; i < N16; i += 16)
   {
      d += dp[i];
      d1 += dp[i+2];
      d2 += dp[i+4];
      d3 += dp[i+6];
      d4 += dp[i+8];
      d5 += dp[i+10];
      d6 += dp[i+12];
      d7 += dp[i+14];
   }
   return(d+d1+d2+d3);
}

double *DoCacheSearch(int fixreps, int timreps, size_t minsz, size_t maxsz, 
                      int *N, size_t **SZS)
{
   size_t i, n=0, nrep, K;
   void *vp;
   double *dp, sum, *times, t0, t1;
   size_t *szs;
   printf("SIZE (KB)            TIME     BW (MB/s)\n");
   printf("=========  ==============  ============\n");
/*
 * Get space big enough to hold largest size
 */
   vp = malloc(maxsz + 512);
   assert(vp);
/*
 * Figure out how many timings we are going to do, and allocate time and
 * dimension arrays
 */
   for (i=maxsz; i >= minsz; i >>= 1)
      n++;
   *N = n;
   *SZS = szs = malloc(sizeof(size_t)*n);
   times = malloc(sizeof(double)*n);
   assert(szs && times);

   dp = (double*)((((size_t)vp)>>9)<<9);
   K = maxsz / sizeof(double);
   nrep = timreps;
   InitSpace(K, dp);

   for (n=0,i=maxsz; i >= minsz; i >>= 1, n++, nrep <<= 1)
   {
      int j;
      szs[n] = i;
      K = i / sizeof(double);
/*
 *    Get memory area allocated to the cache as much as probability allows
 *    by repeatedly sweeping it
 */
      sum = 0.0;
      for (j=0; j < fixreps; j++)
         sum += ReadSpace(K, dp);
      assert(sum == 0.0);   /* keeps compiler from eliminating sweeps */
      t0 = time00();
      for (j=0; j < nrep; j++)
         sum += ReadSpace(K, dp);
      times[n] = time00() - t0;
      assert(sum == 0.0);   /* keeps compiler from eliminating sweeps */
      t0 = ((i/1024)/1024.0)*nrep / times[n];
      printf("%9d  %14e  %12.0f\n", (int)(i / 1024), times[n], t0);
   }

   return(times);
}

void PrintUsage(char *name, int ierr, char *flag)
{
   if (ierr > 0)
      fprintf(stderr, "Bad argument #%d: '%s'\n", ierr,
              flag?flag:"OUT-OF_ARGUMENTS");
   else if (ierr < 0)
      fprintf(stderr, "ERROR: %s\n", flag);
   fprintf(stderr, "USAGE: %s [flags:\n", name);
   fprintf(stderr, "   -r <#> : # of reads of max size to perform\n");
   fprintf(stderr, "   -f <#> : set trip count to fix mem to cache\n");
   fprintf(stderr, "   -M <#> : max size to time (KB) \n");
   fprintf(stderr, "   -m <#> : min size to time (KB) \n");
   exit(ierr ? ierr : -1);
}

int GetFlags(int nargs, char **args, size_t *MINSZ, size_t *MAXSZ, int *FREP)
{
   int timrep=512, i;
   *MINSZ = 4;
   *MAXSZ = 8*1024;
   *FREP = 16;
   for (i=1; i < nargs; i++)
   {
      if (args[i][0] != '-')
         PrintUsage(args[0], i, args[i]);

      switch(args[i][1])
      {
      case 'M':
        if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
         *MAXSZ = atol(args[i]);
         break;
      case 'm':
        if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
         *MINSZ = atol(args[i]);
         break;
      case 'f':
        if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
         *FREP = atoi(args[i]);
         break;
      case 'r':
        if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
         timrep = atoi(args[i]);
         break;
      default:
         PrintUsage(args[0], i, args[i]);
      }
   }
   return(timrep);
}
int main(int nargs, char **args)
{
   int fixrep, timrep, N;
   size_t minsz, maxsz, *szs;
   double *times;
   timrep = GetFlags(nargs, args, &minsz, &maxsz, &fixrep);
   minsz *= 1024;
   maxsz *= 1024;
   printf("MAXSZ=%lu, MINSZ=%lu, fixrep=%d, timrep=%d\n\n", 
          (unsigned long)maxsz, (unsigned long)minsz, fixrep, timrep);
   times = DoCacheSearch(fixrep, timrep, minsz, maxsz, &N, &szs);
   free(times);
   free(szs);
   return(0);
}
@ROUT lcm
#include <stdio.h>
#include <stdlib.h>
@extract -b @(basd)/atlas.base rout=Mylcm
int main(int nargs, char **args)
{
   int i, lcm=1;
   printf("LCM(");
   for (i=1; i < nargs; i++)
   {
      int k;
      k = atoi(args[i]);
      if (i != nargs-1)
         printf("%d,", k);
      else
         printf("%d)", k);
      lcm = Mylcm(lcm, k);
   }
   printf(" = %d\n", lcm);
   return(0);
}
@ROUT !
