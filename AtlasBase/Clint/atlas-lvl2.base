@ifdef ! incd
   @define incd @/home/rwhaley/Base/ATLAS@
@endifdef
@extract -b @(topd)/gen.inc what=crsetup
@ROUT mvtktest mvnktest mvttest mvntest ATL_ger ATL_ger2
@extract -b @(topd)/cw.inc lang=c -define cwdate 2010
@ROUT r1ktest
@extract -b @(topd)/gen.inc what=cw @(cw09)
@ROUT r1test mvtest
@extract -b @(topd)/gen.inc what=cw @(cw00)
@ROUT ATL_symv_old atlas_r1.h ATL_gemv_old @\
      ATL_cgemvN_4x2_1 ATL_cgemvN_2x2_0 ATL_cgemvN_mm @\
      ATL_cgemvN_1x1_1 ATL_cgemvN_1x1_1a ATL_gemvN_4x4_1 ATL_gemvN_4x2_0 @\
      ATL_gemvN_mm ATL_gemvN_8x32_2 ATL_gemvN_8x4_1 ATL_gemvN_16x2_1 @\
      ATL_gemvN_16x4_1 ATL_gemvN_32x4_1 ATL_gemvN_1x1_1 ATL_gemvN_1x1_1a @\
      ATL_gpmvN_32x4_1 ATL_gpmvN_1x1_1a ATL_cgemvT_2x4_1 ATL_cgemvT_2x2_0 @\
      ATL_cgemvT_mm ATL_cgemvT_1x1_1 ATL_gemvT_4x8_1 ATL_gemvT_2x8_0 @\
      ATL_gemvT_mm ATL_gemvT_4x16_1 TL_gemvT_2x16_1 ATL_gemvT_1x1_1 @\
      ATL_trmvUT ATL_trmvUN ATL_trmvLN ATL_trmvLT ATL_trmv_old symv l2blastst @\
      atlas_lvl2.h atlas_level2.h ATL_gemvT_2x16_1 
@extract -b @(topd)/gen.inc what=cw @(cw99)

@rout r1test r1ktest r2ktest mvnktest mvtktest mvntest mvttest
#include "atlas_misc.h"
#include "atlas_tst.h"
#include "atlas_lvl2.h"
#include "atlas_level1.h"
#include <ctype.h>
int FAx=0, MAx=0, FAy=0, MAy=0, FAa=0, MAa=0;
@extract -b @(topd)/FAmalloc.inc

@rout r1test r1ktest r2ktest
static void dumb_ger(int Conj, int M, int N, SCALAR alpha, TYPE *X, int incX, 
                     TYPE *Y, int incY, TYPE *A, int lda)
{
   #ifdef TCPLX
      TYPE tmp[2];
   #endif
   int j;
   ATL_assert(incX == 1);
   ATL_assert( SCALAR_IS_ONE(alpha) );
   for (j=0; j < N; j++)
   {
   #ifdef TREAL
      Mjoin(PATL,axpy)(M, Y[j*incY], X, 1, A+((size_t)lda)*j, 1);
   #else
      tmp[0] = Y[2*j*incY];
      tmp[1] = Y[2*j*incY+1];
      if (Conj) tmp[1] = -tmp[1];
      Mjoin(PATL,axpy)(M, tmp, X, 1, A+2*((size_t)lda)*j, 1);
   #endif
   }
}
@rout mvtktest mvnktest mvttest mvntest
static void dumb_gemv
   (int Conj, ATL_CINT M, ATL_CINT N, const SCALAR alpha, 
    const TYPE *A, ATL_CINT lda, const TYPE *X, ATL_CINT incX,
    const SCALAR beta, TYPE *Y, ATL_CINT incY)
@rout mvnktest mvntest
/*
 * If (conj) y = alpha*conj(A^T)*x + beta*y
 * else  y = alpha*(A^T)*x + beta*y
 * Since this is no-transpose, and A always MxN:
 *   Y is of length M
 *   X is of length N
 */
{
   ATL_INT j;
   #ifdef TCPLX
      const TYPE ra=(*alpha), ia=alpha[1];
      TYPE rx, ix, xa[2];
      const int lda2 = lda+lda, incX2 = incX+incX;
   #else
      TYPE xa;
      const int lda2 = lda, incX2 = incX;
   #endif
/*
 * Apply beta to Y
 */
   if (!SCALAR_IS_ONE(beta))
   {
      if (SCALAR_IS_ZERO(beta))
         Mjoin(PATL,zero)(M, Y, incY);
      else 
         Mjoin(PATL,scal)(M, beta, Y, incY);
   }
   if (SCALAR_IS_ZERO(alpha) || N < 1)
      return;
   for (j=0; j < N; j++, A += lda2, X += incX2)
   {
      #ifdef TCPLX
         rx = *X;
         ix = X[1];
         xa[0] = rx*ra - ix*ia;
         xa[1] = rx*ia + ix*ra;
      #else
        xa = alpha * *X;
      #endif
      Mjoin(PATL,axpy)(M, xa, A, 1, Y, incY);
   }
}
@rout mvtktest mvttest
/*
 * If (conj) y = alpha*conj(A^T)*x + beta*y
 * else  y = alpha*(A^T)*x + beta*y
 * Since this is transpose, and A always MxN:
 *   Y is of length N
 *   X is of length M
 */
{
#ifdef TREAL
   ATL_INT i, j;
   TYPE y0;

   for (j=0; j < N; j++, A += lda)
   {
      y0 = Mjoin(PATL,dot)(M, X, incX, A, 1);
      y0 *= alpha;
      if (beta == ATL_rone)
         Y[j] += y0;
      else if (beta != ATL_rzero)
         Y[j] = beta*Y[j] + y0;
      else 
         Y[j] = y0;
   }
#else
   ATL_INT i, j;
   ATL_CINT lda2 = lda+lda;
   const TYPE ra=(*alpha), ia=alpha[1], rb=(*beta), ib=beta[1];
   TYPE ry, iy, rd, id, tmp;
   TYPE dot[2];
   void (*mydot)(const int N, const TYPE *X, const int incX,
                 const TYPE *Y, const int incY, TYPE *dot);
   mydot = (Conj) ? Mjoin(PATL,dotc_sub) : Mjoin(PATL,dotu_sub);

   for (j=0; j < N; j++, A += lda2, Y += 2)
   {
      mydot(M, X, incX, A, 1, dot);
/* 
 *    Apply beta to original Y
 */
      if (ib == ATL_rzero)
      {
         if (rb == ATL_rzero)
            ry = iy = ATL_rzero;
         else
         {
            ry = *Y * rb;
            iy = Y[1] * rb;
         }
      }
      else
      {
         tmp = ry = *Y;
         ry = Y[1];
         ry = ry*rb - iy*ib;
         iy = tmp*ib + iy*rb;
      }
/*
 *    Apply alpha to dot product
 */
      rd = dot[0];
      id = dot[1];
      if (ia == ATL_rzero)
      {
         ry *= ra;
         iy *= ra;
      }
      else
      {
         tmp = ry;
         ry = ry*ra - iy*ia;
         iy = tmp*ia + iy*ra;
      }
/*
 *    Store alpha*A*x + beta*y to Y
 */
      *Y = ry + rd;
      Y[1] = iy + id;
   }
#endif
}
@ROUT mvtktest mvnktest mvntest mvttest
static int CheckAns(int M, int N, TYPE *G, int incG, TYPE *T, int incT)
{
   int i, ierr=0;
@ROUT mvnktest mvntest
   const int NN = M;
@ROUT mvtktest mvttest
   const int NN = N;
@ROUT mvtktest mvnktest mvntest mvttest
   const double nadds = NN, nmuls = NN+2;
   #ifdef TREAL
      const double epsmul = 2*(nadds+nmuls);
   #else
      const int incG2 = incG+incG, incT2 = incT+incT;
      const double epsmul = 2*(nadds+4*nmuls);
   #endif
   TYPE maxerr, diff, g, t;
   maxerr = epsmul * Mjoin(PATL,epsilon)();
#ifdef TREAL
   for (i=0; i < NN; i++, G += incG, T += incT)
   {
      g = *G;
      g = Mabs(g);
      t = *T;
      t = Mabs(t);
      diff = g - t;
      diff = Mabs(diff);
      if (diff > maxerr)
      {
         if (!ierr)
            ierr = i+1;
         fprintf(stderr, "Y(%d): Good=%f, Computed=%f, diff=%f\n", 
                 i, *G, *T, diff);
      }
   }
#else
   for (i=0; i < NN+NN; i += 2, G += incG2, T += incT2)
   {
      g = *G;
      g = Mabs(g);
      t = *T;
      t = Mabs(t);
      diff = g - t;
      diff = Mabs(diff);
      if (diff > maxerr)
      {
         if (!ierr)
            ierr = (i>>2)+1;
         fprintf(stderr, "Yr(%d): Good=%f, Computed=%f, diff=%f\n", 
                 i, *G, *T, diff);
      }
      g = G[1];
      g = Mabs(g);
      t = T[1];
      t = Mabs(t);
      diff = g - t;
      diff = Mabs(diff);
      if (diff > maxerr)
      {
         if (!ierr)
            ierr = (i>>2)+1;
         fprintf(stderr, "Yi(%d): Good=%f, Computed=%f, diff=%f\n", 
                 i, G[1], T[1], diff);
      }
   }
#endif
   return(ierr);
}
@rout r2ktest
static void dumb_ger2(int Conj, int M, int N, 
                      SCALAR alpha0, TYPE *X0, int incX0, TYPE *Y0, int incY0, 
                      SCALAR alpha1, TYPE *X1, int incX1, TYPE *Y1, int incY1, 
                      TYPE *A, int lda)
{
   dumb_ger(Conj, M, N, alpha0, X0, incX0, Y0, incY0, A, lda);
   dumb_ger(Conj, M, N, alpha1, X1, incX1, Y1, incY1, A, lda);
}

@rout r1test r1ktest
   @define epsmul @4@
@rout r2ktest
   @define epsmul @8@
@rout r1test r1ktest r2ktest
static int CheckAns(int M, int N, TYPE *G, int ldg, TYPE *U, int ldu)
{
   TYPE diff, eps;
   int i, j, ierr=0;
   #ifdef TREAL
      const int M2 = M, emul=@(epsmul);
   #else
      const int M2 = M<<1, emul=4*@(epsmul);
      ldg <<= 1; ldu <<= 1;
   #endif

   eps = Mjoin(PATL,epsilon)();
   for (j=0; j < N; j++, G += ldg, U += ldu)
   {
      for (i=0; i < M2; i++)
      {
         diff = G[i] - U[i];
         if (diff < ATL_rzero) diff = -diff;
         if (diff > emul*eps)
         {
            fprintf(stderr, "A(%d,%d): Good=%f, Computed=%f\n", 
                    i, j, G[i], U[i]);
            if (!ierr) ierr = i+j*M+1;
         }
      }
   }
   return(ierr);
}

@ROUT r1test r1ktest r2ktest mvtktest mvttest
#define NX M
#define NY N
@ROUT mvnktest mvntest
#define NX N
#define NY M
@rout r1test
#ifdef TCPLX
   #define ATL_gerT Mjoin(PATL,geru)
#else
   #define ATL_gerT Mjoin(PATL,ger)
#endif
void ATL_gerT(ATL_CINT M, ATL_CINT N, const SCALAR alpha,
              const TYPE *X, ATL_CINT incX, const TYPE *Y, ATL_CINT incY,
              TYPE *A, ATL_CINT lda);
@ROUT r1ktest
void ATL_UGERK(ATL_CINT M, ATL_CINT N, const TYPE *X, const TYPE *Y,
               TYPE *A, ATL_CINT lda);
@ROUT r2ktest
void ATL_UGER2K(ATL_CINT M, ATL_CINT N, const TYPE *X, const TYPE *Y, 
                const TYPE *W, const TYPE *Z, TYPE *A, ATL_CINT lda);
@ROUT mvnktest mvtktest
void ATL_UGEMV(ATL_CINT M, ATL_CINT N, const TYPE *A, ATL_CINT lda, 
               const TYPE *X, TYPE *Y);
@ROUT mvntest
#define my_gemv Mjoin(PATL,gemvN)
@ROUT mvttest
#ifdef ATL_Conj_
   #define my_gemv Mjoin(PATL,gemvC)
#else
   #define my_gemv Mjoin(PATL,gemvT)
#endif
@ROUT mvntest mvttest
void my_gemv
   (ATL_CINT M, ATL_CINT N, const SCALAR alpha0, const TYPE *A, ATL_CINT lda,
    const TYPE *X, ATL_CINT incX, const SCALAR beta0, TYPE *Y, ATL_CINT incY);

static int RunTest(int M, int N, int lda, int incX, int incY, 
                   SCALAR alpha, SCALAR beta)
@ROUT mvnktest mvtktest

static int RunTest(int M, int N, int lda)
@ROUT r1test r1ktest r2ktest

static int RunTest(int CONJ, int M, int N, int incY, int lda)
@ROUT r1test r1ktest r2ktest mvnktest mvtktest mvntest mvttest
{
   #ifdef TCPLX
      TYPE one[2] = {ATL_rone, ATL_rzero};
@ROUT mvnktest mvtktest    
      #ifdef BETA0
         const TYPE beta[2] = {ATL_rzero, ATL_rzero};
      #else
         const TYPE beta[2] = {ATL_rone, ATL_rzero};
      #endif
@ROUT r1test r1ktest r2ktest mvnktest mvtktest mvntest mvttest
   #else
      TYPE one = ATL_rone; 
@ROUT mvnktest mvtktest
      #ifdef BETA0
         const TYPE beta = ATL_rzero;
      #else
         const TYPE beta = ATL_rone;
      #endif
@ROUT r1test r1ktest r2ktest mvnktest mvtktest mvntest mvttest
   #endif
   TYPE *A, *A0, *X, *Y, *y;
@ROUT mvnktest mvtktest `   int incY=1;`
@ROUT mvnktest mvtktest mvntest mvttest `   TYPE *Y0;`
@ROUT r2ktest `   TYPE *X1, *Y1;`
@ROUT r1test r1ktest r2ktest mvnktest mvtktest
   ATL_CINT aincY = Mabs(incY), incX=1, aincX=1;
@ROUT mvntest mvttest 
   ATL_CINT aincY = Mabs(incY), aincX = Mabs(incX);
@ROUT r1test r1ktest r2ktest mvnktest mvtktest mvntest mvttest
   int ierr;

@ROUT mvntest mvttest
   #ifdef TCPLX
      fprintf(stdout, 
"   TEST M=%d, N=%d, lda=%d, iY=%d, iX=%d al=(%.2f,%.2f) be=(%.2f,%.2f) STARTED\n",
              M, N, lda, incY, incX, *alpha, alpha[1], *beta, beta[1]);
   #else
      fprintf(stdout, 
         "   TEST M=%d, N=%d, lda=%d, iY=%d, iX=%d al=%.2f be=%.2f STARTED\n",
              M, N, lda, incY, incX, alpha, beta);
   #endif
@ROUT mvnktest mvtktest
   fprintf(stdout, "   TEST M=%d, N=%d, lda=%d, STARTED\n", M, N, lda);
@ROUT r1test r1ktest r2ktest 
   fprintf(stdout, "   TEST CONJ=%d, M=%d, N=%d, lda=%d, incY=%d, STARTED\n",
           CONJ, M, N, lda, incY);
@ROUT r1test r1ktest r2ktest mvnktest mvtktest mvntest mvttest
   A = FA_malloc(ATL_MulBySize(lda)*N, FAa, MAa);
@ROUT r1test r1ktest r2ktest `   A0 = FA_malloc(ATL_MulBySize(M)*N, FAa, MAa);`
   Y = FA_malloc(ATL_MulBySize(NY)*aincY, FAy, MAy);
@ROUT mvntest mvttest
   X = FA_malloc(ATL_MulBySize(NX)*aincX, FAy, MAy);
@ROUT r1test r1ktest r2ktest mvnktest mvtktest
   X = FA_malloc(ATL_MulBySize(NX), FAx, MAx);
@ROUT mvnktest mvtktest mvntest mvttest
   Y0 = FA_malloc(ATL_MulBySize(NY)*aincY, FAy, MAy);
   ATL_assert(A && Y0 && X && Y);
   if (aincX != 1)
      Mjoin(PATLU,set)(NX*aincX SHIFT, 4000000000.0, X, 1);
   if (aincY != 1)
   {
      Mjoin(PATLU,set)(NY*aincY SHIFT, 2000000000.0, Y0, 1);
      Mjoin(PATLU,set)(NY*aincY SHIFT, 3000000000.0, Y, 1);
   }
   Mjoin(PATL,gegen)(1, NY, Y0, aincY, NY*aincY);
@ROUT r1test r1ktest r2ktest
   ATL_assert(A && A0 && X && Y);
@ROUT r2ktest
   X1 = FA_malloc(ATL_MulBySize(NX), FAx, MAx);
   Y1 = FA_malloc(ATL_MulBySize(NY)*aincY, FAy, MAy);
   ATL_assert(X1 && Y1);
   if (aincY != 1)
      Mjoin(PATLU,set)(NY*aincY SHIFT, 1000000000.0, Y1, 1);
   if (aincX != 1)
      Mjoin(PATLU,set)(NY*aincX SHIFT, 5000000000.0, X1, 1);
   Mjoin(PATL,gegen)(1, NY, Y1, aincY, ((N*aincY)<<4)+0xFFABCD);
   Mjoin(PATL,gegen)(1, NX, X1, aincX, NY*aincY+0xAC3955F);
@ROUT r1test r1ktest r2ktest mvnktest mvtktest mvntest mvttest
   Mjoin(PATL,gegen)(1, NY, Y, aincY, NY*aincY);
   Mjoin(PATL,gegen)(1, NX, X, aincX, NY*aincY+127*50+77);
@ROUT r1test r1ktest r2ktest `   Mjoin(PATL,gegen)(M, N, A0, M, N*M+513*7+90);`
   Mjoin(PATL,gegen)(M, N, A, lda, N*M+513*7+90);
   if (incY < 0) Y += (NY-1) * (aincY SHIFT);
@ROUT mvntest mvttest `   if (incY < 0) Y0 += (NY-1) * (aincY SHIFT);`
@ROUT mvntest mvttest `   if (incX < 0) X += (NX-1) * (aincX SHIFT);`
@ROUT r2ktest `   if (incY < 0) Y1 += (NY-1) * (aincY SHIFT);`

@ROUT mvntest mvttest
   #ifdef ATL_Conj_
      dumb_gemv(1, M, N, alpha, A, lda, X, incX, beta, Y0, incY);
   #else
      dumb_gemv(0, M, N, alpha, A, lda, X, incX, beta, Y0, incY);
   #endif
   my_gemv(M, N, alpha, A, lda, X, incX, beta, Y, incY);
   ierr = CheckAns(M, N, Y0, incY, Y, incY);
   #ifdef TREAL
      fprintf(stdout,
         "   TEST M=%d, N=%d, al,be=%.2f,%.2f, lda=%d, incXY=%d,%d %s\n",
              M, N, alpha, beta, lda, incX, incY, (ierr) ? "FAILED":"PASSED");
   #else
      fprintf(stdout,
 "   TEST M=%d, N=%d, al,be=(%.2f,%2.f),(%.2f,%.2f), lda=%d, incXY=%d,%d %s\n",
              M, N, *alpha, alpha[1], *beta, beta[1], lda, incX, incY, 
              (ierr) ? "FAILED":"PASSED");
   #endif
@ROUT mvnktest mvtktest
   dumb_gemv(0, M, N, one, A, lda, X, 1, beta, Y0, 1);
   ATL_UGEMV(M, N, A, lda, X, Y);
   ierr = CheckAns(M, N, Y0, 1, Y, 1);
@ROUT mvnktest mvtktest
   fprintf(stdout, "   TEST M=%d, N=%d, be=%.2f, lda=%d, incXY=%d,%d %s\n",
           M, N, SVAL beta, lda, incX, incY, (ierr)?"FAILED":"PASSED");
@ROUT mvnktest mvtktest mvntest mvttest
   FA_free(A, FAa, MAa);
   if (incY < 0)
   {
      Y -= (NY-1) * (aincY SHIFT);
      Y0 -= (NY-1) * (aincY SHIFT);
   }
   FA_free(Y0, FAy, MAy);
   FA_free(Y, FAy, MAy);
   if (incX < 0) X -= (NX-1) * (aincX SHIFT);
   FA_free(X, FAx, MAx);
@rout r1test
   ATL_gerT(M, N, alpha, X, incX, Y, incY, A, lda);
@beginskip
#ifdef TCPLX
   if (CONJ)
      Mjoin(PATL,ger1c_a1_x1_yX)(M, N, one, X, 1, Y, incY, A, lda);
   else Mjoin(PATL,ger1u_a1_x1_yX)(M, N, one, X, 1, Y, incY, A, lda);
#else
   Mjoin(PATL,ger1_a1_x1_yX)(M, N, one, X, 1, Y, incY, A, lda);
#endif
@endskip
@rout r1ktest
@beginskip
#ifdef TCPLS
   if (CONJ)
      ATL_GERK_Conj(M, N, one, X, 1, Y, incY, A, lda);
   else
#endif
@endskip
      ATL_UGERK(M, N, X, Y, A, lda);
@rout r2ktest
   ATL_UGER2K(M, N, X, Y, X1, Y1, A, lda);
   dumb_ger2(CONJ, M, N, one, X, 1, Y, incY, one, X1, 1, Y1, incY, A0, M);
   if (incY < 0) Y1 -= (N-1) * (aincY SHIFT);
   FA_free(Y1, FAy, MAy);
   FA_free(X1, FAx, MAx);
@rout r1test r1ktest
   dumb_ger(CONJ, M, N, one, X, 1, Y, incY, A0, M);
@ROUT r1test r1ktest r2ktest

   if (incY < 0) Y -= (N-1) * (aincY SHIFT);
   FA_free(Y, FAy, MAy);
   FA_free(X, FAx, MAx);
   ierr = CheckAns(M, N, A0, M, A, lda);
   FA_free(A, FAa, MAa);
   FA_free(A0, FAa, MAa);

@ROUT r1test r1ktest r2ktest
   if (ierr)
      fprintf(stdout, "   TEST CONJ=%d, M=%d, N=%d, lda=%d, incY=%d, FAILED\n",
              CONJ, M, N, lda, incY);
   else fprintf(stdout, 
                "   TEST CONJ=%d, M=%d, N=%d, lda=%d, incY=%d, PASSED\n",
                CONJ, M, N, lda, incY);
@ROUT r1test r1ktest r2ktest mvtktest mvnktest mvntest mvttest
   return(ierr);
}
#undef NX
#undef NY

@rout mvnktest mvtktest
int RunTests(int verb, int *Ms, int *Ns, int *ldas)
@rout r1ktest r2ktest
int RunTests(int verb, int *CONJs, int *Ms, int *Ns, int *incYs, int *ldas)
@ROUT mvntest mvttest
int RunTests(int verb, int *Ms, int *Ns, int *incXs, int *incYs, int *ldas,
             TYPE *alphas, TYPE *betas)
@rout r1ktest r2ktest mvnktest mvtktest mvntest mvttest
{
   int iy, ix, ic, in, im;
   ATL_INT m, n, lda, conj, incy;
   int nerr=0;
@ROUT mvntest mvttest
   int ia, ib, incx;
   const int NA=(*alphas), NB=(*betas);
   #ifdef TCPLX
      TYPE *alpha, *beta;
   #else
      TYPE alpha, beta;
   #endif
@rout r1ktest r2ktest mvnktest mvtktest mvntest mvttest
   assert(ldas[0] == Ms[0]);
   for (in=1; in <= Ns[0]; in++)
   {
      n = Ns[in];
      for (im=1; im <= Ms[0]; im++)
      {
         m = Ms[im];
         lda = ldas[im];
@rout mvnktest mvtktest
         nerr += RunTest(m, n, lda);
@rout r1ktest r2ktest mvntest mvttest
         for (iy=1; iy <= incYs[0]; iy++)
         {
            incy = incYs[iy];
@rout r1ktest r2ktest
            for (ic=1; ic <= CONJs[0]; ic++)
            {
               conj = CONJs[ic];
               nerr += RunTest(conj, m, n, incy, lda);
               if (nerr && !verb)
                  return(nerr);
            }
@ROUT mvntest mvttest
            for (ix=1; ix <= incXs[0]; ix++)
            {
               incx = incXs[ix];
               for (ia=1; ia <= NA; ia++)
               {
                  #ifdef TCPLX
                     alpha = alphas+ia+ia;
                  #else
                     alpha = alphas[ia];
                  #endif
                  for (ib=1; ib <= NA; ib++)
                  {
                     #ifdef TCPLX
                        beta = betas+ia+ia;
                     #else
                        beta = betas[ia];
                     #endif
                     nerr += RunTest(m, n, lda, incx, incy, alpha, beta);
                  }
               }
            }
@ROUT r1ktest r2ktest mvntest mvttest mvntest mvttest
         }
@rout r1ktest r2ktest mvnktest mvtktest mvntest mvttest
      }
   }
   return(nerr);
}

void PrintUsage(char *name, int ierr, char *flag)
{
   if (ierr > 0)
      fprintf(stderr, "Bad argument #%d: '%s'\n", 
              ierr, flag ? flag : "Not enough arguments");
   else if (ierr < 0)
      fprintf(stderr, "ERROR: %s\n", flag);

   fprintf(stderr, "USAGE: %s [flags]:\n", name);
   fprintf(stderr, "   -n <#> <N1> ... <N#>\n");
   fprintf(stderr, "   -N <Nstart> <Nend> <Ninc>\n");
   fprintf(stderr, "   -m <#> <M1> ... <M#>\n");
   fprintf(stderr, "   -M <Mstart> <Mend> <Minc>\n");
   fprintf(stderr, "   -l <#> <lda1> ... <lda#>\n");
   fprintf(stderr, "   -g <ldagap> : lda = M + <ldagap> foreach M\n");
@rout r1ktest r2ktest mvntest mvttest
   fprintf(stderr, "   -y <#> <incY1> ... <incY#>\n");
   fprintf(stderr, "   -x <#> <incX1> ... <incX#>\n");
   fprintf(stderr, "   -C <#> <conj1> ... <conj#>\n");
@ROUT mvntest mvttest
   fprintf(stderr, "   -a <#> <alpha1> ... <alpha#>\n");
   fprintf(stderr, "   -b <#> <beta1> ... <beta#>\n");
@rout r1ktest r2ktest mvnktest mvtktest mvntest mvttest
   fprintf(stderr, 
           "   -v [0,1] : 0 - stop on first error, else keep testing\n");
   fprintf(stderr,
"   -F[x,y,a] <#> : if(# > 0) -> force op to be aligned to at least # bytes\n");
   fprintf(stderr,
      "                   if(# < 0) -> force op to be aligned to < # bytes.\n");
        
   exit(ierr ? ierr : -1);
}

@extract -b @(basd)/atlas-parse.base rout=getflagarrs

@rout mvnktest mvtktest
int GetFlags(int nargs, char **args, int **Ms, int **Ns, int **LDAs)
@rout r1ktest r2ktest
int GetFlags(int nargs, char **args, int **CONJs, int **Ms, int **Ns, 
             int **LDAs, int **incYs, int **incXs)
@rout mvntest mvttest
int GetFlags(int nargs, char **args, int **Ms, int **Ns, int **LDAs, 
             int **incYs, int **incXs, TYPE **ALPHAs, TYPE **BETAs)
@rout r1ktest r2ktest mvnktest mvtktest mvntest mvttest
{
   int verb, i, k, *ip;
   char ch;
   int ldagap = 8;
@rout mvntest mvttest
   #ifdef TCPLX
      const TYPE one[2] = {ATL_rone, ATL_rzero};
   #else
      const TYPE one = ATL_rone;
   #endif
@rout r1ktest r2ktest mvnktest mvtktest mvntest mvttest

@rout r1ktest r2ktest `   *Ns = *Ms = *LDAs = *incYs = *incXs = *CONJs = NULL;`
@rout mvnktest mvtktest `   *Ns = *Ms = *LDAs = NULL;`
@ROUT mvntest mvttest `   *Ns = *Ms = *LDAs = *incYs = *incXs = NULL;`
@ROUT mvntest mvttest `   *ALPHAs = *BETAs = NULL;`
   verb = 0;

   for (i=1; i < nargs; i++)
   {
      if (args[i][0] != '-')
         PrintUsage(args[0], i, args[i]);
      ch = args[i][1];
      switch(ch)
      {
      case 'v':
        if (++i >= nargs)
            PrintUsage(args[0], i-1, "out of flags in -g ");
         verb = atoi(args[i]);
         break;
      case 'g':
        if (++i >= nargs)
            PrintUsage(args[0], i-1, "out of flags in -g ");
         ldagap = atoi(args[i]);
         break;
      case 'M':
      case 'N':
         if (i+3 >= nargs)
            PrintUsage(args[0], i-1, "out of flags in -N/M ");
         ip = IntRange2IntList(atoi(args[i+1]),atoi(args[i+2]),atoi(args[i+3]));
         if (ch == 'M')
            *Ms = ip;
         else
            *Ns = ip;
         i += 3;
         break;
      case 'n':
      case 'm':
      case 'l':
@rout r1ktest r2ktest mvntest mvttest
      case 'y':
      case 'x':
@rout r1ktest r2ktest mvnktest mvtktest mvntest mvttest
         ip = GetIntList(nargs, args, i, 1);
         i += ip[0] + 1;
         switch(ch)
         {
         case 'n':
            *Ns = ip;
            break;
         case 'm':
            *Ms = ip;
            break;
         case 'l':
            *LDAs = ip;
            break;
@rout r1ktest r2ktest mvntest mvttest
         case 'y':
            *incYs = ip;
            break;
         case 'x':
            *incXs = ip;
            break;
@rout r1ktest r2ktest mvnktest mvtktest mvntest mvttest
         }
         break;
@ROUT mvntest mvttest
      case 'a':
         *ALPHAs = GetTypeList(nargs, args, i, 1 SHIFT); 
         i += (((int)((*ALPHAs)[0]))SHIFT)+1;
         break;
      case 'b':
         *BETAs = GetTypeList(nargs, args, i, 1 SHIFT); 
         i += (((int)((*BETAs)[0]))SHIFT)+1;
         break;
@rout r1ktest r2ktest mvnktest mvtktest mvntest mvttest
      case 'F':
         ch = tolower(args[i][2]);
         k = atoi(args[++i]);
         if (ch == 'a')
         {
            if (k < 0)
              MAa = -k;
            else 
              FAa = k;
         }
         else if (ch == 'y')
         {
            if (k < 0)
              MAy = -k;
            else 
              FAy = k;
         }
         else
         {
            if (k < 0)
              MAx = -k;
            else 
              FAx = k;
         }
         break;
      default:
         PrintUsage(args[0], i, args[i]);
      }
   }
@rout r1ktest r2ktest
   if (*CONJs == NULL)
   #ifdef TCPX
      *CONJs = GetIntList2(0, 1);
   #else
      *CONJs = GetIntList1(0);
   #endif
@rout r1ktest r2ktest mvntest mvttest
   if (*incXs == NULL)
      *incXs = GetIntList1(1);
   if (*incYs == NULL)
      *incYs = GetIntList1(1);
@rout mvntest mvttest
   if (*ALPHAs == NULL)
      *ALPHAs = GetTypeList1(one);
   if (*BETAs == NULL)
      *BETAs = GetTypeList1(one);
@rout r1ktest r2ktest mvnktest mvtktest mvntest mvttest
   if (*Ms == NULL)
      *Ms = GetIntList1(977);
   if (*Ns == NULL)
      *Ns = GetIntList1(77);
   if (*LDAs == NULL)
   {
      *LDAs = DupIntList(*Ms);
      for (i=1; i <= (*LDAs)[0]; i++)
         (*LDAs)[i] += ldagap;
   }
   assert((*LDAs)[0] == (*Ms)[0]);
   return(verb);
}

int main(int nargs, char **args)
{
   int *Ms, *Ns, *LDAs, *incYs, *incXs, *CONJs;
   int verb, ierr=0;
@rout mvntest mvttest `   TYPE *ALPHAs, *BETAs;`

@rout mvnktest mvtktest
   verb = GetFlags(nargs, args, &Ms, &Ns, &LDAs);
   ierr = RunTests(verb, Ms, Ns, LDAs);
@rout mvntest mvttest
   verb = GetFlags(nargs, args, &Ms, &Ns, &LDAs, &incYs, &incXs,&ALPHAs,&BETAs);
   ierr = RunTests(verb, Ms, Ns, incXs, incYs, LDAs, ALPHAs, BETAs);
   free(ALPHAs);
   free(BETAs);
@rout r1ktest r2ktest
   verb = GetFlags(nargs, args, &CONJs, &Ms, &Ns, &LDAs, &incYs, &incXs);
   ierr = RunTests(verb, CONJs, Ms, Ns, incYs, LDAs);
   free(CONJs);
@rout r1ktest r2ktest mvntest mvttest
   free(incXs);
   free(incYs);
@rout r1ktest r2ktest mvnktest mvtktest mvntest mvttest
   free(Ms);
   free(Ns);
   free(LDAs);
   exit(ierr);
}
@rout r1test
static int RunTests(int M, int N, int incY, int lda)
{
   int j, k=0, ierr = 0;

   ATL_assert(incY != 0);

#ifdef TCPLX
   for (k=0; k < 2; k++)
#endif
   {
      j = RunTest(k, M, N, 1, lda);
      if (!ierr) ierr = j;
      j = RunTest(k, M, N, incY, lda);
      if (!ierr) ierr = j;
      j = RunTest(k, M, N, -incY, lda);
      if (!ierr) ierr = j;
   }
   return(ierr);
}

static void PrintUsage(char *nam)
{
   fprintf(stderr, "USAGE: %s -m <M> -n <N> -Y <incY> -l <lda>\n",
           nam);
   exit(-1);
}

void GetFlags(int nargs, char **args, int *M, int *N, int *incY, int *lda)
{
   int i, k;
   char ch;

   *M = 997;
   *N = 177;
   *incY = 3;
   *lda = -1;

   for (i=1; i < nargs; i++)
   {
      if (args[i][0] != '-') PrintUsage(args[0]);
      switch(args[i][1])
      {
      case 'F':
         ch = args[i][2];
         k = atoi(args[++i]);
         if (ch == 'a')
         {
            if (k < 0)
              MAa = -k;
            else 
              FAa = k;
         }
         else if (ch == 'y')
         {
            if (k < 0)
              MAy = -k;
            else 
              FAy = k;
         }
         else
         {
            if (k < 0)
              MAx = -k;
            else 
              FAx = k;
         }
         break;
      case 'm':
         *M = atoi(args[++i]);
         break;
      case 'n':
         *N = atoi(args[++i]);
         break;
      case 'l':
         *lda = atoi(args[++i]);
         break;
      case 'Y':
         *incY = atoi(args[++i]);
         break;
      default:
         PrintUsage(args[0]);
      }
   }
   if (*lda < *M) *lda = *M + 9;
}

int main(int nargs, char **args)
{
   int M, N, incY, lda, ierr=0;

   GetFlags(nargs, args, &M, &N, &incY, &lda);
   ierr = RunTests(M, N, incY, lda);
   return(ierr);
}
@ROUT ATL_symv_old

#include "atlas_misc.h"
#include "atlas_lvl2.h"
#include <assert.h>
#include Mstr(Mjoin(Mjoin(atlas_,PRE),mv.h))
@skip #include Mstr(Mjoin(Mjoin(atlas_,PRE),mvS.h))

#define gemvN Mjoin(PATL,gemvN_a1_x1_b1_y1)
#define gemvT Mjoin(PATL,gemvT_a1_x1_b1_y1)

static void refsymvL
   (const int N, const SCALAR alpha, const TYPE *A, const int lda,
    const TYPE *X, const int incX, const SCALAR beta, TYPE *Y, const int incY)
{
#ifdef TREAL
   register TYPE t0, t1, t2;
   const int ldap1=lda+1;
   int j, i, iaij, jaj;

   for (j=jaj=0; j < N; j++, jaj+=ldap1)
   {
      t0 = X[j]; t1 = ATL_rzero; Y[j] += t0 * A[jaj];
      for (i=j+1, iaij=1+jaj; i < N; i++, iaij++)
      {
         t2 = A[iaij];
         Y[i] += t2 * t0; 
         t1 += t2 * X[i];
      }
      Y[j] += t1;
   }
#else
   register TYPE yr, yi, ar, ai, xr, xi, Xr, Xi;
   const int ldap1=(lda+1)SHIFT, N2=(N SHIFT);
   const TYPE *a, *x;
   TYPE *y=Y;
   int i, j;

   for (j=0; j < N; j++, A += ldap1, X += 2, Y += 2)
   {
      yr = yi = ATL_rzero;
      xr = *X; xi = X[1];
      ar = *A;
      *Y += ar*xr; Y[1] += ar*xi;
      for (y=Y+2, x=X+2, a=A+2, i=j+1; i < N; i++, a += 2, x += 2, y += 2)
      {
         ar = *a; ai = a[1];
         Xr = *x; Xi = x[1];
         *y   += ar*xr + ai*xi;
         y[1] += ar*xi - ai*xr;
         yr += ar * Xr - ai * Xi;
         yi += ar * Xi + ai * Xr;
      }
      *Y = yr; Y[1] = yi;
   }
#endif
}
static void RsymvL(const int N, const TYPE *A, const int lda, const TYPE *X,
                   const SCALAR beta, TYPE *Y)
{
   int mb, nb, jb, jbs, j, m;
   const TYPE *x0=X, *A0=A;
   const SCALAR alpha=beta;
   TYPE *y0=Y;

   ATL_GetPartSYMV(A, lda, &mb, &nb);

   for (j=0; j < N; j += nb)
   {
      jb = N-j;
      jb = Mmin(jb,nb);
      refsymvL(jb, alpha, A, lda, X, 1, beta, Y, 1);
      m = N-j-jb;
      if (m)
      {
         jbs = jb SHIFT; X += jbs; Y += jbs;
         gemvT(jb, m, alpha, A+jbs, lda, X, 1, beta, y0, 1);
         gemvN(m, jb, alpha, A+jbs, lda, x0, 1, beta, Y, 1);
         A += jbs*(lda+1); x0 = X; y0 = Y;
      }
   }
}
void Mjoin(PATL,symv)
   (const enum ATLAS_UPLO Uplo, const int N, const SCALAR alpha,
    const TYPE *A, const int lda, const TYPE *X, const int incX,
    const SCALAR beta, TYPE *Y, const int incY)
{
   int mb, nb, jb, mb1, incA1, incA, incXY, incXY1, n, j;
   const int lda2=(lda SHIFT);
   const TYPE *x0=X, *x1, *A0=A, *A1;
   TYPE *y1, *y0=Y;

   assert(incX==1 && incY==1 && Uplo == AtlasLower);
   #ifdef TREAL
      assert(alpha == ATL_rone && beta == ATL_rone);
   #else
      assert(*alpha == ATL_rone && *beta == ATL_rone);
      assert(alpha[1] == ATL_rzero && beta[1] == ATL_rzero);
   #endif

   ATL_GetPartSYMV(A, lda, &mb, &nb);
   mb1 = N - ( (N-1) / mb ) * mb;
   incA1 = nb * lda2;  incXY1 = (nb SHIFT);
   incA = incXY = mb SHIFT;
   n = (N-mb)SHIFT;
   A += n; X += n; Y += n; 
   for (n=N-mb; n > 0; n -= mb, A -= incA, X -= incXY, Y -= incXY)
   {
      RsymvL(mb, A+n*lda2, lda, X, beta, Y);
      for (j=0, A1=A, x1=x0, y1=y0; j < n; j += nb, A1 += incA1, x1 += incXY1,
           y1 += incXY1)
      {
         jb = n - j;
         jb = Mmin(jb, nb);
         gemvT(jb, mb, alpha, A1, lda, X, 1, beta, y1, 1);
         gemvN(mb, jb, alpha, A1, lda, x1, 1, beta, Y, 1);
      }
   }
   RsymvL(mb1, A0, lda, x0, beta, y0);
}
@ROUT ATL_GER1_axpy ATL_ger1_4x4_1 ATL_ger1_8x4_0 ATL_ger1_1x4_0
#include "atlas_misc.h"
#include "atlas_lvl2.h"
@ROUT ATL_ger1_axpy `#include "atlas_prefetch.h"`

static void ger_Mle8(const int M, const int N, const TYPE *X, 
                     const TYPE *Y, const int incY, TYPE *A, const int lda)
{
   const TYPE *stY = Y + incY*N;
   register TYPE y0, x0, x1, x2, x3, x4, x5, x6, x7;

   switch(M)
   {
   case 1:
      x0 = *X;
      do
      {
         *A += *Y * x0;
         A += lda;
         Y += incY;
      }
      while (Y != stY);
      break;
   case 2:
      x0 = *X;
      x1 = X[1];
      do
      {
         y0 = *Y;
         *A += y0 * x0; Y += incY;
         A[1] += y0 * x1;
         A += lda;
      }
      while (Y != stY);
      break;
   case 3:
      x0 = *X;
      x1 = X[1];
      x2 = X[2];
      do
      {
         y0 = *Y;
         *A += y0 * x0;
         A[1] += y0 * x1; Y += incY;
         A[2] += y0 * x2; A += lda;
      }
      while (Y != stY);
      break;
   case 4:
      x0 = *X;
      x1 = X[1];
      x2 = X[2];
      x3 = X[3];
      do
      {
         y0 = *Y;
         *A += y0 * x0;
         A[1] += y0 * x1; Y += incY;
         A[2] += y0 * x2;
         A[3] += y0 * x3; A += lda;
      }
      while (Y != stY);
      break;
   case 5:
      x0 = *X;
      x1 = X[1];
      x2 = X[2];
      x3 = X[3];
      x4 = X[4];
      do
      {
         y0 = *Y;
         *A += y0 * x0;
         A[1] += y0 * x1; Y += incY;
         A[2] += y0 * x2;
         A[3] += y0 * x3;
         A[4] += y0 * x4; A += lda;
      }
      while (Y != stY);
      break;
   case 6:
      x0 = *X;
      x1 = X[1];
      x2 = X[2];
      x3 = X[3];
      x4 = X[4];
      x5 = X[5];
      do
      {
         y0 = *Y;
         *A += y0 * x0;
         A[1] += y0 * x1; Y += incY;
         A[2] += y0 * x2;
         A[3] += y0 * x3;
         A[4] += y0 * x4;
         A[5] += y0 * x5; A += lda;
      }
      while (Y != stY);
      break;
   case 7:
      x0 = *X;
      x1 = X[1];
      x2 = X[2];
      x3 = X[3];
      x4 = X[4];
      x5 = X[5];
      x6 = X[6];
      do
      {
         y0 = *Y;
         *A += y0 * x0;
         A[1] += y0 * x1;
         A[2] += y0 * x2; Y += incY;
         A[3] += y0 * x3;
         A[4] += y0 * x4;
         A[5] += y0 * x5;
         A[6] += y0 * x6; A += lda;
      }
      while (Y != stY);
      break;
   case 8:
      x0 = *X;
      x1 = X[1];
      x2 = X[2];
      x3 = X[3];
      x4 = X[4];
      x5 = X[5];
      x6 = X[6];
      x7 = X[7];
      do
      {
         y0 = *Y;
         *A += y0 * x0;
         A[1] += y0 * x1;
         A[2] += y0 * x2; Y += incY;
         A[3] += y0 * x3;
         A[4] += y0 * x4;
         A[5] += y0 * x5;
         A[6] += y0 * x6;
         A[7] += y0 * x7; A += lda;
      }
      while (Y != stY);
      break;
   default:
      ATL_assert(M == 0);
   }
}
static void ger_Nle4(const int M, const int N, const TYPE *X, 
                     const TYPE *Y, const int incY, TYPE *A, const int lda)
{
   register TYPE y0, y1, y2, y3, x0;
   TYPE *A0 = A, *A1 = A+lda, *A2 = A1+lda, *A3 = A2+lda;
   int i;

   switch(N)
   {
   case 1:
      y0 = *Y;
      for (i=0; i != M; i++) A0[i] += y0 * X[i];
      break;
   case 2:
      y0 = *Y; y1 = Y[incY];
      for (i=0; i != M; i++)
      {
         x0 = X[i];
         A0[i] += y0 * x0;
         A1[i] += y1 * x0;
      }
      break;
   case 3:
      y0 = *Y; y1 = Y[incY]; y2 = Y[incY<<1];
      for (i=0; i != M; i++)
      {
         x0 = X[i];
         A0[i] += y0 * x0;
         A1[i] += y1 * x0;
         A2[i] += y2 * x0;
      }
      break;
   case 4:
      y0 = *Y; y1 = Y[incY]; y2 = Y[incY+incY]; y3 = Y[(incY<<1)+incY];
      for (i=0; i != M; i++)
      {
         x0 = X[i];
         A0[i] += y0 * x0;
         A1[i] += y1 * x0;
         A2[i] += y2 * x0;
         A3[i] += y3 * x0;
      }
      break;
   default:;
   }
}
void ATL_UGERK
   (const int M, const int N, const SCALAR alpha, const TYPE *X, const int incX,
    const TYPE *Y, const int incY, TYPE *A, const int lda)
{
@ROUT ATL_ger1_1x4_0
   int i, j;
   const TYPE *x;
   TYPE *A0 = A, *A1 = A + lda, *A2 = A1 + lda, *A3 = A2 + lda;
   const TYPE *Y1 = Y+incY, *Y2 = Y1+incY, *Y3 = Y2+incY;
   const int N4 = (N>>2)<<2, incAn = (lda<<2) - M + 1, incY4 = incY<<2;
   register TYPE m0, m1, m2, m3, x0, y0, y1, y2, y3;

   if (M > 8)
   {
      for (j=N4; j; j -= 4)
      {
         y0 = *Y;  Y  += incY4;
         y1 = *Y1; Y1 += incY4;
         y2 = *Y2; Y2 += incY4;
         y3 = *Y3; Y3 += incY4;
         x = X;
         x0 = *X; x = X + 1;
         m0 = y0 * x0;
         m1 = y1 * x0;
         m2 = y2 * x0;
         m3 = y3 * x0;
         for (i=M-1; i; i--)
         {
            x0 = *x++;
            *A0++ += m0; m0 = y0 * x0;
            *A1++ += m1; m1 = y1 * x0;
            *A2++ += m2; m2 = y2 * x0;
            *A3++ += m3; m3 = y3 * x0;
         }
         *A0 += m0; A0 += incAn;
         *A1 += m1; A1 += incAn;
         *A2 += m2; A2 += incAn;
         *A3 += m3; A3 += incAn;
      }
      if (N-N4) ger_Nle4(M, N-N4, X, Y, incY, A0, lda);
   }
   else ger_Mle8(M, N, X, Y, incY, A, lda);
@ROUT ATL_ger1_8x4_0
   int i, j;
   const int incy = incY<<2;
   const TYPE *Y1= Y + incY, *Y2 = Y1 + incY, *Y3 = Y2 + incY;
   const TYPE *x;
   TYPE *A0 = A, *A1 = A + lda, *A2 = A1 + lda, *A3 = A2 + lda;
   const int M8 = ((M-1)>>3)<<3, mr = M-M8-1;
   const int N4 = (N>>2)<<2, incAn = (lda<<2) - M + 1;
   register TYPE m0, m1, m2, m3, x0, y0, y1, y2, y3;

   if (M8)
   {
      for (j=N4; j; j -= 4)
      {
         y0 = *Y; y1 = *Y1; y2 = *Y2; y3 = *Y3; 
         x0 = *X; x = X + 1;
         m0 = y0 * x0; Y += incy; 
         m1 = y1 * x0; Y1 += incy; 
         m2 = y2 * x0; Y2 += incy; 
         m3 = y3 * x0; Y3 += incy;
         for (i=M8; i; i -= 8)
         {
            x0 = *x;
            *A0 += m0; m0 = y0 * x0;
            *A1 += m1; m1 = y1 * x0;
            *A2 += m2; m2 = y2 * x0;
            *A3 += m3; m3 = y3 * x0;
            x0 = x[1];
            A0[1] += m0; m0 = y0 * x0;
            A1[1] += m1; m1 = y1 * x0;
            A2[1] += m2; m2 = y2 * x0;
            A3[1] += m3; m3 = y3 * x0;
            x0 = x[2];
            A0[2] += m0; m0 = y0 * x0;
            A1[2] += m1; m1 = y1 * x0;
            A2[2] += m2; m2 = y2 * x0;
            A3[2] += m3; m3 = y3 * x0;
            x0 = x[3];
            A0[3] += m0; m0 = y0 * x0;
            A1[3] += m1; m1 = y1 * x0;
            A2[3] += m2; m2 = y2 * x0;
            A3[3] += m3; m3 = y3 * x0;
            x0 = x[4];
            A0[4] += m0; m0 = y0 * x0;
            A1[4] += m1; m1 = y1 * x0;
            A2[4] += m2; m2 = y2 * x0;
            A3[4] += m3; m3 = y3 * x0;
            x0 = x[5];
            A0[5] += m0; m0 = y0 * x0;
            A1[5] += m1; m1 = y1 * x0;
            A2[5] += m2; m2 = y2 * x0;
            A3[5] += m3; m3 = y3 * x0;
            x0 = x[6];
            A0[6] += m0; m0 = y0 * x0;
            A1[6] += m1; m1 = y1 * x0;
            A2[6] += m2; m2 = y2 * x0;
            A3[6] += m3; m3 = y3 * x0;
            x0 = x[7]; x += 8;
            A0[7] += m0; m0 = y0 * x0; A0 += 8;
            A1[7] += m1; m1 = y1 * x0; A1 += 8;
            A2[7] += m2; m2 = y2 * x0; A2 += 8;
            A3[7] += m3; m3 = y3 * x0; A3 += 8;
         }
         if (mr)
         {
            for (i=mr; i; i--)
            {
               x0 = *x++;
               *A0++ += m0; m0 = y0 * x0;
               *A1++ += m1; m1 = y1 * x0;
               *A2++ += m2; m2 = y2 * x0;
               *A3++ += m3; m3 = y3 * x0;
            }
         }
         *A0 += m0; A0 += incAn;
         *A1 += m1; A1 += incAn;
         *A2 += m2; A2 += incAn;
         *A3 += m3; A3 += incAn;
      }
      if (N-N4) ger_Nle4(M, N-N4, X, Y, incY, A0, lda);
   }
   else ger_Mle8(M, N, X, Y, incY, A, lda);
@ROUT ATL_ger1_4x4_1
   int i, j;
   const int incy = incY<<2;
   const TYPE *Y1= Y + incY, *Y2 = Y1 + incY, *Y3 = Y2 + incY;
   const TYPE *x;
   TYPE *A0 = A, *A1 = A + lda, *A2 = A1 + lda, *A3 = A2 + lda;
   const int M4 = (M>>2)<<2, N4 = (N>>2)<<2, incAn = (lda<<2) - M4;
   register TYPE x0, x1, x2, x3, y0, y1, y2, y3;

   if (M4)
   {
      for (j=N4; j; j -= 4)
      {
         y0 = *Y;  Y  += incy;
         y1 = *Y1; Y1 += incy;
         y2 = *Y2; Y2 += incy;
         y3 = *Y3; Y3 += incy;
         x = X;
         for (i=M4; i; i -= 4)
         {
            x0 = *x; x1 = x[1]; x2 = x[2]; x3 = x[3];
            *A0 += y0 * x0;
            x += 4;
            *A1 += y1 * x0;
            *A2 += y2 * x0;
            *A3 += y3 * x0;
            A0[1] += y0 * x1;
            A1[1] += y1 * x1;
            A2[1] += y2 * x1;
            A3[1] += y3 * x1;
            A0[2] += y0 * x2;
            A1[2] += y1 * x2;
            A2[2] += y2 * x2;
            A3[2] += y3 * x2;
            A0[3] += y0 * x3; A0 += 4;
            A1[3] += y1 * x3; A1 += 4;
            A2[3] += y2 * x3; A2 += 4;
            A3[3] += y3 * x3; A3 += 4;
         }
         switch(M-M4)
         {
         case 1:
            x0 = *x;
            *A0 += y0 * x0;
            *A1 += y1 * x0;
            *A2 += y2 * x0;
            *A3 += y3 * x0;
            break;
         case 2:
            x0 = *x; x1 = x[1];
            *A0 += y0 * x0;
            *A1 += y1 * x0;
            *A2 += y2 * x0;
            *A3 += y3 * x0;
            A0[1] += y0 * x1;
            A1[1] += y1 * x1;
            A2[1] += y2 * x1;
            A3[1] += y3 * x1;
            break;
         case 3:
            x0 = *x; x1 = x[1]; x2 = x[2];
            *A0 += y0 * x0;
            *A1 += y1 * x0;
            *A2 += y2 * x0;
            *A3 += y3 * x0;
            A0[1] += y0 * x1;
            A1[1] += y1 * x1;
            A2[1] += y2 * x1;
            A3[1] += y3 * x1;
            A0[2] += y0 * x2;
            A1[2] += y1 * x2;
            A2[2] += y2 * x2;
            A3[2] += y3 * x2;
            break;
         }
         A0 += incAn;
         A1 += incAn;
         A2 += incAn;
         A3 += incAn;
      }
      if (N-N4) ger_Nle4(M, N-N4, X, Y, incY, A0, lda);
   }
   else ger_Mle8(M, N, X, Y, incY, A, lda);
@ROUT ATL_ger1_axpy
   const TYPE *stY = Y + N*incY;
@beginskip
   #ifdef ATL_AltiVec
      int cwrd = ATL_MulBySize(N)>>4;
      if (cwrd >= 64) cwrd = ATL_GetCtrl(512, (cwrd+31)>>5, 0);
      else cwrd = ATL_GetCtrl(64, (cwrd+3)>>2, 4);
   #endif
@endskip
   if (M > 8)
   {
      do
      {
@beginskip
         #ifdef ATL_AltiVec
            ATL_pfavW(A, cwrd, 0);
         #endif
@endskip
         Mjoin(PATL,axpy)(M, *Y, X, 1, A, 1);
         Y += incY;
         A += lda;
      }
      while (Y != stY);
   }
   else ger_Mle8(M, N, X, Y, incY, A, lda);
@ROUT ATL_ger1_axpy ATL_ger1_4x4_1 ATL_ger1_8x4_0 ATL_ger1_1x4_0
}
@ROUT atlas_r1.h
   @define rt @r1@
@ROUT atlas_r2.h
   @define rt @r2@
@ROUT atlas_r1.h atlas_r2.h
#ifdef SREAL
   #include "atlas_s@(rt).h"
#elif defined(DREAL)
   #include "atlas_d@(rt).h"
#elif defined(SCPLX)
   #include "atlas_c@(rt).h"
#elif defined(DCPLX)
   #include "atlas_z@(rt).h"
#endif
@ROUT ATL_Align2Ptr
@beginskip
static void *ATL_Align2Ptr(void *pu, void *pA)
/*
 * Aligns pu%ATL_Cachelen to pA%ATL_Cachelen by adding at most ATL_Cachlen
 * to pu
 */
{
   size_t tu = (size_t) pu, ta = (size_t) pA;

   tu -= (tu/ATL_Cachelen)*ATL_Cachelen;
   ta -= (ta/ATL_Cachelen)*ATL_Cachelen;
   if (tu <= ta)
      tu = ta;
   else
      tu = ta + ATL_Cachelen-tu;
   tu += (size_t) pu;
   return((void*) tu);
}
@endskip
@ROUT ATL_ger2
#include "atlas_misc.h"
#include "atlas_lvl2.h"
#include "atlas_lvl3.h"
#include "atlas_cache.h"
#if defined(ATL_INL1)
   #include Mstr(Mjoin(Mjoin(atlas_,PRE),r2_L1.h))
#elif defined(ATL_INL2)
   #include Mstr(Mjoin(Mjoin(atlas_,PRE),r2_L2.h))
#elif defined(ATL_INOOC) || defined(ATL_TUNING)
   #include Mstr(Mjoin(Mjoin(atlas_,PRE),r2.h))
#else
   #define ATL_CHOICE
   #if defined(LLPC_SZ) && LLPC_LVL != 1
      #define MY_CE LLPC_SZ
   #elif defined(LLC_SZ) && LLC_LVL != 1
      #define MY_CE LLC_SZ
   #else
      #ifndef L1C_SZ
         #error "How is L1 size not defined?"
      #endif
      #define MY_CE (ATL_MulBySize(L1C_SZ)<<2)
   #endif
@skip   #include Mstr(Mjoin(Mjoin(atlas_,PRE),sysinfo.h))
@skip   #include "atlas_cacheedge.h"
@beginskip
   #if defined(ATL_NCPU) && ATL_NCPU > 1
      #include "atlas_tcacheedge.h"
   #else
      #include "atlas_cacheedge.h"
   #endif
/*
 * If I don't believe CacheEdge setting (or not set), set L2 size to 4*L1
 */
   #ifdef CacheEdge
      #if CacheEdge > 4194304 || CacheEdge == 0
         #define MY_CE (4*ATL_MulBySize(L1C_ELTS))
      #else
         #define MY_CE CacheEdge
      #endif
   #else
      #define MY_CE (4*ATL_MulBySize(L1C_ELTS))
   #endif
@endskip
#endif

#ifdef TREAL
   #define MY_GER2 Mjoin(PATL,ger2)
   #define MY_GER  Mjoin(PATL,ger)
#else
   #ifdef Conj_
      #define MY_GER2 Mjoin(PATL,ger2c)
      #define MY_GER  Mjoin(PATL,gerc)
   #else
      #define MY_GER2 Mjoin(PATL,ger2u)
      #define MY_GER  Mjoin(PATL,geru)
   #endif
#endif
#ifdef ATL_INL1
   #define ATL_ger2 Mjoin(MY_GER2,_L1)
   #define ATL_ger Mjoin(MY_GER,_L1)
#elif defined(ATL_INL2)
   #define ATL_ger2 Mjoin(MY_GER2,_L2)
   #define ATL_ger Mjoin(MY_GER,_L2)
#elif defined(ATL_INOOC)
   #define ATL_ger2 Mjoin(MY_GER2,_OOC)
   #define ATL_ger Mjoin(MY_GER,_OOC)
#else
   #define ATL_ger2 MY_GER2
#endif

#ifdef Conj_
void Mjoin(PATL,ger2ck_Nlt8)
   (ATL_CINT M, ATL_CINT N, const SCALAR alpha0, const TYPE *X,
    ATL_CINT incX, const TYPE *Y, ATL_CINT incY, const SCALAR beta0,
    const TYPE *W, ATL_CINT incW, const TYPE *Z, ATL_CINT incZ,
    TYPE *A, const int lda);
void Mjoin(PATL,ger2ck_Mlt16)
   (ATL_CINT M, ATL_CINT N, const SCALAR alpha0, const TYPE *X,
    ATL_CINT incX, const TYPE *Y, ATL_CINT incY, const SCALAR beta0,
    const TYPE *W, ATL_CINT incW, const TYPE *Z, ATL_CINT incZ,
    TYPE *A, const int lda);
#endif
void Mjoin(PATL,ger2k_Nlt8)
   (ATL_CINT M, ATL_CINT N, const SCALAR alpha0, const TYPE *X,
    ATL_CINT incX, const TYPE *Y, ATL_CINT incY, const SCALAR beta0,
    const TYPE *W, ATL_CINT incW, const TYPE *Z, ATL_CINT incZ,
    TYPE *A, const int lda);
void Mjoin(PATL,ger2k_Mlt16)
   (ATL_CINT M, ATL_CINT N, const SCALAR alpha0, const TYPE *X,
    ATL_CINT incX, const TYPE *Y, ATL_CINT incY, const SCALAR beta0,
    const TYPE *W, ATL_CINT incW, const TYPE *Z, ATL_CINT incZ,
    TYPE *A, const int lda);

void ATL_ger2
   (ATL_CINT M, ATL_CINT N, const SCALAR alpha0, const TYPE *X,
    ATL_CINT incX, const TYPE *Y, ATL_CINT incY, const SCALAR beta0,
    const TYPE *W, ATL_CINT incW, const TYPE *Z, ATL_CINT incZ,
    TYPE *A, const int lda)
{
#ifdef ATL_CHOICE
    const size_t opsize = (M*N + ((N+M)<<1))*sizeof(TYPE)SHIFT;

   if (opsize > MY_CE)
@skip       !ATL_L2AIsOverlapped(0, ATL_sizeof, M, N, (size_t)A, lda))
      Mjoin(MY_GER2,_OOC)(M, N, alpha0, X, incX, Y, incY, beta0, W, incW, 
                          Z, incZ, A, lda);
   else if (opsize > ATL_MulBySize(L1C_ELTS))
       Mjoin(MY_GER2,_L2)(M, N, alpha0, X, incX, Y, incY, beta0, W, incW, 
                          Z, incZ, A, lda);
   else /* if (opsize <= ATL_MulBySize(L1C_ELTS)) */
       Mjoin(MY_GER2,_L1)(M, N, alpha0, X, incX, Y, incY, beta0, W, incW, 
                          Z, incZ, A, lda);
#else
   void (*getX)(const int N, const SCALAR alpha, const TYPE *X,
                const int incX, TYPE *Y, const int incY);
   void (*getW)(const int N, const SCALAR alpha, const TYPE *X,
                const int incX, TYPE *Y, const int incY);
   ATL_r2kern_t ger2k;
   void *vp=NULL, *vp2;
   TYPE *x = (TYPE*)X, *y = (TYPE*)Y;
   TYPE *w = (TYPE*)W, *z = (TYPE*)Z;
   size_t t1, t2;
   ATL_INT m, Nm, nr, CacheElts, mb, imb, incy=1;
   int mu, nu, alignX, alignY, ALIGNX2A, ForceNU, minM, minN; 
   int COPYX, COPYY, COPYW, COPYZ, APPLYALPHAX, APPLYBETAW;
   #ifdef TREAL
      #define one ATL_rone
      TYPE alpha = alpha0;
      TYPE beta  = beta0;
      const int ALPHA_IS_ONE = (alpha0 == ATL_rone);
      const int BETA_IS_ONE = (beta0 == ATL_rone);
   #else
      TYPE one[2]={ATL_rone,ATL_rzero}; 
      TYPE *alpha=(TYPE*)alpha0, *beta=(TYPE*)beta0;
      const int ALPHA_IS_ONE = (alpha0[0] == ATL_rone && alpha0[1]==ATL_rzero);
      const int BETA_IS_ONE = (beta0[0] == ATL_rone && beta0[1] == ATL_rzero);
   #endif

   if (M < 1 || N < 1)
      return;
#ifndef TUNING
   if (SCALAR_IS_ZERO(alpha))
   {
      if (!SCALAR_IS_ZERO(beta))
         ATL_ger(M, N, beta, W, incW, Z, incZ, A, lda);
      return;
   }
   if (SCALAR_IS_ZERO(beta))
   {
      ATL_ger(M, N, alpha, X, incX, Y, incY, A, lda);
      return;
   }
#endif
/*
 * Get gerk kernel pointer along with any usage guidelines, and use the
 * optimized CacheElts to compute the correct blocking factor
 */
   ger2k = ATL_GetR2Kern(M, N, A, lda, &mu, &nu, &minM, &minN, &alignX,
                         &ALIGNX2A, &alignY, &ForceNU, &CacheElts);
   if (CacheElts)
   {
      mb = (CacheElts - 4*nu) / (4*(nu+1));
      mb = (mb > mu) ? (mb/mu)*mu : M;
      mb = (mb > M) ? M : mb;
   }
   else
      mb = M;
/*
 * Set up to handle case where kernel requres N to be a multiple if NU
 */
   if (ForceNU)
   {
      Nm = (N/nu)*nu;
      nr = N - Nm;
   }
   else
   {
      Nm = N;
      nr = 0;
   }
/*
 * For very small N, we can't afford the data copy, so call cleanup routine
 */
   if (N < 4 || Nm < 1)
   {
      #ifdef Conj_
         Mjoin(PATL,ger2ck_Nlt8)(M, N, alpha0, X, incX, Y, incY,
                                 beta0, W, incW, Z, incZ, A, lda);
      #else
         Mjoin(PATL,ger2k_Nlt8)(M, N, alpha0, X, incX, Y, incY,
                                 beta0, W, incW, Z, incZ, A, lda);
      #endif
      return;
   }
/*
 * ATLAS's GER2 kernels loop over M in inner loop, which is bad news if M is
 * very small.  Call code that requires no copy of A & B for these degenerate
 * cases
 */
   if (M < 16 || M < minM)
   {
      #ifdef Conj_
         Mjoin(PATL,ger2ck_Mlt16)(M, N, alpha0, X, incX, Y, incY,
                                  beta0, W, incW, Z, incZ, A, lda);
      #else
         Mjoin(PATL,ger2k_Mlt16)(M, N, alpha0, X, incX, Y, incY,
                                 beta0, W, incW, Z, incZ, A, lda);
      #endif
      return;
   }
/*
 *********************************************************************
 Figure out whether vecs need be copied, and which ones will be scaled 
 *********************************************************************
 */
   #ifdef Conj_
      COPYY = COPYZ = 1;
   #else
      COPYY = (incY != 1);
      if (!COPYY && alignY)
      {
         t1 = (size_t) Y;
         COPYY = ((t1/alignY)*alignY != t1);
      }
      COPYZ = (incZ != 1);
      if (!COPYZ && alignY)
      {
         t1 = (size_t) Z;
         COPYZ = ((t1/alignY)*alignY != t1);
      }
   #endif
   @whiledef v X W
   COPY@(v) = (inc@(v) != 1);
   if (!COPY@(v))  /* may still need to copy due to alignment issues */
   {
/*
 *    ATL_Cachelen is the highest alignment that can be requested, so
 *    make X's modulo Cachelen match that of A if you want A & X to have
 *    the same alignment
 */
      if (ALIGNX2A)
      {
         t1 = (size_t) A;
         t2 = (size_t) @(v);
         COPY@(v) = (t1 - ATL_MulByCachelen(ATL_DivByCachelen(t1))) !=
                 (t2 - ATL_MulByCachelen(ATL_DivByCachelen(t2)));
      }
      else if (alignX)
      {
         t1 = (size_t) @(v);
         COPY@(v) = ((t1/alignX)*alignX != t1);
      }
   }
   @endwhile
   if (COPYX != COPYY)         /* if only one of them is already being copied */
      APPLYALPHAX = COPYX;     /* apply alpha to that one */
   else if (!COPYY && !COPYX)  /* nobody currently being copied means */
   {                           /* we'll need to force a copy to apply alpha */
      APPLYALPHAX = (M < N);   /* apply alpha to shorter vector */
      if (!ALPHA_IS_ONE)       /* force copy if alpha != 1.0 */
      {
         COPYX = APPLYALPHAX;
         COPYY = !APPLYALPHAX;
      }
   }
   else                        /* if both are being copied anyway */
      APPLYALPHAX = (M < N);   /* apply alpha to shorter vector */

   if (COPYW != COPYZ)         /* if only one of them is already being copied */
      APPLYBETAW = COPYW;      /* apply alpha to that one */
   else if (!COPYZ && !COPYW)  /* nobody currently being copied means */
   {                           /* we'll need to force a copy to apply beta */
      APPLYBETAW = (M < N);    /* apply beta to shorter vector */
      if (!BETA_IS_ONE)        /* force copy if beta != 1.0 */
      {
         COPYW = APPLYBETAW;
         COPYZ = !APPLYBETAW;
      }
   }
   else                        /* if both are being copied anyway */
      APPLYBETAW = (M < N);    /* apply beta to shorter vector */

   if (COPYX | COPYY | COPYW | COPYZ)  /* if I need to copy any vector */
   {                          /* allocate & align them */
      vp = malloc(ATL_MulBySize((COPYX+COPYW)*mb+(COPYY+COPYZ)*N) 
                  + 4*ATL_Cachelen);
/*
 *    If we cannot allocate enough space to copy the vectors, give up and
 *    call the simple loop-based implementation
 */
      if (!vp)
      {
         #ifdef Conj_
            Mjoin(PATL,ger2ck_Nlt8)
         #else
            Mjoin(PATL,ger2k_Nlt8)
         #endif
            (M, N, alpha0, X, incX, Y, incY, beta0, W, incW, Z, incZ, A, lda);
         return;
      }
      vp2 = vp;
      if (COPYY)
      {
         y = ATL_AlignPtr(vp);
         vp2 = y + (N SHIFT);
         if (!APPLYALPHAX && !ALPHA_IS_ONE)  /* need to apply alpha to Y */
         {
            #ifdef Conj_
               Mjoin(PATL,moveConj)(N, alpha, Y, incY, y, 1);
            #else
               Mjoin(PATL,cpsc)(N, alpha, Y, incY, y, 1);
            #endif
            alpha = one;
         }
         else  /* do not apply alpha */
         #ifdef Conj_
            Mjoin(PATL,copyConj)(N, Y, incY, y, 1);
         #else
            Mjoin(PATL,copy)(N, Y, incY, y, 1);
         #endif
      }
      if (COPYZ)
      {
         z = ATL_AlignPtr(vp2);
         vp2 = z + (N SHIFT);
         if (!APPLYBETAW && !BETA_IS_ONE)  /* need to apply beta  to Z */
         {
            #ifdef Conj_
               Mjoin(PATL,moveConj)(N, beta, Z, incZ, z, 1);
            #else
               Mjoin(PATL,cpsc)(N, beta, Z, incZ, z, 1);
            #endif
            beta = one;
         }
         else  /* do not apply beta */
         #ifdef Conj_
            Mjoin(PATL,copyConj)(N, Z, incZ, z, 1);
         #else
            Mjoin(PATL,copy)(N, Z, incZ, z, 1);
         #endif
      }
      if (COPYX)
      {
         x = (ALIGNX2A) ? ATL_Align2Ptr(vp2, A) : ATL_AlignPtr(vp2);
         vp2 = x + (mb SHIFT);
      }
      if (COPYW)
      {
         w = (ALIGNX2A) ? ATL_Align2Ptr(vp2, A) : ATL_AlignPtr(vp2);
         vp2 = w + (mb SHIFT);
      }
   }
   getX = (COPYX) ? Mjoin(PATL,cpsc) : NULL;
   getW = (COPYW) ? Mjoin(PATL,cpsc) : NULL;
   m = M;
   do
   {
      imb = Mmin(mb, m);
      if (getX)    /* copy X if necessary */
         getX(imb, alpha, X, incX, x, 1);
      else
         x = (TYPE*) X;
      if (getW)    /* copy X if necessary */
         getW(imb, beta, W, incW, w, 1);
      else
         w = (TYPE*) W;

/*
 *    Call optimized kernel (can be restricted or general)
 */
      if (imb >= minM)
         ger2k(imb, Nm, x, y, w, z, A, lda);
      else
         Mjoin(PATL,ger2k_Mlt16)(imb, Nm, one, x, 1, y, 1, one, w, 1, z, 1, 
                                 A, lda);
/*
 *    Some kernels require N%NU=0; if so nr is remainder, do cleanup with axpy
 */
      if (nr)
         Mjoin(PATL,ger2k_Nlt8)(imb, nr, one, x, 1, y+(Nm SHIFT), 1, one,
                                w, 1, z+(Nm SHIFT), 1, 
                                A+((size_t)lda)*(Nm SHIFT), lda);
      A += imb SHIFT;
      X += (imb*incX)SHIFT;
      W += (imb*incW)SHIFT;
      m -= imb;
      imb = Mmin(m,mb);
   }
   while(m);
   if (vp)
      free(vp);
#endif
}
@ROUT ATL_ger ATL_ger_ldamul
#include "atlas_misc.h"
#include "atlas_lvl2.h"
#include "atlas_lvl3.h"
#include "atlas_cache.h"
#if defined(ATL_INL1)
   #include Mstr(Mjoin(Mjoin(atlas_,PRE),r1_L1.h))
#elif defined(ATL_INL2)
   #include Mstr(Mjoin(Mjoin(atlas_,PRE),r1_L2.h))
@ROUT ATL_ger_ldamul
#else defined(ATL_INOOC) || defined(ATL_TUNING)
   #include Mstr(Mjoin(Mjoin(atlas_,PRE),r1.h))
#endif
@ROUT ATL_ger
#elif defined(ATL_INOOC) || defined(ATL_TUNING)
   #include Mstr(Mjoin(Mjoin(atlas_,PRE),r1.h))
#else
   #define ATL_CHOICE
   #include Mstr(Mjoin(Mjoin(atlas_,PRE),sysinfo.h))
   #include "atlas_cacheedge.h"
@beginskip
   #if defined(ATL_NCPU) && ATL_NCPU > 1
      #include "atlas_tcacheedge.h"
   #else
      #include "atlas_cacheedge.h"
   #endif
@endskip
/*
 * If I don't believe CacheEdge setting (or not set), set L2 size to 4*L1
 */
   #ifdef CacheEdge
      #if CacheEdge > 4194304 || CacheEdge == 0
         #define MY_CE (4*ATL_MulBySize(L1C_ELTS))
      #else
         #define MY_CE CacheEdge
      #endif
   #else
      #define MY_CE (4*ATL_MulBySize(L1C_ELTS))
   #endif
#endif

#ifdef TREAL
   #define MY_GER Mjoin(PATL,ger)
   #define MY_GERK_AXPY Mjoin(PATL,gerk_axpy)
   #define MY_GERK_MLT16 Mjoin(PATL,gerk_Mlt16)
#else
   #ifdef Conj_
      #define MY_GER Mjoin(PATL,gerc)
      #define MY_GERK_AXPY Mjoin(PATL,gerck_axpy)
      #define MY_GERK_MLT16 Mjoin(PATL,gerck_Mlt16)
   #else
      #define MY_GER Mjoin(PATL,geru)
      #define MY_GERK_AXPY Mjoin(PATL,gerk_axpy)
      #define MY_GERK_MLT16 Mjoin(PATL,gerk_Mlt16)
   #endif
#endif
#ifdef Conj_
void Mjoin(PATL,gerk_axpy)
   (const int M, const int N, const SCALAR alpha, const TYPE *X, const int incX,
    const TYPE *Y, const int incY, TYPE *A, const int lda);
void Mjoin(PATL,gerk_Mlt16)
   (const int M, const int N, const SCALAR alpha, const TYPE *X, const int incX,
    const TYPE *Y, const int incY, TYPE *A, const int lda);
#endif
void MY_GERK_AXPY
   (const int M, const int N, const SCALAR alpha, const TYPE *X, const int incX,
    const TYPE *Y, const int incY, TYPE *A, const int lda);
void MY_GERK_MLT16
   (const int M, const int N, const SCALAR alpha, const TYPE *X, const int incX,
    const TYPE *Y, const int incY, TYPE *A, const int lda);

#ifdef ATL_INL1
   #define ATL_ger Mjoin(MY_GER,_L1)
#elif defined(ATL_INL2)
   #define ATL_ger Mjoin(MY_GER,_L2)
#elif defined(ATL_INOOC)
   #define ATL_ger Mjoin(MY_GER,_OOC)
#else
   #define ATL_ger MY_GER
#endif

void ATL_ger
   (const int M, const int N, const SCALAR alpha0, const TYPE *X, 
    const int incX, const TYPE *Y, const int incY, TYPE *A, const int lda)
{
#ifdef ATL_CHOICE
   const size_t opsize = (M*N+M+N)*sizeof(TYPE)SHIFT;

   if (opsize <= ATL_MulBySize(L1C_ELTS))
      Mjoin(MY_GER,_L1)(M, N, alpha0, X, incX, Y, incY, A, lda);
   else if (opsize <= MY_CE)
      Mjoin(MY_GER,_L2)(M, N, alpha0, X, incX, Y, incY, A, lda);
   else
      Mjoin(MY_GER,_OOC)(M, N, alpha0, X, incX, Y, incY, A, lda);
#else
   void (*getX)(const int N, const SCALAR alpha, const TYPE *X,
                const int incX, TYPE *Y, const int incY);
   ATL_r1kern_t gerk;
   void *vp=NULL;
   TYPE *x = (TYPE*)X, *y = (TYPE*)Y;
   size_t t1, t2;
   ATL_INT m, Nm, nr, CacheElts, mb, imb, incy=1;
   int mu, nu, alignX, alignY, ALIGNX2A, ForceNU, COPYX, COPYY, APPLYALPHAX;
   int minM, minN;
   #ifdef TREAL
      #define one ATL_rone
      TYPE alpha = alpha0;
      const int ALPHA_IS_ONE = (alpha0 == ATL_rone);
   #else
      TYPE one[2] = {ATL_rone, ATL_rzero}, *alpha=(TYPE*)alpha0;
      const int ALPHA_IS_ONE = (alpha0[0] == ATL_rone && alpha[1] == ATL_rzero);
   #endif

   if (M < 1 || N < 1 || SCALAR_IS_ZERO(alpha))
      return;
/*
 * Get gerk kernel pointer along with any usage guidelines, and use the
 * optimized CacheElts to compute the correct blocking factor
 */
   gerk = ATL_GetR1Kern(M, N, A, lda, &mu, &nu, &minM, &minN, &alignX,
                         &ALIGNX2A, &alignY, &ForceNU, &CacheElts);
   if (CacheElts)
   {
      mb = (CacheElts - 2*nu) / (2*(nu+1));
      mb = (mb > mu) ? (mb/mu)*mu : M;
      mb = (mb > M) ? M : mb;
   }
   else
      mb = M;
/* 
 * Set up to handle case where kernel requres N to be a multiple if NU
 */
   if (ForceNU)
   {
      Nm = (N/nu)*nu;
      nr = N - Nm;
   }
   else
   {
      Nm = N;
      nr = 0;
   }
/*
 * For very small N, we can't afford the data copy, so call AXPY-based routine
 */
   if (N < 4 || Nm < 1)
   {
      MY_GERK_AXPY(M, N, alpha0, X, incX, Y, incY, A, lda);
      return;
   }
/*
 * ATLAS's GER kernels loop over M in inner loop, which is bad news if M is
 * very small.  Call code that requires no copy of A & B for these degenerate
 * cases
 */
   if (M < 16 || M < minM)
   {
      MY_GERK_MLT16(M, N, alpha0, X, incX, Y, incY, A, lda);
      return;
   }
/*
 *****************************************************************************
 Figure out whether vecs need be copied, and which one will be scaled by alpha
 *****************************************************************************
 */
   #ifdef Conj_
      COPYY = 1;
   #else
      COPYY = (incY != 1);
      if (!COPYY && alignY)
      {
         t1 = (size_t) Y;
         COPYY = ((t1/alignY)*alignY != t1);
      }
   #endif
   COPYX = (incX != 1);
   if (!COPYX)  /* may still need to copy due to alignment issues */
   {
/*
 *    ATL_Cachelen is the highest alignment that can be requested, so
 *    make X's % with Cachelen match that of A if you want A & X to have
 *    the same alignment
 */
      if (ALIGNX2A)
      {
         t1 = (size_t) A;
         t2 = (size_t) X;
         COPYX = (t1 - ATL_MulByCachelen(ATL_DivByCachelen(t1))) !=
                 (t2 - ATL_MulByCachelen(ATL_DivByCachelen(t2)));
      }
      else if (alignX)
      {
         t1 = (size_t) X;
         COPYX = ((t1/alignX)*alignX != t1);
      }
   }
   if (COPYX != COPYY)         /* if only one of them is already being copied */
      APPLYALPHAX = COPYX;     /* apply alpha to that one */
   else if (!COPYY && !COPYX)  /* nobody currently being copied means */
   {                           /* we'll need to force a copy to apply alpha */
      APPLYALPHAX = (M < N);   /* apply alpha to shorter vector */
      if (!ALPHA_IS_ONE)       /* force copy if alpha != 1.0 */
      {
         COPYX = APPLYALPHAX;
         COPYY = !APPLYALPHAX;
      }
   }
   else                        /* if both are being copied anyway */
      APPLYALPHAX = (M < N);   /* apply alpha to shorter vector */

   if (COPYX | COPYY)         /* if I need to copy either vector */
   {                          /* allocate & align them */
      vp = malloc(ATL_MulBySize(COPYX*mb+COPYY*N) + 2*ATL_Cachelen);
/* 
 *    If we cannot allocate enough space to copy the vectors, give up and
 *    call the simple loop-based implementation
 */
      if (!vp)
      {
         MY_GERK_AXPY(M, N, alpha0, X, incX, Y, incY, A, lda);
         return;
      }
      if (COPYY)
      {
         y = ATL_AlignPtr(vp);
         x = y + (N SHIFT);
         x = (ALIGNX2A) ? ATL_Align2Ptr(x, A) : ATL_AlignPtr(x);
         if (!APPLYALPHAX && !ALPHA_IS_ONE)  /* need to apply alpha to Y */
         {
            #ifdef Conj_
               Mjoin(PATL,moveConj)(N, alpha, Y, incY, y, 1);
            #else
               Mjoin(PATL,cpsc)(N, alpha, Y, incY, y, 1);
            #endif
            alpha = one;
         }
         else  /* do not apply alpha */
         #ifdef Conj_
            Mjoin(PATL,copyConj)(N, Y, incY, y, 1);
         #else
            Mjoin(PATL,copy)(N, Y, incY, y, 1);
         #endif
      }
      else if (ALIGNX2A)
         x = ATL_Align2Ptr(vp, A);
      else
         x = ATL_AlignPtr(vp);
   }
   getX = (COPYX) ? Mjoin(PATL,cpsc) : NULL;
   m = M;
   do
   {
      imb = Mmin(mb, m);
      if (getX)    /* copy X if necessary */
         getX(imb, alpha, X, incX, x, 1);
      else 
         x = (TYPE*) X;
/*
 *    Call optimized kernel (can be restricted or general)
 */
      if (imb > minM)
         gerk(imb, Nm, x, y, A, lda);
      else
         Mjoin(PATL,gerk_Mlt16)(imb, Nm, one, x, 1, y, 1, A, lda);
/*
 *    Some kernels require N%NU=0; if so nr is remainder, do cleanup with axpy
 */
      if (nr)
         Mjoin(PATL,gerk_axpy)(imb, nr, one, x, 1, y+(Nm SHIFT), 1, 
                               A+((size_t)lda)*(Nm SHIFT), lda);
      A += imb SHIFT;
      X += (imb*incX)SHIFT;
      m -= imb;
      imb = Mmin(m,mb);
   }
   while(m);
   if (vp)
      free(vp);
#endif
}
@ROUT ATL_ger_ldamul
void ATL_ger_ldamul
(
   ATL_CINT M, ATL_CINT N,   /* prob dims */
   const TYPE *Xs,           /* all pos alignments of X */
   const TYPE *Y,            /* Y ptr */
   TYPE *A,                  /* A ptr */
   ATL_CINT lda              /* leading dim of A */
)
/*
 * This routine builds handles the case when lda is not a multiple of
 * the required alignment.  It does this by dividing the $N$ dimension
 * by a factor that is used as a multiplier along lda.  For instance,
 * if a user passes in an odd lda for single precision, but an SSE kernel
 * may demand lda is a multiple of 16 bytes so that all columns of A
 * share the same alignment.  We can fix this problem by making 4 calls
 * to the kernel, each handling N/4 of the columns, each one being called
 * with lda*=4 (this means we select every 4th col).
 * For now, this kernel is restricted to creating an alignment of 16 bytes,
 * but we could generalize it if we wanted to handle higher alignments.
 *
 * Xs is actually a pointer to 2 (4) vectors for 8-byte (4-byte) elements.
 * Xs pts to a X vector aligned to ATL_cachelen.  Each possible alignment
 * of X is then supported, and the next vector is found by:
 *   ((currvec+(M+ATL_cachlen/eltsz)/ATL_cachlen)*ATL_cachelen + offset
 */
{
#if defined(SCPLX) || defined(DREAL)  /* 8-byte elements */
   static ATL_r1kern_t gerk=NULL, gerk8;  /* gerks for 16/8-byte alignments */
   static int mu, nu, minM, minN, alignX, alignY, ALIGNX2A, ForceNU;
   static int mu8, nu8, minM8, minN8, alignX8, alignY8, ALIGNX2A8, ForceNU8;
   ATL_CINT lda2 = lda+lda;
   ATL_INT celts;
   if (!gerk)
   {
      gerk = ATL_GetR1Kern(800, 800, 16, 800, &mu, &nu, &minM, &minN, &alignX,
                           &ALIGNX2A, &alignY, &ForceNU, &celts);
      gerk8 = ATL_GetR1Kern(800, 800, 16, 800, &mu8, &nu8, &minM8, &minN8, 
                            &alignX8, &ALIGNX2A8, &alignY8, &ForceNU8, &celts);
   }
   if (lda & 1) /* lda odd, so must build out of 2 lda*2 calls */
   else         /* even lda is OK */
   {
      if (((size_t)A) % )
   }
   
#else /* must be single precision, 4-byte elements */
#endif
}
@ROUT atlas_mv.h
#ifndef ATLAS_MV_H
   #define ATLAS_MV_H

#include "atlas_misc.h"
#if defined(SREAL)
   #include "atlas_smvn.h"
   #include "atlas_smvt.h"
#elif defined(DREAL)
   #include "atlas_dmvn.h"
   #include "atlas_dmvt.h"
#elif defined(SCPLX)
   #include "atlas_cmvn.h"
   #include "atlas_cmvt.h"
#elif defined(DCPLX)
   #include "atlas_zmvn.h"
   #include "atlas_zmvt.h"
#endif
#define ATL_GetPartSYMV ATL_GetPartMVN

#endif
@ROUT atlas_mv.h_old
#ifndef ATLAS_MV_H
   #define ATLAS_MV_H

#include "atlas_misc.h"

/*
 * Header file for figuring how big a matvec to do at a time, and still keep
 * operands in L1 cache.  Here we use 3/4 of L1 only, to ensure a good amount
 * of operands remain in cache despite conflicts, noise, etc.  Later on we'll
 * determine this empirically, exactly as CacheEdge does for L2 cache.
 * We set # of TLB entries and pagesizes to good defaults.  We will try to
 * probe for them in subsequent releases.
 */
#ifndef ATL_pagesize
   #define ATL_pagesize ATL_DivBySize(4096)
#endif
#ifndef ATL_ntlb
   #define ATL_ntlb 56  /* # of tlb entries; emperically determine later */
#endif

#if (defined(ATL_NOMULADD) && (ATL_mmnreg >= 22)) || \
    (defined(ATL_MULADD) && (ATL_mmnreg >= 28))
   #define ATL_GetPartMVN(A_, lda_, mb_, nb_) \
   { \
      *(nb_) = (((3*(L1C_ELTS - 4)) / (20))>>2)<<1; \
      if (ATL_pagesize > (lda_)) \
      { \
         *(mb_) = (ATL_pagesize / (lda_)) * ATL_ntlb; \
         if ( (*mb_) < *(nb_) ) *(nb_) = ((*(mb_))>>1)<<1; \
      } \
      else *(nb_) = ATL_ntlb; \
      *(mb_) = ( ((3*L1C_ELTS)>>2) - *(nb_) ) / ((*(nb_)+1)<<1); \
@skip      *(mb_) = 4; \
   }
   #define ATL_GetPartMVT(A_, lda_, mb_, nb_) \
   { \
      *(mb_) = (((3*L1C_ELTS) / 20)>>2)<<2; \
      *(nb_) = 2; \
   }
#else
   #include "atlas_lvl3.h"

   #define ATL_GetPartMVN(A_, lda_, mb_, nb_) \
   { \
      *(mb_) = Mmax(2,ATL_mmMU); \
      *(nb_) = ( ((3*L1C_ELTS)>>2) - ((*(mb_))<<1)  ) / ( ((*(mb_))<<1)+1 ); \
      if (ATL_pagesize > (lda_)) \
         (*nb_) = Mmin(*(nb_), (ATL_pagesize/(lda_)) *ATL_ntlb); \
      else *(nb_) = ATL_ntlb; \
      if (*(nb_) > NB) *(nb_) = ATL_MulByNB(ATL_DivByNB(*(nb_))); \
      else (*nb_) = NB; \
      *(mb_) = ( ((3*L1C_ELTS)>>2) - *(nb_) ) / ((*(nb_)+1)<<1); \
      if (*(mb_) > ATL_mmMU) (*mb_) = ((*mb_) / ATL_mmMU)*ATL_mmMU; \
      else *(mb_) = ATL_mmMU; \
   }
   #define ATL_GetPartMVT(A_, lda_, mb_, nb_) \
   { \
      *(nb_) = Mmax(2,ATL_mmMU); \
      *(mb_) = ( ((3*L1C_ELTS)>>2) - ((*(nb_))<<1) ) / ( ((*(nb_))<<1)+1 ); \
      if (*(mb_) > NB) *(mb_) = ATL_MulByNB(ATL_DivByNB(*(mb_))); \
      else *(mb_) = NB; \
   }
#endif

#endif
@ROUT ATL_cgemvN_4x2_1 ATL_cgemvN_2x2_0 ATL_cgemvN_mm ATL_cgemvN_1x1_1 ATL_cgemvN_1x1_1a
#include "atlas_misc.h"
#include "atlas_level2.h"
#include "atlas_level1.h"
@ROUT ATL_cgemvN_4x2_1 `#include "atlas_prefetch.h"`

#ifdef Conj_
   #define PEQ -=
   #define MEQ +=
#else
   #define PEQ +=
   #define MEQ -=
#endif

@ROUT ATL_cgemvN_mm
#include "atlas_lvl3.h"

#ifdef Conj_
void Mjoin(PATL,Mjoin(Mjoin(Mjoin(Mjoin(gemvNc,NM),_x1),BNM),_y1))
   (const int M, const int N, const SCALAR alpha,
    const TYPE *A, const int lda, const TYPE *X, const int incX,
    const SCALAR beta, TYPE *Y, const int incY)
/*
 *  Use trick: y <- alpha * conj(A) + y ==> 
 *             trans(y) <- alpha * trans(x) * ConjTrans(A) + trans(y)
 */
{
   TYPE one[2] = {ATL_rone, ATL_rzero};
   Mjoin(PATL,NCmmJIK)(AtlasTrans, AtlasConjTrans, 1, M, N, one, X, 1,
                       A, lda, beta, Y, 1);
}
#else
void Mjoin(PATL,Mjoin(Mjoin(Mjoin(Mjoin(gemvN,NM),_x1),BNM),_y1))
   (const int M, const int N, const SCALAR alpha,
    const TYPE *A, const int lda, const TYPE *X, const int incX,
    const SCALAR beta, TYPE *Y, const int incY)
{
   TYPE one[2] = {ATL_rone, ATL_rzero};
   Mjoin(PATL,NCmmJIK)(AtlasNoTrans, AtlasNoTrans, M, 1, N, one, A, lda,
                       X, N, beta, Y, M);
}
#endif
@ROUT ATL_cgemvN_4x2_1 ATL_cgemvN_2x2_0 ATL_cgemvN_1x1_1 ATL_cgemvN_1x1_1a
#ifdef Conj_
   #define gemv0 Mjoin(Mjoin(Mjoin(Mjoin(gemvNc,NM),_x1),BNM),_y1)
#else
   #define gemv0 Mjoin(Mjoin(Mjoin(Mjoin(gemvN,NM),_x1),BNM),_y1)
#endif

static void gemvMlt4(const int M, const int N, const TYPE *A, const int lda,
                     const TYPE *X, const SCALAR beta, TYPE *Y)
{
   int i;
   #if defined(BETAX) || defined(BETA1) || defined(BETAXI0)
      register TYPE yr1, yi1;
   #endif
   #ifdef BETAXI0
      const register TYPE rbeta = *beta;
   #endif
   #ifdef BETAX
      register TYPE yr0, yi0;
      const register TYPE rbeta = *beta, ibeta = beta[1];
   #endif

   for(i=M; i; i--, A += 2, Y += 2)
   {
      #ifdef BETA0
         #ifdef Conj_
            Mjoin(PATL,dotc_sub)(N, A, lda, X, 1, Y);
         #else
            Mjoin(PATL,dotu_sub)(N, A, lda, X, 1, Y);
         #endif
      #else
         #ifdef BETAX
            yr0 = *Y;
            yi0 = Y[1];
            yr1 = yr0 * rbeta - yi0 * ibeta;
            yi1 = yr0 * ibeta + yi0 * rbeta;
         #else
            yr1 = *Y;
            yi1 = Y[1];
            #ifdef BETAXI0
               yr1 *= rbeta;
               yi1 *= rbeta;
            #endif
         #endif
         #ifdef Conj_
            Mjoin(PATL,dotc_sub)(N, A, lda, X, 1, Y);
         #else
            Mjoin(PATL,dotu_sub)(N, A, lda, X, 1, Y);
         #endif
         *Y += yr1;
         Y[1] += yi1;
      #endif
   }
}

static void gemvNlt2(const int M, const int N, const TYPE *A, const int lda,
                     const TYPE *X, const SCALAR beta, TYPE *Y)
{
   if (N)
   {
      #if defined(BETA0)
         #ifdef Conj_
            Mjoin(PATL,moveConj)(M, X, A, 1, Y, 1);
         #else
            Mjoin(PATL,cpsc)(M, X, A, 1, Y, 1);
         #endif
      #elif defined(BETAX) || defined(BETAXI0)
         #ifdef Conj_
            Mjoin(PATL,axpbyConj)(M, X, A, 1, beta, Y, 1);
         #else
            Mjoin(PATL,axpby)(M, X, A, 1, beta, Y, 1);
         #endif
      #else
         #ifdef Conj_
            Mjoin(PATL,axpyConj)(M, X, A, 1, Y, 1);
         #else
            Mjoin(PATL,axpy)(M, X, A, 1, Y, 1);
         #endif
      #endif
   }
}

@ROUT ATL_cgemvN_4x2_1
static void gemvN4x2(const int M, const int N, const TYPE *A, const int lda,
                     const TYPE *X, const SCALAR beta, TYPE *Y)
{
   const int M4 = (M>>2)<<2, N2 = (N>>1)<<1, nr = N-N2;
   const int incA = (lda<<2), incAm = (4 - N2*lda)<<1;
   const TYPE *A0 = A, *A1 = A + (lda<<1);
   const TYPE *x, *stX = X + (N2<<1);
   TYPE *stY = Y + (M4<<1);
   register TYPE ar00, ar10, ar20, ar30, ai00, ai10, ai20, ai30;
   register TYPE ar01, ar11, ar21, ar31, ai01, ai11, ai21, ai31;
   register TYPE yr0, yr1, yr2, yr3, yi0, yi1, yi2, yi3;
   register TYPE xr0, xi0, xr1, xi1, p0, p1;
   #ifdef ATL_AltiVec
   const int cwrd=ATL_GetCtrl(ATL_MulBySize(lda), Mmin(N,255), ATL_sizeof>>1);
   #endif


   if (N2)
   {
      if (M4)
      {
         do
         {
            #ifdef ATL_AltiVec
               ATL_pfavR(A0, cwrd, 0);
            #endif
            #ifdef BETA0
               yr0 = yi0 = yr1 = yi1 = yr2 = yi2 = yr3 = yi3 = ATL_rzero;
            #elif defined(BETAX)
               xr0 = *beta; xi0 = beta[1];
               ar00 = *Y;   ai00 = Y[1]; ar10 = Y[2]; ai10 = Y[3];
               ar20 = Y[4]; ai20 = Y[5]; ar30 = Y[6]; ai30 = Y[7];
               yr0 = ar00 * xr0 - ai00 * xi0;
               yi0 = ar00 * xi0 + ai00 * xr0;
               yr1 = ar10 * xr0 - ai10 * xi0;
               yi1 = ar10 * xi0 + ai10 * xr0;
               yr2 = ar20 * xr0 - ai20 * xi0;
               yi2 = ar20 * xi0 + ai20 * xr0;
               yr3 = ar30 * xr0 - ai30 * xi0;
               yi3 = ar30 * xi0 + ai30 * xr0;
            #else
               yr0 = *Y;   yi0 = Y[1]; yr1 = Y[2]; yi1 = Y[3];
               yr2 = Y[4]; yi2 = Y[5]; yr3 = Y[6]; yi3 = Y[7];
               #ifdef BETAXI0
                  xr0 = *beta;
                  yr0 *= xr0; yi0 *= xr0;
                  yr1 *= xr0; yi1 *= xr0;
                  yr2 *= xr0; yi2 *= xr0;
                  yr3 *= xr0; yi3 *= xr0;
               #endif
            #endif
            xr0 = *X; xi0 = X[1]; xr1 = X[2]; xi1 = X[3]; x = X + 4;
            ar00 = *A0;   ar01 = *A1;   ai00 = A0[1]; ai01 = A1[1];
            ar10 = A0[2]; ar11 = A1[2]; ai10 = A0[3]; ai11 = A1[3];
            ar20 = A0[4]; ar21 = A1[4]; ai20 = A0[5]; ai21 = A1[5];
            ar30 = A0[6]; ar31 = A1[6]; ai30 = A0[7]; ai31 = A1[7];
            A0 += incA;  A1 += incA;
            if (N2 != 2)
            {
               do
               {
                  yr0 += ar00 * xr0;
                  yi0 += ar01 * xi1;
                  yr1 += ar10 * xr0; p0 = A1[2];
                  yi1 += ar11 * xi1;
                  yr2 += ar20 * xr0; p1 = A0[2];
                  yi2 += ar21 * xi1;
                  yr3 += ar30 * xr0;
                  yi3 += ar31 * xi1;

                  yr0 += ar01 * xr1; ar01 = *A1;
                  yi0 += ar00 * xi0; ar00 = *A0;
                  yr1 += ar11 * xr1; ar11 = p0;
                  yi1 += ar10 * xi0; ar10 = p1;
                  yr2 += ar21 * xr1; ar21 = A1[4];
                  yi2 += ar20 * xi0; ar20 = A0[4];
                  yr3 += ar31 * xr1; ar31 = A1[6];
                  yi3 += ar30 * xi0; ar30 = A0[6];

                  yr0 MEQ ai00 * xi0;
                  yi0 PEQ ai01 * xr1;
                  yr1 MEQ ai10 * xi0; p0 = *x;
                  yi1 PEQ ai11 * xr1;
                  yr2 MEQ ai20 * xi0; p1 = A1[3];
                  yi2 PEQ ai21 * xr1;
                  yr3 MEQ ai30 * xi0; xi0 = x[1];
                  yi3 PEQ ai31 * xr1; xr1 = x[2];

                  yr0 MEQ ai01 * xi1; ai01 = A1[1];
                  yi0 PEQ ai00 * xr0; ai00 = A0[1];
                  yr1 MEQ ai11 * xi1; ai11 = p1;
                  yi1 PEQ ai10 * xr0; ai10 = A0[3];
                  yr2 MEQ ai21 * xi1; ai21 = A1[5];
                  yi2 PEQ ai20 * xr0; ai20 = A0[5];
                  yr3 MEQ ai31 * xi1; ai31 = A1[7]; xi1 = x[3]; A1 += incA;
                  yi3 PEQ ai30 * xr0; xr0 = p0; ai30 = A0[7]; A0 += incA; 
                  x += 4;
               }
               while (x != stX);
            }
            if (!nr)  /* 2 cols left to do, all fetching done */
            {
               yr0 += ar00 * xr0;
               yi0 += ar01 * xi1;
               yr1 += ar10 * xr0;
               yi1 += ar11 * xi1;
               yr2 += ar20 * xr0;
               yi2 += ar21 * xi1;
               yr3 += ar30 * xr0;
               yi3 += ar31 * xi1;

               yr0 += ar01 * xr1;
               yi0 += ar00 * xi0;
               yr1 += ar11 * xr1;
               yi1 += ar10 * xi0;
               yr2 += ar21 * xr1;
               yi2 += ar20 * xi0;
               yr3 += ar31 * xr1;
               yi3 += ar30 * xi0;

               yr0 MEQ ai00 * xi0;
               yi0 PEQ ai01 * xr1;
               yr1 MEQ ai10 * xi0;
               yi1 PEQ ai11 * xr1;
               yr2 MEQ ai20 * xi0;
               yi2 PEQ ai21 * xr1;
               yr3 MEQ ai30 * xi0;
               yi3 PEQ ai31 * xr1;

               yr0 MEQ ai01 * xi1;
               yi0 PEQ ai00 * xr0;
               yr1 MEQ ai11 * xi1;
               yi1 PEQ ai10 * xr0;
               yr2 MEQ ai21 * xi1;
               yi2 PEQ ai20 * xr0;
               yr3 MEQ ai31 * xi1;
               yi3 PEQ ai30 * xr0;
            }
            else  /* 3 cols left, 2 already fetched */
            {
               yr0 += ar00 * xr0;
               yi0 += ar01 * xi1;
               yr1 += ar10 * xr0; p0 = A0[2];
               yi1 += ar11 * xi1;
               yr2 += ar20 * xr0; p1 = A0[6];
               yi2 += ar21 * xi1;
               yr3 += ar30 * xr0;
               yi3 += ar31 * xi1;

               yr0 += ar01 * xr1;
               yi0 += ar00 * xi0; ar00 = *A0;
               yr1 += ar11 * xr1;
               yi1 += ar10 * xi0; ar10 = p0;
               yr2 += ar21 * xr1;
               yi2 += ar20 * xi0; ar20 = A0[4];
               yr3 += ar31 * xr1;
               yi3 += ar30 * xi0; ar30 = p1;

               yr0 MEQ ai00 * xi0;
               yi0 PEQ ai01 * xr1;
               yr1 MEQ ai10 * xi0; p0 = *x;
               yi1 PEQ ai11 * xr1;
               yr2 MEQ ai20 * xi0;
               yi2 PEQ ai21 * xr1;
               yr3 MEQ ai30 * xi0; xi0 = x[1];
               yi3 PEQ ai31 * xr1;

               yr0 MEQ ai01 * xi1;
               yi0 PEQ ai00 * xr0; ai00 = A0[1];
               yr1 MEQ ai11 * xi1;
               yi1 PEQ ai10 * xr0; ai10 = A0[3];
               yr2 MEQ ai21 * xi1;
               yi2 PEQ ai20 * xr0; ai20 = A0[5];
               yr3 MEQ ai31 * xi1;
               yi3 PEQ ai30 * xr0; xr0 = p0; ai30 = A0[7];

               yr0 += ar00 * xr0;
               yi0 += ar00 * xi0;
               yr1 += ar10 * xr0;
               yi1 += ar10 * xi0;
               yr2 += ar20 * xr0;
               yi2 += ar20 * xi0;
               yr3 += ar30 * xr0;
               yi3 += ar30 * xi0;

               yr0 MEQ ai00 * xi0;
               yi0 PEQ ai00 * xr0;
               yr1 MEQ ai10 * xi0;
               yi1 PEQ ai10 * xr0;
               yr2 MEQ ai20 * xi0;
               yi2 PEQ ai20 * xr0;
               yr3 MEQ ai30 * xi0;
               yi3 PEQ ai30 * xr0;
            }
            *Y   = yr0;
            Y[1] = yi0;
            A0 += incAm;
            Y[2] = yr1;
            Y[3] = yi1;
            A1 += incAm;
            Y[4] = yr2;
            Y[5] = yi2;
            Y[6] = yr3;
            Y[7] = yi3;
            Y += 8;
         }
         while(Y != stY);
      }
      if (M-M4) gemvMlt4(M-M4, N, A0, lda, X, beta, Y);
   }
   else if (N && M) gemvNlt2(M, N, A, lda, X, beta, Y);
}
@ROUT ATL_cgemvN_4x2_1 ATL_cgemvN_2x2_0 ATL_cgemvN_1x1_1 ATL_cgemvN_1x1_1a
void Mjoin(PATL,gemv0)
   (const int M, const int N, const SCALAR alpha,
    const TYPE *A, const int lda, const TYPE *X, const int incX,
    const SCALAR beta, TYPE *Y, const int incY)
{
@ROUT ATL_cgemvN_1x1_1a
   int j;
   const int lda2 = lda<<1, N2 = N<<1;

   #ifdef Conj_
      #define axpycj Mjoin(PATL,axpyConj)
      Mjoin(PATL,axpbyConj)(M, X, A, 1, beta, Y, 1);
   #else
      #define axpycj Mjoin(PATL,axpy)
      Mjoin(PATL,axpby)(M, X, A, 1, beta, Y, 1);
   #endif
   if (N != 1)
   {
      A += lda2;
      X += 2;
      for (j=N-1; j; j--, A += lda2, X += 2) axpycj(M, X, A, 1, Y, 1);
   }
}
@ROUT ATL_cgemvN_1x1_1
   int i, j;
   const int M2 = M<<1, N2 = N<<1;
   #if defined(BETAX) || defined(BETAXI0)
      const TYPE rbeta = *beta, ibeta = beta[1];
   #endif
   register TYPE ra, ia, rx, ix, ry, iy;

   for (i=0; i != M2; i += 2)
   {
      #ifdef BETA0
         ry = iy = ATL_rzero;
      #elif defined(BETAX)
         rx = rbeta; ix = ibeta;
         ra = Y[i]; ia = Y[i+1];
         ry = ra * rx - ia * ix;
         iy = ra * ix + ia * rx;
      #else
         ry = Y[i];
         iy = Y[i+1];
         #ifdef BETAXI0
            rx = rbeta;
            ry *= rx;
            iy *= rx;
         #endif
      #endif
      for(j=0; j != N2; j += 2)
      {
         ra = A[i+j*lda]; ia = A[i+j*lda+1];
         rx = X[j]; ix = X[j+1];
         ry += ra * rx;
         iy += ra * ix;
         ry MEQ ia * ix;
         iy PEQ ia * rx;
      }
      Y[i] = ry;
      Y[i+1] = iy;
   }
}
@ROUT ATL_cgemvN_4x2_1
   gemvN4x2(M, N, A, lda, X, beta, Y);
@ROUT ATL_cgemvN_2x2_0
   const int N2 = (N>>1)<<1, M2 = (M>>1)<<1, nr = N-N2; 
   const int incA = lda<<2, incAm = 4 - N2 * (lda<<1);
   const TYPE *x, *stX = X + (N2<<1), *A0 = A, *A1 = A + (lda<<1);
   TYPE *stY = Y + (M2<<1);
   register TYPE xr0, xi0, xr1, xi1, yr0, yi0, yr1, yi1, yyr0, yyi0, yyr1, yyi1;
   register TYPE ar00, ai00, ar10, ai10, ar01, ai01, ar11, ai11;
   register TYPE m0, m1, m2, m3;

   if (N2)
   {
      if (M2)
      {
         do
         {
            #ifdef BETA0
               yr0 = yi0 = yr1 = yi1 = yyr0 = yyi0 = yyr1 = yyi1 = ATL_rzero;
            #elif defined(BETAX)
               xr0 = *beta; xi0 = beta[1];
               ar00 = *Y; ai00 = Y[1]; ar10 = Y[2]; ai10 = Y[3];
               yyr0 = ar00 * xr0 - ai00 * xi0;
               yyi0 = ar00 * xi0 + ai00 * xr0;
               yyr1 = ar10 * xr0 - ai10 * xi0;
               yyi1 = ar10 * xi0 + ai10 * xr0;
               yr0 = yi0 = yr1 = yi1 = ATL_rzero;
            #else
               yyr0 = *Y; yyi0 = Y[1]; yyr1 = Y[2]; yyi1 = Y[3];
               yr0 = yi0 = yr1 = yi1 = ATL_rzero;
               #ifdef BETAXI0
                 xr0 = *beta;
                 yyr0 *= xr0; yyi0 *= xr0;
                 yyr1 *= xr0; yyi1 *= xr0;
               #endif
            #endif
            x = X + 4;
            ar00 = *A0; ai00 = A0[1]; ar10 = A0[2]; ai10 = A0[3]; A0 += incA;
            xr0 = *X; xi0 = X[1]; xr1 = X[2]; xi1 = X[3];
            ar01 = *A1; ai01 = A1[1]; ar11 = A1[2]; ai11 = A1[3]; A1 += incA;
            m0 = ar00 * xr0;
            m1 = ar01 * xr1;
            m2 = ar00 * xi0;
            m3 = ar01 * xi1;
            if (N2 != 2)
            {
               do
               {
                  ar00 = *A0; ar01 = *A1;
                  yr0  += m0; m0 = ai00 * xi0;
                  yyr0 += m1; m1 = ai01 * xi1;
                  yi0  += m2; m2 = ai00 * xr0; ai00 = A0[1];
                  yyi0 += m3; m3 = ai01 * xr1; ai01 = A1[1];
                  #ifndef Conj_
                     yr0  -= m0; m0 = ar10 * xr0;
                     yyr0 -= m1; m1 = ar11 * xr1;
                     yi0  += m2; m2 = ar10 * xi0; ar10 = A0[2];
                     yyi0 += m3; m3 = ar11 * xi1; ar11 = A1[2];
                  #else
                     yr0  += m0; m0 = ar10 * xr0;
                     yyr0 += m1; m1 = ar11 * xr1;
                     yi0  -= m2; m2 = ar10 * xi0; ar10 = A0[2];
                     yyi0 -= m3; m3 = ar11 * xi1; ar11 = A1[2];
                  #endif

                  yr1  += m0; m0 = ai10 * xi0; xi0 = x[1];
                  yyr1 += m1; m1 = ai11 * xi1; xi1 = x[3];
                  yi1  += m2; m2 = ai10 * xr0; xr0 = *x; 
                              ai10 = A0[3]; A0 += incA;
                  yyi1 += m3; m3 = ai11 * xr1; xr1 = x[2]; x += 4;
                              ai11 = A1[3]; A1 += incA;
                  #ifndef Conj_
                     yr1  -= m0; m0 = ar00 * xr0;
                     yyr1 -= m1; m1 = ar01 * xr1;
                     yi1  += m2; m2 = ar00 * xi0;
                     yyi1 += m3; m3 = ar01 * xi1;
                  #else
                     yr1  += m0; m0 = ar00 * xr0;
                     yyr1 += m1; m1 = ar01 * xr1;
                     yi1  -= m2; m2 = ar00 * xi0;
                     yyi1 -= m3; m3 = ar01 * xi1;
                  #endif
               }
               while (x != stX);
            }
            if (!nr)  /* drain pipe, no cleanup needed */
            {
               yr0  += m0; m0 = ai00 * xi0;
               yyr0 += m1; m1 = ai01 * xi1;
               yi0  += m2; m2 = ai00 * xr0;
               yyi0 += m3; m3 = ai01 * xr1;
               #ifndef Conj_
                  yr0  -= m0; m0 = ar10 * xr0;
                  yyr0 -= m1; m1 = ar11 * xr1;
                  yi0  += m2; m2 = ar10 * xi0;
                  yyi0 += m3; m3 = ar11 * xi1;
               #else
                  yr0  += m0; m0 = ar10 * xr0;
                  yyr0 += m1; m1 = ar11 * xr1;
                  yi0  -= m2; m2 = ar10 * xi0;
                  yyi0 -= m3; m3 = ar11 * xi1;
               #endif

               yr1  += m0; m0 = ai10 * xi0;
               yyr1 += m1; m1 = ai11 * xi1;
               yi1  += m2; m2 = ai10 * xr0;
               yyi1 += m3; m3 = ai11 * xr1;
               #ifndef Conj_
                  yr1  -= m0;
                  yyr1 -= m1;
                  yi1  += m2;
                  yyi1 += m3;
               #else
                  yr1  += m0;
                  yyr1 += m1;
                  yi1  -= m2;
                  yyi1 -= m3;
               #endif
            }
            else  /* drain pipe, and do 1 extra elt of X */
            {
               ar00 = *A0;
               yr0  += m0; m0 = ai00 * xi0;
               yyr0 += m1; m1 = ai01 * xi1;
               yi0  += m2; m2 = ai00 * xr0; ai00 = A0[1];
               yyi0 += m3; m3 = ai01 * xr1;
               #ifndef Conj_
                  yr0  -= m0; m0 = ar10 * xr0;
                  yyr0 -= m1; m1 = ar11 * xr1;
                  yi0  += m2; m2 = ar10 * xi0; ar10 = A0[2];
                  yyi0 += m3; m3 = ar11 * xi1;
               #else
                  yr0  += m0; m0 = ar10 * xr0;
                  yyr0 += m1; m1 = ar11 * xr1;
                  yi0  -= m2; m2 = ar10 * xi0; ar10 = A0[2];
                  yyi0 -= m3; m3 = ar11 * xi1;
               #endif

               yr1  += m0; m0 = ai10 * xi0; xi0 = x[1];
               yyr1 += m1; m1 = ai11 * xi1;
               yi1  += m2; m2 = ai10 * xr0; xr0 = *x; ai10 = A0[3];
               yyi1 += m3; m3 = ai11 * xr1;
               #ifndef Conj_
                  yr1  -= m0; m0 = ar00 * xr0;
                  yyr1 -= m1; m1 = ar00 * xi0;
                  yi1  += m2; m2 = ar10 * xr0;
                  yyi1 += m3; m3 = ar10 * xi0;
               #else
                  yr1  += m0; m0 = ar00 * xr0;
                  yyr1 += m1; m1 = ar00 * xi0;
                  yi1  -= m2; m2 = ar10 * xr0;
                  yyi1 -= m3; m3 = ar10 * xi0;
               #endif

               yr0 += m0; m0 = ai00 * xi0;
               yi0 += m1; m1 = ai00 * xr0;
               yr1 += m2; m2 = ai10 * xi0;
               yi1 += m3; m3 = ai10 * xr0;
               #ifndef Conj_
                  yr0 -= m0;
                  yi0 += m1;
                  yr1 -= m2;
                  yi1 += m3;
               #else
                  yr0 += m0;
                  yi0 -= m1;
                  yr1 += m2;
                  yi1 -= m3;
               #endif
            }
            A0 += incAm;
            A1 += incAm;
            yr0 += yyr0;
            yi0 += yyi0;
            yr1 += yyr1;
            yi1 += yyi1;
            *Y = yr0;
            Y[1] = yi0;
            Y[2] = yr1;
            Y[3] = yi1;
            Y += 4;
         }
         while(Y != stY);
      }
      if (M-M2) gemvMlt4(M-M2, N, A0, lda, X, beta, Y);
   }
   else gemvNlt2(M, N, A, lda, X, beta, Y);
@ROUT ATL_cgemvN_4x2_1 ATL_cgemvN_2x2_0
@beginskip
   TYPE *stY = Y + (M<<1);
   TYPE dot[2];
   const register TYPE rbeta = *beta, ibeta = beta[1];
   register TYPE ry, iy, t0;
   if (M)
   {
         do
         {
            t0 = ry = *Y;
            iy = Y[1];
            ry = ry * rbeta - iy * ibeta;
            iy = t0 * ibeta + iy * rbeta;
            Mjoin(PATL,dotu_sub)(N, X, 1, A, lda, dot);
            ry += *dot;
            iy += dot[1];
            *Y = ry;
            Y[1] = iy;
            Y += 2;
            A += 2;
         }
         while (Y != stY);
   }
@endskip
}

@ROUT ATL_gemvN_4x4_1 ATL_gemvN_4x2_0 ATL_gemvN_mm ATL_gemvN_8x32_2 @\
      ATL_gemvN_8x4_1 ATL_gemvN_16x2_1 ATL_gemvN_16x4_1 ATL_gemvN_32x4_1 @\
      ATL_gemvN_1x1_1 ATL_gemvN_1x1_1a ATL_gpmvN_32x4_1 ATL_gpmvN_1x1_1a
#include "atlas_misc.h"
#include "atlas_level1.h"
#include "atlas_level2.h"
#include "atlas_lvl2.h"
@ROUT ATL_gemvN_8x4_1 `#include "atlas_prefetch.h"`
@ROUT ATL_gemvN_mm `#include "atlas_lvl3.h"`

@ROUT ATL_gpmvN_32x4_1 ATL_gpmvN_1x1_1a
#ifdef TREAL
   #ifdef Lower_
      #define MpIncInc(inc_) (inc_)--
   #else
      #define MpIncInc(inc_) (inc_)++
   #endif
#else
   #ifdef Lower_
      #define MpIncInc(inc_) (inc_) -= 2;
   #else
      #define MpIncInc(inc_) (inc_) += 2;
   #endif
#endif
@ROUT ATL_gemvN_8x32_2
#define Yass(y_) (y_) += 
@beginskip
#ifdef BETA0
   #define Yass(y_) (y_) = 
#elif defined(BETAX)
   #define Yass(y_) (y_) = (y_)*beta +
#else
   #define Yass(y_) (y_) += 
#endif
@endskip

#ifdef BETA1
static void gemv8x32(const int M, const int N, const TYPE *A, const int lda,
                     const TYPE *X, const SCALAR beta, TYPE *Y)
/*
 * Try to let compiler do all the work
 */
{
   const TYPE *A0=A, *A1=A+lda, *A2=A1+lda, *A3=A2+lda;
   const TYPE *A4=A3+lda, *A5=A4+lda, *A6=A5+lda, *A7=A6+lda;
   const TYPE *A8=A7+lda, *A9=A8+lda, *A10=A9+lda, *A11=A10+lda;
   const TYPE *A12=A11+lda, *A13=A12+lda, *A14=A13+lda, *A15=A14+lda;
   const TYPE *A16=A15+lda, *A17=A16+lda, *A18=A17+lda, *A19=A18+lda;
   const TYPE *A20=A19+lda, *A21=A20+lda, *A22=A21+lda, *A23=A22+lda;
   const TYPE *A24=A23+lda, *A25=A24+lda, *A26=A25+lda, *A27=A26+lda;
   const TYPE *A28=A27+lda, *A29=A28+lda, *A30=A29+lda, *A31=A30+lda;
   const TYPE x0=*X, x1=X[1], x2=X[2], x3=X[3];
   const TYPE x4=X[4], x5=X[5], x6=X[6], x7=X[7];
   const TYPE x8=X[8], x9=X[9], x10=X[10], x11=X[11];
   const TYPE x12=X[12], x13=X[13], x14=X[14], x15=X[15];
   const TYPE x16=X[16], x17=X[17], x18=X[18], x19=X[19];
   const TYPE x20=X[20], x21=X[21], x22=X[22], x23=X[23];
   const TYPE x24=X[24], x25=X[25], x26=X[26], x27=X[27];
   const TYPE x28=X[28], x29=X[29], x30=X[30], x31=X[31];
   TYPE *stY = Y + ((M>>3)<<3);

   ATL_assert(M >= 8 && (N == 32));
   do
   {
      Yass(*Y) *A0 * x0 + *A1 * x1 + *A2 * x2 + *A3 * x3 +
               *A4 * x4 + *A5 * x5 + *A6 * x6 + *A7 * x7 +
               *A8 * x8 + *A9 * x9 + *A10 * x10 + *A11 * x11 +
               *A12 * x12 + *A13 * x13 + *A14 * x14 + *A15 * x15 +
               *A16 * x16 + *A17 * x17 + *A18 * x18 + *A19 * x19 +
               *A20 * x20 + *A21 * x21 + *A22 * x22 + *A23 * x23 +
               *A24 * x24 + *A25 * x25 + *A26 * x26 + *A27 * x27 +
               *A28 * x28 + *A29 * x29 + *A30 * x30 + *A31 * x31;
   @whiledef r 7 6 5 4 3 2 1
      Yass(Y[@(r)]) A0[@(r)]*x0 + A1[@(r)]*x1 + A2[@(r)]*x2 + A3[@(r)]*x3 +
                 A4[@(r)]*x4 + A5[@(r)]*x5 + A6[@(r)]*x6 + A7[@(r)]*x7 +
                 A8[@(r)]*x8 + A9[@(r)]*x9 + A10[@(r)]*x10 + A11[@(r)]*x11 +
                 A12[@(r)]*x12 + A13[@(r)]*x13 + A14[@(r)]*x14 + A15[@(r)]*x15 +
                 A16[@(r)]*x16 + A17[@(r)]*x17 + A18[@(r)]*x18 + A19[@(r)]*x19 +
                 A20[@(r)]*x20 + A21[@(r)]*x21 + A22[@(r)]*x22 + A23[@(r)]*x23 +
                 A24[@(r)]*x24 + A25[@(r)]*x25 + A26[@(r)]*x26 + A27[@(r)]*x27 +
                 A28[@(r)]*x28 + A29[@(r)]*x29 + A30[@(r)]*x30 + A31[@(r)]*x31;
   @endwhile
   @multidef col 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16
   @whiledef col 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0
      A@(col) += 8;
   @endwhile
      Y += 8;
   }
   while (Y != stY);
}
static void gemv1x32(const int M, const int N, const TYPE *A, const int lda,
                     const TYPE *X, const SCALAR beta, TYPE *Y)
/*
 * Try to let compiler do all the work
 */
{
   const TYPE *A0=A, *A1=A+lda, *A2=A1+lda, *A3=A2+lda;
   const TYPE *A4=A3+lda, *A5=A4+lda, *A6=A5+lda, *A7=A6+lda;
   const TYPE *A8=A7+lda, *A9=A8+lda, *A10=A9+lda, *A11=A10+lda;
   const TYPE *A12=A11+lda, *A13=A12+lda, *A14=A13+lda, *A15=A14+lda;
   const TYPE *A16=A15+lda, *A17=A16+lda, *A18=A17+lda, *A19=A18+lda;
   const TYPE *A20=A19+lda, *A21=A20+lda, *A22=A21+lda, *A23=A22+lda;
   const TYPE *A24=A23+lda, *A25=A24+lda, *A26=A25+lda, *A27=A26+lda;
   const TYPE *A28=A27+lda, *A29=A28+lda, *A30=A29+lda, *A31=A30+lda;
   const TYPE x0=*X, x1=X[1], x2=X[2], x3=X[3];
   const TYPE x4=X[4], x5=X[5], x6=X[6], x7=X[7];
   const TYPE x8=X[8], x9=X[9], x10=X[10], x11=X[11];
   const TYPE x12=X[12], x13=X[13], x14=X[14], x15=X[15];
   const TYPE x16=X[16], x17=X[17], x18=X[18], x19=X[19];
   const TYPE x20=X[20], x21=X[21], x22=X[22], x23=X[23];
   const TYPE x24=X[24], x25=X[25], x26=X[26], x27=X[27];
   const TYPE x28=X[28], x29=X[29], x30=X[30], x31=X[31];
   TYPE *stY = Y + M;

   ATL_assert(N == 32);
   do
   {
      Yass(*Y) *A0 * x0 + *A1 * x1 + *A2 * x2 + *A3 * x3 +
               *A4 * x4 + *A5 * x5 + *A6 * x6 + *A7 * x7 +
               *A8 * x8 + *A9 * x9 + *A10 * x10 + *A11 * x11 +
               *A12 * x12 + *A13 * x13 + *A14 * x14 + *A15 * x15 +
               *A16 * x16 + *A17 * x17 + *A18 * x18 + *A19 * x19 +
               *A20 * x20 + *A21 * x21 + *A22 * x22 + *A23 * x23 +
               *A24 * x24 + *A25 * x25 + *A26 * x26 + *A27 * x27 +
               *A28 * x28 + *A29 * x29 + *A30 * x30 + *A31 * x31;
      Y++;
   @multidef col 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16
   @whiledef col 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0
      A@(col)++;
   @endwhile
   }
   while (Y != stY);
}
static void gemv8x16(const int M, const int N, const TYPE *A, const int lda,
                     const TYPE *X, const SCALAR beta, TYPE *Y)
/*
 * Try to let compiler do all the work
 */
{
   const TYPE *A0=A, *A1=A+lda, *A2=A1+lda, *A3=A2+lda;
   const TYPE *A4=A3+lda, *A5=A4+lda, *A6=A5+lda, *A7=A6+lda;
   const TYPE *A8=A7+lda, *A9=A8+lda, *A10=A9+lda, *A11=A10+lda;
   const TYPE *A12=A11+lda, *A13=A12+lda, *A14=A13+lda, *A15=A14+lda;
   const TYPE x0=*X, x1=X[1], x2=X[2], x3=X[3];
   const TYPE x4=X[4], x5=X[5], x6=X[6], x7=X[7];
   const TYPE x8=X[8], x9=X[9], x10=X[10], x11=X[11];
   const TYPE x12=X[12], x13=X[13], x14=X[14], x15=X[15];
   TYPE *stY = Y + ((M>>3)<<3);

   ATL_assert(M >= 8 && (N == 16));
   do
   {
      Yass(*Y) *A0 * x0 + *A1 * x1 + *A2 * x2 + *A3 * x3 +
               *A4 * x4 + *A5 * x5 + *A6 * x6 + *A7 * x7 +
               *A8 * x8 + *A9 * x9 + *A10 * x10 + *A11 * x11 +
               *A12 * x12 + *A13 * x13 + *A14 * x14 + *A15 * x15;
   @whiledef r 7 6 5 4 3 2 1
      Yass(Y[@(r)]) A0[@(r)]*x0 + A1[@(r)]*x1 + A2[@(r)]*x2 + A3[@(r)]*x3 +
                 A4[@(r)]*x4 + A5[@(r)]*x5 + A6[@(r)]*x6 + A7[@(r)]*x7 +
                 A8[@(r)]*x8 + A9[@(r)]*x9 + A10[@(r)]*x10 + A11[@(r)]*x11 +
                 A12[@(r)]*x12 + A13[@(r)]*x13 + A14[@(r)]*x14 + A15[@(r)]*x15;
   @endwhile
   @whiledef col 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0
      A@(col) += 8;
   @endwhile
      Y += 8;
   }
   while (Y != stY);
}
static void gemv8x8(const int M, const int N, const TYPE *A, const int lda,
                    const TYPE *X, const SCALAR beta, TYPE *Y)
/*
 * Try to let compiler do all the work
 */
{
   const TYPE *A0=A, *A1=A+lda, *A2=A1+lda, *A3=A2+lda;
   const TYPE *A4=A3+lda, *A5=A4+lda, *A6=A5+lda, *A7=A6+lda;
   const TYPE x0=*X, x1=X[1], x2=X[2], x3=X[3];
   const TYPE x4=X[4], x5=X[5], x6=X[6], x7=X[7];
   TYPE *stY = Y + ((M>>3)<<3);

   ATL_assert(M >= 8 && (N == 8));
   do
   {
      Yass(*Y) *A0 * x0 + *A1 * x1 + *A2 * x2 + *A3 * x3 +
               *A4 * x4 + *A5 * x5 + *A6 * x6 + *A7 * x7;
   @whiledef r 7 6 5 4 3 2 1
      Yass(Y[@(r)]) A0[@(r)]*x0 + A1[@(r)]*x1 + A2[@(r)]*x2 + A3[@(r)]*x3 +
                 A4[@(r)]*x4 + A5[@(r)]*x5 + A6[@(r)]*x6 + A7[@(r)]*x7;
   @endwhile
   @whiledef col 7  6  5  4  3  2  1  0
      A@(col) += 8;
   @endwhile
      Y += 8;
   }
   while (Y != stY);
}

static void gemv8x4(const int M, const int N, const TYPE *A, const int lda,
                    const TYPE *X, const SCALAR beta, TYPE *Y)
/*
 * Try to let compiler do all the work
 */
{
   const TYPE *A0=A, *A1=A+lda, *A2=A1+lda, *A3=A2+lda;
   const TYPE x0=*X, x1=X[1], x2=X[2], x3=X[3];
   TYPE *stY = Y + ((M>>3)<<3);

   ATL_assert(M >= 8 && (N == 4));
   do
   {
      Yass(*Y) *A0 * x0 + *A1 * x1 + *A2 * x2 + *A3 * x3;
   @whiledef r 7 6 5 4 3 2 1
      Yass(Y[@(r)]) A0[@(r)]*x0 + A1[@(r)]*x1 + A2[@(r)]*x2 + A3[@(r)]*x3;
   @endwhile
   @whiledef col 3  2  1  0
      A@(col) += 8;
   @endwhile
      Y += 8;
   }
   while (Y != stY);
}

static void gemv1x1(const int M, const int N, const TYPE *A, const int lda,
                    const TYPE *X, const SCALAR beta, TYPE *Y)
{
   int i;
   for (i=0; i < M; i++) Y[i] += Mjoin(PATL,dot)(N, X, 1, A+i, lda);
}
#endif

static void gemv(const int M, const int N, const TYPE *A, const int lda,
                 const TYPE *X, const SCALAR beta, TYPE *Y)
{
#ifdef BETA0
   Mjoin(PATL,zero)(M, Y, 1);
   Mjoin(PATL,gemvN_a1_x1_b1_y1)(M, N, A, lda, X, beta, Y);
#elif defined(BETAX)
   Mjoin(PATL,scal)(M, beta, Y, 1);
   Mjoin(PATL,gemvN_a1_x1_b1_y1)(M, N, A, lda, X, beta, Y);
#else
   int i, n;
   const int n32 = N>>5, M8 = (M>>3)<<3, mr = M-M8, incA = lda<<5;

   #ifndef BETA1
      ATL_assert(beta == ATL_rone);
   #endif
   for (i=n32; i; i--)
   {
      if (M8) gemv8x32(M8, 32, A, lda, X, beta, Y);
      if (mr) gemv1x32(mr, 32, A+M8, lda, X, beta, Y+M8);
      A += incA;
      X += 32;
   }
   n = N - (n32<<5);
   if (n >= 16)
   {
      n -= 16;
      if (M8) gemv8x16(M8, 16, A, lda, X, beta, Y);
      if (mr) gemv1x1(mr, 16, A+M8, lda, X, beta, Y+M8);
      A += incA>>1;
      X += 16;
   }
   if (n >= 8)
   {
      n -= 8;
      if (M8) gemv8x8(M8, 8, A, lda, X, beta, Y);
      if (mr) gemv1x1(mr, 8, A+M8, lda, X, beta, Y+M8);
      A += incA>>2;
      X += 8;
   }
   if (n >= 4)
   {
      n -= 4;
      if (M8) gemv8x4(M8, 4, A, lda, X, beta, Y);
      if (mr) gemv1x1(mr, 4, A+M8, lda, X, beta, Y+M8);
      A += incA>>3;
      X += 4;
   }
   if (n) gemv1x1(M, n, A, lda, X, beta, Y);
#endif
}

@ROUT ATL_gemvN_8x4_1 ATL_gemvN_4x4_1 ATL_gemvN_16x2_1 ATL_gemvN_16x4_1 @\
      ATL_gemvN_32x4_1 ATL_gemvN_4x2_0 ATL_gpmvN_32x4_1
@ROUT @push

static void gemvMlt8(const int M, const int N, const TYPE *A, const int lda,
                     const TYPE *X, const SCALAR beta, TYPE *Y);
static void gemvNle4(const int M, const int N, const TYPE *A, const int lda,
                     const TYPE *X, const SCALAR beta, TYPE *Y);
#ifdef BETA0
   #define Yget(y_, yp_, bet_) (y_) = ATL_rzero
#elif defined BETAX
   #define Yget(y_, yp_, bet_) (y_) = (yp_) * (bet_)
#else
   #define Yget(y_, yp_, bet_) (y_) = (yp_)
#endif
static void gemvN32x4(const int M, const int N, const TYPE *A, const int lda,
                      const TYPE *x, const SCALAR beta0, TYPE *y)
/*
 * rank-4 daxpy based NoTrans gemv
 */
{
   const int M16 = (M>>4)<<4;
   TYPE *stY = y + M16 - 32;
@ROUT - ATL_gpmvN_32x4_1
   const TYPE *A0 = A, *A1 = A+lda, *A2 = A1 + lda, *A3 = A2 + lda;
@ROUT ATL_gpmvN_32x4_1
   #ifdef Upper_
      const TYPE *A0 = A, *A1 = A+lda, *A2 = A1 + lda+1, *A3 = A2 + lda+2;
   #else
      const TYPE *A0 = A, *A1 = A+lda, *A2 = A1 + lda-1, *A3 = A2 + lda-2;
   #endif
@ROUT @peek
   register TYPE z0, z1, z2, z3, z4, z5, z6, z7;
   register TYPE y0, y1, y2, y3, y4, y5, y6, y7;
   const register TYPE x0 = *x, x1 = x[1], x2 = x[2], x3 = x[3];
   #ifdef BETAX
      const register TYPE beta = beta0;
   #else
      #define beta beta0
   #endif

   ATL_assert(N == 4);
   if (M16 >= 32)
   {
      #ifdef BETA0
         y0 = y1 = y2 = y3 = y4 = y5 = y6 = y7 = ATL_rzero;
      #else
         y0 = *y;   y1 = y[1]; y2 = y[2]; y3 = y[3]; 
         y4 = y[4]; y5 = y[5]; y6 = y[6]; y7 = y[7]; 
         #ifdef BETAX
            y0 *= beta; y1 *= beta; y2 *= beta; y3 *= beta;
            y4 *= beta; y5 *= beta; y6 *= beta; y7 *= beta;
         #endif
      #endif
      y0 += x0 * *A0;   Yget(z0, y[8], beta);   
      y1 += x1 * A1[1];
      y2 += x2 * A2[2]; Yget(z1, y[9], beta);
      y3 += x3 * A3[3];
      y4 += x0 * A0[4]; Yget(z2, y[10], beta);
      y5 += x1 * A1[5];
      y6 += x2 * A2[6]; Yget(z3, y[11], beta);
      y7 += x3 * A3[7];

      y0 += x1 * *A1;   Yget(z4, y[12], beta);
      y1 += x2 * A2[1];
      y2 += x3 * A3[2]; Yget(z5, y[13], beta);
      y3 += x0 * A0[3];
      y4 += x1 * A1[4]; Yget(z6, y[14], beta);
      y5 += x2 * A2[5];
      y6 += x3 * A3[6]; Yget(z7, y[15], beta);
      y7 += x0 * A0[7];

      y0 += x2 * *A2;
      y1 += x3 * A3[1];
      y2 += x0 * A0[2];
      y3 += x1 * A1[3];
      y4 += x2 * A2[4];
      y5 += x3 * A3[5];
      y6 += x0 * A0[6];
      y7 += x1 * A1[7];

      y0 += x3 * *A3; 
      y1 += x0 * A0[1];
      y2 += x1 * A1[2];
      y3 += x2 * A2[3];
      y4 += x3 * A3[4];
      y5 += x0 * A0[5];
      y6 += x1 * A1[6];
      y7 += x2 * A2[7];

      z0 += x0 * A0[8]; *y = y0;
      z1 += x1 * A1[9]; 
      z2 += x2 * A2[10]; y[1] = y1;
      z3 += x3 * A3[11];
      z4 += x0 * A0[12]; y[2] = y2;
      z5 += x1 * A1[13];
      z6 += x2 * A2[14]; y[3] = y3;
      z7 += x3 * A3[15];

      z0 += x1 * A1[8]; y[4] = y4;
      z1 += x2 * A2[9];
      z2 += x3 * A3[10]; y[5] = y5;
      z3 += x0 * A0[11];
      z4 += x1 * A1[12]; y[6] = y6;
      z5 += x2 * A2[13];
      z6 += x3 * A3[14]; y[7] = y7;
      z7 += x0 * A0[15];

      z0 += x2 * A2[8];  Yget(y0, y[16], beta);
      z1 += x3 * A3[ 9];
      z2 += x0 * A0[10]; Yget(y1, y[17], beta);
      z3 += x1 * A1[11];
      z4 += x2 * A2[12]; Yget(y2, y[18], beta);
      z5 += x3 * A3[13];
      z6 += x0 * A0[14]; Yget(y3, y[19], beta);
      z7 += x1 * A1[15];

      z0 += x3 * A3[8];  Yget(y4, y[20], beta);
      z1 += x0 * A0[9];
      z2 += x1 * A1[10]; Yget(y5, y[21], beta);
      z3 += x2 * A2[11];
      z4 += x3 * A3[12]; Yget(y6, y[22], beta); A3 += 16;
      z5 += x0 * A0[13];                        A0 += 16;
      z6 += x1 * A1[14]; Yget(y7, y[23], beta); A1 += 16;
      z7 += x2 * A2[15];                        A2 += 16;
      if (M16 != 32)
      {
         do
         {
            y0 += x0 * *A0;   y[8] = z0;
            y1 += x1 * A1[1];
            y2 += x2 * A2[2]; y[9] = z1;
            y3 += x3 * A3[3];
            y4 += x0 * A0[4]; y[10] = z2;
            y5 += x1 * A1[5];
            y6 += x2 * A2[6]; y[11] = z3;
            y7 += x3 * A3[7];
   
            y0 += x1 * *A1;   y[12] = z4;
            y1 += x2 * A2[1];
            y2 += x3 * A3[2]; y[13] = z5;
            y3 += x0 * A0[3];
            y4 += x1 * A1[4]; y[14] = z6;
            y5 += x2 * A2[5];
            y6 += x3 * A3[6]; y[15] = z7; y += 16;
            y7 += x0 * A0[7];
   
            y0 += x2 * *A2;   Yget(z0, y[8], beta);
            y1 += x3 * A3[1];
            y2 += x0 * A0[2]; Yget(z1, y[9], beta);
            y3 += x1 * A1[3];
            y4 += x2 * A2[4]; Yget(z2, y[10], beta);
            y5 += x3 * A3[5];
            y6 += x0 * A0[6]; Yget(z3, y[11], beta);
            y7 += x1 * A1[7];
   
            y0 += x3 * *A3;   Yget(z4, y[12], beta);
            y1 += x0 * A0[1];
            y2 += x1 * A1[2]; Yget(z5, y[13], beta);
            y3 += x2 * A2[3];
            y4 += x3 * A3[4]; Yget(z6, y[14], beta);
            y5 += x0 * A0[5];
            y6 += x1 * A1[6]; Yget(z7, y[15], beta);
            y7 += x2 * A2[7];
   
            z0 += x0 * A0[8];  *y = y0;
            z1 += x1 * A1[9];
            z2 += x2 * A2[10]; y[1] = y1;
            z3 += x3 * A3[11];
            z4 += x0 * A0[12]; y[2] = y2;
            z5 += x1 * A1[13];
            z6 += x2 * A2[14]; y[3] = y3;
            z7 += x3 * A3[15];
   
            z0 += x1 * A1[8]; y[4] = y4;
            z1 += x2 * A2[9];
            z2 += x3 * A3[10]; y[5] = y5;
            z3 += x0 * A0[11];
            z4 += x1 * A1[12]; y[6] = y6;
            z5 += x2 * A2[13];
            z6 += x3 * A3[14]; y[7] = y7;
            z7 += x0 * A0[15];
   
            z0 += x2 * A2[8];  Yget(y0, y[16], beta);
            z1 += x3 * A3[ 9];
            z2 += x0 * A0[10]; Yget(y1, y[17], beta);
            z3 += x1 * A1[11];
            z4 += x2 * A2[12]; Yget(y2, y[18], beta);
            z5 += x3 * A3[13];
            z6 += x0 * A0[14]; Yget(y3, y[19], beta);
            z7 += x1 * A1[15];
   
            z0 += x3 * A3[8];  Yget(y4, y[20], beta);
            z1 += x0 * A0[9];
            z2 += x1 * A1[10]; Yget(y5, y[21], beta);
            z3 += x2 * A2[11];
            z4 += x3 * A3[12]; Yget(y6, y[22], beta);  A3 += 16;
            z5 += x0 * A0[13];                         A0 += 16;
            z6 += x1 * A1[14]; Yget(y7, y[23], beta);  A1 += 16;
            z7 += x2 * A2[15];                         A2 += 16;
         }
         while (y != stY);
      }
      y0 += x0 * *A0;   y[8] = z0;
      y1 += x1 * A1[1];
      y2 += x2 * A2[2]; y[9] = z1;
      y3 += x3 * A3[3];
      y4 += x0 * A0[4]; y[10] = z2;
      y5 += x1 * A1[5];
      y6 += x2 * A2[6]; y[11] = z3;
      y7 += x3 * A3[7];

      y0 += x1 * *A1;   y[12] = z4;
      y1 += x2 * A2[1];
      y2 += x3 * A3[2]; y[13] = z5;
      y3 += x0 * A0[3];
      y4 += x1 * A1[4]; y[14] = z6;
      y5 += x2 * A2[5];
      y6 += x3 * A3[6]; y[15] = z7; y += 16;
      y7 += x0 * A0[7];
   
      y0 += x2 * *A2;   Yget(z0, y[8], beta);
      y1 += x3 * A3[1];
      y2 += x0 * A0[2]; Yget(z1, y[9], beta);
      y3 += x1 * A1[3];
      y4 += x2 * A2[4]; Yget(z2, y[10], beta);
      y5 += x3 * A3[5];
      y6 += x0 * A0[6]; Yget(z3, y[11], beta);
      y7 += x1 * A1[7];

      y0 += x3 * *A3;   Yget(z4, y[12], beta);
      y1 += x0 * A0[1];
      y2 += x1 * A1[2]; Yget(z5, y[13], beta);
      y3 += x2 * A2[3];
      y4 += x3 * A3[4]; Yget(z6, y[14], beta);
      y5 += x0 * A0[5];
      y6 += x1 * A1[6]; Yget(z7, y[15], beta);
      y7 += x2 * A2[7];

      z0 += x0 * A0[8];  *y = y0;
      z1 += x1 * A1[9];
      z2 += x2 * A2[10]; y[1] = y1;
      z3 += x3 * A3[11];
      z4 += x0 * A0[12]; y[2] = y2;
      z5 += x1 * A1[13];
      z6 += x2 * A2[14]; y[3] = y3;
      z7 += x3 * A3[15];

      z0 += x1 * A1[8]; y[4] = y4;
      z1 += x2 * A2[9];
      z2 += x3 * A3[10]; y[5] = y5;
      z3 += x0 * A0[11];
      z4 += x1 * A1[12]; y[6] = y6;
      z5 += x2 * A2[13];
      z6 += x3 * A3[14]; y[7] = y7;
      z7 += x0 * A0[15];

      z0 += x2 * A2[8];
      z1 += x3 * A3[ 9];
      z2 += x0 * A0[10];
      z3 += x1 * A1[11];
      z4 += x2 * A2[12];
      z5 += x3 * A3[13];
      z6 += x0 * A0[14];
      z7 += x1 * A1[15];

      z0 += x3 * A3[8];
      z1 += x0 * A0[9];
      z2 += x1 * A1[10];
      z3 += x2 * A2[11];
      z4 += x3 * A3[12];
      z5 += x0 * A0[13];
      z6 += x1 * A1[14];
      z7 += x2 * A2[15];
      y[8] = z0;
      y[9] = z1;
      y[10] = z2;
      y[11] = z3;
      y[12] = z4;
      y[13] = z5;
      y[14] = z6;
      y[15] = z7;
      if (M-M16) gemvMlt8(M-M16, N, A0+16, lda, x, beta, y+16);
   }
   else if (N) gemvMlt8(M, N, A, lda, x, beta, y);
}

static void gemv32x4(const int M, const int N, const TYPE *A, const int lda,
                     const TYPE *X, const SCALAR beta, TYPE *Y)
{
   #ifdef BETA1
      int j;
   #endif
@ROUT - ATL_gpmvN_32x4_1
   const int incA = lda<<2;
@ROUT ATL_gpmvN_32x4_1
   int incA = (lda<<2) - 6;
@ROUT @peek

   if (N >= 4)
   {
      if (M >= 32)
      {
         #ifdef BETA1
@ROUT - ATL_gpmvN_32x4_1
            for (j=(N>>2); j; j--, A += incA, X += 4)
@ROUT ATL_gpmvN_32x4_1
            for (j=(N>>2); j; j--, A += incA, incA -= 6, X += 4)
@ROUT @peek
               gemvN32x4(M, 4, A, lda, X, ATL_rone, Y);
            if ( (j = N-((N>>2)<<2)) ) gemvNle4(M, j, A, lda, X, ATL_rone, Y);
         #else
            gemvN32x4(M, 4, A, lda, X, beta, Y);
            if (N != 4)
               Mjoin(PATL,gemvN_a1_x1_b1_y1)
                  (M, N-4, ATL_rone, A+incA, lda, X+4, 1, ATL_rone, Y, 1);
         #endif
      }
      else gemvMlt8(M, N, A, lda, X, beta, Y);
   }
   else if (M) gemvNle4(M, N, A, lda, X, beta, Y);
}

@ROUT - ATL_gpmvN_32x4_1
static void gemvMlt8(const int M, const int N, const TYPE *A, const int lda,
                     const TYPE *X, const SCALAR beta, TYPE *Y)
{
   int i;
   register TYPE y0;
   for (i=M; i; i--)
   {
      #ifdef BETA0
         y0 = Mjoin(PATL,dot)(N, A, lda, X, 1);
      #else
         Yget(y0, *Y, beta);
         y0 += Mjoin(PATL,dot)(N, A, lda, X, 1);
      #endif
      *Y++ = y0;
      A++;
   }
}
@ROUT ATL_gpmvN_32x4_1
static void gpmvM8(const int N, const TYPE *A, const int lda, const TYPE *X,
                   const SCALAR beta, TYPE *Y)
{
   #ifdef Upper_
      register int incA = lda-1;
   #else
      register int incA = lda+1;
   #endif
   #ifdef BETA0
      register TYPE y0=ATL_rzero, y1=ATL_rzero, y2=ATL_rzero, y3=ATL_rzero;
      register TYPE y4=ATL_rzero, y5=ATL_rzero, y6=ATL_rzero, y7=ATL_rzero;
   #else
      register TYPE y0 = *Y, y1 = Y[1], y2 = Y[2], y3 = Y[3];
      register TYPE y4 = Y[4], y5 = Y[5], y6 = Y[6], y7 = Y[7];
   #endif
      register TYPE x0;
   const TYPE *stX = X + N;

   #ifdef BETA1
      x0 = beta;
      y0 *= x0; y1 *= x0; y2 *= x0; y3 *= x0;
      y4 *= x0; y5 *= x0; y6 *= x0; y7 *= x0;
   #endif
   do
   {
      x0 = *X;
      y0 += *A * x0;
      y1 += A[1] * x0; MpIncInc(incA);
      y2 += A[2] * x0;
      y3 += A[3] * x0;
      y4 += A[4] * x0; X++;
      y5 += A[5] * x0;
      y6 += A[6] * x0;
      y7 += A[7] * x0;
      A += incA;
   }
   while (X != stX);
   *Y = y0;
   Y[1] = y1;
   Y[2] = y2;
   Y[3] = y3;
   Y[4] = y4;
   Y[5] = y5;
   Y[6] = y6;
   Y[7] = y7;
}
static void gpmvM4(const int N, const TYPE *A, const int lda, const TYPE *X,
                   const SCALAR beta, TYPE *Y)
{
   #ifdef Upper_
      register int incA = lda-1;
   #else
      register int incA = lda+1;
   #endif
   #ifdef BETA0
      register TYPE y0=ATL_rzero, y1=ATL_rzero, y2=ATL_rzero, y3=ATL_rzero, x0;
   #else
      register TYPE y0 = *Y, y1 = Y[1], y2 = Y[2], y3 = Y[3], x0;
   #endif
   const TYPE *stX = X + N;

   #ifndef BETA0
      #ifndef BETA1
         x0 = beta;
         y0 *= x0; y1 *= x0; y2 *= x0; y3 *= x0;
      #endif
   #endif
   do
   {
      x0 = *X;
      y0 += *A * x0; MpIncInc(incA);
      y1 += A[1] * x0;
      y2 += A[2] * x0; X++;
      y3 += A[3] * x0;
      A += incA;
   }
   while (X != stX);
   *Y = y0;
   Y[1] = y1;
   Y[2] = y2;
   Y[3] = y3;
}
static void gpmvM2(const int N, const TYPE *A, const int lda, const TYPE *X,
                   const SCALAR beta, TYPE *Y)
{
   #ifdef Upper_
      register int incA = lda-1;
   #else
      register int incA = lda+1;
   #endif
   #ifdef BETA0
      register TYPE y0=ATL_rzero, y1=ATL_rzero, x0;
   #else
      register TYPE y0 = *Y, y1 = Y[1], x0;
   #endif
   const TYPE *stX = X + N;

   #ifndef BETA0
      y0 = *Y; y1 = Y[1];
      #ifndef BETA1
         x0 = beta;
         y0 *= x0; y1 *= x0;
      #endif
   #endif
   do
   {
      x0 = *X;
      y0 += *A * x0;  MpIncInc(incA);
      y1 += A[1] * x0; X++;
      A += incA;
   }
   while (X != stX);
   *Y = y0;
   Y[1] = y1;
}
static void gpmvM1(const int N, const TYPE *A, const int lda, const TYPE *X,
                   const SCALAR beta, TYPE *Y)
{
   #ifdef Upper_
      register int incA = lda-1;
   #else
      register int incA = lda+1;
   #endif
   #ifdef BETA0
      register TYPE y0=ATL_rzero;
   #else
      register TYPE y0 = *Y;
   #endif

   #ifdef BETAX
      y0 *= beta;
   #endif
   do
   {
      y0 += *X * *A;
      #ifdef Upper_
         A += incA++;
      #else
         A += incA--;
      #endif
   }
   while (++X != stX);
}
static void gemvMlt8(const int M, const int N, const TYPE *A, const int lda,
                     const TYPE *X, const SCALAR beta, TYPE *Y)
/*
 * Name is wrong, M _is_ small, but sometimes larger than 8
 */
{
   register int m = M;

   if (m>>3)
   {
      TYPE *stY;
      m = (M>>3)<<3;
      stY = Y + m;
      do
      {
         gpmvM8(N, A, lda, X, beta, Y);
         Y += 8;
         A += 8;
      }
      while (Y != stY);
      m = M - m;
   }
   if (m>>2)
   {
      gpmvM4(N, A, lda, X, beta, Y);
      m -= 4;
      Y += 4;
      A += 4;
   }
   if (m>>1)
   {
      gpmvM2(N, A, lda, X, beta, Y);
      m -= 2;
      Y += 2;
      A += 2;
   }
   if (m) gpmvM1(N, A, lda, X, beta, Y);
}
@ROUT @peek
static void gemvNle4(const int M, const int N, const TYPE *A, const int lda,
                     const TYPE *X, const SCALAR beta, TYPE *Y)
{
   int i;
@ROUT - ATL_gpmvN_32x4_1
   const TYPE *A0 = A, *A1 = A+lda, *A2 = A1+lda, *A3 = A2+lda;
@ROUT ATL_gpmvN_32x4_1
   #ifdef Lower_
      const TYPE *A0 = A, *A1 = A+lda, *A2 = A1+lda-1, *A3 = A2+lda-2;
   #else
      const TYPE *A0 = A, *A1 = A+lda, *A2 = A1+lda+1, *A3 = A2+lda+2;
   #endif
@ROUT @peek
   register TYPE x0, x1, x2, x3;
   #ifdef BETAX
      const register TYPE bet=beta;
   #endif

   switch(N)
   {
   case 1:
      #if defined(BETA0)
         Mjoin(PATL,cpsc)(M, *X, A, 1, Y, 1);
      #elif defined(BETAX)
         Mjoin(PATL,axpby)(M, *X, A, 1, beta, Y, 1);
      #else
         Mjoin(PATL,axpy)(M, *X, A, 1, Y, 1);
      #endif
      break;
   case 2:
      x0 = *X; x1 = X[1]; 
      for (i=0; i != M; i++)
      #ifdef BETA0
         Y[i] = A0[i] * x0 + A1[i] * x1;
      #elif defined(BETAX)
         Y[i] = Y[i]*bet + A0[i] * x0 + A1[i] * x1;
      #else
         Y[i] += A0[i] * x0 + A1[i] * x1;
      #endif
      break;
   case 3:
      x0 = *X; x1 = X[1]; x2 = X[2];
      for (i=0; i != M; i++)
      #ifdef BETA0
         Y[i] = A0[i] * x0 + A1[i] * x1 + A2[i] * x2;
      #elif defined(BETAX)
         Y[i] = Y[i]*bet + A0[i] * x0 + A1[i] * x1 + A2[i] * x2;
      #else
         Y[i] += A0[i] * x0 + A1[i] * x1 + A2[i] * x2;
      #endif
      break;
   case 4:
      if (M >= 32) gemv32x4(M, 4, A, lda, X, beta, Y);
      else
      {
         x0 = *X; x1 = X[1]; x2 = X[2]; x3 = X[3];
         for (i=0; i != M; i++)
         #ifdef BETA0
            Y[i] = A0[i] * x0 + A1[i] * x1 + A2[i] * x2 + A3[i] * x3;
         #elif defined(BETAX)
            Y[i] = Y[i]*bet + A0[i] * x0 + A1[i] * x1 + A2[i] * x2 + A3[i] * x3;
         #else
            Y[i] += A0[i] * x0 + A1[i] * x1 + A2[i] * x2 + A3[i] * x3;
         #endif
      }
      break;
   default:
      ATL_assert(!N);
   }
}

@ROUT ATL_gemvN_16x4_1
static void gemv16x4(const int M, const int N, const TYPE *A, const int lda,
                     const TYPE *X, const SCALAR beta, TYPE *Y)
/*
 * 16x4 with feeble prefetch
 */
{
   int j;
   const int M16 = (M>>4)<<4, N4 = (N>>2)<<2, nr = N-N4+4;
   const int incA = lda << 2, incAm = 16 - (N4-4)*lda, incAm0 = 16 - N*lda;
   const TYPE *stX = X + N4, *x; 
   const TYPE *A0 = A, *A1 = A + lda, *A2 = A1 + lda, *A3 = A2 + lda;
   TYPE *stY = Y + M16;
   register TYPE x0, x1, x2, x3;
   register TYPE y0, y1, y2, y3, y4, y5, y6, y7;
   register TYPE y8, y9, y10, y11, y12, y13, y14, y15;
   register TYPE p0, p1, p2, p3;

   if (N > 4)
   {
      if (M16)
      {
         do
         {
            #ifdef BETA0
               y0 = y1 = y2 = y3 = y4 = y5 = y6 = y7 = 
               y8 = y9 = y10 = y11 = y12 = y13 = y14 = y15 = ATL_rzero;
            #elif defined BETAX
               x0 = beta;
               y0 = *Y; y1 = Y[1]; y2 = Y[2];  y3 = Y[3];
               y8 = Y[8]; y9 = Y[9]; y10 = Y[10];  y11 = Y[11];
               y4 = Y[4]; y5 = Y[5]; y6 = Y[6];  y7 = Y[7];
               y12 = Y[12]; y13 = Y[13]; y14 = Y[14];  y15 = Y[15];
               y0 *= x0; y1 *= x0; y2 *= x0; y3 *= x0;
               y8 *= x0; y9 *= x0; y10 *= x0; y11 *= x0;
               y4 *= x0; y5 *= x0; y6 *= x0; y7 *= x0;
               y12 *= x0; y13 *= x0; y14 *= x0; y15 *= x0;
            #else
               y0 = *Y; y1 = Y[1]; y2 = Y[2];  y3 = Y[3];
               y8 = Y[8]; y9 = Y[9]; y10 = Y[10];  y11 = Y[11];
               y4 = Y[4]; y5 = Y[5]; y6 = Y[6];  y7 = Y[7];
               y12 = Y[12]; y13 = Y[13]; y14 = Y[14];  y15 = Y[15];
            #endif
            p0 = *A0; p1 = A1[1];
            p2 = A2[2]; p3 = A3[3];
            x0 = *X; x1 = X[1]; x2 = X[2]; x3 = X[3];
            x = X + 4;
            if (N4 != 4)
            {
               do
               {
                  y0  += x0 * p0; p0 = A0[incA];
                  y1  += x1 * p1; p1 = A1[incA+1];
                  y2  += x2 * p2; p2 = A2[incA+2];
                  y3  += x3 * p3; p3 = A3[incA+3];
                  y8  += x0 * A0[8];
                  y9  += x1 * A1[9];
                  y10 += x2 * A2[10];
                  y11 += x3 * A3[11];
                  y4  += x0 * A0[4];
                  y5  += x1 * A1[5];
                  y6  += x2 * A2[6];
                  y7  += x3 * A3[7];
                  y12 += x0 * A0[12];
                  y13 += x1 * A1[13];
                  y14 += x2 * A2[14];
                  y15 += x3 * A3[15];

                  y0  += x1 * *A1;
                  y1  += x0 * A0[1];
                  y2  += x0 * A0[2];
                  y3  += x0 * A0[3];
                  y8  += x1 * A1[8];
                  y9  += x0 * A0[9];
                  y10 += x0 * A0[10];
                  y11 += x0 * A0[11];
                  y4  += x1 * A1[4];
                  y5  += x0 * A0[5];
                  y6  += x0 * A0[6];
                  y7  += x0 * A0[7];
                  y12 += x1 * A1[12];
                  y13 += x0 * A0[13];
                  y14 += x0 * A0[14];
                  y15 += x0 * A0[15]; x0 = *x;

                  y0  += x2 * *A2;
                  y1  += x2 * A2[1]; A0 += incA;
                  y2  += x1 * A1[2];
                  y3  += x1 * A1[3];
                  y8  += x2 * A2[8];
                  y9  += x2 * A2[9];
                  y10 += x1 * A1[10];
                  y11 += x1 * A1[11];
                  y4  += x2 * A2[4];
                  y5  += x2 * A2[5];
                  y6  += x1 * A1[6];
                  y7  += x1 * A1[7];
                  y12 += x2 * A2[12];
                  y13 += x2 * A2[13];
                  y14 += x1 * A1[14];
                  y15 += x1 * A1[15]; x1 = x[1];

                  y0  += x3 * *A3;
                  y1  += x3 * A3[1];
                  y2  += x3 * A3[2]; A1 += incA;
                  y3  += x2 * A2[3];
                  y8  += x3 * A3[8];
                  y9  += x3 * A3[9];
                  y10 += x3 * A3[10];
                  y11 += x2 * A2[11];
                  y4  += x3 * A3[4];
                  y5  += x3 * A3[5];
                  y6  += x3 * A3[6];
                  y7  += x2 * A2[7];
                  y12 += x3 * A3[12];
                  y13 += x3 * A3[13];
                  y14 += x3 * A3[14]; x3 = x[3]; A3 += incA;
                  y15 += x2 * A2[15]; x2 = x[2]; x += 4; A2 += incA;
               }
               while (x != stX);
            }
            x -= 4;
            for (j=0; j != nr; j++, A0 += lda)
            {
               x0 = x[j];
               y0  += x0 * *A0;
               y1  += x0 * A0[1];
               y2  += x0 * A0[2];
               y3  += x0 * A0[3];
               y8  += x0 * A0[8];
               y9  += x0 * A0[9];
               y10 += x0 * A0[10];
               y11 += x0 * A0[11];
               y4  += x0 * A0[4];
               y5  += x0 * A0[5];
               y6  += x0 * A0[6];
               y7  += x0 * A0[7];
               y12 += x0 * A0[12];
               y13 += x0 * A0[13];
               y14 += x0 * A0[14];
               y15 += x0 * A0[15];
            }
            A0 += incAm0;
            *Y   = y0;
            Y[ 1] = y1 ;
            Y[ 2] = y2 ;
            Y[ 3] = y3 ;
            A1 += incAm;
            Y[ 8] = y8 ;
            Y[ 9] = y9 ;
            Y[10] = y10;
            Y[11] = y11;
            A2 += incAm;
            Y[ 4] = y4 ;
            Y[ 5] = y5 ;
            Y[ 6] = y6 ;
            Y[ 7] = y7 ;
            A3 += incAm;
            Y[12] = y12;
            Y[13] = y13;
            Y[14] = y14;
            Y[15] = y15;
            Y += 16;
         }
         while (Y != stY);
      }
      if (M-M16) gemvMlt8(M-M16, N, A0, lda, X, beta, Y);
   }
   else if (M) gemvNle4(M, N, A, lda, X, beta, Y);
}
@ROUT ATL_gemvN_16x2_1
static void gemv16x2(const int M, const int N, const TYPE *A, const int lda,
                     const TYPE *X, const SCALAR beta, TYPE *Y)
/*
 * 16x2 with feeble prefetch
 */
{
   const int M16 = (M>>4)<<4, N2 = (N>>1)<<1, nr = N-N2;
   const int incA = lda << 1, incAm = 16 - N2*lda;
   const TYPE *stX = X + N2 - 2, *x; 
   const TYPE *A0 = A, *A1 = A + lda;
   TYPE *stY = Y + M16;
   register TYPE x0, x1;
   register TYPE y0, y1, y2, y3, y4, y5, y6, y7;
   register TYPE y8, y9, y10, y11, y12, y13, y14, y15;
   register TYPE p0, p1;

   if (N > 4)
   {
      if (M16)
      {
         do
         {
            #ifdef BETA0
               y0 = y1 = y2 = y3 = y4 = y5 = y6 = y7 = 
               y8 = y9 = y10 = y11 = y12 = y13 = y14 = y15 = ATL_rzero;
            #elif defined BETAX
               x0 = beta;
               y0 = *Y; y1 = Y[1]; y2 = Y[2];  y3 = Y[3];
               y4 = Y[4]; y5 = Y[5]; y6 = Y[6];  y7 = Y[7];
               y8 = Y[8]; y9 = Y[9]; y10 = Y[10];  y11 = Y[11];
               y12 = Y[12]; y13 = Y[13]; y14 = Y[14];  y15 = Y[15];
               y0 *= x0; y1 *= x0; y2 *= x0; y3 *= x0;
               y4 *= x0; y5 *= x0; y6 *= x0; y7 *= x0;
               y8 *= x0; y9 *= x0; y10 *= x0; y11 *= x0;
               y12 *= x0; y13 *= x0; y14 *= x0; y15 *= x0;
            #else
               y0 = *Y; y1 = Y[1]; y2 = Y[2];  y3 = Y[3];
               y4 = Y[4]; y5 = Y[5]; y6 = Y[6];  y7 = Y[7];
               y8 = Y[8]; y9 = Y[9]; y10 = Y[10];  y11 = Y[11];
               y12 = Y[12]; y13 = Y[13]; y14 = Y[14];  y15 = Y[15];
            #endif
            p0 = *A0;
            p1 = A1[1];
            x = X;
            do
            {
               x0 = *x; x1 = x[1]; x += 2;
               y0 += x0 * p0; p0 = A0[incA];
               y1 += x1 * p1; p1 = A1[incA+1];
               y8 += x0 * A0[8];
               y9 += x1 * A1[9];
               y4 += x0 * A0[4];
               y5 += x1 * A1[5];
               y12 += x0 * A0[12];
               y13 += x1 * A1[13];
               y2 += x0 * A0[2];
               y3 += x1 * A1[3];
               y10 += x0 * A0[10];
               y11 += x1 * A1[11];
               y6 += x0 * A0[6];
               y7 += x1 * A1[7];
               y14 += x0 * A0[14];
               y15 += x1 * A1[15];

               y0  += x1 * *A1;
               y1  += x0 * A0[1];
               y8  += x1 * A1[8];
               y9  += x0 * A0[9];
               y4  += x1 * A1[4];
               y5  += x0 * A0[5];
               y12 += x1 * A1[12];
               y13 += x0 * A0[13];
               y2  += x1 * A1[2];
               y3  += x0 * A0[3];
               y10 += x1 * A1[10];
               y11 += x0 * A0[11];
               y6  += x1 * A1[6];
               y7  += x0 * A0[7];
               y14 += x1 * A1[14]; A1 += incA;
               y15 += x0 * A0[15]; A0 += incA;
            }
            while (x != stX);
            if (!nr) /* 2 cols left */
            {
               x0 = *x; x1 = x[1]; x += 2;
               y0 += x0 * p0;
               y1 += x1 * p1;
               y8 += x0 * A0[8];
               y9 += x1 * A1[9];
               y4 += x0 * A0[4];
               y5 += x1 * A1[5];
               y12 += x0 * A0[12];
               y13 += x1 * A1[13];
               y2 += x0 * A0[2];
               y3 += x1 * A1[3];
               y10 += x0 * A0[10];
               y11 += x1 * A1[11];
               y6 += x0 * A0[6];
               y7 += x1 * A1[7];
               y14 += x0 * A0[14];
               y15 += x1 * A1[15];

               y0  += x1 * *A1;
               y1  += x0 * A0[1];
               y8  += x1 * A1[8];
               y9  += x0 * A0[9];
               y4  += x1 * A1[4];
               y5  += x0 * A0[5];
               y12 += x1 * A1[12];
               y13 += x0 * A0[13];
               y2  += x1 * A1[2];
               y3  += x0 * A0[3];
               y10 += x1 * A1[10];
               y11 += x0 * A0[11];
               y6  += x1 * A1[6];
               y7  += x0 * A0[7];
               y14 += x1 * A1[14]; A1 += incA;
               y15 += x0 * A0[15]; A0 += incA;
            }
            else     /* 3 cols left */
            {
               x0 = *x; x1 = x[1]; x += 2;
               y0 += x0 * p0; p0 = A0[incA];
               y1 += x1 * p1;
               y8 += x0 * A0[8];
               y9 += x1 * A1[9];
               y4 += x0 * A0[4];
               y5 += x1 * A1[5];
               y12 += x0 * A0[12];
               y13 += x1 * A1[13];
               y2 += x0 * A0[2];
               y3 += x1 * A1[3];
               y10 += x0 * A0[10];
               y11 += x1 * A1[11];
               y6 += x0 * A0[6];
               y7 += x1 * A1[7];
               y14 += x0 * A0[14];
               y15 += x1 * A1[15];

               y0  += x1 * *A1;
               y1  += x0 * A0[1];
               y8  += x1 * A1[8];
               y9  += x0 * A0[9];
               y4  += x1 * A1[4];
               y5  += x0 * A0[5];
               y12 += x1 * A1[12];
               y13 += x0 * A0[13];
               y2  += x1 * A1[2];
               y3  += x0 * A0[3];
               y10 += x1 * A1[10];
               y11 += x0 * A0[11];
               y6  += x1 * A1[6];
               y7  += x0 * A0[7];
               y14 += x1 * A1[14]; A1 += incA;
               y15 += x0 * A0[15]; A0 += incA;

               x0 = *x;
               y0  += x0 * *A0;
               y1  += x0 * A0[1];
               y2  += x0 * A0[2];
               y3  += x0 * A0[3];
               y4  += x0 * A0[4];
               y5  += x0 * A0[5];
               y6  += x0 * A0[6];
               y7  += x0 * A0[7];
               y8  += x0 * A0[8];
               y9  += x0 * A0[9];
               y10 += x0 * A0[10];
               y11 += x0 * A0[11];
               y12 += x0 * A0[12];
               y13 += x0 * A0[13];
               y14 += x0 * A0[14];
               y15 += x0 * A0[15];
            }
            *Y = y0;
            A0 += incAm;
            Y[1] = y1;
            A1 += incAm;
            Y[2] = y2;
            Y[3] = y3;
            Y[4] = y4;
            Y[5] = y5;
            Y[6] = y6;
            Y[7] = y7;
            Y[8] = y8;
            Y[9] = y9;
            Y[10] = y10;
            Y[11] = y11;
            Y[12] = y12;
            Y[13] = y13;
            Y[14] = y14;
            Y[15] = y15;
            Y += 16;
         }
         while (Y != stY);
      }
      if (M-M16) gemvMlt8(M-M16, N, A0, lda, X, beta, Y);
   }
   else if (M) gemvNle4(M, N, A, lda, X, beta, Y);
}
@ROUT ATL_gemvN_8x4_1
static void gemv8x4(const int M, const int N, const TYPE *A, const int lda,
                    const TYPE *X, const SCALAR beta, TYPE *Y)
{
   int i;
   const int M8 = (M>>3)<<3, N4 = (N>>2)<<2, nr = N-N4;
   const int incA = lda << 2, incAm = 8 - N4*lda;
   const TYPE *stX = X + N4, *x; 
   const TYPE *A0 = A, *A1 = A + lda, *A2 = A1 + lda, *A3 = A2 + lda;
   TYPE *stY = Y + M8;
   register TYPE x0, x1, x2, x3;
   register TYPE y0, y1, y2, y3, y4, y5, y6, y7;
   #ifdef ATL_AltiVec
   const int cwrd=ATL_GetCtrl(ATL_MulBySize(lda), Mmin(N,255), ATL_sizeof>>1);
   #endif

   if (N > 4)
   {
      if (M8)
      {
         do
         {
            #ifdef ATL_AltiVec
               ATL_pfavR(A0, cwrd, 0);
            #endif
            #ifdef BETA0
               y0 = y1 = y2 = y3 = y4 = y5 = y6 = y7 = ATL_rzero;
            #elif defined BETAX
               x0 = beta;
               y0 = *Y; y1 = Y[1]; y2 = Y[2];  y3 = Y[3];
               y4 = Y[4]; y5 = Y[5]; y6 = Y[6];  y7 = Y[7];
               y0 *= x0; y1 *= x0; y2 *= x0; y3 *= x0;
               y4 *= x0; y5 *= x0; y6 *= x0; y7 *= x0;
            #else
               y0 = *Y; y1 = Y[1]; y2 = Y[2];  y3 = Y[3];
               y4 = Y[4]; y5 = Y[5]; y6 = Y[6];  y7 = Y[7];
            #endif
            x = X;
            do
            {
               x0 = *x; x1 = x[1]; x2 = x[2]; x3 = x[3]; x += 4;
               y0 += *A0 * x0;
               y1 += A1[1] * x1;
               y2 += A2[2] * x2;
               y3 += A3[3] * x3;
               y4 += A0[4] * x0;
               y5 += A1[5] * x1;
               y6 += A2[6] * x2;
               y7 += A3[7] * x3;

               y0 += *A1 * x1;
               y1 += A0[1] * x0;
               y2 += A0[2] * x0;
               y3 += A0[3] * x0;
               y4 += A1[4] * x1;
               y5 += A0[5] * x0;
               y6 += A0[6] * x0;
               y7 += A0[7] * x0;

               y0 += *A2 * x2; A0 += incA;
               y1 += A2[1] * x2;
               y2 += A1[2] * x1;
               y3 += A1[3] * x1;
               y4 += A2[4] * x2;
               y5 += A2[5] * x2;
               y6 += A1[6] * x1;
               y7 += A1[7] * x1;

               y0 += *A3 * x3; A1 += incA;
               y1 += A3[1] * x3;
               y2 += A3[2] * x3;
               y3 += A2[3] * x2;
               y4 += A3[4] * x3;
               y5 += A3[5] * x3;
               y6 += A3[6] * x3; A3 += incA;
               y7 += A2[7] * x2; A2 += incA;
            }
            while (x != stX);
            if (nr)
            {
               for (i=0; i < nr; i++, A0 += lda)
               {
                  x0 = x[i];
                  y0 += *A0 * x0;
                  y1 += A0[1] * x0;
                  y2 += A0[2] * x0;
                  y3 += A0[3] * x0;
                  y4 += A0[4] * x0;
                  y5 += A0[5] * x0;
                  y6 += A0[6] * x0;
                  y7 += A0[7] * x0;
               }
               A0 -= nr*lda;
            }
            *Y = y0;
            A0 += incAm;
            Y[1] = y1;
            A1 += incAm;
            Y[2] = y2;
            A2 += incAm;
            Y[3] = y3;
            A3 += incAm;
            Y[4] = y4;
            Y[5] = y5;
            Y[6] = y6;
            Y[7] = y7;
            Y += 8;
         }
         while(Y != stY);
      }
      if (M-M8) gemvMlt8(M-M8, N, A0, lda, X, beta, Y);
   }
   else if (M) gemvNle4(M, N, A, lda, X, beta, Y);
}
@ROUT ATL_gemvN_4x4_1
static void gemv4x4(const int M, const int N, const TYPE *A, const int lda,
                    const TYPE *X, const SCALAR beta, TYPE *Y)
{
   const int M4 = (M>>2)<<2, N4 = (N>>2)<<2, nr = N-N4;
   const int incA = lda << 2, incAm = 4 - N4*lda;
   const TYPE *stX = X + N4, *x; 
   const TYPE *A0 = A, *A1 = A + lda, *A2 = A1 + lda, *A3 = A2 + lda;
   TYPE *stY = Y + M4;
   register TYPE a00, a10, a20, a30, a01, a11, a21, a31;
   register TYPE a02, a12, a22, a32, a03, a13, a23, a33;
   register TYPE y0, y1, y2, y3, yy0, yy1, yy2, yy3;
   register TYPE x0, x1, x2, x3;

   if (N > 4)
   {
      if (M4)
      {
         do
         {
            a00 = *A0; a01 = *A1;  a02 = *A2; a03 = *A3;
            a10 = A0[1]; a11 = A1[1]; a12 = A2[1]; a13 = A3[1];
            a20 = A0[2]; a21 = A1[2]; a22 = A2[2]; a23 = A3[2];
            a30 = A0[3]; a31 = A1[3]; a32 = A2[3]; a33 = A3[3];
            A0 += incA; A1 += incA; A2 += incA; A3 += incA;
            #ifdef BETA0
               yy0 = yy1 = yy2 = yy3 = y0 = y1 = y2 = y3 = ATL_rzero;
            #elif defined BETAX
               y0 = beta;
               yy0 = *Y; yy1 = Y[1]; yy2 = Y[2];  yy3 = Y[3];
               yy0 *= y0; yy1 *= y0; yy2 *= y0; yy3 *= y0;
               y0 = y1 = y2 = y3 = ATL_rzero;
            #else
               yy0 = *Y; yy1 = Y[1]; yy2 = Y[2];  yy3 = Y[3];
               y0 = y1 = y2 = y3 = ATL_rzero;
            #endif
            x0 = *X; x1 = X[1]; x2 = X[2]; x3 = X[3];
            x = X + 4;
            if (N4 != 4)
            {
               do
               {
                  y0  += x0 * a00; a00 = *A0;
                  yy0 += x1 * a01; a01 = *A1;
                  y1  += x0 * a10; a10 = A0[1];
                  yy1 += x1 * a11; a11 = A1[1];
                  y2  += x0 * a20; a20 = A0[2];
                  yy2 += x1 * a21; a21 = A1[2];
                  y3  += x0 * a30; a30 = A0[3]; A0 += incA; x0 = *x;
                  yy3 += x1 * a31; a31 = A1[3]; A1 += incA; x1 = x[1];

                  y0  += x2 * a02; a02 = *A2;
                  yy0 += x3 * a03; a03 = *A3;
                  y1  += x2 * a12; a12 = A2[1];
                  yy1 += x3 * a13; a13 = A3[1];
                  y2  += x2 * a22; a22 = A2[2];
                  yy2 += x3 * a23; a23 = A3[2];
                  y3  += x2 * a32; a32 = A2[3]; A2 += incA; x2 = x[2];
                  yy3 += x3 * a33; a33 = A3[3]; A3 += incA; x3 = x[3]; x += 4;
               }
               while(x != stX);
            }
/*
 *          Drain pipe
 */
            y0  += x0 * a00;
            yy0 += x1 * a01;
            y1  += x0 * a10;
            yy1 += x1 * a11;
            y2  += x0 * a20;
            yy2 += x1 * a21;
            y3  += x0 * a30;
            yy3 += x1 * a31;

            y0  += x2 * a02;
            yy0 += x3 * a03;
            y1  += x2 * a12;
            yy1 += x3 * a13;
            y2  += x2 * a22;
            yy2 += x3 * a23;
            y3  += x2 * a32;
            yy3 += x3 * a33;
/*
 *          loop cleanup
 */
            switch(nr)
            {
            case 1:
               x0 = *x;
               y0 += x0 * *A0;
               y1 += x0 * A0[1];
               y2 += x0 * A0[2];
               y3 += x0 * A0[3];
               break;
            case 2:
               x0 = *x;
               x1 = x[1];
               y0  += x0 * *A0;
               yy0 += x1 * *A1;
               y1  += x0 * A0[1];
               yy1 += x1 * A1[1];
               y2  += x0 * A0[2];
               yy2 += x1 * A1[2];
               y3  += x0 * A0[3];
               yy3 += x1 * A1[3];
               break;
            case 3:
               x0 = *x; x1 = x[1]; x2 = x[2];
               y0  += x0 * *A0;
               yy0 += x1 * *A1;
               y1  += x0 * A0[1];
               yy1 += x1 * A1[1];
               y2  += x0 * A0[2];
               yy2 += x1 * A1[2];
               y3  += x0 * A0[3];
               yy3 += x1 * A1[3];
               y0 += x2 * *A2;
               y1 += x2 * A2[1];
               y2 += x2 * A2[2];
               y3 += x2 * A2[3];
               break;
            default:;
            }
            A0 += incAm;
            y0 += yy0;
            A1 += incAm;
            y1 += yy1;
            A2 += incAm;
            y2 += yy2;
            A3 += incAm;
            y3 += yy3;
            *Y = y0;
            Y[1] = y1;
            Y[2] = y2;
            Y[3] = y3;
            Y += 4;
         }
         while (Y != stY);
      }
      if (M-M4) gemvMlt8(M-M4, N, A0, lda, X, beta, Y);
   }
   else if (M) gemvNle4(M, N, A, lda, X, beta, Y);
}

@ROUT ATL_gemvN_4x4_1 ATL_gemvN_4x2_0 ATL_gemvN_mm ATL_gemvN_8x32_2 @\
      ATL_gemvN_8x4_1 ATL_gemvN_16x2_1 ATL_gemvN_16x4_1 ATL_gemvN_32x4_1 @\
      ATL_gemvN_1x1_1 ATL_gemvN_1x1_1a
void Mjoin(Mjoin(Mjoin(Mjoin(Mjoin(PATL,gemvN),NM),_x1),BNM),_y1)
   (const int M, const int N, const SCALAR alpha, const TYPE *A, const int lda,
    const TYPE *X, const int incX, const SCALAR beta, TYPE *Y, const int incY)
{
@ROUT ATL_gpmvN_1x1_1a ATL_gpmvN_32x4_1
#ifdef Upper_
void Mjoin(Mjoin(Mjoin(Mjoin(PATL,gpmvUN_a1),_x1),BNM),_y1)
#else
void Mjoin(Mjoin(Mjoin(Mjoin(PATL,gpmvLN_a1),_x1),BNM),_y1)
#endif
   (const int M, const int N, const SCALAR alpha, const TYPE *A, const int lda,
    const TYPE *X, const int incX, const SCALAR beta, TYPE *Y, const int incY)
{

   register int ld=(lda SHIFT);
   const TYPE *stX = X + (N SHIFT);
@ROUT ATL_gemvN_1x1_1a
   int j;
@ROUT ATL_gemvN_1x1_1a ATL_gpmvN_1x1_1a

   #ifdef BETA0
      Mjoin(PATL,zero)(M, Y, 1);
   #elif !defined(BETA1)
      Mjoin(PATL,scal)(M, beta, Y, 1);
   #endif
@ROUT ATL_gemvN_1x1_1a
   for (j=N; j; j--, A += lda, X++) Mjoin(PATL,axpy)(M, *X, A, 1, Y, 1);
@ROUT ATL_gpmvN_1x1_1a
   do
   {
      #ifdef TREAL
         Mjoin(PATL,axpy)(M, *X++, A, 1, Y, 1);
      #else
         Mjoin(PATL,axpy)(M, X, A, 1, Y, 1);
         X += 2;
      #endif
      A += ld;
      MpIncInc(ld);
   }
   while (X != stX);
@ROUT ATL_gemvN_1x1_1a ATL_gpmvN_1x1_1a
}
@ROUT ATL_gemvN_1x1_1
   int i, j;
   for (i=0; i != M; i++)
   {
      #ifdef BETA0
         Y[i] = ATL_rzero;
      #elif defined(BETAX)
         Y[i] *= beta;
      #endif
      for (j=0; j != N; j++) Y[i] += A[i+j*lda] * X[j];
   }
}
@ROUT ATL_gemvN_32x4_1
   gemv32x4(M, N, A, lda, X, beta, Y);
@ROUT ATL_gemvN_16x4_1
   gemv16x4(M, N, A, lda, X, beta, Y);
@ROUT ATL_gemvN_16x2_1
   gemv16x2(M, N, A, lda, X, beta, Y);
@ROUT ATL_gemvN_8x4_1
   gemv8x4(M, N, A, lda, X, beta, Y);
@ROUT ATL_gemvN_8x32_2
   gemv(M, N, A, lda, X, beta, Y);
@ROUT ATL_gemvN_4x4_1
   gemv4x4(M, N, A, lda, X, beta, Y);
@ROUT ATL_gemvN_4x2_0
   const int incA = lda<<1, incAm = 4 - ((N>>1)<<1)*lda;
   const int m4 = (M>>2)<<2;
   int n2, nr;
   register TYPE y0, y1, y2, y3, z0, z1, z2, z3, x0, x1, m0, m1, m2, m3;
   register TYPE a00, a10, a20, a30, a01, a11, a21, a31;
   const TYPE *x, *stX = X + ((N>>1)<<1)-2, *A0 = A, *A1 = A + lda;
   TYPE *stY = Y + m4;

   if (N > 4)
   {
      n2 = ((N-4)>>1)<<1;
      nr = N - n2;
      if (m4)
      {
         do
         {
            x = X + 2;
            #ifdef BETA0
               z0 = z1 = z2 = z3 = y0 = y1 = y2 = y3 = ATL_rzero;
            #else
               z0 = *Y;
               z1 = Y[1];
               z2 = Y[2];
               z3 = Y[3];
               #ifdef BETAX
                  y0 = beta;
                  z0 *= y0;
                  z1 *= y0;
                  z2 *= y0;
                  z3 *= y0;
               #endif
               y0 = y1 = y2 = y3 = ATL_rzero;
            #endif
            x0 = *X;
            x1 = X[1];
            a00 = *A0;
            a01 = *A1;
            a10 = A0[1];
            a11 = A1[1];
            a20 = A0[2];
            a21 = A1[2];
            a30 = A0[3];
            a31 = A1[3];
            A0 += incA;
            A1 += incA;
            m0 = x0 * a00;
            a00 = *A0;
            m1 = x1 * a01;
            a01 = *A1;
            m2 = x0 * a10;
            a10 = A0[1];
            m3 = x1 * a11;
            a11 = A1[1];
            if (n2)
            {
               do
               {
                  y0 += m0;
                  m0 = x0 * a20;
                  a20 = A0[2];
                  z0 += m1;
                  m1 = x1 * a21;
                  a21 = A1[2];
                  y1 += m2;
                  m2 = x0 * a30;
                  x0 = *x;
                  a30 = A0[3];
                  A0 += incA;
                  z1 += m3;
                  m3 = x1 * a31;
                  x1 = x[1];
                  a31 = A1[3];
                  x += 2;
                  A1 += incA;
         
                  y2 += m0;
                  m0 = x0 * a00;
                  a00 = *A0;
                  z2 += m1;
                  m1 = x1 * a01;
                  a01 = *A1;
                  y3 += m2;
                  m2 = x0 * a10;
                  a10 = A0[1];
                  z3 += m3;
                  m3 = x1 * a11;
                  a11 = A1[1];
               }
               while (x != stX);
            }
            if (nr == 4)
            {
               y0 += m0;
               m0 = x0 * a20;
               a20 = A0[2];
               z0 += m1;
               m1 = x1 * a21;
               a21 = A1[2];
               y1 += m2;
               m2 = x0 * a30;
               x0 = *x;
               a30 = A0[3];
               z1 += m3;
               m3 = x1 * a31;
               x1 = x[1];
               a31 = A1[3];

               y2 += m0;
               m0 = x0 * a00;
               z2 += m1;
               m1 = x1 * a01;
               y3 += m2;
               m2 = x0 * a10;
               z3 += m3;
               m3 = x1 * a11;

               y0 += m0;
               m0 = x0 * a20;
               z0 += m1;
               m1 = x1 * a21;
               y1 += m2;
               m2 = x0 * a30;
               z1 += m3;
               m3 = x1 * a31;

               y2 += m0;
               A0 += incA;
               z2 += m1;
               A1 += incA;
               y3 += m2;
               z3 += m3;
            }
            else /* nr == 5 */
            {
               y0 += m0;
               m0 = x0 * a20;
               a20 = A0[2];
               z0 += m1;
               m1 = x1 * a21;
               a21 = A1[2];
               y1 += m2;
               m2 = x0 * a30;
               x0 = *x;
               a30 = A0[3];
               A0 += incA;
               z1 += m3;
               m3 = x1 * a31;
               x1 = x[1];
               x += 2;
               a31 = A1[3];

               y2 += m0;
               m0 = x0 * a00;
               a00 = *A0;
               z2 += m1;
               m1 = x1 * a01;
               y3 += m2;
               m2 = x0 * a10;
               a10 = A0[1];
               z3 += m3;
               m3 = x1 * a11;

               y0 += m0;
               m0 = x0 * a20;
               a20 = A0[2];
               z0 += m1;
               m1 = x1 * a21;
               y1 += m2;
               m2 = x0 * a30;
               x0 = *x;
               a30 = A0[3];
               z1 += m3;
               m3 = x1 * a31;

               y2 += m0;
               m0 = x0 * a00;
               z2 += m1;
               m1 = x0 * a10;
               y3 += m2;
               m2 = x0 * a20;
               z3 += m3;
               m3 = x0 * a30;

               y0 += m0;
               A1 += incA;
               y1 += m1;
               y2 += m2;
               y3 += m3;
            }

            y0 += z0;
            A0 += incAm;
            y1 += z1;
            A1 += incAm;
            y2 += z2;
            y3 += z3;
            *Y = y0;
            Y[1] = y1;
            Y[2] = y2;
            Y[3] = y3;
            Y += 4;
         }
         while (Y != stY);
      }
      for (nr=M-m4; nr; nr--)
      {
         #ifdef BETA0
            y0 = Mjoin(PATL,dot)(N, A0, lda, X, 1);
         #else
            #if defined(BETAX)
               y0 = *Y * beta;
            #else
               y0 = *Y;
            #endif
            y0 += Mjoin(PATL,dot)(N, A0, lda, X, 1);
         #endif
         *Y++ = y0;
         A0++;
      }
   }
   else if (M) gemvNle4(M, N, A, lda, X, beta, Y);
@ROUT ATL_gemvN_mm
   Mjoin(PATL,NCmmJIK)(AtlasNoTrans, AtlasNoTrans, M, 1, N, ATL_rone, A, lda,
                       X, N, beta, Y, M);
@ROUT ATL_gemvN_4x4_1 ATL_gemvN_4x2_0 ATL_gemvN_mm ATL_gemvN_8x32_2 ATL_gemvN_8x4_1 ATL_gemvN_16x2_1 ATL_gemvN_16x4_1 ATL_gemvN_32x4_1
}
@ROUT ATL_gpmv_a1_x1_y1
#include "atlas_misc.h"

#if (ATL_mmnreg >= 24) && defined(TREAL)

   @extract -b @(incd)/atlas-lvl2.base rout=ATL_gpmvN_32x4_1

#else  /* ATL_mmnreg < 24 or complex */

   @extract -b @(incd)/atlas-lvl2.base rout=ATL_gpmvN_1x1_1a

#endif
@ROUT ATL_cgemvT_2x4_1 ATL_cgemvT_2x2_0 ATL_cgemvT_mm ATL_cgemvT_1x1_1
#include "atlas_misc.h"
#include "atlas_level1.h"
#include "atlas_level2.h"
@ROUT ATL_cgemvT_mm `#include "atlas_lvl3.h"`
@ROUT ATL_cgemvT_2x4_1 ATL_cgemvT_2x2_0 `#include "atlas_prefetch.h"`

#ifdef Conj_
   #define PEQ -=
   #define MEQ +=
#else
   #define PEQ +=
   #define MEQ -=
#endif

@ROUT ATL_cgemvT_2x4_1 ATL_cgemvT_2x2_0
static void gemvMlt4(const int M, const int N, const TYPE *A, const int lda,
                     const TYPE *X, const SCALAR beta, TYPE *Y)
{
   int j;
   const int lda2 = lda<<1;
   #ifndef BETA0
      register TYPE yr0, yi0, yr1, yi1; 
   #endif
   #if defined(BETAXI0)
      const register TYPE rbeta = *beta;
   #elif defined(BETAX)
      const register TYPE xr0 = *beta, xi0 = beta[1];
   #endif

   for (j=M; j; j--, A += lda2, Y += 2)
   {
   #ifdef BETA0
      #ifndef Conj_
         Mjoin(PATL,dotu_sub)(N, A, 1, X, 1, Y);
      #else
         Mjoin(PATL,dotc_sub)(N, A, 1, X, 1, Y);
      #endif
   #else
      #ifdef BETAX
         yr0 = *Y;
         yi0 = Y[1];
         yr1 = yr0 * xr0 - yi0 * xi0;
         yi1 = yr0 * xi0 + yi0 * xr0;
      #else
         yr1 = *Y;
         yi1 = Y[1];
         #ifdef BETAXI0
            yr1 *= rbeta;
            yi1 *= rbeta;
         #endif
      #endif
      #ifndef Conj_
         Mjoin(PATL,dotu_sub)(N, A, 1, X, 1, Y);
      #else
         Mjoin(PATL,dotc_sub)(N, A, 1, X, 1, Y);
      #endif
      *Y += yr1;
      Y[1] += yi1;
   #endif
   }
}

static void gemvNlt2(const int M, const int N, const TYPE *A, const int lda,
                     const TYPE *X, const SCALAR beta, TYPE *Y)
{
   #ifdef BETA0
      #ifndef Conj_
         Mjoin(PATL,cpsc)(M, X, A, lda, Y, 1);
      #else
         Mjoin(PATL,moveConj)(M, X, A, lda, Y, 1);
      #endif
   #elif defined(BETAX) || defined(BETAXI0)
      #ifndef Conj_
         Mjoin(PATL,axpby)(M, X, A, lda, beta, Y, 1);
      #else
         Mjoin(PATL,axpbyConj)(M, X, A, lda, beta, Y, 1);
      #endif
   #else
      #ifndef Conj_
         Mjoin(PATL,axpy)(M, X, A, lda, Y, 1);
      #else
         Mjoin(PATL,axpyConj)(M, X, A, lda, Y, 1);
      #endif
   #endif
}

@ROUT ATL_cgemvT_2x4_1
static void gemv2x4(const int M, const int N, const TYPE *A, const int lda,
                    const TYPE *X, const SCALAR beta, TYPE *Y)
{
   const int N2 = (N>>1)<<1, M4 = (M>>2)<<2, nr = (N-N2);
   const int incAm = ((lda<<2) - N2)<<1;
   const TYPE *A0 = A, *A1 = A+(lda<<1), *A2 = A1+(lda<<1), *A3 = A2+(lda<<1);
   const TYPE *x, *stX = X + (N2<<1);
   TYPE *stY = Y + (M4<<1);
   #ifdef BETAX
      const TYPE rbeta = *beta, ibeta = beta[1];
   #elif defined(BETAXI0)
      const TYPE rbeta = *beta;
   #endif
   register TYPE yr0, yi0, yr1, yi1, yr2, yi2, yr3, yi3;
   register TYPE xr0, xi0, xr1, xi1;
   register TYPE ar00, ar01, ar02, ar03, ar10, ar11, ar12, ar13;
   register TYPE ai00, ai01, ai02, ai03, ai10, ai11, ai12, ai13;
   #ifdef ATL_AltiVec
      int cwrd = ATL_MulBySize(N)>>4;
      if (cwrd >= 64) cwrd = ATL_GetCtrl(512, (cwrd+31)>>5, 0);
      else cwrd = ATL_GetCtrl(64, (cwrd+3)>>2, 4);
   #endif


   if (N2)
   {
      if (M4)
      {
         do
         {
            #ifdef ATL_AltiVec
               ATL_pfavR(A0, cwrd, 0);
               ATL_pfavR(A1, cwrd, 1);
               ATL_pfavR(A2, cwrd, 2); 
               ATL_pfavR(A3, cwrd, 3);
            #endif

            #ifdef BETA0
               yr0 = yi0 = yr1 = yi1 = yr2 = yi2 = yr3 = yi3 = ATL_rzero;
            #elif defined(BETAX)
               ar00 =   *Y; ai00 = Y[1]; ar01 = Y[2]; ai01 = Y[3];
               ar02 = Y[4]; ai02 = Y[5]; ar03 = Y[6]; ai03 = Y[7];
               yr0 = rbeta * ar00 - ibeta * ai00;
               yi0 = rbeta * ai00 + ibeta * ar00;
               yr1 = rbeta * ar01 - ibeta * ai01;
               yi1 = rbeta * ai01 + ibeta * ar01;
               yr2 = rbeta * ar02 - ibeta * ai02;
               yi2 = rbeta * ai02 + ibeta * ar02;
               yr3 = rbeta * ar03 - ibeta * ai03;
               yi3 = rbeta * ai03 + ibeta * ar03;
            #else
               yr0 =   *Y; yi0 = Y[1]; yr1 = Y[2]; yi1 = Y[3];
               yr2 = Y[4]; yi2 = Y[5]; yr3 = Y[6]; yi3 = Y[7];
               #ifdef BETAXI0
                  yr0 *= rbeta; yi0 *= rbeta;
                  yr1 *= rbeta; yi1 *= rbeta;
                  yr2 *= rbeta; yi2 *= rbeta;
                  yr3 *= rbeta; yi3 *= rbeta;
               #endif
            #endif
            ar00 = *A0;   ar01 = *A1;    ar02 = *A2;   ar03 = *A3;
            ai00 = A0[1]; ai01 = A1[1];  ai02 = A2[1]; ai03 = A3[1];
            ar10 = A0[2]; ar11 = A1[2];  ar12 = A2[2]; ar13 = A3[2];
            ai10 = A0[3]; ai11 = A1[3];  ai12 = A2[3]; ai13 = A3[3];
            A0 += 4; A1 += 4; A2 += 4; A3 += 4;
            xr0 = *X; xi0 = X[1]; xr1 = X[2]; xi1 = X[3]; x = X + 4;
            if (N2 > 3)
            {
               do
               {
                  yr0 += xr0 * ar00;
                  yr1 += xr0 * ar01;
                  yr2 += xr0 * ar02;
                  yr3 += xr0 * ar03;
                  yi0 += xi0 * ar00; ar00 = *A0;
                  yi1 += xi0 * ar01; ar01 = *A1;
                  yi2 += xi0 * ar02; ar02 = *A2;
                  yi3 += xi0 * ar03; ar03 = *A3;
                  #ifndef Conj_
                     yr0 -= xi0 * ai00;
                     yr1 -= xi0 * ai01;
                     yr2 -= xi0 * ai02;
                     yr3 -= xi0 * ai03; xi0 = x[1];
                     yi0 += xr0 * ai00; ai00 = A0[1];
                     yi1 += xr0 * ai01; ai01 = A1[1];
                     yi2 += xr0 * ai02; ai02 = A2[1];
                     yi3 += xr0 * ai03; ai03 = A3[1]; xr0 = *x;
                  #else
                     yr0 += xi0 * ai00;
                     yr1 += xi0 * ai01;
                     yr2 += xi0 * ai02;
                     yr3 += xi0 * ai03; xi0 = x[1];
                     yi0 -= xr0 * ai00; ai00 = A0[1];
                     yi1 -= xr0 * ai01; ai01 = A1[1];
                     yi2 -= xr0 * ai02; ai02 = A2[1];
                     yi3 -= xr0 * ai03; ai03 = A3[1]; xr0 = *x;
                  #endif

                  yr0 += xr1 * ar10;
                  yr1 += xr1 * ar11;
                  yr2 += xr1 * ar12;
                  yr3 += xr1 * ar13;
                  yi0 += xi1 * ar10; ar10 = A0[2];
                  yi1 += xi1 * ar11; ar11 = A1[2];
                  yi2 += xi1 * ar12; ar12 = A2[2];
                  yi3 += xi1 * ar13; ar13 = A3[2];
                  #ifndef Conj_
                     yr0 -= xi1 * ai10;
                     yr1 -= xi1 * ai11;
                     yr2 -= xi1 * ai12;
                     yr3 -= xi1 * ai13; xi1 = x[3];
                     yi0 += xr1 * ai10; ai10 = A0[3]; A0 += 4;
                     yi1 += xr1 * ai11; ai11 = A1[3]; A1 += 4;
                     yi2 += xr1 * ai12; ai12 = A2[3]; A2 += 4;
                     yi3 += xr1 * ai13; ai13 = A3[3]; A3 += 4; xr1=x[2]; x += 4;
                  #else
                     yr0 += xi1 * ai10;
                     yr1 += xi1 * ai11;
                     yr2 += xi1 * ai12;
                     yr3 += xi1 * ai13; xi1 = x[3];
                     yi0 -= xr1 * ai10; ai10 = A0[3]; A0 += 4;
                     yi1 -= xr1 * ai11; ai11 = A1[3]; A1 += 4;
                     yi2 -= xr1 * ai12; ai12 = A2[3]; A2 += 4;
                     yi3 -= xr1 * ai13; ai13 = A3[3]; A3 += 4; xr1=x[2]; x += 4;
                  #endif
               }
               while (x != stX);
            }
            if (!nr) /* fetching done, just do 2 remaining ops */
            {
               yr0 += xr0 * ar00;
               yr1 += xr0 * ar01;
               yr2 += xr0 * ar02;
               yr3 += xr0 * ar03;
               yi0 += xi0 * ar00;
               yi1 += xi0 * ar01;
               yi2 += xi0 * ar02;
               yi3 += xi0 * ar03;
               #ifndef Conj_
                  yr0 -= xi0 * ai00;
                  yr1 -= xi0 * ai01;
                  yr2 -= xi0 * ai02;
                  yr3 -= xi0 * ai03;
                  yi0 += xr0 * ai00;
                  yi1 += xr0 * ai01;
                  yi2 += xr0 * ai02;
                  yi3 += xr0 * ai03;
               #else
                  yr0 += xi0 * ai00;
                  yr1 += xi0 * ai01;
                  yr2 += xi0 * ai02;
                  yr3 += xi0 * ai03;
                  yi0 -= xr0 * ai00;
                  yi1 -= xr0 * ai01;
                  yi2 -= xr0 * ai02;
                  yi3 -= xr0 * ai03;
               #endif

               yr0 += xr1 * ar10;
               yr1 += xr1 * ar11;
               yr2 += xr1 * ar12;
               yr3 += xr1 * ar13;
               yi0 += xi1 * ar10;
               yi1 += xi1 * ar11;
               yi2 += xi1 * ar12;
               yi3 += xi1 * ar13;
               #ifndef Conj_
                  yr0 -= xi1 * ai10;
                  yr1 -= xi1 * ai11;
                  yr2 -= xi1 * ai12;
                  yr3 -= xi1 * ai13;
                  yi0 += xr1 * ai10;
                  yi1 += xr1 * ai11;
                  yi2 += xr1 * ai12;
                  yi3 += xr1 * ai13;
               #else
                  yr0 += xi1 * ai10;
                  yr1 += xi1 * ai11;
                  yr2 += xi1 * ai12;
                  yr3 += xi1 * ai13;
                  yi0 -= xr1 * ai10;
                  yi1 -= xr1 * ai11;
                  yi2 -= xr1 * ai12;
                  yi3 -= xr1 * ai13;
               #endif
            }
            else  /* 3 rows left to do, 2 rows prefetched */
            {
               yr0 += xr0 * ar00;
               yr1 += xr0 * ar01;
               yr2 += xr0 * ar02;
               yr3 += xr0 * ar03;
               yi0 += xi0 * ar00; ar00 = *A0;
               yi1 += xi0 * ar01; ar01 = *A1;
               yi2 += xi0 * ar02; ar02 = *A2;
               yi3 += xi0 * ar03; ar03 = *A3;
               #ifndef Conj_
                  yr0 -= xi0 * ai00;
                  yr1 -= xi0 * ai01;
                  yr2 -= xi0 * ai02;
                  yr3 -= xi0 * ai03; xi0 = x[1];
                  yi0 += xr0 * ai00; ai00 = A0[1];
                  yi1 += xr0 * ai01; ai01 = A1[1];
                  yi2 += xr0 * ai02; ai02 = A2[1];
                  yi3 += xr0 * ai03; ai03 = A3[1]; xr0 = *x;
               #else
                  yr0 += xi0 * ai00;
                  yr1 += xi0 * ai01;
                  yr2 += xi0 * ai02;
                  yr3 += xi0 * ai03; xi0 = x[1];
                  yi0 -= xr0 * ai00; ai00 = A0[1];
                  yi1 -= xr0 * ai01; ai01 = A1[1];
                  yi2 -= xr0 * ai02; ai02 = A2[1];
                  yi3 -= xr0 * ai03; ai03 = A3[1]; xr0 = *x;
               #endif

               yr0 += xr1 * ar10;
               yr1 += xr1 * ar11;
               yr2 += xr1 * ar12;
               yr3 += xr1 * ar13;
               yi0 += xi1 * ar10;
               yi1 += xi1 * ar11;
               yi2 += xi1 * ar12;
               yi3 += xi1 * ar13;
               #ifndef Conj_
                  yr0 -= xi1 * ai10;
                  yr1 -= xi1 * ai11;
                  yr2 -= xi1 * ai12;
                  yr3 -= xi1 * ai13;
                  yi0 += xr1 * ai10;
                  yi1 += xr1 * ai11;
                  yi2 += xr1 * ai12;
                  yi3 += xr1 * ai13;
               #else
                  yr0 += xi1 * ai10;
                  yr1 += xi1 * ai11;
                  yr2 += xi1 * ai12;
                  yr3 += xi1 * ai13;
                  yi0 -= xr1 * ai10;
                  yi1 -= xr1 * ai11;
                  yi2 -= xr1 * ai12;
                  yi3 -= xr1 * ai13;
               #endif

               yr0 += xr0 * ar00;
               yr1 += xr0 * ar01;
               yr2 += xr0 * ar02;
               yr3 += xr0 * ar03;
               yi0 += xi0 * ar00;
               yi1 += xi0 * ar01;
               yi2 += xi0 * ar02;
               yi3 += xi0 * ar03;
               #ifndef Conj_
                  yr0 -= xi0 * ai00;
                  yr1 -= xi0 * ai01;
                  yr2 -= xi0 * ai02;
                  yr3 -= xi0 * ai03;
                  yi0 += xr0 * ai00;
                  yi1 += xr0 * ai01;
                  yi2 += xr0 * ai02;
                  yi3 += xr0 * ai03;
               #else
                  yr0 += xi0 * ai00;
                  yr1 += xi0 * ai01;
                  yr2 += xi0 * ai02;
                  yr3 += xi0 * ai03;
                  yi0 -= xr0 * ai00;
                  yi1 -= xr0 * ai01;
                  yi2 -= xr0 * ai02;
                  yi3 -= xr0 * ai03;
               #endif
            }
            *Y   = yr0;
            A0 += incAm;
            Y[1] = yi0;
            A1 += incAm;
            Y[2] = yr1;
            A2 += incAm;
            Y[3] = yi1;
            A3 += incAm;
            Y[4] = yr2;
            Y[5] = yi2;
            Y[6] = yr3;
            Y[7] = yi3;
            Y += 8;
         }
         while(Y != stY);
      }
      if (M-M4) gemvMlt4(M-M4, N, A0, lda, X, beta, Y);
   }
   else if (M && N) gemvNlt2(M, N, A, lda, X, beta, Y);
}
@ROUT ATL_cgemvT_2x4_1 ATL_cgemvT_2x2_0 ATL_cgemvT_mm ATL_cgemvT_1x1_1

#ifdef Conj_
@ROUT ATL_cgemvT_mm `   #define TransA AtlasConjTrans`
   #define gemv0 Mjoin(Mjoin(Mjoin(Mjoin(gemvC,NM),_x1),BNM),_y1)
#else
@ROUT ATL_cgemvT_mm `   #define TransA AtlasTrans`
   #define gemv0 Mjoin(Mjoin(Mjoin(Mjoin(gemvT,NM),_x1),BNM),_y1)
#endif
void Mjoin(PATL,gemv0)
   (const int M, const int N, const SCALAR alpha,
    const TYPE *A, const int lda, const TYPE *X, const int incX,
    const SCALAR beta, TYPE *Y, const int incY)
{
@ROUT ATL_cgemvT_1x1_1
   int i, j;
   const int M2 = M<<1, N2 = N<<1;
   #ifdef BETAX
      const TYPE rbeta = *beta, ibeta = beta[1];
   #elif defined(BETAXI0)
      const TYPE rbeta = *beta;
   #endif
   register TYPE ra, ia, rx, ix, ry, iy;

   for (j=0; j != M2; j += 2)
   {
      #ifdef BETA0
         ry = iy = ATL_rzero;
      #elif defined(BETAX)
         rx = rbeta; ix = ibeta;
         ra = Y[j]; ia = Y[j+1];
         ry = ra * rx - ia * ix;
         iy = ra * ix + ia * rx;
      #else
         ry = Y[j];
         iy = Y[j+1];
         #ifdef BETAXI0
            ry *= rbeta;
            iy *= rbeta;
         #endif
      #endif
      for (i=0; i != N2; i += 2)
      {
         ra = A[i+j*lda]; ia = A[i+1+j*lda];
         rx = X[i]; ix = X[i+1];
         ry += ra * rx;
         iy += ra * ix;
         ry MEQ ia * ix;
         iy PEQ ia * rx;
      }
      Y[j] = ry;
      Y[j+1] = iy;
   }
}
@ROUT ATL_cgemvT_2x4_1
   gemv2x4(M, N, A, lda, X, beta, Y);
@ROUT ATL_cgemvT_2x2_0
   const int N2 = (N>>1)<<1, M2 = (M>>1)<<1;
   const int nr = N-N2, incAm = ((lda<<1) - N2)<<1;
   const TYPE *x, *stX = X + (N2<<1), *A0 = A, *A1 = A + (lda<<1);
   TYPE *stY = Y + (M2<<1);
   register TYPE xr0, xi0, xr1, xi1, yr0, yi0, yr1, yi1;
   register TYPE ar00, ai00, ar10, ai10, ar01, ai01, ar11, ai11;
   register TYPE m0, m1, m2, m3;
   #ifndef ATL_PFD
      #define ATL_PFD 8
   #endif

   if (N2)
   {
      if (M2)
      {
         do
         {
            #ifdef BETA0
               yr0 = yi0 = yr1 = yi1 = ATL_rzero;
            #elif defined(BETAX)
               xr0 = *beta; xi0 = beta[1];
               ar00 = *Y; ai00 = Y[1]; ar10 = Y[2]; ai10 = Y[3];
               yr0 = ar00 * xr0 - ai00 * xi0;
               yi0 = ar00 * xi0 + ai00 * xr0;
               yr1 = ar10 * xr0 - ai10 * xi0;
               yi1 = ar10 * xi0 + ai10 * xr0;
            #else
               yr0 = *Y; yi0 = Y[1]; yr1 = Y[2]; yi1 = Y[3];
               #ifdef BETAXI0
                  xr0 = *beta;
                  yr0 *= xr0; yi0 *= xr0;
                  yr1 *= xr0; yi1 *= xr0;
               #endif
            #endif
            x = X + 4;
            ar00 = *A0; ai00 = A0[1]; ar10 = A0[2]; ai10 = A0[3]; A0 += 4;
            xr0 = *X; xi0 = X[1]; xr1 = X[2]; xi1 = X[3];
            ar01 = *A1; ai01 = A1[1]; ar11 = A1[2]; ai11 = A1[3]; A1 += 4;
            m0 = ar00 * xr0;
            m1 = ar01 * xr0;
            m2 = ar00 * xi0;
            m3 = ar01 * xi0;
            if (N2 != 2)
            {
               do
               {
                  ar00 = *A0; ar01 = *A1;
                  yr0 += m0; m0 = ai00 * xi0;
                                  ATL_pfl1R(A0+ATL_PFD); ATL_pfl1R(A1+ATL_PFD);
                  yr1 += m1; m1 = ai01 * xi0; xi0 = x[1];
                  yi0 += m2; m2 = ai00 * xr0; ai00 = A0[1];
                  yi1 += m3; m3 = ai01 * xr0; ai01 = A1[1]; xr0 = *x;
                  #ifndef Conj_
                     yr0 -= m0; m0 = ar10 * xr1;
                     yr1 -= m1; m1 = ar11 * xr1;
                     yi0 += m2; m2 = ar10 * xi1; ar10 = A0[2];
                     yi1 += m3; m3 = ar11 * xi1; ar11 = A1[2];
                  #else
                     yr0 += m0; m0 = ar10 * xr1;
                     yr1 += m1; m1 = ar11 * xr1;
                     yi0 -= m2; m2 = ar10 * xi1; ar10 = A0[2];
                     yi1 -= m3; m3 = ar11 * xi1; ar11 = A1[2];
                  #endif

                  yr0 += m0; m0 = ai10 * xi1;
                  yr1 += m1; m1 = ai11 * xi1; xi1 = x[3];
                  yi0 += m2; m2 = ai10 * xr1; ai10 = A0[3]; A0 += 4;
                  yi1 += m3; m3 = ai11 * xr1; ai11 = A1[3]; A1 += 4;
                         xr1 = x[2]; x += 4; 
                  #ifndef Conj_
                     yr0 -= m0; m0 = ar00 * xr0;
                     yr1 -= m1; m1 = ar01 * xr0;
                     yi0 += m2; m2 = ar00 * xi0;
                     yi1 += m3; m3 = ar01 * xi0;
                  #else
                     yr0 += m0; m0 = ar00 * xr0;
                     yr1 += m1; m1 = ar01 * xr0;
                     yi0 -= m2; m2 = ar00 * xi0;
                     yi1 -= m3; m3 = ar01 * xi0;
                  #endif
               }
               while (x != stX);
            }
/*
 *          Drain pipes & store to Y
 */
            if (nr)
            {
               ar00 = *A0; ar01 = *A1;
               yr0 += m0; m0 = ai00 * xi0;
               yr1 += m1; m1 = ai01 * xi0; xi0 = x[1];
               yi0 += m2; m2 = ai00 * xr0; ai00 = A0[1];
               yi1 += m3; m3 = ai01 * xr0; ai01 = A1[1]; xr0 = *x;
               #ifndef Conj_
                  yr0 -= m0; m0 = ar10 * xr1;
                  yr1 -= m1; m1 = ar11 * xr1;
                  yi0 += m2; m2 = ar10 * xi1;
                  yi1 += m3; m3 = ar11 * xi1;
               #else
                  yr0 += m0; m0 = ar10 * xr1;
                  yr1 += m1; m1 = ar11 * xr1;
                  yi0 -= m2; m2 = ar10 * xi1;
                  yi1 -= m3; m3 = ar11 * xi1;
               #endif

               yr0 += m0; m0 = ai10 * xi1;
               yr1 += m1; m1 = ai11 * xi1;
               yi0 += m2; m2 = ai10 * xr1;
               yi1 += m3; m3 = ai11 * xr1;
               #ifndef Conj_
                  yr0 -= m0; m0 = ar00 * xr0;
                  yr1 -= m1; m1 = ar01 * xr0;
                  yi0 += m2; m2 = ar00 * xi0;
                  yi1 += m3; m3 = ar01 * xi0;
               #else
                  yr0 += m0; m0 = ar00 * xr0;
                  yr1 += m1; m1 = ar01 * xr0;
                  yi0 -= m2; m2 = ar00 * xi0;
                  yi1 -= m3; m3 = ar01 * xi0;
               #endif

               yr0 += m0; m0 = ai00 * xi0;
               yr1 += m1; m1 = ai01 * xi0;
               yi0 += m2; m2 = ai00 * xr0;
               yi1 += m3; m3 = ai01 * xr0;
               #ifndef Conj_
                  yr0 -= m0;
                  yr1 -= m1;
                  yi0 += m2;
                  yi1 += m3;
               #else
                  yr0 += m0;
                  yr1 += m1;
                  yi0 -= m2;
                  yi1 -= m3;
               #endif
            }
            else
            {
               yr0 += m0; m0 = ai00 * xi0;
               yr1 += m1; m1 = ai01 * xi0;
               yi0 += m2; m2 = ai00 * xr0;
               yi1 += m3; m3 = ai01 * xr0;
               #ifndef Conj_
                  yr0 -= m0; m0 = ar10 * xr1;
                  yr1 -= m1; m1 = ar11 * xr1;
                  yi0 += m2; m2 = ar10 * xi1;
                  yi1 += m3; m3 = ar11 * xi1;
               #else
                  yr0 += m0; m0 = ar10 * xr1;
                  yr1 += m1; m1 = ar11 * xr1;
                  yi0 -= m2; m2 = ar10 * xi1;
                  yi1 -= m3; m3 = ar11 * xi1;
               #endif
   
               yr0 += m0; m0 = ai10 * xi1;
               yr1 += m1; m1 = ai11 * xi1;
               yi0 += m2; m2 = ai10 * xr1;
               yi1 += m3; m3 = ai11 * xr1;
               #ifndef Conj_
                  yr0 -= m0;
                  yr1 -= m1;
                  yi0 += m2;
                  yi1 += m3;
               #else
                  yr0 += m0;
                  yr1 += m1;
                  yi0 -= m2;
                  yi1 -= m3;
               #endif
            }
   
            *Y = yr0;
            A0 += incAm;
            Y[1] = yi0;
            Y[2] = yr1;
            A1 += incAm;
            Y[3] = yi1;
            Y += 4;
         }
         while (Y != stY);
      }
      if (M-M2) gemvMlt4(M-M2, N, A0, lda, X, beta, Y);
   }
   else if (M && N) gemvNlt2(M, N, A, lda, X, beta, Y);
@ROUT ATL_cgemvT_mm
   TYPE one[2] = {ATL_rone, ATL_rzero};

   Mjoin(PATL,NCmmJIK)(TransA, AtlasNoTrans, M, 1, N, one, A, lda,
                       X, N, beta, Y, M);
@ROUT ATL_cgemvT_2x4_1 ATL_cgemvT_2x2_0 ATL_cgemvT_mm
@beginskip
   const int incA = lda<<1;
   TYPE *stY = Y + (M<<1);
   TYPE dot[2];
   const register TYPE rbeta = *beta, ibeta = beta[1];
   register TYPE ry, iy, t0;
   if (M)
   {
      if (ibeta == ATL_rzero)
      {
         if (rbeta == ATL_rzero)
         {
            do
            {
               Mjoin(PATL,dotu_sub)(N, X, 1, A, 1, Y);
               Y += 2;
               A += incA;
            }
            while (Y != stY);
         }
         else if (rbeta == ATL_rone)
         {
            do
            {
               ry = *Y;
               iy = Y[1];
               Mjoin(PATL,dotu_sub)(N, X, 1, A, 1, dot);
               ry += *dot;
               iy += dot[1];
               *Y = ry;
               Y[1] = iy;
               Y += 2;
               A += incA;
            }
            while (Y != stY);
         }
         else
         {
            do
            {
               ry = *Y;
               iy = Y[1];
               ry *= rbeta;
               iy *= rbeta;
               Mjoin(PATL,dotu_sub)(N, X, 1, A, 1, dot);
               ry += *dot;
               iy += dot[1];
               *Y = ry;
               Y[1] = iy;
               Y += 2;
               A += incA;
            }
            while (Y != stY);
         }
      }
      else
      {
         do
         {
            t0 = ry = *Y;
            iy = Y[1];
            ry = ry * rbeta - iy * ibeta;
            iy = t0 * ibeta + iy * rbeta;
            Mjoin(PATL,dotu_sub)(N, X, 1, A, 1, dot);
            ry += *dot;
            iy += dot[1];
            *Y = ry;
            Y[1] = iy;
            Y += 2;
            A += incA;
         }
         while (Y != stY);
      }
   }
@endskip
}
@ROUT ATL_gemvT_4x8_1 ATL_gemvT_2x8_0 ATL_gemvT_mm ATL_gemvT_4x16_1 ATL_gemvT_2x16_1 ATL_gemvT_1x1_1
#include "atlas_misc.h"
#include "atlas_level1.h"
#include "atlas_level2.h"
@ROUT ATL_gemvT_mm `#include "atlas_lvl3.h"`
@ROUT ATL_gemvT_4x16_1 ATL_gemvT_2x16_1 `#include "atlas_prefetch.h"`

@ROUT ATL_gemvT_4x8_1 ATL_gemvT_2x8_0 ATL_gemvT_4x16_1
static void gemvT_Nsmall(const int M, const int N, const TYPE *A, const int lda,
                         const TYPE *X, const SCALAR beta, TYPE *Y)
{
   int i;
   register TYPE x0, x1, x2, x3, x4, x5, x6, x7, y0;
   TYPE *stY = Y + M;

   switch(N)
   {
   case 1:
      #ifdef BETA0
         Mjoin(PATL,cpsc)(M, *X, A, lda, Y, 1);
      #elif defined(BETAX)
         Mjoin(PATL,axpby)(M, *X, A, lda, beta, Y, 1);
      #else
         Mjoin(PATL,axpy)(M, *X, A, lda, Y, 1);
      #endif
      break;
   case 2:
      x0 = *X;
      x1 = X[1];
      do
      {
         #ifdef BETA0
            *Y = x0 * *A + x1 * A[1];
         #elif defined(BETAX)
            y0 = *Y;
            *Y = y0 * beta + x0 * *A + x1 * A[1];
         #else
            *Y += x0 * *A + x1 * A[1];
         #endif
         A += lda;
      }
      while (++Y != stY);
      break;
   case 3:
      x0 = *X;
      x1 = X[1];
      x2 = X[2];
      do
      {
         #ifdef BETA0
            *Y = x0 * *A + x1 * A[1] + x2 * A[2];
         #elif defined(BETAX)
            y0 = *Y;
            *Y = y0 * beta + x0 * *A + x1 * A[1] + x2 * A[2];
         #else
            *Y += x0 * *A + x1 * A[1] + x2 * A[2];
         #endif
         A += lda;
      }
      while (++Y != stY);
      break;
   case 4:
      x0 = *X;
      x1 = X[1];
      x2 = X[2];
      x3 = X[3];
      do
      {
         #ifdef BETA0
            *Y = x0 * *A + x1 * A[1] + x2 * A[2] + x3 * A[3];
         #elif defined(BETAX)
            y0 = *Y;
            *Y = y0 * beta + x0 * *A + x1 * A[1] + x2 * A[2] + x3 * A[3];
         #else
            *Y += x0 * *A + x1 * A[1] + x2 * A[2] + x3 * A[3];
         #endif
         A += lda;
      }
      while (++Y != stY);
      break;
   case 5:
      x0 = *X;
      x1 = X[1];
      x2 = X[2];
      x3 = X[3];
      x4 = X[4];
      do
      {
         #ifdef BETA0
            *Y = x0 * *A + x1 * A[1] + x2 * A[2] + x3 * A[3] 
                 + x4 * A[4];
         #elif defined(BETAX)
            y0 = *Y;
            *Y = y0 * beta + x0 * *A + x1 * A[1] + x2 * A[2] + x3 * A[3]
                 + x4 * A[4];
         #else
            *Y += x0 * *A + x1 * A[1] + x2 * A[2] + x3 * A[3] + x4 * A[4];
         #endif
         A += lda;
      }
      while (++Y != stY);
      break;
   case 6:
      x0 = *X;
      x1 = X[1];
      x2 = X[2];
      x3 = X[3];
      x4 = X[4];
      x5 = X[5];
      do
      {
         #ifdef BETA0
            *Y = x0 * *A + x1 * A[1] + x2 * A[2] + x3 * A[3] 
                 + x4 * A[4] + x5 * A[5];
         #elif defined(BETAX)
            y0 = *Y;
            *Y = y0 * beta + x0 * *A + x1 * A[1] + x2 * A[2] + x3 * A[3]
                 + x4 * A[4] + x5 * A[5];
         #else
            *Y += x0 * *A + x1 * A[1] + x2 * A[2] + x3 * A[3]
                 + x4 * A[4] + x5 * A[5];
         #endif
         A += lda;
      }
      while (++Y != stY);
      break;
   case 7:
      x0 = *X;
      x1 = X[1];
      x2 = X[2];
      x3 = X[3];
      x4 = X[4];
      x5 = X[5];
      x6 = X[6];
      do
      {
         #ifdef BETA0
            *Y = x0 * *A + x1 * A[1] + x2 * A[2] + x3 * A[3] 
                 + x4 * A[4] + x5 * A[5] + x6 * A[6];
         #elif defined(BETAX)
            y0 = *Y;
            *Y = y0 * beta + x0 * *A + x1 * A[1] + x2 * A[2] + x3 * A[3]
                 + x4 * A[4] + x5 * A[5] + x6 * A[6];
         #else
            *Y += x0 * *A + x1 * A[1] + x2 * A[2] + x3 * A[3]
                 + x4 * A[4] + x5 * A[5] + x6 * A[6];
         #endif
         A += lda;
      }
      while (++Y != stY);
      break;
   case 8:
      x0 = *X;
      x1 = X[1];
      x2 = X[2];
      x3 = X[3];
      x4 = X[4];
      x5 = X[5];
      x6 = X[6];
      x7 = X[7];
      do
      {
         #ifdef BETA0
            *Y = x0 * *A + x1 * A[1] + x2 * A[2] + x3 * A[3] 
                 + x4 * A[4] + x5 * A[5] + x6 * A[6] + x7 * A[7];
         #elif defined(BETAX)
            y0 = *Y;
            *Y = y0 * beta + x0 * *A + x1 * A[1] + x2 * A[2] + x3 * A[3]
                 + x4 * A[4] + x5 * A[5] + x6 * A[6] + x7 * A[7];
         #else
            *Y += x0 * *A + x1 * A[1] + x2 * A[2] + x3 * A[3]
                 + x4 * A[4] + x5 * A[5] + x6 * A[6] + x7 * A[7];
         #endif
         A += lda;
      }
      while (++Y != stY);
      break;
   default:
      if (M)
      {
         do
         {
            #ifdef BETA0
               y0 = ATL_rzero;
            #elif defined(BETAX)
               y0 = *Y * beta;
            #else
               y0 = *Y;
            #endif
            for (i=0; i != N; i++) y0 += A[i] * X[i];
            *Y++ = y0;
            A += lda;
         }
         while (Y != stY);
      }
   }
}

@ROUT ATL_gemvT_4x8_1 ATL_gemvT_2x8_0 ATL_gemvT_4x16_1 ATL_gemvT_2x16_1
static void gemvT_Msmall(const int M, const int N, const TYPE *A, const int lda,
                         const TYPE *X, const SCALAR beta, TYPE *Y)
{
   const TYPE *stY = Y + M;
   #ifndef BETA0
      register TYPE y0;
   #endif

   do
   {
      #ifdef BETA0
         *Y = Mjoin(PATL,dot)(N, X, 1, A, 1);
      #else
         y0 = *Y;
         #ifdef BETAX
            y0 *= beta;
         #endif
         y0 += Mjoin(PATL,dot)(N, X, 1, A, 1);
         *Y = y0;
      #endif
      Y++;
      A += lda;
   }
   while (Y != stY);
}
@ROUT ATL_gemvT_4x8_1
static void gemvT4x4(const int M, const int N, const TYPE *A, const int lda,
                     const TYPE *X, const SCALAR beta, TYPE *Y)
{
   const int M4 = (M>>2)<<2, N4 = (N>>2)<<2; 
   const int nr = N-N4, incAm = (lda<<2) - N4;
   const TYPE *stX = X + N4, *x; 
   const TYPE *A0 = A, *A1 = A + lda, *A2 = A1 + lda, *A3 = A2 + lda;
   TYPE *stY = Y + M4;
   register TYPE a00, a10, a20, a30, a01, a11, a21, a31;
   register TYPE a02, a12, a22, a32, a03, a13, a23, a33;
   register TYPE y0, y1, y2, y3, yy0, yy1, yy2, yy3;
   register TYPE x0, x1, x2, x3;

   if (N4 > 4)
   {
      if (M4)
      {
         do
         {
            a00 = *A0;   a01 = *A1;   a02 = *A2;   a03 = *A3;
            a10 = A0[1]; a11 = A1[1]; a12 = A2[1]; a13 = A3[1];
            a20 = A0[2]; a21 = A1[2]; a22 = A2[2]; a23 = A3[2];
            a30 = A0[3]; a31 = A1[3]; a32 = A2[3]; a33 = A3[3];
            A0 += 4;     A1 += 4;     A2 += 4;     A3 += 4;
            #ifdef BETA0
               y0 = y1 = y2 = y3 = yy0 = yy1 = yy2 = yy3 = ATL_rzero;
            #elif defined(BETAX)
               y0 = beta;
               yy0 = *Y; yy1 = Y[1]; yy2 = Y[2];  yy3 = Y[3];
               yy0 *= y0; yy1 *= y0; yy2 *= y0; yy3 *= y0;
               y0 = y1 = y2 = y3 = ATL_rzero;
            #else
               yy0 = *Y; yy1 = Y[1]; yy2 = Y[2];  yy3 = Y[3];
               y0 = y1 = y2 = y3 = ATL_rzero;
            #endif
            x0 = *X; x1 = X[1]; x2 = X[2]; x3 = X[3]; x = X + 4;
            do
            {
               y0  += a00 * x0; a00 = *A0;
               y1  += a01 * x0; a01 = *A1;
               yy0 += a10 * x1; a10 = A0[1];
               yy1 += a11 * x1; a11 = A1[1];
               y2  += a02 * x0; a02 = *A2;
               y3  += a03 * x0; a03 = *A3; x0 = *x;
               yy2 += a12 * x1; a12 = A2[1];
               yy3 += a13 * x1; a13 = A3[1]; x1 = x[1];

               y0  += a20 * x2; a20 = A0[2];
               y1  += a21 * x2; a21 = A1[2];
               yy0 += a30 * x3; a30 = A0[3]; A0 += 4;
               yy1 += a31 * x3; a31 = A1[3]; A1 += 4;
               y2  += a22 * x2; a22 = A2[2];
               y3  += a23 * x2; a23 = A3[2]; x2 = x[2];
               yy2 += a32 * x3; a32 = A2[3]; A2 += 4;
               yy3 += a33 * x3; a33 = A3[3]; A3 += 4; x3 = x[3]; x += 4;
            }
            while (x != stX);
            y0  += a00 * x0;
            y1  += a01 * x0;
            yy0 += a10 * x1;
            yy1 += a11 * x1;
            y2  += a02 * x0;
            y3  += a03 * x0;
            yy2 += a12 * x1;
            yy3 += a13 * x1;

            y0  += a20 * x2;
            y1  += a21 * x2;
            yy0 += a30 * x3;
            yy1 += a31 * x3;
            y2  += a22 * x2;
            y3  += a23 * x2;
            yy2 += a32 * x3;
            yy3 += a33 * x3;
            switch(nr)
            {
            case 1:
               x0 = *x;
               y0 += *A0 * x0;
               y1 += *A1 * x0;
               y2 += *A2 * x0;
               y3 += *A3 * x0;
               break;
            case 2:
               x0 = *x;
               x1 = x[1];
               y0  += *A0 * x0;
               y1  += *A1 * x0;
               yy0 += A0[1] * x1;
               yy1 += A1[1] * x1;
               y2  += *A2 * x0;
               y3  += *A3 * x0;
               yy2 += A2[1] * x1;
               yy3 += A3[1] * x1;
               break;
            case 3:
               x0 = *x;
               x1 = x[1];
               x2 = x[2];
               y0  += *A0 * x0;
               y1  += *A1 * x0;
               yy0 += A0[1] * x1;
               yy1 += A1[1] * x1;
               y2  += *A2 * x0;
               y3  += *A3 * x0;
               yy2 += A2[1] * x1;
               yy3 += A3[1] * x1;
               y0  += A0[2] * x2;
               y1  += A1[2] * x2;
               y2  += A2[2] * x2;
               y3  += A3[2] * x2;
               break;
            default:;
            }
            A0 += incAm;
            y0 += yy0;
            A1 += incAm;
            y1 += yy1;
            A2 += incAm;
            y2 += yy2;
            A3 += incAm;
            y3 += yy3;
            *Y = y0;
            Y[1] = y1;
            Y[2] = y2;
            Y[3] = y3;
            Y += 4;
         }
         while (Y != stY);
      }
      if (M-M4) gemvT_Msmall(M-M4, N, A0, lda, X, beta, Y);
   }
   else if (M) gemvT_Nsmall(M, N, A, lda, X, beta, Y);
}
@ROUT ATL_gemvT_2x16_1
static void gemvT2x16(const int M, const int N, const TYPE *A, const int lda,
                      const TYPE *X, const SCALAR beta, TYPE *Y)
{
   int i;
   const int M2 = (M>>1)<<1, N16 = (N>>4)<<4; 
   const int incAm = (N16 ? (lda<<1) - N16 + 16 : (lda<<1));
   const int nr = (N16 ? N-N16+16 : N);
   TYPE *stY = Y + M2;
   const TYPE *stX = X + N16-16, *x; 
   const TYPE *A0 = A, *A1 = A + lda;
   register TYPE y0, y1, x0, x1;
   #ifndef ATL_PFD 
      #define ATL_PFD 12
   #endif

   if (M2)
   {
      do
      {
         #ifdef BETA0
            y0 = y1 = ATL_rzero;
         #elif defined(BETAX)
            y0 = *Y * beta; y1 = beta * Y[1];
         #else
            y0 = *Y; y1 = Y[1];
         #endif
         x = X;
         if (N16 > 16)
         {
            x0 = *x; x1 = x[1];
            do
            {
               y0 += x0 * *A0; ATL_pfl1R(A0+ATL_PFD); ATL_pfl1R(A1+ATL_PFD); 
                               ATL_pfl1R(A0+ATL_PFD+8); ATL_pfl1R(A1+ATL_PFD+8);
               y1 += x0 * *A1; x0 = x[2];
               y0 += x1 * A0[1];
               y1 += x1 * A1[1]; x1 = x[3];
               y0 += x0 * A0[2];
               y1 += x0 * A1[2]; x0 = x[4];
               y0 += x1 * A0[3];
               y1 += x1 * A1[3]; x1 = x[5];
               y0 += x0 * A0[4];
               y1 += x0 * A1[4]; x0 = x[6];
               y0 += x1 * A0[5];
               y1 += x1 * A1[5]; x1 = x[7];
               y0 += x0 * A0[6];
               y1 += x0 * A1[6]; x0 = x[8];
               y0 += x1 * A0[7];
               y1 += x1 * A1[7]; x1 = x[9];
               y0 += x0 * A0[8];  
                  ATL_pfl1R(A0+ATL_PFD+4); ATL_pfl1R(A1+ATL_PFD+4);
                  ATL_pfl1R(A0+ATL_PFD+12); ATL_pfl1R(A1+ATL_PFD+12);
               y1 += x0 * A1[8]; x0 = x[10];
               y0 += x1 * A0[9];
               y1 += x1 * A1[9]; x1 = x[11];
               y0 += x0 * A0[10];
               y1 += x0 * A1[10]; x0 = x[12];
               y0 += x1 * A0[11];
               y1 += x1 * A1[11]; x1 = x[13];
               y0 += x0 * A0[12];
               y1 += x0 * A1[12]; x0 = x[14];
               y0 += x1 * A0[13];
               y1 += x1 * A1[13]; x1 = x[15];
               y0 += x0 * A0[14]; x += 16;
               y1 += x0 * A1[14]; x0 = *x;
               y0 += x1 * A0[15]; A0 += 16;
               y1 += x1 * A1[15]; x1 = x[1]; A1 += 16;
            }
            while(x != stX);
         }
         for (i=0; i != nr; i++)
         {
            x0 = x[i];
            y0 += x0 * A0[i];
            y1 += x0 * A1[i];
         }
         A0 += incAm;
         *Y = y0;
         A1 += incAm;
         Y[1] = y1;
         Y += 2;
      }
      while (Y != stY);
   }
   if (M-M2) gemvT_Msmall(M-M2, N, A0, lda, X, beta, Y);
}
@ROUT ATL_gemvT_4x16_1
static void gemvT4x16(const int M, const int N, const TYPE *A, const int lda,
                      const TYPE *X, const SCALAR beta, TYPE *Y)
{
   int j;
   const int M4 = (M>>2)<<2, N16 = (N>>4)<<4, incAm = (lda<<2) - N; 
   const int nr = ( N16 ? N-N16+16 : N );
   const TYPE *stX = X + N16-16, *x; 
   const TYPE *A0 = A, *A1 = A + lda, *A2 = A1 + lda, *A3 = A2 + lda;
   TYPE *stY = Y + M4;
   register TYPE a00, a01, a02, a03, a10, a11, a12, a13;
   register TYPE b00, b01, b02, b03, b10, b11, b12, b13;
   register TYPE y0, y1, y2, y3, z0, z1, z2, z3;
   register TYPE x0, x1, x2, x3;
   #ifdef ATL_AltiVec
      int cwrd = ATL_MulBySize(N)>>4;     
      if (cwrd >= 64) cwrd = ATL_GetCtrl(512, (cwrd+31)>>5, 0);
      else cwrd = ATL_GetCtrl(64, (cwrd+3)>>2, 4); 
   #endif  


   if (N >= 10)
   {
      if (M4)
      {
         do
         {
            #ifdef ATL_AltiVec
               ATL_pfavR(A0, cwrd, 0);
               ATL_pfavR(A1, cwrd, 1);
               ATL_pfavR(A2, cwrd, 2);
               ATL_pfavR(A3, cwrd, 3);
            #endif

            a00 = *A0;   a01 = *A1;   a02 = *A2;   a03 = *A3;
            a10 = A0[1]; a11 = A1[1]; a12 = A2[1]; a13 = A3[1];
            b00 = A0[8]; b01 = A1[8]; b02 = A2[8]; b03 = A3[8];
            b10 = A0[9]; b11 = A1[9]; b12 = A2[9]; b13 = A3[9];
            #ifdef BETA0
               y0 = y1 = y2 = y3 = z0 = z1 = z2 = z3 = ATL_rzero;
            #elif defined(BETAX)
               y0 = beta;
               z0 = *Y; z1 = Y[1]; z2 = Y[2];  z3 = Y[3];
               z0 *= y0; z1 *= y0; z2 *= y0; z3 *= y0;
               y0 = y1 = y2 = y3 = ATL_rzero;
            #else
               z0 = *Y; z1 = Y[1]; z2 = Y[2];  z3 = Y[3];
               y0 = y1 = y2 = y3 = ATL_rzero;
            #endif
            x0 = *X; x1 = X[1]; x2 = X[8]; x3 = X[9]; x = X;
            if (N16 > 16)
            {
               do
               {
                  y0  += a00 * x0; a00 = A0[2];
                  y1  += a01 * x0; a01 = A1[2];
                  y2  += a02 * x0; a02 = A2[2];
                  y3  += a03 * x0; a03 = A3[2]; x0 = x[2];
                  z0  += b00 * x2; b00 = A0[10];
                  z1  += b01 * x2; b01 = A1[10];
                  z2  += b02 * x2; b02 = A2[10];
                  z3  += b03 * x2; b03 = A3[10]; x2 = x[10];
   
                  y0  += a10 * x1; a10 = A0[3];
                  y1  += a11 * x1; a11 = A1[3];
                  y2  += a12 * x1; a12 = A2[3];
                  y3  += a13 * x1; a13 = A3[3]; x1 = x[3];
                  z0  += b10 * x3; b10 = A0[11];
                  z1  += b11 * x3; b11 = A1[11];
                  z2  += b12 * x3; b12 = A2[11];
                  z3  += b13 * x3; b13 = A3[11]; x3 = x[11];
   
                  y0  += a00 * x0; a00 = A0[4];
                  y1  += a01 * x0; a01 = A1[4];
                  y2  += a02 * x0; a02 = A2[4];
                  y3  += a03 * x0; a03 = A3[4]; x0 = x[4];
                  z0  += b00 * x2; b00 = A0[12];
                  z1  += b01 * x2; b01 = A1[12];
                  z2  += b02 * x2; b02 = A2[12];
                  z3  += b03 * x2; b03 = A3[12]; x2 = x[12];
   
                  y0  += a10 * x1; a10 = A0[5];
                  y1  += a11 * x1; a11 = A1[5];
                  y2  += a12 * x1; a12 = A2[5];
                  y3  += a13 * x1; a13 = A3[5]; x1 = x[5];
                  z0  += b10 * x3; b10 = A0[13];
                  z1  += b11 * x3; b11 = A1[13];
                  z2  += b12 * x3; b12 = A2[13];
                  z3  += b13 * x3; b13 = A3[13]; x3 = x[13];
   
                  y0  += a00 * x0; a00 = A0[6];
                  y1  += a01 * x0; a01 = A1[6];
                  y2  += a02 * x0; a02 = A2[6];
                  y3  += a03 * x0; a03 = A3[6]; x0 = x[6];
                  z0  += b00 * x2; b00 = A0[14];
                  z1  += b01 * x2; b01 = A1[14];
                  z2  += b02 * x2; b02 = A2[14];
                  z3  += b03 * x2; b03 = A3[14]; x2 = x[14];
   
                  y0  += a10 * x1; a10 = A0[7];
                  y1  += a11 * x1; a11 = A1[7];
                  y2  += a12 * x1; a12 = A2[7];
                  y3  += a13 * x1; a13 = A3[7]; x1 = x[7];
                  z0  += b10 * x3; b10 = A0[15]; A0 += 16;
                  z1  += b11 * x3; b11 = A1[15]; A1 += 16;
                  z2  += b12 * x3; b12 = A2[15]; A2 += 16;
                  z3  += b13 * x3; b13 = A3[15]; x3 = x[15]; x += 16; A3 += 16;
   
                  y0  += a00 * x0; a00 = *A0;
                  y1  += a01 * x0; a01 = *A1;
                  y2  += a02 * x0; a02 = *A2;
                  y3  += a03 * x0; a03 = *A3; x0 = *x;
                  z0  += b00 * x2; b00 = A0[8];
                  z1  += b01 * x2; b01 = A1[8];
                  z2  += b02 * x2; b02 = A2[8];
                  z3  += b03 * x2; b03 = A3[8]; x2 = x[8];
   
                  y0  += a10 * x1; a10 = A0[1];
                  y1  += a11 * x1; a11 = A1[1];
                  y2  += a12 * x1; a12 = A2[1];
                  y3  += a13 * x1; a13 = A3[1]; x1 = x[1];
                  z0  += b10 * x3; b10 = A0[9];
                  z1  += b11 * x3; b11 = A1[9];
                  z2  += b12 * x3; b12 = A2[9];
                  z3  += b13 * x3; b13 = A3[9]; x3 = x[9];
               }
               while (x != stX);
            }
            for (j=(nr>>1); j; j--, A0 += 2, A1 += 2, A2 += 2, A3 += 2, x += 2)
            {
               x0 = *x; x1 = x[1];
               y0 += *A0 * x0;
               y1 += *A1 * x0;
               y2 += *A2 * x0;
               y3 += *A3 * x0;
               z0 += A0[1] * x1;
               z1 += A1[1] * x1;
               z2 += A2[1] * x1;
               z3 += A3[1] * x1;
            }
            if (nr != (nr>>1)<<1)
            {
               x0 = *x;
               z0 += *A0++ * x0;
               z1 += *A1++ * x0;
               z2 += *A2++ * x0;
               z3 += *A3++ * x0;
            }
            A0 += incAm;
            y0 += z0;
            A1 += incAm;
            y1 += z1;
            A2 += incAm;
            y2 += z2;
            A3 += incAm;
            y3 += z3;
            *Y = y0;
            Y[1] = y1;
            Y[2] = y2;
            Y[3] = y3;
            Y += 4;
         }
         while (Y != stY);
      }
      if (M-M4) gemvT_Msmall(M-M4, N, A0, lda, X, beta, Y);
   }
   else if (M) gemvT_Nsmall(M, N, A, lda, X, beta, Y);
}

@ROUT ATL_gemvT_4x8_1 ATL_gemvT_2x8_0 ATL_gemvT_mm ATL_gemvT_4x16_1 ATL_gemvT_2x16_1 ATL_gemvT_1x1_1
#define gemv0 Mjoin(Mjoin(Mjoin(Mjoin(gemvT,NM),_x1),BNM),_y1)
void Mjoin(PATL,gemv0)
   (const int M, const int N, const SCALAR alpha,
    const TYPE *A, const int lda, const TYPE *X, const int incX,
    const SCALAR beta, TYPE *Y, const int incY)
{
@ROUT ATL_gemvT_1x1_1
   int i, j;
   for (j=0; j != M; j++)
   {
      #ifdef BETA0
         Y[j] = ATL_rzero;
      #elif defined(BETAX)
         Y[j] *= beta;
      #endif
      for (i=0; i != N; i++) Y[j] += A[i+j*lda] * X[i];
   }
}
@ROUT ATL_gemvT_2x16_1
   gemvT2x16(M, N, A, lda, X, beta, Y);
@ROUT ATL_gemvT_4x16_1
   gemvT4x16(M, N, A, lda, X, beta, Y);
@ROUT ATL_gemvT_4x8_1
   gemvT4x4(M, N, A, lda, X, beta, Y);
@ROUT ATL_gemvT_2x8_0

   const int M2 = (M>>1)<<1, n4 = (N>>2)<<2; 
   const int nr = N-n4, incAm = (lda<<1) - n4;
   const TYPE *stX = X + n4 - 4, *x, *A0 = A, *A1 = A + lda;
   TYPE *stY = Y + M2;
   register TYPE y0, y1, yy0, yy1, x0, x1, x2, x3, m0, m1, m2, m3;
   register TYPE a00, a10, a20, a30, a01, a11, a21, a31;

   if (N >= 8)
   {
      if (M2)
      {
         do
         {
            x = X + 4;
            #ifdef BETA0
               y0 = y1 = yy0 = yy1 = ATL_rzero;
            #elif defined(BETAX)
               y0 = beta;
               yy0 = *Y * y0; yy1 = Y[1] * y0;
               y0 = y1 = ATL_rzero;
            #else
               yy0 = *Y; yy1 = Y[1];
               y0 = y1 = ATL_rzero;
            #endif
            a00 = *A0; a10 = A0[1]; a20 = A0[2]; a30 = A0[3]; A0 += 4;
            a01 = *A1; a11 = A1[1]; a21 = A1[2]; a31 = A1[3]; A1 += 4;
            x0 = *X; x1 = X[1]; x2 = X[2]; x3 = X[3];
            m0 = a00 * x0; a00 = *A0;
            m1 = a01 * x0; a01 = *A1; x0 = *x;
            m2 = a10 * x1; a10 = A0[1];
            m3 = a11 * x1; a11 = A1[1]; x1 = x[1];

            if (n4 != 8)
            {
               do
               {
                  y0  += m0; m0 = a20 * x2; a20 = A0[2];
                  y1  += m1; m1 = a21 * x2; a21 = A1[2]; x2 = x[2];
                  yy0 += m2; m2 = a30 * x3; a30 = A0[3]; A0 += 4;
                  yy1 += m3; m3 = a31 * x3; a31 = A1[3]; A1 += 4; 
                             x3 = x[3]; x += 4;
                  y0  += m0; m0 = a00 * x0; a00 = *A0;
                  y1  += m1; m1 = a01 * x0; a01 = *A1;   x0 = *x;
                  yy0 += m2; m2 = a10 * x1; a10 = A0[1];
                  yy1 += m3; m3 = a11 * x1; a11 = A1[1]; x1 = x[1];
               }
               while (x != stX);
            }
/*
 *          Drain pipes, then do cleanup
 */
            y0  += m0; m0 = a20 * x2; a20 = A0[2];
            y1  += m1; m1 = a21 * x2; a21 = A1[2]; x2 = x[2];
            yy0 += m2; m2 = a30 * x3; a30 = A0[3]; A0 += 4;
            yy1 += m3; m3 = a31 * x3; a31 = A1[3]; A1 += 4; x3 = x[3]; x += 4;
            y0  += m0; m0 = a00 * x0;
            y1  += m1; m1 = a01 * x0; 
            yy0 += m2; m2 = a10 * x1; 
            yy1 += m3; m3 = a11 * x1; 

            y0  += m0; m0 = a20 * x2;
            y1  += m1; m1 = a21 * x2;
            yy0 += m2; m2 = a30 * x3;
            yy1 += m3; m3 = a31 * x3;
            y0  += m0;
            y1  += m1;
            yy0 += m2;
            yy1 += m3;

            switch(nr)
            {
            case 1:
               x0 = *x;
               y0 += *A0 * x0;
               y1 += *A1 * x0;
               break;
            case 2:
               x0 = *x;
               x1 = x[1];
               y0  += *A0 * x0;
               y1  += *A1 * x0;
               yy0 += A0[1] * x1;
               yy1 += A1[1] * x1;
               break;
            case 3:
               x0 = *x;
               x1 = x[1];
               x2 = x[2];
               y0  += *A0 * x0;
               y1  += *A1 * x0;
               yy0 += A0[1] * x1;
               yy1 += A1[1] * x1;
               y0  += A0[2] * x2;
               y1  += A1[2] * x2;
               break;
            default:;
            }
            A0 += incAm;
            y0 += yy0;
            A1 += incAm;
            y1 += yy1;
            *Y = y0;
            Y[1] = y1;
            Y += 2;
         }
         while (Y != stY);
      }
      if (M-M2)
      {
         #ifdef BETA0
            *Y = Mjoin(PATL,dot)(N, X, 1, A0, 1);
         #else
            y0 = *Y;
            #ifdef BETAX
               y0 *= beta;
            #endif
            y0 += Mjoin(PATL,dot)(N, X, 1, A0, 1);
            *Y = y0;
         #endif
      }
   }
   else if (M) gemvT_Nsmall(M, N, A, lda, X, beta, Y);

@ROUT ATL_gemvT_mm

   Mjoin(PATL,NCmmJIK)(AtlasTrans, AtlasNoTrans, M, 1, N, ATL_rone, A, lda,
                       X, N, beta, Y, M);

@ROUT ATL_gemvT_4x8_1 ATL_gemvT_2x8_0 ATL_gemvT_mm ATL_gemvT_4x16_1 ATL_gemvT_2x16_1
}
@ROUT ATL_gemvT_old
#include "atlas_misc.h"
#include "atlas_level1.h"
#include "atlas_level2.h"
#define ATL_NOMULADD
#define ATL_mmnreg 7

void Mjoin(Mjoin(Mjoin(Mjoin(Mjoin(PATL,gemvT),NM),_x1),BNM),_y1)
   (const int M, const int N, const SCALAR alpha, const TYPE *A, const int lda,
    const TYPE *X, const int incX, const SCALAR beta, TYPE *Y, const int incY)
{
#if defined(ATL_NOMULADD)
   const int M2 = (M>>1)<<1;
   int ib, n4, nr, incA, i;
   const TYPE *pA0=A, *pA1 = A + lda;
   const TYPE *x, *stX;
   TYPE *y=Y, *stY = Y + M2;
   #if ATL_mmnreg >= 18
      register TYPE m0, m1, m2, m3, x0, x1, y0, y1, yy0, yy1;
      register TYPE a00, a10, a20, a30, a01, a11, a21, a31;
   #else
      register TYPE m0, m1, m2, m3, y0, y1, x0;
   #endif

   ATL_FindPtrAdjust(A, ib);
   if (ib > N) ib = N;
   n4 = ((N-ib)>>2)<<2;
   nr = N - ib - n4;
   stX = X + ib + (n4 - 4);
   incA = lda + lda - (N-nr);
@skip fprintf(stderr, "line %d of %s: ib=%d, n4=%d, nr=%d\n", __LINE__,__FILE__,ib,n4,nr);

   if (M2)
   {
      do
      {
         x = X + (ib SHIFT);
         #if ATL_mmnreg >= 18
            #ifdef BETA0
               yy0 = yy1 = ATL_rzero;
            #elif defined(BETA1)
               yy0 = *y; yy1 = y[1];
            #else
               yy0 = *y; yy1 = y[1];
               yy0 *= beta;  yy1 *= beta;
            #endif
         #elif !defined(BETA0)
            m0 = *y;
            m1 = y[1];
            #ifndef BETA1
               m0 *= beta;
               m1 *= beta;
            #endif
         #endif
         if (ib)  /* partial first block to get alignment on cache boundary */
         {
            switch(ib)
            {
            case 1:
               y0 = *pA0++ * *X;
               y1 = *pA1++ * *X;
               break;
            case 2:
               y0 = *pA0 * *X + pA0[1] * X[1];
               y1 = *pA1 * *X + pA1[1] * X[1];
               pA0 += 2;
               pA1 += 2;
               break;
            case 3:
               y0 = *pA0 * *X + pA0[1] * X[1] + pA0[2] * X[2];
               y1 = *pA1 * *X + pA1[1] * X[1] + pA1[2] * X[2];
               pA0 += 3;
               pA1 += 3;
               break;
            case 4:
               y0 = *pA0 * *X + pA0[1] * X[1] + pA0[2] * X[2] + pA0[3] * X[3];
               y1 = *pA1 * *X + pA1[1] * X[1] + pA1[2] * X[2] + pA1[3] * X[3];
               pA0 += 4;
               pA1 += 4;
               break;
            case 5:
               y0 = *pA0 * *X + pA0[1] * X[1] + pA0[2] * X[2] + pA0[3] * X[3] + 
                    pA0[4] * X[4];
               y1 = *pA1 * *X + pA1[1] * X[1] + pA1[2] * X[2] + pA1[3] * X[3] + 
                    pA1[4] * X[4];
               pA0 += 5;
               pA1 += 5;
               break;
            case 6:
               y0 = *pA0 * *X + pA0[1] * X[1] + pA0[2] * X[2] + pA0[3] * X[3] + 
                    pA0[4] * X[4] + pA0[5] * X[5];
               y1 = *pA1 * *X + pA1[1] * X[1] + pA1[2] * X[2] + pA1[3] * X[3] + 
                    pA1[4] * X[4] + pA1[5] * X[5];
               pA0 += 6;
               pA1 += 6;
               break;
            case 7:
               y0 = *pA0 * *X + pA0[1] * X[1] + pA0[2] * X[2] + pA0[3] * X[3] + 
                    pA0[4] * X[4] + pA0[5] * X[5] + pA0[6] * X[6];
               y1 = *pA1 * *X + pA1[1] * X[1] + pA1[2] * X[2] + pA1[3] * X[3] + 
                    pA1[4] * X[4] + pA1[5] * X[5] + pA1[6] * X[6];
               pA0 += 7;
               pA1 += 7;
               break;
            default:
               for (i=0; i != ib; i++)
               {
                  y0 += pA0[i] * X[i];
                  y1 += pA1[i] * X[i];
               }
               pA0 += ib;
               pA1 += ib;
            }
         }
         else y0 = y1 = ATL_rzero;
/*
 *       Perform 4x2 unrolling, 4-cycle fp latency hiding, with prefetch
 */
   #if ATL_mmnreg >= 18
         if (n4)  /* can do 4 unrolling */
         {
            a00 = *pA0, a01 = *pA1;
            x0 = *x; x1 = x[1];
            a10 = pA0[1]; a11 = pA1[1];
            a20 = pA0[2]; a21 = pA1[2];
            a30 = pA0[3]; a31 = pA1[3];
            pA0 += 4; pA1 += 4;
            m0 = x0 * a00;  a00 = *pA0;
            m1 = x0 * a01;  a01 = *pA1;
            x0 = x[2];
            m2 = x1 * a10;  a10 = pA0[1];
            m3 = x1 * a11;  a11 = pA1[1];
            x1 = x[3];
            x += 4;
            if (x != stX)
            {
               do
               {
                  y0 += m0;
                  m0 = x0 * a20;
                  a20 = pA0[2];
                  y1 += m1;
                  m1 = x0 * a21;
                  x0 = *x;
                  a21 = pA1[2];
                  yy0 += m2;
                  m2 = a30 * x1;
                  a30 = pA0[3];
                  pA0 += 4;
                  yy1 += m3;
                  m3 = a31 * x1;
                  a31 = pA1[3];
                  x1 = X[1];
                  pA1 += 4;
                  y0 += m0;
                  m0 = x0 * a00;
                  a00 = *pA0;
                  y1 += m1;
                  m1 = x0 * a01;
                  a01 = *pA1;
                  x0 = x[2];
                  yy0 += m2;
                  m2 = x1 * a10;
                  a10 = pA0[1];
                  yy1 += m3;
                  m3 = x1 * a11;
                  a11 = pA1[1];
                  x1 = x[3];
                  x += 4;
               }
               while (x != stX);
            }
            y0 += m0;
            m0 = x0 * a20;
            y1 += m1;
            m1 = x0 * a21;
            yy0 += m2;
            m2 = a30 * x1;
            yy1 += m3;
            m3 = a31 * x1;
            y0 += m0;
            pA0 += 4;
            y1 += m1;
            pA1 += 4;
            yy0 += m2;
            x += 4;
            yy1 += m3;
         }
   #else  /* low register code (i.e., x86) */
         #ifndef BETA0
            y0 += m0;
            y1 += m1;
         #endif
         if (n4)  /* can do 4 unrolling */
         {
            m0 = *pA0;
            m1 = *pA1;
            x0 = *x;
            m2 = pA0[1];
            m3 = pA1[1];
            m0 *= x0;
            m1 *= x0;
            x0 = x[1];
            m2 *= x0;
            m3 *= x0;
            x0 = x[2];
            if (n4 != 4)
            {
               do
               {
                  y0 += m0;
                  m0 = pA0[2] * x0;
                  y1 += m1;
                  m1 = pA1[2] * x0;
                  x0 = x[3];
                  x += 4;
                  y0 += m2;
                  m2 = pA0[3] * x0;
                  pA0 += 4;
                  y1 += m3;
                  m3 = pA1[3] * x0;
                  x0 = *x;
                  pA1 += 4;
                  y0 += m0;
                  m0 = *pA0 * x0;
                  y1 += m1;
                  m1 = *pA1 * x0;
                  x0 = x[1];
                  y0 += m2;
                  m2 = pA0[1] * x0;
                  y1 += m3;
                  m3 = pA1[1] * x0;
                  x0 = x[2];
               }
               while (x != stX);
            }
            y0 += m0;
            m0 = pA0[2] * x0;
            y1 += m1;
            m1 = pA1[2] * x0;
            x0 = x[3];
            y0 += m2;
            m2 = pA0[3] * x0;
            y1 += m3;
            m3 = pA1[3] * x0;
            y0 += m0;
            pA0 += 4;
            y1 += m1;
            pA1 += 4;
            y0 += m2;
            x += 4;
            y1 += m3;
         }
   #endif
   
         switch(nr)  /* cleanup last part of loop */
         {
         case 1:
            y0 += *pA0 * *x;
            y1 += *pA1 * *x;
            break;
         case 2:
            y0 += *pA0 * *x + pA0[1] * x[1];
            y1 += *pA1 * *x + pA1[1] * x[1];
            break;
         case 3:
            y0 += *pA0 * *x + pA0[1] * x[1] + pA0[2] * x[2];
            y1 += *pA1 * *x + pA1[1] * x[1] + pA1[2] * x[2];
            break;
         case 0 : ;
         }
         #if ATL_mmnreg >= 18
            y0 += yy0;
            y1 += yy1;
         #endif
         *y = y0;
         y[1] = y1;
         y += 2;
         pA0 += incA;
         pA1 += incA;
      }
      while(y != stY);
   }
   #ifdef BETA0
      if (M != M2) *y = Mjoin(PATL,dot)(N, X, 1, pA0, 1);
   #elif defined BETA1
      if (M != M2) *y += Mjoin(PATL,dot)(N, X, 1, pA0, 1);
   #else
      if (M != M2) *y = beta * *y + Mjoin(PATL,dot)(N, X, 1, pA0, 1);
   #endif
#else
   void Mjoin(PATL,refgemv)
   (const enum ATLAS_TRANS TA, const int M, const int N, const SCALAR alpha,
    const TYPE *A, const int lda, const TYPE *X, const int incX,
    const SCALAR beta, TYPE *Y, const int incY);

   Mjoin(PATL,refgemv)(TransA, M, N, alpha, A, lda, X, incX, beta, Y, incY);
#endif
}
@ROUT ATL_trmvUT
#include "atlas_misc.h"
#include "atlas_lvl2.h"
#include "atlas_level2.h"
#include "atlas_mv.h"

#ifndef Conj_
   #define gemv0 Mjoin(PATL,gemvT_a1_x1_b0_y1)
   #define gemv Mjoin(PATL,gemvT_a1_x1_b1_y1)
   #define trmv Mjoin(PATL,trmvUT)
   #define ktrmvN Mjoin(PATL,ktrmvUTN)
   #define ktrmvU Mjoin(PATL,ktrmvUTU)
#else
   #define gemv0 Mjoin(PATL,gemvC_a1_x1_b0_y1)
   #define gemv Mjoin(PATL,gemvC_a1_x1_b1_y1)
   #define trmv Mjoin(PATL,trmvUC)
   #define ktrmvN Mjoin(PATL,ktrmvUCN)
   #define ktrmvU Mjoin(PATL,ktrmvUCU)
#endif
void trmv(const enum ATLAS_DIAG Diag, const int N, const TYPE *A, const int lda,
          const TYPE *X, TYPE *Y)
{
   int i, mb;
   int incA;
   #ifdef TCPLX
      TYPE one[3] = {ATL_rone, ATL_rzero, ATL_rzero}, *zero = one + 1;
      int incmb;
   #else
      #define one ATL_rone
      #define zero ATL_rzero
      #define incmb mb
   #endif
   void (*ktrmv)(const int N, const TYPE *A, const int lda, 
                 const TYPE *X, const int BetaIsOne, TYPE *Y);

   if (Diag == AtlasNonUnit) ktrmv = ktrmvN;
   else ktrmv = ktrmvU;

   ATL_GetPartMVT(A, lda, &mb, &i);
   mb = Mmin(mb, N);
   #ifdef TCPLX
      incmb = mb SHIFT;
   #endif
   incA = lda * incmb;

   ktrmv(mb, A, lda, X, 0, Y);
   if (mb != N)
   {
      A += incA; Y += incmb;
      gemv0(N-mb, mb, one, A, lda, X, 1, zero, Y, 1);
      X += incmb; A += incmb;
   
      for (i=mb; i < N; i += mb)
      {
         mb = Mmin(mb, N-i);
         ktrmv(mb, A, lda, X, 1, Y);
         A += incA; Y += incmb;
         gemv(N-i-mb, mb, one, A, lda, X, 1, one, Y, 1);
         X += incmb; A += incmb;
      }
   }
}
@ROUT symv
void Mjoin(PATL,symvL)(const int N, const SCALAR alpha, const TYPE *A,
                       const int lda, const TYPE *X, const int incX,
                       const SCALAR beta, TYPE *Y, const int incY)
{
/*
 * Figure partioning for A
 */
   ATL_GetPartMVN(A, lda, &mb, &i);
   ATL_GetPartMVT(A, lda, &i, &nb);
   if (ATL_pagesize > lda) maxNB = (ATL_pagesize / lda) * ATL_ntlb;
   else maxNB = ATL_ntlb;
   nb = ATL_lcm(mb, nb);
   size = (3*L1C_ELTS)>>3;
   while (nb*(2+nb) < size) nb >>= 1;
   nb <<= 1;

/*
 * Figure mb & nb partitioning for A
 */
   size = (3*L1C_ELTS)>>3;
   while (mb+nb+mb*nb < size)
   {
      if (mb<<1 <= maxNB) mb <<= 1;
      nb <<= 1;
      if (mb+nb+mb*nb > size)
      {
         nb >>= 1;
         break;
      }
   }
   if (mb+nb+mb*nb > size) mb >>= 1;
   ksymv(AtlasLower, nb
}
@ROUT mvtest
#include "atlas_misc.h"
#include "atlas_tst.h"
#include "atlas_lvl2.h"
int FAx=0, MAx=0, FAy=0, MAy=0, FAa=0, MAa=0;
@extract -b @(topd)/FAmalloc.inc

int CheckAns(int M, int N, SCALAR beta, TYPE *Y, TYPE *Y0)
{
   TYPE eps, diff;
   #ifdef TCPLX
      const int M2 = M<<1, mul=8;
   #else
      const int M2 = M, mul=4;
   #endif
   int i, ierr=0;

   eps = Mjoin(PATL,epsilon)();
   for (i=0; i < M2; i++)
   {
      diff = Y0[i] - Y[i];
      if (diff < 0.0) diff = -diff;
      if (diff > N*mul*eps + 2.0*eps)
      {
         ierr = i+1;
         fprintf(stderr, "Y[%d] = %f, expected %f\n", i, Y[i], Y0[i]);
      }
   }
   return(ierr);
}

#ifdef TREAL
static void dumb_gemv(enum ATLAS_TRANS TA, int M, int N, SCALAR alpha, 
                      TYPE *A, int lda, TYPE *X, SCALAR beta, TYPE *Y)
{
   register TYPE y0;
   int i, j;

   ATL_assert(alpha == ATL_rone);
   if (beta == ATL_rzero) Mjoin(PATL,zero)(M, Y, 1);
   else if (beta != ATL_rone) Mjoin(PATL,scal)(M, beta, Y, 1);

   if (TA == AtlasNoTrans)
   {
      for (j=0; j < N; j++) Mjoin(PATL,axpy)(M, X[j], A+j*lda, 1, Y, 1);
   }
   else
   {
      for (i=0; i < M; i++)
      {
         y0 = Y[i];
         for (j=0; j < N; j++) y0 += A[i*lda+j] * X[j];
         Y[i] = y0;
      }
   }
}
#else
static void dumb_gemv(enum ATLAS_TRANS TA, int M, int N, SCALAR alpha, 
                      TYPE *A, int lda, TYPE *X, SCALAR beta, TYPE *Y)
{
   register TYPE ry, iy, rx, ix, ra, ia;
   int i, j;
   const int M2 = M<<1, N2 = N<<1;

   ATL_assert(SCALAR_IS_ONE(alpha));
   if ( SCALAR_IS_ZERO(beta) ) Mjoin(PATL,zero)(M, Y, 1);
   else if ( !SCALAR_IS_ONE(beta) ) Mjoin(PATL,scal)(M, beta, Y, 1);

   if (TA == AtlasNoTrans)
      for (j=0; j < N; j++) Mjoin(PATL,axpy)(M, X+2*j, A+j*2*lda, 1, Y, 1);
   else if (TA == AtlasConj)
      for (j=0; j < N; j++) Mjoin(PATL,axpyConj)(M, X+2*j, A+j*2*lda, 1, Y, 1);
   else if (TA == AtlasTrans)
   {
      for (i=0; i < M2; i += 2)
      {
         ry = Y[i];
         iy = Y[i+1];
         for (j=0; j < N2; j += 2)
         {
            ra = A[i*lda+j]; ia = A[i*lda+j+1];
            rx = X[j];       ix = X[j+1];
            ry += rx * ra - ix * ia;
            iy += rx * ia + ix * ra;
         }
         Y[i] = ry;
         Y[i+1] = iy;
      }
   }
   else if (TA == AtlasConjTrans)
   {
      for (i=0; i < M2; i += 2)
      {
         ry = Y[i];
         iy = Y[i+1];
         for (j=0; j < N2; j += 2)
         {
            ra = A[i*lda+j]; ia = -A[i*lda+j+1];
            rx = X[j];       ix = X[j+1];
            ry += rx * ra - ix * ia;
            iy += rx * ia + ix * ra;
         }
         Y[i] = ry;
         Y[i+1] = iy;
      }
   }
}
#endif

int RunTest(enum ATLAS_TRANS TA, int M, int N, int lda, TYPE *beta0)
{
   #ifdef TCPLX
      TYPE alpha[2] = {ATL_rone, ATL_rzero};
      #define beta beta0
   #else
      TYPE alpha= ATL_rone;
      TYPE beta = *beta0;
   #endif
   TYPE *A, *X, *Y, *Y0;
   int mA, nA, ierr;
   char cta, ln[32];

   if (TA == AtlasNoTrans) cta = 'N';
   else if (TA == AtlasTrans) cta = 'T';
   else if (TA == AtlasConjTrans) cta = 'C';
   else cta = '-';
   if (TA == AtlasNoTrans || TA == AtlasConj) { mA = M; nA = N; }
   else { mA = N; nA = M; }

   #ifdef TREAL
      fprintf(stdout, "   TEST TA=%c, M=%d, N=%d, lda=%d, beta=%f STARTED\n",
              cta, M, N, lda, beta);
   #else
      fprintf(stdout, 
              "   TEST TA=%c, M=%d, N=%d, lda=%d, beta=(%f,%f) STARTED\n",
              cta, M, N, lda, *beta, beta[1]);
   #endif
   A = FA_malloc(lda * ATL_MulBySize(nA), FAa, MAa);
   X = FA_malloc(ATL_MulBySize(N), FAx, MAx);
   Y = FA_malloc(ATL_MulBySize(M), FAy, MAy);
   Y0 = FA_malloc(ATL_MulBySize(M), FAy, MAy);
   ATL_assert(A && X && Y && Y0);
   Mjoin(PATL,gegen)(mA, nA, A, lda, M*N+lda);
   Mjoin(PATL,gegen)(N, 1, X, N, N*1139+52);
   if ( !SCALAR_IS_ZERO(beta) )
   {
      Mjoin(PATL,gegen)(M, 1, Y, M, M*8897+112);
      Mjoin(PATL,gegen)(M, 1, Y0, M, M*8897+112);
   }

   if (TA == AtlasNoTrans)
   {
      if ( SCALAR_IS_ZERO(beta) )
         Mjoin(PATL,gemvN_a1_x1_b0_y1)(M, N, alpha, A, lda, X, 1, 
                                       beta, Y, 1);
      else if ( SCALAR_IS_ONE(beta) )
         Mjoin(PATL,gemvN_a1_x1_b1_y1)(M, N, alpha, A, lda, X, 1, 
                                       beta, Y, 1);
      #ifdef TCPLX
         else if (beta[1] == ATL_rzero)
            Mjoin(PATL,gemvN_a1_x1_bXi0_y1)(M, N, alpha, A, lda, X, 1, 
                                            beta, Y, 1);
      #endif
      else
         Mjoin(PATL,gemvN_a1_x1_bX_y1)(M, N, alpha, A, lda, X, 1, 
                                       beta, Y, 1);
   }
   else if (TA == AtlasTrans)
   {
      if ( SCALAR_IS_ZERO(beta) )
         Mjoin(PATL,gemvT_a1_x1_b0_y1)(M, N, alpha, A, lda, X, 1, 
                                       beta, Y, 1);
      else if ( SCALAR_IS_ONE(beta) )
         Mjoin(PATL,gemvT_a1_x1_b1_y1)(M, N, alpha, A, lda, X, 1, 
                                       beta, Y, 1);
      #ifdef TCPLX
         else if (beta[1] == ATL_rzero)
            Mjoin(PATL,gemvT_a1_x1_bXi0_y1)(M, N, alpha, A, lda, X, 1, 
                                            beta, Y, 1);
      #endif
      else
         Mjoin(PATL,gemvT_a1_x1_bX_y1)(M, N, alpha, A, lda, X, 1, 
                                       beta, Y, 1);
   }
   #ifdef TCPLX
      else if (TA == AtlasConj)
      {
         if (beta[1] == ATL_rzero)
         {
            if (*beta == ATL_rzero)
               Mjoin(PATL,gemvNc_a1_x1_b0_y1)(M, N, alpha, A, lda, X, 1, 
                                              beta, Y, 1);
            else if (*beta == ATL_rone)
               Mjoin(PATL,gemvNc_a1_x1_b1_y1)(M, N, alpha, A, lda, X, 1, 
                                              beta, Y, 1);
            else
               Mjoin(PATL,gemvNc_a1_x1_bXi0_y1)(M, N, alpha, A, lda, X, 1, 
                                                beta, Y, 1);
         }
         else Mjoin(PATL,gemvNc_a1_x1_bX_y1)(M, N, alpha, A, lda, X, 1, 
                                             beta, Y, 1);
      }
      else if (TA == AtlasConjTrans)
      {
         if (beta[1] == ATL_rzero)
         {
            if (*beta == ATL_rzero)
               Mjoin(PATL,gemvC_a1_x1_b0_y1)(M, N, alpha, A, lda, X, 1, 
                                             beta, Y, 1);
            else if (*beta == ATL_rone)
               Mjoin(PATL,gemvC_a1_x1_b1_y1)(M, N, alpha, A, lda, X, 1, 
                                             beta, Y, 1);
            else
               Mjoin(PATL,gemvC_a1_x1_bXi0_y1)(M, N, alpha, A, lda, X, 1, 
                                               beta, Y, 1);
         }
         else Mjoin(PATL,gemvC_a1_x1_bX_y1)(M, N, alpha, A, lda, X, 1, 
                                            beta, Y, 1);
      }
   #endif
   dumb_gemv(TA, M, N, alpha, A, lda, X, beta, Y0);

   FA_free(A, FAa, MAa);
   FA_free(X, FAx, MAx);

   ierr = CheckAns(M, N, beta, Y, Y0);

   FA_free(Y, FAy, MAy);
   FA_free(Y0, FAy, MAy);

   if (ierr) sprintf(ln, "FAILED");
   else sprintf(ln, "PASSED");
   #ifdef TREAL
      fprintf(stdout, "   TEST TA=%c, M=%d, N=%d, lda=%d, beta=%f %s\n",
              cta, M, N, lda, beta, ln);
   #else
      fprintf(stdout, "   TEST TA=%c, M=%d, N=%d, lda=%d, beta=(%f,%f) %s\n",
              cta, M, N, lda, *beta, beta[1], ln);
   #endif
@skip   A = malloc(lda * ATL_MulBySize(nA));
   return(ierr);
}

int RunTests(enum ATLAS_TRANS TA, int M, int N, int lda, SCALAR beta)
{
   int ierr = 0, i;
   #ifdef TREAL
      int nbeta = 3, incb = 1;
      TYPE betas[3];
   #else
      int nbeta = 8, incb = 2;
      TYPE betas[8];
   #endif

   #ifdef TREAL
      betas[0] = ATL_rzero;
      betas[1] = ATL_rone;
      betas[2] = beta;
   #else
      betas[0] = betas[1] = betas[3] = betas[5] = ATL_rzero;
      betas[2] = ATL_rone;
      betas[4] = betas[6] = *beta;
      betas[7] = beta[1];
   #endif
   for (i=0; i < nbeta; i += incb)
   {
      if (TA == AtlasNoTrans)
      {
         ierr = RunTest(AtlasNoTrans, M, N, lda, &betas[i]);
         if (ierr) break;
         #ifdef TCPLX
            ierr = RunTest(AtlasConj, M, N, lda, &betas[i]);
            if (ierr) break;
         #endif
      }
      else
      {
         ierr = RunTest(AtlasTrans, M, N, lda, &betas[i]);
         if (ierr) break;
         #ifdef TCPLX
            ierr = RunTest(AtlasConjTrans, M, N, lda, &betas[i]);
            if (ierr) break;
         #endif
      }
   }
   return(ierr);
}

void PrintUsage(char *nam)
{
   fprintf(stderr, "usage: %s -A t/n -m <M> -n <N> -l <lda> -b <betaX>\n", nam);
   exit(-1);
}

void GetFlags(int nargs, char **args, enum ATLAS_TRANS *TA, 
              int *M0, int *MN, int *incM, int *N0, int *NN, int *incN,
              int *lda, TYPE *beta)
{
   int i, k;
   char ch;

   *TA = AtlasNoTrans;
   *M0 = *MN = *incM = 997;
   *N0 = *NN = *incN = 177;
   *lda = 0;
   *beta = 0.8;
   #ifdef TCPLX
      beta[1] = 0.3;
   #endif
   for (i=1; i < nargs; i++)
   {
      if (args[i][0] != '-') PrintUsage(args[0]);
      switch(args[i][1])
      {
      case 'F':
         ch = args[i][2];
         k = atoi(args[++i]);
         if (ch == 'a')
         {
            if (k < 0)
              MAa = -k;
            else 
              FAa = k;
         }
         else if (args[i][2] == 'y')
         {
            if (k < 0)
              MAy = -k;
            else 
              FAy = k;
         }
         else
         {
            if (k < 0)
              MAx = -k;
            else 
              FAx = k;
         }
         break;
      case 'A':
         i++;
         if (args[i][0] == 'N' || args[i][0] == 'n') *TA = AtlasNoTrans;
         else if (args[i][0] == 'T' || args[i][0] == 't') *TA = AtlasTrans;
         else if (args[i][0] == 'C' || args[i][0] == 'c') *TA = AtlasConjTrans;
         else PrintUsage(args[0]);
         break;
      case 'm':
         *M0 = *MN = atoi(args[++i]);
         break;
      case 'n':
         *N0 = *NN = atoi(args[++i]);
         break;
      case 'M':
         *M0 = atoi(args[++i]);
         *MN = atoi(args[++i]);
         *incM = atoi(args[++i]);
         break;
      case 'N':
         *N0 = atoi(args[++i]);
         *NN = atoi(args[++i]);
         *incN = atoi(args[++i]);
         break;
      case 'l':
         *lda = atoi(args[++i]);
         break;
      case 'b':
         *beta = atof(args[++i]);
         #ifdef TCPLX
            beta[1] = atof(args[++i]);
         #endif
         break;
      default:
         PrintUsage(args[0]);
      }
   }
   if (*lda == 0)
   {
      if (*TA == AtlasNoTrans  || *TA == AtlasConj) *lda = -(*M0 + 7);
      else *lda = -(*N0 + 7);
   }
}

int main(int nargs, char **args)
/*
 * Test the GEMV primitives
 */
{
   #ifdef TREAL
      TYPE beta;
      #define bet &beta
   #else
      TYPE beta[2];
      #define bet beta
   #endif
   enum ATLAS_TRANS TA;
   int M0, MN, incM, N0, NN, incN, m, n, lda, ldagap=0, ierr=0;

   GetFlags(nargs, args, &TA, &M0, &MN, &incM,  &N0, &NN, &incN, &lda, bet);
   if (lda < 0)
   {
      lda = -lda;
      if (TA == AtlasNoTrans || TA == AtlasConj) ldagap = lda - M0;
      else ldagap = lda - N0;
      lda -= ldagap;
   }
   fprintf(stdout, "\n\nBEGINNING GEMV PRIMITIVE TESTING:\n\n");
   for (n=N0; n <= NN; n += incN)
   {
      for (m=M0; m <= MN; m += incM)
      {
         if (ldagap)
         {
            if (TA == AtlasNoTrans || TA == AtlasConj) lda = m + ldagap;
            else lda = n + ldagap;
         }
         ierr += RunTests(TA, m, n, lda, beta);
      }
   }
/*   ierr = RunTests(TA, M, N, lda, beta); */
   if (ierr == 0) fprintf(stdout, "\n\nGEMV PRIMITIVE PASSED ALL TESTS\n\n");
   else fprintf(stdout, "\n\nGEMV PRIMITIVE FAILED SOME TESTS\n\n");
   return(ierr);
}
@ROUT l2blastst
#include "atlas_misc.h"
#include "atlas_tst.h"
#include "atlas_level2.h"
#include <string.h>

#define DEBUG
#define THRESH 50.0
static TYPE eps;
enum LVL2_ROUT {GEMV=0, GBMV, HEMV, HBMV, HPMV, SYMV, SBMV, SPMV, TRMV, TBMV,
                TPMV, TRSV, TBSV, TPSV, GER, GERU, GERC, HER, HPR, HER2, HPR2, 
                SYR, SPR, SYR2, SPR2, ALLROUTS};

#if 1
   #define trusted_gemv(TA, M, N, alpha, A, lda, X, incX, beta, Y, incY) \
      Mjoin(PATL,f77gemv)(TA, M, N, alpha, A, lda, X, incX, beta, Y, incY)
   #define trusted_trmv(UP, TA, DI, N, A, lda, X, incX) \
      Mjoin(PATL,f77trmv)(UP, TA, DI, N, A, lda, X, incX)
   #define trusted_ger(M, N, alpha, X, incX, Y, incY, A, lda) \
      Mjoin(PATL,f77ger)(M, N, alpha, X, incX, Y, incY, A, lda)
   #define trusted_geru(M, N, alpha, X, incX, Y, incY, A, lda) \
      Mjoin(PATL,f77geru)(M, N, alpha, X, incX, Y, incY, A, lda)
   #define trusted_gerc(M, N, alpha, X, incX, Y, incY, A, lda) \
      Mjoin(PATL,f77gerc)(M, N, alpha, X, incX, Y, incY, A, lda)
#else
   #define trusted_gemv(TA, M, N, alpha, A, lda, X, incX, beta, Y, incY) \
      Mjoin(PATL,refgemv)(TA, M, N, alpha, A, lda, X, incX, beta, Y, incY)
   #define trusted_trmv(UP, TA, DI, N, A, lda, X, incX) \
      Mjoin(PATL,reftrmv)(UP, TA, DI, N, A, lda, X, incX)
   #define trusted_ger(M, N, alpha, X, incX, Y, incY, A, lda) \
      Mjoin(PATL,refger)(M, N, alpha, X, incX, Y, incY, A, lda)
   #define trusted_geru(M, N, alpha, X, incX, Y, incY, A, lda) \
      Mjoin(PATL,refgeru)(M, N, alpha, X, incX, Y, incY, A, lda)
   #define trusted_gerc(M, N, alpha, X, incX, Y, incY, A, lda) \
      Mjoin(PATL,refgerc)(M, N, alpha, X, incX, Y, incY, A, lda)
#endif

#define test_gemv(TA, M, N, alpha, A, lda, X, incX, beta, Y, incY) \
   Mjoin(PATL,gemv)(TA, M, N, alpha, A, lda, X, incX, beta, Y, incY)
#define test_trmv(UP, TA, DI, N, A, lda, X, incX) \
   Mjoin(PATL,trmv)(UP, TA, DI, N, A, lda, X, incX)
#define test_ger(M, N, alpha, X, incX, Y, incY, A, lda) \
   Mjoin(PATL,ger)(M, N, alpha, X, incX, Y, incY, A, lda)
#define test_gerc(M, N, alpha, X, incX, Y, incY, A, lda) \
   Mjoin(PATL,gerc)(M, N, alpha, X, incX, Y, incY, A, lda)
#define test_geru(M, N, alpha, X, incX, Y, incY, A, lda) \
   Mjoin(PATL,geru)(M, N, alpha, X, incX, Y, incY, A, lda)


TYPE gertst(const enum ATLAS_TRANS TY, const int M, const int N,
            const SCALAR alpha, const int incX, const int incY, const int lda,
            double *ttrust0, double *ttest0, double *mftrust0, double *mftest0)
{
   const int aincX = Mabs(incX), aincY = Mabs(incY);
   const int FlushSize=L2SIZE/sizeof(double);
   int i;
   TYPE normA, normD, normY, normX, resid;
   TYPE *X, *x, *Y, *y, *A, *Y0, *A0;
   double *flush;
   double t0, ttest, ttrust;
   #ifdef TREAL
      const double ops = 2.0 * M * N;
   #else
      const double ops = 8.0 * M * N;
   #endif
   extern TYPE eps;

   eps = EPS;

   *ttrust0 = *ttest0 = *mftest0 = *mftrust0 = -1.0;
   flush = malloc(sizeof(double)*(FlushSize));
   if (flush == NULL) return(-1);
   A = malloc(ATL_MulBySize(lda) * N);
   if (A == NULL)
   {
      free(flush);
      return(-1);
   }

   x = X = malloc(ATL_MulBySize(M) * aincX);
   if (X == NULL)
   {
      free(flush);
      free(A);
      return(-1);
   }

   y = Y = malloc(ATL_MulBySize(N) * aincY);
   if (Y == NULL)
   {
      free(flush);
      free(A);
      free(X);
      return(-1);
   }
   A0 = malloc(ATL_MulBySize(lda)*N);
   if (A0 == NULL)
   {
      free(flush);
      free(A);
      free(X);
      free(Y);
      return(-1);
   }
/*
 * Generate operands, figure starting norms, and then flush cache
 */
   Mjoin(PATL,gegen)(M, N, A, lda, M*N+lda);
   Mjoin(PATL,gegen)(M, N, A0, lda, M*N+lda);
   Mjoin(PATL,gegen)(1, M, X, aincX, N*incX*27+213);
   Mjoin(PATL,gegen)(1, N, Y, aincY, M*incY);
   #if defined(DEBUG) && 0
      Mjoin(PATL,geprint)("A", M, N, A, lda);
      Mjoin(PATL,geprint)("A0", M, N, A0, lda);
      Mjoin(PATL,geprint)("X", 1, M, X, aincX);
      Mjoin(PATL,geprint)("Y", 1, N, Y, aincY);
   #endif
   normA = Mjoin(PATL,genrm1)(M, N, A, lda);
   normX = Mjoin(PATL,infnrm)(M, X, aincX);
   normY = Mjoin(PATL,infnrm)(N, Y, aincY);
   #ifdef TREAL
      if (Mabs(alpha) > ATL_rone) normA *= Mabs(alpha);
   #else
      if (Mabs(*alpha)+Mabs(alpha[1]) > ATL_rone) 
         normA *= (Mabs(*alpha) + Mabs(alpha[1]));
   #endif

   if (incX < 0) x += (1-M)*incX SHIFT;
   if (incY < 0) y += (1-N)*incY SHIFT;

   ATL_dset(FlushSize, 0.0, flush, 1);
   for (i=0; i < FlushSize; i++) if (flush[i] != 0.0) exit(-1);

   t0 = time00();
   #ifdef TREAL
      trusted_ger(M, N, alpha, x, incX, y, incY, A0, lda);
   #else
      if (TY != AtlasConjTrans)
         trusted_geru(M, N, alpha, x, incX, y, incY, A0, lda);
      else trusted_gerc(M, N, alpha, x, incX, y, incY, A0, lda);
   #endif
   ttrust = time00() - t0;

   ATL_dset(FlushSize, 0.0, flush, 1);
   for (i=0; i < FlushSize; i++) if (flush[i] != 0.0) exit(-1);

   t0 = time00();
   #ifdef TREAL
      test_ger(M, N, alpha, x, incX, y, incY, A, lda);
   #else
      if (TY != AtlasConjTrans)
         test_geru(M, N, alpha, x, incX, y, incY, A, lda);
      else test_gerc(M, N, alpha, x, incX, y, incY, A, lda);
   #endif
   ttest = time00() - t0;

   *ttrust0 = *ttest0 = *mftest0 = *mftrust0 = 0.0;
   if (ttrust > 0.0)
   {
      *ttrust0 = ttrust;
      *mftrust0 = ops / (ttrust * 1000000.0);
   }
   if (ttest > 0.0)
   {
      *ttest0 = ttest;
      *mftest0 = ops / (ttest * 1000000.0);
   }
/*
 * Perform error check
 */
   normD = Mjoin(PATL,gediffnrm1)(M, N, A, lda, A0, lda);
   resid = normD / (normA * normX * normY * eps * Mmax(M,N));
   #ifdef DEBUG
      if (resid > THRESH || resid != resid)
      {
         fprintf(stderr, 
            "   resid=%f, normD=%f, normA=%f, normX=%f, normY=%f, eps=%e\n",
                 resid, normD, normA, normX, normY, eps);
         Mjoin(PATL,geprint)("A0", M, N, A0, lda);
         Mjoin(PATL,geprint)("A?", M, N, A, lda);
      }
   #endif
   free(flush);
   free(A);
   free(X);
   free(Y);
   free(A0);
   return(resid);
}

TYPE gemvtst(const enum ATLAS_TRANS TA, const int M, const int N, 
             const SCALAR alpha, const int lda, const int incX, 
             const SCALAR beta, const int incY, double *ttrust0,
             double *ttest0, double *mftrust0, double *mftest0)
{
   const int aincX = Mabs(incX), aincY = Mabs(incY);
   const int FlushSize=L2SIZE/sizeof(double);
   int i, mA, nA;
   TYPE normA, normD, normY, normX, resid;
   TYPE *X, *x, *Y, *y, *A, *Y0, *YD;
   double *flush;
   double t0, ttest, ttrust;
   #ifdef TREAL
      const double ops = 2.0 * M * N;
   #else
      const double ops = 8.0 * M * N;
   #endif
   extern TYPE eps;

   eps = EPS;
   if (TA == AtlasNoTrans)
   {
      mA = M;
      nA = N;
   }
   else
   {
      mA = N;
      nA = M;
   }

   *ttrust0 = *ttest0 = *mftest0 = *mftrust0 = -1.0;
   flush = malloc(sizeof(double)*(FlushSize));
   if (flush == NULL) return(-1);
   A = malloc(ATL_MulBySize(lda) * nA);
   if (A == NULL)
   {
      free(flush);
      return(-1);
   }

   x = X = malloc(ATL_MulBySize(N) * aincX);
   if (X == NULL)
   {
      free(flush);
      free(A);
      return(-1);
   }

   y = Y = malloc(2*ATL_MulBySize(M) * aincY);
   if (Y == NULL)
   {
      free(flush);
      free(A);
      free(X);
      return(-1);
   }
   Y0 = Y + M*(aincY SHIFT);
   YD = malloc(ATL_MulBySize(M));
   if (YD == NULL)
   {
      free(flush);
      free(A);
      free(X);
      free(Y);
      return(-1);
   }
/*
 * Generate operands, figure starting norms, and then flush cache
 */
   Mjoin(PATL,gegen)(mA, nA, A, lda, mA*nA+lda);
   Mjoin(PATL,gegen)(1, N, X, aincX, N*incX*27+213);
   Mjoin(PATL,gegen)(1, M, Y, aincY, M*incY);
   Mjoin(PATL,gegen)(1, M, Y0, aincY, M*incY);
   #if defined(DEBUG) && 0
      Mjoin(PATL,geprint)("A", mA, nA, A, lda);
      Mjoin(PATL,geprint)("X", 1, N, X, aincX);
      Mjoin(PATL,geprint)("Y0", 1, M, Y0, aincY);
      Mjoin(PATL,geprint)("Y", 1, M, Y, aincY);
   #endif
   normA = Mjoin(PATL,genrm1)(mA, nA, A, lda);
   normX = Mjoin(PATL,infnrm)(N, X, aincX);
   normY = Mjoin(PATL,infnrm)(M, Y, aincY);
   #ifdef TREAL
      if (beta == ATL_rzero) normY = 1.0;
      else if (Mabs(beta) > ATL_rone) normY *= Mabs(beta);
      if (Mabs(alpha) > ATL_rone) normX *= Mabs(alpha);
   #else
      if ( SCALAR_IS_ZERO(beta) ) normY = 1.0;
      else if (Mabs(*beta)+Mabs(beta[1]) > ATL_rone) 
         normY *= (Mabs(*beta)+Mabs(beta[1]));
      if (Mabs(*alpha)+Mabs(alpha[1]) > ATL_rone) 
         normX *= (Mabs(*alpha) + Mabs(alpha[1]));
   #endif

   if (incX < 0) x += (1-N)*incX SHIFT;
   if (incY < 0) y = Y0 + ((1-M)*incY SHIFT);
   else y = Y0;

   ATL_dset(FlushSize, 0.0, flush, 1);
   for (i=0; i < FlushSize; i++) if (flush[i] != 0.0) exit(-1);

   t0 = time00();
   trusted_gemv(TA, M, N, alpha, A, lda, x, incX, beta, y, incY);
   ttrust = time00() - t0;

   if (incY < 0) y = Y + ((1-M)*incY SHIFT);
   else y = Y;
   ATL_dset(FlushSize, 0.0, flush, 1);
   for (i=0; i < FlushSize; i++) if (flush[i] != 0.0) exit(-1);

   t0 = time00();
   test_gemv(TA, M, N, alpha, A, lda, x, incX, beta, y, incY);
   ttest = time00() - t0;

   *ttrust0 = *ttest0 = *mftest0 = *mftrust0 = 0.0;
   if (ttrust > 0.0)
   {
      *ttrust0 = ttrust;
      *mftrust0 = ops / (ttrust * 1000000.0);
   }
   if (ttest > 0.0)
   {
      *ttest0 = ttest;
      *mftest0 = ops / (ttest * 1000000.0);
   }
/*
 * Perform error check
 */
   Mjoin(PATL,vdiff)(M, Y, aincY, Y0, aincY, YD, 1);
   normD = Mjoin(PATL,infnrm)(M, YD, 1);
   resid = normD / (normA * normX * normY * eps * Mmax(M,N));
   #ifdef DEBUG
      if (resid > THRESH || resid != resid)
      {
         fprintf(stderr, 
            "   resid=%f, normD=%f, normA=%f, normX=%f, normY=%f, eps=%e\n",
                 resid, normD, normA, normX, normY, eps);
         Mjoin(PATL,geprint)("Y0", 1, M, Y0, aincY);
         Mjoin(PATL,geprint)("Y?", 1, M, Y, aincY);
      }
   #endif
   free(flush);
   free(A);
   free(X);
   free(Y);
   free(YD);
   return(resid);
}
TYPE trmvtst(const enum ATLAS_UPLO Uplo, const enum ATLAS_TRANS TA, 
             const enum ATLAS_DIAG Diag, const int N, const int lda,
             const int incX, double *ttrust0, double *ttest0, 
             double *mftrust0, double *mftest0)
{
   const int aincX = Mabs(incX);
   const int FlushSize=L2SIZE/sizeof(double);
   int i;
   TYPE normA, normD, normX, resid;
   TYPE *X, *x, *A, *X0, *XD;
   double *flush;
   double t0, ttest, ttrust;
   #ifdef TREAL
      const double ops = 2.0 * N * ((N+1)/2);
   #else
      const double ops = 8.0 * N * ((N+1)/2);
   #endif
   extern TYPE eps;

   eps = EPS;

   *ttrust0 = *ttest0 = *mftest0 = *mftrust0 = -1.0;
   flush = malloc(sizeof(double)*(FlushSize));
   if (flush == NULL) return(-1);
   A = malloc(ATL_MulBySize(lda) * N);
   if (A == NULL)
   {
      free(flush);
      return(-1);
   }

   x = X0 = malloc(2*ATL_MulBySize(N) * aincX);
   if (X0 == NULL)
   {
      free(flush);
      free(A);
      return(-1);
   }
   X = X0 + N*(aincX SHIFT);

   XD = malloc(ATL_MulBySize(N));
   if (XD == NULL)
   {
      free(flush);
      free(A);
      free(X0);
      return(-1);
   }
/*
 * Generate operands, figure starting norms, and then flush cache
 */
   Mjoin(PATL,trgen)(Uplo, Diag, N, A, lda, N+lda);
   Mjoin(PATL,gegen)(1, N, X, aincX, N*incX*27+213);
   Mjoin(PATL,gegen)(1, N, X0, aincX, N*incX*27+213);
   #if defined(DEBUG) && 0
      Mjoin(PATL,geprint)("A", N, N, A, lda);
      Mjoin(PATL,geprint)("X", 1, N, X, aincX);
      Mjoin(PATL,geprint)("X0", 1, N, X, aincX);
   #endif
   normA = Mjoin(PATL,trnrm1)(Uplo, Diag, N, A, lda);
   normX = Mjoin(PATL,infnrm)(N, X, aincX);

   if (incX < 0) x += (1-N)*incX SHIFT;

   ATL_dset(FlushSize, 0.0, flush, 1);
   for (i=0; i < FlushSize; i++) if (flush[i] != 0.0) exit(-1);

   t0 = time00();
   trusted_trmv(Uplo, TA, Diag, N, A, lda, x, incX);
   ttrust = time00() - t0;

   if (incX < 0) x = X + ((1-N)*incX SHIFT);
   else x = X;
   ATL_dset(FlushSize, 0.0, flush, 1);
   for (i=0; i < FlushSize; i++) if (flush[i] != 0.0) exit(-1);

   t0 = time00();
   test_trmv(Uplo, TA, Diag, N, A, lda, x, incX);
   ttest = time00() - t0;

   *ttrust0 = *ttest0 = *mftest0 = *mftrust0 = 0.0;
   if (ttrust > 0.0)
   {
      *ttrust0 = ttrust;
      *mftrust0 = ops / (ttrust * 1000000.0);
   }
   if (ttest > 0.0)
   {
      *ttest0 = ttest;
      *mftest0 = ops / (ttest * 1000000.0);
   }
/*
 * Perform error check
 */
   Mjoin(PATL,vdiff)(N, X, aincX, X0, aincX, XD, 1);
   normD = Mjoin(PATL,infnrm)(N, XD, 1);
   resid = normD / (normA * normX * eps * N);
   #ifdef DEBUG
      if (resid > THRESH || resid != resid)
      {
         fprintf(stderr, 
            "   resid=%f, normD=%f, normA=%f, normX=%f, eps=%e\n",
                 resid, normD, normA, normX, eps);
         Mjoin(PATL,geprint)("X0", 1, N, X0, aincX);
         Mjoin(PATL,geprint)("X?", 1, N, X, aincX);
      }
   #endif
   free(flush);
   free(A);
   free(X0);
   free(XD);
   return(resid);
}

int trmvcase(int MFLOP, int TEST, const enum ATLAS_UPLO Uplo, 
             const enum ATLAS_TRANS TA, const enum ATLAS_DIAG Diag, 
             const int N, const int lda, const int incX, 
             double *ttrust0, double *ttest0, 
             double *mftrust0, double *mftest0)
{
   const int aincX = Mabs(incX), inca = lda * N SHIFT, incx = N*incX SHIFT;
   int i, lx, la, PASSED;
   TYPE *A0, *A, *a, *stA, *X0, *X, *x, *stX;
   double ttrust, ttest, mftrust, mftest, t0, resid;
   #ifdef TREAL
      const double flops = 2.0 * N * ((N+1)/2);
   #else
      const double flops= 8.0 * N * ((N+1)/2);
   #endif
   const int reps = Mmax((MFLOP * 1000000.0) / flops, 1);

   if (MFLOP*1000000.0 <= flops || TEST)
   {
      resid = trmvtst(Uplo, TA, Diag, N, lda, incX, ttrust0, ttest0,
                      mftrust0, mftest0);
      if (resid > THRESH) fprintf(stderr, "   resid=%e\n", resid);
   }
   if (resid < 0.0) PASSED = -1;
   else PASSED = resid <= THRESH;
   if (MFLOP*1000000.0 <= flops) return(PASSED);

   i = (ATL_DivBySize(L2SIZE)+N-1)/N;
   lx = i * N * aincX;
   X0 = X = x = malloc(ATL_MulBySize(lx));
   if (x == NULL) return(-1);

   i = (ATL_DivBySize(L2SIZE)+N*N)/(N*N);
   la = i * inca;
   A0 = A = a = malloc(ATL_MulBySize(la));
   if (a == NULL)
   {
      free(x);
      return(-1);
   }

   if (incX < 1)
   {
      stX = x;
      x = X = x + (lx SHIFT);
   }
   else stX = x + (lx SHIFT);
   stA = a + (la SHIFT);

   Mjoin(PATL,gegen)(lx, 1, X0, lx, N*incX+127*50+77);
   Mjoin(PATL,gegen)(la, 1, A0, la, N+513*7+90);

   t0 = time00();
   for (i=reps; i; i--)
   {
      trusted_trmv(Uplo, TA, Diag, N, a, lda, x, incX);
      x += incx;
      a += inca;
      if (x == stX) x = X;
      if (a == stA) a = A;
   }
   ttrust = time00() - t0;

   x = X; a = A;
   Mjoin(PATL,gegen)(lx, 1, X0, lx, N*incX+127*50+77);
   Mjoin(PATL,gegen)(la, 1, A0, la, N+513*7+90);

   t0 = time00();
   for (i=reps; i; i--)
   {
      test_trmv(Uplo, TA, Diag, N, a, lda, x, incX);
      x += incx;
      a += inca;
      if (x == stX) x = X;
      if (a == stA) a = A;
   }
   ttest = time00() - t0;

   if (ttrust > 0.0) mftrust = (reps * flops) / (1000000.0 * ttrust);
   else mftrust = 0.0;
   if (ttest > 0.0) mftest = (reps * flops) / (1000000.0 * ttest);
   else mftest = 0.0;
   ttrust /= reps;
   ttest  /= reps;
   *ttrust0 = ttrust;
   *ttest0  = ttest;
   *mftrust0 = mftrust;
   *mftest0 = mftest;

   free(A0);
   free(X0);
   return(PASSED);
}

int gercase(int MFLOP, int TEST, const enum ATLAS_TRANS TY, const int M, 
            const int N, const SCALAR alpha, const int incX, const int incY,
            const int lda, double *ttrust0, double *ttest0,
            double *mftrust0, double *mftest0)
{
   unsigned long reps;
   int i, lx, ly, la;
   #ifdef TREAL
      const double flops = 2.0 * M * N;
   #else
      const double flops = 8.0 * M * N;
   #endif
   double ttrust, ttest, mftrust, mftest, t0;
   const int aincY = Mabs(incY), aincX = Mabs(incX);
   const int inca = lda*N SHIFT, incx = M*incX SHIFT, incy = N*incY SHIFT;
   TYPE *a, *A, *stA, *A0, *x, *X, *X0, *stX, *y, *Y, *Y0, *stY;
   TYPE resid=0.0;
   int PASSED;
   #ifdef TREAL
      const TYPE nalpha = -alpha;
      TYPE alp = alpha;
   #else
      const TYPE *alp = alpha;
      TYPE nalpha[2];
      nalpha[0] = -alpha[0]; nalpha[1] = -alpha[1];
   #endif

   if (MFLOP*1000000.0 <= flops || TEST)
   {
      resid = gertst(TY, M, N, alpha, incX, incY, lda, ttrust0, ttest0, 
                     mftrust0, mftest0);
      if (resid > THRESH) fprintf(stderr, "   resid=%e\n", resid);
   }
   if (resid < 0.0) PASSED = -1;
   else PASSED = resid <= THRESH;
   if (MFLOP*1000000.0 <= flops) return(PASSED);

   i = (ATL_DivBySize(L2SIZE)+M-1)/M;
   lx = i * M * aincX;
   X0 = X = x = malloc(ATL_MulBySize(lx));
   if (x == NULL) return(-1);

   i = (ATL_DivBySize(L2SIZE)+N-1)/N;
   ly = i * N * aincY;
   Y0 = Y = y = malloc(ATL_MulBySize(ly));
   if (y == NULL)
   {
      free(x);
      return(-1);
   }
   i = (ATL_DivBySize(L2SIZE)+M*N)/(M*N);
   la = i * lda*N;
   A0 = A = a = malloc(ATL_MulBySize(la));
   if (a == NULL)
   {
      free(x);
      free(y);
      return(-1);
   }
   if (incX < 1)
   {
      stX = x;
      x = X = x + (lx SHIFT);
   }
   else stX = x + (lx SHIFT);
   if (incY < 1)
   {
      stY = y;
      y = Y = y + (ly SHIFT);
   }
   else stY = y + (ly SHIFT);
   stA = a + (la SHIFT);

   reps = (MFLOP * 1000000.0) / flops;
   if (reps < 1) reps = 1;
   Mjoin(PATL,gegen)(ly, 1, Y0, ly, M*incY);
   Mjoin(PATL,gegen)(lx, 1, X0, lx, N*incY+127*50+77);
   Mjoin(PATL,gegen)(la, 1, A0, la, N*M+513*7+90);

   t0 = time00();
   for (i=reps; i; i--)
   {
      #ifdef TREAL
         trusted_ger(M, N, alpha, x, incX, y, incY, A0, lda);
      #else
         if (TY != AtlasConjTrans)
            trusted_geru(M, N, alpha, x, incX, y, incY, A0, lda);
         else trusted_gerc(M, N, alpha, x, incX, y, incY, A0, lda);
      #endif
      x += incx;
      y += incy;
      a += inca;
      if (x == stX) x = X;
      if (y == stY) y = Y;
      if (a == stA)
      {
         a = A;
         if (alp == alpha) alp = nalpha;
         else alp = alpha;
      }
   }
   ttrust = time00() - t0;

   alp = alpha;
   x = X; y = Y; a = A;
   Mjoin(PATL,gegen)(ly, 1, Y0, ly, M*incY);
   Mjoin(PATL,gegen)(lx, 1, X0, lx, N*incY+127*50+77);
   Mjoin(PATL,gegen)(la, 1, A0, la, N*M+513*7+90);

   t0 = time00();
   for (i=reps; i; i--)
   {
      #ifdef TREAL
         test_ger(M, N, alpha, x, incX, y, incY, A0, lda);
      #else
         if (TY != AtlasConjTrans)
            test_geru(M, N, alpha, x, incX, y, incY, A0, lda);
         else test_gerc(M, N, alpha, x, incX, y, incY, A0, lda);
      #endif
      x += incx;
      y += incy;
      a += inca;
      if (x == stX) x = X;
      if (y == stY) y = Y;
      if (a == stA)
      {
         a = A;
         if (alp == alpha) alp = nalpha;
         else alp = alpha;
      }
   }
   ttest = time00() - t0;

   if (ttrust > 0.0) mftrust = (reps * flops) / (1000000.0 * ttrust);
   else mftrust = 0.0;
   if (ttest > 0.0) mftest = (reps * flops) / (1000000.0 * ttest);
   else mftest = 0.0;
   ttrust /= reps;
   ttest  /= reps;
   *ttrust0 = ttrust;
   *ttest0  = ttest;
   *mftrust0 = mftrust;
   *mftest0 = mftest;

   free(A0);
   free(X0);
   free(Y0);
   return (PASSED);
}

int gemvcase(int MFLOP, int TEST, const enum ATLAS_TRANS TA, const int M,
             const int N, const SCALAR alpha, const int lda, const int incX, 
             const SCALAR beta, const int incY, double *ttrust0, 
             double *ttest0, double *mftrust0, double *mftest0)
{
   unsigned long reps;
   int i, lx, ly, la;
   #ifdef TREAL
      const double flops = 2.0 * M * N;
   #else
      const double flops = 8.0 * M * N;
   #endif
   double ttrust, ttest, mftrust, mftest, t0;
   const int aincY = Mabs(incY), aincX = Mabs(incX);
   const int inca = (TA == AtlasNoTrans) ? lda * (N SHIFT) : lda * (M SHIFT);
   const int incx = N*incX SHIFT, incy = M*incY SHIFT;
   TYPE *a, *A, *stA, *A0, *x, *X, *X0, *stX, *y, *Y, *Y0, *stY;
   TYPE resid=0.0;
   int PASSED;
   #ifdef TREAL
      const TYPE nbeta = -beta;
      TYPE bet = beta;
   #else
      const TYPE *bet = beta;
      TYPE nbeta[2];
      nbeta[0] = -beta[0]; nbeta[1] = -beta[1];
   #endif

   if (MFLOP*1000000.0 <= flops || TEST)
   {
      resid = gemvtst(TA, M, N, alpha, lda, incX, beta, incY, 
                      ttrust0, ttest0, mftrust0, mftest0);
      if (resid > THRESH) fprintf(stderr, "   resid=%f\n", resid);
   }
   if (resid < 0.0) PASSED = -1;
   else PASSED = (resid <= THRESH);
   if (MFLOP * 1000000.0 <= flops) return(PASSED);

   i = (ATL_DivBySize(L2SIZE)+N-1)/N;
   lx = i * N * aincX;
   X0 = X = x = malloc(ATL_MulBySize(lx));
   if (x == NULL) return(-1);

   i = (ATL_DivBySize(L2SIZE)+M-1)/M;
   ly = i * M * aincY;
   Y0 = Y = y = malloc(ATL_MulBySize(ly));
   if (y == NULL)
   {
      free(x);
      return(-1);
   }
   i = (ATL_DivBySize(L2SIZE)+M*N)/(M*N);
   la = i * inca;
   A0 = A = a = malloc(ATL_MulBySize(la));
   if (a == NULL)
   {
      free(x);
      free(y);
      return(-1);
   }
   if (incX < 1)
   {
      stX = x;
      x = X = x + (lx SHIFT);
   }
   else stX = x + (lx SHIFT);
   if (incY < 1)
   {
      stY = y;
      y = Y = y + (ly SHIFT);
   }
   else stY = y + (ly SHIFT);
   stA = a + (la SHIFT);

   reps = (MFLOP * 1000000.0) / flops;
   if (reps < 1) reps = 1;
   Mjoin(PATL,gegen)(ly, 1, Y0, ly, M*incY);
   Mjoin(PATL,gegen)(lx, 1, X0, lx, N*incY+127*50+77);
   Mjoin(PATL,gegen)(la, 1, A0, la, N*M+513*7+90);

   t0 = time00();
   for (i=reps; i; i--)
   {
      trusted_gemv(TA, M, N, alpha, a, lda, x, incX, beta, y, incY);
      x += incx;
      y += incy;
      a += inca;
      if (x == stX) x = X;
      if (y == stY)
      {
         y = Y;
         if (bet == beta) bet = nbeta;
         else bet = beta;
      }
      if (a == stA) a = A;
   }
   ttrust = time00() - t0;

   bet = beta;
   x = X; y = Y; a = A;
   Mjoin(PATL,gegen)(ly, 1, Y0, ly, M*incY);
   Mjoin(PATL,gegen)(lx, 1, X0, lx, N*incY+127*50+77);
   Mjoin(PATL,gegen)(la, 1, A0, la, N*M+513*7+90);

   t0 = time00();
   for (i=reps; i; i--)
   {
      test_gemv(TA, M, N, alpha, a, lda, x, incX, beta, y, incY);
      x += incx;
      y += incy;
      a += inca;
      if (x == stX) x = X;
      if (y == stY)
      {
         y = Y;
         if (bet == beta) bet = nbeta;
         else bet = beta;
      }
      if (a == stA) a = A;
   }
   ttest = time00() - t0;

   if (ttrust > 0.0) mftrust = (reps * flops) / (1000000.0 * ttrust);
   else mftrust = 0.0;
   if (ttest > 0.0) mftest = (reps * flops) / (1000000.0 * ttest);
   else mftest = 0.0;
   ttrust /= reps;
   ttest  /= reps;
   *ttrust0 = ttrust;
   *ttest0  = ttest;
   *mftrust0 = mftrust;
   *mftest0 = mftest;

   free(A0);
   free(X0);
   free(Y0);
   return(PASSED);
}

void RunCases(int TEST, int LDA_IS_M, int MFLOP, int nside,
              enum ATLAS_SIDE *Side, int nuplo, enum ATLAS_UPLO *Uplo, 
              int nta, enum ATLAS_TRANS *TA, int ndiag, enum ATLAS_DIAG *Diag,
              int M0, int MN, int incM, int N0, int NN, int incN,
              int K0, int KN, int incK, int nalphas, TYPE *alphas, int nbetas,
              TYPE *betas, int nincX, int *incX, int nincY, int *incY,
              int nrouts, enum LVL2_ROUT *Rout)
{
   enum ATLAS_TRANS TY;
   char cTA, cdiag, cuplo;
   char *pass, *form;
   int ro, mm, nn, kk, si, up, ta, di, iy, ix, al, be;
   int i, m, n, k, lda;
   int itst=0, np=0;
   int MSAME=0, KSAME=0;
   double t0, mftrust, mftest, ttrust, ttest;

   if (M0 == -1)
   {
      M0 = MN = incM = NN;
      MSAME = 1;
   }
   if (K0 == -1)
   {
      K0 = KN = incK = NN;
      KSAME = 1;
   }
   for (ro=0; ro < nrouts; ro++)
   {
      switch(Rout[ro])
      {
      case GER:
         fprintf(stdout, 
"\n------------------------------- GER ---------------------------------\n");
         fprintf(stdout, 
"TST#     M     N ALPHA INCX INCY   LDA   TIME  MFLOP  SpUp  TEST\n");
         fprintf(stdout, 
"==== ===== ===== ===== ==== ==== ===== ====== ====== ===== =====\n");
         form =
"%4d  %5d %5d %5.1f %4d %4d %5d %6.2f %6.1f %5.2f %5s\n";
         break;
      case GERU:
      case GERC:
         if (Rout[ro] == GERU)
            fprintf(stdout, 
"\n------------------------------- GERU --------------------------------\n");
         else fprintf(stdout, 
"\n------------------------------- GERC --------------------------------\n");
         fprintf(stdout, 
"TST#     M     N       ALPHA INCX INCY   LDA   TIME  MFLOP  SpUp  TEST\n");
         fprintf(stdout, 
"==== ===== ===== ===== ===== ==== ==== ===== ====== ====== ===== =====\n");
         form =
"%4d  %5d %5d %5.1f %5.1f %4d %4d %5d %6.2f %6.1f %5.2f %5s\n";
         break;
      case TRMV:
            fprintf(stdout, 
"\n------------------------------- TRMV --------------------------------\n");
            fprintf(stdout, 
"TST# UPLO TRAN DIAG    N  LDA INCX   TIME MFLOP  SpUp  TEST\n");
            fprintf(stdout, 
"==== ==== ==== ==== ==== ==== ==== ====== ====== ===== =====\n");
            form = 
"%4d    %c    %c    %c %4d %4d %4d %6.2f %6.1f %5.2f %5s\n";
         break;
      case GEMV:
#ifdef TREAL
            fprintf(stdout, 
"\n------------------------------- GEMV --------------------------------\n");
            fprintf(stdout, 
"TST# TR    M    N ALPHA  LDA INCX  BETA INCY   TIME MFLOP  SpUp  TEST\n");
            fprintf(stdout, 
"==== == ==== ==== ===== ==== ==== ===== ==== ====== ===== ===== =====\n");
            form =
"%4d  %c %4d %4d %5.1f %4d %4d %5.1f %4d %6.2f %5.1f %5.2f %5s\n";
#else
            fprintf(stdout, 
"\n----------------------------------- GEMV -----------------------------------\n");
            fprintf(stdout, 
"TST# TR    M    N     ALPHA  LDA INCX      BETA INCY   TIME MFLOP  SpUp  TEST\n");
            fprintf(stdout, 
"==== == ==== ==== ==== ==== ==== ==== ==== ==== ==== ====== ===== ===== =====\n");
            form =
"%4d  %c %4d %4d %4.1f %4.1f %4d %4d %4.1f %4.1f %4d %6.2f %5.1f %5.2f %5s\n";
#endif
            break;
         default:
           exit(-1);
      }
      for (mm=M0; mm <= MN; mm += incM)
      {
         for (nn=N0; nn <= NN; nn += incN)
         {
            n = nn;
            if (MSAME) m = n;
            else m = mm;
            for (kk=K0; kk <= KN; kk += incK)
            {
               if (KSAME) k = n;
               else k = kk;
               for (si=0; si < nside; si++)
               {
                  for (up=0; up < nuplo; up++)
                  {
                     if (Uplo[up] == AtlasUpper) cuplo = 'U';
                     else cuplo = 'L';
                     for (ta=0; ta < nta; ta++)
                     {
                        if (TA[ta] == AtlasNoTrans) cTA = 'N';
                        else if (TA[ta] == AtlasTrans) cTA = 'T';
                        else if (TA[ta] == AtlasConjTrans) cTA = 'C';
                        for (di=0; di < ndiag; di++)
                        {
                           if (Diag[di] == AtlasUnit) cdiag = 'U';
                           else cdiag = 'N';
                           for (iy=0; iy < nincY; iy++)
                           {
                              for (ix=0; ix < nincX; ix++)
                              {
                                 for (al=0; al < nalphas; al++)
                                 {
                                    for (be=0; be < nbetas; be++)
                                    {
   switch(Rout[ro])
   {
   case GEMV:
      if (TA[ta] == AtlasNoTrans)
      {
         if (LDA_IS_M) lda = m;
         else lda = MN;
         cTA = 'N';
      }
      else
      {
         if (LDA_IS_M) lda = n;
         else lda = NN;
         if (TA[ta] == AtlasTrans) cTA = 'T';
         else if (TA[ta] == AtlasConjTrans) cTA = 'C';
         else exit(-1);
      }
      #ifdef TREAL
         i = gemvcase(MFLOP, TEST, TA[ta], m, n, alphas[al], lda,
                      incX[ix], betas[be], incY[iy], 
                      &ttrust, &ttest, &mftrust, &mftest);
      #else
         i = gemvcase(MFLOP, TEST, TA[ta], m, n, alphas+(al<<1), lda,
                      incX[ix], betas+(be<<1), incY[iy], 
                      &ttrust, &ttest, &mftrust, &mftest);
      #endif
      if (!TEST) pass = "SKIP ";
      else if (i < 0) pass = "NoMEM";
      else if (i) pass = "PASS ";
      else pass = "FAIL ";
      if (i > 0) np++;
      if (mftrust > 0.0 && mftest > 0.0) t0 = mftest / mftrust;
      else t0 = 0.0;
      #ifdef TREAL
         fprintf(stdout, form, itst, cTA, m, n, alphas[al], lda, incX[ix],
                 betas[be], incY[iy], ttrust, mftrust, 1.0, "-----");
         fprintf(stdout, form, itst, cTA, m, n, alphas[al], lda, incX[ix],
                 betas[be], incY[iy], ttest, mftest, t0, pass);
      #else
         fprintf(stdout, form, itst, cTA, m, n, alphas[2*al], alphas[2*al+1],
                 lda, incX[ix], betas[2*be], betas[2*be+1], incY[iy], 
                 ttrust, mftrust, 1.0, "-----");
         fprintf(stdout, form, itst, cTA, m, n, alphas[al<<1], alphas[2*al+1],
                 lda, incX[ix], betas[2*be], betas[2*be+1], incY[iy], 
                 ttest, mftest, t0, pass);
      #endif
      break;
   case TRMV:
      if (LDA_IS_M) lda = n; 
      else lda = NN;
      i = trmvcase(MFLOP, TEST, Uplo[up], TA[ta], Diag[di], n, lda, incX[ix], 
                   &ttrust, &ttest, &mftrust, &mftest);
      if (!TEST) pass = "SKIP ";
      else if (i < 0) pass = "NoMEM";
      else if (i) pass = "PASS ";
      else pass = "FAIL ";
      if (i > 0) np++;
      if (mftrust > 0.0 && mftest > 0.0) t0 = mftest / mftrust;
      else t0 = 0.0;
      fprintf(stdout, form, itst, cuplo, cTA, cdiag, n, lda, incX[ix], 
              ttrust, mftrust, 1.0, "-----");
      fprintf(stdout, form, itst, cuplo, cTA, cdiag, n, lda, incX[ix], 
              ttest, mftest, t0, pass);
      break;
   case GER:
   case GERU:
   case GERC:
      if (Rout[ro] != GERC) TY = AtlasTrans;
      else TY = AtlasConjTrans;
      if (LDA_IS_M) lda = m;
      else lda = MN;
      #ifdef TREAL
         i = gercase(MFLOP, TEST, TY, m, n, alphas[al], incX[ix], incY[iy],
                     lda, &ttrust, &ttest, &mftrust, &mftest);
      #else
         i = gercase(MFLOP, TEST, TY, m, n, alphas+2*al, incX[ix], incY[iy],
                     lda, &ttrust, &ttest, &mftrust, &mftest);
      #endif
      if (!TEST) pass = "SKIP ";
      else if (i < 0) pass = "NoMEM";
      else if (i) pass = "PASS ";
      else pass = "FAIL ";
      if (i > 0) np++;
      if (mftrust > 0.0 && mftest > 0.0) t0 = mftest / mftrust;
      else t0 = 0.0;
      #ifdef TREAL
         fprintf(stdout, form, itst, m, n, alphas[al],
                 incX[ix], incY[iy], lda, ttrust, mftrust, 1.0, "-----");
         fprintf(stdout, form, itst, m, n, alphas[al],
                 incX[ix], incY[iy], lda, ttest, mftest, t0, pass);
      #else
         fprintf(stdout, form, itst, m, n, alphas[2*al], alphas[2*al+1],
                 incX[ix], incY[iy], lda, ttrust, mftrust, 1.0, "-----");
         fprintf(stdout, form, itst, m, n, alphas[2*al], alphas[2*al+1],
                 incX[ix], incY[iy], lda, ttest, mftest, t0, pass);
      #endif
      break;
   default:
      exit(-1);
   }
                                       itst++;
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
   }
   if (TEST) fprintf(stdout, "\n%d tests run, %d passed\n\n", itst, np);
}

void PrintUsage(char *nam)
{
   fprintf(stderr, "USAGE: %s -R <rout> -Side <nsides> L/R -Uplo <nuplo> L/U -Atrans <ntrans> n/t/c -Diag <ndiags> N/U -M <m1> <mN> <minc> -N <n1> <nN> <ninc> -K <k1> <kN> <kinc> -n <n> -m <m> -k <k> -a <nalphas> <alpha1> ... <alphaN> -b <nbetas> <beta1> ... <betaN> -Test <0/1> -F <mflops> -X <nincXs> <incX0> ... <incX1> -Y <nincYs> <incY0> ... <incYN>\n", nam);
   exit(-1);
}

void GetFlags(int nargs, char *args[], int *TEST, int *nside,
              enum ATLAS_SIDE **Side, int *nuplo, enum ATLAS_UPLO **Uplo, 
              int *nta, enum ATLAS_TRANS **TransA, 
              int *ndiag, enum ATLAS_DIAG **Diag, 
              int *M0, int *MN, int *Minc, int *N0, int *NN, int *Ninc, 
              int *K0, int *KN, int *Kinc, int *nalphas, TYPE **alphas, 
              int *nbetas, TYPE **betas, int *nincX, int **incXs,
              int *nincY, int **incYs, int *nrouts, enum LVL2_ROUT **Routs, 
              int *LDA_IS_M, int *mflop)
{
   char ch;
   int i=1, j, k,l=0;
/*
 * Set up defaults
 */
   *TEST = 1;
   *nincX = *nincY = *M0 = *N0 = *K0 = -1;
   *nrouts = *nuplo = *nta = *nside = *ndiag = *nalphas = *nbetas = -1;
   *mflop = *LDA_IS_M = 0;

   for (i=1; i < nargs ; )
   {
      if ( args[i][0] != '-' ) PrintUsage(args[0]);
      switch(args[i++][1])
      {
      case 'F':
         if (args[i] == NULL) PrintUsage(args[0]);
         *mflop = atoi(args[i++]);
         break;
      case 'X':
         if (args[i] == NULL) PrintUsage(args[0]);
         *nincX = atoi(args[i++]);
         if (*nincX <= 0) PrintUsage(args[0]);
         *incXs = malloc(*nincX * sizeof(int));
         ATL_assert(*incXs);
         for (j=0; j < *nincX; j++)
         {
            if (args[i] == NULL) PrintUsage(args[0]);
            (*incXs)[j] = atoi(args[i++]);
         }
         break;
      case 'Y':
         if (args[i] == NULL) PrintUsage(args[0]);
         *nincY = atoi(args[i++]);
         if (*nincY <= 0) PrintUsage(args[0]);
         *incYs = malloc(*nincY * sizeof(int));
         ATL_assert(*incYs);
         for (j=0; j < *nincY; j++)
         {
            if (args[i] == NULL) PrintUsage(args[0]);
            (*incYs)[j] = atoi(args[i++]);
         }
         break;
      case 'S':
         if (args[i] == NULL) PrintUsage(args[0]);
         *nside = atoi(args[i++]);
         if (*nside <= 0) PrintUsage(args[0]);
         *Side = malloc(*nside * sizeof(int));
         ATL_assert(*Side);
         for (j=0; j != *nside; j++)
         {
            if (args[i] == NULL) PrintUsage(args[0]);
            ch = *args[i++];
            if (ch == 'r' || ch == 'R') (*Side)[j] = AtlasRight;
            else if (ch == 'l' || ch == 'L') (*Side)[j] = AtlasLeft;
            else PrintUsage(args[0]);
         }
         break;
      case 'U':
         if (args[i] == NULL) PrintUsage(args[0]);
         *nuplo = atoi(args[i++]);
         if (*nuplo <= 0) PrintUsage(args[0]);
         *Uplo = malloc(*nuplo * sizeof(int));
         ATL_assert(*Uplo);
         for (j=0; j != *nuplo; j++)
         {
            if (args[i] == NULL) PrintUsage(args[0]);
            ch = *args[i++];
            if (ch == 'u' || ch == 'U') (*Uplo)[j] = AtlasUpper;
            else if (ch == 'l' || ch == 'L') (*Uplo)[j] = AtlasLower;
            else PrintUsage(args[0]);
         }
         break;
      case 'D':
         if (args[i] == NULL) PrintUsage(args[0]);
         *ndiag = atoi(args[i++]);
         if (*ndiag <= 0) PrintUsage(args[0]);
         *Diag = malloc(*ndiag * sizeof(int));
         ATL_assert(*Diag);
         for (j=0; j != *ndiag; j++)
         {
            if (args[i] == NULL) PrintUsage(args[0]);
            ch = *args[i++];
            if (ch == 'u' || ch == 'U') (*Diag)[j] = AtlasUnit;
            else if (ch == 'n' || ch == 'N') (*Diag)[j] = AtlasNonUnit;
            else PrintUsage(args[0]);
         }
         break;
      case 'A':
         if (args[i] == NULL) PrintUsage(args[0]);
         *nta   = atoi(args[i++]);
         if (*nta <= 0) PrintUsage(args[0]);
         *TransA = malloc(*nta * sizeof(int));
         ATL_assert(*TransA);
         for (j=0; j != *nta; j++)
         {
            if (args[i] == NULL) PrintUsage(args[0]);
            ch = *args[i++];
            if (ch == 'n' || ch == 'N') (*TransA)[j] = AtlasNoTrans;
            else if (ch == 't' || ch == 'T') (*TransA)[j] = AtlasTrans;
            else if (ch == 'c' || ch == 'C') (*TransA)[j] = AtlasConjTrans;
            else PrintUsage(args[0]);
         }
         break;
      case 'M':
         if (args[i] == NULL) PrintUsage(args[0]);
         *M0 = atoi(args[i++]);
         if (*M0 < 0) PrintUsage(args[0]);
         if (args[i] == NULL) PrintUsage(args[0]);
         *MN = atoi(args[i++]);
         if (*MN < 0) PrintUsage(args[0]);
         if (args[i] == NULL) PrintUsage(args[0]);
         *Minc = atoi(args[i++]);
         if (*Minc <= 0) PrintUsage(args[0]);
         break;
      case 'N':
         if (args[i] == NULL) PrintUsage(args[0]);
         *N0 = atoi(args[i++]);
         if (*N0 < 0) PrintUsage(args[0]);
         if (args[i] == NULL) PrintUsage(args[0]);
         *NN = atoi(args[i++]);
         if (*NN < 0) PrintUsage(args[0]);
         if (args[i] == NULL) PrintUsage(args[0]);
         *Ninc = atoi(args[i++]);
         if (*Ninc <= 0) PrintUsage(args[0]);
         break;
      case 'K':
         if (args[i] == NULL) PrintUsage(args[0]);
         *K0 = atoi(args[i++]);
         if (*K0 < 0) PrintUsage(args[0]);
         if (args[i] == NULL) PrintUsage(args[0]);
         *KN = atoi(args[i++]);
         if (*KN < 0) PrintUsage(args[0]);
         if (args[i] == NULL) PrintUsage(args[0]);
         *Kinc = atoi(args[i++]);
         if (*Kinc <= 0) PrintUsage(args[0]);
         break;
      case 'T':
         if (args[i] == NULL) PrintUsage(args[0]);
         *TEST = atoi(args[i++]);
         break;
      case 'R':
         if (args[i] == NULL) PrintUsage(args[0]);
         if (isdigit(*args[i]))
         {
            *nrouts = atoi(args[i++]);
            *Routs = malloc( (*nrouts) * sizeof(enum LVL2_ROUT) );
            ATL_assert(*Routs);
         }
         else
         {
            *nrouts = 1;
            *Routs = malloc( sizeof(enum LVL2_ROUT) );
            ATL_assert(*Routs);
         }
         for (j=0; j < *nrouts; j++)
         {
            if (args[i] == NULL) PrintUsage(args[0]);
            if ( !strcmp(args[i], "GEMV") || !strcmp(args[i], "gemv") )
               *(Routs)[j] = GEMV;
            else if ( !strcmp(args[i], "TRMV") || !strcmp(args[i], "trmv") )
               *(Routs)[j] = TRMV;
            #ifdef TREAL
               else if ( !strcmp(args[i], "GER") || !strcmp(args[i], "ger") )
                  *(Routs)[j] = GER;
            #else
               else if ( !strcmp(args[i], "GERU") || !strcmp(args[i], "geru") )
                  *(Routs)[j] = GERU;
               else if ( !strcmp(args[i], "GERC") || !strcmp(args[i], "gerc") )
                  *(Routs)[j] = GERC;
            #endif
            else if ( !strcmp(args[i], "ALL") || !strcmp(args[i], "all") )
            {
               if (*nrouts != 1) PrintUsage(args[0]);
               free(*Routs);
               *nrouts = 25;
               *Routs = malloc( *nrouts * sizeof(enum LVL2_ROUT) );
               ATL_assert(*Routs);
               for (j=0; j < *nrouts; j++) (*Routs)[j] = j;
            }
            else PrintUsage(args[0]);
            i++;
         } 
         break;
      case 'm':
         if (args[i] == NULL) PrintUsage(args[0]);
         *M0 = *MN = atoi(args[i++]);
         *Minc = 1;
         if (*M0 <= 0) PrintUsage(args[0]);
         break;
      case 'n':
         if (args[i] == NULL) PrintUsage(args[0]);
         *N0 = *NN = atoi(args[i++]);
         *Ninc = 1;
         if (*N0 < 0) PrintUsage(args[0]);
         break;
      case 'k':
         if (args[i] == NULL) PrintUsage(args[0]);
         *K0 = *KN = atoi(args[i++]);
         *Kinc = 1;
         if (*K0 <= 0) PrintUsage(args[0]);
         break;
      case 'a':
         if (args[i] == NULL) PrintUsage(args[0]);
         *nalphas = atoi(args[i++]);
         if (*nalphas <= 0)  PrintUsage(args[0]);
         *alphas = malloc(ATL_MulBySize(*nalphas ));
         ATL_assert(*alphas);
         for (j=0; j < *nalphas SHIFT; j++)
         {
            if (args[i] == NULL) PrintUsage(args[0]);
            (*alphas)[j] = atof(args[i++]);
         }
         break;
      case 'b':
         if (args[i] == NULL) PrintUsage(args[0]);
         *nbetas  = atoi(args[i++]);
         if (*nbetas <= 0)  PrintUsage(args[0]);
         *betas  = malloc(ATL_MulBySize(*nbetas ));
         ATL_assert(*betas );
         for (j=0; j < *nbetas SHIFT; j++)
         {
            if (args[i] == NULL) PrintUsage(args[0]);
            (*betas)[j] = atof(args[i++]);
         }
         break;
      case 'd':
         *LDA_IS_M  = atoi(args[i++]);
         break;
      default:
         PrintUsage(args[0]);
         break;
      }
   }
/*
 * Finish setting up defaults if the user has not selected
 */
   if (*N0 == -1)
   {
      *N0 = 100;
      *NN = 1000;
      *Ninc = 100;
   }
   if (*nside == -1)
   {
      *nside = 1;
      *Side = malloc(sizeof(int));
      ATL_assert(*Side);
      **Side = AtlasLeft;
   }
   if (*nuplo == -1)
   {
      *nuplo = 1;
      *Uplo = malloc(sizeof(int));
      ATL_assert(*Uplo);
      **Uplo = AtlasLower;
   }
   if (*nta == -1)
   {
      *nta = 1;
      *TransA = malloc(sizeof(int));
      ATL_assert(*TransA);
      **TransA = AtlasNoTrans;
   }
   if (*ndiag == -1)
   {
      *ndiag = 1;
      *Diag = malloc(sizeof(int));
      ATL_assert(*Diag);
      **Diag = AtlasNonUnit;
   }
   if (*nalphas == -1)
   {
      *nalphas = 1;
      *alphas = malloc(ATL_MulBySize(1));
      ATL_assert(*alphas);
      #ifdef TREAL
         **alphas = 1.0;
      #else
         **alphas = 1.0;
         (*alphas)[1] = 0.0;
      #endif
   }
   if (*nbetas  == -1)
   {
      *nbetas  = 1;
      *betas  = malloc(ATL_MulBySize(1));
      ATL_assert(*betas );
      #ifdef TREAL
         **betas  = 1.0;
      #else
         **betas  = 1.0;
         (*betas)[1] = 0.0;
      #endif
   }
   if (*nincX == -1)
   {
      *nincX = 1;
      *incXs = malloc(sizeof(int));
      **incXs = 1;
   }
   if (*nincY == -1)
   {
      *nincY = 1;
      *incYs = malloc(sizeof(int));
      **incYs = 1;
   }
   if (*nrouts == -1)
   {
      *nrouts = 1;
      *Routs = malloc( sizeof(enum LVL2_ROUT) );
      ATL_assert(*Routs);
      (*Routs)[0] = GEMV;
   }
}
int main(int nargs, char **args)
{
   int LDA_IS_M, TEST, nside, nuplo, nta, ndiag, M0, MN, incM, N0, NN, incN;
   int K0, KN, incK, nalphas, nbetas, nincX, nincY, nrouts, MFLOP;
   int *incXs, *incYs;
   TYPE *alphas, *betas;
   enum LVL2_ROUT *Routs;
   enum ATLAS_SIDE *Side;
   enum ATLAS_UPLO *Uplo;
   enum ATLAS_TRANS *TA;
   enum ATLAS_DIAG *Diag;
   extern TYPE eps;

   GetFlags(nargs, args, &TEST, &nside, &Side, &nuplo, &Uplo, &nta, &TA, 
            &ndiag, &Diag, &M0, &MN, &incM, &N0, &NN, &incN, &K0, &KN, &incK,
            &nalphas, &alphas, &nbetas, &betas, &nincX, &incXs, &nincY, &incYs,
            &nrouts, &Routs, &LDA_IS_M, &MFLOP);
   eps = Mjoin(PATL,epsilon)();
   RunCases(TEST, LDA_IS_M, MFLOP, nside, Side, nuplo, Uplo, nta, TA,
            ndiag, Diag, M0, MN, incM, N0, NN, incN, K0, KN, incK, 
            nalphas, alphas, nbetas, betas, nincX, incXs, nincY, incYs, 
            nrouts, Routs);
   free(Side);
   free(Uplo);
   free(TA);
   free(Diag);
   free(alphas);
   free(incXs);
   free(incYs);
   free(betas);
   free(Routs);
   return(0);
}
@ROUT atlas_lvl2.h
#include "atlas_level2.h"
#include "atlas_kernel2.h"
#ifndef ATLAS_LVL2_H
#define ATLAS_LVL2_H

int ATL_L2AIsOverlapped(int rank, int sz, size_t M, size_t N, 
                        size_t A, size_t lda);

/*
 * Real kernels
 */
@multidef typ double float
@whiledef pre d s 
@whiledef rt ger ger_L2 ger_L1 ger_OOC
void ATL_@(pre)@(rt)
   (ATL_CINT M, ATL_CINT N, const @(typ) alpha, const @(typ) *X,
    ATL_CINT incX, const @(typ) *Y, ATL_CINT incY, @(typ) *A, ATL_CINT lda);
@endwhile
@whiledef rt ger2 ger2_L2 ger2_L1 ger2_OOC
void ATL_@(pre)@(rt)
   (ATL_CINT M, ATL_CINT N, const @(typ) alpha, const @(typ) *X,
    ATL_CINT incX, const @(typ) *Y, ATL_CINT incY, const @(typ) beta,
    const @(typ) *W, ATL_CINT incW, const @(typ) *Z, ATL_CINT incZ,
    @(typ) *A, ATL_CINT lda);
@endwhile
void Mjoin(PATL,gemv)
   (const enum ATLAS_TRANS TA, ATL_CINT M, ATL_CINT N, const SCALAR alpha, 
    const TYPE *A, ATL_CINT lda, const TYPE *X, ATL_CINT incX, 
    const SCALAR beta, TYPE *Y, ATL_CINT incY);
@whiledef rt gemvT gemvT_L1 gemvT_L2 gemvN gemvN_L1 gemvN_L2
void Mjoin(PATL,@(rt))
   (ATL_CINT M, ATL_CINT N, const SCALAR alpha, const TYPE *A, ATL_CINT lda,
    const TYPE *X, ATL_CINT incX, const SCALAR beta, TYPE *Y, ATL_CINT incY);
@endwhile

@whiledef rt mvt mvn
void ATL_@(pre)@(rt)k_smallN
   (ATL_CINT M, ATL_CINT N, const @(typ) alpha, const @(typ) *A, ATL_CINT lda,
    const @(typ) *X, ATL_CINT incX, const @(typ) beta, 
    @(typ) *Y, ATL_CINT incY);
void ATL_@(pre)@(rt)k_Mlt16
   (ATL_CINT M, ATL_CINT N, const @(typ) alpha, const @(typ) *A, ATL_CINT lda,
    const @(typ) *X, ATL_CINT incX, const @(typ) beta, 
    @(typ) *Y, ATL_CINT incY);
@endwhile
void ATL_@(pre)ger2k_Mlt16
   (ATL_CINT M, ATL_CINT N, const @(typ) alpha, const @(typ) *X,
    ATL_CINT incX, const @(typ) *Y, ATL_CINT incY, const @(typ) beta,
    const @(typ) *W, ATL_CINT incW, const @(typ) *Z, ATL_CINT incZ,
    @(typ) *A, ATL_CINT lda);
void ATL_@(pre)ger2k_Nlt8
   (ATL_CINT M, ATL_CINT N, const @(typ) alpha, const @(typ) *X,
    ATL_CINT incX, const @(typ) *Y, ATL_CINT incY, const @(typ) beta,
    const @(typ) *W, ATL_CINT incW, const @(typ) *Z, ATL_CINT incZ,
    @(typ) *A, ATL_CINT lda);
void ATL_@(pre)gerk_Mlt16
   (const int M, const int N, const @(typ) alpha, const @(typ) *X,
    const int incX, const @(typ) *Y, const int incY, @(typ) *A, const int lda);
void ATL_@(pre)gerk_axpy
   (const int M, const int N, const @(typ) alpha, const @(typ) *X,
    const int incX, const @(typ) *Y, const int incY, @(typ) *A, const int lda);
@beginskip
   @whiledef up L U
      @whiledef ta T N
         @whiledef di N U
void ATL_@(pre)trmv@(up)@(ta)
   (const enum ATLAS_DIAG Diag, const int N, const @(typ) *A, const int lda,
    const @(typ) *X, @(typ) *Y);
void ATL_@(pre)ktrmv@(up)@(ta)@(di)
   (const int N, const @(typ) *A, const int lda, const @(typ) *X, 
    const int BetaIsOne, @(typ) *Y);
         @endwhile
      @endwhile
   @endwhile
@endskip
   @undef typ
@endwhile

/*
 * Complex kernels
 */
@multidef typ double float
@whiledef pre z c 
@multidef rt gemvN gemvN_L1 gemvN_L2 gemvCN gemvCN_L1 gemvCN_L2
@whiledef rt gemvT gemvT_L1 gemvT_L2 gemvCT gemvCT_L1 gemvCT_L2
void Mjoin(PATL,@(rt))
   (ATL_CINT M, ATL_CINT N, const SCALAR alpha, const TYPE *A, ATL_CINT lda,
    const TYPE *X, ATL_CINT incX, const SCALAR beta, TYPE *Y, ATL_CINT incY);
@endwhile
@whiledef rt gerc gerc_L1 gerc_L2 gerc_OOC geru geru_L1 geru_L2 geru_OOC
void ATL_@(pre)@(rt)
   (ATL_CINT M, ATL_CINT N, const @(typ) *alpha, const @(typ) *X,
    ATL_CINT incX, const @(typ) *Y, ATL_CINT incY, @(typ) *A, ATL_CINT lda);
@endwhile
@whiledef rt ger2c ger2c_L1 ger2c_L2 ger2c_OOC ger2u ger2u_L1 ger2u_L2 ger2u_OOC
void ATL_@(pre)@(rt)
   (ATL_CINT M, ATL_CINT N, const @(typ) *alpha, const @(typ) *X,
    ATL_CINT incX, const @(typ) *Y, ATL_CINT incY, const @(typ) *beta,
    const @(typ) *W, ATL_CINT incW, const @(typ) *Z, ATL_CINT incZ,
    @(typ) *A, ATL_CINT lda);
@endwhile
@whiledef rt mvt mvn
void ATL_@(pre)@(rt)k_smallN
   (ATL_CINT M, ATL_CINT N, const @(typ) *alpha, const @(typ) *A, ATL_CINT lda,
    const @(typ) *X, ATL_CINT incX, const @(typ) *beta, 
    @(typ) *Y, ATL_CINT incY);
void ATL_@(pre)@(rt)k_Mlt16
   (ATL_CINT M, ATL_CINT N, const @(typ) *alpha, const @(typ) *A, ATL_CINT lda,
    const @(typ) *X, ATL_CINT incX, const @(typ) *beta, 
    @(typ) *Y, ATL_CINT incY);
@endwhile
void ATL_@(pre)ger2ck_Mlt16
   (ATL_CINT M, ATL_CINT N, const @(typ) *alpha, const @(typ) *X,
    ATL_CINT incX, const @(typ) *Y, ATL_CINT incY, const @(typ) *beta,
    const @(typ) *W, ATL_CINT incW, const @(typ) *Z, ATL_CINT incZ,
    @(typ) *A, ATL_CINT lda);
void ATL_@(pre)ger2ck_Nlt8
   (ATL_CINT M, ATL_CINT N, const @(typ) *alpha, const @(typ) *X,
    ATL_CINT incX, const @(typ) *Y, ATL_CINT incY, const @(typ) *beta,
    const @(typ) *W, ATL_CINT incW, const @(typ) *Z, ATL_CINT incZ,
    @(typ) *A, ATL_CINT lda);
void ATL_@(pre)ger2k_Mlt16
   (ATL_CINT M, ATL_CINT N, const @(typ) *alpha, const @(typ) *X,
    ATL_CINT incX, const @(typ) *Y, ATL_CINT incY, const @(typ) *beta,
    const @(typ) *W, ATL_CINT incW, const @(typ) *Z, ATL_CINT incZ,
    @(typ) *A, ATL_CINT lda);
void ATL_@(pre)ger2k_Nlt8
   (ATL_CINT M, ATL_CINT N, const @(typ) *alpha, const @(typ) *X,
    ATL_CINT incX, const @(typ) *Y, ATL_CINT incY, const @(typ) *beta,
    const @(typ) *W, ATL_CINT incW, const @(typ) *Z, ATL_CINT incZ,
    @(typ) *A, ATL_CINT lda);
void ATL_@(pre)gerck_Mlt16
   (const int M, const int N, const @(typ) *alpha, const @(typ) *X,
    const int incX, const @(typ) *Y, const int incY, @(typ) *A, const int lda);
void ATL_@(pre)gerck_axpy
   (const int M, const int N, const @(typ) *alpha, const @(typ) *X,
    const int incX, const @(typ) *Y, const int incY, @(typ) *A, const int lda);
void ATL_@(pre)gerk_Mlt16
   (const int M, const int N, const @(typ) *alpha, const @(typ) *X,
    const int incX, const @(typ) *Y, const int incY, @(typ) *A, const int lda);
void ATL_@(pre)gerk_axpy
   (const int M, const int N, const @(typ) *alpha, const @(typ) *X,
    const int incX, const @(typ) *Y, const int incY, @(typ) *A, const int lda);
@beginskip
   @whiledef up L U
      @whiledef ta Nc C T N
         @whiledef di N U
void ATL_@(pre)trmv@(up)@(ta)
   (const enum ATLAS_DIAG Diag, const int N, const @(typ) *A, const int lda,
    const @(typ) *X, @(typ) *Y);
void ATL_@(pre)ktrmv@(up)@(ta)@(di)
   (const int N, const @(typ) *A, const int lda, const @(typ) *X, 
    const int BetaIsOne, @(typ) *Y);
         @endwhile
      @endwhile
   @endwhile
@endskip
   @undef typ
@endwhile

#endif
@ROUT atlas_level2.h
/*
 * ===========================================================================
 * Prototypes for level 2 BLAS
 * ===========================================================================
 */
#ifndef ATLAS_LEVEL2_H
#define ATLAS_LEVEL2_H

int ATL_L2AIsOverlapped(int rank, int sz, size_t M, size_t N, 
                        size_t A, size_t lda);
/* 
 * Routines with standard 4 prefixes (S, D, C, Z)
 */
@multidef sty double@^* float@^* double@^ float@^
@multidef typ double float double float
@whiledef pre z c d s
void ATL_@(pre)gemv(const enum ATLAS_TRANS TransA, const int M, const int N,
               const @(sty)alpha, const @(typ) *A, const int lda,
               const @(typ) *X, const int incX, const @(sty)beta,
               @(typ) *Y, const int incY);
@whiledef rt gemvT gemvT_L1 gemvT_L2 gemvN gemvN_L1 gemvN_L2
void ATL_@(pre)@(rt)
   (ATL_CINT M, ATL_CINT N, const @(sty)alpha, const @(typ) *A, ATL_CINT lda,
    const @(typ) *X, ATL_CINT incX, const @(sty)beta, @(typ) *Y, ATL_CINT incY);
@endwhile
void ATL_@(pre)gbmv(const enum ATLAS_TRANS TransA, const int M, const int N,
               const int KL, const int KU, const @(sty)alpha,
               const @(typ) *A, const int lda, const @(typ) *X,
               const int incX, const @(sty)beta, @(typ) *Y, const int incY);
void ATL_@(pre)trmv(const enum ATLAS_UPLO Uplo, const enum ATLAS_TRANS TransA,
               const enum ATLAS_DIAG Diag, const int N,
               const @(typ) *A, const int lda, @(typ) *X, const int incX);
void ATL_@(pre)tbmv(const enum ATLAS_UPLO Uplo, const enum ATLAS_TRANS TransA,
               const enum ATLAS_DIAG Diag, const int N, const int K,
               const @(typ) *A, const int lda, @(typ) *X, const int incX);
void ATL_@(pre)tpmv(const enum ATLAS_UPLO Uplo, const enum ATLAS_TRANS TransA,
               const enum ATLAS_DIAG Diag, const int N, const @(typ) *Ap, 
               @(typ) *X, const int incX);
void ATL_@(pre)trsv(const enum ATLAS_UPLO Uplo, const enum ATLAS_TRANS TransA,
               const enum ATLAS_DIAG Diag, const int N,
               const @(typ) *A, const int lda, @(typ) *X, const int incX);
void ATL_@(pre)tbsv(const enum ATLAS_UPLO Uplo, const enum ATLAS_TRANS TransA,
               const enum ATLAS_DIAG Diag, const int N, const int K,
               const @(typ) *A, const int lda, @(typ) *X, const int incX);
void ATL_@(pre)tpsv(const enum ATLAS_UPLO Uplo, const enum ATLAS_TRANS TransA,
               const enum ATLAS_DIAG Diag, const int N,
               const @(typ) *Ap, @(typ) *X, const int incX);
   @undef typ
   @undef sty

@endwhile

/* 
 * Routines with S and D prefixes only
 */
@multidef typ double float
@whiledef pre d s
void ATL_@(pre)symv(const enum ATLAS_UPLO Uplo, const int N,
               const @(typ) alpha, const @(typ) *A, const int lda,
               const @(typ) *X, const int incX, const @(typ) beta,
               @(typ) *Y, const int incY);
void ATL_@(pre)sbmv(const enum ATLAS_UPLO Uplo, const int N, const int K,
               const @(typ) alpha, const @(typ) *A, const int lda,
               const @(typ) *X, const int incX, const @(typ) beta,
               @(typ) *Y, const int incY);
void ATL_@(pre)spmv(const enum ATLAS_UPLO Uplo, const int N, const @(typ) alpha,
               const @(typ) *Ap, const @(typ) *X, const int incX,
               const @(typ) beta, @(typ) *Y, const int incY);
@whiledef rt ger ger_L2 ger_L1 ger_OOC
void ATL_@(pre)@(rt)
   (const int M, const int N, const @(typ) alpha, const @(typ) *X, 
    const int incX, const @(typ) *Y, const int incY, @(typ) *A, const int lda);
@endwhile
@whiledef rt ger2 ger2_L2 ger2_L1 ger2_OOC
void ATL_@(pre)@(rt)
   (const int M, const int N, const @(typ) alpha, const @(typ) *X, 
    const int incX, const @(typ) *Y, const int incY, const @(typ) beta,
    const @(typ) *W, const int incW, const @(typ) *Z, const int incZ,
    @(typ) *A, const int lda);
@endwhile
void ATL_@(pre)syr(const enum ATLAS_UPLO Uplo, const int N, const @(typ) alpha,
              const @(typ) *X, const int incX, @(typ) *A, const int lda);
void ATL_@(pre)spr(const enum ATLAS_UPLO Uplo, const int N, const @(typ) alpha,
              const @(typ) *X, const int incX, @(typ) *Ap);
void ATL_@(pre)syr2(const enum ATLAS_UPLO Uplo, const int N, const @(typ) alpha,
               const @(typ) *X, const int incX, const @(typ) *Y, const int incY,
               @(typ) *A, const int lda);
void ATL_@(pre)spr2(const enum ATLAS_UPLO Uplo, const int N, const @(typ) alpha,
               const @(typ) *X, const int incX, const @(typ) *Y, const int incY,
               @(typ) *A);
   @undef typ

@endwhile

/* 
 * Routines with C and Z prefixes only
 */
@multidef styp double@^* float@^*
@multidef typ double float
@whiledef pre z c
@whiledef rt gemvCT gemvCT_L1 gemvCT_L2 gemvCN gemvCN_L1 gemvCN_L2
void ATL_@(pre)@(rt)
   (ATL_CINT M, ATL_CINT N, const @(styp)alpha, const @(typ) *A, ATL_CINT lda,
    const @(typ) *X, ATL_CINT incX, const @(styp)beta, @(typ) *Y, ATL_CINT incY);
@endwhile
void ATL_@(pre)hemv(const enum ATLAS_UPLO Uplo, const int N,
               const @(styp)alpha, const @(typ) *A, const int lda,
               const @(typ) *X, const int incX, const @(typ) *beta,
               @(typ) *Y, const int incY);
void ATL_@(pre)hbmv(const enum ATLAS_UPLO Uplo, const int N, const int K,
               const @(styp)alpha, const @(typ) *A, const int lda,
               const @(typ) *X, const int incX, const @(styp)beta,
               @(typ) *Y, const int incY);
void ATL_@(pre)hpmv(const enum ATLAS_UPLO Uplo, const int N,
               const @(styp)alpha, const @(typ) *Ap,
               const @(typ) *X, const int incX, const @(typ) *beta,
               @(typ) *Y, const int incY);
@whiledef rt geru geru_L1 geru_L2 geru_OOC gerc gerc_L1 gerc_L2 gerc_OOC
void ATL_@(pre)@(rt)
   (const int M, const int N, const @(styp)alpha, const @(typ) *X, 
    const int incX, const @(typ) *Y, const int incY, @(typ) *A, const int lda);
@endwhile

@whiledef rt ger2u ger2u_L1 ger2u_L2 ger2u_OOC ger2c ger2c_L1 ger2c_L2 ger2c_OOC
void ATL_@(pre)@(rt)
   (const int M, const int N, const @(styp)alpha, const @(typ) *X, 
    const int incX, const @(typ) *Y, const int incY, const @(styp)beta, 
    const @(typ) *W, const int incW, const @(typ) *Z, const int incZ,
    @(typ) *A, const int lda);
@endwhile
void ATL_@(pre)her(const enum ATLAS_UPLO Uplo, const int N, const @(typ) alpha,
              const @(typ) *X, const int incX, @(typ) *A, const int lda);
void ATL_@(pre)hpr(const enum ATLAS_UPLO Uplo, const int N, const @(typ) alpha,
                   const @(typ) *X, const int incX, @(typ) *A);
void ATL_@(pre)her2(const enum ATLAS_UPLO Uplo, const int N,
               const @(styp)alpha, const @(typ) *X, const int incX,
               const @(typ) *Y, const int incY, @(typ) *A, const int lda);
void ATL_@(pre)hpr2(const enum ATLAS_UPLO Uplo, const int N,
               const @(styp)alpha, const @(typ) *X, const int incX,
               const @(typ) *Y, const int incY, @(typ) *Ap);
   @undef styp
   @undef typ

@endwhile

#endif
@rout mvktime
   @define rt @mv@
@rout r1ktime
   @define rt @r1@
@rout r2ktime
   @define rt @r2@
@ROUT mvksearch r1ktime r2ktime mvktime
@extract -b @(topd)/cw.inc lang=c -define cwdate 2009 -define cwdate 2010
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <string.h>
#include "atlas_misc.h"
#include "atlas_cache.h"
#include Mstr(Mjoin(Mjoin(atlas_,PRE),sysinfo.h))

@ROUT r1ktime r2ktime mvktime
static char *resfile=NULL;
static FILE *fpres=NULL;
@ROUT r1ktime
   @define rt @r1@
@ROUT r2ktime
   @define rt @r2@
@ROUT r1ktime r2ktime mvktime
@extract -b @(topd)/FAmalloc.inc
#include "atlas_@(rt)testtime.h"

@ROUT r2ktime
#ifdef TIME_KERNEL
   void ATL_UGER2K(ATL_CINT M, ATL_CINT N, const TYPE *X, const TYPE *Y, 
                   const TYPE *X1, const TYPE *Y1, TYPE *A, ATL_CINT lda);
#else
   void Mjoin(PATL,ger2)(ATL_CINT, ATL_CINT, const SCALAR, const TYPE*, 
                         ATL_CINT, const TYPE *, ATL_CINT, const SCALAR, 
                         const TYPE*, ATL_CINT, const TYPE *, ATL_CINT, 
                         TYPE *, ATL_CINT);
   #ifdef TREAL
      #define test_ger2(M, N, alpha, X, incX, Y, incY, \
                        alpha1, X1, incX1, Y1, incY1, A, lda) \
         Mjoin(PATL,ger2)(M, N, *alpha, X, incX, Y, incY, \
                          *alpha1, X1, incX1, Y1, incY1, A, lda)
   #else
      #define test_ger2(M, N, alpha, X, incX, Y, incY, \
                        alpha1, X1, incX1, Y1, incY1, A, lda) \
         Mjoin(PATL,ger2u)(M, N, alpha, X, incX, Y, incY, \
                           alpha1, X1, incX1, Y1, incY1, A, lda)
   #endif
#endif
@ROUT r1ktime
#ifdef TIME_KERNEL
   void ATL_UGERK(ATL_CINT M, ATL_CINT N, const TYPE *X, const TYPE *Y, 
                  TYPE *A, ATL_CINT lda);
#else
   void Mjoin(PATL,ger)(ATL_CINT, ATL_CINT, const SCALAR, const TYPE*, ATL_CINT, 
                        const TYPE *, ATL_CINT, TYPE *, ATL_CINT);
   #ifdef TREAL
      #define test_ger(M, N, alpha, X, incX, Y, incY, A, lda) \
         Mjoin(PATL,ger)(M, N, *alpha, X, incX, Y, incY, A, lda)
   #else
      #define test_ger(M, N, alpha, X, incX, Y, incY, A, lda) \
         Mjoin(PATL,geru)(M, N, alpha, X, incX, Y, incY, A, lda)
   #endif
#endif
@ROUT mvktime
#ifdef TIME_KERNEL
   void ATL_UGEMV(ATL_CINT M, ATL_CINT N, const TYPE *A, ATL_CINT lda, 
                  const TYPE *X, TYPE *Y);
#else
   #ifdef ATL_TRANS_
      void Mjoin(PATL,gemvT)
         (ATL_CINT M, ATL_CINT N, const SCALAR alpha, const TYPE *A, 
          ATL_CINT lda, const TYPE *X, ATL_CINT incX, 
          const SCALAR beta, TYPE *Y, ATL_CINT incY);
      #ifdef TREAL
         #define test_gemv(M, N, alpha, A, lda, X, incX, beta, Y, incY) \
            Mjoin(PATL,gemvT)(M, N, *alpha, A, lda, X, incX, *beta, Y, incY)
      #else
         #define test_gemv(M, N, alpha, A, lda, X, incX, beta, Y, incY) \
            Mjoin(PATL,gemvT)(M, N, alpha, A, lda, X, incX, beta, Y, incY)
      #endif
   #else
      void Mjoin(PATL,gemvN)
         (ATL_CINT M, ATL_CINT N, const SCALAR alpha, const TYPE *A, 
          ATL_CINT lda, const TYPE *X, ATL_CINT incX, 
          const SCALAR beta, TYPE *Y, ATL_CINT incY);
      #ifdef TREAL
         #define test_gemv(M, N, alpha, A, lda, X, incX, beta, Y, incY) \
            Mjoin(PATL,gemvN)(M, N, *alpha, A, lda, X, incX, *beta, Y, incY)
      #else
         #define test_gemv(M, N, alpha, A, lda, X, incX, beta, Y, incY) \
            Mjoin(PATL,gemvN)(M, N, alpha, A, lda, X, incX, beta, Y, incY)
      #endif
   #endif
#endif
@ROUT r1ktime r2ktime mvktime

double Time2Flop(ATL_INT M, ATL_INT N, double time)
{
   if (time == 0.0 || time != time)
      return(0.0);
@ROUT r1ktime
   @define omul @@
@ROUT r2ktime
   @define omul @2*@
@ROUT r1ktime r2ktime
   #ifdef TREAL
      return(@(omul)((1.0*M)*(2.0*N)+Mmin(M,N))/(time*1.0e6));
   #else
      return(@(omul)((((6.0*M)*N+Mmin(M,N)) + (2.0*M)*N)*1.0e-6)/time);
   #endif
@ROUT mvktime
   #ifdef TREAL
      return(((1.0e-6 * M)*(2.0*N+1.0))/time);
   #else
      return((((6.0*M)*(N+1.0) + (2.0*M)*N)*1.0e-6)/time);
   #endif
@ROUT r1ktime r2ktime mvktime
}

void Times2Flops(ATL_INT M, ATL_INT N, ATL_INT ntim, double *mf)
/*
 * Converts time to MFLOP
 */
{
   int i;

   for (i=0; i < ntim; i++)
      mf[i] = Time2Flop(M, N, mf[i]);
}

static double mysum(ATL_CINT N, double *d)
{
   int i;
   double sum;

   sum = d[0];
   for (i=1; i < N; i++)
      sum += d[i];
   return(sum);
}

@ROUT r1ktime r2ktime
   #define NX M
   #define NY N
@ROUT mvktime
#ifdef ATL_TRANS_
   #define NX M
   #define NY N
#else
   #define NX N
   #define NY M
#endif
@ROUT r1ktime r2ktime mvktime
#ifdef TIME_KERNEL
double @(rt)time(
   int verb,            /* verbosity */
   int nreps,           /* number of reps to do for one timing sample */
   size_t flushelts,    /* size of area to flush to avoid cache reuse */
   ATL_INT M,           /* # of rows of array A */
   ATL_INT N,           /* # of cols of array A */
   TYPE *alpha,
@ROUT mvktime `   TYPE *beta,`
   ATL_INT lda,         /* leading dim */
   int incX,            /* ignored, assumed 1 by definition */
   int incY,            /* increment on Y; can be non-1 */
   int FAa,             /* if (FA. = 0) enforce no alignment */
   int MAa,             /* else force op to be aligned to at least FA bytes */
   int FAx,             /* if MA. != 0, disallow op to be aligned to MA. byts */
   int MAx,
   int FAy,
   int MAy)
/* 
 * This function directly calls the kernel routine on data that has been
 * preloaded (through initialization) to any cache large enough to hold it.
 */
{
   double t0, t1;
   TYPE *A, *X, *Y;
   ATL_INT i;
   int k;
@ROUT r2ktime
   TYPE *X1, *Y1;
   #ifdef TREAL
      const TYPE negalpha[1] = {-alpha[0]};
   #else
      const TYPE negalpha[2] = {-alpha[0], -alpha[1]};
   #endif
@ROUT r1ktime r2ktime mvktime

   A = FA_malloc(ATL_MulBySize(lda)*N, FAa, MAa);
   X = FA_malloc(ATL_MulBySize(NX), FAx, MAx);
   Y = FA_malloc(ATL_MulBySize(NY*incY), FAy, MAy);
   ATL_assert(A && X && Y);
@ROUT r2ktime
   X1 = FA_malloc(ATL_MulBySize(NX), FAx, MAx);
   Y1 = FA_malloc(ATL_MulBySize(NY*incY), FAy, MAy);
   ATL_assert(X1 && Y1);
@ROUT r1ktime r2ktime mvktime

   Mjoin(PATL,gegen)(1, NY, Y, incY, M);
   Mjoin(PATL,gegen)(NX, 1, X, NX, N+127*50+77);
@ROUT r2ktime
   Mjoin(PATL,gegen)(1, NY, Y1, incY, M);         /* for timing, just use */
   Mjoin(PATL,gegen)(NX, 1, X1, M, N+127*50+77);  /* same data for X1/Y1 */
@ROUT r1ktime r2ktime mvktime
   Mjoin(PATL,gegen)(M, N, A, lda, N*M+513*7+90);
/*
 * NOTE: if nreps too high this could lead to under/overflow
 */
   for (k=0; k < 8; k++)  /* loop until results are believable, or give up */
   {
      t0 = time00();
      for (i=nreps; i; i--)
      {
@ROUT r2ktime
         ATL_UGER2K(M, N, X, Y, X1, Y1, A, lda);
@ROUT r1ktime
         ATL_UGERK(M, N, X, Y, A, lda);
@ROUT mvktime
         ATL_UGEMV(M, N, A, lda, X, Y);
@ROUT r1ktime r2ktime mvktime
      }
      t1 = time00();
      if (t1 > t0) break;
      nreps = (nreps) ? nreps+nreps : 1;
   }
   t1 = (t1 - t0)/(1.0*nreps);
   if (verb)
      fprintf(stdout, "   M=%d, N=%d, lda=%d, nreps=%d, time=%e, mflop=%.2f\n",
              M, N, lda, nreps, t1, Time2Flop(M, N, t1));
   FA_free(A, FAa, MAa);
   FA_free(X, FAx, MAx);
   FA_free(Y, FAy, MAy);
@ROUT r2ktime
   FA_free(X1, FAx, MAx);
   FA_free(Y1, FAy, MAy);
@ROUT r1ktime r2ktime mvktime
   return(t1);
}
#else
@ROUT r1ktime r2ktime mvktime
double @(rt)time(
   int verb,            /* verbosity */
   int nreps,           /* number of reps to do for one timing sample */
   ATL_INT flushelts,   /* size of area to flush to avoid cache reuse */
   ATL_INT M,           /* # of rows of array A */
   ATL_INT N,           /* # of cols of array A */
   TYPE *alpha,
@ROUT mvktime `   TYPE *beta,`
   ATL_INT lda,         /* leading dim */
   int mu,              /* unrolling on M */
   int nu,              /* unrolling on N */
   int FAa,             /* if (FA. = 0) enforce no alignment */
   int MAa,             /* else force op to be aligned to at least FA bytes */
   int FAx,             /* if MA. != 0, disallow op to be aligned to MA. bytes*/
   int MAx,
   int FAy,
   int MAy)
@ROUT r1ktime r2ktime mvktime
/*
 * Times the kernel for out-of-cache (where flushelts sets the cache that it
 * is not allowed to be in) use.  
 * RETURNS: elapsed time in seconds to average repitition of indicated problem.
@ROUT r2ktime
 * NOTE: This timer adapted from r1ktime, and just reuses x & y as X1, Y1
 *       for rank-2 update.  This may affect timings for highly rectangular
 *       matrices with one small dim where the vector costs are important!
@ROUT r1ktime r2ktime mvktime
 */
{
   #ifdef TREAL
      TYPE NONE = -1.0;
@rout r2ktime `   TYPE nalpha[1] = {-alpha[0]};`
@rout mvktime `   TYPE nbeta[1] = {-beta[0]}, *be=beta;`
   #else
      TYPE NONE[2] = {-1.0, 0.0};
@rout r2ktime `   TYPE nalpha[2] = {-alpha[0], -alpha[1]};`
@rout mvktime `   TYPE nbeta[2] = {-beta[0], -beta[1]}, *be=beta;`
   #endif
   double t0, t1;
   TYPE *A, *X, *Y, *a, *x, *y;
   void *vmem;
@ROUT r1ktime r2ktime mvktime
   size_t Aelts, Xelts, Yelts, setspan, ygap, xgap, agap, pregap, setsz, nsets;
   size_t ptr_st;
   ATL_INT i, j;
   int k, maxalign;

   if (MAx)
      assert(MAx != FAx);
   if (MAy)
      assert(MAy != FAy);
   if (MAa)
      assert(MAa != FAa);
/*
 * Find basic length of each operand in elements
 */
   Aelts = lda * N;
@ROUT mvktime
   #ifdef ATL_TRANS_
      Xelts = M;
      Yelts = N;
   #else
      Xelts = N;
      Yelts = M;
   #endif
@ROUT r1ktime r2ktime
   Xelts = M;
   Yelts = N;
@ROUT r1ktime r2ktime mvktime
/*
 * Map memory so that we can enforce all required alignments while moving
 * through memory; mem starts with maxalign-aligned memory, so that we can
 * guarantee all further alignments
 */
   @beginskip
   maxalign = (MAx >= MAa) ? MAx : MAa;
   maxalign = (maxalign >= MAy) ? maxalign : MAy;
   maxalign = (maxalign >= FAy) ? maxalign : FAy;
   maxalign = (maxalign >= FAx) ? maxalign : FAx;
   maxalign = (maxalign >= FAa) ? maxalign : FAa;
   @endskip
   maxalign = (MAx) ? MAx : 1;
   if (MAy)
      maxalign = ATL_lcm(MAy,maxalign);
   if (MAa)
      maxalign = ATL_lcm(MAa,maxalign);
   if (FAx)
      maxalign = ATL_lcm(FAx,maxalign);
   if (FAy)
      maxalign = ATL_lcm(FAy,maxalign);
   if (FAa)
      maxalign = ATL_lcm(FAa,maxalign);
   if (maxalign == 1)
      maxalign = 0;
   j = (FAx) ? FAx : sizeof(TYPE);
   if (MAx)
      for (i=0; (i % j != 0 || i%MAx == 0); i += sizeof(TYPE));
   else if (FAx)
      for (i=0; i % j != 0 ; i += sizeof(TYPE));
   else 
      i = 0;
   pregap = i;
   xgap = ATL_MulBySize(Xelts);
   if (FAy || MAy)
   {
      j = (FAy) ? FAy : sizeof(TYPE);
      if (MAy)
         for (i=pregap+xgap; (i%j != 0 || i%MAy == 0); i += sizeof(TYPE));
      else
         for (i=pregap+xgap; (i%j != 0); i += sizeof(TYPE));
      xgap = i - pregap;
   }
   ygap = ATL_MulBySize(Yelts);
   if (FAa || MAa)
   {
      j = (FAa) ? FAa : sizeof(TYPE);
      if (MAa)
         for (i=pregap+xgap+ygap; (i%j != 0 || i%MAa == 0); i += sizeof(TYPE));
      else
         for (i=pregap+xgap+ygap; (i%j != 0); i += sizeof(TYPE));
      ygap = i - pregap - xgap;
   }
   agap = ATL_MulBySize(Aelts);

   if (maxalign)
   {
      j = pregap;
      for (i=pregap+xgap+ygap+agap; i%maxalign != 0; i++);
      agap = i-pregap-xgap-ygap;
   }
   setspan = pregap + xgap + ygap + agap;
   assert(setspan%sizeof(TYPE) == 0);
   setsz = ATL_MulBySize(M+N+M*N);
   nsets = (ATL_MulBySize(flushelts)+setsz-1)/setsz;
   if (!nsets)
      nsets = 1;
   vmem = malloc(maxalign + nsets*setspan);
   assert(vmem);
   if (maxalign)   /* start maxaligned to guarantee all alignments */
      for (ptr_st = (size_t)vmem; ptr_st%maxalign; ptr_st++);
   else ptr_st = (size_t) vmem;
   X = (TYPE*) (ptr_st + pregap);
   Y = (TYPE*) (ptr_st + pregap + xgap);
   A = (TYPE*) (ptr_st + pregap + xgap + ygap);
/*
 * Set ptrs to last set in memory
 */
   setspan /= sizeof(TYPE);
   a = A += (nsets-1) * setspan;
   x = X += (nsets-1) * setspan;
   y = Y += (nsets-1) * setspan;
   for (i=nsets; i; i--)
   {
      #define DEBUG_FA
      #ifdef DEBUG_FA
         if (FAa)
            assert(((size_t)a)%FAa == 0);
         if (FAx)
            assert(((size_t)x)%FAx == 0);
         if (FAy)
            assert(((size_t)y)%FAy == 0);
         if (MAa)
            assert(((size_t)a)%MAa != 0);
         if (MAx)
            assert(((size_t)x)%MAx != 0);
         if (MAy)
            assert(((size_t)y)%MAy != 0);
      #endif
      Mjoin(PATL,gegen)(Yelts, 1, y, Yelts, M);
      Mjoin(PATL,gegen)(Xelts, 1, x, Xelts, N+127*50+77);
      if (i&1)
         Mjoin(PATL,scal)(Xelts, NONE, x, 1);
      Mjoin(PATL,gegen)(M, N, A, lda, N*M+513*7+90);
      a -= setspan; x -= setspan; y -= setspan;
   }
   a = A; x = X; y = Y;

   j=0;
   for (k=0; k < 8; k++) /* loop until good timing or too many trips */
   {
      t0 = time00();
      for (i=nreps; i; i--)
      {
@ROUT r1ktime `         test_ger(M, N, alpha, x, 1, y, 1, A, lda);`
@ROUT mvktime `         test_gemv(M, N, alpha, A, lda, x, 1, be, y, 1);`
@ROUT r2ktime `         test_ger2(M, N, alpha, x, 1, y, 1, nalpha, x, 1, y, 1, A, lda);`
         if (++j < nsets) { a -= setspan; x -= setspan; y -= setspan; }
@ROUT mvktime
         else  { a = A; x = X; y = Y; j=0; be = (be == beta) ? nbeta : beta;}
@ROUT r1ktime r2ktime
         else  { a = A; x = X; y = Y; j=0; }
@ROUT r1ktime r2ktime mvktime
      }
      t1 = time00();
      if (t1 > t0) 
         break;
      nreps = (nreps) ? nreps+nreps : 1;
   }
   free(vmem);
   t1 = (t1-t0) / (1.0*nreps);
   if (verb)
      fprintf(stdout, "   M=%d, N=%d, lda=%d, nreps=%d, time=%e, mflop=%.2f\n",
              M, N, lda, nreps, t1, Time2Flop(M, N, t1));
   return(t1);
}
@ROUT r2ktime r1ktime mvktime `#endif`

@ROUT mvktime
void DoTimes(int verb, size_t flshelts, ATL_INT ntim, ATL_INT nrep, 
             ATL_INT mu, ATL_INT nu, ATL_INT M, ATL_INT N, TYPE *alpha, 
             TYPE *beta, ATL_INT lda, 
             int FAa, int MAa, int FAx, int MAx, int FAy, int MAy)
@ROUT r1ktime r2ktime
void DoTimes(int verb, size_t flshelts, ATL_INT ntim, ATL_INT nrep, 
             ATL_INT mu, ATL_INT nu, ATL_INT M, ATL_INT N, TYPE *alpha, 
             ATL_INT lda, int FAa, int MAa, int FAx, int MAx, int FAy, int MAy)
@ROUT r1ktime r2ktime mvktime
{
   double *times;
   int i;

   times = malloc(ntim * sizeof(double));
   assert(times);
   
@ROUT r1ktime r2ktime
#ifdef TREAL
   fprintf(stdout, 
   "GE@up@(rt): M=%d, N=%d, lda=%d, AF=[%d,%d,%d], AM=[%d,%d,%d], alpha=%e:\n",
           M, N, lda, FAa, FAx, FAy, MAa, MAx, MAy, *alpha);
#else
   fprintf(stdout, "GE@up@(rt): M=%d, N=%d, lda=%d, AF=[%d,%d,%d], AM=[%d,%d,%d], alpha=[%e,%e]:\n",
           M, N, lda, FAa, FAx, FAy, MAa, MAx, MAy, *alpha, alpha[1]);
#endif
   for (i=0; i < ntim; i++)
      times[i] = @(rt)time(verb, nrep, flshelts, M, N, alpha, lda,
                        mu, nu, FAa, MAa, FAx, MAx, FAy, MAy);
@ROUT mvktime
#ifdef TREAL
   fprintf(stdout, "GEMV: M=%d, N=%d, lda=%d, AF=[%d,%d,%d], AM=[%d,%d,%d], beta=%e, alpha=%e:\n",
           M, N, lda, FAa, FAx, FAy, MAa, MAx, MAy, *beta, *alpha);
#else
   fprintf(stdout, "GEMV: M=%d, N=%d, lda=%d, AF=[%d,%d,%d], AM=[%d,%d,%d], beta=[%e,%e], alpha=[%e,%e]:\n",
           M, N, lda, FAa, FAx, FAy, MAa, MAx, MAy, 
           *beta, beta[1], *alpha, alpha[1]);
#endif
@ROUT mvktime
   for (i=0; i < ntim; i++)
      times[i] = @(rt)time(verb, nrep, flshelts, M, N, alpha, beta, lda,
                        mu, nu, FAa, MAa, FAx, MAx, FAy, MAy);
@ROUT r1ktime r2ktime mvktime
   SortDoubles(ntim, times);
   Times2Flops(M, N, ntim, times);
   if (fpres)
   {
      #if defined(PentiumCPS) || defined(WALL)
         fprintf(fpres, "%d 1\n", ntim);
      #else
         fprintf(fpres, "%d 0\n", ntim);
      #endif
      for (i=0; i < ntim; i++)
         fprintf(fpres, "%le\n", times[i]);
      fclose(fpres);
   }
   fprintf(stdout, "NREPS=%d, MAX=%.2f, MIN=%.2f, AVG=%.2f, MED=%.2f\n", 
           ntim, times[0], times[ntim-1], mysum(ntim, times)/ntim,
           times[ntim>>1]);
   free(times);
}

void PrintUsage(char *name, char *arg, int i)
{
   if (i > 0)
      fprintf(stderr, "BAD ARG '%s' on %dth FLAG\n", arg, i);
   fprintf(stderr, "USAGE: %s [flags], where flags are:\n", name);
   fprintf(stderr, "   -v <#> : set verbosity level\n");
   fprintf(stderr, "   -C <#> : set flushsz = # (kbytes)\n");
@ROUT r1ktime r2ktime mvktime
   fprintf(stderr, "   -x <#> : unrolling for X in kernel is #\n");
   fprintf(stderr, "   -y <#> : unrolling for Y in kernel is #\n");
   fprintf(stderr, "   -m <#> : set # of rows of matrix to #\n");
   fprintf(stderr, "   -n <#> : set # of cols of matrix to #\n");
   fprintf(stderr, "   -l <#> : set leading dimension of array A to #\n");
   fprintf(stderr, "   -F <#> : do at least # MFLOPS for each timing interval\n");
   fprintf(stderr, "   -f <file> : output timing summary in <file>; if file exists read & report\n");
   fprintf(stderr, 
           "   -r <#> : do # repetitions of the call for each timing interval\n");
   fprintf(stderr, 
      "   -# <#> : report # timings (each interval may have multiple calls)\n");
   fprintf(stderr, 
"   -F[x,y,a] <#> : if(# > 0) -> force op to be aligned to at least # bytes\n");
   fprintf(stderr, 
"                   if(# < 0) -> force op to be aligned to < # bytes.\n");
   fprintf(stderr, "   -b <beta> : 2 floats for complex, one for real.\n");
   exit(i ? i : -1);
}

void GetFlags(int nargs, char **args, int *verb,
              size_t *flushelts, ATL_INT *celts, ATL_INT *pgelts, 
              ATL_INT *mu, ATL_INT *nu, ATL_INT *ntim, ATL_INT *nrep, 
              enum ATLAS_TRANS *TA, ATL_INT *m, ATL_INT *n, ATL_INT *lda, 
              TYPE *beta,
              int *FAa, int *MAa, int *FAx, int *MAx, int *FAy, int *MAy)
{
   double mfF=ATL_nkflop/1000.0, flops;
   ATL_INT j, h;
   size_t il;
   int i;
   char ch;

   *verb = 1;
   #ifdef ATL_PAGESZ
      *pgelts = ATL_DivBySize(ATL_PAGESZ);
   #else
      *pgelts = 4*ATL_DivBySize(1024);
   #endif
   *celts = 0.75*L1C_ELTS;
   #ifdef L2SIZE
      *flushelts = L2SIZE;
   #else
      *flushelts = 8*1024*ATL_DivBySize(1024);
   #endif
   *mu = *nu = 1;
   *m = 800;
   *n = 200;
   *nrep = *lda = 0;
   *ntim = 3;
   *FAa = *MAa = *FAx = *MAx = *FAy = *MAy = 0;
   *beta = 1.0;
   #ifdef TCPLX
      beta[1] = 0.0;
   #endif

   for (i=1; i < nargs; i++)
   {
      if (args[i][0] != '-')
         PrintUsage(args[0], "No '-' preceeding flag!", i);
      switch(args[i][1])
      {
      case 'f' :  /* set resfile output */
         if (++i >= nargs)
            PrintUsage(args[0], "out of flags in -f ", i-1);
         resfile = args[i];
         break;
      case 'v' :  /* set verbosity */
         if (++i >= nargs)
            PrintUsage(args[0], "out of flags in -v ", i-1);
         *verb = atoi(args[i]);
         break;
      case 'G' :  /* set GEMV blocking cache size in KB */
         if (++i >= nargs)
            PrintUsage(args[0], "out of flags in -G ", i-1);
         j = atoi(args[i]);
         *celts = j*ATL_DivBySize(1024);
         break;
      case 'A' :  /* set transpose */
         if (++i >= nargs)
            PrintUsage(args[0], "out of flags in -A ", i-1);
         ch = args[i][0];
         if (ch == 't' || ch == 'T')
            *TA = AtlasTrans;
         else if (ch == 'c' || ch == 'C')
            *TA = AtlasConjTrans;
         else if (ch == 'z' || ch == 'Z')
            *TA = AtlasConj;
         else
            *TA = AtlasNoTrans;
         break;
      case 'C' :  /* set flushsz in KB */
         if (++i >= nargs)
            PrintUsage(args[0], "out of flags in -C ", i-1);
         il = atol(args[i]);
         if (il >= 0)
            *flushelts = il*ATL_DivBySize(1024);
         break;
      case 'p' :  /* set pagesz in KB */
         if (++i >= nargs)
            PrintUsage(args[0], "out of flags in -p ", i-1);
         j = atoi(args[i]);
         *pgelts = j*ATL_DivBySize(1024);
         break;
      case 'x' :  /* set mu */
         if (++i >= nargs)
            PrintUsage(args[0], "out of flags in -x ", i-1);
         *mu = atoi(args[i]);
         break;
      case 'y' :  /* set nu */
         if (++i >= nargs)
            PrintUsage(args[0], "out of flags in -y ", i-1);
         *nu = atoi(args[i]);
         break;
      case 'm' :  /* set M */
         if (++i >= nargs)
            PrintUsage(args[0], "out of flags in -m ", i-1);
         *m = atoi(args[i]);
         break;
      case 'n' :  /* set N */
         if (++i >= nargs)
            PrintUsage(args[0], "out of flags in -n ", i-1);
         *n = atoi(args[i]);
         break;
      case 'l' :  /* set lda */
         if (++i >= nargs)
            PrintUsage(args[0], "out of flags in -l ", i-1);
         *lda = atoi(args[i]);
         break;
      case 'a' : /* alias for setting alpha in r1ktime */
      case 'b' : /* set beta */
         if (++i >= nargs)
            PrintUsage(args[0], "out of flags in -b ", i-1);
         *beta = atof(args[i]);
         #ifdef TCPLX
            if (++i >= nargs)
               PrintUsage(args[0], "out of flags in -b ", i-1);
            beta[1] = atof(args[i]);
         #endif
         break;
      case 'F' :  /* set nrep by specifying MFLOPS, or force alignment */
         ch = args[i][2];
         if (ch == '\0')   /* specifying MFLOPS */
         {
            if (++i >= nargs)
               PrintUsage(args[0], "out of flags in -F ", i-1);
            j = atoi(args[i]);
            mfF = j;
         }
         else
         {
            if (ch != 'a' && ch != 'y' && ch != 'x')
               PrintUsage(args[0], args[i], i);
            if (++i >= nargs)
               PrintUsage(args[0], args[i-1], i-1);
            j = atoi(args[i]);
            if (j < 0)
            {
               if (ch == 'a')
                  *MAa = -j;
               else if (ch == 'y')
                  *MAy = -j;
               else if (ch == 'x')
                  *MAx = -j;
            }
            else
            {
               if (ch == 'a')
                  *FAa = j;
               else if (ch == 'y')
                  *FAy = j;
               else if (ch == 'x')
                  *FAx = j;
            }
         }
         break;
      case 'r' :  /* set nrep directly as integer */
         if (++i >= nargs)
            PrintUsage(args[0], "out of flags in -r ", i-1);
         *nrep = atoi(args[i]);
         break;
      case '#' :  /* set number of timings to report */
         if (++i >= nargs)
            PrintUsage(args[0], "out of flags in -# ", i-1);
         *ntim = atoi(args[i]);
         break;
      default:
         PrintUsage(args[0], args[i], i);
      }
   }
   if (!(*nrep))
   { 
      flops = Time2Flop(*m, *n, 1.0) * 1000.0;  /* Get kiloFLOPS in GEMV */
      *nrep = (mfF+flops-1)/flops;
      if (*nrep < 1) *nrep = 1;
   }
   if (!(*lda))
      *lda = *m + 8;
}
int main(int nargs, char **args)
{
   size_t flushelts;
   ATL_INT celts, pgelts, mu, nu, ntim, nrep, m, n, lda;
   int FAa, MAa, FAx, MAx, FAy, MAy;    /* Force & Max align for ops */
   int verb;
   enum ATLAS_TRANS TA;
   double *dres;
   #ifdef TREAL
      TYPE beta;
   #else
      TYPE beta[2];
   #endif

   GetFlags(nargs, args, &verb, &flushelts, &celts, &pgelts, &mu, &nu, &ntim, 
            &nrep, &TA, &m, &n, &lda, SADD beta, 
            &FAa, &MAa, &FAx, &MAx, &FAy, &MAy);
   if (resfile)
   {
      dres = ReadResultsFile(1, ntim, resfile);
      if (dres)
      {
         fprintf(stdout, "TIMINGS READ IN FROM '%s':\n", resfile);
         PrintResultsFromFile(stdout, dres);
         free(dres);
         exit(0);
      }
      fpres = fopen(resfile, "w");
      assert(fpres);
   }
@ROUT r1ktime r2ktime
   DoTimes(verb, flushelts, ntim, nrep, mu, nu, m, n, SADD beta, lda, 
           FAa, MAa, FAx, MAx, FAy, MAy);
@ROUT mvktime
   DoTimes(verb, flushelts, ntim, nrep, mu, nu, m, n, SADD beta, SADD beta, lda,
           FAa, MAa, FAx, MAx, FAy, MAy);
@ROUT r1ktime r2ktime mvktime
   exit(0);
}
@ROUT sr1cases.idx dr1cases.idx cr1cases.idx zr1cases.idx @\
      sr2cases.idx dr2cases.idx cr2cases.idx zr2cases.idx 
#
# In this file, any line beginning with a '#' is ignored, but the # must be in
# column 0.  All multiple whitespace is reduced to one space (i.e. used only
# to distinguish where words begin/end).  Lines may be extended by putting '\'
# as the *last* character of line.
#
# The file has the following format:
# ROUT='routine name' AUTH='author names' COMP='compiler name' CFLAGS='flags'
# ID=<id> NU=<nu> MU=<mu> minN=<#> minM=<#> alignX=<#> alignY=<#> alignA=<#>,
# SSE=[0,1,2,3] X87=[0,1] PREF[a,x,y]=[DIST,INSTDIST, INST] LDAMUL=<#>
# ALLALIGNXY=[0,1] GEMMBASED=[0,1] CONJDEF=[0,1] FNU=[0,1]
# ASM=[asmlist], eg., asmlist is "GAS_x8664,GAS_x8632" or "GAS_SPARC"
# ASM defaults to no assembly dialect required.
# If NU/MU is negative, then the routine can only handle multiples of NU/MU.
#
# Assuming M is the length of X, and N is the length of Y, all routines
# are assumed to handle any runtime value of N >= minN, M >= minM.
# They must respect the compile-time macros BETA0, BETA1, & BETAX.
# Some less-obvious keywords:
# LDAMUL    : Kernel will only work if lda is a multiple of # (in bytes)
# PFTUNEx   : Kernel uses pref_x(mem) macro for each op=x (A,y,x).  prefetch
#             inst can be varied wt this macro, as can fetch distance.
#             If set to INSTDIST, tune both distance and instruction type;
#             If set to INST, tune instruction type only
#             If set to DIST, tune distance only
# FNU       : if set, kernel can only handle N where N%NU == 0
@ROUT sr2cases.idx dr2cases.idx
ID=1 MU=1  NU=1 AUTH='R. Clint Whaley', ROUT='ATL_ger2k_1x1_1.c'
@ROUT sr2cases.idx
ID=2 MU=8  NU=4 AUTH='Md. Rakib Hasan' ROUT='ATL_sger2K_NEON_lda4.S' \
     LDAMUL=32 ALIGNX2A=1 \
     COMP='gcc' CFLAGS='-x assembler-with-cpp -mcpu=cortex-a9 -mfpu=neon'
ID=3 MU=8  NU=4 AUTH='Md. Rakib Hasan' ROUT='ATL_sger2K_NEON.S' ALIGNX2A=1 \
     COMP='gcc' CFLAGS='-x assembler-with-cpp -mcpu=cortex-a9 -mfpu=neon'
@ROUT dr2cases.idx
ID=2 MU=2  NU=2 AUTH='R. Clint Whaley', ROUT='ATL_dger2k_2x2_sse3.c' \
     SSE=2 alignY=16 alignX=16 FNU=1 minN=2 COMP='gcc' \
     CFLAGS='-fomit-frame-pointer -mfpmath=sse -msse3 -O2'
ID=2 MU=2  NU=2 AUTH='R. Clint Whaley', ROUT='ATL_dger2k_2x2_sse3.c' \
     SSE=2 alignY=16 alignX=16 FNU=1 minN=2 COMP='gcc' \
     CFLAGS='-fomit-frame-pointer -mfpmath=sse -msse3 -O2 -DATL_USEREAL'
ID=3 MU=2  NU=2 AUTH='R. Clint Whaley', ROUT='ATL_dger2k_2x2_sse3.c' \
     SSE=2 alignA=16 alignY=16 alignX=16 LDAMUL=16 FNU=1 minN=2 COMP='gcc' \
     CFLAGS='-fomit-frame-pointer -mfpmath=sse -msse3 -O2 -DATL_ALIGNED'
ID=4 MU=2  NU=2 AUTH='R. Clint Whaley', ROUT='ATL_dger2k_2x2_sse3.c' \
     SSE=2 alignA=16 alignY=16 alignX=16 LDAMUL=16 FNU=1 minN=2 COMP='gcc' \
     CFLAGS='-fomit-frame-pointer -mfpmath=sse -msse3 -O2 -DATL_ALIGNED -DATL_USEREAL'
@ROUT cr2cases.idx zr2cases.idx
ID=1 MU=1  NU=1 AUTH='R. Clint Whaley', ROUT='ATL_cger2k_1x1_1.c'
@ROUT zr2cases.idx
ID=2 MU=1  NU=2 AUTH='R. Clint Whaley', ROUT='ATL_zger2k_2x1_sse3.c' \
     SSE=3 alignA=16 alignX=16 LDAMUL=16 FNU=1 minM=4 minN=2 \
     COMP='gcc' CFLAGS='-x assembler-with-cpp'
ID=3  MU=2  NU=3 FNU=1 LDAMUL=16 alignY=16 alignX=16 alignA=16 SSE=3 \
      AUTH='R. Clint Whaley' ROUT='ATL_zger2k_rk2_sse3.c' \
      COMP='gcc' CFLAGS='-fomit-frame-pointer -mfpmath=sse -msse3 -O2'
ID=4  MU=2  NU=3 FNU=1 LDAMUL=32 alignY=32 alignX=32 alignA=32 SSE=3 \
      AUTH='R. Clint Whaley' ROUT='ATL_zger2k_rk2_avx.c' COMP='gcc'  \
      CFLAGS='-fomit-frame-pointer -mfpmath=sse -mavx -O2 -fno-schedule-insns2'
@ROUT sr1cases.idx dr1cases.idx
ID=1 MU=16 NU=1  AUTH='R. Clint Whaley' ROUT='ATL_gerk_axpy.c'
ID=2 MU=4  NU=4  AUTH='R. Clint Whaley' ROUT='ATL_gerk_4x4_1.c'
ID=3 MU=1  NU=4  AUTH='R. Clint Whaley' ROUT='ATL_gerk_1x4_0.c'
ID=4 MU=8  NU=4  AUTH='R. Clint Whaley' ROUT='ATL_gerk_8x4_0.c'
@ROUT dr1cases.idx
ID=6 MU=8  NU=4  SSE=3 LDAMUL=16 ALIGNX2A=1 \
     AUTH='R. Clint Whaley' ROUT='ATL_dgerk_4x8_sse.c'
ID=7 ROUT='ATL_gerk_vx4_vsx.c' AUTH='IBM'  MU=2 NU=4
@ROUT sr1cases.idx
ID=6 MU=8  NU=4  SSE=3 LDAMUL=16 ALIGNX2A=1 \
     AUTH='R. Clint Whaley' ROUT='ATL_sgerk_8x4_sse.c'
ID=7 ROUT='ATL_gerk_vx4_vsx.c' AUTH='IBM'  MU=4 NU=4
@ROUT cr1cases.idx zr1cases.idx
ID=1  MU=16 NU=1  AUTH='R. Clint Whaley' ROUT='ATL_cgerk_axpy.c'
@skip ID=2  MU=32 NU=2  AUTH='Camm Maguire'    ROUT='ATL_gerk_SSE.c'
ID=2  MU=2  NU=1  AUTH='R. Clint Whaley' ROUT='ATL_cgerk_2x1p.c'
@ROUT zr1cases.idx
ID=3  MU=1  NU=4  ALIGNX2A=1 AUTH='R. Clint Whaley' ROUT='ATL_zgerk_1x4_sse3.c'
@ROUT cr1cases.idx
ID=3  MU=8  NU=4 minM=9 minN=4 alignA=8 ALIGNX2A=1 alignY=8 SSE=3 LDAMUL=16 \
      PFTUNABLE=1 ASM="GAS_x8664" FNU=1 AUTH='R. Clint Whaley' \
      ROUT='ATL_cgerk_8x4_sse3.c' COMP='gcc' CFLAGS='-x assembler-with-cpp'
@ROUT mvtksearch mvnksearch
@define rt @mv@
@define RT @MV@
@define ru @mv@
@define RU @MV@
@ROUT mvnksearch
@define KP @MVN@
@ROUT mvtksearch
@define KP @MVT@
@ROUT r1ksearch
@define rt @r1@
@define ru @r1@
@define RT @R1@
@define RU @R1@
@define KP @R1@
@ROUT r2ksearch
@define rt @r2@
@define ru @r1@
@define RT @R2@
@define RU @R1@
@define KP @R2@
@ROUT mvtksearch r1ksearch r2ksearch 
   @define nV @N@
   @define mV @M@
@ROUT mvnksearch
   @define nV @N@
   @define mV @M@
@ROUT r1ksearch r2ksearch mvtksearch mvnksearch
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <string.h>
@skip @extract -b @(basd)/atlconf.base rout=asmconf.h
#include "atlas_misc.h"
#include "atlas_@(ru)parse.h"
#include "atlas_@(rt)testtime.h"
#include "atlas_cache.h"
#include "atlas_ssysinfo.h"

/*
 * NREPCT & VERB currently unused.
 * I should also modify FORCETIME so that it will delete any result file if
 * FORCETIME is negative.
 */
static int FLUSHKB=(-1), L2KB=0, NREPCT=3, NREP=3, VERB=0;

void GetDimsByContext
(
   int L1CacheElts,     /* size of L1 cache in elements */
   int imf,             /* index into mflop & see below */
   char pre,            /* type/precision prefix */
   ATL_@(ru)node_t *kp, /* kernels to use */
   int *M,              /* # of rows to use */
   int *N,              /* # of cols to use */
   int *lda,            /* leading dim to use */
   int *percL1,         /* percL1 to block for */
   int *flushKB         /* flushing size to use */
)
{
   if (imf == 0 || imf == 1 || imf == 2)
   {
      *M = (pre == 's') ? 3000 : 2300;
      *N = (pre == 'z') ? 1000 : 2000;
      *flushKB = FLUSHKB;
      *percL1 = imf ? 400 : 85;
      *percL1 = (imf == 2) ? 0 : *percL1;
   }
   else   /* Time in-cache data with no blocking */
   {
      *flushKB = *percL1 = 0;
      if (imf == 3)  /* L2-contained data */
      {
         *N = ((16+kp->@(nV)U-1)/kp->@(nV)U)*kp->@(nV)U;
         *M = 128*1024/pre2size(pre);
         if (*M > 4*L1CacheElts)
            *M = 4*L1CacheElts;
         *M /= *N;
      }
      else if (imf == 4)  /* L1-contained data */
      {
         *N = ((8+kp->@(nV)U-1)/kp->@(nV)U)*kp->@(nV)U;
         *M = (85*L1CacheElts)/(*N*100);
      }
   }
   *N = (*N/kp->@(nV)U)*kp->@(nV)U;
   if (!(*N))
      *N = kp->@(nV)U;
   if (kp->ldamul == 0)
      *lda = ((*M + 9)/7)*7;  /* make lda prime for worst case */
   else
   {
      int i, sz = pre2size(pre);
      i = kp->ldamul / sz;
      assert(kp->ldamul == i*sz);
      *lda = ((*M + 8 + i-1)/i)*i;
   }
}

static double TimeMyKernel
(int verb,              /* 0: no output, 1 min ouput, 2: full output */
 int FTIME,             /* if nonzero, ignore existing timing file */
                        /* if negative, don't retain timing file */
 ATL_@(ru)node_t *r1p,     /* ptr to kernel structure */
 char pre,              /* precision prefix */
 ATL_INT M, ATL_INT N,  /* dimensions to time */
 ATL_INT lda,           /* stride between row elements */
 ATL_INT percL1,        /* if 0, time kernel directly wt no blocking */
                        /* if non-zero, block for that % of L1 cache size */
 int nrep,              /* if >=1, # of trials, else use default (3) */
 int imf,               /* which context you are using (diff than timer!) */
 int cflush             /* if >= 0, size of cache flush area, else ignored */
)
{
   double mf;
   #ifdef WALL
      static int fmflop[5] = {0,0,0,0,0};
   #else
      static int fmflop[5] = 
         {ATL_nkflop/1000.0,ATL_nkflop/1000.0,ATL_nkflop/1000.0,
          ATL_nkflop/10.0,ATL_nkflop};
   #endif

   mf = Time@(RT)Kernel(verb, FTIME, r1p, pre, M, N, lda, percL1, nrep,
                     fmflop[imf], cflush);
   while (mf == 0.0)
   {
      const int ft= (FTIME < 0) ? -1 : 1;
      fmflop[imf] = (fmflop[imf]) ? (fmflop[imf]<<1) : (ATL_nkflop+999)/1000;
      mf = Time@(RT)Kernel(verb, ft, r1p, pre, M, N, lda, percL1, nrep,
                        fmflop[imf], cflush);
   }
   return(mf);
}

ATL_@(ru)node_t *TimeAllKernels
(
   int retclone,                /* 0: return w/o cloning, else clone best */
   int L1CacheElts,             /* size of L1 cache in elements */
   int imf,                     /* index into bp->mflop  */
   char pre,                    /* type/precision prefix */
   int Fflops,                  /* what to set Force flops to (see below) */
   int FTIME,                   /* 0: use prior output files */
   int flushKB,                 /* 0: no flushing, else mem to flush */
   ATL_@(ru)node_t *kq             /* queue of kernels */
)
/* 
 * This routine times all kernels in kq, putting results in kq->mflop[imf]
 * Fflops: for very large problems, set to 0, else the # of flops to force
 * RETURNS: ptr to fastest kernel
 */
{
   ATL_@(ru)node_t *kp, *bestp=NULL, *besttp=NULL;
   int percL1, M, N, lda, i;
   double mf, mfmax=0.0, tmfmax=0.0;
   ATL_@(ru)node_t *TunePF(int L1CacheElts, int imf, char pre, int Fflops, 
                           int flushKB, ATL_@(ru)node_t *kb);

   for (kp=kq; kp; kp = kp->next)
   {
      GetDimsByContext(L1CacheElts, imf, pre, kp, &M, &N, &lda, &percL1, &i);
      mf = ((double)kp->CacheElts) / ((double)L1CacheElts)*100.0;
      percL1 = mf;
      mf = Time@(RT)Kernel(1, FTIME, kp, pre, M, N, lda, percL1, NREP,
                           Fflops, flushKB);
      kp->mflop[imf] = mf;
      if (mf > mfmax)    /* maximum for all kernels */
      {
         bestp = kp;
         mfmax = mf;
      }
      if (FLAG_IS_SET(kp->flag, @up@(ru)F_PFTUNABLE) && mf > tmfmax)
      {
         besttp = kp;
         tmfmax = mf;
      }
   }
   if (retclone && besttp)  /* have a prefetch tunable kernel we should tune */
   {
      kp = Clone@up@(ru)Node(besttp);
      kp = TunePF(L1CacheElts, imf, pre, Fflops, flushKB, kp);
      if (kp->mflop[imf] > mfmax)
         return(kp);
      Kill@(RU)Node(kp);
   }
   if (retclone)
      bestp = Clone@up@(ru)Node(bestp);
   return(bestp);
}

ATL_@(ru)node_t *TimeAllKernelsForContext
(
   int L1CacheElts,     /* size of L1 cache in elements */
   int imf,             /* index into mflop & see below */
   char pre,            /* type/precision prefix */
   int nsamp,           /* # of samples for timing */
   ATL_@(ru)node_t *bp     /* queue of kernels */
)
/* 
 * This routine naively assumes that 4*L1CacheSize is a decent marker for
 * the L2 size to use in initial L2-timings.
 *
 * imf: parameter describing type of timings to perform:
 *    0: large out-of-cache, blocked for 85% of L1CacheSize
 *    1: large out-of-cache, blocked for MIN(128K,4*L1CacheSize) (L2-blocked)
 *    2: large out-of-cache, no blocking
 *    3: in-L2 problem, no blocking
 *    4: in-L1 problem, no blocking
 * RETURNS: best-performing kernel in context
 */
{
   ATL_@(ru)node_t *r1p, *r1max=NULL;
   double mf, mfmax=0.0;
   int M, N, n, lda, percL1, cflush; 

   for (r1p=bp; r1p; r1p = r1p->next)
   {
      GetDimsByContext(L1CacheElts, imf, pre, r1p, &M, &N, &lda, &percL1, 
                       &cflush);
      mf = TimeMyKernel(1, 0, r1p, pre, M, N, lda, percL1, nsamp, 0, cflush);
      if (mf > mfmax)
      {
         mfmax = mf;
         r1max = r1p;
      }
      r1p->mflop[imf] = mf;
   }
   return(r1max);
}

static ATL_@(ru)node_t *DelBadTestKernels(char pre, ATL_@(ru)node_t *bp)
/*
 * Deletes all kernels that can't pass basic usage test
 */
{
   int die;
   ATL_@(ru)node_t *p, *prev;
   int m, n, lda, i, j;
   fprintf(stdout, "\nBEGIN BASIC KERNEL TESTS:\n");

   prev = p = bp;
   while(p)
   {
      m = n = lda = 1000;
      if (FLAG_IS_SET(p->flag, @(RU)F_FNU))
      {
         i = p->@(nV)U;
         n = ((n+i-1)/i)*i;
      }
      if (p->ldamul)
      {
         j = pre2size(pre);
         i = p->ldamul / j;
         assert(p->ldamul == i*j);
         lda = ((lda+i-1)/i)*i;
      }
      if (@(RT)KernelFailsTest(0, pre, m, n, lda, p))
      {
         fprintf(stdout, "   NUKING bad kernel %s(%d), MU=%d, NU=%d\n", 
                 p->rout, p->ID, p->MU, p->NU);
         if (p->genstr)
            fprintf(stdout, "      genstr='%s'\n", p->genstr);
         if (p == bp)
            bp = p = Kill@(RU)Node(p);
         else
            prev->next = p = Kill@(RU)Node(p);
      }
      else
      {
         fprintf(stdout, "   Kernel %s(%d) passes basic test\n", 
                 p->rout, p->ID);
         prev = p;
         p = p->next;
      }
   }
   fprintf(stdout, "DONE BASIC KERNEL TESTS:\n\n");
   return(bp);
}

ATL_@(ru)node_t *ChooseKernelBlocking
(ATL_@(ru)node_t *L1,      /* L1 blocked kernel, scope imf=0 */
 ATL_@(ru)node_t *L2,      /* L2 blocked kernel, scope imf=1 */
 ATL_@(ru)node_t *NOB      /* no-blocking kernel, scope imf=2 */
)
/*
 * This routine compares 3 different blocking strategy using 1-3 kernels
 * (i.e., they may all be the same kernel).
 * It is possible that the data we use may stay in a very large L3 cache,
 * so only accept no-blocking if it is significantly faster than doing
 * blocking.  L1-blocking will tend to minimize the number of kernels required,
 * so stress it very slightly more than L2 blocking.
 * RETURNS: cloned node of best blocking/kernel
 */
{
   ATL_@(ru)node_t *best;
   double mf1, mf2, mf3;

   mf1 = L1->mflop[0] * 1.05;  /* give small adv to safest option, L1 blk */
   mf2 = L2->mflop[1] * 1.03;  /* give small adv to blocking over not */
   mf3 = NOB->mflop[2];        /* no blocking loss may vary by size, penalize */
   if (mf1 > mf2 && mf1 > mf3)
      best = L1;
   else if (mf2 > mf1 && mf2 > mf3)
      best = L2;
   else
      best = NOB;
   return(best);
}

double ExhCESrch
/*
 * RETURNS: best mflop found 
 */
(
   ATL_@(ru)node_t *r1p,           /* kernel to search with */
   char pre,                    /* type/precision prefix */
   int M, int N, int lda,
   int stride,                  /* stride to search with, real pL = pL*stride */
   int pLL,                     /* lower percL1 (mul by stride for real val) */
   int pLH,                     /* higher percL1 */
   double mfL,                  /* mflops achieved by lower */
   double mfH,                  /* mflops achieved by higher */
   int *pLB                     /* the best percL1 found */
)
{
   int plm, plb;
   double mf;

   plm = (pLH-pLL)>>1;
   if (plm < 1)
   {
      if (mfL < mfH)
      {
         *pLB = pLH;
         return(mfH);
      }
      *pLB = pLL;
      return(mfL);
   }
   plm += pLL;
   mf = TimeMyKernel(0, 0, r1p, pre, M, N, lda, plm*stride, NREP, 0, FLUSHKB);
   fprintf(stdout, "%6d  %6d  %6d  %6d  %9.2f\n", M, N, lda, plm*stride, mf);
   mfL = ExhCESrch(r1p, pre, M, N, lda, stride, pLL, plm, mfL, mf, pLB);
   mfH = ExhCESrch(r1p, pre, M, N, lda, stride, plm, pLH, mf, mfH, &plb);
   if (mfH > mfL)
   {
      mfL = mfH;
      *pLB = plb;
   }
   return(mfL);
}

void ExhaustiveCESrch
/*
 * Performs an exhaustive search on entire range using recursive halving
 * And modifies CE to be best % of L1 size found.
 */
(
   ATL_@(ru)node_t *r1p,           /* kernel to search with */
   int imf,                     /* set r1p->mflop[imf] to best perf */
   char pre,                    /* type/precision prefix */
   int M, int N, int lda,       /* prob size to tune with */
   int stride,                  /* stride to search with, real pL = pL*stride */
   int pLL,                     /* lower percL1 (mul by stride for real val) */
   int pLH                      /* higher percL1 */
)
{
   double mfH, mfL;
   int percL1;
   fprintf(stdout, "\nCACHE TUNING FOR %d:'%s', MU=%d NU=%d\n", 
           r1p->ID, r1p->rout, r1p->MU, r1p->NU);
   fprintf(stdout, "------------------------------------------\n");
   fprintf(stdout, "     M       N     lda  percL1       mflop\n");
   fprintf(stdout, "======  ======  ======  ======  ==========\n");
   
   mfL = TimeMyKernel(0, 0, r1p, pre, M, N, lda, pLL*stride, NREP, 0, FLUSHKB);
   fprintf(stdout, "%6d  %6d  %6d  %6d  %9.2f\n", M, N, lda, pLL*stride, mfL);
   mfH = TimeMyKernel(0, 0, r1p, pre, M, N, lda, pLH*stride, NREP, 0, FLUSHKB);
   fprintf(stdout, "%6d  %6d  %6d  %6d  %9.2f\n", M, N, lda, pLH*stride, mfH);
   mfL = ExhCESrch(r1p, pre, M, N, lda, stride, pLL, pLH, mfL, mfH, &percL1);
   fprintf(stdout, "\nBEST CASE %d percent of L1, MFLOP=%.2f\n\n", 
           percL1*stride, mfL);
   r1p->mflop[imf] = mfL;
   r1p->CacheElts = percL1*stride;
}

static int GetMaxID(ATL_@(ru)node_t *r1b)
{
   ATL_@(ru)node_t *r1p;
   int maxID=0;

   for (r1p=r1b; r1p; r1p = r1p->next)
      maxID = Mmax(maxID, r1p->ID);

   return(maxID);
}
#ifdef ATL_SSE3
void FillInGenNode
(
   ATL_@(ru)node_t *r1p,   /* data structure to fill in */
   int nmu,             /* unrolling on mu unrolled inner (X) loop */
   int mu,              /* register blk to apply to X */
                        /* total X unrolling is nmu*mu! */
   int nu,              /* unroll&jam on outer (Y) loop */
   int evenlda,         /* assume X&Y have same (mis)align, lda is even */
   int allalign16,      /* assume X,Y,A all aligned to 16 bytes */
   int aptrs            /* use ptrs rather than lda for column indexing */
)
{
   char ln[2048];
}
ATL_@(ru)node_t *SrchSSEGen
(
   char pre,    /* precision prefix indicating type */
   int maxID,   /* IDs > maxID are safe to use in generation */
   ATL_CINT M,  /* will use (M/MU)*MU as size of prob to time */
   ATL_CINT N,  /* will use (N/NU)*NU as size of prob to time */
   ATL_CINT lda /* leading dimension of array */
)
/*
 * Finds the best kernel the code generator can produce for given problem
 * size w/o blocking.
 * RETURNS: best kernels to be added to the multiple implementation srch
 */
{
   ATL_INT i, j;
/*
 * First, let's find decent NU=1 case to use
 */
   return(NULL);
}
#endif

ATL_@(ru)node_t *SortRestricted
/*
 * Sorts queue of kernels into a queue of unrestricted kernels (can be
 * always be used) and restricted (only used under certain conditions,
 * such as lda*size a multiple 16).  Destroys R1B in process.
 */
(
   ATL_@(ru)node_t *R1B,   /* original queue containing restricted & unrest */
   ATL_@(ru)node_t **R1R   /* queue of only restricted kernels */
)
{
   ATL_@(ru)node_t *r1B=NULL, *r1R=NULL, *r1b=NULL, *r1r=NULL, *r1p;

   for (r1p=R1B; r1p; r1p = r1p->next)
   {
      if (r1p->ldamul > @(RU)flag2size(r1p->flag) ||
          r1p->alignA > @(RU)flag2size(r1p->flag) ||
          r1p->minN >= 4 || r1p->minM >= 16
         )
      {
         if (r1R)
            r1r->next = r1p;
         else
            r1R = r1p;
         r1r = r1p;
      }
      else
      {
         if (r1B)
            r1b->next = r1p;
         else
            r1B = r1p;
         r1b = r1p;
      }
   }
   if (r1R)
      r1r->next = NULL;
   assert(r1B);
   r1b->next = NULL;
   *R1R = r1R;
   return(r1B);
}

ATL_@(ru)node_t *EliminateRepeatedRestrictions
(
   int imf,             /* entry in mflop array to read for performance */
   ATL_@(ru)node_t *R1R    /* queue of already-timed restricted kernels */
)
/*
 * This routine sorts R1R by performance, and then eliminates all slower
 * kernels that handle the same restricted cases.
 *
 * IMPORTANT: what constitutes valid restrictions will change with 
 * architectures, so we need to keep this file up-to-date.  
 *
 * Things that seem like restrictions but we don't care about:
 *    alignX & Y : handled by copy in ATL_ger
 *    R1F_ALIGNX2A: handled by copy in ATL-ger
 *    R1F_ALLALIGNXY : not presently supported, but would be handled by ATL_ger
 *    R1F_FNU : handled by main loop in ATL_ger
 *
 * Valid restrictions as of 02/14/10 are:
 *    alignA: asserts A must be aligned to alignA%ATL_cachelen boundary
 *            alignA in bytes
 *    ldamul: asserts lda*size must a multiple of ldamul (which is in bytes)
 *    minN: only restriction if >= 4 (else handled by ATL_ger)
 *    minM: only restriction if >= 16 (else handled by ATL_ger)
 */
{
   ATL_@(ru)node_t *p, *p2, *prev, *curr, *del;

   if (!R1R)
      return(NULL);
   if (!R1R->next)
      return(R1R);
   R1R = ATL_Sort@(RU)NodesByMflop(imf, R1R);  /* sort from fastest to slowest */
   for (p=R1R; p && p->next; p = p->next)
   {
      prev = p;
      p2 = p->next;
      while (p2)
      {
         int SAMEA, SAMEL;
         del = NULL;
@skip         if (p2->alignA == p->alignA && p2->ldamul == p->ldamul)
         SAMEA = (p2->alignA == p->alignA);
         if (!SAMEA && p->alignA && p2->alignA)
            SAMEA = (p2->alignA%p->alignA) == 0;
         SAMEL = p->ldamul == p2->ldamul;
         if (!SAMEL && p->ldamul && p2->ldamul)
            SAMEL = (p2->ldamul%p->ldamul) == 0;
         if (SAMEA && SAMEL)
         {
            if (p->minN < 4 && p->minM < 16)  /* quit if that's all */
               del = p2;
            if (p2->minN >= p->minN && p2->minM >= p->minM)
               del = p2;
            if (p->minN != 0 && p2->minN%p->minN == 0)
               if (p->minM != 0 && p2->minM%p->minM == 0)
                  del = p2;
         }
         if (del)
            p2 = prev->next = Kill@(RU)Node(del);
         else
         {
            prev = p2;
            p2 = p2->next;
         }
      }
   }
   return(R1R);
}

ATL_@(ru)node_t *DecimateAndRankRestricted
(
   int imf,             /* entry in mflop array to read for performance */
   ATL_@(ru)node_t *urp,   /* unrestricted kernel to be used */
   ATL_@(ru)node_t *R1R    /* queue of already-timed restricted kernels */
)
/*
 * Takes a timed queue of restricted kernels (with relevant results in
 * (rp->mflop[imf]), and does the following ranking:
 * (1) Any kernel not noticably outperforming urp is removed,
 * (2) Any kernels with the same restrictions are compared, and only
 *     the fastest one is retained
 * (3) Surviving queue are ranked in performance between 1 and NR,
 *     with 1 being the slowest, and NR being the fastest.  This rank
 *     is stored in rp->rankR.  When code is generated, will select kernel 
 *     to use by asking if restrictions are satisfied in high-to-low order.
 * (4) RETURNS: queue of surviving kernels, sorted from fastest to slowest
 */
{
   ATL_@(ru)node_t *rp, *prev;
/*
 * Give 4% advantage to unrestricted; not worth extra instruction load if
 * we can't get the improvement above 4% (often less than clock resolution)
 */
   const double mfur = urp->mflop[imf] * 1.04; 
   int i;                    

/*
 * Get rid of any kernel not noticably faster than unrestricted kernel
 */
   while (R1R && R1R->mflop[imf] < mfur)
      R1R = Kill@(RU)Node(R1R);
   if (!R1R)
      return(NULL);
   for (prev=R1R,rp=R1R->next; rp; rp = rp->next)
   {
      if (rp->mflop[imf] < mfur)
      {
         prev->next = Kill@(RU)Node(rp);
         rp = prev;
      }
      else
         prev = rp;
   }
   R1R = EliminateRepeatedRestrictions(imf, R1R);
   for (i=ATL_CountNumberOf@(RU)Nodes(R1R), rp=R1R; i > 0; rp = rp->next, i--)
      rp->rankR = i;
   return(R1R);
}

void PrintUsage(char *name, int ierr, char *flag)
{
   if (ierr > 0)
      fprintf(stderr, "Bad argument #%d: '%s'\n",
              ierr, flag ? flag : "Not enough arguments");
   else if (ierr < 0)
      fprintf(stderr, "ERROR: %s\n", flag);
   fprintf(stderr,"USAGE: %s [flags]:\n", name);
   fprintf(stderr, "   -p [s,d,c,z]: set precision prefix \n");
   fprintf(stderr,
           "   -e <fname> : external search filename (& make target)\n");
   fprintf(stderr,
           "   -o <fname> : output filename [<pre>@(KP)K.sum]\n");
   fprintf(stderr,
           "   -i <fnam> : kernel index file [@(KP)CASES/<pre>cases.idx]\n");
   fprintf(stderr,
           "   -C <kbytes> : default cache flush size to use\n");
   fprintf(stderr, "   -# <reps> : number of repetitions for each timing\n");
   fprintf(stderr, 
      "   -#c <reps> : number of repetitions for each cache block timing\n");
   fprintf(stderr, "   -T <#> : Bitfield controlling detailed timings:\n");
   fprintf(stderr, "      0: if bitfield 0, do normal pruning search\n");
   fprintf(stderr, "      1: perform tests before timing kernels\n");
   fprintf(stderr, "      2: Time unblocked out-of-cache (OOC) performance\n");
   fprintf(stderr, "      4: Time L2-blocked OOC performance\n");
   fprintf(stderr, "      8: Time L1-blocked OOC performance\n");
   fprintf(stderr, "     16: Do Exhaustive search on OOC blocking factors\n");
   fprintf(stderr, "     32: Time in-L2 performance\n");
   fprintf(stderr, "     64: Time in-L1 performance\n");
   fprintf(stderr, "   -v <#> : verbosity level [0]\n");
   fprintf(stderr, "   -2 <kbytes> : size of L2 cache to assume\n");
   exit(ierr ? ierr : -1);
}

ATL_@(ru)node_t *GetFlags(int nargs, char **args, char *pre, int *ESRCH,
                       char **fin, char **fout)
{
   ATL_@(ru)node_t *eb=NULL, *ep, *en;
   int i;
   char ch;
   char ln[512];

   NREPCT = NREP = 3;
   FLUSHKB = 8192;
   VERB = 1;
   *ESRCH = 0;
   *fin = NULL;
   *fout = NULL;
   *pre = 'd';

   for (i=1; i < nargs; i++)
   {
      if (args[i][0] != '-')
         PrintUsage(args[0], i, args[i]);
      switch(args[i][1])
      {
      case 'o': /* -o <fname> : output filename [<pre>@(RT)K.sum] */
         if (++i >= nargs)
            PrintUsage(args[0], i, NULL);
         *fout = args[i];
         break;
      case 'i': /* -i <fnam> : kernel index file [@(RT)CASES/<pre>cases.idx] */
         if (++i >= nargs)
            PrintUsage(args[0], i, NULL);
         *fin = args[i];
         break;
      case 'v': /* -v <verbosity level> */
         if (++i >= nargs)
            PrintUsage(args[0], i, NULL);
         VERB = atoi(args[i]);
         break;
      case 'C': /* -C <kbytes> : default cache flush size to use */
         if (++i >= nargs)
            PrintUsage(args[0], i, NULL);
         FLUSHKB = atoi(args[i]);
         break;
      case '2': /* -C <kbytes> : L2 cache size to assume */
         if (++i >= nargs)
            PrintUsage(args[0], i, NULL);
         L2KB = atoi(args[i]);
         break;
      case 'T': /* -T # : do/don't do exhaustive timing */
         if (++i >= nargs)
            PrintUsage(args[0], i, NULL);
         *ESRCH = atoi(args[i]);
         break;
      case '#': /* -# <reps>/ -#c : number of repetitions for timing */
         if (++i >= nargs)
            PrintUsage(args[0], i, NULL);
         if (args[i-1][2] == 'c')
            NREPCT = atoi(args[i]);
         else
            NREP = atoi(args[i]);
         break;
      case 'e':  /* external file we should read in */
         if (++i >= nargs)
            PrintUsage(args[0], i, NULL);
         sprintf(ln, "make %s", args[i]);
         if (system(ln) != 0)
            fprintf(stderr, "\nEXTERNAL SEARCH MAKE '%s' FAILED!\n\n", ln);
         else
         {
            en = Read@(RU)File(ln+5);
            if (en)              /* We got new results */
            {
               if (!eb)         /* if this first, becomes base pointer */
                  eb = en;
               else             /* else, add it to queue after earlier */
               {
                  for (ep=eb; ep->next; ep = ep->next);
                  ep->next = en;
               }
            }
            else
               fprintf(stderr, "\nEMPTY EXTERNAL SEARCH '%s'!!\n\n", ln);
         }
         break;
      case 'p':  /* -p <pre> */
         if (++i >= nargs)
            PrintUsage(args[0], i, NULL);

         ch = tolower(args[i][0]);
         assert(ch == 's' || ch == 'd' || ch == 'c' || ch == 'z');
         *pre = ch;
         break;
      default:
         PrintUsage(args[0], i, args[i]);
      }
   }
/*
 * Get filenames in freeable string
 */
   if (!(*fout))
   {
      if (*ESRCH)
         sprintf(ln, "res/%c@(KP)Ktimes.sum", *pre);
      else
         sprintf(ln, "res/%c@(KP)K.sum", *pre);
      *fout = DupString(ln);
   }
   else
      *fout = DupString(*fout);
   if (!(*fin))
   {
      if (*ESRCH)
         sprintf(ln, "@(KP)CASES/%c@(rt)time.idx", *pre);
      else
         sprintf(ln, "@(KP)CASES/%c@low@(KP)cases.idx", *pre);
      *fin = DupString(ln);
   }
   else
      *fin = DupString(*fin);
/*
 * Don't trust external search's own timings & settings: we will test ourselves
 */
   for (ep=eb; ep; ep = ep->next)
   {
      for (i=0; i < 8; i++)
         ep->mflop[0] = 0.0;
      if (ep->kname)
         free(ep->kname);
      ep->kname = NULL;
      ep->rankR = 0;
   }
   return(eb);
}

void WriteMflopExp(FILE *fpout)
{
   fprintf(fpout, "#\n#MFLOP array has following meaning by index:\n");
   fprintf(fpout, "#   0 : Out-of-cache, L1 blocked\n");
   fprintf(fpout, "#   1 : Out-of-cache, L2 blocked\n");
   fprintf(fpout, "#   2 : Out-of-cache, no blocking\n");
   fprintf(fpout, "#   3 : Problem preloaded to L2, no blocking\n");
   fprintf(fpout, "#   4 : Problem preloaded to L1, no blocking\n#\n");
}

void Write@(RU)SummFile(char *fnam, ATL_@(ru)node_t *r1b)
{
   char ln[256];
   FILE *fpout;
   ATL_@(ru)node_t *bases[4], *r1p;
   char *exp[4] = {"out-of-cache operands", 
                   "operands preloaded to the L2 cache",
                   "operands preloaded to the L1 cache",
                   "operands out-of-cache, but blocked"
                  };
   int i;

   ATL_@(RU)SplitContexts(r1b, bases, bases+1, bases+2, bases+3);
   fpout = fopen(fnam, "w");
   assert(fpout);
   WriteMflopExp(fpout);
   fprintf(fpout, "#\n#Each kernel context has multiple kernels:\n");
   fprintf(fpout, 
           "#   All kernels with rankR > 0 have restrictions, and are only\n");
   fprintf(fpout,
           "#   used when certain conditions are met.  The last kernel in\n");
   fprintf(fpout, 
"#   the context series has rankR=0, and can be called for any valid input\n");
   fprintf(fpout, "#\n");
   for (i=0; i < 4; i++)
   {
      fprintf(fpout, 
"# ------------------------------------------------------------------------\n");

      fprintf(fpout, 
         "# Following %d GE@(RT) kernels are optimized for %s\n", 
              bases[i]->rankR+1, exp[i]);
      if (i == 3)
         fprintf(fpout, 
              "# for L1 reuse.  These are used in low-rank update\n");
      fprintf(fpout, 
"# ------------------------------------------------------------------------\n");
      for (r1p = bases[i]; r1p; r1p = r1p->next)
         Print@up@(ru)Line(fpout, r1p);
   }
   fclose(fpout);
/*
 * Restore queue in case it used by caller
 */
   r1b = ATL_@up@(ru)LinkContexts(bases[0],bases[1],bases[2],bases[3]);
}

void NameAllKernels(char pre, ATL_@(ru)node_t *r1b)
/*
 * Gives all kernels unique names.  For now, just name them gerk_<ID>
 */
{
   ATL_@(ru)node_t *p;
   char ln[64];

   for (p=r1b; p; p = p->next)
   {
@ROUT mvnksearch `      sprintf(ln, "ATL_%cmvnk__%d", pre, p->ID);`
@ROUT mvtksearch `      sprintf(ln, "ATL_%cmvtk__%d", pre, p->ID);`
@ROUT r2ksearch `      sprintf(ln, "ATL_%cger2k__%d", pre, p->ID);`
@ROUT r1ksearch `      sprintf(ln, "ATL_%cgerk__%d", pre, p->ID);`
      p->kname = DupString(ln);
   }
}

@extract -b @(basd)/atlas.base rout=Mylcm

ATL_@(ru)node_t *FindSmallestNU(ATL_@(ru)node_t *r1b)
/*
 * RETURNS: ptr to node wt smallest NU setting
 */
{
   ATL_@(ru)node_t *r1min, *r1p;
   int numin;

   if (!r1b)
      return(NULL);
   numin = r1b->NU;
   r1min = r1b;
   for (r1p=r1b; r1p; r1p = r1p->next)
   {
      if (r1p->NU < numin)
      {
         numin = r1p->NU;
         r1min = r1p;
      }
   }
   return(r1min);
}

ATL_@(ru)node_t *SortQByNU(ATL_@(ru)node_t *r1b)
/*
 * Sorts queue on NU (greatest-to-least)
 * RETURNS: pointer to new Q sorted from greatest to least on NU (NU)
 */
{
   ATL_@(ru)node_t *r1s=NULL, *r1p, *r1m;
   while (r1b)
   {
      r1m = FindSmallestNU(r1b);
      if (r1m == r1b)
         r1b = r1b->next;
      else
      {
         for (r1p=r1b; r1p->next != r1m; r1p = r1p->next);
         r1p->next = r1p->next->next;
      }
      r1m->next = r1s;
      r1s = r1m;
   }
   return(r1s);
}

@ROUT r1ksearch r2ksearch mvtksearch mvnksearch
ATL_@(ru)node_t *FindPrefInst
(
   int L1CacheElts,             /* size of L1 cache in elements */
   int imf,                     /* index into bp->mflop  */
   char pre,                    /* type/precision prefix */
   int  M, int N, int lda,      /* problem dimensions */
   int Fflops,                  /* what to set Force flops to (see below) */
   int flushKB,                 /* 0: no flushing, else mem to flush */
   ATL_@(ru)node_t *k0,         /* kernel to tune prefetch on */
   char arrc,                   /* A, X, or Y */
   int ninst,                   /* # of pref inst to try */
   char **pfinst                /* array of prefetch suffixes */
)
{
   ATL_@(ru)node_t *kb, *kp, *kB;
   double mf;
   int i, j, percL1;

   printf("\n   OP  PREF    MU    NU         MFLOP\n");
   printf(  "   ==  ====  ====  ====  ============\n");
   printf( "    %c   DEF %5d %5d  %12.2f\n", arrc, k0->@(mV)U, k0->@(nV)U, k0->mflop[imf]);
   kB = k0;
   kb = NULL;
/*
 * Retime default case before we believe its results (in case prior timing
 * was on different prob size or CacheElts or something)
 */
   mf = ((double)k0->CacheElts) / ((double)L1CacheElts)*100.0;
   percL1 = mf;
   mf = TimeMyKernel(0, 1, k0, pre, M, N, lda, percL1, Mmax(NREP,8), 
                     imf, flushKB);
   k0->mflop[imf] = mf;
   for (i=0; i < ninst; i++)
   {
      #ifndef ATL_3DNow
         if (pfinst[i][0] == 'w' && pfinst[i][1] == '\0')
            continue;
      #endif
      kp = Clone@up@(ru)Node(k0);
      if (kp->cflags)
      {
         j = strlen(kp->cflags) + 20;
         kp->cflags = GetLongerString(kp->cflags, j);
         sprintf(kp->cflags+j-20, " -DPFI%c=prefetch%s", arrc, pfinst[i]);
      }
      else
      {
         char ln[32];
         sprintf(ln, "-DPFI%c=prefetch%s", arrc, pfinst[i]);
         kp->cflags = DupString(ln);
         SET_FLAG(kp->flag, @up@(ru)F_ADDCFLAGS, 1);
      }
      mf = ((double)kp->CacheElts) / ((double)L1CacheElts)*100.0;
      percL1 = mf;
      mf = TimeMyKernel(0, -1, kp, pre, M, N, lda, percL1, Mmax(NREP,8), 
                        imf, flushKB);
      kp->mflop[imf] = mf;
      printf("    %c   %3.3s %5d %5d  %12.2f\n", arrc, pfinst[i], kp->@(mV)U, kp->@(nV)U, mf);
      if (mf > kB->mflop[imf])
         kB = kp;
      kp->next = kb;
      kb = kp;
   }
   kp = Clone@up@(ru)Node(kB);
   KillAll@(RU)Nodes(kb);
   return(kp);
}

ATL_@(ru)node_t *TunePFINST
(
   int L1CacheElts,             /* size of L1 cache in elements */
   int imf,                     /* index into bp->mflop  */
   char pre,                    /* type/precision prefix */
   int Fflops,                  /* what to set Force flops to (see below) */
   int flushKB,                 /* 0: no flushing, else mem to flush */
   ATL_@(ru)node_t *kb          /* kernel to tune prefetch on */
)
/*
 * If kb is a kernel that you can tune the prefetch instruction type
 * using ATLAS's PFI[A,X,Y] macros, try all combinations to find the best
 * RETURNS: node ptr to best performing variant. 
 * NOTE: kb is destroyed.
 */
{
   double mf;
   int M, N, lda, i, j;      /* problem dimensions */
#ifdef ATL_3DNow
@ROUT mvtksearch mvnksearch
   const int nA=5, nY=6;
   char *pfsA[5] = {"", "nta", "t0", "t1", "t2"};
   char *pfsY[6] = {"w", "", "nta", "t0", "t1", "t2"};
@ROUT r1ksearch r2ksearch 
   const int nA=6, nY=5;
   char *pfsY[5] = {"", "nta", "t0", "t1", "t2"};
   char *pfsA[6] = {"w", "", "nta", "t0", "t1", "t2"};
@ROUT r1ksearch r2ksearch mvtksearch mvnksearch
#else
   const int nA=4; 
   char *pfsA[4] = {"nta", "t0", "t1", "t2"};
   #define nY nA
   #define pfsY pfsA
#endif
@ROUT r1ksearch r2ksearch
   #define nX nY
   #define pfsX pfsY
@ROUT mvtksearch mvnksearch
   #define nX nA
   #define pfsX pfsA
@ROUT r1ksearch r2ksearch mvtksearch mvnksearch
   if (!FLAG_IS_SET(kb->flag, @up@(ru)F_PFTUNABLE))
      return(kb);
/*
 * First, find best case for prefetch of A, then for X, then for Y
 */
   mf = kb->mflop[imf];
   GetDimsByContext(L1CacheElts, imf, pre, kb, &M, &N, &lda, &i, &j);
   printf("\nTUNING PREFETCH INST, imf=%d, BASELINE MFLOP=%.2f\n", imf, mf);
   kb = FindPrefInst(L1CacheElts, imf, pre, M, N, lda, Fflops, flushKB, 
                     kb, 'A', nA, pfsA);
   kb = FindPrefInst(L1CacheElts, imf, pre, M, N, lda, Fflops, flushKB, 
                     kb, 'X', nX, pfsX);
   kb = FindPrefInst(L1CacheElts, imf, pre, M, N, lda, Fflops, flushKB, 
                     kb, 'Y', nY, pfsY);
   printf("\nBEST MFLOP[%d]=%.2f (%.2f percent improvement)\n",
          imf, kb->mflop[imf], 100*(kb->mflop[imf]/mf - 1.0));
   printf("   cflags='%s'\n", kb->cflags);
   return(kb);
}

ATL_@(ru)node_t *FindPrefDist
(
   int L1CacheElts,             /* size of L1 cache in elements */
   int imf,                     /* index into bp->mflop  */
   char pre,                    /* type/precision prefix */
   int  M, int N, int lda,      /* problem dimensions */
   int percL1,                  /* % of L1 to block for */
   int Fflops,                  /* what to set Force flops to (see below) */
   int flushKB,                 /* 0: no flushing, else mem to flush */
   ATL_@(ru)node_t *kb,         /* kernel to tune prefetch on */
   char arrc                    /* A, X, or Y */
)
{
   double mf, mfB;
   int maxd = 256, slen, lo, hi, dB, i;
   ATL_@(ru)node_t *kp;
   const int DEFFLAGS = (kb->cflags == NULL);

   if (DEFFLAGS)
      kb->cflags = GetKCFlags(pre);
   printf("\nTUNING PREFETCH DISTANCE FOR OPERAND '%c', imf=%d:\n", arrc, imf);
   if (pre == 'd' || pre == 'c')
      maxd *= 8;
   else if (pre == 's')
      maxd *= 4;
   else
      maxd *= 16;
/*
 * Retime default case to ensure perf is all up-to-date
 */
   mf = TimeMyKernel(0, 1, kb, pre, M, N, lda, percL1, Mmax(NREP,8), 
                     imf, flushKB);
   kb->mflop[imf] = mf;
   printf("   OP  DIST    MU    NU         MFLOP\n");
   printf("   ==  ====  ====  ====  ============\n");
   printf("    %c   DEF %5d %5d  %12.2f\n", arrc, kb->@(mV)U, kb->@(nV)U, kb->mflop[imf]);
/*
 * First, starting with 64 bytes, double distance (hi starts at 256) until
 * performance drops
 * or we reach 256 elements (max distance ahead).
 */
   slen = strlen(kb->cflags);
   kp = Clone@up@(ru)Node(kb);
   mfB = 0.0;
   i = 64;
   while (i < maxd)
   {
      if (kp->cflags)
         free(kp->cflags);
      kp->cflags = DupString(kb->cflags);
      kp->cflags = GetLongerString(kp->cflags, slen + 16);
      sprintf(kp->cflags+slen, " -DPF%cDIST=%d", arrc, i);
      mf = TimeMyKernel(0, -1, kp, pre, M, N, lda, percL1, Mmax(NREP,8), 
                        imf, flushKB);
      printf("    %c %5d %5d %5d  %12.2f\n", arrc, i, kb->@(mV)U, kb->@(nV)U, mf);
      if (mf <= mfB)
         break;
      mfB = mf;
      i = (i == 64) ? 256 : (i<<1);
   }
/*
 * Now refine distance in steps of 64 
 */
   dB = (i>>1);
   hi = i;
   for (i=dB+64; i < hi; i += 64)
   {
      if (kp->cflags)
         free(kp->cflags);
      kp->cflags = DupString(kb->cflags);
      kp->cflags = GetLongerString(kp->cflags, slen + 16);
      sprintf(kp->cflags+slen, " -DPF%cDIST=%d", arrc, i);
      mf = TimeMyKernel(0, -1, kp, pre, M, N, lda, percL1, Mmax(NREP,8), 
                        imf, flushKB);
      printf("    %c %5d %5d %5d  %12.2f\n", arrc, i, kb->@(mV)U, kb->@(nV)U, mf);
      if (mf > mfB)
      {
         mfB = mf;
         dB = i;
      }
   }
/*
 * Try no prefetch at all (signaled by setting DIST=0)
 */
   if (kp->cflags)
      free(kp->cflags);
   kp->cflags = DupString(kb->cflags);
   kp->cflags = GetLongerString(kp->cflags, slen + 16);
   sprintf(kp->cflags+slen, " -DPF%cDIST=0", arrc);
   mf = TimeMyKernel(0, -1, kp, pre, M, N, lda, percL1, Mmax(NREP,8), 
                     imf, flushKB);
   printf("    %c %5d %5d %5d  %12.2f\n", arrc, 0, kb->@(mV)U, kb->@(nV)U, mf);
   if (mf > mfB)
   {
      mfB = mf;
      dB = 0;
   }
   Kill@up@(ru)Node(kp);
   if (mfB > kb->mflop[imf])
   {
      kb->cflags = GetLongerString(kb->cflags, slen + 16);
      sprintf(kb->cflags+slen, " -DPF%cDIST=%d", arrc, dB);
      printf("BEST imf=%d PF%cDIST=%d (%.2f)\n", imf, arrc, dB, mfB);
      return(kb);
   }
   printf("DEFAULT imf=%d %cDISTANCE IS BEST (%.2f)\n", 
          imf, arrc, kb->mflop[imf]);
   if (DEFFLAGS)
   {
      free(kb->cflags);
      kb->cflags = NULL;
   }
   return(kb);
}

ATL_@(ru)node_t *TunePFDIST
(
   int L1CacheElts,             /* size of L1 cache in elements */
   int imf,                     /* index into bp->mflop  */
   char pre,                    /* type/precision prefix */
   int Fflops,                  /* what to set Force flops to (see below) */
   int flushKB,                 /* 0: no flushing, else mem to flush */
   ATL_@(ru)node_t *kb          /* kernel to tune prefetch on */
)
{
   int i, j, M, N, lda, percL1;
   double mf;
   if (!FLAG_IS_SET(kb->flag, @up@(ru)F_PFTUNABLE))
      return(kb);
/*
 * Find best prefetch distance for all operands
 */
   mf = ((double)kb->CacheElts) / ((double)L1CacheElts)*100.0;
   percL1 = mf;
   mf = kb->mflop[imf];
   GetDimsByContext(L1CacheElts, imf, pre, kb, &M, &N, &lda, &i, &j);
   kb = FindPrefDist(L1CacheElts, imf, pre, M, N, lda, percL1, Fflops, 
                     flushKB, kb, 'A');
   kb = FindPrefDist(L1CacheElts, imf, pre, M, N, lda, percL1, Fflops,
                     flushKB, kb, 'X');
   kb = FindPrefDist(L1CacheElts, imf, pre, M, N, lda, percL1, Fflops, 
                     flushKB, kb, 'Y');
/*
 * Retime kernel with improved prefetch
 */
   kb->mflop[imf] = TimeMyKernel(0, 1, kb, pre, M, N, lda, percL1, 
                                 Mmax(NREP,8), imf, flushKB);
   printf(
      "\nPREFETCH DISTANCE TUNING imf=%d improved from %.2f to %.2f (%.2f percent)\n",
          imf, mf, kb->mflop[imf], (kb->mflop[imf]/mf)*100.0-100.0);
   return(kb);
}

ATL_@(ru)node_t *TunePF
(
   int L1CacheElts,             /* size of L1 cache in elements */
   int imf,                     /* index into bp->mflop  */
   char pre,                    /* type/precision prefix */
   int Fflops,                  /* what to set Force flops to */
   int flushKB,                 /* 0: no flushing, else mem to flush */
   ATL_@(ru)node_t *kb          /* kernel to tune prefetch on */
)
/*
 * This routine tunes the prefetch parameters for kb
 */
{
   #ifdef ATL_NOPREFETCH
      return(kb);
   #endif
/*
 * First tune the instruction types, then the prefetch distances
 */
   #if defined(ATL_SSE1)
      kb = TunePFINST(L1CacheElts, imf, pre, Fflops, flushKB, kb);
   #endif
   return(TunePFDIST(L1CacheElts, imf, pre, Fflops, flushKB, kb));
}

ATL_@(ru)node_t *TuneBestPF
(
   int replace,                 /* 0: return new node, else replace old */
   int L1CacheElts,             /* size of L1 cache in elements */
   int imf,                     /* index into bp->mflop  */
   char pre,                    /* type/precision prefix */
   int Fflops,                  /* what to set Force flops to */
   int flushKB,                 /* 0: no flushing, else mem to flush */
   ATL_@(ru)node_t *kb          /* kernel to tune prefetch on */
)
/*
 * Assumes queue kb has been timed already for mflop[imf].  Finds the fastest
 * prefetch tunable kernel, and tunes it.
 * RETURNS: new node with best performing kernel.
 */
{
   double mfB, mftB;
   ATL_@(ru)node_t *kp, *tkpB, *kpB;

   mfB = mftB = 0;
   tkpB = kpB = NULL;
   for (kp=kb; kp; kp = kp->next)
   {
      if (FLAG_IS_SET(kp->flag, @up@(ru)F_PFTUNABLE))
      {
         if (kp->mflop[imf] > mftB)
         {
            mftB = kp->mflop[imf];
            tkpB = kp;
         }
      }
      if (kp->mflop[imf] > mfB)
      {
         mfB = kp->mflop[imf];
         kpB = kp;
      }
   }
   assert(kpB);          /* ERROR: die if no kernel has valid timing */
   if (kpB == tkpB)
   {
      kpB = NULL;
      mfB = 0.0;
   }
/*
 * If replace, replace current best tunable kernel with tuned version and
 * return the possibly new queue head
 */
   if (replace)
   {
      if (tkpB)
      {
         kpB = Clone@up@(ru)Node(tkpB);
         kpB = TunePF(L1CacheElts, imf, pre, Fflops, flushKB, kpB);
         if (tkpB != kb)
         {
            for (kp=kb; kp->next != tkpB; kp = kp->next);
            kpB->next = Kill@up@(ru)Node(tkpB);
            kp->next = kpB;
         }
         else
         {
            kpB->next = Kill@up@(ru)Node(kb);
            kb = kpB;
         }
      }
      return(kb);
   }
   if (tkpB)
   {
      tkpB = Clone@up@(ru)Node(tkpB);
      tkpB = TunePF(L1CacheElts, imf, pre, Fflops, flushKB, tkpB);
   }
   else if (replace)
      return(NULL);
   if (!tkpB)
      return(Clone@up@(ru)Node(kpB));
   else if (!kpB)
      return(tkpB);
   else if (tkpB->mflop[imf] > kpB->mflop[imf])
      return(tkpB);
   Kill@up@(ru)Node(tkpB);
   return(Clone@up@(ru)Node(kpB));
}

ATL_@(ru)node_t *TuneExtractMU
(
   int L1CacheElts,             /* size of L1 cache in elements */
   int imf,                     /* index into bp->mflop  */
   char pre,                    /* type/precision prefix */
   int Fflops,                  /* what to set Force flops to (see below) */
   int flushKB,                 /* 0: no flushing, else mem to flush */
   ATL_@(ru)node_t *klo         /* kernel wt good NU already selected */
)
@ROUT mvtksearch mvnksearch r1ksearch r2ksearch
{
   ATL_@(ru)node_t *khi, *kp;
   int i, maxU, minU, bestU, CL;
   double mfB;

   if (pre == 'd' || pre == 'c')
      CL = 8;
   else
      CL = (pre == 'z') ? 4 : 16;
   printf("\nBEGIN MU EXTRACT SEARCH, imf=%d\n", imf);
   printf("   NU=%d, MU=%d, mflop[%d]=%.2f\n", klo->@(nV)U, klo->@(mV)U, 
          imf, klo->mflop[imf]);
   khi = Clone@up@(ru)Node(klo);
   khi->min@(mV) = khi->@(mV)U = (klo->@(mV)U)<<1;
   FillIn@(RT)ExtractGenStrings(pre, khi);
   TimeAllKernelsForContext(L1CacheElts, imf, pre, Mmax(NREP,8), khi);
   printf("   NU=%d, MU=%d, mflop[%d]=%.2f\n", khi->@(nV)U, khi->@(mV)U, 
          imf, khi->mflop[imf]);
   while (khi->mflop[imf] > klo->mflop[imf] && klo->@(mV)U < 256)
   {
      kp = klo;
      klo = khi;
      khi = kp;
      khi->min@(mV) = khi->@(mV)U = (klo->@(mV)U)<<1;
      FillIn@(RT)ExtractGenStrings(pre, khi);
      TimeAllKernelsForContext(L1CacheElts, imf, pre, Mmax(NREP,8), khi);
      printf("   NU=%d, MU=%d, mflop[%d]=%.2f\n", khi->@(nV)U, khi->@(mV)U, 
             imf, khi->mflop[imf]);
   }
   minU = klo->@(mV)U;
   maxU = (khi->@(mV)U >= 256) ? 256 : khi->@(mV)U;
   if (khi->mflop[imf] > klo->mflop[imf])
   {
      bestU = khi->@(mV)U;
      mfB = khi->mflop[imf];
   }
   else
   {
      bestU = klo->@(mV)U;
      mfB = klo->mflop[imf];
   }
   KillAll@(RU)Nodes(khi);
   for (i=minU+CL; i < maxU; i += CL)
   {
      klo->min@(mV) = klo->@(mV)U = i;
      FillIn@(RT)ExtractGenStrings(pre, klo);
      TimeAllKernelsForContext(L1CacheElts, imf, pre, Mmax(NREP,8), klo);
      if (klo->mflop[imf] > mfB)
      {
         mfB = klo->mflop[imf];
         bestU = i;
      }
      printf("   NU=%d, MU=%d, mflop[%d]=%.2f\n", klo->@(nV)U, klo->@(mV)U, 
             imf, klo->mflop[imf]);
   }
/*
 * Try unrollings below CL for generators that support it
 */
   if (klo->asmbits != asmNames2bitfield("GAS_x8664"))
   {
      i = 1;
      while (i < CL)
      {
         klo->min@(mV) = klo->@(mV)U = i;
         FillIn@(RT)ExtractGenStrings(pre, klo);
         TimeAllKernelsForContext(L1CacheElts, imf, pre, Mmax(NREP,8), klo);
         if (klo->mflop[imf] > mfB)
         {
            mfB = klo->mflop[imf];
            bestU = i;
         }
         printf("   NU=%d, MU=%d, mflop[%d]=%.2f\n", klo->@(nV)U, klo->@(mV)U, 
                imf, klo->mflop[imf]);
         i = (i < 4) ? (i<<1) : i + 4;
      }
   }
   klo->mflop[imf] = mfB;
   klo->min@(mV) = klo->@(mV)U = bestU;
   FillIn@(RT)ExtractGenStrings(pre, klo);
   printf("BEST MU-TUNED GENERATED KERNEL FOR imf=%d: NU=%d, MU=%d, MF=%.2f\n",
          imf, klo->@(nV)U, bestU, mfB);
   return(klo);
}
@ROUT r1ksearch r2ksearch mvtksearch mvnksearch

ATL_@(ru)node_t *TuneExtractMUNU
(
   int L1CacheElts,             /* size of L1 cache in elements */
   int imf,                     /* index into bp->mflop  */
   char pre,                    /* type/precision prefix */
   int Fflops,                  /* what to set Force flops to (see below) */
   int flushKB,                 /* 0: no flushing, else mem to flush */
   int isuff                    /* 0: C, 1:C/SSE, 2:AMD64/SSE */
)
/*
 * This routine uses extract and the basefile atlas-l2g.base to generate
 * @up@(ru) kernels.  It exercises only M & N loop unrolling, leaving
 * all other parameters at their defaults (they will be searched later).
 */
{
@ROUT mvtksearch mvnksearch r1ksearch r2ksearch
   ATL_@(ru)node_t *kp, *kb, *kret, *b2, *k2;
/*
 * These variables document the number and values of valid N unrollings by 
 * precision.  Will need to change when more support is added to l2g.base.
 */
@ROUT r2ksearch
   const int dnnu=6, dNUs[6] = {1, 2, 3, 4, 5, 6};
   const int snnu=6, sNUs[6] = {1, 2, 3, 4, 5, 6};
   const int znnu=2, zNUs[2] = {1, 2};
   const int cnnu=2, cNUs[2] = {1, 2};
@ROUT mvtksearch mvnksearch r1ksearch
   const int dnnu=8, dNUs[8] = {1, 2, 4, 6, 8, 10, 12, 14};
   const int snnu=6, sNUs[6] = {1, 2, 4, 8, 12, 14};
   const int znnu=6, zNUs[6] = {1, 2, 3, 4, 5, 6};
   const int cnnu=5, cNUs[5] = {1, 2, 3, 4, 6};
@ROUT r2ksearch
   const int cxnnu=5, xnnu=7, xNUs[7] = {1, 2, 4, 8, 12, 16, 20};
@ROUT mvtksearch mvnksearch r1ksearch
   const int cxnnu=6, xnnu=8, xNUs[8] = {1, 2, 4, 8, 12, 16, 20, 24};
@ROUT mvtksearch mvnksearch r1ksearch r2ksearch
   int i, j, nnu, mu, nu, CL; 
   const int *NUs;
   char *suffs[3] = {"C", "Csse", "sse"};
   char ln[128];
   #if !defined(ATL_GAS_x8664) || !defined(ATL_SSE3)
      if (isuff == 2)
         return(NULL);
   #endif
   if (isuff != 0 && isuff != 2)
      return(NULL);

   fprintf(stdout, "BEGIN NU/MU EXTRACT SEARCH, imf=%d:\n", imf);
   switch(pre)
   {
   case 's' :
      if (isuff == 2)
      {
         nnu = snnu-1;
         NUs = sNUs;
      }
      else
      {
         nnu = xnnu;
         NUs = xNUs;
      }
      CL = 16;
      break;
   case 'z' :
      if (isuff == 2)
      {
         nnu = znnu;
         NUs = zNUs;
      }
      else
      {
         nnu = cxnnu;
         NUs = xNUs;
      }
      CL = 4;
      break;
   case 'c' :
      if (isuff == 2)
      {
         nnu = cnnu;
         NUs = cNUs;
      }
      else
      {
         nnu = cxnnu;
         NUs = xNUs;
      }
      CL = 8;
      break;
   default :
      if (isuff == 2)
      {
         nnu = dnnu-1;
         NUs = dNUs;
      }
      else
      {
         nnu = xnnu;
         NUs = xNUs;
      }
      CL = 8;
   }
/*
 * Create a queue of all legal NU with MU=1
 */
   kp = Get@up@(ru)Node();
   kp->ID = 900000;        /* ID=900,000-999,999 reserved for genned codes */
@ROUT mvnksearch `   sprintf(ln, "%cmvn_%s.c", pre, suffs[isuff]);`
@ROUT mvtksearch `   sprintf(ln, "%cmvt_%s.c", pre, suffs[isuff]);`
@ROUT r1ksearch  `   sprintf(ln, "%cr1_%s.c", pre, suffs[isuff]);`
@ROUT r2ksearch  `   sprintf(ln, "%cr2_%s.c", pre, suffs[isuff]);`
   kp->rout = DupString(ln);
   if (isuff == 2)
   {
      kp->cflags = DupString("-x assembler-with-cpp");
      kp->asmbits = asmNames2bitfield("GAS_x8664");
   }
   else
      kp->cflags = GetKCFlags(pre);
   if (isuff)
   {
      kp->comp = DupString(GetGoodGcc());
      kp->alignX = kp->alignY = 16;
      kp->SSE = 3;
   }
   kp->auth = DupString("R. Clint Whaley");
   kp->exflags = DupString("@up@(KP)Kdir=EXTDIR");
   kp->@(mV)U = kp->min@(mV) = CL;
   kp->@(nV)U = kp->min@(nV) = NUs[nnu-1];
@ROUT mvtksearch `   kp->TA = AtlasTrans;`
@ROUT mvnksearch `   kp->TA = AtlasNoTrans;`
@ROUT mvnksearch `   SET_FLAG(kp->flag, MVF_AXPYBASED, 1);`
   SET_FLAG(kp->flag, @(RU)F_FNU, 1);
   SET_FLAG(kp->flag, @(RU)F_INCYISONE, 1);
   SET_FLAG(kp->flag, @(RU)F_PFTUNABLE, 1);
   kp->next = NULL;

   kb = kp;
   kp = Clone@up@(ru)Node(kb);
   kp->@(nV)U = kp->min@(nV) = NUs[nnu-1];
   kp->@(mV)U = kp->min@(mV) = 2*CL;
   b2 = kp;
/*
 * Get all legal N unrollings added to queue, using MU=1, and roughly constant
 * number of inst, with MU=2 for largest NU;  The NU unrollings with constant
 * # of inst should minimize the choice of large NU based purely on loop
 * overhead reduction.  Smaller NU are better due to less conflict misses,
 * so only use them when real improvement due to vector reuse is seen.
 */
   j = NUs[nnu-1]*2*CL;  /* total number of inst */
   for (i=nnu-2; i >= 0; i--)
   {
      int big, small;
@ROUT mvtksearch mvnksearch
      if (isuff == 2 &&  NUs[i] == 3 && pre == 'c' && kp->TA == AtlasTrans)
         continue;  /* NU=3 not supported for scplx transpose */
@ROUT mvtksearch mvnksearch r1ksearch r2ksearch
/*
 *    Add MU=1 case
 */
      kp = Clone@up@(ru)Node(kb);
      kp->@(nV)U = kp->min@(nV) = NUs[i];
      kp->next = kb;
      kb = kp;
/*
 *    Add MU >=2 case, where # of inst kept roughly constant
 */
      kp = Clone@up@(ru)Node(b2);
      kp->@(nV)U = kp->min@(nV) = NUs[i];
      big = (kp->@(mV)U+CL) * NUs[i];
      big -= j;
      small = (kp->@(mV)U) * NUs[i];
      small -= j;
      big = Mabs(big);
      small = Mabs(small);
      kp->@(mV)U = kp->min@(mV) = (small < big) ? (kp->@(mV)U) : (kp->@(mV)U)+CL;
      kp->next = b2;
      b2 = kp;
   }
/*
 * Join queues together, create generation strings, and time.
 */
   for (kp=kb; kp->next; kp = kp->next);
   kp->next = b2;
   FillIn@(RT)ExtractGenStrings(pre, kb);
   #ifndef DEBUG
      kb = DelBadTestKernels(pre, kb);
   #endif
   kp = TimeAllKernelsForContext(L1CacheElts, imf, pre, Mmax(NREP,8), kb);
   assert(kp);
/*
 * Print out results of NU search
 */
   for (k2=kb; k2; k2 = k2->next)
      printf("   mu=%d, nu=%d, mflop[%d]=%.2f\n", k2->MU, k2->NU, imf, 
             k2->mflop[imf]);
/*
 * Choose best performing case for MU exploration, delete NU queue
 */
   kp = Clone@up@(ru)Node(kp);
   KillAll@(RU)Nodes(kb);
   kp->next = NULL;
   printf("BEST GENERATED NU-TUNED KERNEL FOR imf=%d: MU=%d, NU=%d, MF=%.2f\n", 
          imf, kp->@(mV)U, kp->@(nV)U, kp->mflop[imf]);
   kb = TuneExtractMU(L1CacheElts, imf, pre, Fflops, flushKB, kp);
   assert(DelBadTestKernels(pre,kb) == kb);
   return(kb);
}
@ROUT r1ksearch r2ksearch mvtksearch mvnksearch

void ExhaustiveTime(char pre, char *fin, char *fout, int lvl)
/* 
 * This routine attempts to time every kernel for all contexts, with the
 * out-of-cache blocking being individually tuned for each routine.  It is
 * used to compare differing implementations head-to-head, and does no
 * kernel selection, just the timing.  
 * All timings use all operands aligned to ATL_Cachelen, incX=incY=1.
 */
{
   ATL_@(ru)node_t *r1b, *r1p, *r1OOC, *r1L1, *r1L2, *r1s; 
   ATL_@(ru)node_t *r1L1b=NULL, *r1L2b=NULL;
   double mfB;
   char *blkstr;
   FILE *fpout;
   size_t Nooc=8000/16, Mooc=8000*16;  /* rough dims of out-of-cache problem */
   int Nl2, Ml2, Nl1, Ml1, lcmM, lcmN, minNU, maxNU, n;
   int L1ce, L2ce, fflops, L2CacheElts, L1CacheElts, i;

   r1b = Read@up@(ru)File(fin);  /* get kernels to be timed */
   assert(r1b);
   r1b = DelRepeated@up@(ru)Kernels(r1b);
   r1b = DelBadArch@up@(ru)Kernels(r1b);
   if (lvl & 1)
      r1b = DelBadTestKernels(pre, r1b);
   assert(r1b);
   fprintf(stdout, "\nSurviving cases:\n");
   Write@up@(ru)File("stdout", r1b);
/*
 * Find M/N unrollings that are multiples of all kernel's native blocking
 * Force lcmM to be at least 32 bytes long to avoid alignment issues
 */
   if (pre == 's')
      lcmM = 8;
   else if (pre == 'd' || pre == 'c')
      lcmM = 4;
   else 
      lcmM = 2; 
   lcmN = 1;
   maxNU = minNU = r1b->NU;
   for (r1p=r1b; r1p; r1p = r1p->next)
   {
      lcmM = Mylcm(lcmM, r1p->MU);
      lcmN = Mylcm(lcmN, r1p->NU);
      if (minNU > r1p->NU)
         minNU = r1p->NU;
      if (maxNU < r1p->NU)
         maxNU = r1p->NU;
   }
/*
 * Set out-of-cache dimensions; first compute minimum acceptable values
 */
   L2CacheElts = (L2KB) ? (L2KB*1024)/pre2size(pre) : 4*L1CacheElts;
   Mooc = (1.1*L2CacheElts)/(minNU+1);  /* OOC working set for everyone */
   if (Mooc >= lcmM)
      Mooc = ((Mooc+lcmM-1)/lcmM)*lcmM;
   Nooc = ((8*maxNU+lcmN-1)/lcmN)*lcmN;
   if (Nooc < 100)
      Nooc = ((100+lcmN-1)/lcmN)*lcmN;
/*
 * Adjust M upward until matrix at least as big as 8000x8000
 */
   if (Mooc * Nooc < 8000*8000)
   {
      Mooc = (8000*8000)/Nooc;
      if (Mooc >= lcmM)
         Mooc = ((Mooc+lcmM-1)/lcmM)*lcmM;
   }
/*
 * If matrix bigger than 488MB, may cause swapping to time it, so
 * reduce Nooc, at the cost of having to floor it with NU
 */
   if (Mooc*Nooc*pre2size(pre) > 8000*8000*sizeof(double))
   {
      Nooc = (8000*8000*sizeof(double))/pre2size(pre);
      Nooc = (Nooc)/Mooc;
      Nooc = ((Nooc+maxNU-1)/maxNU)*maxNU;
      if (Nooc < maxNU)
         Nooc = maxNU;
   }


/*
 * Force in-cache problems to do 3 mflops for timing
 */
   fflops = 3;
/*
 * Set in-L2 cache problem dimensions, estimate use of 80% of cache
 */
   Nl2 = lcmN;
   Ml2 = 0.8*L2CacheElts;
   Ml2 /= Nl2;
   if (Ml2 >= lcmM+lcmM)
      Ml2 = (Ml2/lcmM)*lcmM;
/*
 * If M dimension strongly constrained, rescale N dim and accept slightly 
 * differing problem sizes.  Need Q sorted from greatest to least, so that
 * we ensure the common N can use the floor operation with NU in order 
 * to vary the N dim to work with all NU
 */
   if (Ml2 < 480)
   {
      r1s = Clone@(RU)Queue(r1b);  /* get dup Q */
      r1s = SortQByNU(r1s);     /* sort from greatest to least */
      Ml2 = 0.8*L2CacheElts;
      i = Nl2 = r1s->NU;
      for (r1p=r1s->next; r1p; r1p = r1p->next)
      {
         i = Mylcm(i, r1p->NU);
         if (i*480 > Ml2) break;
         Nl2 = i;
      }
      KillAll@(RU)Nodes(r1s);
      Ml2 /= Nl2;
      if (Ml2 >= lcmM+lcmM)
         Ml2 = (Ml2/lcmM)*lcmM;
   }
/*
 * Set in-L1 cache problem dimensions, estimate use of 90% of cache
 */
   L1CacheElts = (GetL1CacheSize()*1024) / pre2size(pre);
   Nl1 = lcmN;
   Ml1 = 0.9*L1CacheElts;
   Ml1 /= Nl1;
   Ml1 = (Ml1/lcmM)*lcmM;
   if (Ml1 >= lcmM+lcmM)
      Ml1 = (Ml1/lcmM)*lcmM;
   if (Ml1 < 120)
   {
      r1s = Clone@(RU)Queue(r1b);  /* get dup Q */
      r1s = SortQByNU(r1s);     /* sort from greatest to least */
      Ml1 = 0.9*L2CacheElts;
      i = Nl1 = r1s->NU;
      for (r1p=r1s->next; r1p; r1p = r1p->next)
      {
         i = Mylcm(i, r1p->NU);
         if (i*120 > Ml1) break;
         Nl1 = i;
      }
      KillAll@(RU)Nodes(r1s);
      Ml1 /= Nl1;
      if (Ml1 >= lcmM+lcmM)
         Ml1 = (Ml1/lcmM)*lcmM;
   }
   printf("lcmM=%d, lcmN=%d\n", lcmM, lcmN);
   printf("Mooc=%d, Nooc=%d;  ML2=%d, NL2=%d;  ML1=%d NL1=%d\n",
          (int)Mooc, (int)Nooc, Ml2, Nl2, Ml1, Nl1);
   if (lvl & 2)
   {
/*
 *    Find kernels unblocked performance for out-of-cache timings
 */
      printf("\nTIMING OUT-OF-CACHE CASES WITH NO BLOCKING, M=%d, N=%d\n", 
             (int)Mooc, (int)Nooc);
      for (r1p=r1b; r1p; r1p = r1p->next)
      {
         r1p->CacheElts = 0;
         r1p->mflop[2] = Time@(RT)Kernel(VERB, 0, r1p, pre, (Mooc/r1p->MU)*r1p->MU,
                                      (Nooc/r1p->NU)*r1p->NU, Mooc, 0, 
                                      NREP, fflops, 0);
      }
   }
/*
 * Handle blocking tuning differently if we need exhaustive search
 */
   if (lvl & 16)
   {
      if (lvl & 8) /* time L1-blocked OOC? */
      {
         r1L1b = Clone@(RU)Queue(r1b);  /* get dup Q */
         for (r1p=r1L1b, r1s=r1b; r1p; r1p = r1p->next, r1s=r1s->next)
         {
            n = (Nooc/r1p->NU)*r1p->NU;
            ExhaustiveCESrch(r1p, 0, pre, (Mooc/r1p->MU)*r1p->MU, n, Mooc, 
                             2, 25, 50);
            r1p->CacheElts = L1CacheElts*0.01*r1p->CacheElts;
            if (r1p->mflop[0] >= r1s->mflop[2])
               r1s->CacheElts = r1p->CacheElts;
            r1s->mflop[0] = r1p->mflop[0];
         }
      }
      if (lvl & 4)  /* time L2-blocked OOC? */
      {
         r1L2b = Clone@(RU)Queue(r1b);  /* get dup Q */
         for (r1p=r1L2b, r1s=r1b; r1p; r1p = r1p->next, r1s = r1s->next)
         {
            n = (Nooc/r1p->NU)*r1p->NU;
            r1p->CacheElts = L2CacheElts;
            i = 2*L2CacheElts / (L1CacheElts);
            i = Mmax(i, 16);
            ExhaustiveCESrch(r1p, 1, pre, (Mooc/r1p->MU)*r1p->MU, n, Mooc, 
                             50, 3, i);
            r1p->CacheElts = L1CacheElts*0.01*r1p->CacheElts;
            if (r1p->mflop[1] >= r1s->mflop[2] && r1p->mflop[1] > r1s->mflop[0])
               r1s->CacheElts = r1p->CacheElts;
            r1s->mflop[1] = r1p->mflop[1];
         }
      }
      if (lvl & 2)  /* Timed no-blocking results */
      {
         printf("\nNO BLOCKING RESULTS:\n");
         printf("--------------------\n");
         for (r1p=r1b; r1p; r1p = r1p->next)
            printf("   %d:%s, M=%d, N=%d, CacheElts=%d, gets =%.2f MFLOPS\n",
                   r1p->ID, r1p->rout, (int)(Mooc/r1p->MU)*r1p->MU, 
                   (int)(Nooc/r1p->NU)*r1p->NU, r1p->CacheElts, r1p->mflop[2]);
      }
      if (lvl & 8) /* timed L1-blocked OOC? */
      {
         printf("\nL1 BLOCKING RESULTS:\n");
         printf("--------------------\n");
         for (r1p=r1L1b; r1p; r1p = r1p->next)
            printf("   %d:%s, M=%d, N=%d, CacheElts=%d, gets =%.2f MFLOPS\n",
                   r1p->ID, r1p->rout, (int)(Mooc/r1p->MU)*r1p->MU, 
                   (int)(Nooc/r1p->NU)*r1p->NU, r1p->CacheElts, r1p->mflop[0]);
      }
      if (lvl & 4) /* timed L2-blocked OOC? */
      {
         printf("\nL2 BLOCKING RESULTS:\n");
         printf("--------------------\n");
         for (r1p=r1L2b; r1p; r1p = r1p->next)
            printf("   %d:%s, M=%d, N=%d, CacheElts=%d, gets =%.2f MFLOPS\n",
                   r1p->ID, r1p->rout, (int)(Mooc/r1p->MU)*r1p->MU, 
                   (int)(Nooc/r1p->NU)*r1p->NU, r1p->CacheElts, r1p->mflop[1]);
      }
   }
   else  /* Just do normal 75/90% searches */
   {
      if (lvl & 8) /* time L1-blocked OOC? */
      {
/*
 *       Find kernels L1-blocked & L2-blocked performance using 85% of cache
 */
         printf("\nTIMING OUT-OF-CACHE CASES WITH L1 BLOCKING, M=%d, N=%d\n", 
                (int)Mooc, (int)Nooc);
         for (r1p=r1b; r1p; r1p = r1p->next)
         {
            r1p->CacheElts = 0.92 * L1CacheElts;
            r1p->mflop[0] = TimeMyKernel(VERB, 0, r1p, pre, 
                                         (Mooc/r1p->MU)*r1p->MU,
                                         (Nooc/r1p->NU)*r1p->NU, Mooc, 85, 
                                         NREP, 0, 0);
         }
      }
      if (lvl & 4) /* time L2-blocked OOC? */
      {
         printf("\nTIMING OUT-OF-CACHE CASES WITH L2 BLOCKING, M=%d, N=%d\n", 
                (int)Mooc, (int)Nooc);
         for (r1p=r1b; r1p; r1p = r1p->next)
         {
            r1p->CacheElts = 0.75 * L2CacheElts;
            i = (100.0*r1p->CacheElts)/(1.0*L1CacheElts);
            r1p->mflop[1] = TimeMyKernel(VERB, 0, r1p, pre, 
                                         (Mooc/r1p->MU)*r1p->MU,
                                         (Nooc/r1p->NU)*r1p->NU, Mooc, i, 
                                         NREP, 1, 0);
         }
      }
      if (lvl&12)  /* did both L1 & L2, choose best one */
      {
         for (r1p=r1b; r1p; r1p = r1p->next)
            r1p->CacheElts = (r1p->mflop[0] >= r1p->mflop[1]) ? 
                             0.92*L1CacheElts : 0.75*L2CacheElts;
      }
   }  /* end if on exhaustive or estimate blocking search */

   if (lvl & 32) /* time in-L2 problems? */
   {
      printf("\nTIMING IN-L2 PROBLEMS, M=%d, N=%d\n", Ml2, Nl2);
      for (r1p=r1b; r1p; r1p = r1p->next)
         r1p->mflop[3] = TimeMyKernel(VERB, 0, r1p, pre, (Ml2/r1p->MU)*r1p->MU,
                                      (Nl2/r1p->NU)*r1p->NU, Ml2, 0, 
                                      NREP, 3, 0);
   }
   if (lvl & 64) /* time in-L1 performance? */
   {
      printf("\nTIMING IN-L1 PROBLEMS, M=%d, N=%d\n", Ml1, Nl1);
      for (r1p=r1b; r1p; r1p = r1p->next)
         r1p->mflop[4] = TimeMyKernel(VERB, 0, r1p, pre, (Ml1/r1p->MU)*r1p->MU,
                                      (Nl1/r1p->NU)*r1p->NU, Ml1, 0, 
                                      NREP, 4, 0);
   }
/*
 * Find best kernel for out-of-cache, and the blocking it used
 */
   r1OOC = NULL;
   mfB = 0.0;

   if (lvl & 2)  /* did we time unblocked OOC? */
   {
      r1OOC = FindFastest@(RU)Kernel(pre, r1b, 2, 1);
      r1OOC->CacheElts = 0;
      blkstr = "no blocking";
      mfB = r1OOC->mflop[2];
   }
   if (lvl&16)  /* did exhaustive cache blocking search */
   {
      if (lvl & 4) /* did we time L2-blocked OOC? */
      {
         r1p = FindFastest@(RU)Kernel(pre, r1L2b, 1, 1);
         if (!r1OOC || r1p->mflop[1] > mfB)
         {
            r1OOC = Clone@(RU)Node(r1p);
            r1OOC->next = NULL;
            blkstr = "L2 blocking";
            mfB = r1p->mflop[1];
         }
         KillAll@(RU)Nodes(r1L2b);
      }

      if (lvl & 8) /* did we time L1-blocked OOC? */
      {
         r1p = FindFastest@(RU)Kernel(pre, r1L1b, 0, 1);
         if (!r1OOC || r1p->mflop[0] > mfB)
         {
            r1OOC = Clone@(RU)Node(r1p);
            r1OOC->next = NULL;
            blkstr = "L1 blocking";
            mfB = r1p->mflop[0];
         }
         KillAll@(RU)Nodes(r1L1b);
      }
   }
   else  /* did simple % estimate cacheedge search */
   {
      if (lvl & 4) /* did L2-blocked OOC */
      {
         r1p = FindFastest@(RU)Kernel(pre, r1b, 1, 1);
         if (!r1OOC || r1p->mflop[1] > mfB)
         {
            mfB = r1p->mflop[1];
            r1OOC = r1p;
            blkstr = "L2 blocking";
         }
      }
      if (lvl & 8) /* did L1-blocked OOC */
      {
         r1p = FindFastest@(RU)Kernel(pre, r1b, 0, 1);
         if (!r1OOC || r1p->mflop[0] > mfB)
         {
            mfB = r1p->mflop[0];
            r1OOC = r1p;
            blkstr = "L1 blocking";
         }
      }
   }    /* end if on type of cacheedge search */
/*
 * Find best in-L2 and in-L1 kernels
 */
   r1L2 = FindFastest@(RU)Kernel(pre, r1b, 3, 1);
   r1L1 = FindFastest@(RU)Kernel(pre, r1b, 4, 1);

   fpout = fopen(fout, "w");
   assert(fpout);
   WriteMflopExp(fpout);
   fprintf(fpout, 
           "#\n# Mooc=%d, Nooc=%d, Ml2=%d, Nl2=%d, Ml1=%d Nl1=%d\n#\n#\n",
           (int)Mooc, (int)Nooc, Ml2, Nl2, Ml1, Nl1);
   fprintf(fpout, "# ==========================\n");
   fprintf(fpout, "# Performance of all kernels\n");
   fprintf(fpout, "# ==========================\n");
   Print@(RU)Nodes(fpout, r1b);
   fprintf(fpout, "################################### -- CUT HERE -- ############################\n");
   fprintf(fpout, "###############################################################################\n#\n");

   if (lvl & 64)
   {
      fprintf(fpout, "# ----------------------------------------\n");
      fprintf(fpout, "# Following kernel is best in-L1 performer\n");
      fprintf(fpout, "# ----------------------------------------\n");
      Print@(RU)Line(fpout, r1L1);
   }
   if (lvl & 32)
   {
      fprintf(fpout, "# ----------------------------------------\n");
      fprintf(fpout, "# Following kernel is best in-L2 performer\n");
      fprintf(fpout, "# ----------------------------------------\n");
      Print@(RU)Line(fpout, r1L2);
   }
   if (lvl & 2)
   {
      fprintf(fpout, "# ---------------------------------------------------\n");
      fprintf(fpout, "# Following kernel is best out-of-cache using %s\n", 
              blkstr);
      fprintf(fpout, "# ---------------------------------------------------\n");
      Print@(RU)Line(fpout, r1OOC);
   }
   WriteMflopExp(fpout);
   fclose(fpout);
}
@ROUT r1ksearch
void GetCEDims
(
   ATL_r1node_t *r1L2,     /* best L2-cache contained rank-1 update */
   size_t CE,              /* # elts to assume in cache */
   int *M,
   int *N
)
{
   const int nu=r1L2->NU, mu=r1L2->MU;
   int m, n;
   n = nu<<2;
   n = (n >= r1L2->minN) ? n : r1L2->minN;
   m = (CE-n) / (n+1);
   m = (m/mu)*mu;
   assert(m >= r1L2->minM);
   *M = m;
   *N = n;
}
/*
 * Should only be called for pre='d'
 */
void FindCacheEdge
(
   ATL_r1node_t *r1L2,     /* best L2-cache contained rank-1 update */
   size_t L1CacheElts      /* size of L1 cache in elements */
)
{
/*
 * beginning elts not allowed > 128K (L1 might really be L2 in such case)
 */
   size_t elt0 = (L1CacheElts >= 16384) ? 16384 : L1CacheElts;
   const size_t maxSZ = 16*1024*1024;
   double mf;
   int i;

   printf("     M       N  Cache Size   footprint      MFLOPS\n");
   printf("======  ======  ==========  ==========  ==========\n");

   r1L2 = CloneR1Node(r1L2);  /* get local copy, don't mess up original */

   for (i=0; i < 24; i++)
   {
      size_t Ne = (elt0 << i);
      unsigned int M, N;

      if (Ne*sizeof(double) > maxSZ)
         break;
      GetCEDims(r1L2, Ne, &M, &N);
      mf = TimeMyKernel(0, 1, r1L2, 'd', M, N, M, 0, 5, 0, 0);
      printf("%6u %7u %11u %11u %10.1f\n", M, N, 
             (unsigned int)(Ne*sizeof(double)), 
             (unsigned int)((M*N+M+N)*sizeof(double)), mf);
   }
   KillR1Node(r1L2);        /* delete local copy */
}

@ROUT r1ksearch r2ksearch mvtksearch mvnksearch
int main(int nargs, char **args)
{
   ATL_@(ru)node_t *ocb, *i2b, *i1b, *syb, *r1cA, *r1cB;
   ATL_@(ru)node_t *r1b, *r1p, *r1r, *r1bestL2b, *r1gen, *r1gA, *r1gB; 
   ATL_@(ru)node_t *r1bestOC, *r1bestOCr, *r1bestL1b, *r1bestL1br;
   ATL_@(ru)node_t *r1bestL1, *r1bestL1r, *r1bestL2, *r1bestL2r;
   FILE *fpin, *fpout;
   double mf, percL1;
   int i, j, L1CacheElts, CE1, CE2, maxID, ETIME, imf, M, N, lda, genID;
   char *fin, *fout;
   char ln[128];
   char pre;

   r1r = GetFlags(nargs, args, &pre, &ETIME, &fin, &fout);
   if (ETIME)
   {
      ExhaustiveTime(pre, fin, fout, ETIME);
      exit(0);
   }
   L1CacheElts = (GetL1CacheSize()*1024) / pre2size(pre);
   r1b = Read@(RU)File(fout);
   SetAll@(RU)TypeFlags(pre, r1b);
   ATL_SubGoodGccIn@(RU)Nodes(r1b);
   maxID = GetMaxID(r1b);
   if (r1b)
   {
      if (r1r)  /* don't care about external searches if we've got answer */
         KillAll@(RU)Nodes(r1r);
/*
 *    Create generator strings & say to look in EXTDIR for files that need it
 */
      FillIn@up@(rt)ExtractGenStrings(pre, r1b);
      for (r1p=r1b; r1p; r1p = r1p->next)
      {
         if (r1p->ID >= 900000 && r1p->ID < 1000000)
         {
            if (r1p->exflags)
            {
               i = strlen(r1p->exflags);
               r1p->exflags = GetLongerString(r1p->exflags, i+16);
               strcpy(r1p->exflags+i, "@up@(KP)Kdir=EXTDIR");
            }
            else
               r1p->exflags = DupString("@up@(KP)Kdir=EXTDIR");
         }
      }
      if (r1b->mflop[3] <= 0.0)
      {
/*
 *       Split queue by context/routine
 */
         ATL_@(RU)SplitContexts(r1b, &ocb, &i2b, &i1b, &syb);
/*
 *       Retime out-of-cache kernel
 */
         TimeAllKernels(0, L1CacheElts, 0, pre, 0, 0, -1, ocb);
/* 
 *       Retime in-L2 timings
 */
         TimeAllKernelsForContext(L1CacheElts, 3, pre, NREP, i2b);
@ROUT r1ksearch
         #if 0
         if (pre == 'd')
         {
            r1bestL2r = i2b->next;
            r1bestL2r = (r1bestL2r) ? r1bestL2r : i2b;
            FindCacheEdge(r1bestL2r, L1CacheElts);
         }
         #endif
@ROUT r1ksearch r2ksearch mvtksearch mvnksearch
/* 
 *       Retime in-L1 timings
 */
         TimeAllKernelsForContext(L1CacheElts, 4, pre, NREP, i1b);
/*
 *       Retime L1-blocked out-of-cache timings
 */
         TimeAllKernels(0, L1CacheElts, 0, pre, 0, 0, -1, syb);
         r1b = ATL_@(RU)LinkContexts(ocb, i2b, i1b, syb);
         ResubGoodGccIn@(RU)Nodes(r1b);
         Write@(RU)SummFile(fout, r1b);
      }
      Print@(RU)Nodes(stdout, r1b);
      KillAll@(RU)Nodes(r1b);
      exit(0);
   }
   r1b = Read@up@(ru)File(fin);
   if (r1r)  /* add external outputs to our queue */
   {
      if (!r1b)
         r1b = r1r;
      else
      {
         for (r1p=r1b; r1b->next; r1p = r1p->next);
         r1p->next = r1r;
      }
   }
   if (!r1b)
   {
      fprintf(stderr, "\n%s: NO INPUT KERNELS, CANNOT RUN!\n\n", args[0]);
      exit(-1);
   }
   fprintf(stdout, "\nCases read in:\n");
   Write@(RU)File("stdout", r1b);
   r1b = DelRepeated@(RU)Kernels(r1b);
   r1b = DelBadArch@(RU)Kernels(r1b);
@skip   fprintf(stdout, "\nCases after weeding:\n");
@skip   WriteR1File("stdout", r1b);
   r1b = DelBadTestKernels(pre, r1b);
   fprintf(stdout, "\nSurviving cases:\n");
   Write@(RU)File("stdout", r1b);

   r1b = SortRestricted(r1b, &r1r);     /* sort into general & rest kernels */
/*
 * Find best out-of-cache kernel using the ANSI C generator, and add it to
 * the unrestricted kernels.
 */
   genID = 0;
   r1gen = TuneExtractMUNU(L1CacheElts, 1, pre, 0, -1, 0);
   if (r1gen)
   {
      r1gen->next = r1b;
      r1gen->ID++;
      genID = r1gen->ID + 1;
      r1cA = r1b = r1gen;
   }
/*
 * Find best out-of-cache generated kernel using x8664 SSE3 assembly, and 
 * add it to the unrestricted kernels; add an aligned-A version to the 
 * restricted kernels
 */
   r1gen = TuneExtractMUNU(L1CacheElts, 1, pre, 0, -1, 2);
   if (r1gen)
   {
      r1gen->next = r1b;
      if (genID)
         r1gen->ID = genID;
      else
         r1gen->ID = genID = r1gen->ID + 1;
      genID++;
      r1gA = r1b = r1gen;
      r1gen = Clone@(RU)Node(r1gen);
      r1gen->alignA = r1gen->ldamul = 16;
      r1gen->ID = genID++;
      FillIn@(RT)ExtractGenStrings(pre, r1gen);
      r1gen->next = r1r;
      r1r = r1gen;
   }
   else r1gA = NULL;
/*
 * Find best general kernel for L1-blocked out-of-cache behavior; use
 * cache elements of 85% of L1 size
 */
   for (r1p=r1b; r1p; r1p = r1p->next)
      r1p->CacheElts = 0.85 * L1CacheElts;
   fprintf(stdout, "\nBEGIN L1-BLOCKED TUNING\n");
   TimeAllKernels(0, L1CacheElts, 0, pre, 0, 0, -1, r1b);
   r1bestL1b = TuneBestPF(0, L1CacheElts, 0, pre, 0, -1, r1b);
   fprintf(stdout, "DONE L1-BLOCKED TUNING, CHOSE '%s' (%.2f)\n\n",
           r1bestL1b->rout, r1bestL1b->mflop[0]);
/* 
 * Find best L1 blocking % of cache, convert back to Elts
 */
   GetDimsByContext(L1CacheElts, 0, pre, r1bestL1b, &M, &N, &lda, &i, &j);
   ExhaustiveCESrch(r1bestL1b, 0, pre, M, N, lda, 2, 25, 50);
   r1bestL1b->CacheElts = L1CacheElts*0.01*r1bestL1b->CacheElts;
/*
 * Find best kernel for L2-blocked out-of-cache context; use min of 4*L1 
 * and 128K as good effective L2 estimate, convert back to elts
 */
   CE1 = 4 * L1CacheElts;
   CE1 = Mmin(CE1, 128*1024/pre2size(pre));
   for (r1p=r1b; r1p; r1p = r1p->next)
      r1p->CacheElts = CE1;
   fprintf(stdout, "\nBEGIN L2-BLOCKED TUNING\n");
   TimeAllKernels(0, L1CacheElts, 1, pre, 0, 0, -1, r1b);
   r1bestL2b = TuneBestPF(0, L1CacheElts, 1, pre, 0, -1, r1b);
   fprintf(stdout, "DONE L2-BLOCKED TUNING, CHOSE '%s' (%.2f)\n\n",
           r1bestL2b->rout, r1bestL2b->mflop[1]);

   GetDimsByContext(L1CacheElts, 1, pre, r1bestL1b, &M, &N, &lda, &i, &j);
   ExhaustiveCESrch(r1bestL2b, 1, pre, M, N, lda, 50, 3, 16);
   r1bestL2b->CacheElts = L1CacheElts*0.01*r1bestL2b->CacheElts;

   printf("BEST L1-blocked kernel:\n");
   Write@up@(ru)File("stdout", r1bestL1b);
   printf("BEST L2-blocked kernel:\n");
   Write@up@(ru)File("stdout", r1bestL2b);
/*
 * Find best kernel for in-L2 and in-L1 usage; add best MU/NU generated cases
 */
   r1gen = TuneExtractMUNU(L1CacheElts, 4, pre, 0, -1, 0);
   if (r1gen && (r1gen->MU != r1cA->MU || r1gen->NU != r1cA->NU))
   {
      r1gen->ID = genID++;
      r1gen->next = r1b;
      r1cB = r1b = r1gen;
   }
   else
   {
      Kill@up@(ru)Node(r1gen);
      r1cB = r1cA;
   }
   r1gen = TuneExtractMUNU(L1CacheElts, 4, pre, 0, -1, 2);
   if (r1gen && (r1gen->MU != r1gA->MU || r1gen->NU != r1gA->NU))
   {
      r1gen->ID = genID++;
      r1gen->next = r1b;
      r1gB = r1b = r1gen;
      r1gen = Clone@(RU)Node(r1gen);
      r1gen->alignA = r1gen->ldamul = 16;
      r1gen->ID = genID++;
      FillIn@(RT)ExtractGenStrings(pre, r1gen);
      r1gen->next = r1r;
      r1r = r1gen;
   }
   else
   {
      Kill@up@(ru)Node(r1gen);
      r1gB = r1gA;
   }
   r1gen = TuneExtractMUNU(L1CacheElts, 3, pre, 0, -1, 0);
   if (r1gen && (r1gen->MU != r1cA->MU || r1gen->NU != r1cA->NU) &&
       (r1gen->MU != r1cB->MU || r1gen->NU != r1cB->NU))
   {
      r1gen->ID = genID++;
      r1gen->next = r1b;
      r1b = r1gen;
   }
   else if (r1gen)
      Kill@up@(ru)Node(r1gen);
   r1gen = TuneExtractMUNU(L1CacheElts, 3, pre, 0, -1, 2);
   if ( r1gen && (r1gen->MU != r1gA->MU || r1gen->NU != r1gA->NU) &&
        (r1gen->MU != r1gB->MU || r1gen->NU != r1gB->NU) )
   {
      r1gen->ID = genID++;
      r1gen->next = r1b;
      r1b = r1gen;
      r1gen = Clone@(RU)Node(r1gen);
      r1gen->alignA = r1gen->ldamul = 16;
      r1gen->ID = genID++;
      FillIn@(RT)ExtractGenStrings(pre, r1gen);
      r1gen->next = r1r;
      r1r = r1gen;
   }
   else
      Kill@up@(ru)Node(r1gen);
   TimeAllKernelsForContext(L1CacheElts, 4, pre, NREP, r1b);
   r1bestL1 = TuneBestPF(0, L1CacheElts, 4, pre, 0, 0, r1b);
   r1bestL2 = TimeAllKernelsForContext(L1CacheElts, 3, pre, NREP, r1b);
   r1bestL2 = TuneBestPF(0, L1CacheElts, 3, pre, 0, 0, r1b);
   r1bestOC = TimeAllKernelsForContext(L1CacheElts, 2, pre, NREP, r1b);
   r1bestOC = TuneBestPF(0, L1CacheElts, 2, pre, 0, -1, r1b);
   r1bestL2->CacheElts = r1bestL2b->CacheElts;
   r1bestOC->CacheElts = 0;
   r1bestL1->next = r1bestL2->next = r1bestOC->next = NULL;
   r1bestL1->CacheElts = r1bestL1b->CacheElts;
/*
 * Figure out what type of blocking to use for out-of-cache context
 */
   r1p = ChooseKernelBlocking(r1bestL1b, r1bestL2b, r1bestOC);
   if (r1p != r1bestOC)
   {
      Kill@(RU)Node(r1bestOC);
      r1bestOC = Clone@(RU)Node(r1p);
   }
   printf("\nBest out-of-cache kernel:\n");
   Write@up@(ru)File("stdout", r1bestOC);
/*
 * When timing restricted kernels, we will use best CE found by unresticted,
 * and we can tune only the contexts we use: r1bestOC, r1bestL1[b], r1bestL2.
 */
   if (r1r)
   {
/*
 *    Find best restricted out-of-cache, L1blocked, in-L1 & in-L2 kernels
 */
      fprintf(stdout, "\nBEGIN RESTRICTED OUT-OF-CACHE TUNING\n");
      for (r1p=r1r; r1p; r1p = r1p->next)
         r1p->CacheElts = r1bestOC->CacheElts;
      if (r1bestOC->CacheElts > L1CacheElts)
         i = 1;
      else if (r1bestOC->CacheElts)
         i = 0;
      else 
         i = 2;
      TimeAllKernels(0, L1CacheElts, i, pre, 0, 0, -1, r1r);
      r1p = Clone@(RU)Queue(r1r);  /* get private copy for destruction */
      r1p = TuneBestPF(1, L1CacheElts, i, pre, 0, -1, r1p);
      r1bestOCr = DecimateAndRankRestricted(i, r1bestOC, r1p);
      if (r1bestOCr)
      {
         fprintf(stdout, "KERNEL CHOSEN:\n");
         Print@(RU)Nodes(stdout, r1bestOCr);
         fprintf(stdout, "DONE RESTRICTED OUT-OF-CACHE TUNING.\n");
      }
      else
         fprintf(stdout, "NO RESTRICTED OUT-OF-CACHE KERNEL USED.\n");

      fprintf(stdout, "\nBEGIN RESTRICTED L1-BLOCKED TUNING\n");
      for (r1p=r1r; r1p; r1p = r1p->next)
         r1p->CacheElts = r1bestL1b->CacheElts;
      TimeAllKernels(0, L1CacheElts, 0, pre, 0, 0, -1, r1r);
      r1p = Clone@(RU)Queue(r1r);  /* get private copy for destruction */
      r1p = TuneBestPF(1, L1CacheElts, 0, pre, 0, -1, r1p);
      r1bestL1br = DecimateAndRankRestricted(0, r1bestL1b, r1p);
      if (r1bestL1br)
      {
         fprintf(stdout, "KERNEL CHOSEN:\n");
         Print@(RU)Nodes(stdout, r1bestL1br);
         fprintf(stdout,"DONE RESTRICTED L1-BLOCKED TUNING.\n");
      }
      else
         fprintf(stdout, "NO RESTRICTED L1-BLOCKED KERNEL USED.\n");

      fprintf(stdout, "\nBEGIN RESTRICTED in-L1 TUNING\n");
      TimeAllKernelsForContext(L1CacheElts, 4, pre, NREP, r1r);
      r1bestL1r = Clone@up@(ru)Queue(r1r);  /* get private copy for destruction */
      r1bestL1r = TuneBestPF(1, L1CacheElts, 4, pre, 0, 0, r1bestL1r);
      r1bestL1r = DecimateAndRankRestricted(4, r1bestL1, r1bestL1r);
      if (r1bestL1r)
      {
         fprintf(stdout, "KERNEL CHOSEN:\n");
         Print@(RU)Nodes(stdout, r1bestL1r);
         fprintf(stdout, "DONE RESTRICTED in-L1 TUNING.\n");
      }
      else
         fprintf(stdout, "NO RESTRICTED L1-BLOCKED KERNEL USED.\n");

      fprintf(stdout, "\nBEGIN RESTRICTED in-L2 TUNING\n");
      for (r1p=r1r; r1p; r1p = r1p->next)
         r1p->CacheElts = r1bestL2b->CacheElts;
      TimeAllKernelsForContext(L1CacheElts, 3, pre, NREP, r1r);
      r1bestL2r = Clone@(RU)Queue(r1r);  /* get private copy for destruction */
      r1bestL2r = TuneBestPF(1, L1CacheElts, 3, pre, 0, 0, r1bestL2r);
      r1bestL2r = DecimateAndRankRestricted(3, r1bestL2, r1bestL2r);
      if (r1bestL2r)
      {
         fprintf(stdout, "KERNEL CHOSEN:\n");
         Print@(RU)Nodes(stdout, r1bestL2r);
         fprintf(stdout, "DONE RESTRICTED in-L2 TUNING.\n");
      }
      else
         fprintf(stdout, "NO RESTRICTED in-L2 KERNEL USED.\n");
   }
   else
      r1bestOCr = r1bestL1r = r1bestL2r = r1bestL1br = NULL;
/* 
 * Indicate unrestricted kernel by setting rankR=0, and add it to end
 * of restricted kernels to make our final fastest-to-slowest call chain
 */
   KillAll@(RU)Nodes(r1b);
   KillAll@(RU)Nodes(r1r);
   r1bestOC->rankR = r1bestL1b->rankR = r1bestL1->rankR = r1bestL2->rankR = 0;

   if (r1bestOCr)
   {
      r1p = ATL_Last@(RU)Node(r1bestOCr);
      r1p->next = r1bestOC;
   }
   else
      r1bestOCr = r1bestOC;

   if (r1bestL1br)
   {
      r1p = ATL_Last@(RU)Node(r1bestL1br);
      r1p->next = r1bestL1b;
   }
   else
      r1bestL1br = r1bestL1b;

   if (r1bestL1r)
   {
      r1p = ATL_Last@(RU)Node(r1bestL1r);
      r1p->next = r1bestL1;
   }
   else
      r1bestL1r = r1bestL1;

   if (r1bestL2r)
   {
      r1p = ATL_Last@(RU)Node(r1bestL2r);
      r1p->next = r1bestL2;
   }
   else
      r1bestL2r = r1bestL2;
@skip   if (pre == 'd') FindCacheEdge(r1bestL2r, L1CacheElts);
/*
 * Join all together in combined context queue, and write out answer
 */
   r1b = ATL_@up@(ru)LinkContexts(r1bestOCr, r1bestL2r, r1bestL1r, r1bestL1b);
   NameAllKernels(pre, r1b);
   ResubGoodGccIn@up@(ru)Nodes(r1b);
   Write@up@(ru)SummFile(fout, r1b);
   KillAll@up@(ru)Nodes(r1b);
   return(0);
}

@ROUT mvthgen
   @define rt @mvt@
   @define ru @mv@
   @define su @1@
   @define s2 @@
@ROUT mvnhgen
   @define rt @mvn@
   @define ru @mv@
   @define su @1@
   @define s2 @@
@ROUT r1hgen
   @define rt @r1@
   @define ru @r1@
   @define su @1@
   @define s2 @@
@ROUT r2hgen
   @define rt @r2@
   @define ru @r1@
   @define su @2@
   @define s2 @2@
@ROUT r1hgen r2hgen mvthgen mvnhgen
@extract -b @(topd)/cw.inc lang=c -define cwdate 2009 -define cwdate 2010
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include "atlas_misc.h"
#include "atlas_@(ru)parse.h"
@ROUT mvthgen mvnhgen r1hgen `#include "atlas_@(ru)testtime.h"`
@ROUT r2hgen `#include "atlas_r2testtime.h"`
@skip @extract -b @(basd)/atlconf.base rout=asmconf.h
@skip @extract -b @(basd)/atlas-parse.base rout=r1read
@extract -b @(basd)/atlas-gen.base rout=GetMul
@extract -b @(basd)/atlas.base rout=Mylcm

@ROUT r1hgen r2hgen
void UnrollSYR@(su)
(
   FILE *fpout,         /* stream to print to */
   char *name,          /* name for macro */
   char pre,            /* precisition/type prefix */
   enum ATLAS_UPLO Uplo,   
   int  nu              /* unroll factor */
)
/*
 * For SYR and SYR2, generate a macro which does a small NUxNU 
 * triangular matrix so that GER kernel can be called
 * on rest of NU-wide panel.
 * Real precision unroll of SYR@(su)
 */
{
   int i, j;

   fprintf(fpout, "#define %s(A_, lda_, x_, y_) \\\n{ \\\n", name);
   fprintf(fpout, "   TYPE *aa=(A_); \\\n");
   fprintf(fpout, "   ATL_CINT lda0_ = 0");
   for (i=1; i < nu; i++)
      fprintf(fpout, ", lda%d_ = lda%d_+(lda_)", i, i-1);
   fprintf(fpout, "; \\\n   const TYPE x0_=*(x_)");
   for (i=1; i < nu; i++)
      fprintf(fpout, ", x%d_=(x_)[%d]", i, i);
   fprintf(fpout, "; \\\n   const TYPE y0_=*(y_)");
   for (i=1; i < nu; i++)
      fprintf(fpout, ", y%d_=(y_)[%d]", i, i);
   fprintf(fpout, "; \\\n");
   if (Uplo == AtlasUpper)
   {
      for (j=0; j < nu; j++)
         for (i=0; i <= j; i++)
@ROUT r2hgen
            fprintf(fpout, "   aa[lda%d_+%d] += x%d_*y%d_ + y%d_*x%d_; \\\n",
                    j, i, i, j, i, j);
@ROUT r1hgen
            fprintf(fpout, "   aa[lda%d_+%d] += x%d_*y%d_; \\\n",
                    j, i, i, j);
@ROUT r2hgen r1hgen
   }
   else
   {
      for (j=0; j < nu; j++)
         for (i=j; i < nu; i++)
@ROUT r2hgen
            fprintf(fpout, "   aa[lda%d_+%d] += x%d_*y%d_ + y%d_*x%d_; \\\n",
                    j, i, i, j, i, j);
@ROUT r1hgen
            fprintf(fpout, "   aa[lda%d_+%d] += x%d_*y%d_; \\\n",
                    j, i, i, j);
@ROUT r1hgen r2hgen
   }
   fprintf(fpout, "}\n");
}

void UnrollHER@(su)
(
   FILE *fpout,         /* stream to print to */
   char *name,          /* name for macro */
   char pre,            /* precisition/type prefix */
   enum ATLAS_UPLO Uplo,   
   int  nu              /* unroll factor */
)
/*
 * Complex type unroll of HER@(su)
 */
{
   int i, j;

@ROUT r2hgen
   fprintf(fpout, "#define %s(A_, lda_, x_, y_, xt_, yt_) \\\n{ \\\n", name);
@ROUT r1hgen
   fprintf(fpout, "#define %s(A_, lda_, x_, xt_) \\\n{ \\\n", name);
@ROUT r1hgen r2hgen
   fprintf(fpout, "   TYPE *aa=(A_); \\\n");
   fprintf(fpout, "   ATL_CINT lda0_ = 0");
   for (i=1; i < nu; i++)
      fprintf(fpout, ", lda%d_ = lda%d_+(lda_)+(lda_)", i, i-1);
   fprintf(fpout, "; \\\n   const TYPE x0r=*(x_), x0i=(x_)[1]");
   for (i=1; i < nu; i++)
      fprintf(fpout, ", x%dr=(x_)[%d], x%di=(x_)[%d]", i, 2*i, i, 2*i+1);
   fprintf(fpout, "; \\\n   const TYPE xt0r=*(xt_), xt0i=(xt_)[1]");
   for (i=1; i < nu; i++)
      fprintf(fpout, ", xt%dr=(xt_)[%d], xt%di=(xt_)[%d]", i, 2*i, i, 2*i+1);
@ROUT r2hgen
   fprintf(fpout, "; \\\n   const TYPE y0r=*(y_), y0i=(y_)[1]");
   for (i=1; i < nu; i++)
      fprintf(fpout, ", y%dr=(y_)[%d], y%di=(y_)[%d]", i, 2*i, i, 2*i+1);
   fprintf(fpout, "; \\\n   const TYPE yt0r=*(yt_), yt0i=(yt_)[1]");
   for (i=1; i < nu; i++)
      fprintf(fpout, ", yt%dr=(yt_)[%d], yt%di=(yt_)[%d]", i, 2*i, i, 2*i+1);
@ROUT r1hgen r2hgen
   fprintf(fpout, "; \\\n");
   if (Uplo == AtlasUpper)
   {
      for (j=0; j < nu; j++)
      {
         for (i=0; i < j; i++)
         {
@ROUT r2hgen
            fprintf(fpout, 
      "   aa[lda%d_+%d] += x%dr*yt%dr-x%di*yt%di + y%dr*xt%dr-y%di*xt%di; \\\n",
                    j, 2*i, i, j, i, j, i, j, i, j);
            fprintf(fpout, 
      "   aa[lda%d_+%d] += x%dr*yt%di+x%di*yt%dr + y%dr*xt%di+y%di*xt%dr; \\\n",
                    j, 2*i+1, i, j, i, j, i, j, i, j);
@ROUT r1hgen
            fprintf(fpout, "   aa[lda%d_+%d] += x%dr*xt%dr-x%di*xt%di; \\\n",
                    j, 2*i, i, j, i, j);
            fprintf(fpout, "   aa[lda%d_+%d] += x%dr*xt%di+x%di*xt%dr; \\\n",
                    j, 2*i+1, i, j, i, j, i, j, i, j);
@ROUT r1hgen r2hgen
         }
@ROUT r2hgen
         fprintf(fpout, 
      "   aa[lda%d_+%d] += x%dr*yt%dr-x%di*yt%di + y%dr*xt%dr-y%di*xt%di; \\\n",
                 j, 2*j, j, j, j, j, j, j, j, j);
@ROUT r1hgen
         fprintf(fpout, "   aa[lda%d_+%d] += x%dr*xt%dr-x%di*xt%di; \\\n",
                 j, 2*j, j, j, j, j);

@ROUT r1hgen r2hgen
         fprintf(fpout, "   aa[lda%d_+%d] = 0.0; \\\n", j, 2*j+1);
      }
   }
   else
   {
      for (j=0; j < nu; j++)
      {
@ROUT r2hgen
         fprintf(fpout, 
      "   aa[lda%d_+%d] += x%dr*yt%dr-x%di*yt%di + y%dr*xt%dr-y%di*xt%di; \\\n",
                 j, 2*j, j, j, j, j, j, j, j, j);
@ROUT r1hgen
         fprintf(fpout, "   aa[lda%d_+%d] += x%dr*xt%dr-x%di*xt%di; \\\n",
                 j, 2*j, j, j, j, j);
@ROUT r1hgen r2hgen
         fprintf(fpout, "   aa[lda%d_+%d] = 0.0; \\\n", j, 2*j+1);
         for (i=j+1; i < nu; i++)
         {
@ROUT r2hgen
            fprintf(fpout, 
      "   aa[lda%d_+%d] += x%dr*yt%dr-x%di*yt%di + y%dr*xt%dr-y%di*xt%di; \\\n",
                    j, 2*i, i, j, i, j, i, j, i, j);
            fprintf(fpout, 
      "   aa[lda%d_+%d] += x%dr*yt%di+x%di*yt%dr + y%dr*xt%di+y%di*xt%dr; \\\n",
                    j, 2*i+1, i, j, i, j, i, j, i, j);
@ROUT r1hgen
            fprintf(fpout, "   aa[lda%d_+%d] += x%dr*xt%dr-x%di*xt%di; \\\n",
                    j, 2*i, i, j, i, j);
            fprintf(fpout, "   aa[lda%d_+%d] += x%dr*xt%di+x%di*xt%dr; \\\n",
                    j, 2*i+1, i, j, i, j);
@ROUT r1hgen r2hgen
         }
      }
   }
   fprintf(fpout, "}\n");
}

@ROUT r1hgen r2hgen mvthgen mvnhgen
int FixMB(char pre, int mu, int mb)
/*
 * Makes sure MB is not a power of two, and that it won't mess up alignment
 * and that it is a multiple of mu
 */
{
   int MU;

/*
 * Find MU necessary to keep Cachelen-byte alignment & take LCM wt kernel's mu
 */
   if (pre == 's')
      MU = ATL_Cachelen/sizeof(float);
   else if (pre == 'c')
      MU = ATL_Cachelen/(2*sizeof(float));
   else if (pre == 'd')
      MU = ATL_Cachelen/sizeof(double);
   else  /* if (pre == 'z') */
      MU = ATL_Cachelen/(2*sizeof(double));
   MU = (MU) ? MU : 1;
   MU = Mylcm(mu, MU);
/*
 * If this is 0, then do not block!
 */
   return((mb/MU)*MU);
}
@beginskip
HERE HERE
@ROUT mvthgen
   @define rt @mvt@
   @define vn @Y@
@ROUT mvnhgen
   @define rt @mvn@
   @define vn @X@
@ROUT r1hgen
   @define rt @r1@
   @define vn @Y@
@ROUT r2hgen
   @define rt @r2@
   @define vn @Y@
@ROUT r1hgen r2hgen mvthgen mvnhgen
void GenKernPeelN
(
   ATL_@(ru)node_t *kp,   /* kernel that has passed all restrictions */
   ATL_@(ru)node_t *gp,   /* general kernel w/o any restrictions */
   char pre,              /* precision modifier */
   int beta,              /* 0: beta is 0, else beta is 1 */
   FILE *fpout,           /* output file */
   char *spc,             /* string of spaces, can move ptr for more/less */
   int size,              /* elt size */
)
/*
 * Kernel kp has passed all kp tests, and needs to be invoked with proper
 * N partitioning.  The N partitions are:
 *    Np : peel amount to achieve vector alignment
 *    NN : amount to call main kernel with
 *    Nr : any remainder forced by FNU
 */
{
   const int minN = FLAG_IS_SET(kp->flag, F@up@(ru)_FNU) ? 
                    Mmax(kp->minN, kp->NU) : kp->minN;
   int i;

   if (kp->alignY > size)   /* we have Np partition */
   {
      i = GetPower2(kp->alignY);
      if (i)
         fprintf(fpout, 
            "%s   ATL_CINT Np = (TYPE*)((((size_t)@(vn)) + %d)>>%d) - @(vn);\n",
                 spc, kp->alignY-1, i);
      else
         fprintf(fpout, 
            "%s   ATL_CINT Np = (TYPE*)((((size_t)@(vn)) + %d)/%d) - @(vn);\n",
                 spc, kp->alignY-1, kp->alignY);
       if (FLAG_IS_SET(kp->flag, F@up@(ru)_FNU))  /* all 3 partitions */
       {
          fprintf(fpout, "%s   ATL_CINT N1 = N - N0;\n", spc);
          i = GetPower2(kp->NU);
          if (i)
             fprintf(fpout, "%s   ATL_CINT NN = (N1>>%d)<<%d;\n", spc, i, i);
          else
             fprintf(fpout, "%s   ATL_CINT NN = (N1/%d)*%d;\n", 
                     spc, kp->NU, kp->NU);
          if (minN > 1)
          {
             fprintf(fpout, "%s   if (NN > %d)\n", spc, minN);
             spc -= 3;
          }
          fprintf(fpout, "%s   ATL_CINT Nr = N - N0 - NN\n", spc);

          fprintf(fpout, "%s   if (N0)\n", spc);
          fprintf(fpout, "%s      %s(M, N0, A, lda, X, Y);\n", spc, gp->kname);
          fprintf(fpout, 
                  "%s   %s(M, NN, A+N0*(lda SHIFT), lda, X, Y+(N0 SHIFT));\n", 
                  spc, kp->kname);
          fprintf(fpout, "%s   if (Nr)\n", spc);
          fprintf(fpout, 
     "%s      %s(M, NN, A+(N0+NN)*(lda SHIFT), lda, X, Y+((N0+NN) SHIFT));\n", 
                  spc, kp->kname);
          fprintf(fpout, "%s   return;\n");
          if (minN > 1)
          {
             spc += 3;
             fprintf(fpout, "%s   } /* end NN > minN check */\n", spc);
          }
       }
       else  /* N0 and NN are only partitions */
       {
          fprintf(fpout, "%s   ATL_CINT NN = N - N0;\n", spc);
          if (minN > 1)
          {
             fprintf(fpout, "%s   if (NN > %d)\n", spc, minN);
             spc -= 3;
          }
          fprintf(fpout, "%s   if (N0)\n", spc);
          fprintf(fpout, "%s      %s(M, N0, A, lda, X, Y);\n", spc, gp->kname);
          fprintf(fpout, 
                  "%s   %s(M, NN, A+N0*(lda SHIFT), lda, X, Y+(N0 SHIFT));\n", 
                  spc, kp->kname);
          fprintf(fpout, "%s   return;\n");
          if (minN > 1)
          {
             spc += 3;
             fprintf(fpout, "%s   } /* end NN > minN check */\n", spc);
          }
       }
    }
    else if (FLAG_IS_SET(kp->flag, F@up@(ru)_FNU)) /* NN & Nr only part */
    {
       i = GetPower2(kp->NU);
       if (i)
          fprintf(fpout, "%s   ATL_CINT NN = (N>>%d)<<%d, Nr = N-NN;\n", 
                  spc, i, i);
       else
          fprintf(fpout, "%s   ATL_CINT NN = (N/%d)*%d, Nr = N-NN;\n", 
                  spc, kp->NU, kp->NU);
       if (minN > 1)
       {
          fprintf(fpout, "%s   if (NN > %d)\n", spc, minN);
          spc -= 3;
       }
       fprintf(fpout, "%s   %s(M, NN, A, lda, X, Y);\n", spc, kp->kname);
       fprintf(fpout, "%s   if (Nr)\n", spc);
       fprintf(fpout, 
          "%s      %s(M, Nr, A+(lda SHIFT)*NN, lda, X, Y+(NN SHIFT));\n",
               spc, gp->kname);
       fprintf(fpout, "%s   return;\n");

       if (minN > 1)
       {
          spc += 3;
          fprintf(fpout, "%s   } /* end NN > minN check */\n", spc);
       }
    }
    else /* kernel can do all of N at once */
    {
       fprintf(fpout, "%s   %s(M, N, A, lda, X, Y);\n", spc, kp->kname);
       fprintf(fpout, "%s   return;\n");
    }
}

void GenKernFunc
(
   ATL_@(ru)node_t *kb,   /* standard combined kernel list */
   char pre,
   int beta,
   FILE *fpout
)
/*
 * Generates a kernel function that will work with any operand values,
 * assuming the standard kernel queue in kb (kernels sorted by performance).
 * Always generate a function if there are any restrictions, so that we
 * can use a function pointer.
 * This version assumes x is single ptr (i.e. not ptr to all aligned Xes),
 * and attempts to adapt to found alignments.
 * Possible restrictions and workarounds to them are:
 *  ALIGNX2A: could only be fixed if lda allows some cols to share alignment
 *  alignA : can be fixed by peeling M, if allowed by ALIGNX2A & alignX
 *  alignX : can be fixed by peeling M, if allowed by ALIGNX2A & alignA
 *  alignY : Can be fixed by peeling N, if allowed by ALIGNX2A
 *  ldamul : Can use kernel for part of computation by multiplying it by
 *           for instance, 2, and doing half the problem at once
 *  FNU: do last N%FNU by call to Nlt8
 *  minM, minN: can be fixed by not using kernel for too small of a problem
 */
{
   ATL_@(ru)node_t *kp, *gp;
   char *bet;
   char spcs[64], *spc;
   const int size = (pre == 'd' || pre == 'c') ? 8 :
                    (pre == 's') ? 4 : 16;
   int i, DOMPEEL=0, align, szsh;

   for (gp=kb; gp->next; gp = gp->next);  /* find general cleanup kernel */
   szsh = GetPower2(size);
   for (i=0; i < 63; i++)
      spcs[i] = ' ';
   spcs[63] = '\0';
   spc = spcs + 60;
   if (!beta)
      bet = (pre == 'd' || pre == 's') ? "ATL_rzero" : "zero";
   else
      bet = (pre == 'd' || pre == 's') ? "ATL_rone" : "one";
/* 
 * If there is only one kernel, and no size restrictions, just generate a macro
 */
   if (gp == kb)
   {
      fprintf(fpout, "#define ATL_GEN@(rt) %s\n", kb->rout);
      return;
   }

   fprintf(fpout, "#include \"atlas_misc.h\"\n\n");
   fprintf(fpout, 
   "void ATL_GEN@up@(rt)(ATL_CINT M0, ATL_CINT N0, const TYPE *A, ATL_CINT lda0,\n");
   fprintf(fpout, "               const TYPE *X, TYPE *Y);\n{\n");

   fprintf(fpout, "   ATL_INT M=M0, N=N0, lda=lda0;\n");
   fprintf(fpout, "   size_t t1, t2;\n");
   if (pre == 'c' || pre == 'z')
   {
      fprintf(fpout, "   const TYPE one[2] = {ATL_rone, ATL_rzero};\n");
      fprintf(fpout, "   const TYPE zero[2] = {ATL_rzero, ATL_rzero};\n");
   }
   else
   {
      fprintf(fpout, "   #define one ATL_rone\n");
      fprintf(fpout, "   #define zero ATL_rzero\n");
   }
   if (pre == 's' || pre == 'd')
   {
      fprintf(fpout, "   if (M < 16)\n   {\n");
      fprintf(fpout, 
         "      Mjoin(PATL,@(rt)k_Mlt16)(M, N, ATL_rone, A, lda,\n");
      fprintf(fpout, "                             X, 1, %s, Y, 1);\n", bet);
      fprintf(fpout, "      return;\n   }\n");
   }
   for (kp=kb; kp; kp = kp->next)
   {
      int minN = FLAG_IS_SET(kp->flag, F@up@(ru)_FNU) ? 
                 Mmax(kp->minN, kp->nu) : kp->minN;
      if (kp->minM > 0 && minN > 0)
         fprintf(fpout, "%sif (M > %d && N > %d)\n", spc, kp->minM, minN);
      else if (kp->minM > 0)
         fprintf(fpout, "%sif (M > %d)\n", spc, kp->minM);
      else if (minN > 0)
         fprintf(fpout, "%sif (N > %d)\n", spc, minN);
      if (kp->minM > 0 || minN > 0)
      {
         fprintf(fpout, "%s{\n", spc);
         spc -= 3;
      }
/*
 *    If ALIGNX2A is set, then we can peel M safely
 */
      if (FLAG_IS_SET(kp->flag, F@up@(ru)_ALIGNX2A))
      {
         fprintf(fpout, "%st1 = (size_t) A;\n%st2 = (size_t) X;\n", spc, spc);
         fprintf(fpout, 
            "%sif ((t1-ATL_MulByCachelen(ATL_DivByCachelen(t1))) == \n", spc)
         fprintf(fpout, 
            "%s    (t2 - ATL_MulByCachelen(ATL_DivByCachelen(t2))))\n", spc);
         fprintf(fpout, %s   {\n", spc);
         spc -= 3;
         kp->alignX = -1;
      }
/*
 *    If A & X must both be aligned, then any M peeling must fix them both!
 *    These ifs establish that no peeling is needed.
 */
      if (kp->alignA > size && kp->alignX > size)  /* must align both X & A */
         fprintf(fpout, "%sif (!(((size_t)A) & %d) && !(((size_t)X) & %d))\n",
                 spc, kp->alignA-1, kp->alignX-1);
      else if (kp->alignA > size) /* must align A only, M-peel always works */
         fprintf(fpout, "%sif (!(((size_t)A) & %d))\n", spc, kp->alignA-1);
      else if (kp->alignX > size) /* must align X only, M-peel always works */
         fprintf(fpout, "%sif (!(((size_t)X) & %d))\n", spc, kp->alignX-1);
      if (kp->alignA > size || kp->alignX > size)
      {
         fprintf(fpout, "%s{\n", spc);
         spc -= 3;
      }
      if (kp->ldamul > size)
      {
         if (GetPower2(kp->ldamul))
            fprintf(fpout, "%sif (!((((size_t)lda)<<%d) & %d))\n", 
                    spc, szsh, kp->ldamul-1);
         else
            fprintf(fpout, "%sif (!((((size_t)lda)<<%d) %% %d == 0))\n", 
                    spc, szsh, kp->ldamul);
         fprintf(fpout, "%s{\n", spc);
         spc -= 3;
      }
      GenKernPeelN(kp, gp, pre, beta, fpout, spc, size);
      HERE HERE
/*
 *    If ldamul prevents our using good kernel, can pump ldamul up and
 *    call kernel multiple times.  In order to do this, X's alignment
 *    must not be tied to A's.
 */
      if (kp->ldamul > size)
      {
         spc += 3;
         fprintf(fpout, "%s} /* end ldamul check */\n", spc);
         fprintf(fpout, "%selse /* ldamul check failed */\n%s{\n", spc, spc);
         fprintf(fpout, "%s   ATL_INT nNpart, i, n;\n", spc);
         fprintf(fpout, "%s   for (i=2; (1 << i) != ATL_sizeof; i++);\n", spc);
         fprintf(fpout, 
            "%s   for (t1=ATL_MulBySize(lda); !(t1 & (1<<(i+1))-1); i++);\n",
                 spc);
         fprintf(fpout, "%s   nNpart = %d >> i;\n", spc, kp->ldamul);
         fprintf(fpout, "%s   for (i=0; i < nNpart; i++)
         fprintf(fpout, "%s   n = N / nNpart;\n", spc);
         fprintf(fpout, "%s   if (n > 64)\n%s   {", spc, spc);
         fprintf(fpout, "%s      lda *= nNpart;\n", spc);
         fprintf(fpout, 
                 "%s      ATL_GEN@up@(rt)(M, n+N-n*nNpart, A, lda, X, Y);\n",
                  spc);
         fprintf(fpout, "%s      for (i=1; i < nNpart; i++)\n", spc);
         fprintf(fpout, 
         "%s   ATL_GEN@up@(rt)(M, n, A+i*(lda SHIFT), lda, X, Y+(i SHIFT));\n",
                 spc);
         fprintf(fpout, "%s      } /* end loop over nNpart */\n", spc);
      }
/*
 *    If we miss alignment of X and/or A, see if we can fix by M peel
 */
      if (kp->alignA > size || kp->alignX > size)
      {
         spc += 3;
         fprintf(fpout, "%s} /* end X/A align check */\n", spc);
         DOMPEEL=1;
         if (kp->alignA > size && kp->alignX > size)
         {
            if (kp->alignA >= kp->alignX)
            {
               align = kp->alignA;
               DOMPEEL = (kp->alignA % kp->alignX  == 0);
            }
            else
            {
               align = kp->alignX;
               DOMPEEL = (kp->alignX % kp->alignA  == 0);
            }
            if (DOMPEEL)
            {
            }
         }
         else if (kp->alignA > size)
            align = kp->alignA;
         else if (kp->alignX > size)
            align = kp->alignX;
      }

      if (kp->alignX > size)
      {
         fprintf(fpout, "%sif ((((size_t)X) & %d) == 0)\n", spc, kp->alignX-1);
         fprintf(fpout, %s   {\n", spc);
         spc -= 3;
      }

      if (FLAG_IS_SET(kp->flag, F@up@(ru)_ALIGNX2A))
      {
         spc += 3;
         fprintf(fpout, "%s} /* end ALIGNX2A check */\n", spc);
      }
      if (kp->alignX > size)
      {
         spc += 3;
         fprintf(fpout, "%s} /* end alignX check */\n", spc);
      }
      if (kp->minM > 0 || kp->minN > 0)
      {
         spc += 3;
         fprintf(fpout, "%s} /* end minM/N check */\n", spc);
      }
   }
   if (kb->ldamul > size)
   {
      fprintf(if (((lda*%d)/%d)*
   }
}
@endskip

@ROUT r2hgen
   @define rk @2@
@ROUT r1hgen
   @define rk @1@
@ROUT r1hgen r2hgen
void s@(rk)hgen
(
   ATL_r1node_t *r1B,   /* standard combined kernel list */
   int LVL,             /* 0:out-of-cache, 1: in-L1, 2: in-L2 */
   int L1Elts,          /* number of elements in L1 cache */
   char pre, 
   char *path           /* path to generate header files in */
)
{
   int Pre2Size(char pre);
   ATL_r1node_t *r1q, *r1ur;  /* queue of kernels to use, unrestricted kern */
   ATL_r1node_t *ocb, *i2b, *i1b, *ocl1b, *r1p, *r1t, *minp;
   FILE *fpout;
   int maxNU, NUL, NU0L, NUU, NU0U, NU, NU0, NU0s[2], NUs[2], imf, i, j;
   const int tsize = Pre2Size(pre);
   char *ln;
   char PRE = toupper(pre);

   r1B = CloneR1Queue(r1B);   /* get private copy for destruction */
   ATL_R1SplitContexts(r1B, &ocb, &i2b, &i1b, &ocl1b);
/*
 * Select kernels based on LVL
 */
   if (!LVL)
   {
      imf = 0;
      r1q = ocb;
      maxNU = 16;
   }
   else if (LVL == 2)
   {
      imf = 3;
      r1q = i2b;
      maxNU = 16;
   }
   else if (LVL == 1)
   {
      imf = 4;
      r1q = i1b;
      maxNU = 8;
   }
   if (ocb != r1q)
      KillAllR1Nodes(ocb);
   if (i2b != r1q)
      KillAllR1Nodes(i2b);
   if (i1b != r1q)
      KillAllR1Nodes(i1b);
   if (ocl1b != r1q)
      KillAllR1Nodes(ocl1b);
   r1ur = ATL_LastR1Node(r1q);  /* find unrestricted kernel */
/*
 * Find NUs that would work for all kernels
 */
   if (r1ur->alignY && tsize%r1ur->alignY)
      NU0U = Mylcm(r1ur->NU, Mylcm(r1ur->alignY, tsize)/tsize);
   else
      NU0U = r1ur->NU;
   NU0L = (r1ur->alignX) ? Mylcm(NU0U, Mylcm(r1ur->alignY, tsize)/tsize) : NU0U;
   NUU = NU0U;
   NUL = NU0L;
   for (r1p=r1q; r1p->next; r1p = r1p->next)
   {
      NUU = Mylcm(NUU, r1p->NU);
      NUL = Mylcm(NUL, r1p->NU);
   }
   NU0s[0] = NU0U;
   NU0s[1] = NU0L;
   NUs[0] = NUU;
   NUs[1] = NUL;

/*
 * If NU has grown large enough to significantly impact our ability to
 * use it to tune the kernel, eliminate restricted kernel that causes us
 * to use the largest unrolling until NU is small enough 
 */
   for (j=0; j < 2; j++)
   {
      NU0 = NU0s[j];
      NU = NUs[j];
      while (NU > maxNU && maxNU >= NU0)
      {
         NU = NU0;
         r1t = NULL;
         for (i=NU0, r1p=r1q; r1p->next; r1p = r1p->next)
         {
            i = Mylcm(i, r1p->NU);
            if (i > maxNU && r1p->next)  /* don't delete unrest kernel */
            {
               r1t = r1p;
               break;
            }
         }
         if (r1t)
            r1q = KillR1NodeFromQ(r1q, r1t);
         assert(r1q);
         NU = NU0;
         for (r1p=r1q; r1p->next; r1p = r1p->next)
            NU = Mylcm(NU, r1p->NU);
      }
/*
 *    See if we can allow NU to be a multiple of everybodies' alignment
 */
      if (NU < maxNU)
      {
         for (i=NU, r1p=r1q; r1p; r1p = r1p->next)
         {
            if (r1p->alignY && tsize%r1p->alignY)
               i = Mylcm(i, Mylcm(r1p->alignY, tsize)/tsize);
            if (j == 1)
            {
               if (r1p->alignX && tsize%r1p->alignX)
                  i = Mylcm(i, Mylcm(r1p->alignX, tsize)/tsize);
            }
            if (i > maxNU)
            {
               i = 0;
               break;
            }
         }
         NU = (i) ? i : NU;
      }
      NUs[j] = NU;
   }
   NUU = NUs[0];
   NUL = NUs[1];
   i = strlen(path) + 32;
   ln = malloc(i);
   assert(ln);

   if (LVL)
@ROUT r1hgen
      sprintf(ln, "%s/atlas_%csyr_L%d.h", path, pre, LVL);
   else
      sprintf(ln, "%s/atlas_%csyr.h", path, pre);
@ROUT r2hgen
      sprintf(ln, "%s/atlas_%c%s_L%d.h", path, pre, 
              (pre == 'c' || pre == 'z') ? "her2":"syr2", LVL);
   else
      sprintf(ln, "%s/atlas_%c%s.h", path, pre,
              (pre == 'c' || pre == 'z') ? "her2":"syr2");
@ROUT r1hgen r2hgen
   fpout = fopen(ln, "w");
   free(ln);
   fprintf(fpout, "/*\n * This file generated on line %d of %s\n */\n",
           __LINE__, __FILE__);
   if (LVL)
   {
      fprintf(fpout, 
      "#ifndef ATLAS_%cSYR@(rk)_L%d_H\n   #define ATLAS_%cSYR@(rk)_L%d_H\n\n",
              PRE, LVL, PRE, LVL);
      fprintf(fpout, "#include \"atlas_%cr@(rk)_L%d.h\"\n", pre, LVL);
   }
   else
   {
      fprintf(fpout, 
              "#ifndef ATLAS_%cSYR@(rk)_H\n   #define ATLAS_%cSYR@(rk)_H\n\n",
              PRE, PRE);
      fprintf(fpout, "#include \"atlas_%cr@(rk).h\"\n", pre);
   }

//   NU = (NU < 4) ? NU+NU : NU;
   fprintf(fpout, "\n#define ATL_s@(rk)U_NU %d\n", NUU);
   fprintf(fpout, "\n#define ATL_s@(rk)L_NU %d\n", NUL);
/*
 * Only out-of-cache needs blocking stuff; others always unblocked
 */
   if (!LVL) 
   {
      fprintf(fpout, "\n");
      if (!r1ur->CacheElts)
      {
         fprintf(fpout, "#define ATL_NOBLOCK_S@(rk) 1\n");
         fprintf(fpout, 
  "#define ATL_GetPartS@(rk)(A_, lda_, mb_, nb_) { (mb_) = 0; (nb_) = 0; }\n");
      }
      else if (NU == r1ur->NU)
         fprintf(fpout, "#define ATL_GetPartS@(rk) ATL_GetPartR@(rk)\n");
      else
      {
         i = r1ur->CacheElts;
@ROUT r1hgen `         i = (i-2*NU)/(2*(NU+1));`
@ROUT r2hgen `         i = (i-4*NU)/(2*(NU+1));`
         i = FixMB(pre, r1ur->MU, i);
         fprintf(fpout, 
  "#define ATL_GetPartS@(rk)(A_, lda_, mb_, nb_) { (mb_) = %d; (nb_) = %d; }\n",
                 i, i ? NU : 0);
      }
   }
/*
 * Find the smallest M that can be used with all kernels
 */
   for (i=r1q->minM, minp=r1p=r1q; r1p->next; r1p = r1p->next)
   {
      i = Mmax(r1p->minM, i);
      if (r1p->minM < minp->minM)
         minp = r1p;
   }
   fprintf(fpout, "#define ATL_MIN_RESTRICTED_M %d\n", i);
/*
 * ATL_URGERK is always the unrestricted kernel
 */
   fprintf(fpout, "#define ATL_URGERK %s\n", r1ur->kname);
    
/*
 * ATL_GENGERK will be a kernel that can be called with any operands
 */
@ROUT r2hgen
   if (r1ur->minM < 2 && r1ur->minN < 2)
      fprintf(fpout, "#define ATL_GENGERK %s\n", r1ur->kname);
   else
   {
      char *one, *pN;
      fprintf(fpout, 
         "static void ATL_GENGERK(ATL_CINT M, ATL_CINT N, const TYPE *X,\n");
      fprintf(fpout, 
      "                        const TYPE *Y, const TYPE *W, const TYPE *Z,\n");
      fprintf(fpout, 
         "                        TYPE *A, ATL_CINT lda)\n");
      fprintf(fpout, 
              "{\n   int nu, minM, minN, i, FNU, aX, aX2A, aY, aW, aZ;\n");
      fprintf(fpout, "   ATL_INT CEL;\n   ATL_r@(rk)kern_t gerk;\n");
      if (pre == 'd' || pre == 's')
      {
          one = "ATL_rone";
          pN = "n";
      }
      else 
      {
          fprintf(fpout, "   const TYPE one[2] = {ATL_rone, ATL_rzero};\n");
          one = "one";
          pN = "(n+n)";
      }
      fprintf(fpout, 
         "   gerk = ATL_GetR2Kern(M, N, A, lda, &i, &nu, &minM, &minN,\n");
      fprintf(fpout, 
         "                        &aX, &aX2A, &aY, &FNU, &CEL);\n");
      fprintf(fpout, "   if (aX2A)\n   {\n");
      fprintf(fpout, 
  "      aX = ((size_t)A) %% ATL_Cachelen == ((size_t)X) %% ATL_Cachelen;\n");
      fprintf(fpout, 
  "      aW = ((size_t)A) %% ATL_Cachelen == ((size_t)W) %% ATL_Cachelen;\n");
      fprintf(fpout, 
      "   }   else\n   {\n");
      fprintf(fpout, 
              "      aW = (aX) ? (((size_t)W)/aX)*aX == (size_t)W : 1;\n");
      fprintf(fpout, 
              "      aX = (aX) ? (((size_t)X)/aX)*aX == (size_t)X : 1;\n");
      fprintf(fpout, "   }\n");
      fprintf(fpout, "   aZ = (aY) ? (((size_t)Z)/aY)*aY == (size_t)Z : 1;\n");
      fprintf(fpout, "   aY = (aY) ? (((size_t)Y)/aY)*aY == (size_t)Y : 1;\n");
      fprintf(fpout, 
              "   if (M >= minM && N >= minN && aX && aY && aW && aZ)\n   {\n");
      fprintf(fpout, "      if (FNU)\n      {\n");
      fprintf(fpout, "          ATL_CINT n = (N/nu)*nu, nr=N-n;\n");
      fprintf(fpout, "          gerk(M, n, X, Y, W, Z, A, lda);\n");
      fprintf(fpout, "          if (nr)\n");
      fprintf(fpout, "             ATL_%cger2k_Nlt8(M, nr, %s, X, 1, Y+%s, 1, %s, W, 1, Z+%s, 1, A+%s*lda, lda);\n",
              pre, one, pN, one, pN, pN);
      fprintf(fpout, "      } /* end if (FNU) */\n");
      fprintf(fpout, "      else\n");
      fprintf(fpout, "         gerk(M, N, X, Y, W, Z, A, lda);\n");
      fprintf(fpout, "   } /* end if can call optimized kernel */\n");
      fprintf(fpout, "   else\n      ATL_%cger2k_Mlt16(M, N, %s, X, 1, Y, 1, %s, W, 1, Z, 1, A, lda);\n",
              pre, one, one);
      fprintf(fpout, "}\n");
   }
@ROUT r1hgen
   if (r1ur->minM < 2 && r1ur->minN < 2)
      fprintf(fpout, "#define ATL_GENGERK %s\n", r1ur->kname);
   else
   {
      char *one, *pN;
      fprintf(fpout, 
         "static void ATL_GENGERK(ATL_CINT M, ATL_CINT N, const TYPE *X,\n");
      fprintf(fpout, 
         "                        const TYPE *Y, TYPE *A, ATL_CINT lda)\n");
      fprintf(fpout, "{\n   int nu, minM, minN, i, FNU, aX, aX2A, aY;\n");
      fprintf(fpout, "   ATL_INT CEL;\n   ATL_r@(rk)kern_t gerk;\n");
      if (pre == 'd' || pre == 's')
      {
          one = "ATL_rone";
          pN = "n";
      }
      else 
      {
          fprintf(fpout, "   const TYPE one[2] = {ATL_rone, ATL_rzero};\n");
          one = "one";
          pN = "(n+n)";
      }
      fprintf(fpout, 
         "   gerk = ATL_GetR1Kern(M, N, A, lda, &i, &nu, &minM, &minN,\n");
      fprintf(fpout, 
         "                        &aX, &aX2A, &aY, &FNU, &CEL);\n");
      fprintf(fpout, "   if (aX2A)\n");
      fprintf(fpout, 
      "      aX = ((size_t)A) %% ATL_Cachelen == ((size_t)X) %% ATL_Cachelen;\n");
      fprintf(fpout, 
      "   else\n      aX = (aX) ? (((size_t)X)/aX)*aX == (size_t)X : 1;\n");
      fprintf(fpout, "   aY = (aY) ? (((size_t)Y)/aY)*aY == (size_t)Y : 1;\n");
      fprintf(fpout, "   if (M >= minM && N >= minN && aX && aY)\n   {\n");
      fprintf(fpout, "      if (FNU)\n      {\n");
      fprintf(fpout, "          ATL_CINT n = (N/nu)*nu, nr=N-n;\n");
      fprintf(fpout, "          gerk(M, n, X, Y, A, lda);\n");
      fprintf(fpout, "          if (nr)\n");
      fprintf(fpout, "             ATL_%cgerk_axpy(M, nr, %s, X, 1, Y+%s, 1, A+%s*lda, lda);\n",
              pre, one, pN, pN);
      fprintf(fpout, "      } /* end if (FNU) */\n");
      fprintf(fpout, "      else\n");
      fprintf(fpout, "         gerk(M, N, X, Y, A, lda);\n");
      fprintf(fpout, "   } /* end if can call optimized kernel */\n");
      fprintf(fpout, 
      "   else\n      ATL_%cgerk_Mlt16(M, N, %s, X, 1, Y, 1, A, lda);\n",
              pre, one);
      fprintf(fpout, "}\n");
   }
@ROUT r1hgen r2hgen

   fprintf(fpout, "\n");
   if (pre == 's' || pre == 'd')
   {
      UnrollSYR@(rk)(fpout, "ATL_SYR@(rk)U_nu", pre, AtlasUpper, NUU);
      UnrollSYR@(rk)(fpout, "ATL_SYR@(rk)L_nu", pre, AtlasLower, NUL);
   }
   else
   {
      UnrollHER@(rk)(fpout, "ATL_HER@(rk)U_nu", pre, AtlasUpper, NUU);
      UnrollHER@(rk)(fpout, "ATL_HER@(rk)L_nu", pre, AtlasLower, NUL);
   }
   KillAllR1Nodes(r1q);

   fprintf(fpout, "\n#endif\n");
   fclose(fpout);
}

@ROUT r2hgen
@beginskip
void s2hgen
(
   ATL_r1node_t *r1B,   /* standard combined kernel list */
   int L1Elts,          /* number of elements in L1 cache */
   char pre, 
   char *path           /* path to generate header files in */
)
/*
 * Generates atlas_<pre>syr2.h file, given r1B
 */
{
   char ln[1024];
   FILE *fpout;
   ATL_r1node_t *r1p, *r1IC, *r1OC, *r1ICr, *r1OCr;
   int CacheElts, MU, NU, i;
   char PRE = toupper(pre);
/*
 * Fill in standard names for these files
 */
   PutKernNameInStr(r1B);
/*
 * Default to blocking for L1
 */
   r1OCr = r1B->next->next->next->next->next->next;
   r1OC = r1OCr->next;
   r1ICr = r1B->next->next->next->next;
   r1IC = r1ICr->next;
   CacheElts = r1OC->CacheElts;
/*
 * If best out-of-cache (OC) kernels use no blocking or L2 blocking, we
 * need to check if L2-blocking will be faster for SYR2
 */
   r1p = r1B->next;
   if (r1p->CacheElts == 0 || r1p->CacheElts > L1Elts)
   {
      double mfL1, mfL2;
      mfL1 = (r1OCr->mflop[0] + r1IC->mflop[4])/2.0;
      mfL2 = (r1p->CacheElts) ? r1p->mflop[1] : r1p->mflop[2];
      mfL2 = (mfL2+r1B->next->next->next->mflop[3])/2.0;
      if (mfL2 >= 1.02*mfL1)
      {
         r1OCr = r1B;
         r1OC  = r1OCr->next;
         r1ICr = r1B->next->next;
         r1IC  = r1ICr->next;
         CacheElts = (r1OC->CacheElts) ? r1OC->CacheElts : r1IC->CacheElts;
      }
   }
   if (r1ICr->ID == r1IC->ID)
      r1ICr = NULL;
   if (r1OCr->ID == r1OC->ID)
      r1OCr = NULL;
   MU = Mylcm(r1OC->MU, r1IC->MU);
   if (r1ICr)
      MU = Mylcm(MU, r1ICr->MU);
   if (r1OCr)
      MU = Mylcm(MU, r1OCr->MU);
   NU = Mylcm(r1OC->NU, r1IC->NU);
   if (r1ICr)
      NU = Mylcm(NU, r1ICr->NU);
   if (r1OCr)
      NU = Mylcm(NU, r1OCr->NU);
   
   
   sprintf(ln, "%s/atlas_%csyr2.h", path, pre);
   fpout = fopen(ln, "w");
   assert(fpout);
   fprintf(fpout, "/*\n * This file generated on line %d of %s\n */\n",
           __LINE__, __FILE__);
   fprintf(fpout, 
           "#ifndef ATLAS_%cSYR2_H\n   #define ATLAS_%cSYR2_H\n\n", 
           PRE, PRE);

   fprintf(fpout, "#include \"atlas_%cr1kernels.h\"\n", pre);

   fprintf(fpout, "#define ATL_s2CacheElts %d\n", CacheElts);
   fprintf(fpout, "#define ATL_s2MU %d\n", MU);
   fprintf(fpout, "#define ATL_s2NU %d\n", NU);
   fprintf(fpout, "#define ATL_R1OC %s\n", r1OC->str);
   fprintf(fpout, "#define ATL_R1OCr %s\n", r1OCr ? r1OCr->str : r1OC->str);
   fprintf(fpout, "#define ATL_R1IC %s\n", r1IC->str);
   fprintf(fpout, "#define ATL_R1ICr %s\n", r1ICr ? r1ICr->str : r1IC->str);
   i = FLAG_IS_SET(r1OC->flag, R1F_ALIGNX2A);
   i |= FLAG_IS_SET(r1IC->flag, R1F_ALIGNX2A);
   if (r1OCr)
      i |= FLAG_IS_SET(r1OCr->flag, R1F_ALIGNX2A);
   if (r1ICr)
      i |= FLAG_IS_SET(r1ICr->flag, R1F_ALIGNX2A);
   if (i)
      fprintf(fpout, "#define ATL_s2ALIGNX2A 1\n");

   if (r1OCr)
   {
      fprintf(fpout, "#define ATL_s2USERESTRICTK_OC 1\n");
      fprintf(fpout, "#define ATL_s2UseRestrictK_OC(M_, N_, A_, lda_) \\\n");
      assert(r1OCr->ldamul > 1);  /* only allowed restriction right now! */
      if (r1OCr->ldamul > 1)
         fprintf(fpout, "   (%s == ATL_sizeof*(lda_))",
                 GetMul(r1OCr->ldamul, GetDiv(r1OCr->ldamul, 
                                              "ATL_sizeof*(lda_)")));
   }
   if (r1ICr)
   {
      fprintf(fpout, "#define ATL_s2USERESTRICTK_IC 1\n");
      fprintf(fpout, "#define ATL_s2UseRestrictK_IC(M_, N_, A_, lda_) \\\n");
      assert(r1ICr->ldamul > 1);  /* only allowed restriction right now! */
      if (r1ICr->ldamul > 1)
         fprintf(fpout, "   (%s == ATL_sizeof*(lda_))",
                 GetMul(r1ICr->ldamul, GetDiv(r1ICr->ldamul, 
                                              "ATL_sizeof*(lda_)")));
   }
   i = (CacheElts-4*NU)/(2*NU+2);
   i = FixMB(pre, MU, i);
   fprintf(fpout, "\n#define ATL_GetPartS2(A_, lda_, mb_, nb_) { (mb_) = %d; (nb_) = ATL_s2NU; }\n\n", i);
   if (pre == 's' || pre == 'd')
   {
      UnrollSYR2(fpout, "ATL_SYR2U_nu", pre, AtlasUpper, NU);
      UnrollSYR2(fpout, "ATL_SYR2L_nu", pre, AtlasLower, NU);
   }
   else
   {
      UnrollHER2(fpout, "ATL_HER2U_nu", pre, AtlasUpper, NU);
      UnrollHER2(fpout, "ATL_HER2L_nu", pre, AtlasLower, NU);
   }

   fprintf(fpout, "\n#endif\n");
   fclose(fpout);
}
@endskip
@ROUT mvthgen mvnhgen
void PrintPrototype(FILE *fpout, char pre, char *rout, char *type, char *styp)
{
   fprintf(fpout, 
      "void %s(ATL_CINT, ATL_CINT, const %s*, ATL_CINT, const %s*, %s*);\n", 
           rout, type, type, type);
}
@ROUT r1hgen r2hgen mvthgen mvnhgen

void GenKernFiles(char pre, char *path, ATL_@(ru)node_t *r1b)
/*
 * r1b is a list of rank-1 kernels that must be compiled (including those
 * needed to form SYR and SYR2).  This list should be unique (same kernel
 * not compiled twice).  r1b->kname will have the routine name to give the
 * kernel during compilation.
 */
{
   ATL_@(ru)node_t *r1p;
   char ln[2048];

   r1b = Clone@up@(ru)Queue(r1b);
   r1b = DelRepeated@up@(ru)Kernels(r1b);
@ROUT r1hgen mvthgen mvnhgen `   FillIn@up@(ru)ExtractGenStrings(pre, r1b);`
@ROUT r2hgen `   FillInR2ExtractGenStrings(pre, r1b);`
   for (r1p = r1b; r1p; r1p = r1p->next)
   {
      if (r1p->genstr)   /* generate kernel if necessary */
      {
         assert(!system(r1p->genstr));
         sprintf(ln, "cp EXTDIR/%s %s/%s.c\n", r1p->rout, path, r1p->kname);
      }
      else
         sprintf(ln, "cp @up@(rt)CASES/%s %s/%s.c\n", r1p->rout, path, r1p->kname);
      if (system(ln))
      {
         fprintf(stderr, "FAILED: %s\n", ln);
         exit(-1);
      }
   }
   KillAll@up@(ru)Nodes(r1b);
}

void EmitMakefile(char pre, char *path, ATL_@(ru)node_t *r1b)
/*
 * r1b is a list of kernels that must be compiled (including those
 * needed to form SYR and SYR2).  This list should be unique (same kernel
 * not compiled twice).  r1b->kname will have the routine name to give the
 * kernel during compilation.
 */
{
   ATL_@(ru)node_t *r1p, *r1k;
   char *kern, *outf, *typD;
   FILE *fpout;
   int i, ialias=0, USEGOODGCC=0;
   const char UPRE = (pre == 'z' || pre == 'd') ? 'D' : 'S';
   static char *aliased[16];

   r1b = Clone@up@(ru)Queue(r1b);  /* get our own copy of kernel Q we can mess up */
   r1b = DelRepeated@up@(ru)Kernels(r1b);  /* don't compile same kernel twice */
   assert(path);
@skip   kern = (pre == 'z' || pre == 'c') ? "geru" : "ger";
   if (pre == 'd')
      typD = "DREAL";
   else if (pre == 's')
      typD = "SREAL";
   else if (pre == 'c')
      typD = "SCPLX";
   else if (pre == 'z')
      typD = "DCPLX";
   else 
      assert(0);

   i = strlen(path);
   outf = malloc((i+16)*sizeof(char));
   assert(outf);
   strcpy(outf, path);
   strcpy(outf+i, "/Make_");   /* Make_<pre>@(rt) */
   outf[i+6] = pre;
@ROUT mvthgen mvnhgen
   outf[i+7] = 'm';
   outf[i+8] = 'v';
@ROUT mvnhgen
   outf[i+9] = 'n';
@ROUT mvthgen
   #ifdef ATL_Conj_
      outf[i+9] = 'c';
   #else
      outf[i+9] = 't';
   #endif
@ROUT mvthgen mvnhgen
   outf[i+10] = '\0';
@ROUT r1hgen r2hgen
   outf[i+7] = 'r';
   outf[i+8] = '@(su)';
   outf[i+9] = '\0';
@ROUT r1hgen r2hgen mvthgen mvnhgen
   fpout = fopen(outf, "w");
   assert(fpout);

   fprintf(fpout, "#\n#  This file generated at line %d of %s\n#\n",
           __LINE__, __FILE__);
   fprintf(fpout, "include Make.inc\n\n");
   fprintf(fpout, "@up@(rt)CC = $(%cKC)\n@up@(rt)FLAGS = $(CDEFS) $(%cKCFLAGS)",
            UPRE, UPRE);
   fprintf(fpout, " -D%s\n\n", typD);
   fprintf(fpout, "obj =");
   for (r1p=r1b; r1p; r1p = r1p->next)
@ROUT mvthgen mvnhgen
      fprintf(fpout, " %s.o %s_b0.o", r1p->kname, r1p->kname);
@ROUT r1hgen r2hgen
      fprintf(fpout, " %s.o", r1p->kname);
@ROUT r1hgen r2hgen mvthgen mvnhgen
   fprintf(fpout, "\n");

   fprintf(fpout, "lib : %clib\n%clib : %c@(rt)k.grd\n", pre, pre, pre);
   fprintf(fpout, "%c@(rt)k.grd : $(obj)\n", pre);
   fprintf(fpout, "\t$(ARCHIVER) $(ARFLAGS) $(ATLASlib) $(obj)\n");
   fprintf(fpout, "\t$(RANLIB) $(ATLASlib)\n");
   fprintf(fpout, "\ttouch %c@(rt)k.grd\n", pre);

   fprintf(fpout, "%cclean : clean\n", pre);
   fprintf(fpout, "clean :\n\t- rm -f $(obj) %c@(rt)k.grd\n\n", pre);

   fprintf(fpout, "%ckilllib : killlib\n", pre);
   fprintf(fpout, "killlib : \n");
   fprintf(fpout, "\t- $(ARCHIVER) d $(ATLASlib) $(obj)\n");
   fprintf(fpout, "\t$(RANLIB) $(ATLASlib)\n");
   fprintf(fpout, "killall : killlib clean\n");
   fprintf(fpout, "\t rm -f");
   for (r1p=r1b; r1p; r1p = r1p->next)
      fprintf(fpout, " %s.c", r1p->kname);
   fprintf(fpout, "\n\n");
/*
 * Spit out build command for all surviving kernels
 */
   for (r1p=r1b; r1p; r1p = r1p->next)
   {
      fprintf(fpout, "%s.o : %s.c\n", r1p->kname, r1p->kname);
      if (r1p->comp)
      {
         if (r1p->comp[0] == 'g' && r1p->comp[1] == 'c' && 
             r1p->comp[2] == 'c' && r1p->comp[3] == '\0')
         {
            USEGOODGCC = 1;
            fprintf(fpout, "\t $(GOODGCC)");
         }
         else
            fprintf(fpout, "\t %s", r1p->comp);
      }
      else
         fprintf(fpout, "\t $(@up@(rt)CC)");
@ROUT mvthgen mvnhgen
      fprintf(fpout, " -o %s.o -c -DATL_UGEMV=%s", r1p->kname, r1p->kname);
@ROUT r1hgen r2hgen
      fprintf(fpout, " -o %s.o -c -DATL_UGER@(s2)K=%s", r1p->kname, r1p->kname);
@ROUT r1hgen r2hgen mvthgen mvnhgen
      if (r1p->cflags)
      {
         if (r1p->comp)
         {
            fprintf(fpout, " %s -D%s $(CDEFS)", r1p->cflags, typD);
            #ifdef ATL_DYLIBS
               if (strstr(r1p->comp, "gcc") && !strstr(r1p->cflags, "-fPIC"))
                  fprintf(fpout, " -fPIC");
            #endif
         }
         else /* using default compiler, start wt default flags */
            fprintf(fpout, " $(@up@(rt)FLAGS) -D%s %s", typD, r1p->cflags);
      }
      else
         fprintf(fpout, " $(@up@(rt)FLAGS)");
      fprintf(fpout, " %s.c\n", r1p->kname);
@ROUT mvthgen mvnhgen
      USEGOODGCC = 0;
      fprintf(fpout, "%s_b0.o : %s.c\n", r1p->kname, r1p->kname);
      if (r1p->comp)
      {
         if (r1p->comp[0] == 'g' && r1p->comp[1] == 'c' && 
             r1p->comp[2] == 'c' && r1p->comp[3] == '\0')
         {
            USEGOODGCC = 1;
            fprintf(fpout, "\t $(GOODGCC)");
         }
         else
            fprintf(fpout, "\t %s", r1p->comp);
      }
      else
         fprintf(fpout, "\t $(@up@(rt)CC)");
      fprintf(fpout, " -o %s_b0.o -c -DATL_UGEMV=%s_b0 -DBETA0", 
              r1p->kname, r1p->kname);
      if (r1p->cflags)
      {
         if (r1p->comp)
         {
            fprintf(fpout, " %s -D%s $(CDEFS)", r1p->cflags, typD);
            #ifdef ATL_DYLIBS
               if (strstr(r1p->comp, "gcc") && !strstr(r1p->cflags, "-fPIC"))
                  fprintf(fpout, " -fPIC");
            #endif
         }
         else /* using default compiler, start wt default flags */
            fprintf(fpout, " $(@up@(rt)FLAGS) -D%s %s", typD, r1p->cflags);
      }
      else
         fprintf(fpout, " $(@up@(rt)FLAGS)");
      fprintf(fpout, " %s.c\n", r1p->kname);
@ROUT r1hgen r2hgen mvthgen mvnhgen
   }
   KillAll@up@(ru)Nodes(r1b);  /* done wt our copy of these queues */
   free(outf);
}

void @(rt)khgen(char pre, char *path, ATL_@(ru)node_t *r1b)
{
   char *ln;
   int i;
   FILE *fpout;
   ATL_@(ru)node_t *r1p;
   char *styp, *type = (pre == 'd' || pre == 'z') ? "double" : "float";
   char PRE;
   void PrintPrototypes(char pre, FILE *fpout, ATL_@(ru)node_t *kb);
   
   PRE = toupper(pre);
   if (pre == 'd')
      styp = "double";
   else if (pre == 's')
      styp = "float";
   else if (pre == 'c')
      styp = "float*";
   else
      styp = "double*";

   i = strlen(path);
   ln = malloc(i+32*sizeof(char));
   sprintf(ln, "%s/atlas_%c@(rt)kernels.h", path, pre);

   fpout = fopen(ln, "w");
   assert(fpout);
   fprintf(fpout, "/*\n * This file generated on line %d of %s\n */\n",
           __LINE__, __FILE__);
   fprintf(fpout, 
           "#ifndef ATLAS_%c@up@(rt)KERNELS_H\n   #define ATLAS_%c@up@(rt)KERNELS_H\n\n", 
           PRE, PRE);

   PrintPrototypes(pre, fpout, r1b);
   fprintf(fpout, "\n#endif /* end guard around atlas_%c@(rt)kernels.h */\n", pre);

   fclose(fpout);
   free(ln);
}

char *Pre2Type(char pre)
{
   return((pre == 'c' || pre == 's') ? "float" : "double");
}

int Pre2SizeMin(char pre)
{
   return((pre == 'c' || pre == 's') ? 4 : 8);
}

int Pre2Size(char pre)
{
   if (pre == 'c' || pre == 'd')
      return(8);
   return(pre == 'z' ? 16 : 4);
}

char *Pre2ScalarType(char pre)
{
   char *sp;
   if (pre == 'c')
      sp = "float *";
   else if (pre == 'z')
      sp = "double *";
   else if (pre == 's')
      sp = "float";
   else
      sp = "double";
   return(sp);
}

void GenGetKern(char pre, ATL_@(ru)node_t *kb, FILE *fpout)
{
   char *type, *styp;
   ATL_@(ru)node_t *kp;
   int i, minsize;
   char spcs[128], *spc = spcs+127;

   type = Pre2Type(pre);
   styp = Pre2ScalarType(pre);
   minsize = Pre2SizeMin(pre);
   for (i=0; i < 127; i++)
      spcs[i] = ' ';
   spcs[127] = '\0';

@ROUT r2hgen
   fprintf(fpout, "static ATL_@(rt)kern_t ATL_Get@up@(rt)Kern\n");
@ROUT r1hgen mvthgen mvnhgen
   fprintf(fpout, "static ATL_@(ru)kern_t ATL_Get@up@(rt)Kern\n");
@ROUT r1hgen r2hgen mvthgen mvnhgen
   fprintf(fpout, "   (ATL_CINT M, ATL_CINT N, const void *A, ATL_CINT lda,\n");
@ROUT mvthgen `   fprintf(fpout, "    ATL_@(ru)kern_t *mvk_b0, \n");`
@ROUT mvnhgen `   fprintf(fpout, "    ATL_@(ru)kern_t *mvk_b0, int *DOTBASED,\n");`
   fprintf(fpout, 
 "    int *mu, int *nu, int *minM, int *minN, int *alignX, int *ALIGNX2A,\n");
   fprintf(fpout, 
   "    int *alignY, int *FNU, ATL_INT *CacheElts) \n{\n");

   spc -= 3;
   for (kp=kb; kp; kp = kp->next)
   {
      if (kp->rankR)  /* if its restricted, will need to see if we can use */
      {
         if (kp->alignA)
         {
            fprintf(fpout, "%sif (%s == (size_t)(A))\n%s{\n", spc, 
                    GetMul(kp->alignA, GetDiv(kp->alignA, "((size_t)(A))")), 
                    spc);
            spc -= 3;
         }
         if (kp->ldamul > 1)
         {
            fprintf(fpout, "%sif (%s == ATL_MulBySize(lda))\n%s{\n", spc, 
                    GetMul(kp->ldamul,GetDiv(kp->ldamul, "ATL_MulBySize(lda)")),
                    spc);
            spc -= 3;
         }
         if (kp->minN > 1)
         {
            fprintf(fpout, "%sif (N >= %d)\n%s{\n", spc, kp->minN, spc);
            spc -= 3;
         }
         if (kp->minM > 1)
         {
            fprintf(fpout, "%sif (M >= %d)\n%s{\n", spc, kp->minM, spc);
            spc -= 3;
         }
      }
      fprintf(fpout, "%s*minM = %d;   *minN = %d;\n", spc, kp->minM, kp->minN);
      fprintf(fpout, "%s*mu = %d;     *nu = %d;\n", spc, kp->MU, kp->NU);
      fprintf(fpout, "%s*alignX = %d;  *alignY = %d;\n", spc,
              kp->alignX > 1 ? kp->alignX : minsize,
              kp->alignY > 1 ? kp->alignY : minsize);
      fprintf(fpout, "%s*ALIGNX2A = %d;\n", spc, 
              FLAG_IS_SET(kp->flag, @up@(ru)F_ALIGNX2A));
      fprintf(fpout, "%s*FNU = %d;\n", spc, FLAG_IS_SET(kp->flag, @up@(ru)F_FNU));
      fprintf(fpout, "%s*CacheElts = %d;\n", spc, kp->CacheElts);
@ROUT mvthgen mvnhgen  
      fprintf(fpout, "%s*mvk_b0 = %s_b0;\n", spc, kp->kname);
@ROUT mvnhgen
      fprintf(fpout, "%s*DOTBASED = %d;\n", spc,
              FLAG_IS_SET(kp->flag, MVF_AXPYBASED) ? 0 : kp->ntlb);
@ROUT r1hgen r2hgen mvthgen mvnhgen
      fprintf(fpout, "%sreturn(%s);\n", spc, kp->kname);
      if (kp->rankR)  /* if its restricted, end any ifs */
      {
         if (kp->minM > 1)
         {
           spc += 3;
           fprintf(fpout, "%s} /* end if on minimal N guard */\n", spc);
         }
         if (kp->minN > 1)
         {
           spc += 3;
           fprintf(fpout, "%s} /* end if on minimal M guard */\n", spc);
         }
         if (kp->ldamul > 1)
         {
           spc += 3;
           fprintf(fpout,"%s} /* end if on lda multiple restriction */\n", spc);
         }
         if (kp->alignA)
         {
           spc += 3;
           fprintf(fpout, "%s} /* end if on align of A */\n", spc);
         }
      }
   }
   fprintf(fpout, "}\n");
}

void PrintPrototypes(char pre, FILE *fpout, ATL_@(ru)node_t *kb)
{
   ATL_@(ru)node_t *kp;
   char *type;

   type = Pre2Type(pre);
   for (kp=kb; kp; kp = kp->next)
   {
@ROUT mvthgen mvnhgen 
      fprintf(fpout, 
         "void %s(ATL_CINT, ATL_CINT, const %s*, ATL_CINT, const %s*, %s*);\n", 
              kp->kname, type, type, type);
      fprintf(fpout, 
      "void %s_b0(ATL_CINT, ATL_CINT, const %s*, ATL_CINT, const %s*, %s*);\n", 
              kp->kname, type, type, type);
@ROUT r1hgen r2hgen
      fprintf(fpout, "void %s\n", kp->kname);
@ROUT r1hgen
      fprintf(fpout, 
              "   (ATL_CINT, ATL_CINT, const %s*, const %s*, %s*, ATL_CINT);\n",
              type, type, type);
@ROUT r2hgen
      fprintf(fpout, 
         "   (ATL_CINT, ATL_CINT, const %s*, const %s*, const %s*,\n",
               type, type, type);
     fprintf(fpout, "    const %s*, %s*, ATL_CINT);\n", type, type);
@ROUT r1hgen r2hgen mvthgen mvnhgen 
   }
   fprintf(fpout, "\n");
}

void @(rt)hgen(char pre, char *path, int LVL, ATL_@(ru)node_t *kb)
{
   ATL_@(ru)node_t *kp, *kur;
   FILE *fpout;
   char PRE = toupper(pre);
   char *styp, *sp, *type;
   char gerk[32];
   int mb, nb, TIMECASE=0;
   int irest=12, iconj=8;
   int alignX=0, alignY=0;

   assert(kb);
   if (LVL < 0)
   {
      TIMECASE = 1;
      LVL = 0;
   }
   for (kur=kb; kur->next; kur = kur->next);  /* unrestricted kernel */
/*
 * Name the kernel according to cache block level and data type
 */
   assert(LVL >= 0 && LVL <= 9);
   sp = malloc(strlen(path) + 18);
   assert(sp);
   if (!LVL)
      sprintf(sp, "%s/atlas_%c@(rt).h", path, pre);
   else
      sprintf(sp, "%s/atlas_%c@(rt)_L%d.h", path, pre, LVL);
   fpout = fopen(sp, "w");
   free(sp);
   type = Pre2Type(pre);
   styp = Pre2ScalarType(pre);

   fprintf(fpout, "#ifndef ATLAS_%c@up@(rt)_L%d_H\n#define ATLAS_%c@up@(rt)_L%d_H\n\n", 
           PRE, LVL, PRE, LVL);

   fprintf(fpout, "#include \"atlas_type.h\"\n\n");
@ROUT r1hgen
   fprintf(fpout, "typedef void (*ATL_r1kern_t)\n");
   fprintf(fpout, 
      "   (ATL_CINT, ATL_CINT, const %s*, const %s*, %s*, ATL_CINT);\n",
           type, type, type);
@ROUT r2hgen
   fprintf(fpout, "typedef void (*ATL_r2kern_t)\n");
   fprintf(fpout, 
      "   (ATL_CINT, ATL_CINT, const %s*, const %s*, const %s*,\n",
           type, type, type);
   fprintf(fpout, "    const %s*, %s*, ATL_CINT);\n", type, type);
@ROUT mvthgen mvnhgen 
   fprintf(fpout, "#ifndef ATL_MVKERN_DEF\n");
   fprintf(fpout, "   #define ATL_MVKERN_DEF\n");
   fprintf(fpout, "   typedef void (*ATL_mvkern_t)\n");
   fprintf(fpout, 
      "      (ATL_CINT, ATL_CINT, const %s*, ATL_CINT, const %s*, %s*);\n\n",
           type, type, type);
   fprintf(fpout, "#endif\n");
@ROUT r1hgen r2hgen mvthgen mvnhgen

   if (TIMECASE)
@ROUT r1hgen  `      kur->kname = DupString("ATL_UGERK");`
@ROUT r2hgen  `      kur->kname = DupString("ATL_UGER2K");`
@ROUT mvthgen `      kur->kname = DupString("ATL_UGEMVTK");`
@ROUT mvnhgen `      kur->kname = DupString("ATL_UGEMVNK");`
   PrintPrototypes(pre, fpout, kb);
   GenGetKern(pre, kb, fpout);
@ROUT mvnhgen
   if (!FLAG_IS_SET(kur->flag, MVF_AXPYBASED))
   {
      nb = (kur->ntlb >= 0) ? kur->ntlb : 0;
      nb = (nb > kur->MU) ?  nb = (nb/kur->MU)*kur->MU : kur->MU;
      mb = 0;
   }
   else
@ROUT r1hgen r2hgen mvthgen mvnhgen
   if (kur->CacheElts)
   {
@ROUT r2hgen `      mb = (kur->CacheElts - 4*kur->NU) / (2*(kur->NU+1));`
@ROUT mvnhgen mvthgen r1hgen `      mb = (kur->CacheElts - 2*kur->NU) / (2*(kur->NU+1));`
      mb = (mb > kur->MU) ? (mb/kur->MU)*kur->MU : 0;
      nb = kur->NU;
   }
   else
      mb = nb = 0;
   fprintf(fpout, 
@ROUT r1hgen r2hgen
"\n#define ATL_GetPart@up@(rt)(A_, lda_, mb_, nb_) { (mb_) = %d; (nb_) = %d; }\n",
@ROUT mvthgen mvnhgen
"\n#define ATL_GetPart@up@(rt)(A_, lda_, mb_, nb_) { *(mb_) = %d; *(nb_) = %d; }\n",
@ROUT r1hgen r2hgen mvthgen mvnhgen
           mb, nb);

   fprintf(fpout, 
           "\n#endif  /* end protection around header file contents */\n");
   fclose(fpout);
   
}

void PrintUsage(char *name, int ierr, char *flag)
{
   if (ierr > 0)
      fprintf(stderr, "Bad argument #%d: '%s'\n",
              ierr, flag ? flag : "Not enough arguments");
   else if (ierr < 0)
      fprintf(stderr, "ERROR: %s\n", flag);
   fprintf(stderr, "USAGE: %s [flags]:\n", name);
   fprintf(stderr, "   -p [s,d,c,z]: set type/precision prefix \n");
   fprintf(stderr, "   -d <dir> : output files using path <dir>\n");
   fprintf(stderr, "   -F <file> : read kernel file & gen headers\n");
   fprintf(stderr, "    The following flags can be used if -F is not:\n");
   fprintf(stderr, "      -l <l1mul> : use l1mul*L1CacheSize for blocking\n");
   fprintf(stderr, "      -m <mu> : mu rows unrolled for matrix access\n");
   fprintf(stderr, "      -n <nu> : nu cols unrolled for matrix access\n");
   fprintf(stderr, "      -f <iflag> : set the flag bitfield to iflag\n");
@ROUT mvnhgen
   fprintf(stderr, 
           "      -t <ntlb> : # of cols dot-based gemvN should traverse\n");
@ROUT r1hgen r2hgen mvthgen mvnhgen
   exit(ierr ? ierr : -1);
}

@ROUT mvnhgen
void GetFlags(int nargs, char **args, char *PRE, char **FNAM, char **DIR,
              int *MU, int *NU, int *DOTBASED, int *L1MUL, int *IFLAG)
@ROUT r1hgen r2hgen mvthgen
void GetFlags(int nargs, char **args, char *PRE, char **FNAM, char **DIR,
              int *MU, int *NU, int *L1MUL, int *IFLAG)
@ROUT r1hgen r2hgen mvthgen mvnhgen
{
   int i, k;
   char pre='d';

   *DIR = "./";
   *IFLAG = *MU = *NU = *L1MUL = 0;
   *FNAM = NULL;
   for (i=1; i < nargs; i++)
   {
      if (args[i][0] != '-')
         PrintUsage(args[0], i, args[i]);
      switch(args[i][1])
      {
      case 'm':
         if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
         *MU = atoi(args[i]);
         break;
      case 'n':
         if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
         *NU = atoi(args[i]);
         break;
      case 'l':
         if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
         *L1MUL = atoi(args[i]);
         break;
@ROUT mvnhgen
      case 't':
         if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
         *DOTBASED = atoi(args[i]);
         break;
@ROUT r1hgen r2hgen mvthgen mvnhgen
      case 'f':
         if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
         *IFLAG = atoi(args[i]);
         break;
      case 'd':
         if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
         *DIR = args[i];
         break;
      case 'p':
        if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
        pre = tolower(args[i][0]);
        assert(pre == 's' || pre == 'd' || pre == 'z' || pre == 'c');
        break;
      case 'F':
        if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
        *FNAM = args[i];
        break;
      default:
         PrintUsage(args[0], i, args[i]);
      }
   }
   *PRE = pre;
   if (*FNAM == NULL && (*MU == 0 || *NU == 0))
   {
      *FNAM = malloc(16*sizeof(char));
      sprintf(*FNAM, "res/%cR@(su)K.sum", pre);
   }
}

int main(int nargs, char **args)
{
   ATL_@(ru)node_t *bases[4];
   char *fnam, *path;
   ATL_@(ru)node_t *r1b, *r1p, *r1B;
   int i, mu, nu, l1mul, iflag, L1Elts, dotbased=0;
   char pre;

@ROUT mvnhgen
   GetFlags(nargs, args, &pre, &fnam, &path, &mu, &nu, &dotbased, 
            &l1mul, &iflag);
@ROUT r1hgen r2hgen mvthgen
   GetFlags(nargs, args, &pre, &fnam, &path, &mu, &nu, &l1mul, &iflag);
@ROUT r1hgen r2hgen mvthgen mvnhgen
   
/*
 * If we just want simple tuning header, no need to read file for details
 */
   if (!fnam)
   {
      r1b = Get@up@(ru)Node();
      r1b->next = NULL;
      r1b->minM = r1b->MU = mu;
      r1b->minN = r1b->NU = nu;
      r1b->flag = iflag;

@ROUT mvnhgen 
      if (dotbased)
      {
         r1b->ntlb = dotbased;
         r1b->flag &= ~(MVF_AXPYBASED);
      }
      else
         r1b->flag |= MVF_AXPYBASED;
@ROUT r1hgen r2hgen mvthgen mvnhgen
      r1b->CacheElts = (l1mul/100.0) * GetL1CacheElts(pre);
      @(rt)hgen(pre, path, -1, r1b);
      exit(0);
   }
/*
 * Otherwise, we should be doing a full-blown install; read in summary file
 */
   r1b = Read@up@(ru)File(fnam);
   SetAll@up@(ru)TypeFlags(pre, r1b);
/*
 * Generate prototype file for all routines
 */
   @(rt)khgen(pre, path, r1b);
/*
 * For each cache level, generate a header file which provides the function
 * returning the best kernel and its parameters
 */
   ATL_@up@(ru)SplitContexts(r1b, bases, bases+1, bases+2, bases+3);
   @(rt)hgen(pre, path, 0, bases[0]);
   @(rt)hgen(pre, path, 2, bases[1]);
   @(rt)hgen(pre, path, 1, bases[2]);
@skip   for (i=0; i < 3; i++)
@skip      @(rt)hgen(pre, path, i, bases[i]);
   r1b = ATL_@up@(ru)LinkContexts(bases[0], bases[1], bases[2], bases[3]);
/*
 * Generate Makefiles to compile all GER kernels (including those used by
 * SYR and SYR2).  These Makefiles & kernels will wind up in 
 *   BLDdir/src/blas/ger/
 */
   EmitMakefile(pre, path, r1b);
/*
 * Get required .c kernel files
 */
   GenKernFiles(pre, path, r1b);
@ROUT r1hgen r2hgen
/*
 * Generate header files for SYR@(rk) and HER@(rk)
 */
   L1Elts = GetL1CacheElts(pre);
   for(i=0; i < 3; i++)
      s@(rk)hgen(r1b, i, L1Elts, pre, path);
@ROUT r1hgen r2hgen mvthgen mvnhgen
   KillAll@up@(ru)Nodes(r1b);
   return(0);
}
@ROUT mvksearch
@extract -b @(basd)/atlas-parse.base rout=mvread
@ROUT smvcases.idx dmvcases.idx cmvcases.idx zmvcases.idx
#
# In this file, any line beginning with a '#' is ignored, but the # must be in
# column 0.  All multiple whitespace is reduced to one space (i.e. used only
# to distinguish where words begin/end).  Lines may be extended by putting '\'
# as the *last* character of line.
#
# The file has the following format:
# ROUT='routine name' AUTH='author names' COMP='compiler name' FLAGS='flags'
# ID=<id> NU=<nu> MU=<mu> minN=<#> minM=<#> alignX=<#> alignY=<#> alignA=<#>,
# TA='[t,n,c]' TB='[t,n,c]' SSE=[0,1,2,3] X87=[0,1] 
# LDTOP=[0,1] ALLALIGNXY=[0,1] AXPYBASED=[0,1] GEMMBASED=[0,1] CONJDEF=[0,1]
# ASM=[asmlist], eg., asmlist is "GAS_x8664,GAS_x8632" or "GAS_SPARC"
# ASM defaults to no assembly dialect required.
# If NU/MU is negative, then the routine can only handle multiples of NU/MU.
#
# Assuming N is the length of X, and M is the length of Y, all routines
# are assumed to handle any runtime value of M >= minN, N >= minM.
# They must respect the compile-time macros BETA0, BETA1, & BETAX.
# Some less-obvious keywords:
# LDTOP     : set to 1 if load Y at top of MV loop (more error)
# CONJDEF   : Defining Conj_ will cause A to be conjugated before use
#             if 0, then can only be used for TA setting
# ALLALIGNXY: Create k copies of X and Y, where k is the number of times
#             the native alignment goes into the required alignment.  So,
#             if ALIGNX=16, and we are doing single precision, X will be
#             passed as float *X[4], and X[0] will be 16-byte aligned,
#             X[1]: 4-byte aligned, X[2]: 8-byte aligned, X[3]: 12 byte aligned
#             if ALIGN[X/Y] == native length, then this flag has no effect on
#             that vector.
# AXPYBASED : Routine employs the outer-product matvec (mainly for NoTrans)
# GEMMBASED : Kernel calls GEMM to do matvec
# PFTUNEx   : Kernel uses pref_x(mem) macro for each op=x (A,y,x).  prefetch
#             inst can be varied wt this macro, as can fetch distance.
#
@ROUT ATL_gemvN_tM
#include "atlas_mvN_Mdegen.h"

void Mjoin(PATL,gemvN_tM)
   (ATL_CINT M, ATL_CINT N, const SCALAR alpha, const TYPE *A, ATL_CINT lda, 
    const TYPE *X, ATL_CINT incX, const SCALAR beta, TYPE *Y, ATL_CINT incY)
/* 
 * This routine is specialized for very small M dimension GEMV.
 */
{
   ATL_assert(M <= 16);
}
@ROUT ATL_gemv_new
void Mjoin(PATL,gemv)
   (const enum ATLAS_TRANS TA, ATL_CINT M, ATL_CINT N, const SCALAR alpha,
    const TYPE *A, ATL_CINT lda, const TYPE *X, ATL_CINT incX,
    const SCALAR beta, TYPE *Y, ATL_CINT incY)
{
   if (M <= 8)
   {
      if (M > 0)
      {
         if (TA == AtlasNoTrans || TA == AtlasConj)
            Mjoin(PATL,gemvN_degenM)(M, N, alpha, A, lda, X, incX, beta, Y, incY);
         else
            Mjoin(PATL,gemvT_degenM)(M, N, alpha, A, lda, X, incX, beta, Y, incY);
      }
      return;
   }
   if (N <= 8)
   {
      if (N > 0)
      {
         if (TA == AtlasNoTrans || TA == AtlasConj)
            Mjoin(PATL,gemvN_degenN)(M, N, alpha, A, lda, X, incX, beta, Y, incY);
         else
            Mjoin(PATL,gemvT_degenN)(M, N, alpha, A, lda, X, incX, beta, Y, incY);
      }
      return;
   }
}
@ROUT ATL_gemvT ATL_gemvN
@beginskip
typedef void (*mvkern_t)(ATL_CINT, ATL_CINT, const TYPE*, ATL_CINT, const TYPE*,
                         const SCALAR, TYPE*);

static void *ATL_AlignToX(void *v, int bytes)
{
   size_t sp = (size_t) v;
   if (bytes == 16)
      while (((sp>>4)<<4) != sp) sp++;
   else
      while ((sp/alignY)*alignY != sp) sp++;
   return((void*)sp);
}
#ifdef TREAL
void Mjoin(PATL,cpXs)(const int N, const SCALAR alpha, const TYPE *X,
                      const int incX, TYPE *Y, const int nYs)
{
   TYPE **Ys = (TYPE**) Y;
   TYPE *y0, *y1, *y2, *y3;
   ATL_int i;

   if (nYs == 2)        /* SSE2 kernels in double */
   {
      y0 = Ys[0]; y1 = Ys[1];
      for(i=0; i < N; i++, X += incX)
          y0[i] = y1[i] = *X * alpha;
   }
   else if (nYs == 4)    /* SSE kernels in single */
   {
      y0 = Ys[0]; y1 = Ys[1]; y2 = Ys[2]; y3 = Ys[3];
      for(i=0; i < N; i++, X += incX)
          y0[i] = y1[i] = y2[i] = y3[i] = *X * alpha;
   }
   else
   {
      Mjoin(PATL,cpsc)(N, alpha, X, incX, Ys[0], 1);
      for (i=1; i < nYs; i++)
         Mjoin(PATL,copy)(N, Ys[0], 1, Ys[i], 1);
   }
}
#else
void Mjoin(PATL,cpXs)(const int N, const SCALAR alpha, const TYPE *X,
                      const int incX, TYPE *Y, const int nYs)
{
   TYPE **Ys = (TYPE**) Y;
   TYPE *y0, *y1, *y2, *y3;
   ATL_CINT incx = incX+incX, N2=N+N;
   const register TYPE ra, ia;
   register TYPE rx, ix;
   ATL_INT i;

   if (nYs == 2)        /* SSE2 kernels in double */
   {
      y0 = Ys[0]; y1 = Ys[1];
      if (ix == ATL_rzero)
      {
         for (i=0; i < N2; i += 2, X += incx)
         {
             rx = *X;
             ix = X[1];
             y0[i] = y1[i] = ra*rx;
             y0[i+1] = y1[i+1] = ia*rx;
         }
      }
      else
      {
         for(i=0; i < N2; i += 2, X += incx)
         {
             rx = *X;
             ix = X[1];
             y0[i] = y1[i] = ra*rx - ia*ix;
             y0[i+1] = y1[i+1] = ra*ix + ia*rx;
         }
      }
   }
   else if (nYs == 4)    /* SSE kernels in single */
   {
      if (ix == ATL_rzero)
      {
         for (i=0; i < N2; i += 2, X += incx)
         {
             rx = *X;
             ix = X[1];
             y0[i] = y1[i] = ra*rx;
             y0[i+1] = y1[i+1] = ia*rx;
         }
      }
      else
      {
         y0 = Ys[0]; y1 = Ys[1]; y2 = Ys[2]; y3 = Ys[3];
         for(i=0; i < N2; i += 2, X += incx)
         {
             rx = *X;
             ix = X[1];
             y0[i] = y1[i] = y2[i] = y3[i] = ra*rx - ia*ix;
             y0[i+1] = y1[i+1] = y2[i+1] = y3[i+1] = ra*ix + ia*rx;
         }
      }
   }
}
#endif

@ROUT ATL_gemvT_L2
   @define suf @_L2@
@ROUT ATL_gemvT ATL_gemvT_L2
   @define TA @T@
   @define suf @@
@ROUT ATL_gemvT ATL_gemvT_L2
#define Nx M
#define Ny N
@ROUT ATL_gemvN
   @define TA @N@
#define Nx N
#define Ny M
@ROUT ATL_gemvT ATL_gemvN
void Mjoin(PATL,gemv@(TA)@(suf))
   (ATL_CINT M, ATL_CINT N, const SCALAR alpha,
    const TYPE *A, ATL_CINT lda, const TYPE *X, ATL_CINT incX,
    const SCALAR beta, TYPE *Y, ATL_CINT incY)
/*
@ROUT ATL_gemvN 
 *  y <- alpha * A * x + beta*y  .. or .. y <- alpha * conj(A) * x + beta*y
 *  A is MxN and X has length N and Y has length M
@ROUT ATL_gemvT ATL_gemvT_L2
 *  y <= alpha * A' * x + beta*y .. or .. y <- alpha * conj(A') * x + beta*y
 *  A is MxN and X has length M and Y has length N
@ROUT ATL_gemvT ATL_gemvN ATL_gemvT_L2
 */
{
   mvkern_t gemv0, gemv1, gemvX;  /* main gemv kernels */
   mvkern_t mvdN0, mvdN1, mvdNX;  /* small-N handling kernels */
   void (*getX)(const int N, const SCALAR alpha, const TYPE *X,
                const int incX, TYPE *Y, const int incY);
   void (*putY)(const int N, const SCALAR alpha, const TYPE *X,
                const int incX, const SCALAR beta, TYPE *Y, const int incY);
   TYPE **Xs;
   int allalign=0;                /* does kernel require X wt all alignments? */
   int COPYX=0, COPYY=0;
   int mu, nu;    /* M and N unrolling of kernel */
   int Fmu, Fnu;  /* if nonzero, kernel only handles multiples of this size */
@ROUT ATL_gemvT ATL_gemvT_L2
/*
 * Call special code if M is degenerate
 */
   if (M <= 8)
   {
      if (M > 0)
         Mjoin(PATL,gemvT_degenM)(M, N, alpha, A, lda, X, incX, 
                                  beta, Y, incY);
      return;
   }
/* 
 * =======================================
 * Select kernel to be used by this driver
 * =======================================
 */
/*
 * If we have a kernel that insists that A be alignable, use it.  Note that
 * transpose kernels must take any value of M, but are allowed to insist they
 * handle only certain multiples of N, which is stored in Fnu
 */
   gemv0 = gemv1 = gemvX = NULL;
   mu = nu = ku = 1;
   Fnu = 0;
   alignX = alignY = allalignX = 0;
   #if ATL_MVALIGNA > ATL_sizeof
      mvdN0 = mvdN1 = mvdNX = Mjoin(PATL,gemvT_degenN);
      i = ATL_MulBySize(lda);
      if (((i/ATL_MVALIGNA)*ATL_MVALIGNA) == i)
      {
         gemv0 = ATL_mvk_alignA_b0;
         gemv1 = ATL_mvk_alignA_b1;
         gemvX = ATL_mvk_alignA_bX;
         #ifdef ATL_MVA_ALLALIGNX
            allalignX = 1;
         #elif defined(ATL_MVA_ALIGNX)
            alignX = ATL_MVA_ALIGNX;
         #endif
         #if defined(ATL_MVA_ALIGNY)
            alignY = ATL_MVA_ALIGNY;
         #endif
         #if defined(ATL_MVA_FNU)
            Fnu = ATL_MVA_FNU;
            #ifndef ATL_MV_FNU
               mvdN0 = ATL_mvk_b0;
               mvdN1 = ATL_mvk_b1;
               mvdNX = ATL_mvk_bX;
            #endif
         #endif
         #ifdef ATL_MVA_INCY1
            COPYY = (incY != 1);
         #endif
         ATL_GetPartMVA@(TA)(A, lda, &mb, &nb);
      }
   if (!gemv0)
   #endif
   {
      gemv0 = ATL_mvk_b0;
      gemv1 = ATL_mvk_b1;
      gemvX = ATL_mvk_bX;
      #ifdef ATL_MV_ALLALIGNX
         allalignX = 1;
      #elif defined(ATL_MV_ALIGNX)
         alignX = ATL_MV_ALIGNX;
      #endif
      #if defined(ATL_MV_ALIGNY)
         alignY = ATL_MV_ALIGNY;
      #endif
      #if defined(ATL_MV_FNU)
         Fnu = ATL_MV_FNU;
      #endif
      #ifdef ATL_MV_INCY1
         COPYY = (incY != 1);
      #endif
      ATL_GetPartMV@(TA)(A, lda, &mb, &nb);
   }
/*
 * If N is not at least as large as the forced unroll of the selected kernel,
 * call the degenerate-N driver to handle the gemv
 */
   if (N < Fnu)
   {
      Mjoin(PATL,gemvT_degenN)(M, N, alpha, A, lda, X, incX, beta, Y, incY);
      return;
   }
/*
 * Compute if we need to copy the vectors.  We must always copy X to
 * contiguous storage for our kernels for Transpose.  We will apply alpha
 * during the X copy, and if we don't copy, we must see if it is cheaper
 * to apply alpha by copying X or Y
 */
   COPYX = (incX != 1 | (AlphaIsX & Nx <= Ny) | allalignX);
   if (!COPYX && alignX)
   {
      sz = (size_t) X;
      COPYX = ((sz/alignX)*alignX != sz);
   }
   COPYY = COPYY | (!COPYX && AlphaIsX);
   if (!COPYY && alignY)
   {
      sz = (size_t) Y;
      COPYY = (((sz/alignY)*alignY != sz) | (incY != 1));
   }
/*
 * Count the number of vectors, and allocate them with the required alignment
 */
   nxvec = ((allalignX) ? 4 : COPYX);
   nyvec = COPYY;
   if (nxvec|nyvec)
   {
      vp = malloc(ATL_MulBySize(nxvec*mb+nyvec*Ny)+
                  (nxvec+nyvec)*(ATL_Cachelen+ATL_Cachelen));
      ATL_assert(vp);
      sz = (size_t) vp;
      if (nyvec)
      {
         alignY = (alignY) ? alignY : 16;
         ATL_assert(alignY <= ATL_Cachelen);
         y = ATL_AlignToX(vp, alignY);
         sz = (size_t) (y+Ny);
      }
      if (nxvec)
      {
         if (!allalignX)
         {
            alignX = (alignX) ? alignX : 16;
            x = ATL_AlignToX((TYPE*)sz, alignX);
         }
/*
 *       allalign means I want all legal alignments between 0-alignX in steps
 *       of sizeof(TYPE)
 */
         else
         {
            nXptrs = ATL_DivBySize(alignX);
            ATL_assert(ATL_MulBySize(nXptrs) == alignX);
            Xs = malloc(nXptrs * sizeof(TYPE*));
            for (i=0; i < nXptrs; i++)
            {
               Xs[i] = ATL_AlignToX((TYPE*)sz, alignX));
               Xs[i] += i;
               sz = (size_t) (Xs[i] + mb);
            }
         }
      }
   }
/*
 * See where I'm going to apply BETA
 */
   if (COPYY || BetaIsZero)
      gemv0 = ATL_gemv@(TA)_b0;
   else if (BetaIsOne)
      gemv0 = ATL_gemv@(TA)_b1;
   else 
      gemv0 = ATL_gemv@(TA)_bX;
   gemv1 = ATL_gemv@(TA)_b1;
   putY = (COPYY) ? Mjoin(PATL,axpby) : NULL;
   getX = (COPYX) ? Mjoin(PATL,cpsc) : NULL;
}
@endskip
@ROUT ATL_ger2k_Nlt8
#include "atlas_misc.h"
#include "atlas_level1.h"
#ifdef Conj_
void Mjoin(PATL,ger2ck_Nlt8)
#else
void Mjoin(PATL,ger2k_Nlt8)
#endif
   (ATL_CINT M, ATL_CINT N, const SCALAR alpha0, const TYPE *X0, 
    ATL_CINT incX0, const TYPE *Y0, ATL_CINT incY0, 
    const SCALAR alpha1, const TYPE *X1, ATL_CINT incX1, const TYPE *Y1, 
    ATL_CINT incY1, TYPE *A, ATL_CINT lda)
/*
 * A += alpha0*X0*Y0 + alpha1*X1*Y1;
 * This routine typically called when N is very small, and so we can't afford
 * to copy the vectors even if M is large; in this case we simply address
 * the columns of A one-by-one with simple loops.
 */
{
#ifdef TCPLX
   const TYPE *xp0, *xp1;
   const TYPE al0r = *alpha0, al0i = alpha0[1];
   const TYPE al1r = *alpha1, al1i = alpha1[1];
   ATL_CINT incAn=(lda-M)<<1, incY02=incY0+incY0, incY12=incY1+incY1;
   ATL_CINT incX02=incX0+incX0, incX12=incX1+incX1;
   ATL_INT i, j;
   register TYPE y0r, y0i, y1r, y1i, x0r, x0i, x1r, x1i;

   for (j=0; j < N; j++, A += incAn, Y0 += incY02, Y1 += incY12)
   {
/*
 *    Load values from Y
 */
      #ifdef Conj_
         y0r = *Y0; y0i = -Y0[1];
         y1r = *Y1; y1i = -Y1[1];
      #else
         y0r = *Y0; y0i = Y0[1];
         y1r = *Y1; y1i = Y1[1];
      #endif
/*
 *    Apply alpha to Y registers
 */
      x0r = al0r * y0r - al0i * y0i;
      y0i = al0r * y0i + al0i * y0r;
      y0r = x0r;
      x0r = al1r * y1r - al1i * y1i;
      y1i = al1r * y1i + al1i * y1r;
      y1r = x0r;
      xp0 = X0; xp1 = X1;
/*
 *    Now do A += x0*y0 + x1*y1
 */
      for (i=0; i < M; i++, A += 2, xp0 += incX02, xp1 += incX12)
      {
         x0r = *xp0; x0i = xp0[1];
         x1r = *xp1; x1i = xp1[1];
         *A   += x0r * y0r - x0i * y0i + x1r * y1r - x1i * y1i;
         A[1] += x0r * y0i + x0i * y0r + x1r * y1i + x1i * y1r;
      }
   }
#else
   ATL_INT i, j;
   const TYPE *xp0, *xp1;
   register TYPE y0, y1;
   for (j=0; j < N; j++, A += lda, Y0 += incY0, Y1 += incY1)
   {
      y0 = alpha0 * *Y0;
      y1 = alpha1 * *Y1;
      xp0 = X0;
      xp1 = X1;
      for (i=0; i < M; i++, xp0 += incX0, xp1 += incX1)
         A[i] += *xp0 * y0 + *xp1 * y1;
   }
#endif
}
@ROUT ATL_gerk_axpy
#include "atlas_misc.h"
#include "atlas_level1.h"
#ifdef Conj_
void Mjoin(PATL,gerck_axpy)
#else
void Mjoin(PATL,gerk_axpy)
#endif
   (const int M, const int N, const SCALAR alpha, const TYPE *X, const int incX,
    const TYPE *Y, const int incY, TYPE *A, const int lda)
/*
 * This routine typically called when N is very small, and so we can't afford
 * to copy the vectors even if M is large; in this case we simply loop over
 * the appropriate calls to the AXPY
 */
{
#ifdef TCPLX
   const int incy = incY+incY, lda2 = lda+lda;
   TYPE y[2];
   const TYPE ralp=(*alpha), ialp=alpha[1];
   TYPE ry, iy;
   int j;

   for (j=0; j < N; j++, A += lda2, Y += incy)
   {
      ry = *Y; iy = Y[1];
      #ifdef Conj_
         y[0] = ry*ralp + iy*ialp;
         y[1] = ry*ialp - iy*ralp;
      #else
         y[0] = ry*ralp - iy*ialp;
         y[1] = ry*ialp + iy*ralp;
      #endif
      Mjoin(PATL,axpy)(M, y, X, incX, A, 1);
   }
#else
   int j;
   for (j=0; j < N; j++, A += lda, Y += incY)
      Mjoin(PATL,axpy)(M, *Y*alpha, X, incX, A, 1);
#endif
}
@ROUT ATL_ger2k_Mlt16
   @define rt @ger2@
@ROUT ATL_gerk_Mlt16
   @define rt @ger@
@ROUT ATL_gerk_Mlt16 ATL_ger2k_Mlt16
#include "atlas_misc.h"
#include "atlas_lvl2.h"
@ROUT ATL_ger2k_Mlt16

typedef void (*ger2k_t)
   (ATL_CINT M, ATL_CINT N, const SCALAR alp_a, const TYPE *Xa, ATL_CINT incXa,
    const TYPE *Ya, ATL_CINT incYa, const SCALAR alp_b, const TYPE *Xb, 
    ATL_CINT incXb, const TYPE *Yb, ATL_CINT incYb, TYPE *A, const int lda);
@ROUT ATL_gerk_Mlt16
#ifdef TCPLX
   #include "atlas_reflevel2.h"
#endif

typedef void (*gerk_t)
   (const int M, const int N, const SCALAR alpha, const TYPE *X, const int incX,
    const TYPE *Y, const int incY, TYPE *A, const int lda);
@ROUT ATL_gerk_Mlt16 ATL_ger2k_Mlt16

#ifdef TREAL
@BEGINPROC gerkN M
@ROUT ATL_gerk_Mlt16
static void ATL_gerk_Meq@(M)
   (const int M, const int N, const SCALAR alpha, const TYPE *X, const int incX,
    const TYPE *Y, const int incY, TYPE *A, const int lda)
@ROUT ATL_ger2k_Mlt16
static void ATL_ger2k_Meq@(M)
   (ATL_CINT M, ATL_CINT N, const SCALAR alp_a, const TYPE *Xa, ATL_CINT incXa,
    const TYPE *Ya, const int incYa, const SCALAR alp_b, const TYPE *Xb, 
    ATL_CINT incXb, const TYPE *Yb, ATL_CINT incYb, TYPE *A, const int lda)
@ROUT ATL_gerk_Mlt16 ATL_ger2k_Mlt16
{
   register int j;
   @declare "   register TYPE " n n ";"
      @ROUT ATL_gerk_Mlt16 `y0`
      @ROUT ATL_ger2k_Mlt16 `y0a y0b`
      @define i @0@
      @iwhile i < @(M)
         @ROUT ATL_gerk_Mlt16 `x@(i)`
         @ROUT ATL_ger2k_Mlt16 `x@(i)a x@(i)b`
         @iexp i 1 @(i) +
      @endiwhile
      @undef i
   @enddeclare

@ROUT ATL_ger2k_Mlt16
   @whiledef alp a b
   if (alp_@(alp) == ATL_rone) goto ALP_@up@(alp)_1;
   else if (alp_@(alp) != ATL_rnone) goto ALP_@up@(alp)_X;
@define i @0@
@iwhile i < @(M)
   x@(i)@(alp) = -X@(alp)[@(i)*incX@(alp)];
   @iexp i 1 @(i) +
@endiwhile
@undef i
X@up@(alp)_IS_LOADED:
   @endwhile
@ROUT ATL_gerk_Mlt16
   if (alpha == ATL_rone) goto ALPHA1;
   else if (alpha != ATL_rnone) goto ALPHAX;
@define i @0@
@iwhile i < @(M)
   x@(i) = -X[@(i)*incX];
   @iexp i 1 @(i) +
@endiwhile
@undef i
X_IS_LOADED:
@ROUT ATL_gerk_Mlt16 ATL_ger2k_Mlt16

   for (j=0; j < N; j++, A += lda)
   {
@ROUT ATL_gerk_Mlt16
      y0 = Y[incY*j];
@ROUT ATL_ger2k_Mlt16 
      y0a = Ya[incYa*j];
      y0b = Yb[incYb*j];
@ROUT ATL_gerk_Mlt16 ATL_ger2k_Mlt16
   @define i @0@
   @iwhile i < @(M)
@ROUT ATL_gerk_Mlt16  `      A[@(i)] += x@(i) * y0;`
@ROUT ATL_ger2k_Mlt16 `      A[@(i)] += x@(i)a * y0a + x@(i)b * y0b;`
      @iexp i 1 @(i) +
   @endiwhile
   @undef i
   }
   return;

@ROUT ATL_gerk_Mlt16
ALPHAX:
@define i @0@
@iwhile i < @(M)
   y0 = alpha;
   x@(i) = X[@(i)*incX] * y0;
   @iexp i 1 @(i) +
@endiwhile
@undef i
   goto X_IS_LOADED;
ALPHA1:
@define i @0@
@iwhile i < @(M)
   x@(i) = X[@(i)*incX];
   @iexp i 1 @(i) +
@endiwhile
@undef i
   goto X_IS_LOADED;
}
@ROUT ATL_ger2k_Mlt16
@whiledef ab a b
ALP_@up@(ab)_X:
@define i @0@
@iwhile i < @(M)
   y0a = alp_@(ab);
   x@(i)@(ab) = X@(ab)[@(i)*incX@(ab)] * y0a;
   @iexp i 1 @(i) +
@endiwhile
@undef i
   goto X@up@(ab)_IS_LOADED;
ALP_@up@(ab)_1:
@define i @0@
@iwhile i < @(M)
   x@(i)@(ab) = X@(ab)[@(i)*incX@(ab)];
   @iexp i 1 @(i) +
@endiwhile
@undef i
   goto X@up@(ab)_IS_LOADED;
@endwhile
}
@ENDPROC

@define j @1@
@iwhile j < 16
   @callproc gerkN @(j)
   @iexp j 1 @(j) +
@endiwhile
@undef j

void Mjoin(PATL,@(rt)k_Mlt16)
@ROUT ATL_ger2k_Mlt16
   (const int M, const int N, const SCALAR alp_a, const TYPE *Xa, 
    const int incXa, const TYPE *Ya, const int incYa, const SCALAR alp_b, 
    const TYPE *Xb, const int incXb, const TYPE *Yb, const int incYb, 
    TYPE *A, const int lda)
@ROUT ATL_gerk_Mlt16
   (const int M, const int N, const SCALAR alpha, const TYPE *X, const int incX,
    const TYPE *Y, const int incY, TYPE *A, const int lda)
@ROUT ATL_gerk_Mlt16 ATL_ger2k_Mlt16
/*
 * ATLAS's normal @up@(rt) kernels are optimized for long-M, and loop over rows in
 * the inner loop.  To avoid this killing us on short, wide matrices, have
 * special case code for M < 16.  This also allows kernels to assume M >= 16.
 */
{
   @declare "   static @(rt)k_t @(rt)ks[15]={" y n "};"
      @define i @1@
      @iwhile i < 16
         ATL_@(rt)k_Meq@(i)
         @iexp i 1 @(i) +
      @endiwhile
      @undef i
   @enddeclare
@ROUT ATL_gerk_Mlt16
   if (M < 1 || N < 1 || SCALAR_IS_ZERO(alpha))
      return;
@ROUT ATL_ger2k_Mlt16
   if (M < 1 || N < 1 || (SCALAR_IS_ZERO(alp_a) && SCALAR_IS_ZERO(alp_b)))
      return;
@ROUT ATL_gerk_Mlt16 ATL_ger2k_Mlt16
   #ifdef ATL_GAS_x8664
   if (M > 14)
   #elif defined(ATL_GAS_x8632)
   if (M > 6)
   #else
   if (M > 15)
   #endif
   {
@ROUT ATL_gerk_Mlt16 
      Mjoin(PATL,gerk_axpy)(M, N, alpha, X, incX, Y, incY, A, lda);
@ROUT ATL_ger2k_Mlt16 
      Mjoin(PATL,ger2k_Nlt8)(M, N, alp_a, Xa, incXa, Ya, incYa, alp_b, 
                             Xb, incXb, Yb, incYb, A, lda);
@ROUT ATL_gerk_Mlt16 ATL_ger2k_Mlt16
      return;
   }
@ROUT ATL_ger2k_Mlt16
   ger2ks[M-1](M, N, alp_a, Xa, incXa, Ya, incYa,  
               alp_b, Xb, incXb, Yb, incYb, A, lda);
@ROUT ATL_gerk_Mlt16
   gerks[M-1](M, N, alpha, X, incX, Y, incY, A, lda);
@ROUT ATL_gerk_Mlt16 ATL_ger2k_Mlt16
}

#else /* complex type */
@ROUT ATL_ger2k_Mlt16
#ifdef Conj_
void Mjoin(PATL,ger2ck_Mlt16)
#else
void Mjoin(PATL,ger2k_Mlt16)
#endif
   (ATL_CINT M, ATL_CINT N, const SCALAR alp_a, const TYPE *Xa, ATL_CINT incXa,     const TYPE *Ya, ATL_CINT incYa, const SCALAR alp_b, const TYPE *Xb, 
    ATL_CINT incXb, const TYPE *Yb, ATL_CINT incYb, TYPE *A, ATL_CINT lda)
{
/*
 * For now, complex simply calls loop-based routine.
 */
#ifdef Conj_
   Mjoin(PATL,ger2ck_Nlt8)(M, N, alp_a, Xa, incXa, Ya, incYa, 
                           alp_b, Xb, incXb, Yb, incYb, A, lda);
#else
   Mjoin(PATL,ger2k_Nlt8)(M, N, alp_a, Xa, incXa, Ya, incYa, 
                          alp_b, Xb, incXb, Yb, incYb, A, lda);
#endif
}
@ROUT ATL_gerk_Mlt16
#ifdef Conj_
void Mjoin(PATL,gerck_Mlt16)
#else
void Mjoin(PATL,gerk_Mlt16)
#endif
   (const int M, const int N, const SCALAR alpha, const TYPE *X, const int incX,
    const TYPE *Y, const int incY, TYPE *A, const int lda)
{
/*
 * For now, complex simply calls refblas for short M, axpy-based for large.
 * Probably not worth additional instruction load for complex to unroll.
 */
   #ifndef TUNING
   if (M < 8)
#ifdef Conj_
      Mjoin(PATL,refgerc)(M, N, alpha, X, incX, Y, incY, A, lda);
#else
      Mjoin(PATL,refgeru)(M, N, alpha, X, incX, Y, incY, A, lda);
#endif
   else
   #endif
#ifdef Conj_
      Mjoin(PATL,gerck_axpy)(M, N, alpha, X, incX, Y, incY, A, lda);
#else
      Mjoin(PATL,gerk_axpy)(M, N, alpha, X, incX, Y, incY, A, lda);
#endif
}
@ROUT ATL_gerk_Mlt16 ATL_ger2k_Mlt16
#endif
@ROUT gemvT_oc
@ROUT gensy2
void UnrolledSyr2(FILE *fpout, char pre, enum ATLAS_UPLO Uplo, int N)
/*
 * Assume regular files defines lda[2-nu]
 */
{
   char **ldas;
   ldas = malloc(N*sizeof(char*));
   assert(ldas);
   ldas[0] = "";
   ldas[1] = "+lda";
   for (j=2; j < N; j++)
   {
      ldas[j] = malloc(8*sizeof(char));
      sprintf(ldas[j], "+lda%d", j);
   }
   fprintf(fpout, "#define ATL_SYR2_Diag(A_, lda_, x_, y_) \\\n{ \\\n");
   fprintf(fpout, "   const %s x0=*(x_)", type);
   for (i=1; i < N; i++)
      fprintf(fpout, ", x%d=(x_)[%d]", i, i);
   fprintf(fpout, "; \\\n");
   fprintf(fpout, "   const %s y0=*(y_)", type);
   for (i=1; i < N; i++)
      fprintf(fpout, ", y%d=(y_)[%d]", i, i);
   fprintf(fpout, "; \\\n");
   for (j=0; j < N; j++)
   {
      for (i=j; i < N; i++)
         fprintf(fpout, "   A[%d%s] += x%d*y%d + x%d*y%d; \\\n",
	         i, ldas[j], i, j, j, i);
   }
   for (j=2; j < N; j++)
      free(ldas[j]);
   free(ldas);
}
@ROUT ATL_syr2K
#ifdef TCPLX
void Mjoin(PATL,syr2KL)
   (ATL_CINT N, const SCALAR alpha, const TYPE *X, ATL_CINT incX, 
    const TYPE *Y, ATL_CINT incY, TYPE *A, ATL_CINT lda0)
{
   int i, j;
   const int lda = lda0+lda0, N2=N+N, M2=M+M;
   TYPE rXj, iXj, rXi, iXi, rYi, iYi, rYj, iYj;
   for (j=0; j < N2; j += 2, A += lda)
   {
      rXj = X[j];
      iXj = X[j+1];
      rYj = Y[j];
      iYj = Y[j+1];
      for (i=j; i < M2; i += 2)
      {
         rXi = X[i];
         iXi = X[i+1];
         rYi = Y[i];
         iYi = Y[i+1];
	 A[i] += rXj*rYi - iXj*iYi + rXi*rYj - iXi*iYj;
	 A[i+1] += rXj*iYi + iXj*rYi + rXi*iYj + iXi*rYj;
      }
   }
}
#else
void Mjoin(PATL,syr2KL)
   (ATL_CINT N, const SCALAR alpha, const TYPE *X, ATL_CINT incX, 
    const TYPE *Y, ATL_CINT incY, TYPE *A, ATL_CINT lda)
{
   int i, j;
   TYPE xi, yi, xj, yj;

   for (j=0; j < N; j++, A += lda)
   {
      xj = X[j];
      yj = Y[j];
      for (i=j; i < N; i++)
      {
         xi = X[i];
	 yi = Y[i];
	 A[i] += xi*yj + xj*yi;
      }
   }
}
#endif
@ROUT ATL_syr
   @define rt @syr@
@ROUT ATL_her
   @define rt @her@
@ROUT ATL_her ATL_syr
#include "atlas_misc.h"
#include "atlas_level1.h"
#include "atlas_reflvl2.h"
#include "atlas_reflevel2.h"
#include "atlas_lvl2.h"
#if defined(ATL_INL1)
   #include Mstr(Mjoin(Mjoin(atlas_,PRE),syr_L1.h))
   #define ATL_@(rt) Mjoin(PATL,@(rt)_L1)
#elif defined(ATL_INL2)
   #include Mstr(Mjoin(Mjoin(atlas_,PRE),syr_L2.h))
   #define ATL_@(rt) Mjoin(PATL,@(rt)_L2)
#else
   #include Mstr(Mjoin(Mjoin(atlas_,PRE),syr.h))
   #define ATL_@(rt) Mjoin(PATL,@(rt))
#endif

#ifdef ATL_NXTUNE
   extern int ATL_KERN_NX;
   #define ATL_S1NX ATL_KERN_NX
#else
   #include Mstr(Mjoin(Mjoin(atlas_,PRE),syrNX.h))
   #ifndef ATL_S1NX
      #define ATL_S1NX 128
   #endif
#endif
void Mjoin(PATL,@(rt)_kU)
(
   ATL_r1kern_t gerk0,          /* func ptr to selected GER kernel */
   ATL_CINT N,                  /* size of prob to solve */
   const TYPE alpha,            /* alpha */
@ROUT ATL_syr
   const TYPE *x,               /* vector X -- may have alpha applied */
   const TYPE *xt,              /* X^T */
   TYPE *A,                     /* symmetric matrix, A = A + x*xt */
@ROUT ATL_her
   const TYPE *x,               /* input vector X */
   const TYPE *xh,              /* alpha*X^H */
   TYPE *A,                     /* hermitian matrix, A = A + x*xh */
@ROUT ATL_syr ATL_her
   ATL_CINT lda                 /* row stride of A */
)
{
   ATL_r1kern_t gerk=gerk0;
   ATL_INT nx, j;
@ROUT ATL_her
   TYPE one[2] = {ATL_rone, ATL_rzero};
   ATL_CINT lda2 = lda+lda;
@ROUT ATL_syr ATL_her
   ATL_CINT NN = (N/ATL_s1U_NU)*ATL_s1U_NU;

   nx = (ATL_S1NX >= ATL_s1U_NU) ? (ATL_S1NX/ATL_s1U_NU)*ATL_s1U_NU : ATL_s1U_NU;
   nx = Mmin(nx, N);
@ROUT ATL_syr
   Mjoin(PATL,ref@(rt))(AtlasUpper, nx, alpha, xt, 1, A, lda);
   for (j=nx; j < NN; j += ATL_s1U_NU)
   {
      #if ATL_MIN_RESTRICTED_M > 0
         gerk = (j >= ATL_MIN_RESTRICTED_M) ? gerk0 : ATL_GENGERK;
      #endif
      gerk(j, ATL_s1U_NU, x, xt+j, A+j*lda, lda);
      ATL_@up@(rt)1U_nu(A+j*(lda+1), lda, x+j, xt+j);
   }
   nx = N - j;
   if (nx)
   {
      ATL_GENGERK(j, nx, x, xt+j, A+j*lda, lda);
      Mjoin(PATL,ref@(rt)U)(nx, alpha, xt+j, 1, A+j*(lda+1), lda);
   }
@ROUT ATL_her
   Mjoin(PATL,ref@(rt)U)(nx, alpha, x, 1, A, lda);
   for (j=nx; j < NN; j += ATL_s1U_NU)
   {
      #if ATL_MIN_RESTRICTED_M > 0
         gerk = (j >= ATL_MIN_RESTRICTED_M) ? gerk0 : ATL_GENGERK;
      #endif
      gerk(j, ATL_s1U_NU, x, xh+j+j, A+j*lda2, lda);
      ATL_@up@(rt)1U_nu(A+j*(lda2+2), lda, x+j+j, xh+j+j);
   }
   nx = N - j;
   if (nx)
   {
      ATL_GENGERK(j, nx, x, xh+j+j, A+j*lda2, lda);
      Mjoin(PATL,ref@(rt)U)(nx, alpha, x+j+j, 1, A+j*(lda2+2), lda);
   }
@ROUT ATL_syr ATL_her
}

void Mjoin(PATL,@(rt)_kL)
(
   ATL_r1kern_t gerk0,          /* func ptr to selected GER kernel */
   ATL_CINT N,                  /* size of prob to solve */
   const TYPE alpha,            /* alpha */
@ROUT ATL_syr
   const TYPE *x,               /* vector X -- may have alpha applied */
   const TYPE *xt,              /* X^T */
   TYPE *A,                     /* symmetric matrix, A = A + x*xt */
@ROUT ATL_her
   const TYPE *x,               /* input vector X */
   const TYPE *xh,              /* alpha*X^H */
   TYPE *A,                     /* hermitian matrix, A = A + x*xh */
@ROUT ATL_syr ATL_her
   ATL_CINT lda                 /* row stride of A */
)
{
   ATL_r1kern_t gerk=gerk0;
   ATL_INT nx=Mmin(ATL_S1NX,N), i, NN, n;
@ROUT ATL_her
   ATL_CINT lda2 = lda+lda;
   const TYPE one[2] = {ATL_rone, ATL_rzero};
@ROUT ATL_syr ATL_her

   i = N - nx;
   i = (i/ATL_s1L_NU)*ATL_s1L_NU;
   if (i != N-nx)
      nx += N-nx-i;
   NN = N - nx;
@ROUT ATL_syr
   for (i=0; i < NN; i += ATL_s1L_NU)
   {
      ATL_@up@(rt)1L_nu(A, lda, x, xt);
      n = N-i-ATL_s1L_NU;
      #if ATL_MIN_RESTRICTED_M > 0
         gerk = (n >= ATL_MIN_RESTRICTED_M) ? gerk0 : ATL_GENGERK;
      #endif
      gerk(n, ATL_s1L_NU, x+ATL_s1L_NU, xt, A+ATL_s1L_NU, lda);
      A += ATL_s1L_NU*(lda+1);
      xt += ATL_s1L_NU;
      x += ATL_s1L_NU;
   }
   Mjoin(PATL,ref@(rt))(AtlasLower, nx, alpha, xt, 1, A, lda);
@ROUT ATL_her
   for (i=0; i < NN; i += ATL_s1L_NU)
   {
      ATL_@up@(rt)1L_nu(A, lda, x, xh);
      n = N-i-ATL_s1L_NU;
      #if ATL_MIN_RESTRICTED_M > 0
         gerk = (n >= ATL_MIN_RESTRICTED_M) ? gerk0 : ATL_GENGERK;
      #endif
      gerk(n, ATL_s1L_NU, x+ATL_s1L_NU+ATL_s1L_NU, xh, A+ATL_s1L_NU+ATL_s1L_NU, lda);
      A += ATL_s1L_NU*(lda2+2);
      xh += ATL_s1L_NU+ATL_s1L_NU;
      x += ATL_s1L_NU+ATL_s1L_NU;
   }
   Mjoin(PATL,ref@(rt))(AtlasLower, nx, alpha, x, 1, A, lda);
@ROUT ATL_syr ATL_her
}

void ATL_@(rt)(const enum ATLAS_UPLO Uplo, ATL_CINT N, const TYPE alpha,
               const TYPE *X, ATL_CINT incX, TYPE *A, ATL_CINT lda)
{
@ROUT ATL_her `   const TYPE calpha[2] = {alpha, ATL_rzero};`
   void *vp=NULL;
   TYPE *x, *xt;
   ATL_r1kern_t gerk;
   ATL_INT CacheElts;
   const int ALP1 = (alpha == ATL_rone);
   int COPYX, COPYXt;
   int mu, nu, minM, minN, alignX, alignXt, FNU, ALIGNX2A;
   if (N < 1 || (alpha == ATL_rzero))
      return;
/*
 * For very small problems, avoid overhead of func calls & data copy
 */
   if (N < 50)
   {
      Mjoin(PATL,ref@(rt))(Uplo, N, alpha, X, incX, A, lda);
      return;
   }
/*
 * Determine the GER kernel to use, and its parameters
 */
   gerk = ATL_GetR1Kern(N-ATL_s1L_NU, ATL_s1L_NU, A, lda, &mu, &nu, 
                        &minM, &minN, &alignX, &ALIGNX2A, &alignXt, 
                        &FNU, &CacheElts);
/*
 * Determine if we need to copy the vectors
 */
@ROUT ATL_her
   COPYX = (incX != 1);
@ROUT ATL_syr
   COPYXt = COPYX = (incX != 1);
@ROUT ATL_syr ATL_her
   if (!COPYX)  /* may still need to copy due to alignment issues */
   {
/*
 *    ATL_Cachelen is the highest alignment that can be requested, so
 *    make X's % with Cachelen match that of A if you want A & X to have
 *    the same alignment
 */
      if (ALIGNX2A)
      {
         size_t t1 = (size_t) A, t2 = (size_t) X;
         COPYX = (t1 - ATL_MulByCachelen(ATL_DivByCachelen(t1))) !=
                 (t2 - ATL_MulByCachelen(ATL_DivByCachelen(t2)));
      }
      else if (alignX)
      {
         size_t t1 = (size_t) X;
         COPYX = ((t1/alignX)*alignX != t1);
      }
   }
@ROUT ATL_syr
   if (!COPYXt && alignXt)  /* alignment might still force a copy */
   {
      size_t t1 = (size_t) X;
      COPYXt = ((t1/alignX)*alignX != t1);
   }
   if (!COPYX && !COPYXt && !ALP1)
      COPYX=1;
/*
 * See if X and Xt can legally be the same vector
 */
   if (ALP1 && (!alignXt || alignX == alignXt))
   {
      if (COPYX)
      {
         vp = malloc(ATL_MulBySize(N)+ATL_Cachelen);
         if (!vp)
         {
            Mjoin(PATL,refsyr)(Uplo, N, alpha, X, incX, A, lda);
            return;
         }
         x = xt = ALIGNX2A ? ATL_Align2Ptr(vp, A) : ATL_AlignPtr(vp);
         Mjoin(PATL,copy)(N, X, incX, x, 1);
         COPYX = 0;
      }
      else
         x = xt = (TYPE*) X;
   }
   else if (COPYX || COPYXt)
   {
      vp = malloc((COPYX+COPYXt)*(ATL_Cachelen + ATL_MulBySize(N)));
      if (!vp)
      {
         Mjoin(PATL,refsyr)(Uplo, N, alpha, X, incX, A, lda);
         return;
      }
      if (!COPYXt)      /* apply alpha to X, orig vec Xt */
      {
         xt = (TYPE*) X;
         x = (ALIGNX2A) ? ATL_Align2Ptr(vp, A) : ATL_AlignPtr(vp);
         if (ALP1)
            Mjoin(PATL,copy)(N, X, incX, x, 1);
         else
            Mjoin(PATL,cpsc)(N, alpha, X, incX, x, 1);
      }
      else if (!COPYX)  /* apply alpha to Xt, orig vec X */
      {
         x = (TYPE*) X;
         xt = ATL_AlignPtr(vp);
         if (ALP1)
            Mjoin(PATL,copy)(N, X, incX, xt, 1);
         else
            Mjoin(PATL,cpsc)(N, alpha, X, incX, xt, 1);
      }
      else /* copy both vectors */
      {
         xt = ATL_AlignPtr(vp);
         x = xt + N;
         x = (ALIGNX2A) ? ATL_Align2Ptr(x, A) : ATL_AlignPtr(x);
         if (ALP1)
         {
            register int i;
            for (i=0; i < N; i++, X += incX)
               xt[i] = x[i] = *X;
         }
         else
         {
            register int i;
            for (i=0; i < N; i++, X += incX)
            {
               const register TYPE rx = *X;
               xt[i] = rx;
               x[i] = alpha * rx;
            }
         }
      }
   }
   else
      x = xt = (TYPE*)X;
@ROUT ATL_her
   vp = malloc((ATL_Cachelen+ATL_MulBySize(N))*(1+COPYX));
   if (!vp)
   {
      Mjoin(PATL,refher)(Uplo, N, alpha, X, incX, A, lda);
      return;
   }
   xt = ATL_AlignPtr(vp);
   if (COPYX)
   {
      x = xt + N+N;
      x = ALIGNX2A ? ATL_Align2Ptr(x, A) : ATL_AlignPtr(x);
      Mjoin(PATL,copy)(N, X, incX, x, 1);
   }
   else
      x = (TYPE*) X;
   if (ALP1)
      Mjoin(PATL,copyConj)(N, X, incX, xt, 1);
   else
      Mjoin(PATL,moveConj)(N, calpha, X, incX, xt, 1);
@ROUT ATL_syr ATL_her
   if (Uplo == AtlasUpper)
      Mjoin(PATL,@(rt)_kU)(gerk, N, alpha, x, xt, A, lda);
   else
      Mjoin(PATL,@(rt)_kL)(gerk, N, alpha, x, xt, A, lda);
   if (vp)
     free(vp);
}
@beginskip
#define MY_GERK(m_, n_, x_, xt_, A_, lda_) \
{ \
   if (FNU) \
   { \
      ATL_CINT nnu = ((n_) >= minN && (m_) >= minM) ? ((n_)/nu)*nu : 0, \
               nr = (n_)-nnu; \
      if (nnu) \
         gerk(m_, nnu, x_, xt_, A_, lda_); \
      if (nr) \
@ROUT ATL_syr
         ATL_GENGERK(m_, nr, x_, (xt_)+nnu, (A_)+nnu*(lda_), lda_); \
@ROUT ATL_her
         ATL_GENGERK(m_, nr, x_, (xt_)+nnu+nnu, (A_)+(nnu+nnu)*(lda_), lda_); \
@ROUT ATL_syr ATL_her
   } \
   else \
      gerk(m_, n_, x_, xt_, A_, lda_); \
}

void ATL_@(rt)(const enum ATLAS_UPLO Uplo, ATL_CINT N, const TYPE alpha,
               const TYPE *X, ATL_CINT incX, TYPE *A, ATL_CINT lda)
{
   size_t t1, t2;
@ROUT ATL_her
   const TYPE one[2] = {ATL_rone, ATL_rzero}, calpha[2] = {alpha, ATL_rzero};
   ATL_CINT lda2 = lda+lda, incx = incX+incX;
@ROUT ATL_syr ATL_her
   void *vp=NULL;
@ROUT ATL_syr `   TYPE *x, *xt, *xx=(TYPE*)X;`
@ROUT ATL_her `   TYPE *x, *xh;`
   ATL_r1kern_t gerk, gerk0;
@ROUT ATL_syr `   ATL_INT MB, NB, mb, nb, Nmb, i, n, incx=incX, CacheElts;`
@ROUT ATL_her `   ATL_INT MB, NB, mb, nb, Nmb, n, i, CacheElts;`
   int mu, nu, minM, minN, alignX, alignXt, FNU;
   int COPYX=0, COPYXt=0, ALIGNX2A=0;
   const int ALPHA_IS_ONE=(alpha == ATL_rone);

   if (N < 1 || (alpha == ATL_rzero))
      return;
/*
 * For very small problems, avoid overhead of func calls & data copy
 */
   if (N < 50)
   {
      Mjoin(PATL,ref@(rt))(Uplo, N, alpha, X, incX, A, lda);
      return;
   }
/*
 * Determine the GER kernel to use, and its parameters
 */
   ATL_GetPartS1(A, lda, mb, nb);
   if (!mb || !nb || mb > N || nb > N)
   {
      MB = N-ATL_s1L_NU;
      NB = N-ATL_s1L_NU;
      mb = nb = N;
   }
   else
   {
      MB = mb;
      NB = nb;
   }
   gerk = ATL_GetR1Kern(MB, NB, A, lda, &mu, &nu, &minM, &minN, &alignX,
                        &ALIGNX2A, &alignXt, &FNU, &CacheElts);
/*
 * Determine if we need to copy the vectors
 */
   COPYX = (incX != 1);
   if (!COPYX)  /* may still need to copy due to alignment issues */
   {
/*
 *    ATL_Cachelen is the highest alignment that can be requested, so
 *    make X's % with Cachelen match that of A if you want A & X to have
 *    the same alignment
 */
      if (ALIGNX2A)
      {
         t1 = (size_t) A;
         t2 = (size_t) X;
         COPYX = (t1 - ATL_MulByCachelen(ATL_DivByCachelen(t1))) !=
                 (t2 - ATL_MulByCachelen(ATL_DivByCachelen(t2)));
      }
      else if (alignX)
      {
         t1 = (size_t) X;
         COPYX = ((t1/alignX)*alignX != t1);
      }
   }
@ROUT ATL_syr
   COPYXt = (incX != 1);
   if (!COPYXt && alignXt)  /* alignment might still force a copy */
   {
      t1 = (size_t) X;
      COPYXt = ((t1/alignX)*alignX != t1);
   }
   MB = mb;
@skip   MB = (mb > N || mb < 1) ? N : mb;
@skip   if (nb > N || nb < 1)
@skip      nb = N;
@ROUT ATL_her
   i = N + COPYX*mb;
   vp = malloc(ATL_MulBySize(i)+2*ATL_Cachelen);
   if (!vp)
   {
      Mjoin(PATL,ref@(rt))(Uplo, N, alpha, X, incX, A, lda);
      return;
   }
   xh = ATL_AlignPtr(vp);
   if (COPYX)
   {
      x = xh + N+N;
      x = ALIGNX2A ? ATL_Align2Ptr(x, A) : ATL_AlignPtr(x);
   }
   else 
      x = (TYPE*) X;
   if (ALPHA_IS_ONE)
      Mjoin(PATL,copyConj)(N, X, incX, xh, 1);
   else
      Mjoin(PATL,moveConj)(N, calpha, X, incX, xh, 1);
@ROUT ATL_syr
/*
 * See if X and Xt can legally be the same vector 
 */
   if (ALPHA_IS_ONE && (!alignXt || alignX == alignXt))
   {
      if (COPYX)
      {
         vp = malloc(ATL_MulBySize(N)+ATL_Cachelen);
         if (!vp)
         {
            Mjoin(PATL,ref@(rt))(Uplo, N, alpha, X, incX, A, lda);
            return;
         }
         x = xt = ALIGNX2A ? ATL_Align2Ptr(vp, A) : ATL_AlignPtr(vp);
         Mjoin(PATL,copy)(N, X, incX, x, 1);
         COPYX = 0;
      }
      else
         x = xt = (TYPE*) X;
   }
   else if (incX == 1 && !COPYXt)          /* apply alpha to X, orig vec Xt */
   {
      COPYX = 1;
      xt = (TYPE*) X;
      vp = malloc(ATL_MulBySize(MB)+ATL_Cachelen);
      if (!vp)
      {
         Mjoin(PATL,ref@(rt))(Uplo, N, alpha, X, incX, A, lda);
         return;
      }
      x = ALIGNX2A ? ATL_Align2Ptr(vp, A) : ATL_AlignPtr(vp);
   }
   else                         /* must copy both X & Xt, apply alpha to x */
   {
      COPYX = 1;
      vp = malloc(ATL_MulBySize(MB+N)+2*ATL_Cachelen);
      if (!vp)
      {
         Mjoin(PATL,ref@(rt))(Uplo, N, alpha, X, incX, A, lda);
         return;
      }
      x = ALIGNX2A ? ATL_Align2Ptr(vp, A) : ATL_AlignPtr(vp);
      xt = x + MB;
      xt = ATL_AlignPtr(xt);
      Mjoin(PATL,copy)(N, X, incX, xt, 1);
/*
 *    Set it up so that we copy from contiguous vector, not original X
 */
      xx = xt;
      incx = 1;
   }
@ROUT ATL_syr ATL_her
   Nmb = ((N-1)/mb)*mb;
   if (Uplo == AtlasUpper)
   {
      for (i=0; i < Nmb; i += mb)
      {
         n = N-i-MB;
         if (COPYX)
@ROUT ATL_syr
            Mjoin(PATL,cpsc)(MB, alpha, xx+i*incx, incx, x, 1);
         Mjoin(PATL,syr_kU)(gerk, FNU, MB, alpha, x, xt+i, A+i*(lda+1), lda);
         MY_GERK(MB, n, x, xt+i+MB, A+(MB+i)*lda+i, lda);
         if (!COPYX)
            x += MB;
@ROUT ATL_her
            Mjoin(PATL,copy)(MB, X+i*incx, incX, x, 1);
         Mjoin(PATL,her_kU)(gerk, FNU, MB, alpha, x, xh+i+i, A+i*(lda2+2), lda);
         MY_GERK(MB, n, x, xh+((i+MB)<<1), A+(MB+i)*lda2+i+i, lda);
         if (!COPYX)
            x += MB+MB;
@ROUT ATL_syr ATL_her
      }
      mb = N - Nmb;
      if (COPYX)
@ROUT ATL_syr
         Mjoin(PATL,cpsc)(mb, alpha, xx+Nmb*incx, incx, x, 1);
      Mjoin(PATL,syr_kU)(gerk, FNU, mb, alpha, x, xt+Nmb, A+Nmb*(lda+1), lda);
@ROUT ATL_her
         Mjoin(PATL,copy)(mb, X+Nmb*incx, incX, x, 1);
      Mjoin(PATL,her_kU)(gerk, FNU, mb, alpha, x, xh+Nmb+Nmb, 
                         A+Nmb*(lda2+2), lda);
@ROUT ATL_syr ATL_her
   }
   else         /* Uplo == AtlasLower */
   {
      mb = N - Nmb;
      #if ATL_MIN_RESTRICTED_M > 0
         gerk0 = gerk = (mb >= minM) ? gerk0 : ATL_GENGERK;
      #endif
      if (COPYX)
@ROUT ATL_syr
         Mjoin(PATL,cpsc)(mb, alpha, xx, incx, x, 1);
      Mjoin(PATL,syr_kL)(gerk, mb, alpha, x, xt, A, lda);
@ROUT ATL_her
         Mjoin(PATL,copy)(mb, X, incX, x, 1);
      Mjoin(PATL,her_kL)(gerk, mb, alpha, x, xh, A, lda);
@ROUT ATL_syr ATL_her
      for (i=mb; i < N; i += MB)
      {
         #if ATL_MIN_RESTRICTED_M > 0
            gerk = (i >= minN) ? gerk0 : ATL_GENGERK;
         #endif
         if (COPYX)
@ROUT ATL_syr
            Mjoin(PATL,cpsc)(MB, alpha, xx+i*incx, incx, x, 1);
         else 
            x += mb;
         MY_GERK(MB, i, x, xt, A+i, lda);
         Mjoin(PATL,syr_kL)(gerk, MB, alpha, x, xt+i, A+i*(lda+1), lda);
@ROUT ATL_her
            Mjoin(PATL,copy)(MB, X+i*incx, incX, x, 1);
         else 
            x += mb+mb;
         MY_GERK(MB, i, x, xh, A+i+i, lda);
         Mjoin(PATL,her_kL)(gerk, MB, alpha, x, xh+i+i, A+i*(lda2+2), lda);
@ROUT ATL_syr ATL_her
         mb = MB;
      }
   }
@ROUT ATL_her ATL_syr
   
   if (vp)
     free(vp);
}
@endskip
@ROUT ATL_syr2
   @define rt @syr2@
@ROUT ATL_her2
   @define rt @her2@
@ROUT ATL_her2 ATL_syr2
#include "atlas_misc.h"
#include "atlas_level1.h"
#include "atlas_lvl2.h"
#include "atlas_reflvl2.h"
#include "atlas_reflevel2.h"
#if defined(ATL_INL1)
   #include Mstr(Mjoin(Mjoin(atlas_,PRE),@(rt)_L1.h))
   #define ATL_@(rt) Mjoin(PATL,@(rt)_L1)
#elif defined(ATL_INL2)
   #include Mstr(Mjoin(Mjoin(atlas_,PRE),@(rt)_L2.h))
   #define ATL_@(rt) Mjoin(PATL,@(rt)_L2)
#else
   #include Mstr(Mjoin(Mjoin(atlas_,PRE),@(rt).h))
   #define ATL_@(rt) Mjoin(PATL,@(rt))
#endif

#ifdef ATL_NXTUNE
   extern int ATL_KERN_NX;
   #define ATL_S2NX ATL_KERN_NX
#else
   #include Mstr(Mjoin(Mjoin(atlas_,PRE),syr2NX.h))
   #ifndef ATL_S2NX
      #define ATL_S2NX 128
   #endif
#endif

@beginskip
#define MY_GERK(m_, n_, x_, y_, w_, z_, A_, lda_) \
{ \
   if (FNU) \
   { \
      ATL_CINT nnu = ((n_) >= minN && (m_) >= minM) ? ((n_)/nu)*nu : 0, \
               nr = (n_)-nnu; \
      if (nnu) \
         gerk(m_, nnu, x_, y_, w_, z_, A_, lda_); \
      if (nr) \
@ROUT ATL_syr2
         ATL_GENGERK(m_, nr, x_, (y_)+nnu, w_, (z_)+nnu, \
                     (A_)+nnu*(lda_), lda_); \
@ROUT ATL_her2
         ATL_GENGERK(m_, nr, x_, (y_)+nnu+nnu, w_, (z_)+nnu, \
                     (A_)+(nnu+nnu)*(lda_), lda_); \
@ROUT ATL_her2 ATL_syr2
   } \
   else \
      gerk(m_, n_, x_, y_, w_, z_, A_, lda_); \
}
@endskip

void Mjoin(PATL,@(rt)_kU)
(
   ATL_r2kern_t gerk0,          /* func ptr to selected GER kernel */
   ATL_CINT N,                  /* size of prob to solve */
@ROUT ATL_syr2
   const TYPE *x,               /* vector x -- alpha applied to x or y */
   const TYPE *y,               /* vector y -- alpha applied to x or y */
   TYPE *A,                     /* symmetric matrix, A = A + x*y^T + y*x^T */
@ROUT ATL_her2
   const SCALAR alpha,          /* need orig alpha to pass to ref blas */
   const TYPE *x,               /* input vector x */
   const TYPE *xh,              /* conj(alpha)*x^H */
   const TYPE *y,               /* input vector y */
   const TYPE *yh,              /* alpha * y^H */
   TYPE *A,                     /* hermitian matrix, A = A + x*y^H + y*x^H*/
@ROUT ATL_syr2 ATL_her2
   ATL_CINT lda                 /* row stride of A */
)
{
   ATL_r2kern_t gerk=gerk0;
   ATL_INT nx=(ATL_S2NX/ATL_s2U_NU)*ATL_s2U_NU, j;
@ROUT ATL_her2
   TYPE one[2] = {ATL_rone, ATL_rzero};
   ATL_CINT lda2 = lda+lda;
@ROUT ATL_syr2 ATL_her2
   ATL_CINT NN = (N/ATL_s2U_NU)*ATL_s2U_NU;

   nx = (ATL_S2NX >= ATL_s2U_NU) ? (ATL_S2NX/ATL_s2U_NU)*ATL_s2U_NU 
        : ATL_s2U_NU;
   nx = Mmin(nx,N);
@ROUT ATL_syr2   // A += x*y^T + y*x^T
   Mjoin(PATL,refsyr2U)(nx, ATL_rone, x, 1, y, 1, A, lda);
   if (nx == N)
     return;
   for (j=nx; j < NN; j += ATL_s2U_NU)
   {
      #if ATL_MIN_RESTRICTED_M > 0
         gerk = (j >= ATL_MIN_RESTRICTED_M) ? gerk0 : ATL_GENGERK;
      #endif
      gerk(j, ATL_s2U_NU, x, y+j, y, x+j, A+j*lda, lda);
      ATL_SYR2U_nu(A+j*(lda+1), lda, x+j, y+j);
   }
   nx = N - NN;
   if (nx)
   {
      ATL_GENGERK(NN, nx, x, y+NN, y, x+NN, A+NN*lda, lda);
      Mjoin(PATL,refsyr2U)(nx, ATL_rone, x+NN, 1, y+NN, 1, A+NN*(lda+1), lda);
   }
@ROUT ATL_her2
   Mjoin(PATL,refher2U)(nx, alpha, x, 1, y, 1, A, lda);
   if (nx == N)
     return;
   for (j=nx; j < NN; j += ATL_s2U_NU)
   {
      #if ATL_MIN_RESTRICTED_M > 0
         gerk = (j >= ATL_MIN_RESTRICTED_M) ? gerk0 : ATL_GENGERK;
      #endif
      gerk(j, ATL_s2U_NU, x, yh+j+j, y, xh+j+j, A+j*lda2, lda);
      ATL_HER2U_nu(A+j*(lda2+2), lda, x+j+j, y+j+j, xh+j+j, yh+j+j);
   }
   nx = N - NN;
   if (nx)
   {
      ATL_GENGERK(j, nx, x, yh+j+j, y, xh+j+j, A+j*lda2, lda);
      Mjoin(PATL,refher2U)(nx, alpha, x+j+j, 1, y+j+j, 1, A+j*(lda2+2), lda);
   }
@ROUT ATL_syr2 ATL_her2
}

void Mjoin(PATL,@(rt)_kL)
(
   ATL_r2kern_t gerk0,          /* func ptr to selected GER kernel */
   ATL_CINT N,                  /* size of prob to solve */
@ROUT ATL_syr2
   const TYPE *x,               /* vector x -- alpha applied to x or y */
   const TYPE *y,               /* vector y -- alpha applied to x or y */
   TYPE *A,                     /* symmetric matrix, A = A + x*y^T + y*x^T */
@ROUT ATL_her2
   const SCALAR alpha,          /* need orig alpha to pass to ref blas */
   const TYPE *x,               /* input vector x */
   const TYPE *xh,              /* conj(alpha)*x^H */
   const TYPE *y,               /* input vector y */
   const TYPE *yh,              /* alpha * y^H */
   TYPE *A,                     /* hermitian matrix, A = A + x*y^H + y*x^H*/
@ROUT ATL_syr2 ATL_her2
   ATL_CINT lda                 /* row stride of A */
)
{
   ATL_r2kern_t gerk=gerk0;
   ATL_INT nx=Mmin(ATL_S2NX,N), i, NN, n;
@ROUT ATL_syr2
   ATL_CINT incA = ATL_s2L_NU*(lda+1);
@ROUT ATL_her2
   ATL_CINT lda2 = lda+lda, incA =  ATL_s2L_NU*(lda2+2);
   const TYPE one[2] = {ATL_rone, ATL_rzero};
@ROUT ATL_syr2 ATL_her2

   i = N - nx;
   i = (i/ATL_s2L_NU)*ATL_s2L_NU;
   if (i != N-nx)
      nx += N-nx-i;
   NN = N - nx;
@ROUT ATL_syr2
   for (i=0; i < NN; i += ATL_s2L_NU)
   {
      ATL_SYR2L_nu(A, lda, x, y);
      n = N-i-ATL_s2L_NU;
      #if ATL_MIN_RESTRICTED_M > 0
         gerk = (n >= ATL_MIN_RESTRICTED_M) ? gerk0 : ATL_GENGERK;
      #endif
      gerk(n, ATL_s2L_NU, x+ATL_s2L_NU, y, y+ATL_s2L_NU, x, A+ATL_s2L_NU, lda);
      A += incA;
      x += ATL_s2L_NU;
      y += ATL_s2L_NU;
   }
   Mjoin(PATL,refsyr2L)(nx, ATL_rone, x, 1, y, 1, A, lda);
@ROUT ATL_her2
   for (i=0; i < NN; i += ATL_s2L_NU)
   {
      ATL_HER2L_nu(A, lda, x, y, xh, yh);
      n = N-i-ATL_s2L_NU;
      #if ATL_MIN_RESTRICTED_M > 0
         gerk = (n >= ATL_MIN_RESTRICTED_M) ? gerk0 : ATL_GENGERK;
      #endif
      gerk(n, ATL_s2L_NU, x+ATL_s2L_NU+ATL_s2L_NU, yh, y+ATL_s2L_NU+ATL_s2L_NU,
           xh, A+ATL_s2L_NU+ATL_s2L_NU, lda);
      A += incA;
      xh += ATL_s2L_NU+ATL_s2L_NU;
      x += ATL_s2L_NU+ATL_s2L_NU;
      yh += ATL_s2L_NU+ATL_s2L_NU;
      y += ATL_s2L_NU+ATL_s2L_NU;
   }
   Mjoin(PATL,refher2L)(nx, alpha, x, 1, y, 1, A, lda);
@ROUT ATL_syr2 ATL_her2
}

@ROUT ATL_syr2
void Mjoin(PATL,@(rt))(const enum ATLAS_UPLO Uplo, ATL_CINT N, 
                      const SCALAR alpha, const TYPE *X, ATL_CINT incX, 
                      const TYPE *Y, ATL_CINT incY, TYPE *A, ATL_CINT lda)
{
   void *vp=NULL;
   TYPE *x, *xt, *y, *yt;
   ATL_r2kern_t gerk;
   ATL_INT CacheElts;
   const int ALP1 = (alpha == ATL_rone);
   int nu = (Uplo == AtlasUpper) ? ATL_s2U_NU : ATL_s2L_NU;
   int mu, minM, minN, alignX, alignXt, FNU, ALIGNX2A, COPYX, COPYY;
   int ApplyAlphaToXt=0, ApplyAlphaToYt=0, YisYt, XisXt, COPYXt, COPYYt;
   size_t len;

   if (N < 1 || SCALAR_IS_ZERO(alpha))
      return;
/*
 * For small problems, avoid overhead of func calls & data copy
 */
   if (N <= ATL_S2NX)
   {
      Mjoin(PATL,ref@(rt))(Uplo, N, alpha, X, incX, Y, incY, A, lda);
      return;
   }
/*
 * Determine the GER kernel to use, and its parameters
 */
   gerk = ATL_GetR2Kern(N-nu, nu, A, lda, &mu, &nu, &minM, &minN, &alignX,
                        &ALIGNX2A, &alignXt, &FNU, &CacheElts);
/*
 * See if it is OK to have transpose vectors same as no-transpose
 */
   YisYt = XisXt = ALP1;
   if (!YisYt && alignXt > sizeof(TYPE)) /* align rest may prevent */
   {
      if (ALIGNX2A)
      {
         const size_t t1 = (size_t) A;
         if ((t1/alignXt)*alignXt != t1)
            YisYt = XisXt = 0;
      }
      else if (alignXt > alignX)
      {
         if ((alignXt/alignX)*alignX != alignXt)
            YisYt = XisXt = 0;
         else
            alignX = alignXt;
      }
      else if ((alignX/alignXt)*alignXt != alignX)
         YisYt = XisXt = 0;
   }
/*
 * See if we have to copy the no-transpose vectors
 */
   COPYY = (incY != 1);
   if (!COPYY)  /* may still need to copy due to alignment issues */
   {
/*
 *    ATL_Cachelen is the highest alignment that can be requested, so
 *    make Y's modulo with Cachelen match that of A if you want A & Y
 *    to have the same alignment
 */
      if (ALIGNX2A)
      {
         const size_t t1 = (size_t) A, t2 = (size_t) Y;
         COPYY = (t1 - ATL_MulByCachelen(ATL_DivByCachelen(t1))) !=
                 (t2 - ATL_MulByCachelen(ATL_DivByCachelen(t2)));
      }
      else if (alignX)
      {
         size_t t1 = (size_t) Y;
         COPYY = ((t1/alignX)*alignX != t1);
      }
   }
   COPYX = (incX != 1);
   if (!COPYX)  /* may still need to copy due to alignment issues */
   {
/*
 *    ATL_Cachelen is the highest alignment that can be requested, so
 *    make X's modulo with Cachelen match that of A if you want A & X
 *    to have the same alignment
 */
      if (ALIGNX2A)
      {
         size_t t1 = (size_t) A, t2 = (size_t) X;
         COPYX = (t1 - ATL_MulByCachelen(ATL_DivByCachelen(t1))) !=
                 (t2 - ATL_MulByCachelen(ATL_DivByCachelen(t2)));
      }
      else if (alignX)
      {
         size_t t1 = (size_t) X;
         COPYX = ((t1/alignX)*alignX != t1);
      }
   }
/*
 * See if we have to copy the transpose vectors
 */
   COPYYt = (incY != 1);
   if (!COPYYt && alignXt > sizeof(TYPE))
   {                /* may still need copy due to alignment issues */
      size_t t1 = (size_t) Y;
      COPYYt = ((t1/alignXt)*alignXt != t1);
   }
   COPYXt = (incX != 1);
   if (!COPYXt && alignXt > sizeof(TYPE))
   {                /* may still need copy due to alignment issues */
      size_t t1 = (size_t) X;
      COPYXt = ((t1/alignXt)*alignXt != t1);
   }
/*
 * See if applying alpha will force a copy; must apply alpha to either
 * no-transpose or transpose vectors, not mixture
 */
   if (!ALP1)
   {
      if (!COPYX && !COPYXt)
         COPYX = 1;
      else
         ApplyAlphaToXt = !COPYX;
      if (ApplyAlphaToXt)
         COPYYt = ApplyAlphaToYt = 1;
      else   /* must apply alpha to Y */
         COPYY = 1;
   }
/*
 * Compute amount of space necessary to allocate any needed vectors
 */
   len = (!YisYt) ? (COPYY + COPYYt) : (COPYY || COPYYt);
   len += (!XisXt) ? (COPYX + COPYXt) : (COPYX || COPYXt);
   len *= ATL_MulBySize(N) + ATL_Cachelen;
   x = xt = (TYPE*) X;
   y = yt = (TYPE*) Y;
   if (len)
   {
      TYPE *tp;
      tp = vp = malloc(len);
      if (!vp)
      {
         Mjoin(PATL,ref@(rt))(Uplo, N, alpha, X, incX, Y, incY, A, lda);
         return;
      }
      if (COPYYt)
      {
         if (YisYt)
         {
            tp = y = yt = (ALIGNX2A)?ATL_Align2Ptr(tp, A):ATL_AlignPtr(tp);
            COPYY = 0;
         }
         else
            tp = yt = ATL_AlignPtr(tp);
         tp += N;
      }
      if (COPYY)
      {
         tp = y = ALIGNX2A ? ATL_Align2Ptr(tp, A) : ATL_AlignPtr(tp);
         tp += N;
      }
      if (COPYXt)
      {
         if (XisXt)
         {
            tp = x = xt = (ALIGNX2A)?ATL_Align2Ptr(tp, A):ATL_AlignPtr(tp);
            COPYX = 0;
         }
         else
            tp = xt = ATL_AlignPtr(tp);
         tp += N;
      }
      if (COPYX)
         x = ALIGNX2A ? ATL_Align2Ptr(tp, A) : ATL_AlignPtr(tp);
   }
/*
 * Copy vector(s) to workspace with one pass through the input vectors
 */
   if (COPYX || COPYXt)
   {
      if (COPYX && COPYXt)
      {
         if (ALP1)  /* no scaling */
         {
            register ATL_INT i;
            for (i=0; i < N; i++, X += incX)
               x[i] = xt[i] = *X;
         }
         else  /* when both vecs copied, apply alpha to one of them */
         {
            register ATL_INT i;
            const register TYPE ra=alpha;
            TYPE *v, *z;
            if (ApplyAlphaToXt)
            {
               z = xt;
               v = x;
            }
            else
            {
               z = x;
               v = xt;
            }
            for (i=0; i < N; i++, X += incX)
            {
               const register TYPE rx=(*X);
               z[i] = rx * ra;
               v[i] = rx;
            }
         }
      }
      else if (COPYXt)
      {
         if (!ALP1)
            Mjoin(PATL,cpsc)(N, alpha, X, incX, xt, 1);
         else
            Mjoin(PATL,copy)(N, X, incX, xt, 1);
      }
      else if (COPYX)
      {
         if (!ALP1)
            Mjoin(PATL,cpsc)(N, alpha, X, incX, x, 1);
         else
            Mjoin(PATL,copy)(N, X, incX, x, 1);
      }
   }
   if (COPYY || COPYYt)
   {
      if (COPYY && COPYYt)
      {
         if (ALP1)  /* no scaling */
         {
            register ATL_INT i;
            for (i=0; i < N; i++, Y += incY)
               y[i] = yt[i] = *Y;
         }
         else  /* when both vecs copied, apply alpha to transposed vec */
         {
            register ATL_INT i;
            const register TYPE ra=alpha;
            TYPE *v, *z;
            if (ApplyAlphaToYt)
            {
               z = yt;
               v = y;
            }
            else
            {
               z = y;
               v = yt;
            }
            for (i=0; i < N; i++, Y += incY)
            {
               const register TYPE ry=(*Y);
               z[i] = ry * ra;
               v[i] = ry;
            }
         }
      }
      else if (COPYYt)
      {
         if (!ALP1)
            Mjoin(PATL,cpsc)(N, alpha, Y, incY, yt, 1);
         else
            Mjoin(PATL,copy)(N, Y, incY, yt, 1);
      }
      else if (COPYY)
      {
         if (!ALP1)
            Mjoin(PATL,cpsc)(N, alpha, Y, incY, y, 1);
         else
            Mjoin(PATL,copy)(N, Y, incY, y, 1);
      }
   }
   if (Uplo == AtlasUpper)
      Mjoin(PATL,syr2_kU)(gerk, N, x, yt, A, lda);
   else
      Mjoin(PATL,syr2_kL)(gerk, N, x, yt, A, lda);
   if (vp)
      free(vp);
}
@ROUT ATL_her2
void Mjoin(PATL,@(rt))(const enum ATLAS_UPLO Uplo, ATL_CINT N, 
                      const SCALAR alpha, const TYPE *X, ATL_CINT incX, 
                      const TYPE *Y, ATL_CINT incY, TYPE *A, ATL_CINT lda)
{
   const TYPE calpha[2]={*alpha, -alpha[1]};
   void *vp;
   TYPE *x, *xh, *y, *yh;
   ATL_r2kern_t gerk;
   ATL_INT CacheElts;
   ATL_CINT N2 = N+N, incX2=incX+incX, incY2=incY+incY;
   const int ALP1 = (alpha[0] == ATL_rone && alpha[1] == ATL_rzero);
   int nu = (Uplo == AtlasUpper) ? ATL_s2U_NU : ATL_s2L_NU;
   int mu, minM, minN, alignX, alignY, FNU, ALIGNX2A, COPYX, COPYY;
   size_t len;

   if (N < 1 || SCALAR_IS_ZERO(alpha))
      return;
/*
 * For small problems, avoid overhead of func calls & data copy
 */
   if (N <= ATL_S2NX)
   {
      Mjoin(PATL,ref@(rt))(Uplo, N, alpha, X, incX, Y, incY, A, lda);
      return;
   }

   gerk = ATL_GetR2Kern(N-nu, nu, A, lda, &mu, &nu, &minM, &minN, &alignX,
                        &ALIGNX2A, &alignY, &FNU, &CacheElts);
   COPYX = (incX != 1);
   if (!COPYX)  /* may still need to copy due to alignment issues */
   {
      if (ALIGNX2A)
      {
         const size_t t1 = (size_t) A, t2 = (size_t) X;
         COPYX = (t1 - ATL_MulByCachelen(ATL_DivByCachelen(t1))) !=
                  (t2 - ATL_MulByCachelen(ATL_DivByCachelen(t2)));
      }
      else if (alignX)
      {
         const size_t t1 = (size_t) X;
         COPYX = ((t1/alignX)*alignX != t1);
      }
   }
   COPYY = (incY != 1);
   if (!COPYY)  /* may still need to copy due to alignment issues */
   {
/*
 *    ATL_Cachelen is the highest alignment that can be requested, so
 *    make Y's modulo with Cachelen match that of A if you want A & Y to have
 *    the same alignment;  We use Y in the same way as X in GER2, so
 *    its alignment is controlled by the X align settings, while
 *    Y^H's alignment is controlled by the Y align settings.
 */
      if (ALIGNX2A)
      {
         const size_t t1 = (size_t) A, t2 = (size_t) Y;
         COPYY = (t1 - ATL_MulByCachelen(ATL_DivByCachelen(t1))) !=
                  (t2 - ATL_MulByCachelen(ATL_DivByCachelen(t2)));
      }
      else if (alignY)
      {
         const size_t t1 = (size_t) Y;
         COPYY = ((t1/alignX)*alignX != t1);
      }
   }
/*
 * Allocate work vectors, and setup vector pointers
 */
   len = ATL_Cachelen + ATL_MulBySize(N);
   len *= 2+COPYY+COPYX;
   vp = malloc(len);
   if (!vp)
   {
      Mjoin(PATL,ref@(rt))(Uplo, N, alpha, X, incX, Y, incY, A, lda);
      return;
   }
   xh = ATL_AlignPtr(vp);
   yh = xh + N + N;
   yh = ATL_AlignPtr(yh);
   y = yh + N + N;
   if (COPYX)
   {
      x = ALIGNX2A ? ATL_Align2Ptr(y, A) : ATL_AlignPtr(y);
      y = x + N + N;
   }
   else
      x = (TYPE*)X;
   if (COPYY)
      y = ALIGNX2A ? ATL_Align2Ptr(y, A) : ATL_AlignPtr(y);
   else
      y = (TYPE*)Y;
/*
 * Copy/scale work vectors using only one pass through input vectors
 */
   if (ALP1)  /* no scaling required, just conjugation */
   {
      if (COPYX)
      {
         register ATL_INT i;
         for (i=0; i < N2; i += 2, X += incX2)
         {
            const register TYPE ix = X[1];
            x[i] = xh[i] = *X;
            x[i+1] = ix;
            xh[i+1] = -ix;
         }
      }
      else
         Mjoin(PATL,copyConj)(N, X, incX, xh, 1);
      if (COPYY)
      {
         register ATL_INT i;
         for (i=0; i < N2; i += 2, Y += incY2)
         {
            const register TYPE iy = Y[1];
            y[i] = yh[i] = *Y;
            y[i+1] = iy;
            yh[i+1] = -iy;
         }
      }
      else
         Mjoin(PATL,copyConj)(N, Y, incY, yh, 1);
   }
   else if (alpha[1] == ATL_rzero) /* must apply real scalar to conjvecs */
   {
      const register TYPE ra = *alpha;
      if (COPYX)
      {
         register ATL_INT i;
         for (i=0; i < N2; i += 2, X += incX2)
         {
            const register TYPE rx = *X, ix = X[1];
            x[i] = rx;
            x[i+1] = ix;
            xh[i] = ra * rx;
            xh[i+1] = ra * (-ix);
         }
      }
      else /* xh = conj(alpha*x) */
         Mjoin(PATL,moveConj)(N, calpha, X, incX, xh, 1);
      if (COPYY)
      {
         register ATL_INT i;
         for (i=0; i < N2; i += 2, Y += incY2)
         {
            const register TYPE ry = *Y, iy = Y[1];
            y[i] = ry;
            y[i+1] = iy;
            yh[i] = ra * ry;
            yh[i+1] = ra * (-iy);
         }
      }
      else /* yh = alpha*conj(y) */
         Mjoin(PATL,moveConj)(N, alpha, Y, incY, yh, 1);
   }
   else /* must apply complex scalar to conjugated vecs */
   {
      const register TYPE ra = *alpha, ia = alpha[1];
      if (COPYX)
      {
         register ATL_INT i;
         for (i=0; i < N2; i += 2, X += incX2)
         {
            const register TYPE rx = *X, ix = X[1];
            x[i] = rx;
            x[i+1] = ix;
            xh[i] = ra * rx - ia * ix;
            xh[i+1] = -(ra * ix + ia * rx);
         }
      }
      else /* xh = conj(alpha*x) */
         Mjoin(PATL,moveConj)(N, calpha, X, incX, xh, 1);
      if (COPYY)
      {
         register ATL_INT i;
         for (i=0; i < N2; i += 2, Y += incY2)
         {
            const register TYPE ry = *Y, iy = Y[1];
            y[i] = ry;
            y[i+1] = iy;
            yh[i] = ra * ry + ia * iy;
            yh[i+1] = ia * ry - ra * iy;
         }
      }
      else /* yh = alpha*conj(y) */
         Mjoin(PATL,moveConj)(N, alpha, Y, incY, yh, 1);
   }
   if (Uplo == AtlasUpper)
      Mjoin(PATL,her2_kU)(gerk, N, alpha, x, xh, y, yh, A, lda);
   else
      Mjoin(PATL,her2_kL)(gerk, N, alpha, x, xh, y, yh, A, lda);

   free(vp);
}

@ROUT ATL_her2 ATL_syr2
@beginskip
void Mjoin(PATL,@(rt))(const enum ATLAS_UPLO Uplo, ATL_CINT N, 
                      const SCALAR alpha0, const TYPE *X, ATL_CINT incX, 
                      const TYPE *Y, ATL_CINT incY, TYPE *A, ATL_CINT lda)
{
   size_t t1, t2;
@ROUT ATL_her2
   const TYPE *alpha = alpha0;
   const TYPE one[2] = {ATL_rone, ATL_rzero}, calpha[2]={*alpha0, -alpha0[1]};
   ATL_CINT lda2 = lda+lda, incx = incX+incX, incy = incY+incY;
   const int ALPHA_IS_ONE = (alpha[0] == ATL_rone && alpha[1] == ATL_rzero);
   TYPE *x, *y, *xh, *yh;
@ROUT ATL_syr2
   const TYPE alpha = alpha0;
   TYPE alphaX = alpha0, alphaY=alpha0;
   ATL_INT incx=incX, incy=incY;
   int XisXt, YisYt, COPYYt, COPYXt, ApplyAlphaToXt=0, ApplyAlphaToYt=0;
   void *vp2;
   TYPE *x, *xt, *y, *yt;
   const int ALPHA_IS_ONE = (alpha == ATL_rone);
@ROUT ATL_syr2 ATL_her2
   void *vp=NULL;
   ATL_r2kern_t gerk, gerk0;
   int MB, NB, mb, nb, mu, nu, minM, minN, alignX, alignXt, FNU;
   int COPYX=0, COPYY, ALIGNX2A=0;
   ATL_INT CacheElts, i, n;
   ATL_CINT S2NU = (Uplo == AtlasUpper) ? ATL_s2U_NU : ATL_s2L_NU;

   if (N < 1 || SCALAR_IS_ZERO(alpha))
      return;
/*
 * For small problems, avoid overhead of func calls & data copy
 */
   if (N <= ATL_S2NX)
   {
      Mjoin(PATL,ref@(rt))(Uplo, N, alpha, X, incX, Y, incY, A, lda);
      return;
   }
/*
 * Determine the GER kernel to use, and its parameters
 */
   ATL_GetPartS2(A, lda, mb, nb);
   if (!mb || !nb || mb > N || nb > N)
   {
      MB = N-S2NU;
      NB = N-S2NU;
      mb = nb = N;
   }
   else
   {
      MB = mb;
      NB = nb;
   }
   gerk = ATL_GetR2Kern(MB, NB, A, lda, &mu, &nu, &minM, &minN, &alignX,
                        &ALIGNX2A, &alignXt, &FNU, &CacheElts);
@ROUT ATL_syr2
/*
 * See if it is OK to have transpose vectors same as no-transpose
 */
   YisYt = XisXt = ALPHA_IS_ONE;
   if (ALPHA_IS_ONE && alignXt > sizeof(TYPE)) /* align rest may prevent */
   {
      if (ALIGNX2A)
      {
         t1 = (size_t) A;
         if ((t1/alignXt)*alignXt != t1)
            YisYt = XisXt = 0;
      }
      else if (alignXt > alignX)
      {
         if ((alignXt/alignX)*alignX != alignXt)
            YisYt = XisXt = 0;
         else
            alignX = alignXt;
      }
      else if ((alignX/alignXt)*alignXt != alignX)
         YisYt = XisXt = 0;
   }
/*
 * See if we have to copy the no-transpose vectors
 */
@whiledef v X Y
   COPY@(v) = (inc@(v) != 1);
   if (!COPY@(v))  /* may still need to copy due to alignment issues */
   {
/*
 *    ATL_Cachelen is the highest alignment that can be requested, so
 *    make @(v)'s modulo with Cachelen match that of A if you want A & @(v) 
 *    to have the same alignment
 */
      if (ALIGNX2A)
      {
         t1 = (size_t) A;
         t2 = (size_t) @(v);
         COPY@(v) = (t1 - ATL_MulByCachelen(ATL_DivByCachelen(t1))) !=
                 (t2 - ATL_MulByCachelen(ATL_DivByCachelen(t2)));
      }
      else if (alignX)
      {
         t1 = (size_t) @(v);
         COPY@(v) = ((t1/alignX)*alignX != t1);
      }
   }
@endwhile
/*
 * See if we have to copy the transpose vectors
 */
@multidef vv Xt Yt
@whiledef v  X  Y
   COPY@(vv) = (inc@(v) != 1);
   if (!COPY@(vv) && alignXt > sizeof(TYPE))  
   {                /* may still need copy due to alignment issues */
      t1 = (size_t) @(v);
      COPY@(vv) = ((t1/alignXt)*alignXt != t1);
   }
   @undef vv
@endwhile
/*
 * See if applying alpha will force a copy; must apply alpha to either
 * no-transpose or transpose vectors, not mixture
 */
   if (!ALPHA_IS_ONE)
   {
      if (!COPYX && !COPYXt)
         COPYX = 1;
      else
         ApplyAlphaToXt = !COPYX;
      if (ApplyAlphaToXt)
         COPYYt = ApplyAlphaToYt = 1;
      else   /* must apply alpha to Y */
         COPYY = 1;
   }
/*
 * Compute amount of space necessary to allocate any needed vectors
 */
   i = 0;
   if (!YisYt)  /* vectors are distinct */
   {
      i += (COPYY) ? mb : 0;
      i += (COPYYt) ? N : 0;
   }
   else if (COPYY || COPYYt)
      i = N;

   if (!XisXt)  /* vectors are distinct */
   {
      i += (COPYX) ? mb : 0;
      i += (COPYXt) ? N : 0;
   }
   else if (COPYX || COPYXt)
      i += N;
/*
 * Allocate space, and set vector pointers; start out assuming all vectors
 * come from original input
 */
   x = xt = (TYPE*) X;
   y = yt = (TYPE*) Y;
   if (i)
   {
      vp2 = vp = malloc(ATL_MulBySize(i) + 4*ATL_Cachelen);
      if (!vp)
      {
         Mjoin(PATL,refsyr2)(Uplo, N, alpha, X, incX, Y, incY, A, lda);
         return;
      }
      if (COPYYt)
      {
         if (YisYt)
            yt = ALIGNX2A ? ATL_Align2Ptr(vp2, A) : ATL_AlignPtr(vp2);
         else
            yt = ATL_AlignPtr(vp2);
         if (ApplyAlphaToYt && !ALPHA_IS_ONE)
            Mjoin(PATL,cpsc)(N, alpha, Y, incY, yt, 1);
         else
            Mjoin(PATL,copy)(N, Y, incY, yt, 1);
         if (YisYt)
         {
            y = yt;
            COPYY = 0;
            incy = 1;
         }
         vp2 = yt + N;
      }
      if (COPYY)
      {
         y = ALIGNX2A ? ATL_Align2Ptr(vp2, A) : ATL_AlignPtr(vp2);
         if (ApplyAlphaToYt)
            alphaY = ATL_rone;
         vp2 = y + mb;
      }
      if (COPYXt)
      {
         if (XisXt)
            xt = ALIGNX2A ? ATL_Align2Ptr(vp2, A) : ATL_AlignPtr(vp2);
         else
            xt = ATL_AlignPtr(vp2);
         if (ApplyAlphaToXt && !ALPHA_IS_ONE)
            Mjoin(PATL,cpsc)(N, alpha, X, incX, xt, 1);
         else
            Mjoin(PATL,copy)(N, X, incX, xt, 1);
         if (XisXt)
         {
            x = xt;
            COPYX = 0;
            incx = 1;
         }
         vp2 = xt + N;
      }
      if (COPYX)
      {
         x = ALIGNX2A ? ATL_Align2Ptr(vp2, A) : ATL_AlignPtr(vp2);
         if (ApplyAlphaToXt)
            alphaX = ATL_rone;
      }
   }
/*
 * If we are copying the no-transpose vectors, see if we can copy them from
 * the transpose vectors.  This case can occur due to differing align restr.
 */
   if (COPYX && COPYXt && ALPHA_IS_ONE)
   {
      X = (const TYPE*) xt;
      incx = 1;
   }
   if (COPYY && COPYYt && ALPHA_IS_ONE)
   {
      Y = (const TYPE*) yt;
      incy = 1;
   }
@ROUT ATL_her2
   @whiledef v X Y
   COPY@(v) = (inc@(v) != 1);
   if (!COPY@(v))  /* may still need to copy due to alignment issues */
   {
/*
 *    ATL_Cachelen is the highest alignment that can be requested, so
 *    make @(v)'s modulo with Cachelen match that of A if you want A & @(v) to have
 *    the same alignment;  We use Y in the same way as X in GER2, so
 *    its alignment is controlled by the X align settings, while
 *    Y^H's alignment is controlled by the Y align settings.
 */
      if (ALIGNX2A)
      {
         t1 = (size_t) A;
         t2 = (size_t) Y;
         COPY@(v) = (t1 - ATL_MulByCachelen(ATL_DivByCachelen(t1))) !=
                 (t2 - ATL_MulByCachelen(ATL_DivByCachelen(t2)));
      }
      else if (alignX)
      {
         t1 = (size_t) @(v);
         COPY@(v) = ((t1/alignX)*alignX != t1);
      }
   }
   @endwhile
   i = N+N + (COPYX+COPYY)*mb;
   vp = malloc(ATL_MulBySize(i)+4*ATL_Cachelen);
   if (!vp)
   {
      Mjoin(PATL,ref@(rt))(Uplo, N, alpha, X, incX, Y, incY, A, lda);
      return;
   }
   xh = ATL_AlignPtr(vp);
   yh = xh + N + N;
   yh = ATL_AlignPtr(yh);
   y = yh + N + N;
   if (COPYX)
   {
      x = ALIGNX2A ? ATL_Align2Ptr(y, A) : ATL_AlignPtr(y);
      y = x + mb+mb;
   }
   else 
      x = (TYPE*) X;
   if (COPYY)
      y = ALIGNX2A ? ATL_Align2Ptr(y, A) : ATL_AlignPtr(y);
   else 
      y = (TYPE*) Y;
   if (ALPHA_IS_ONE)
   {
      Mjoin(PATL,copyConj)(N, X, incX, xh, 1);
      Mjoin(PATL,copyConj)(N, Y, incY, yh, 1);
   }
   else
   {
      Mjoin(PATL,moveConj)(N, calpha, X, incX, xh, 1); /* xh = conj(alpha*x) */
      Mjoin(PATL,moveConj)(N, alpha, Y, incY, yh, 1);  /* yh = alpha*conj(y) */
      alpha = one;
   }
@ROUT ATL_syr2 ATL_her2
   if (Uplo == AtlasUpper)
   {
      for (i=0; i < N; i += mb)
      {
         n = N-i;
         mb = Mmin(n, mb);
         n -= mb;
         #if ATL_MIN_RESTRICTED_M > 0
            if (n < minN)
               gerk = ATL_GENGERK;
         #endif
@ROUT ATL_syr2
         if (COPYX)
            Mjoin(PATL,cpsc)(mb, alphaX, X+i*incx, incx, x, 1);
         if (COPYY)
            Mjoin(PATL,cpsc)(mb, alphaY, Y+i*incy, incy, y, 1);
         Mjoin(PATL,syr2_kU)(gerk, FNU, mb, x, yt+i, A+i*(lda+1), lda);
         if (n)
            MY_GERK(mb, n, x, yt+i+mb, y, xt+i+mb, A+(mb+i)*lda+i, lda);
         if (!COPYX)
            x += mb;
         if (!COPYY)
            y += mb;
@ROUT ATL_her2
         if (COPYX)
            Mjoin(PATL,copy)(mb, X+i*incx, incX, x, 1);
         if (COPYY)
            Mjoin(PATL,copy)(mb, Y+i*incy, incY, y, 1);
         Mjoin(PATL,her2_kU)(gerk, FNU, mb, alpha0, x, xh+i+i, y, yh+i+i, 
                             A+i*(lda2+2), lda);
         if (n)
            MY_GERK(mb, n, x, yh+((i+mb)<<1), y, xh+((i+mb)<<1), 
                    A+(mb+i)*lda2+i+i, lda);
         if (!COPYX)
            x += mb+mb;
         if (!COPYY)
            y += mb+mb;
@ROUT ATL_syr2 ATL_her2
      }
   }
   else         /* Uplo == AtlasLower */
   {
      i = ((N-1)/mb)*mb;  
      MB = N - i;         /* at least MIN(mb,N) col here due to N-1 above */
      gerk0 = gerk;
      #if ATL_MIN_RESTRICTED_M > 0
         gerk = (MB >= minN) ? gerk : ATL_GENGERK;
      #endif
@ROUT ATL_syr2
      if (COPYX)
         Mjoin(PATL,cpsc)(MB, alphaX, X, incx, x, 1);
      if (COPYY)
         Mjoin(PATL,cpsc)(MB, alphaY, Y, incy, y, 1);
      Mjoin(PATL,syr2_kL)(gerk, MB, x, yt, A, lda);
@ROUT ATL_her2
      if (COPYX)
         Mjoin(PATL,copy)(MB, X, incX, x, 1);
      if (COPYY)
         Mjoin(PATL,copy)(MB, Y, incY, y, 1);
      Mjoin(PATL,her2_kL)(gerk, MB, alpha0, x, xh, y, yh, A, lda);
@ROUT ATL_syr2 ATL_her2
      for (i=MB; i < N; i += mb)
      {
         gerk = (i >= minN && mb >= minM) ? gerk0 : ATL_GENGERK;
@ROUT ATL_syr2
         if (COPYX)
            Mjoin(PATL,cpsc)(mb, alpha, X+i*incx, incx, x, 1);
         else 
            x += mb;
         if (COPYY)
            Mjoin(PATL,cpsc)(mb, alpha, Y+i*incy, incy, y, 1);
         else 
            y += mb;
         MY_GERK(mb, i, x+i, yt, y+i, xt, A+i,lda);
         Mjoin(PATL,syr2_kL)(gerk, mb, x+i, yt+i*incy, A+i*(lda+1), lda);
@ROUT ATL_her2
         if (COPYX)
            Mjoin(PATL,copy)(mb, X+i*incx, incX, x, 1);
         else 
            x += mb+mb;
         if (COPYY)
            Mjoin(PATL,copy)(mb, Y+i*incy, incY, y, 1);
         else 
            y += mb+mb;
         MY_GERK(mb, i, x+i+i, yh, y+i+i, xh, A+i+i, lda);
         Mjoin(PATL,her2_kL)(gerk, mb, alpha0, x+i+i, xh+i+i, y+i+i, yh+i+i,
                             A+i*(lda2+2), lda);
@ROUT ATL_syr2 ATL_her2
      }
   }
@ROUT ATL_her2 ATL_syr2
   
   if (vp)
     free(vp);
}
@endskip
@beginskip
@ROUT ATL_syr2
   @define rt @syr2@
   @define alp @ATL_rone@
@ROUT ATL_her2
   @define alp @alpha@
   @define rt @her2@
@ROUT ATL_her2 ATL_syr2
#include "atlas_misc.h"
#include "atlas_level1.h"
#include "atlas_reflvl2.h"
#include "atlas_reflevel2.h"
#if 0
   #include Mstr(Mjoin(Mjoin(atlas_,PRE),syr2.h))
#endif

@ROUT ATL_syr2 ATL_her2
#ifndef ATL_S2NX
  #define ATL_S2NX 28
#endif
void Mjoin(PATL,@(rt)U_k)
(
   ATL_CINT N,
   const TYPE *X,
   const TYPE *Y,
@ROUT ATL_her2
   const SCALAR alpha,  /* Need orig alpha to pass to ref HER2 */
   const TYPE *Xt,
   const TYPE *Yt,
@ROUT ATL_her2 ATL_syr2
   TYPE *A,
   ATL_CINT lda
)
{
#if 1
   Mjoin(PATL,ref@(rt))(AtlasUpper, N, @(alp), X, 1, Y, 1, A, lda);
#else
@ROUT ATL_syr2 `   const TYPE *Xt=X, *Yt=Y;`
   ATL_INT i, m, nx=(ATL_S2NX<=N) ? ATL_S2NX : N, nr = N-nx;
   #ifdef TREAL
      #define one ATL_rone
   #else
      TYPE one[2] = {ATL_rone, ATL_rzero};
   #endif
   #ifdef ATL_s2USERESTRICTK_IC
      void (*gerk_IC)(ATL_CINT, ATL_CINT, const double, const double*, 
                      ATL_CINT, const double*, ATL_CINT, double*, ATL_CINT);
   #else
      #define gerk_IC ATL_R1IC
   #endif
   #ifdef ATL_s2USERESTRICTK_OC
      void (*gerk_OC)(ATL_CINT, ATL_CINT, const double, const double*, 
                      ATL_CINT, const double*, ATL_CINT, double*, ATL_CINT);
   #else
      #define gerk_OC ATL_R1OC
   #endif

   i = (nr/ATL_s2NU)*ATL_s2NU;
   if (nr != i)
   {
      nx += nr - i;
      nr = i;
   }
   nx = (nx <= N) ? nx : N;
   Mjoin(PATL,ref@(rt))(AtlasUpper, nx, @(alp), X, 1, Y, 1, A, lda);
   if (nx == N)
      return;
   A += lda*nx SHIFT;
   Yt += nx SHIFT;
   Xt += nx SHIFT;
   #ifdef ATL_s2USERESTRICTK_OC
      gerk_OC = ATL_s2UseRestrictK_OC(M, N, A, lda) ? ATL_R1OCr : ATL_R1OC;
   #endif
   #ifdef ATL_s2USERESTRICTK_IC
      gerk_IC = ATL_s2UseRestrictK_IC(M, N, A, lda) ? ATL_R1ICr : ATL_R1IC;
   #endif

   m = nx;
   do
   {
      gerk_OC(m, ATL_s2NU, one, X, 1, Yt, 1, A, lda);
      gerk_IC(m, ATL_s2NU, one, Y, 1, Xt, 1, A, lda);
@ROUT ATL_syr2 `      ATL_SYR2U_nu(A+m, lda, X+m, Yt);`
@ROUT ATL_her2 `      ATL_HER2U_nu(A+(m SHIFT), lda, X+(m SHIFT), Y+(m SHIFT), Xt, Yt);`
      Xt += ATL_s2NU SHIFT;
      Yt += ATL_s2NU SHIFT;
      A += (ATL_s2NU*lda)SHIFT;
      m += ATL_s2NU;
      nr -= ATL_s2NU;
   }
   while (nr);
#endif
}

void Mjoin(PATL,@(rt)L_k)
(
   ATL_CINT N,          /* length of X, Y, and both dim of A */
   const TYPE *X,       /* N-length vector X */
   const TYPE *Y,       /* N-length vector Y */
@ROUT ATL_her2
   const SCALAR alpha,  /* Need orig alpha to pass to ref HER2 */
   const TYPE *Xt,      /* hermitian transpose of X with conj(alpha) applied */
   const TYPE *Yt,      /* hermitian transpose of Y with alpha applied */
@ROUT ATL_her2 ATL_syr2
   TYPE *A,             /* ldaxN matrix */
   ATL_CINT lda         /* row stride */
)
{
#if 1
   Mjoin(PATL,ref@(rt))(AtlasLower, N, @(alp), X, 1, Y, 1, A, lda);
#else
   ATL_INT i, j, m, nn, nx=(ATL_S2NX<=N) ? ATL_S2NX : N, nr = N-nx;
   #ifdef TREAL
      #define one ATL_rone
   #else
      TYPE one[2] = {ATL_rone, ATL_rzero};
   #endif
   #ifdef ATL_s2USERESTRICTK_IC
      void (*gerk_IC)(ATL_CINT, ATL_CINT, const double, const double*, 
                      ATL_CINT, const double*, ATL_CINT, double*, ATL_CINT);
   #endif
   #ifdef ATL_s2USERESTRICTK_OC
      void (*gerk_OC)(ATL_CINT, ATL_CINT, const double, const double*, 
                      ATL_CINT, const double*, ATL_CINT, double*, ATL_CINT);
   #endif

   #ifdef ATL_s2USERESTRICTK_OC
      gerk_OC = ATL_s2UseRestrictK_OC(M, N, A, lda) ? ATL_R1OCr : ATL_R1OC;
   #endif
   #ifdef ATL_s2USERESTRICTK_IC
      gerk_IC = ATL_s2UseRestrictK_IC(M, N, A, lda) ? ATL_R1ICr : ATL_R1IC;
   #endif
   i = (nr/ATL_s2NU)*ATL_s2NU;
   if (nr != i)
   {
      nx += nr - i;
      nr = i;
   }
   if (nx < N)
   {
      nn = N - nx;
      m = N;
      for (j=0; j < nn; j += ATL_s2NU)
      {
@ROUT ATL_syr2 
         ATL_SYR2L_nu(A, lda, X, Y);
         m -= ATL_s2NU;
         A += ATL_s2NU;
         gerk_OC(m, ATL_s2NU, one, X+ATL_s2NU, 1, Y, 1, A, lda);
         gerk_IC(m, ATL_s2NU, one, Y+ATL_s2NU, 1, X, 1, A, lda);
         A += lda*ATL_s2NU;
         X += ATL_s2NU;
         Y += ATL_s2NU;
@ROUT ATL_her2 
         ATL_HER2L_nu(A, lda, X, Y, Xt, Yt);
         X += ATL_s2NU+ATL_s2NU;
         Y += ATL_s2NU+ATL_s2NU;
         A += ATL_s2NU+ATL_s2NU;
         m -= ATL_s2NU;
         gerk_OC(m, ATL_s2NU, one, X, 1, Yt, 1, A, lda);
         gerk_IC(m, ATL_s2NU, one, Y, 1, Xt, 1, A, lda);
         A += lda*(ATL_s2NU+ATL_s2NU);
         Xt += ATL_s2NU+ATL_s2NU;
         Yt += ATL_s2NU+ATL_s2NU;
@ROUT ATL_her2 ATL_syr2
      }
   }
   else 
      nx = N;
   Mjoin(PATL,ref@(rt))(AtlasLower, nx, @(alp), X, 1, Y, 1, A, lda);
#endif
}

void Mjoin(PATL,@(rt))(const enum ATLAS_UPLO Uplo, ATL_CINT N, 
                      const SCALAR alpha, const TYPE *X, ATL_CINT incX, 
                      const TYPE *Y, ATL_CINT incY, TYPE *A, ATL_CINT lda)
{
#if 1
   Mjoin(PATL,ref@(rt))(Uplo, N, alpha, X, incX, Y, incY, A, lda);
#else
   TYPE *x, *y;
@ROUT ATL_her2 `   TYPE *xh, *yh;        /* hermitian transposes */`
   void *vp=NULL;
   #ifdef TCPLX
      const TYPE one[2] = {ATL_rone, ATL_rzero}, alconj[2]={*alpha, -alpha[1]};
   #endif
   #ifdef ATL_s2USERESTRICTK_IC
      void (*gerk_IC)(ATL_CINT, ATL_CINT, const TYPE, const TYPE*, 
                      ATL_CINT, const TYPE*, ATL_CINT, TYPE*, ATL_CINT);
   #endif
   #ifdef ATL_s2USERESTRICTK_OC
      void (*gerk_OC)(ATL_CINT, ATL_CINT, const TYPE, const TYPE*, 
                      ATL_CINT, const TYPE*, ATL_CINT, TYPE*, ATL_CINT);
   #endif
   ATL_INT MB, mb, nb, i, j;
@ROUT ATL_syr2 `   int APPLYALPHATOX=1, COPYX, COPYY;`
@ROUT ATL_her2 `   int COPYX, COPYY;`
   const int ALPHA_IS_ONE = SCALAR_IS_ONE(alpha);

   if (N < 1 || SCALAR_IS_ZERO(alpha))
      return;
   ATL_GetPartS2(A, lda, MB, i);
   MB = (MB/ATL_s2MU)*ATL_s2MU;
@ROUT ATL_her2 
   #ifdef ATL_s2ALIGNX2A
      COPYY = COPYX = 1;
   #else
      COPYX = (incX != 1);
      COPYY = (incY != 1);
   #endif
   i = (COPYX+COPYY)*N + N+N;
   vp = malloc(ATL_MulBySize(i) + 4*ATL_Cachelen);
   if (!vp)
   {
      Mjoin(PATL,ref@(rt))(Uplo, N, alpha, X, incX, Y, incY, A, lda);
      return;
   }
   xh = ATL_AlignPtr(vp);
   yh = xh + N+N;
   yh = ATL_AlignPtr(yh);
   if (COPYY)
   {
      y = yh + N+N;
      #ifdef ATL_s2ALIGNX2A
         y = ATL_Align2Ptr(y, A);
      #else
         y = ATL_AlignPtr(y);
      #endif
      Mjoin(PATL,copy)(N, Y, incY, y, 1);
   }
   else
      y = (TYPE*) Y;
   if (COPYX)
   {
      x = COPYY ? y+N+N : yh+N+N;
      #ifdef ATL_s2ALIGNX2A
         x = ATL_Align2Ptr(x, A);
      #else
         x = ATL_AlignPtr(x);
      #endif
      Mjoin(PATL,copy)(N, X, incX, x, 1);
   }
   else
      x = (TYPE*) X;
   Mjoin(PATL,moveConj)(N, alpha, y, 1, yh, 1);   /* yh = alpha*conj(y) */
   Mjoin(PATL,moveConj)(N, alconj, x, 1, xh, 1);  /* xh = conj(alpha*x) */
@ROUT ATL_syr2 
   #ifdef ATL_s2ALIGNX2A
      COPYX = 1;
   #else
      COPYX = (incX != 1);
   #endif
   COPYY = (incY != 1);
   if (COPYX == 0 && COPYY == 0)        /* Neither presently copied */
      APPLYALPHATOX = COPYX = 1;
   else if (COPYX == COPYY)             /* both are being copied */
      APPLYALPHATOX = 0;
   else
      APPLYALPHATOX = COPYX;
   i = (COPYX+COPYY)*N;
   if (i)
   {
      vp = malloc(ATL_MulBySize(i) + 2*ATL_Cachelen);
      if (!vp)
      {
         Mjoin(PATL,ref@(rt))(Uplo, N, alpha, X, incX, Y, incY, A, lda);
         return;
      }
      if (COPYY)
      {
         y = COPYX ? (void*)(((char*)vp)+ATL_MulBySize(N)+ATL_Cachelen) : vp;
         y = ATL_AlignPtr(y);
         if (!APPLYALPHATOX && !ALPHA_IS_ONE)
            Mjoin(PATL,cpsc)(N, alpha, Y, incY, y, 1);
         else
            Mjoin(PATL,copy)(N, Y, incY, y, 1);
      }
      else
         y = (TYPE*)Y;
      if (COPYX)
      {
         #ifdef ATL_s2ALIGNX2A
            x = ATL_Align2Ptr(vp, A);
         #else
            x = ATL_AlignPtr(vp);
         #endif
         if (APPLYALPHATOX && !ALPHA_IS_ONE)
            Mjoin(PATL,cpsc)(N, alpha, X, incX, x, 1);
         else
            Mjoin(PATL,copy)(N, X, incX, x, 1);

      }
      else 
         x = (TYPE*) X;
   }
   else
   {
      x = (TYPE*) X;
      y = (TYPE*) Y;
   }
@ROUT ATL_syr2 ATL_her2
   #ifdef ATL_s2USERESTRICTK_OC
      gerk_OC = ATL_s2UseRestrictK_OC(M, N, A, lda) ? ATL_R1OCr : ATL_R1OC;
   #endif
   #ifdef ATL_s2USERESTRICTK_IC
      gerk_IC = ATL_s2UseRestrictK_IC(M, N, A, lda) ? ATL_R1ICr : ATL_R1IC;
   #endif
   if (Uplo == AtlasUpper)
   {
      mb = mb <= N ? mb : N;
      for (i=0; i < N; i += MB)
      {
         mb = N-i;
         mb = Mmin(mb, MB);
@ROUT ATL_syr2
         Mjoin(PATL,syr2U_k)(mb, x+i, y+i, A+i+i*lda, lda);
@ROUT ATL_her2
         Mjoin(PATL,her2U_k)(mb, x+i+i, y+i+i, alpha, xh+i+i, yh+i+i, 
                             A+((i+i*lda)<<1), lda);
@ROUT ATL_syr2 ATL_her2
         for (j=i+mb; j < N; j += ATL_s2NU)
         {
            nb = N-j;
            nb = Mmin(nb, ATL_s2NU);
@ROUT ATL_syr2
            gerk_OC(mb, nb, one, x+i, 1, y+j, 1, A+i+j*lda, lda);
            gerk_IC(mb, nb, one, y+i, 1, x+j, 1, A+i+j*lda, lda);
@ROUT ATL_her2
            gerk_OC(mb, nb, one, x+i+i, 1, yh+j+j, 1, 
                    A+((i+j*lda)<<1), lda);
            gerk_IC(mb, nb, one, y+i+i, 1, xh+j+j, 1, 
                    A+((i+j*lda)<<1), lda);
@ROUT ATL_syr2 ATL_her2
         }
      }
   }
   else
   {
      for (i=0; i < N; i += MB)
      {
         mb = N-i;
         mb = Mmin(mb, MB);
         for (j=0; j < i; j += ATL_s2NU)
         {
            nb = N-j;
            nb = Mmin(nb, ATL_s2NU);
@ROUT ATL_syr2
            gerk_OC(mb, nb, one, x+i, 1, y+j, 1, A+i+j*lda, lda);
            gerk_IC(mb, nb, one, y+i, 1, x+j, 1, A+i+j*lda, lda);
@ROUT ATL_her2
            gerk_OC(mb, nb, one, x+i+i, 1, yh+j+j, 1, 
                    A+((i+j*lda)<<1), lda);
            gerk_IC(mb, nb, one, y+i+i, 1, xh+j+j, 1, 
                    A+((i+j*lda)<<1), lda);
@ROUT ATL_syr2 ATL_her2
         }
@ROUT ATL_syr2
         Mjoin(PATL,syr2L_k)(mb, x+i, y+i, A+i*(lda+1), lda);
@ROUT ATL_her2
         Mjoin(PATL,her2L_k)(mb, x+i+i, y+i+i, alpha, xh+i+i, yh+i+i, 
                             A+i*((lda+1)SHIFT), lda);
@ROUT ATL_syr2 ATL_her2
      }
   }
   if (vp)
      free(vp);
#endif
}
@endskip
@ROUT ATL_mvnk_Mlt16
   @define kn @mvn@
@ROUT ATL_mvtk_Mlt16
   @define kn @mvt@
@ROUT ATL_mvtk_Mlt16 ATL_mvnk_Mlt16
@extract -b @(topd)/cw.inc lang=c -define cwdate 2010
#include "atlas_misc.h"
#include "atlas_lvl2.h"
#include "atlas_lvl3.h"
#include "atlas_reflevel2.h"

@SKIP for Trans, be is BETA, and is ignored for NoTrans
@BEGINPROC mvMU M be
@ROUT ATL_mvnk_Mlt16 `static void ATL_@(kn)_Meq@(M)`
@ROUT ATL_mvtk_Mlt16 `static void ATL_@(kn)_Meq@(M)_b@(be)`
   (ATL_CINT M, ATL_CINT N, const SCALAR alpha, const TYPE *A, ATL_CINT lda,
    const TYPE *X, ATL_CINT incX, const SCALAR beta, TYPE *Y, ATL_CINT incY)
{
   register int j;
   @declare "   register TYPE " n n ";"
      @ROUT ATL_mvtk_Mlt16 `y0`
      @ROUT ATL_mvnk_Mlt16 `x0`
      @define i @0@
      @iwhile i < @(M)
         @ROUT ATL_mvtk_Mlt16 `x@(i)`
         @ROUT ATL_mvnk_Mlt16 `y@(i)`
      @iexp i 1 @(i) +
      @endiwhile
   @enddeclare

   @ROUT ATL_mvnk_Mlt16
      @iexp i 0 0 +
      @iwhile i < @(M)
   y@(i) = ATL_rzero;
      @iexp i 1 @(i) +
      @endiwhile
   @ROUT ATL_mvtk_Mlt16
      @iexp i 0 0 +
      @iwhile i < @(M)
   x@(i) = alpha * X[@(i)*incX];
      @iexp i 1 @(i) +
      @endiwhile
@ROUT ATL_mvtk_Mlt16 ATL_mvnk_Mlt16
   for (j=0; j < N; j++)
   {
   @ROUT ATL_mvnk_Mlt16
      x0 = *X;
      @iexp i 0 0 +
   @ROUT ATL_mvtk_Mlt16
      @mif be = "1
      *Y += *A * x0
      @endmif
      @mif be = "0
      *Y = *A * x0
      @endmif
      @mif be = "X
      *Y = beta * *Y + *A * x0
      @endmif
   @iexp i 1 0 +
   @ROUT ATL_mvtk_Mlt16 ATL_mvnk_Mlt16
   @iwhile i < @(M)
      @ROUT ATL_mvtk_Mlt16
           + A[@(i)] * x@(i)
      @ROUT ATL_mvnk_Mlt16
      y@(i) += A[@(i)] * x0;      
      @ROUT ATL_mvtk_Mlt16 ATL_mvnk_Mlt16
   @iexp i 1 @(i) +
   @endiwhile
   @ROUT ATL_mvtk_Mlt16 `           ;`
      A += lda;
   @ROUT ATL_mvnk_Mlt16 `      X += incX;`
   @ROUT ATL_mvtk_Mlt16 `      Y += incY;`
   }
   @ROUT ATL_mvnk_Mlt16 
   if (beta == ATL_rzero)
   {
      @iexp i 0 0 +
      @iwhile i < @(M)
      Y[@(i)*incY] = y@(i)*alpha;
      @iexp i 1 @(i) +
      @endiwhile
   }
   else if (beta == ATL_rone)
   {
      @iexp i 0 0 +
      @iwhile i < @(M)
      Y[@(i)*incY] += y@(i)*alpha;
      @iexp i 1 @(i) +
      @endiwhile
   }
   else
   {
      @iexp i 0 0 +
      @iwhile i < @(M)
      Y[@(i)*incY] = y@(i)*alpha + beta*Y[@(i)*incY];
      @iexp i 1 @(i) +
      @endiwhile
   }
   @ROUT ATL_mvtk_Mlt16 ATL_mvnk_Mlt16
   @undef i
}
@ENDPROC

#ifdef TREAL
@ROUT ATL_mvnk_Mlt16
   @define j @1@
   @iwhile j < 16
      @callproc mvMU @(j) 1
      @iexp j @(j) 1 +
   @endiwhile
   @undef j
@ROUT ATL_mvtk_Mlt16
   @define j @1@
   @iwhile j < 16
      @whiledef b 0 1 X
         @callproc mvMU @(j) @(b)
      @endwhile
      @iexp j @(j) 1 +
   @endiwhile
   @undef j

@ROUT ATL_mvtk_Mlt16 ATL_mvnk_Mlt16
typedef void (*ATL_MVFUNC)
   (ATL_CINT M, ATL_CINT N, const SCALAR alpha, const TYPE *A, ATL_CINT lda,
    const TYPE *X, ATL_CINT incX, const SCALAR beta, TYPE *Y, ATL_CINT incY);
#endif

void Mjoin(PATL,@(kn)k_Mlt16)
   (ATL_CINT M, ATL_CINT N, const SCALAR alpha, const TYPE *A, ATL_CINT lda,
    const TYPE *X, ATL_CINT incX, const SCALAR beta, TYPE *Y, ATL_CINT incY)
/*
 * y = alpha*A*x + beta*y
@ROUT ATL_mvtk_Mlt16
 * A is MxN, so X is of length N and Y is of length M.
 *
 * For now, just call axpy-based implementation.  Need to fix using unrollings
 * ASAP.
@ROUT ATL_mvtk_Mlt16
 * A is MxN, so X is of length M and Y is of length N (A stores transposed mat)
 *
 * ATLAS's normal MVT kernels are optimized for long-M, and loop over M
 * in the innermost loop.  To avoid this killing us on short, wide matrices,
 * have special case code for M < 16 (which allows all kernels to assume
 * M >= 16).
 *
 * NOTE: for right now, just call dot-prod implementation in order to get
 *       things working.  This is terrible for perf, so need to fix using
 *       unrolling as in GER ASAP.
@ROUT ATL_mvtk_Mlt16 ATL_mvnk_Mlt16
 */
{
#ifdef TREAL
@ROUT ATL_mvnk_Mlt16
   const static ATL_MVFUNC mvfunc[15] = {ATL_mvn_Meq1,
@define i @2@
@iwhile i < 15
                                         ATL_mvn_Meq@(i),
   @iexp i @(i) 1 +
@endiwhile
                                         ATL_mvn_Meq15 
                                         };
@ROUT ATL_mvtk_Mlt16
   @whiledef be 0 1 X
   const static ATL_MVFUNC mvfunc_b@(be)[15] = {ATL_mvt_Meq1_b@(be),
   @define i @2@
   @iwhile i < 15
                                                ATL_mvt_Meq@(i)_b@(be),
   @iexp i @(i) 1 +
   @endiwhile
                                                ATL_mvt_Meq15_b@(be) 
                                               };
@endwhile
@ROUT ATL_mvtk_Mlt16 ATL_mvnk_Mlt16

   if ( M < 1 || N < 1 || (SCALAR_IS_ZERO(alpha) && SCALAR_IS_ONE(beta)) )
      return;
/*
 * Base max unrolling we use on how many regs we think we have 
 */
   #ifdef ATL_GAS_x8664
   if (M > 14)
   #elif defined(ATL_GAS_x8632)
   if (M > 6)
   #else
   if (M > 15)
   #endif
   {
      Mjoin(PATL,@(kn)k_smallN)(M, N, alpha, A, lda, X, incX, beta, Y, incY);
      return;
   }
@ROUT ATL_mvtk_Mlt16
   if (beta == ATL_rone)
      mvfunc_b1[M-1](M, N, alpha, A, lda, X, incX, beta, Y, incY);
   else if (beta == ATL_rzero)
      mvfunc_b0[M-1](M, N, alpha, A, lda, X, incX, beta, Y, incY);
   else
      mvfunc_bX[M-1](M, N, alpha, A, lda, X, incX, beta, Y, incY);
@ROUT ATL_mvnk_Mlt16
   mvfunc[M-1](M, N, alpha, A, lda, X, incX, beta, Y, incY);
@ROUT ATL_mvtk_Mlt16 ATL_mvnk_Mlt16
#else
   #ifndef TUNING
   if (M <= 8)
@ROUT ATL_mvnk_Mlt16
      Mjoin(PATL,refgemv)(AtlasNoTrans, M, N, alpha, A, lda, X, incX, 
                          beta, Y, incY);
@ROUT ATL_mvtk_Mlt16
      Mjoin(PATL,refgemv)(AtlasTrans, N, M, alpha, A, lda, X, incX, 
                          beta, Y, incY);
@ROUT ATL_mvtk_Mlt16 ATL_mvnk_Mlt16
   else
   #endif
      Mjoin(PATL,@(kn)k_smallN)(M, N, alpha, A, lda, X, incX, beta, Y, incY);
#endif
}
@ROUT ATL_mvnk_smallN
@extract -b @(topd)/cw.inc lang=c -define cwdate 2010
#include "atlas_misc.h"
#include "atlas_level1.h"
#include "atlas_lvl2.h"
#include "atlas_lvl3.h"

void Mjoin(PATL,mvnk_smallN)
   (ATL_CINT M, ATL_CINT N, const SCALAR alpha, const TYPE *A, ATL_CINT lda,
    const TYPE *X, ATL_CINT incX, const SCALAR beta, TYPE *Y, ATL_CINT incY)
/*
 * y = alpha*A*x + beta*y, A is MxN, len(X) = N, len(Y) = M
 */
#ifdef TREAL
{
   ATL_INT j;

   if (alpha == ATL_rzero)
   {
      if (beta == ATL_rzero)
         Mjoin(PATL,zero)(M, Y, incY);
      else if (beta != ATL_rone)
         Mjoin(PATL,scal)(M, beta, Y, incY);
      return;
   }
   if (beta == ATL_rzero)
   {
      Mjoin(PATL,cpsc)(M, *X * alpha, A, 1, Y, incY);
      A += lda;
      j = 1;
      X += incX;
   }
   else if (beta != ATL_rone)
   {
      Mjoin(PATL,axpby)(M, *X * alpha, A, 1, beta, Y, incY);
      A += lda;
      j = 1;
      X += incX;
   }
   else
      j=0;
   for (; j < N; j++, A += lda, X += incX)
      Mjoin(PATL,axpy)(M, *X * alpha, A, 1, Y, incY);
}
#else
{
   TYPE xx[2];
   const register TYPE ral=(*alpha), ial=alpha[1], rbe=(*beta), ibe=beta[1];
   register TYPE rx, ix;
   ATL_INT j;
   ATL_CINT lda2 = lda+lda, incX2 = incX+incX;

/*
 * Handle alpha=0 case where A & X don't matter
 */
   if (ral == ATL_rzero && ial == ATL_rzero)
   {
      if (ibe == ATL_rzero)
      {
         if (rbe == ATL_rzero)
            Mjoin(PATL,zero)(M, Y, incY);
         else if (rbe != ATL_rone)
            Mjoin(PATL,scal)(M, beta, Y, incY);
      }
      else
         Mjoin(PATL,scal)(M, beta, Y, incY);
      return;
   }
/*
 * Apply beta only on first write of Y
 */
   if (rbe == ATL_rzero && ibe == ATL_rzero)
   {
      rx = *X; ix = X[1];
      xx[0] = rx*ral - ix*ial;
      xx[1] = rx*ial + ix*ral;
      Mjoin(PATL,cpsc)(M, xx, A, 1, Y, incY);
      A += lda2;
      j = 1;
      X += incX2;
   }
   else if (rbe != ATL_rone || ibe != ATL_rzero)
   {
      rx = *X; ix = X[1];
      xx[0] = rx*ral - ix*ial;
      xx[1] = rx*ial + ix*ral;
      Mjoin(PATL,axpby)(M, xx, A, 1, beta, Y, incY);
      A += lda2;
      j = 1;
      X += incX2;
   }
   else
      j=0;
   for (; j < N; j++, A += lda2, X += incX2)
   {
      rx = *X;
      ix = X[1];
      xx[0] = rx*ral - ix*ial;
      xx[1] = rx*ial + ix*ral;
      Mjoin(PATL,axpy)(M, xx, A, 1, Y, incY);
   }
}
#endif
@ROUT ATL_mvtk_smallN
@extract -b @(topd)/cw.inc lang=c -define cwdate 2010
#include "atlas_misc.h"
#include "atlas_level1.h"
#include "atlas_lvl2.h"
#include "atlas_lvl3.h"

void Mjoin(PATL,mvtk_smallN)
   (ATL_CINT M, ATL_CINT N, const SCALAR alpha, const TYPE *A, ATL_CINT lda,
    const TYPE *X, ATL_CINT incX, const SCALAR beta, TYPE *Y, ATL_CINT incY)
/*
 * y = alpha*A*x + beta*y
 * A is MxN, so X is of length M and Y is of length M
 * NOTE: this routines is usually called for cleanup or when N is too small
 *       to allow for vector copies
 * This routine calls dot product, in the hope that the Level 1 has been
 * at least somewhat tuned to the architecture.
 */
{
#ifdef TREAL
   TYPE y0, dot;
   ATL_INT j;
   ATL_CINT BetaIsNonZero = (beta != ATL_rzero);

   for (j=0; j < N; j++, A += lda, Y += incY)
   {
      y0 = (BetaIsNonZero) ? *Y * beta : ATL_rzero;
      dot = alpha * Mjoin(PATL,dot)(M, A, 1, X, incX);
      *Y = y0 + dot;
   }
#else
   TYPE ry, iy, rd, id, tmp;
   const TYPE rbe = *beta, ibe = beta[1], ral = *alpha, ial = alpha[1];
   ATL_CINT lda2 = lda+lda, incY2 = incY+incY; 
   ATL_INT j;

   if (ibe == ATL_rzero) /* real scalar */
   {
      if (rbe == ATL_rzero)     /* beta is zero */
      {
         for (j=0; j < N; j++, A += lda2, Y += incY2)
         {
            Mjoin(PATL,dotu_sub)(M, A, 1, X, incX, Y);
            rd = Y[0];
            id = Y[1];
            tmp = rd*ral - id*ial;
            id  = rd*ial + id*ral;
            *Y = tmp;
            Y[1] = id;
         }
      }
      else if (rbe == ATL_rone) /* beta is one */
      {
         for (j=0; j < N; j++, A += lda2, Y += incY2)
         {
            ry = *Y;
            iy = Y[1];
            Mjoin(PATL,dotu_sub)(M, A, 1, X, incX, Y);
            rd = Y[0];
            id = Y[1];
            tmp = rd*ral - id*ial;
            id  = rd*ial + id*ral;
            *Y = ry+tmp;
            Y[1] = iy+id;
         }
      }
      else                      /* beta is arbitrary real scalar */
      {
         for (j=0; j < N; j++, A += lda2, Y += incY2)
         {
            ry = *Y * rbe;
            iy = Y[1] * rbe;
            Mjoin(PATL,dotu_sub)(M, A, 1, X, incX, Y);
            rd = Y[0];
            id = Y[1];
            tmp = rd*ral - id*ial;
            id  = rd*ial + id*ral;
            *Y = ry+tmp;
            Y[1] = iy+id;
         }
      }
   }
   else /* beta is a complex scalar */
   {
      for (j=0; j < N; j++, A += lda2, Y += incY2)
      {
         ry = *Y;
         iy = Y[1];
         tmp = ry*rbe - iy*ibe;
         iy  = ry*ibe + iy*rbe;
         ry  = tmp;
         Mjoin(PATL,dotu_sub)(M, A, 1, X, incX, Y);
         rd = Y[0];
         id = Y[1];
         tmp = rd*ral - id*ial;
         id  = rd*ial + id*ral;
         *Y = ry+tmp;
         Y[1] = iy+id;
      }
   }
#endif
}
@ROUT ATL_gemvT
@extract -b @(topd)/cw.inc lang=c -define cwdate 2010
#include "atlas_misc.h"
#include "atlas_lvl2.h"
#include "atlas_lvl3.h"
#if defined(ATL_INL1)
   #include Mstr(Mjoin(Mjoin(atlas_,PRE),mvt_L1.h))
#elif defined(ATL_INL2)
   #include Mstr(Mjoin(Mjoin(atlas_,PRE),mvt_L2.h))
#else
   #include Mstr(Mjoin(Mjoin(atlas_,PRE),mvt.h))
#endif

#ifdef ATL_INL1
   #define ATL_gemv Mjoin(PATL,gemvT_L1)
#elif defined(ATL_INL2)
   #define ATL_gemv Mjoin(PATL,gemvT_L2)
#else
   #define ATL_gemv Mjoin(PATL,gemvT)
#endif
void ATL_gemv
   (ATL_CINT M, ATL_CINT N, const SCALAR alpha0, const TYPE *A, ATL_CINT lda,
    const TYPE *X, ATL_CINT incX, const SCALAR beta0, TYPE *Y, ATL_CINT incY)
/*
 * y = alpha*A*x + beta*y
 */
{
   void (*getX)(const int N, const SCALAR alpha, const TYPE *X,
                const int incX, TYPE *Y, const int incY);
   ATL_mvkern_t mvtk, mvtk_b1, mvtk_b0;
   void *vp=NULL;
   TYPE *x = (TYPE*)X, *y = (TYPE*)Y;
   size_t t1, t2;
   ATL_INT m, Nm, nr, CacheElts, mb, imb, incy=1;
   int mu, nu, alignX, alignY, ALIGNX2A, ForceNU, COPYX, COPYY, APPLYALPHAX;
   int minM, minN;
   #ifdef TREAL
      #define one ATL_rone
      #define Zero ATL_rzero
      TYPE alpha = alpha0, beta = beta0;
      const int ALPHA_IS_ONE = (alpha0 == ATL_rone);
   #else
      TYPE one[2] = {ATL_rone, ATL_rzero}; 
      #ifdef Conj_
         TYPE *alpha=one;
      #else
         TYPE *alpha=(TYPE*)alpha0;
      #endif
      TYPE Zero[2] = {ATL_rzero, ATL_rzero};
      TYPE *beta = (TYPE*) beta0;
      const int ALPHA_IS_ONE = (alpha0[0] == ATL_rone && alpha[1] == ATL_rzero);
   #endif

   if (M < 1 || N < 1)          /* F77 BLAS doesn't scale in either case */
      return;
   if (SCALAR_IS_ZERO(alpha))   /* No contrib from alpha*A*x */
   {
      if (!SCALAR_IS_ONE(beta))
      {
         if (SCALAR_IS_ZERO(beta))
            Mjoin(PATL,zero)(N, Y, incY);
         else
            Mjoin(PATL,scal)(N, beta, Y, incY);
      }
      return;
   }
/*
 * ATLAS's MVT kernels loop over M in inner loop, which is bad news if M is
 * very small.  Call code that requires no copy of X & Y for these degenerate
 * cases
 */
   if (M < 16)
   {
      Mjoin(PATL,mvtk_Mlt16)(M, N, alpha0, A, lda, X, incX, beta0, Y, incY);
      return;
   }
/*
 * Get mvtk kernel pointer along with any usage guidelines, and use the
 * optimized CacheElts to compute the correct blocking factor
 */
   mvtk_b1 = ATL_GetMVTKern(M, N, A, lda, &mvtk_b0, &mu, &nu, 
                            &minM, &minN, &alignX, &ALIGNX2A, &alignY, 
                            &ForceNU, &CacheElts);
/*
 * Set up to handle case where kernel requres N to be a multiple if NU
 */
   if (ForceNU)
   {
      Nm = (N/nu)*nu;
      nr = N - Nm;
   }
   else
   {
      Nm = N;
      nr = 0;
   }
/*
 * For very small N, we can't afford the data copy, so call special case code
 */
   if (N < 4 || Nm < 1)
   {
      Mjoin(PATL,mvtk_smallN)(M, N, alpha0, A, lda, X, incX, beta0, Y, incY);
      return;
   }
   if (CacheElts)
   {
      mb = (CacheElts - 2*nu) / (2*(nu+1));
      mb = (mb > mu) ? (mb/mu)*mu : M;
      mb = (mb > M) ? M : mb;
   }
   else
      mb = M;
/*
 *****************************************************************************
 Figure out whether vecs need be copied, and which one will be scaled by alpha
 *****************************************************************************
 */
   COPYY = (incY != 1);
   if (!COPYY && alignY)
   {
      t1 = (size_t) Y;
      COPYY = ((t1/alignY)*alignY != t1);
   }
   COPYX = (incX != 1);
   if (!COPYX)  /* may still need to copy due to alignment issues */
   {
/*
 *    ATL_Cachelen is the highest alignment that can be requested, so
 *    make X's % with Cachelen match that of A if you want A & X to have
 *    the same alignment
 */
      if (ALIGNX2A)
      {
         t1 = (size_t) A;
         t2 = (size_t) X;
         COPYX = (t1 - ATL_MulByCachelen(ATL_DivByCachelen(t1))) !=
                 (t2 - ATL_MulByCachelen(ATL_DivByCachelen(t2)));
      }
      else if (alignX)
      {
         t1 = (size_t) X;
         COPYX = ((t1/alignX)*alignX != t1);
      }
   }
   if (COPYX != COPYY)         /* if only one of them is being copied */
      APPLYALPHAX = COPYX;     /* apply alpha to that one */
   else if (!COPYY && !COPYX)  /* nobody currently being copied means */
   {                           /* we need to force a copy to apply alpha */
      APPLYALPHAX = (M < N);   /* apply alpha to shorter vector */
      if (!ALPHA_IS_ONE)       /* force copy if alpha != 1.0 */
      {
         COPYX = APPLYALPHAX;
         COPYY = !APPLYALPHAX;
      }
   }
   else                        /* if both are being copied anyway */
      APPLYALPHAX = 0;         /* apply alpha during update of Y */

   if (COPYX | COPYY)         /* if I need to copy either vector */
   {                          /* allocate & align them */
      vp = malloc(ATL_MulBySize(COPYX*mb+COPYY*N) + 2*ATL_Cachelen);
/*
 *    If we cannot allocate enough space to copy the vectors, give up and
 *    call the simple loop-based implementation
 */
      if (!vp)
      {
         Mjoin(PATL,mvtk_smallN)(M, N, alpha0, A, lda, X, incX, beta0, Y, incY);
         return;
      }
      if (COPYY)
      {
         y = ATL_AlignPtr(vp);
         x = y + (N SHIFT);
         x = (ALIGNX2A) ? ATL_Align2Ptr(x, A) : ATL_AlignPtr(x);
         beta = Zero;
         alpha = one;
      }
      else if (ALIGNX2A)
         x = ATL_Align2Ptr(vp, A);
      else
         x = ATL_AlignPtr(vp);
   }
/*
 * Apply beta to Y if we aren't copying Y
 */
   if (!COPYY && !SCALAR_IS_ONE(beta0))
   {
      if (SCALAR_IS_ZERO(beta0))
         beta = Zero;
      else
      {
         Mjoin(PATL,scal)(N, beta0, Y, incY);
         beta = one;
      }
   }
   getX = (COPYX) ? Mjoin(PATL,cpsc) : NULL;
   mvtk = (COPYY || SCALAR_IS_ZERO(beta)) ? mvtk_b0 : mvtk_b1;
   m = M;
   do
   {
      imb = Mmin(mb, m);
      if (getX)    /* copy X if necessary */
         getX(imb, alpha, X, incX, x, 1);
      else
         x = (TYPE*) X;
/*
 *    Call optimized kernel (can be restricted or general)
 */
      if (imb >= minM)
         mvtk(imb, Nm, A, lda, x, y);
      else
         Mjoin(PATL,mvtk_Mlt16)(imb, Nm, one, A, lda, x, 1, beta, y, 1);
/*
 *    Some kernels require N%NU=0; if so nr is remainder, do cleanup with axpy
 */
      if (nr)
         Mjoin(PATL,mvtk_smallN)(imb, nr, one, A+((size_t)lda)*(Nm SHIFT), lda, 
                                 x, 1, beta, y+(Nm SHIFT), 1);
      beta = one;
      mvtk = mvtk_b1;
      A += imb SHIFT;
      X += (imb*incX)SHIFT;
      m -= imb;
      imb = Mmin(m,mb);
   }
   while(m);

   if (COPYY)  /* move Y back to user's vector */
      Mjoin(PATL,axpby)(N, alpha0, y, 1, beta0, Y, incY);
   if (vp)
      free(vp);
}
@ROUT ATL_gemvCT
@extract -b @(topd)/cw.inc lang=c -define cwdate 2010
#include "atlas_misc.h"
#include "atlas_lvl2.h"
#include "atlas_lvl3.h"
#include "atlas_reflevel2.h"
#if defined(ATL_INL1)
   #include Mstr(Mjoin(Mjoin(atlas_,PRE),mvt_L1.h))
#elif defined(ATL_INL2)
   #include Mstr(Mjoin(Mjoin(atlas_,PRE),mvt_L2.h))
#else
   #include Mstr(Mjoin(Mjoin(atlas_,PRE),mvt.h))
#endif

#ifdef ATL_INL1
   #define ATL_gemv Mjoin(PATL,gemvCT_L1)
#elif defined(ATL_INL2)
   #define ATL_gemv Mjoin(PATL,gemvCT_L2)
#else
   #define ATL_gemv Mjoin(PATL,gemvCT)
#endif
void ATL_gemv
   (ATL_CINT M, ATL_CINT N, const SCALAR alpha0, const TYPE *A, ATL_CINT lda,
    const TYPE *X, ATL_CINT incX, const SCALAR beta0, TYPE *Y, ATL_CINT incY)
/*
 * Y = alpha*conj(A)*X + beta*Y
 * For Conjugate transpose, first form x = conj(X), y = A^T * conj(X),
 * then use axpbyConj to add this to original Y in the operation
 * Y = beta*Y + alpha*conj(y) = beta*Y + alpha*(A^H * X), which is
 * Y = beta*Y + alpha * A^H * X.
 */
{
   ATL_mvkern_t mvtk, mvtk_b1, mvtk_b0;
   void *vp=NULL;
   TYPE *x = (TYPE*)X, *y = (TYPE*)Y;
   size_t t1, t2;
   ATL_INT m, Nm, nr, CacheElts, mb, imb, incy=1;
   int mu, nu, alignX, alignY, ALIGNX2A, ForceNU, COPYX, COPYY, APPLYALPHAX;
   int minM, minN;
   TYPE one[2] = {ATL_rone, ATL_rzero}; 
   TYPE Zero[2] = {ATL_rzero, ATL_rzero};
   TYPE *beta = (TYPE*) beta0;
   const int ALPHA_IS_ONE = (alpha0[0] == ATL_rone && alpha0[1] == ATL_rzero);

   if (M < 1 || N < 1)          /* F77 BLAS doesn't scale in either case */
      return;
   if (SCALAR_IS_ZERO(alpha0))   /* No contrib from alpha*A*x */
   {
      if (!SCALAR_IS_ONE(beta0))
      {
         if (SCALAR_IS_ZERO(beta0))
            Mjoin(PATL,zero)(N, Y, incY);
         else
            Mjoin(PATL,scal)(N, beta, Y, incY);
      }
      return;
   }
/*
 * ATLAS's MVT kernels loop over M in inner loop, which is bad news if M is
 * very small.  Call code that requires no copy of X & Y for these degenerate
 * cases
 */
   if (M < 16)
   {
      Mjoin(PATL,refgemv)(AtlasConjTrans, N, M, alpha0, A, lda, X, incX, 
                          beta0, Y, incY);
      return;
   }
/*
 * Get mvtk kernel pointer along with any usage guidelines, and use the
 * optimized CacheElts to compute the correct blocking factor
 */
   mvtk_b1 = ATL_GetMVTKern(M, N, A, lda, &mvtk_b0, &mu, &nu, 
                            &minM, &minN, &alignX, &ALIGNX2A, &alignY, 
                            &ForceNU, &CacheElts);
/*
 * Set up to handle case where kernel requres N to be a multiple if NU
 */
   if (ForceNU)
   {
      Nm = (N/nu)*nu;
      nr = N - Nm;
   }
   else
   {
      Nm = N;
      nr = 0;
   }
/*
 * For very small N, we can't afford the data copy, so call special case code
 */
   if (N < 4 || Nm < 1)
   {
      Mjoin(PATL,refgemv)(AtlasConjTrans, N, M, alpha0, A, lda, X, incX, 
                          beta0, Y, incY);
      return;
   }
   if (CacheElts)
   {
      mb = (CacheElts - 2*nu) / (2*(nu+1));
      mb = (mb > mu) ? (mb/mu)*mu : M;
      mb = (mb > M) ? M : mb;
   }
   else
      mb = M;
   vp = malloc(ATL_MulBySize(mb+N) + 2*ATL_Cachelen);
/*
 * If we cannot allocate enough space to copy the vectors, give up and
 * call the simple loop-based implementation
 */
   if (!vp)
   {
      Mjoin(PATL,refgemv)(AtlasConjTrans, N, M, alpha0, A, lda, X, incX, 
                          beta0, Y, incY);
      return;
   }
   y = ATL_AlignPtr(vp);
   x = y + (N SHIFT);
   x = (ALIGNX2A) ? ATL_Align2Ptr(x, A) : ATL_AlignPtr(x);
   beta = Zero;
/*
 * In this step, we form y = A^T * conj(X)
 */
   mvtk = mvtk_b0;
   m = M;
   do
   {
      imb = Mmin(mb, m);
      Mjoin(PATL,copyConj)(imb, X, incX, x, 1);  /* x = conj(X) */
/*
 *    Call optimized kernel (can be restricted or general)
 */
      if (imb >= minM)
         mvtk(imb, Nm, A, lda, x, y);
      else
         Mjoin(PATL,mvtk_Mlt16)(imb, Nm, one, A, lda, x, 1, beta, y, 1);
/*
 *    Some kernels require N%NU=0; if so nr is remainder, do cleanup with axpy
 */
      if (nr)
         Mjoin(PATL,mvtk_smallN)(imb, nr, one, A+((size_t)lda)*(Nm SHIFT), lda,
                                 x, 1, beta, y+(Nm SHIFT), 1);
      beta = one;
      mvtk = mvtk_b1;
      A += imb SHIFT;
      X += (imb*incX)SHIFT;
      m -= imb;
      imb = Mmin(m,mb);
   }
   while(m);

/*
 * Given y = A^T * conj(X) from above, now do:
 *    Y = beta*Y + alpha*conj(y) = beta*Y + alpha*(A^H * x), which is
 *    Y = beta*Y + alpha * A^H * x.
 */
   Mjoin(PATL,axpbyConj)(N, alpha0, y, 1, beta0, Y, incY);
   free(vp);
}
@ROUT ATL_gemvN
@extract -b @(topd)/cw.inc lang=c -define cwdate 2010
#include "atlas_misc.h"
#include "atlas_lvl2.h"
#include "atlas_lvl3.h"
#if defined(ATL_INL1)
   #include Mstr(Mjoin(Mjoin(atlas_,PRE),mvn_L1.h))
#elif defined(ATL_INL2)
   #include Mstr(Mjoin(Mjoin(atlas_,PRE),mvn_L2.h))
#else
   #include Mstr(Mjoin(Mjoin(atlas_,PRE),mvn.h))
#endif

@beginskip
static void ATL_gemv_by_rows
   (ATL_CINT M, ATL_CINT N, const SCALAR alpha0, const TYPE *A, ATL_CINT lda,
    const TYPE *X, ATL_CINT incX, const SCALAR beta, TYPE *Y, ATL_CINT incY,
    ATL_mvkern_t mvnk_b1, ATL_mvkern_t mvnk_b0, int nb, int mu, int nu, 
    int minM, int minN, int ForceMU, ATL_INT CacheElts, int ALIGNY2A, 
    int COPYX, int COPYY)
/*
 * Driver routine for dot-based (row-wise) gemvN, len(X) = N, len(Y) = M
 */
{
   void *vp=NULL;
   TYPE *x = (TYPE*)X, *y = (TYPE*)Y;
   ATL_mvkern_t mvnk = mvnk_b1;
   void (*getX)(const int N, const SCALAR alpha, const TYPE *X,
                const int incX, TYPE *Y, const int incY);
   ATL_INT inb, n;
   int APPLYALPHAX=0;
   #ifdef TCPLX
      const TYPE one[2] = {ATL_rone, ATL_rzero}, *alpha;
   #else
      TYPE alpha;
      #define one ATL_rone
   #endif

   if (!SCALAR_IS_ONE(alpha))
   {
      if (!COPYX && !COPYY)
         COPYX = APPLYALPHAX = 1;
      else if (!COPYY)
         APPLYALPHAX = 1;
   }
   alpha = (APPLYALPHAX) ? alpha0 : one;

   if (COPYX | COPYY)
   {
      vp = malloc(ATL_MulBySize(COPYX*nb+M*COPYY) + 2*ATL_Cachelen);
/*
 *    If we cannot allocate enough space to copy the vectors, give up and
 *    call the simple loop-based implementation
 */
      if (!vp)
      {
         Mjoin(PATL,mvnk_smallN)(M, N, alpha0, A, lda, X, incX, beta, Y, incY);
         return;
      }
      if (COPYY)
      {
         mvnk = mvnk_b0;
         y = (ALIGNY2A) ? ATL_Align2Ptr(vp, A) : ATL_AlignPtr(vp);
         if (COPYX)
         {
            x = y + (M SHIFT);
            x = ATL_AlignPtr(x);
         }
      }
      else if (COPYX)
         x = ATL_AlignPtr(vp);
   }
/*
 * Apply beta to Y if we aren't copying Y; set X copy funcptr
 */
   if (!COPYY && !SCALAR_IS_ONE(beta))
      Mjoin(PATL,scal)(M, beta, Y, incY);
   getX = (COPYX) ? Mjoin(PATL,cpsc) : NULL;
   n = N;
   do
   {
      inb = Mmin(nb, n);
      if (getX)
         getX(inb, alpha, X, incX, x, 1);
      else
         x = (TYPE*) X;
      mvnk(M, inb, A, lda, x, y);
      mvnk = mvnk_b1;
      A += lda*inb SHIFT;
      X += (inb*incX)SHIFT;
      n -= inb;
   }
   while(n);
   if (COPYY)  /* move Y back to user's vector */
      Mjoin(PATL,axpby)(M, APPLYALPHAX ? one : alpha0, y, 1, beta, Y, incY);
   if (vp)
      free(vp);
}

@endskip
#ifdef ATL_INL1
   #define ATL_gemv Mjoin(PATL,gemvN_L1)
#elif defined(ATL_INL2)
   #define ATL_gemv Mjoin(PATL,gemvN_L2)
#else
   #define ATL_gemv Mjoin(PATL,gemvN)
#endif
void ATL_gemv
   (ATL_CINT M, ATL_CINT N, const SCALAR alpha0, const TYPE *A, ATL_CINT lda,
    const TYPE *X, ATL_CINT incX, const SCALAR beta0, TYPE *Y, ATL_CINT incY)
/*
 * y = alpha*A*x + beta*y, A is MxN, len(X) = N, len(Y) = M
 */
{
   ATL_mvkern_t mvnk, mvnk_b1, mvnk_b0;
   void *vp=NULL;
   TYPE *x = (TYPE*)X, *y = (TYPE*)Y, *p;
   size_t t1, t2;
   ATL_INT m, Nm, nr, CacheElts, mb, imb, incy=1;
   int mu, nu, alignX, alignY, ALIGNY2A, ForceNU, COPYX, COPYY, APPLYALPHAX;
   int minM, minN, DOTBASED;
   #ifdef TREAL
      #define one ATL_rone
      #define Zero ATL_rzero
      TYPE alpha = alpha0, beta = beta0;
      const int ALPHA_IS_ONE = (alpha0 == ATL_rone);
   #else
      TYPE one[2] = {ATL_rone, ATL_rzero}, *alpha=(TYPE*)alpha0;
      TYPE Zero[2] = {ATL_rzero, ATL_rzero};
      TYPE *beta = (TYPE*) beta0;
      const int ALPHA_IS_ONE = (alpha0[0] == ATL_rone && alpha[1] == ATL_rzero);
   #endif

   if (M < 1 || N < 1)          /* F77BLAS doesn't scale in either case */
      return;
   if (SCALAR_IS_ZERO(alpha))   /* No contrib from alpha*A*x */
   {
      if (!SCALAR_IS_ONE(beta))
      {
         if (SCALAR_IS_ZERO(beta))
            Mjoin(PATL,zero)(M, Y, incY);
         else
            Mjoin(PATL,scal)(M, beta, Y, incY);
      }
      return;
   }
/*
 * ATLAS's mvn kernels loop over M in inner loop, which is bad news if M is
 * very small.  Call code that requires no copy of X & Y for these degenerate
 * cases
 */
   if (M < 16)
   {
      Mjoin(PATL,mvnk_Mlt16)(M, N, alpha0, A, lda, X, incX, beta0, Y, incY);
      return;
   }
/*
 * Get mvnk kernel pointer along with any usage guidelines, and use the
 * optimized CacheElts to compute the correct blocking factor
 * For no transpose, X alignment args really apply to Y, and vice versa.
 */
   mvnk_b1 = ATL_GetMVNKern(M, N, A, lda, &mvnk_b0, &DOTBASED, &mu, &nu, 
                            &minM, &minN, &alignY, &ALIGNY2A, &alignX, 
                            &ForceNU, &CacheElts);
/*
 * Set up to handle case where kernel requires N to be a multiple if NU
 */
   if (ForceNU)
   {
      Nm = (N/nu)*nu;
      nr = N - Nm;
   }
   else
   {
      Nm = N;
      nr = 0;
   }
/*
 * For very small N, we can't afford the data copy, so call special case code
 */
   if (N < 4 || Nm < 1)
   {
      Mjoin(PATL,mvnk_smallN)(M, N, alpha0, A, lda, X, incX, beta0, Y, incY);
      return;
   }
   if (CacheElts)
   {
      mb = (CacheElts - 2*nu) / (2*(nu+1));
      mb = (mb > mu) ? (mb/mu)*mu : M;
      mb = (mb > M) ? M : mb;
   }
   else
      mb = M;
/*
 *****************************************************************************
 Figure out whether vecs need be copied, and which one will be scaled by alpha
 *****************************************************************************
 */
@beginskip
   if (DOTBASED)
   {
      p = (TYPE*) X;
      X = (const TYPE*) Y;
      Y = (TYPE*) p;
   }
@endskip
   COPYX = (incX != 1);
   if (!COPYX && alignX)
   {
      t1 = (size_t) X;
      COPYX = ((t1/alignX)*alignX != t1);
   }
   COPYY = (incY != 1);
   if (!COPYY)  /* may still need to copy due to alignment issues */
   {
/*
 *    ATL_Cachelen is the highest alignment that can be requested, so
 *    make X's % with Cachelen match that of A if you want A & X to have
 *    the same alignment
 */
      if (ALIGNY2A)
      {
         t1 = (size_t) A;
         t2 = (size_t) Y;
         COPYY = (t1 - ATL_MulByCachelen(ATL_DivByCachelen(t1))) !=
                 (t2 - ATL_MulByCachelen(ATL_DivByCachelen(t2)));
      }
      else if (alignY)
      {
         t1 = (size_t) Y;
         COPYY = ((t1/alignY)*alignY != t1);
      }
   }
@beginskip
   if (DOTBASED)
   {
      ATL_gemv_by_rows(M, N, alpha0, A, lda, (const TYPE*)Y, incX, beta0, 
                       (TYPE*)X, incY, mvnk_b1, mvnk_b0, DOTBASED, mu, nu, 
                       minM, minN, ForceNU, CacheElts, ALIGNY2A, COPYX, COPYY);
      return;
   }
@endskip
   if (COPYX != COPYY)         /* if only one of them is already being copied */
      APPLYALPHAX = COPYX;     /* apply alpha to that one */
   else if (!COPYY && !COPYX)  /* nobody currently being copied means */
   {                           /* we'll need to force a copy to apply alpha */
      APPLYALPHAX = (M < N);   /* apply alpha to vector requiring least */
      if (!ALPHA_IS_ONE)       /* workspace if alpha != 1.0 */
      {
         COPYX = APPLYALPHAX;
         COPYY = !APPLYALPHAX;
      }
   }
   else                        /* if both are being copied anyway */
      APPLYALPHAX = 0;         /* apply alpha during update of Y */

   if (COPYX | COPYY)         /* if I need to copy either vector */
   {                          /* allocate & align them */
      vp = malloc(ATL_MulBySize(COPYY*mb+COPYX*N) + 2*ATL_Cachelen);
/*
 *    If we cannot allocate enough space to copy the vectors, give up and
 *    call the simple loop-based implementation
 */
      if (!vp)
      {
         Mjoin(PATL,mvnk_smallN)(M, N, alpha0, A, lda, X, incX, beta0, Y, incY);
         return;
      }
      if (COPYX)
      {
         x = ATL_AlignPtr(vp);
         if (APPLYALPHAX && !ALPHA_IS_ONE)
            Mjoin(PATL,cpsc)(N, alpha, X, incX, x, 1);
         else
            Mjoin(PATL,copy)(N, X, incX, x, 1);
         if (COPYY)
            y = x + (N SHIFT);
      }
      else /* if (COPYY)  known true by surrounding if */
         y = vp;
      if (COPYY)
      {
         y = (ALIGNY2A) ? ATL_Align2Ptr(y, A) : ATL_AlignPtr(y);
         beta = Zero;
         alpha = one;
      }
   }
/*
 * Apply beta to Y if we aren't copying Y
 */
   if (!COPYY && !SCALAR_IS_ONE(beta0))
   {
      if (SCALAR_IS_ZERO(beta0))
         beta = Zero;
      else
      {
         Mjoin(PATL,scal)(M, beta0, Y, incY);
         beta = one;
      }
   }
   mvnk = (COPYY || SCALAR_IS_ZERO(beta)) ? mvnk_b0 : mvnk_b1;
   m = M;
   do
   {
      imb = Mmin(mb, m);
/*
 *    Call optimized kernel (can be restricted or general)
 */
      if (imb >= minM)
         mvnk(imb, Nm, A, lda, x, y);
      else
         Mjoin(PATL,mvnk_Mlt16)(imb, Nm, one, A, lda, x, 1, beta, y, 1);
/*
 *    Some kernels require N%NU=0; if so nr is remainder, do cleanup with axpy
 */
      if (nr)
         Mjoin(PATL,mvnk_smallN)(imb, nr, one, A+((size_t)lda)*(Nm SHIFT), lda, 
                                 x+(Nm SHIFT), 1, one, y, 1);
/*
 *    If we are copying Y, we have formed A*x into y, so scale it by the
 *    original alpha, by using axpby: Y = beta0*Y + alpha0*y
 */
      if (COPYY)
         Mjoin(PATL,axpby)(imb, alpha0, y, 1, beta0, Y, incY);
      else
         y += imb SHIFT;
      A += imb SHIFT;
      Y += (imb*incY)SHIFT;
      m -= imb;
   }
   while(m);
   if (vp)
      free(vp);
}
@ROUT ATL_gemvCN
@extract -b @(topd)/cw.inc lang=c -define cwdate 2010
#include "atlas_misc.h"
#include "atlas_lvl2.h"
#include "atlas_lvl3.h"
#include "atlas_reflevel2.h"
#if defined(ATL_INL1)
   #include Mstr(Mjoin(Mjoin(atlas_,PRE),mvn_L1.h))
#elif defined(ATL_INL2)
   #include Mstr(Mjoin(Mjoin(atlas_,PRE),mvn_L2.h))
#else
   #include Mstr(Mjoin(Mjoin(atlas_,PRE),mvn.h))
#endif

#ifdef ATL_INL1
   #define ATL_gemv Mjoin(PATL,gemvCN_L1)
#elif defined(ATL_INL2)
   #define ATL_gemv Mjoin(PATL,gemvCN_L2)
#else
   #define ATL_gemv Mjoin(PATL,gemvCN)
#endif
void ATL_gemv
   (ATL_CINT M, ATL_CINT N, const SCALAR alpha0, const TYPE *A, ATL_CINT lda,
    const TYPE *X, ATL_CINT incX, const SCALAR beta0, TYPE *Y, ATL_CINT incY)
/*
 * Y = alpha*conj(A)*X + beta*Y, A is MxN, len(X) = N, len(Y) = M
 * We don't have a conj(A) kernel, so form this with O(N) extra flops:
 *    x = conj(X); y = A * conj(X), 
 * then add this into Y using axpbyConj:
 *    Y = alpha*conj(y) + beta*Y = alpha*(conj(A)*X) + beta*Y
 * providing:
 *    Y = alpha*conj(A)*X + beta*Y
 */
{
   ATL_mvkern_t mvnk, mvnk_b1, mvnk_b0;
   void *vp=NULL;
   TYPE *x = (TYPE*)X, *y = (TYPE*)Y, *p;
   size_t t1, t2;
   ATL_INT m, Nm, nr, CacheElts, mb, imb, incy=1;
   int mu, nu, alignX, alignY, ALIGNY2A, ForceNU, COPYX, COPYY, APPLYALPHAX;
   int minM, minN, DOTBASED;
   TYPE one[2] = {ATL_rone, ATL_rzero}, *alpha=(TYPE*)alpha0;
   TYPE Zero[2] = {ATL_rzero, ATL_rzero};
   TYPE *beta = (TYPE*) beta0;
   const int ALPHA_IS_ONE = (alpha0[0] == ATL_rone && alpha[1] == ATL_rzero);

   if (M < 1 || N < 1)          /* F77BLAS doesn't scale in either case */
      return;
   if (SCALAR_IS_ZERO(alpha))   /* No contrib from alpha*A*x */
   {
      if (!SCALAR_IS_ONE(beta))
      {
         if (SCALAR_IS_ZERO(beta))
            Mjoin(PATL,zero)(M, Y, incY);
         else
            Mjoin(PATL,scal)(M, beta, Y, incY);
      }
      return;
   }
/*
 * ATLAS's mvn kernels loop over M in inner loop, which is bad news if M is
 * very small.  Call code that requires no copy of X & Y for these degenerate
 * cases
 */
   if (M < 16)
   {
      Mjoin(PATL,refgemv)(AtlasConj, M, N, alpha0, A, lda, X, incX, 
                          beta0, Y, incY);
      return;
   }
/*
 * Get mvnk kernel pointer along with any usage guidelines, and use the
 * optimized CacheElts to compute the correct blocking factor
 * For no transpose, X alignment args really apply to Y, and vice versa.
 */
   mvnk_b1 = ATL_GetMVNKern(M, N, A, lda, &mvnk_b0, &DOTBASED, &mu, &nu, 
                            &minM, &minN, &alignY, &ALIGNY2A, &alignX, 
                            &ForceNU, &CacheElts);
/*
 * Set up to handle case where kernel requires N to be a multiple if NU
 */
   if (ForceNU)
   {
      Nm = (N/nu)*nu;
      nr = N - Nm;
   }
   else
   {
      Nm = N;
      nr = 0;
   }
/*
 * For very small N, we can't afford the data copy, so call special case code
 */
   if (N < 4 || Nm < 1)
   {
      Mjoin(PATL,refgemv)(AtlasConj, M, N, alpha0, A, lda, X, incX, 
                          beta0, Y, incY);
      return;
   }
   if (CacheElts)
   {
      mb = (CacheElts - 2*nu) / (2*(nu+1));
      mb = (mb > mu) ? (mb/mu)*mu : M;
      mb = (mb > M) ? M : mb;
   }
   else
      mb = M;
/*
 *****************************************************************************
 Figure out whether vecs need be copied, and which one will be scaled by alpha
 *****************************************************************************
 */
   vp = malloc(ATL_MulBySize(mb+N) + 2*ATL_Cachelen);
/*
 * If we cannot allocate enough space to copy the vectors, give up and
 * call the simple loop-based implementation
 */
   if (!vp)
   {
      Mjoin(PATL,refgemv)(AtlasConj, M, N, alpha0, A, lda, X, incX, 
                          beta0, Y, incY);
      return;
   }
/*
 * Form x = conj(X)
 */
   x = ATL_AlignPtr(vp);
   Mjoin(PATL,copyConj)(N, X, incX, x, 1);
   y = x + (N SHIFT);
   y = (ALIGNY2A) ? ATL_Align2Ptr(y, A) : ATL_AlignPtr(y);
/*
 * Loop over cache-blocked (for vector reuse) gemv calls
 */
   mvnk = mvnk_b0;
   beta = Zero;
   m = M;
   do
   {
/*
 *    Form y = A * conj(X)
 */
      imb = Mmin(mb, m);
/*
 *    Call optimized kernel (can be restricted or general)
 */
      if (imb >= minM)
         mvnk(imb, Nm, A, lda, x, y);
      else
         Mjoin(PATL,mvnk_Mlt16)(imb, Nm, one, A, lda, x, 1, beta, y, 1);
/*
 *    Some kernels require N%NU=0; if so nr is remainder, do cleanup with axpy
 */
      if (nr)
         Mjoin(PATL,mvnk_smallN)(imb, nr, one, A+((size_t)lda)*(Nm SHIFT), lda, 
                                 x+(Nm SHIFT), 1, one, y, 1);
/*
 *    Given y = A * conj(X) from above, now do:
 *       Y = beta*Y + alpha*conj(y) = beta*Y + alpha*(conj(A)*X)
 *         = beta*Y + alpha * conj(A) * X
 */
      Mjoin(PATL,axpbyConj)(imb, alpha0, y, 1, beta0, Y, incY);
      A += imb SHIFT;
      Y += (imb*incY)SHIFT;
      m -= imb;
   }
   while(m);
   free(vp);
}
@ROUT ATL_gemv
@extract -b @(topd)/cw.inc lang=c -define cwdate 2010
#include "atlas_misc.h"
#include "atlas_lvl2.h"
#include "atlas_lvl3.h"
@skip #include Mstr(Mjoin(Mjoin(atlas_,PRE),sysinfo.h))
#include "atlas_cacheedge.h"
#include "atlas_cache.h"
@beginskip
#if defined(ATL_NCPU) && ATL_NCPU > 1
   #include "atlas_tcacheedge.h"
#else
   #include "atlas_cacheedge.h"
#endif
@endskip
/*
 * If I don't believe CacheEdge setting (or not set), set L2 size to 4*L1
 */
#ifdef CacheEdge
   #if CacheEdge > 4194304 || CacheEdge == 0
      #define MY_CE (4*ATL_MulBySize(L1C_ELTS))
   #else
      #define MY_CE CacheEdge
   #endif
#else
   #define MY_CE (4*ATL_MulBySize(L1C_ELTS))
#endif

void Mjoin(PATL,gemv)
   (const enum ATLAS_TRANS TA, ATL_CINT M, ATL_CINT N, const SCALAR alpha,
    const TYPE *A, ATL_CINT lda, const TYPE *X, ATL_CINT incX, 
    const SCALAR beta, TYPE *Y, ATL_CINT incY)
/*
 * ATL_gemv is a wrapper that chooses which context-tuned GEMV to call.
 * Supported contexts are tuned for in-L1 performance (_L1), tuned for
 * in-L2 performance (_L2), and tuned for out-of-cache (no suffix).
 * Right now, we do this based sheerly on operand size, since this matches
 * most common (we think!) LAPACK usage, like in factorizations.  If we
 * had access to the hardware counters, a better way to would be to access
 * say 10/100 elements of A, and call one of these contexts based on how
 * many cache misses were generated
 */
{
   const size_t opsize = (M*N+M+N)*sizeof(TYPE)SHIFT, Abeg, Aend, Obeg, Oend;
   int OL;

@skip   OL = ATL_L2AIsOverlapped(0, ATL_sizeof, M, N, (size_t)A, lda);
   if (TA == AtlasNoTrans)
   {
@skip      if (!OL || opsize > MY_CE)
      if (opsize > MY_CE)
        Mjoin(PATL,gemvN)(M, N, alpha, A, lda, X, incX, beta, Y, incY);
      else if (opsize > ATL_MulBySize(L1C_ELTS))
        Mjoin(PATL,gemvN_L2)(M, N, alpha, A, lda, X, incX, beta, Y, incY);
      else
        Mjoin(PATL,gemvN_L1)(M, N, alpha, A, lda, X, incX, beta, Y, incY);
   }
   else
   {
   #ifdef TCPLX
      if (TA == AtlasTrans)
      {
   #endif
      if (opsize > MY_CE)
         Mjoin(PATL,gemvT)(M, N, alpha, A, lda, X, incX, beta, Y, incY);
      else if (opsize > ATL_MulBySize(L1C_ELTS))
         Mjoin(PATL,gemvT_L2)(M, N, alpha, A, lda, X, incX, beta, Y, incY);
      else
         Mjoin(PATL,gemvT_L1)(M, N, alpha, A, lda, X, incX, beta, Y, incY);
   #ifdef TCPLX
      }
      else if (TA == AtlasConjTrans)
      {
         if (opsize > MY_CE)
            Mjoin(PATL,gemvCT)(M, N, alpha, A, lda, X, incX, beta, Y, incY);
         else if (opsize > ATL_MulBySize(L1C_ELTS))
            Mjoin(PATL,gemvCT_L2)(M, N, alpha, A, lda, X, incX, beta, Y, incY);
         else
            Mjoin(PATL,gemvCT_L1)(M, N, alpha, A, lda, X, incX, beta, Y, incY);
      }
      else /* if (TA == AtlasConj) */
      {
         if (opsize > MY_CE)
            Mjoin(PATL,gemvCN)(M, N, alpha, A, lda, X, incX, beta, Y, incY);
         else if (opsize > ATL_MulBySize(L1C_ELTS))
            Mjoin(PATL,gemvCN_L2)(M, N, alpha, A, lda, X, incX, beta, Y, incY);
         else
            Mjoin(PATL,gemvCN_L1)(M, N, alpha, A, lda, X, incX, beta, Y, incY);
      }
   #endif
   }
}
@ROUT ATL_trsvUN
@extract -b @(topd)/cw.inc lang=c -define cwdate 2010
#include "atlas_misc.h"
#include "atlas_level1.h"
#include "atlas_kernel2.h"
#include "atlas_lvl2.h"

#if defined(ATL_INL1)
   #include Mstr(Mjoin(Mjoin(atlas_,PRE),mvn_L1.h))
   #define LVL _L1
#elif defined(ATL_INL2)
   #include Mstr(Mjoin(Mjoin(atlas_,PRE),mvn_L2.h))
   #define LVL _L2
#else
   #include Mstr(Mjoin(Mjoin(atlas_,PRE),mvn.h))
   #define LVL _OOC
#endif

#ifdef Unit_
   #define UNIT AtlasUnit
   #define TRMVUN Mjoin(Mjoin(PATL,trmvUNU),LVL)
   #define reftrsv Mjoin(PATL,reftrsvUNU)
#else
   #define UNIT AtlasNonUnit
   #define TRMVUN Mjoin(Mjoin(PATL,trmvUNN),LVL)
   #define reftrsv Mjoin(PATL,reftrsvUNN)
#endif
#define NX 128
static void TRMVUN_k
(
   const int              N,
   const TYPE             *A,
   const int              lda,
   TYPE                   *X,
   const int              incX
)
{
   ATL_mvkern_t mvnk, mvnk_b1, mvnk_b0;
   ATL_INT CacheElts, nx;
   int j, mu, nu, minM, minN, alignY, ALIGNY2A, alignX, ForceNU;

   mvnk_b1 = ATL_GetMVNKern(M, N, A, lda, &mvnk_b0, &j, &mu, &nu,
                            &minM, &minN, &alignY, &ALIGNY2A, &alignX,
                            &ForceNU, &CacheElts);
/*
 * Figure initial ref call; make sure we have enough left after doing NX
 * so that we can make a call to optimized kernel
 */
   nx = ((NX+1)>>1)<<1;
   if (Mmax(nu,minN)+nx >= N)
   {
      reftrsv(N, A, lda, X, incX);
      return;
   }
   
}

void TRMVUN
(
   const int              N,
   const TYPE             *A,
   const int              lda,
   TYPE                   *X,
   const int              incX
)
{
   TRMVUN_k(N, A, lda, X, incX);
}
@ROUT ATL_trmv  ATL_trsv ATL_symv ATL_hemv
@extract -b @(topd)/cw.inc lang=c -define cwdate 2012 -define cwdate 2010 -define contrib "Antoine P. Petitet"
#include "atlas_misc.h"
#include "atlas_level1.h"
#include "atlas_kernel2.h"
#include "atlas_lvl2.h"

#include "atlas_reflvl2.h"          /* temporary for building purposes */
#include "atlas_reflevel2.h"        /* used for gbmv, gpmv and gpr.    */
@skip #include Mstr(Mjoin(Mjoin(atlas_,PRE),sysinfo.h))
#include "atlas_cache.h"
@skip #include "atlas_cacheedge.h"

#ifdef CacheEdge
@ROUT ATL_trmv  ATL_trsv
   #if !defined(CacheEdge) || CacheEdge > 4194304 || CacheEdge == 0
      #define MY_CE (4*ATL_MulBySize(L1C_ELTS))
@ROUT ATL_symv ATL_hemv
   #if !defined(CacheEdge) || CacheEdge == 0
      #define MY_CE (4*ATL_MulBySize(L1C_ELTS))
@ROUT ATL_trmv  ATL_trsv ATL_symv ATL_hemv
   #else
      #define MY_CE CacheEdge
   #endif
#else
   #define MY_CE (4*ATL_MulBySize(L1C_ELTS))
#endif

@ROUT ATL_trmv 
static void ATL_trmvUTNk
(
   ATL_CINT N,
   const TYPE *A,
   ATL_CINT lda,
   const TYPE *X,  /* aligned with A */
   TYPE *Y         /* 16-byte aligned */
)
{
   register ATL_INT j;
#ifdef TREAL
   for (j=0; j < N; j++)
      Y[j] += Mjoin(PATL,dot)(j+1, X, 1, A+j*lda, 1);
#else
   for (j=0; j < N; j++)
   {
      const register ATL_INT j2 = j + j;
      register TYPE ry=Y[j2], iy=Y[j2+1];
      Mjoin(PATL,dotu_sub)(j+1, X, 1, A+j2*lda, 1, Y+j2);
      Y[j2] += ry;
      Y[j2+1] += iy;
   }
#endif
}

static void ATL_trmvUTUk
(
   ATL_CINT N,
   const TYPE *A,
   ATL_CINT lda,
   const TYPE *X,  /* aligned with A */
   TYPE *Y         /* 16-byte aligned */
)
{
   register ATL_INT j;
#ifdef TREAL
   *Y += *X; A += lda;
   for (j=1; j < N; j++, A += lda)
      Y[j] += X[j] + Mjoin(PATL,dot)(j, X, 1, A, 1);
#else
   register ATL_CINT lda2=lda+lda;
   *Y += *X;
   Y[1] += X[1];
   A += lda2;
   for (j=1; j < N; j++, A += lda2)
   {
      const register ATL_INT j2 = j + j;
      register TYPE ry=Y[j2], iy=Y[j2+1];
      ry += X[j2];
      iy += X[j2+1];
      Mjoin(PATL,dotu_sub)(j, X, 1, A, 1, Y+j2);
      Y[j2] += ry;
      Y[j2+1] += iy;
   }
#endif
}

static void ATL_trmvUNNk
(
   ATL_CINT N,
   const TYPE *A,
   ATL_CINT lda,
   const TYPE *X,
   TYPE *Y
)
{
   ATL_INT j;
   #ifdef TREAL
      for (j=0; j < N; j++, A += lda)
         Mjoin(PATL,axpy)(j+1, X[j], A, 1, Y, 1);
   #else
      ATL_CINT lda2=lda+lda;
      for (j=0; j < N; j++, A += lda2)
         Mjoin(PATL,axpy)(j+1, X+j+j, A, 1, Y, 1);
   #endif
}
static void ATL_trmvUNUk
(
   ATL_CINT N,
   const TYPE *A,
   ATL_CINT lda,
   const TYPE *X,
   TYPE *Y
)
{
#ifdef TREAL
   ATL_INT j;
   *Y += *X; A += lda;
   for (j=1; j < N; j++, A += lda)
   {
      register TYPE x=X[j];
      Mjoin(PATL,axpy)(j, x, A, 1, Y, 1);
      Y[j] += x;
   }
#else
   register ATL_INT j;
   register ATL_CINT lda2 = lda+lda;
   *Y += *X;
   Y[1] += X[1]; A += lda2;
   for (j=1; j < N; j++, A += lda2)
   {
      register ATL_CINT j2 = j + j;
      Mjoin(PATL,axpy)(j, X+j2, A, 1, Y, 1);
      Y[j2] += X[j2];
      Y[j2+1] += X[j2+1];
   }
#endif
}


static void ATL_trmvLTNk
(
   ATL_CINT N,
   const TYPE *A,
   ATL_CINT lda,
   const TYPE *X,  /* aligned with A */
   TYPE *Y         /* 16-byte aligned */
)
{
   register ATL_INT j;
   ATL_CINT ldap1 = lda+1;
#ifdef TREAL
   for (j=0; j < N; j++)
      Y[j] += Mjoin(PATL,dot)(N-j, X+j, 1, A+j*ldap1, 1);
#else
   for (j=0; j < N; j++)
   {
      const register ATL_INT j2 = j + j;
      register TYPE ry=Y[j2], iy=Y[j2+1];
      Mjoin(PATL,dotu_sub)(N-j, X+j2, 1, A+j2*ldap1, 1, Y+j2);
      Y[j2] += ry;
      Y[j2+1] += iy;
   }
#endif
}

static void ATL_trmvLTUk
(
   ATL_CINT N,
   const TYPE *A,
   ATL_CINT lda,
   const TYPE *X,  /* aligned with A */
   TYPE *Y         /* 16-byte aligned */
)
{
   register ATL_INT j;
   register ATL_CINT ldap1 = lda+1, Nm1 = N-1;
#ifdef TREAL
   for (j=0; j < Nm1; j++)
   {
      register TYPE t0 = X[j];
      t0 += Mjoin(PATL,dot)(N-j-1, X+j+1, 1, A+1+j*ldap1, 1);
      Y[j] += t0;
   }
   Y[Nm1] += X[Nm1];
#else
   for (j=0; j < Nm1; j++)
   {
      const register ATL_INT j2 = j + j;
      register TYPE ry=Y[j2], iy=Y[j2+1];
      ry += X[j2];
      iy += X[j2+1];
      Mjoin(PATL,dotu_sub)(N-j-1, X+j2+2, 1, A+2+j2*ldap1, 1, Y+j2);
      Y[j2] += ry;
      Y[j2+1] += iy;
   }
   j = Nm1+Nm1;
   Y[j] += X[j];
   Y[j+1] += X[j+1];
#endif
}

static void ATL_trmvLNNk
(
   ATL_CINT N,
   const TYPE *A,
   ATL_CINT lda,
   const TYPE *X,
   TYPE *Y
)
{
   ATL_INT j;
   ATL_CINT ldap1 = (lda+1)SHIFT;
   #ifdef TREAL
      for (j=0; j < N; j++)
         Mjoin(PATL,axpy)(N-j, X[j], A+j*ldap1, 1, Y+j, 1);
   #else
      for (j=0; j < N; j++)
         Mjoin(PATL,axpy)(N-j, X+j+j, A+j*ldap1, 1, Y+j+j, 1);
   #endif
}
static void ATL_trmvLNUk
(
   ATL_CINT N,
   const TYPE *A,
   ATL_CINT lda,
   const TYPE *X,
   TYPE *Y
)
{
#ifdef TREAL
   ATL_INT j;
   ATL_CINT ldap1 = lda+1, Nm1=N-1;
   for (j=0; j < Nm1; j++)
   {
      Y[j] += X[j];
      Mjoin(PATL,axpy)(N-j-1, X[j], A+1+j*ldap1, 1, Y+j+1, 1);
   }
   Y[N-1] += X[N-1];
#else
   ATL_INT j, n=N-1;
   ATL_CINT ldap1 = lda+1, Nm1 = N+N-2;
   for (j=0,n=N-1; n; n--)
   {
      register ATL_CINT jn = j + 2;
      Y[j] += X[j];
      Y[j+1] += X[j+1];
      Mjoin(PATL,axpy)(n, X+j, A+2+j*ldap1, 1, Y+jn, 1);
      j = jn;
   }
   Y[Nm1] += X[Nm1];
   Y[Nm1+1] += X[Nm1+1];
#endif
}

static int ATL_trmvUN
(
   const enum ATLAS_DIAG  Diag,
   const int nb,
   ATL_CINT N,
   const TYPE *A,
   ATL_CINT lda,
   TYPE *X,
   ATL_CINT incX
)
/*
 * RETURNS: 0 if TRMV was performed, non-zero if nothing done
 */
{
   static void (*trmvK)(ATL_CINT, const TYPE*, ATL_CINT, const TYPE*, TYPE*);
   void (*gemv)(ATL_CINT, ATL_CINT, const SCALAR, const TYPE*, ATL_CINT, 
                const TYPE*, ATL_CINT, const SCALAR, TYPE*, ATL_CINT);
   void *vp;
   TYPE *x, *y;
   const size_t opsize = (N*N+N+N)*sizeof(TYPE)SHIFT;
   size_t t0;
   #ifdef TCPLX
      size_t N2=N+N, lda2 = lda+lda;
      TYPE one[2] = {ATL_rone, ATL_rzero};
   #else
      #define N2 N
      #define lda2 lda
      #define one ATL_rone
   #endif
   const size_t incA = ((size_t)lda2)*nb;
   ATL_INT j;

   if (N < nb+nb)
      return(1);
   if (opsize > MY_CE)
      gemv = Mjoin(PATL,gemvN);
   else
      gemv = (opsize <= ATL_MulBySize(L1C_ELTS)) ? Mjoin(PATL,gemvN_L1) :
             Mjoin(PATL,gemvN_L2);
   trmvK = (Diag == AtlasNonUnit) ? ATL_trmvUNNk : ATL_trmvUNUk;
/*
 * If X is aligned to Cachelen wt inc=1, use it as y
 */
   t0 = (size_t) X;
   if (incX == 1 && (ATL_MulByCachelen(ATL_DivByCachelen(t0)) == t0))
   {
      ATL_INT i;
      vp = malloc(ATL_Cachelen+ATL_MulBySize(N));
      if (!vp)
         return(2);
      x = ATL_AlignPtr(vp);
      y = X;
      for (i=0; i < N2; i++)
      {
         x[i] = X[i];
         X[i] = ATL_rzero;
      }

   }
   else  /* allocate both X and Y */
   {
      vp = malloc((ATL_Cachelen+ATL_MulBySize(N))<<1);
      if (!vp)
         return(3);
      x = ATL_AlignPtr(vp);
      y = x + N2;
      y = ATL_AlignPtr(y);
      Mjoin(PATL,copy)(N, X, incX, x, 1);
      Mjoin(PATL,zero)(N, y, 1);
   }
   trmvK(nb, A, lda, x, y);
   A += incA;
   for (j=nb; j < N; j += nb, A += incA)
   {
      int kb = N-j;
      #ifdef TCPLX
         const register size_t j2 = j + j;
      #else
         #define j2 j
      #endif
      kb = Mmin(nb, kb);
      gemv(j, kb, one, A, lda, x+j2, 1, one, y, 1);
      trmvK(kb, A+j2, lda, x+j2, y+j2);
      #ifndef TCPLX
         #undef j2
      #endif
   }
   if (y != X)
      Mjoin(PATL,copy)(N, y, 1, X, incX);
   free(vp);
   return(0);
}
#ifndef TCPLX
   #undef N2
   #undef lda2
   #undef one
#endif

static int ATL_trmvUT
(
   const enum ATLAS_DIAG  Diag,
   const int nb,
   ATL_CINT N,
   const TYPE *A,
   ATL_CINT lda,
   TYPE *X,
   ATL_CINT incX
)
/*
 * RETURNS: 0 if TRMV was performed, non-zero if nothing done
 */
{
   static void (*trmvK)(ATL_CINT, const TYPE*, ATL_CINT, const TYPE*, TYPE*);
   void (*gemv)(ATL_CINT, ATL_CINT, const SCALAR, const TYPE*, ATL_CINT, 
                const TYPE*, ATL_CINT, const SCALAR, TYPE*, ATL_CINT);
   void *vp;
   TYPE *x, *y;
   const size_t opsize = (N*N+N+N)*sizeof(TYPE)SHIFT;
   size_t t0;
   #ifdef TCPLX
      size_t N2=N+N, lda2 = lda+lda;
      TYPE one[2] = {ATL_rone, ATL_rzero};
   #else
      #define N2 N
      #define lda2 lda
      #define one ATL_rone
   #endif
   const size_t incA = ((size_t)lda2)*nb;
   ATL_INT j;

   if (N < nb+nb)
      return(1);
   if (opsize > MY_CE)
      gemv = Mjoin(PATL,gemvT);
   else
      gemv = (opsize <= ATL_MulBySize(L1C_ELTS)) ? Mjoin(PATL,gemvT_L1) :
             Mjoin(PATL,gemvT_L2);
   trmvK = (Diag == AtlasNonUnit) ? ATL_trmvUTNk : ATL_trmvUTUk;
/*
 * If X is aligned to Cachelen wt inc=1, use it as y
 */
   t0 = (size_t) X;
   if (incX == 1 && (ATL_MulByCachelen(ATL_DivByCachelen(t0)) == t0))
   {
      ATL_INT i;
      vp = malloc(ATL_Cachelen+ATL_MulBySize(N));
      if (!vp)
         return(2);
      x = ATL_AlignPtr(vp);
      y = X;
      for (i=0; i < N2; i++)
      {
         x[i] = X[i];
         X[i] = ATL_rzero;
      }

   }
   else  /* allocate both X and Y */
   {
      vp = malloc((ATL_Cachelen+ATL_MulBySize(N))<<1);
      if (!vp)
         return(3);
      x = ATL_AlignPtr(vp);
      y = x + N2;
      y = ATL_AlignPtr(y);
      Mjoin(PATL,copy)(N, X, incX, x, 1);
      Mjoin(PATL,zero)(N, y, 1);
   }
   trmvK(nb, A, lda, x, y);
   A += incA;
   for (j=nb; j < N; j += nb, A += incA)
   {
      int kb = N-j;
      #ifdef TCPLX
         const register size_t j2 = j + j;
      #else
         #define j2 j
      #endif
      kb = Mmin(nb, kb);
      gemv(j, kb, one, A, lda, x, 1, one, y+j2, 1);
      trmvK(kb, A+j2, lda, x+j2, y+j2);
      #ifndef TCPLX
         #undef j2
      #endif
   }
   if (y != X)
      Mjoin(PATL,copy)(N, y, 1, X, incX);
   free(vp);
   return(0);
}
#ifndef TCPLX
   #undef N2
   #undef lda2
   #undef one
#endif

static int ATL_trmvLN
(
   const enum ATLAS_DIAG  Diag,
   const int nb,
   ATL_CINT N,
   const TYPE *A,
   ATL_CINT lda,
   TYPE *X,
   ATL_CINT incX
)
/*
 * RETURNS: 0 if TRMV was performed, non-zero if nothing done
 */
{
   static void (*trmvK)(ATL_CINT, const TYPE*, ATL_CINT, const TYPE*, TYPE*);
   void (*gemv)(ATL_CINT, ATL_CINT, const SCALAR, const TYPE*, ATL_CINT, 
                const TYPE*, ATL_CINT, const SCALAR, TYPE*, ATL_CINT);
   void *vp;
   TYPE *x, *y;
   const size_t opsize = (N*N+N+N)*sizeof(TYPE)SHIFT;
   size_t t0;
   #ifdef TCPLX
      size_t N2=N+N, lda2 = lda+lda;
      TYPE one[2] = {ATL_rone, ATL_rzero};
   #else
      #define N2 N
      #define lda2 lda
      #define one ATL_rone
   #endif
   const size_t incA = ((size_t)lda+1)*(nb SHIFT);
   ATL_CINT Nnb = ((N-1)/nb)*nb, Nr = N-Nnb;
   ATL_INT j;

   if (N < nb+nb)
      return(1);
   if (opsize > MY_CE)
      gemv = Mjoin(PATL,gemvN);
   else
      gemv = (opsize <= ATL_MulBySize(L1C_ELTS)) ? Mjoin(PATL,gemvN_L1) :
             Mjoin(PATL,gemvN_L2);
   trmvK = (Diag == AtlasNonUnit) ? ATL_trmvLNNk : ATL_trmvLNUk;
/*
 * If X is aligned to Cachelen wt inc=1, use it as y
 */
   t0 = (size_t) X;
   if (incX == 1 && (ATL_MulByCachelen(ATL_DivByCachelen(t0)) == t0))
   {
      ATL_INT i;
      vp = malloc(ATL_Cachelen+ATL_MulBySize(N));
      if (!vp)
         return(2);
      x = ATL_AlignPtr(vp);
      y = X;
      for (i=0; i < N2; i++)
      {
         x[i] = X[i];
         X[i] = ATL_rzero;
      }

   }
   else  /* allocate both X and Y */
   {
      vp = malloc((ATL_Cachelen+ATL_MulBySize(N))<<1);
      if (!vp)
         return(3);
      x = ATL_AlignPtr(vp);
      y = x + N2;
      y = ATL_AlignPtr(y);
      Mjoin(PATL,copy)(N, X, incX, x, 1);
      Mjoin(PATL,zero)(N, y, 1);
   }
   for (j=0; j < Nnb; j += nb, A += incA)
   {
      #ifdef TCPLX
         const register size_t j2=j+j, nb2=nb+nb;
      #else
         #define j2 j
         #define nb2 nb
      #endif
      trmvK(nb, A, lda, x+j2, y+j2);
      gemv(N-j-nb, nb, one, A+nb2, lda, x+j2, 1, one, y+j2+nb2, 1);
      #ifndef TCPLX
         #undef j2
         #undef nb2
      #endif
   }
   #ifdef TCPLX
      j += j;
   #endif
   trmvK(Nr, A, lda, x+j, y+j);
   if (y != X)
      Mjoin(PATL,copy)(N, y, 1, X, incX);
   free(vp);
   return(0);
}
#ifndef TCPLX
   #undef N2
   #undef lda2
   #undef one
#endif

static int ATL_trmvLT
(
   const enum ATLAS_DIAG  Diag,
   const int nb,
   ATL_CINT N,
   const TYPE *A,
   ATL_CINT lda,
   TYPE *X,
   ATL_CINT incX
)
/*
 * RETURNS: 0 if TRMV was performed, non-zero if nothing done
 */
{
   static void (*trmvK)(ATL_CINT, const TYPE*, ATL_CINT, const TYPE*, TYPE*);
   void (*gemv)(ATL_CINT, ATL_CINT, const SCALAR, const TYPE*, ATL_CINT, 
                const TYPE*, ATL_CINT, const SCALAR, TYPE*, ATL_CINT);
   void *vp;
   TYPE *x, *y;
   const size_t opsize = (N*N+N+N)*sizeof(TYPE)SHIFT;
   size_t t0;
   #ifdef TCPLX
      size_t N2=N+N, lda2 = lda+lda;
      TYPE one[2] = {ATL_rone, ATL_rzero};
   #else
      #define N2 N
      #define lda2 lda
      #define one ATL_rone
   #endif
   const size_t incA = ((size_t)lda+1)*(nb SHIFT);
   ATL_CINT Nnb = ((N-1)/nb)*nb, Nr = N-Nnb;
   ATL_INT j;

   if (N < nb+nb)
      return(1);
   if (opsize > MY_CE)
      gemv = Mjoin(PATL,gemvT);
   else
      gemv = (opsize <= ATL_MulBySize(L1C_ELTS)) ? Mjoin(PATL,gemvT_L1) :
             Mjoin(PATL,gemvT_L2);
   trmvK = (Diag == AtlasNonUnit) ? ATL_trmvLTNk : ATL_trmvLTUk;
/*
 * If X is aligned to Cachelen wt inc=1, use it as y
 */
   t0 = (size_t) X;
   if (incX == 1 && (ATL_MulByCachelen(ATL_DivByCachelen(t0)) == t0))
   {
      ATL_INT i;
      vp = malloc(ATL_Cachelen+ATL_MulBySize(N));
      if (!vp)
         return(2);
      x = ATL_AlignPtr(vp);
      y = X;
      for (i=0; i < N2; i++)
      {
         x[i] = X[i];
         X[i] = ATL_rzero;
      }

   }
   else  /* allocate both X and Y */
   {
      vp = malloc((ATL_Cachelen+ATL_MulBySize(N))<<1);
      if (!vp)
         return(3);
      x = ATL_AlignPtr(vp);
      y = x + N2;
      y = ATL_AlignPtr(y);
      Mjoin(PATL,copy)(N, X, incX, x, 1);
      Mjoin(PATL,zero)(N, y, 1);
   }
   for (j=0; j < Nnb; j += nb, A += incA)
   {
      #ifdef TCPLX
         const register size_t j2=j+j, nb2=nb+nb;
      #else
         #define j2 j
         #define nb2 nb
      #endif
      trmvK(nb, A, lda, x+j2, y+j2);
      gemv(N-j-nb, nb, one, A+nb2, lda, x+j2+nb2, 1, one, y+j2, 1);
      #ifndef TCPLX
         #undef j2
         #undef nb2
      #endif
   }
   #ifdef TCPLX
      j += j;
   #endif
   trmvK(Nr, A, lda, x+j, y+j);
   if (y != X)
      Mjoin(PATL,copy)(N, y, 1, X, incX);
   free(vp);
   return(0);
}
#ifndef TCPLX
   #undef N2
   #undef lda2
   #undef one
#endif
void Mjoin(PATL,trmv)
(
   const enum ATLAS_UPLO  Uplo,
   const enum ATLAS_TRANS Trans,
   const enum ATLAS_DIAG  Diag,
   const int              N,
   const TYPE             *A,
   const int              lda,
   TYPE                   *X,
   const int              incX
)
/*
 * Purpose
 * =======
 *
 * Mjoin( PATL, trmv ) performs one of the matrix-vector operations
 *
 *    x := A * x,   or   x := conjg( A  ) * x,   or
 *
 *    x := A'* x,   or   x := conjg( A' ) * x,
 *
 * where x is an n-element vector and  A is an n by n unit, or non-unit,
 * upper or lower triangular matrix.
 *
 * This is a blocked version of the algorithm.  For a more detailed des-
 * cription of  the arguments of this function, see the reference imple-
 * mentation in the ATLAS/src/blas/reference directory.
 *
 * ---------------------------------------------------------------------
 */
{
   int ierr=1;
   #define NBMV 120   /* LCM(1,2,3,4,5,6,8); no NU cleanup most kerns */
/*
 * Small-case code just calls reference to avoid copies and setup costs
 */
   if (N < NBMV+NBMV)
   {
      Mjoin(PATL,reftrmv)(Uplo, Trans, Diag, N, A, lda, X, incX);
      return;
   }
/*
 * Handle conjugate transpose by conjugating input/output vector
 */
   #ifdef TCPLX
   if (Trans == AtlasConjTrans || Trans == AtlasConj)
   {
      Mjoin(PATLU,scal)(N, ATL_rnone, X+1, incX+incX);
      Mjoin(PATL,trmv)(Uplo, (Trans == AtlasConj) ? AtlasNoTrans:AtlasTrans, 
                       Diag, N, A, lda, X, incX);
      Mjoin(PATLU,scal)(N, ATL_rnone, X+1, incX+incX);
      return;
   }
   #endif
   if (Uplo == AtlasUpper)
   {
      if (Trans == AtlasNoTrans)
         ierr = ATL_trmvUN(Diag, NBMV, N, A, lda, X, incX);
      else
         ierr = ATL_trmvUT(Diag, NBMV, N, A, lda, X, incX);
   }
   else if (Trans == AtlasNoTrans)
      ierr = ATL_trmvLN(Diag, NBMV, N, A, lda, X, incX);
   else /* if (Trans == AtlasTrans) */
      ierr = ATL_trmvLT(Diag, NBMV, N, A, lda, X, incX);
   if (ierr)
      Mjoin(PATL,reftrmv)(Uplo, Trans, Diag, N, A, lda, X, incX);
@beginskip
   return;
   if (incX == 1)
   {
      void *vp;
      TYPE *y;
      vp = malloc(ATL_Cachelen + ATL_MulBySize(N));
      y = ATL_Align2Ptr(vp, A);
      Mjoin(PATL,zero)(N, y, 1);
      if (Uplo == AtlasLower)
      {
         if (Trans == AtlasNoTrans)
         {
            if (Diag == AtlasNonUnit)
               ATL_trmvLNNk(N, A, lda, X, y);
            else
               ATL_trmvLNUk(N, A, lda, X, y);
         }
         else
         {
            if (Diag == AtlasNonUnit)
               ATL_trmvLTNk(N, A, lda, X, y);
            else
               ATL_trmvLTUk(N, A, lda, X, y);
         }
      }
      else
      {
         if (Trans == AtlasNoTrans)
         {
            if (Diag == AtlasNonUnit)
               ATL_trmvUNNk(N, A, lda, X, y);
            else
               ATL_trmvUNUk(N, A, lda, X, y);
         }
         else
         {
            if (Diag == AtlasNonUnit)
               ATL_trmvUTNk(N, A, lda, X, y);
            else
               ATL_trmvUTUk(N, A, lda, X, y);
         }
      }
      Mjoin(PATL,copy)(N, y, 1, X, incX);
      return;
   }
   Mjoin(PATL,reftrmv)(Uplo, Trans, Diag, N, A, lda, X, incX);
@endskip
}
@ROUT ATL_trsv

static int ATL_trsvUN_k
(
   const enum ATLAS_DIAG Diag,
   const int nb,
   ATL_CINT N,
   const TYPE *A,
   ATL_CINT lda,
   TYPE *X,
   ATL_CINT incX
)
{
   void (*gemv)(ATL_CINT, ATL_CINT, const SCALAR, const TYPE*, ATL_CINT,
                const TYPE*, ATL_CINT, const SCALAR, TYPE*, ATL_CINT);
   void *vp=NULL;
   TYPE *x;
   const TYPE *a;
   const size_t opsize = (N*N+N+N)*sizeof(TYPE)SHIFT;
   size_t t0;
   #ifdef TCPLX
      size_t N2=N+N, lda2 = lda+lda;
      TYPE one[2] = {ATL_rone, ATL_rzero}, none[2] = {ATL_rnone, ATL_rzero};
   #else
      #define N2 N
      #define lda2 lda
      #define one ATL_rone
      #define none ATL_rnone
   #endif
   const size_t incA = ((size_t)lda2)*nb;
   ATL_CINT Nnb = ((N-1)/nb)*nb, Nr = N-Nnb;
   ATL_INT j;

   if (N < nb+nb)
      return(1);
   if (opsize > MY_CE)
      gemv = Mjoin(PATL,gemvN);
   else
      gemv = (opsize <= ATL_MulBySize(L1C_ELTS)) ? Mjoin(PATL,gemvN_L1) :
             Mjoin(PATL,gemvN_L2);
/*
 * If X is aligned to Cachelen wt inc=1, use it as y
 */
   t0 = (size_t) X;
   if (incX == 1 && (ATL_MulByCachelen(ATL_DivByCachelen(t0)) == t0))
      x = X;
   else  /* allocate aligned X to hopefully avoid GEMV copying */
   {
      vp = malloc(ATL_Cachelen+ATL_MulBySize(N));
      if (!vp)
         return(2);
      x = ATL_AlignPtr(vp);
      Mjoin(PATL,copy)(N, X, incX, x, 1);
   }

   a = A + ((size_t)lda2)*(N-nb);
   for (j=N-nb; j >= Nr; j -= nb, a -= incA)
   {
      #ifdef TCPLX
         const register size_t j2 = j + j;
      #else
         #define j2 j
      #endif
      Mjoin(PATL,reftrsv)(AtlasUpper, AtlasNoTrans, Diag, nb, a+j2, lda, 
                          x+j2, 1);
      Mjoin(PATL,scal)(nb, none, x+j2, 1);
      gemv(j, nb, one, a, lda, x+j2, 1, one, x, 1);
      #ifndef TCPLX
         #undef j2
      #endif
   }
   Mjoin(PATL,reftrsv)(AtlasUpper, AtlasNoTrans, Diag, Nr, A, lda, x, 1);
   if (x != X)
   {
      Mjoin(PATL,scal)(Nr, none, x, 1);
      Mjoin(PATL,cpsc)(N, none, x, 1, X, incX);
      free(vp);
   }
   else
      Mjoin(PATL,scal)(Nnb, none, x+(Nr SHIFT), 1);
   return(0);
}
#ifndef TCPLX
   #undef N2
   #undef lda2
   #undef one
   #undef none
#endif

static int ATL_trsvUT_k
(
   const enum ATLAS_DIAG Diag,
   const int nb,
   ATL_CINT N,
   const TYPE *A,
   ATL_CINT lda,
   TYPE *X,
   ATL_CINT incX
)
{
   void (*gemv)(ATL_CINT, ATL_CINT, const SCALAR, const TYPE*, ATL_CINT,
                const TYPE*, ATL_CINT, const SCALAR, TYPE*, ATL_CINT);
   void *vp=NULL;
   TYPE *x;
   const size_t opsize = (N*N+N+N)*sizeof(TYPE)SHIFT;
   size_t t0;
   #ifdef TCPLX
      size_t N2=N+N, lda2 = lda+lda;
      const int nb2 = nb+nb;
      TYPE one[2] = {ATL_rone, ATL_rzero}, none[2] = {ATL_rnone, ATL_rzero};
   #else
      #define N2 N
      #define lda2 lda
      #define one ATL_rone
      #define none ATL_rnone
      #define nb2 nb
   #endif
   const size_t incA = ((size_t)lda2)*nb;
   ATL_CINT Nnb = ((N-1)/nb)*nb, Nr = N-Nnb;
   ATL_INT j;

   if (N < nb+nb)
      return(1);
   if (opsize > MY_CE)
      gemv = Mjoin(PATL,gemvT);
   else
      gemv = (opsize <= ATL_MulBySize(L1C_ELTS)) ? Mjoin(PATL,gemvT_L1) :
             Mjoin(PATL,gemvT_L2);
/*
 * If X is aligned to Cachelen wt inc=1, use it as y
 */
   t0 = (size_t) X;
   if (incX == 1 && (ATL_MulByCachelen(ATL_DivByCachelen(t0)) == t0))
      x = X;
   else  /* allocate aligned X to hopefully avoid GEMV copying */
   {
      vp = malloc(ATL_Cachelen+ATL_MulBySize(N));
      if (!vp)
         return(2);
      x = ATL_AlignPtr(vp);
      Mjoin(PATL,copy)(N, X, incX, x, 1);
   }

   Mjoin(PATL,reftrsv)(AtlasUpper, AtlasTrans, Diag, Mmin(N,nb), A, lda, x, 1);
   A += incA;
   for (j=nb; j < N; j += nb, A += incA)
   {
      #ifdef TCPLX
         const register size_t j2 = j + j;
      #else
         #define j2 j
      #endif
      register int kb = N-j;
      kb = (kb >= nb) ? nb : kb;
      Mjoin(PATL,scal)(nb, none, x+j2-nb2, 1);
      gemv(j, kb, one, A, lda, x, 1, one, x+j2, 1);
      Mjoin(PATL,reftrsv)(AtlasUpper, AtlasTrans, Diag, kb, A+j2, lda, 
                          x+j2, 1);
      #ifndef TCPLX
         #undef j2
      #endif
   }
   j = Nnb SHIFT;
   if (x != X)
   {
      if (Nnb)
      {
         Mjoin(PATL,scal)(Nr, none, x+j, 1);
         Mjoin(PATL,cpsc)(N, none, x, 1, X, incX);
      }
      else
         Mjoin(PATL,copy)(N, x, 1, X, incX);
      free(vp);
   }
   else if (Nnb)
      Mjoin(PATL,scal)(Nnb, none, x, 1);
   return(0);
}
#ifndef TCPLX
   #undef N2
   #undef nb2
   #undef lda2
   #undef one
   #undef none
#endif

static int ATL_trsvLN_k
(
   const enum ATLAS_DIAG Diag,
   const int nb,
   ATL_CINT N,
   const TYPE *A,
   ATL_CINT lda,
   TYPE *X,
   ATL_CINT incX
)
{
   void (*gemv)(ATL_CINT, ATL_CINT, const SCALAR, const TYPE*, ATL_CINT,
                const TYPE*, ATL_CINT, const SCALAR, TYPE*, ATL_CINT);
   void *vp=NULL;
   TYPE *x, *a;
   const size_t opsize = (N*N+N+N)*sizeof(TYPE)SHIFT;
   size_t t0;
   #ifdef TCPLX
      const size_t N2=N+N, lda2 = lda+lda, nb2 = nb+nb;
      const TYPE one[2] = {ATL_rone, ATL_rzero}, 
                 none[2] = {ATL_rnone, ATL_rzero};
   #else
      #define N2 N
      #define lda2 lda
      #define one ATL_rone
      #define none ATL_rnone
      #define nb2 nb
   #endif
   const size_t incA = ((size_t)lda+1)*(nb SHIFT);
   ATL_CINT Nnb = ((N-1)/nb)*nb, Nr = N-Nnb;
   ATL_INT j;

   if (N < nb+nb)
      return(1);
   if (opsize > MY_CE)
      gemv = Mjoin(PATL,gemvN);
   else
      gemv = (opsize <= ATL_MulBySize(L1C_ELTS)) ? Mjoin(PATL,gemvN_L1) :
             Mjoin(PATL,gemvN_L2);
/*
 * If X is aligned to Cachelen wt inc=1, use it as y
 */
   t0 = (size_t) X;
   if (incX == 1 && (ATL_MulByCachelen(ATL_DivByCachelen(t0)) == t0))
      x = X;
   else  /* allocate aligned X to hopefully avoid GEMV copying */
   {
      vp = malloc(ATL_Cachelen+ATL_MulBySize(N));
      if (!vp)
         return(2);
      x = ATL_AlignPtr(vp);
      Mjoin(PATL,copy)(N, X, incX, x, 1);
   }

   for (j=0; j < Nnb; j += nb, A += incA)
   {
      #ifdef TCPLX
         const register size_t j2 = j + j;
      #else
         #define j2 j
      #endif
      Mjoin(PATL,reftrsv)(AtlasLower, AtlasNoTrans, Diag, nb, A, lda, x+j2, 1);
      Mjoin(PATL,scal)(nb, none, x+j2, 1);
      gemv(N-j-nb, nb, one, A+nb2, lda, x+j2, 1, one, x+j2+nb2, 1);
      #ifndef TCPLX
         #undef j2
      #endif
   }
   #ifdef TCPLX
      j += j;
   #endif
   Mjoin(PATL,reftrsv)(AtlasLower, AtlasNoTrans, Diag, Nr, A, lda, x+j, 1);
   if (x != X)
   {
      Mjoin(PATL,scal)(Nr, none, x+j, 1);
      Mjoin(PATL,cpsc)(N, none, x, 1, X, incX);
      free(vp);
   }
   else
      Mjoin(PATL,scal)(Nnb, none, x, 1);
   return(0);
}
#ifndef TCPLX
   #undef N2
   #undef lda2
   #undef nb2
   #undef one
   #undef none
#endif

static int ATL_trsvLT_k
(
   const enum ATLAS_DIAG Diag,
   const int nb,
   ATL_CINT N,
   const TYPE *A,
   ATL_CINT lda,
   TYPE *X,
   ATL_CINT incX
)
{
   void (*gemv)(ATL_CINT, ATL_CINT, const SCALAR, const TYPE*, ATL_CINT,
                const TYPE*, ATL_CINT, const SCALAR, TYPE*, ATL_CINT);
   void *vp=NULL;
   TYPE *x, *a;
   const size_t opsize = (N*N+N+N)*sizeof(TYPE)SHIFT;
   size_t t0;
   #ifdef TCPLX
      const size_t N2=N+N, lda2 = lda+lda, nb2 = nb+nb;
      const TYPE one[2] = {ATL_rone, ATL_rzero}, 
                 none[2] = {ATL_rnone, ATL_rzero};
   #else
      #define N2 N
      #define lda2 lda
      #define one ATL_rone
      #define none ATL_rnone
      #define nb2 nb
   #endif
   const size_t incA = ((size_t)lda+1)*(nb SHIFT);
   ATL_CINT Nnb = ((N-1)/nb)*nb, Nr = N-Nnb;
   ATL_INT j;
   int pnb;

   if (N < nb+nb)
      return(1);
   if (opsize > MY_CE)
      gemv = Mjoin(PATL,gemvT);
   else
      gemv = (opsize <= ATL_MulBySize(L1C_ELTS)) ? Mjoin(PATL,gemvT_L1) :
             Mjoin(PATL,gemvT_L2);
/*
 * If X is aligned to Cachelen wt inc=1, use it as x
 */
   t0 = (size_t) X;
   if (incX == 1 && (ATL_MulByCachelen(ATL_DivByCachelen(t0)) == t0))
      x = X;
   else  /* allocate aligned X to hopefully avoid GEMV copying */
   {
      vp = malloc(ATL_Cachelen+ATL_MulBySize(N));
      if (!vp)
         return(2);
      x = ATL_AlignPtr(vp);
      Mjoin(PATL,copy)(N, X, incX, x, 1);
   }
   j = (N-Nr)SHIFT;
   A += (lda+1)*j;
   Mjoin(PATL,reftrsv)(AtlasLower, AtlasTrans, Diag, Nr, A, lda, x+j, 1);
   pnb = Nr;
   A -= incA;

   for (j=N-Nr-nb; j >= 0; j -= nb, A -= incA)
   {
      #ifdef TCPLX
         const register size_t j2 = j + j;
      #else
         #define j2 j
      #endif
      Mjoin(PATL,scal)(pnb, none, x+j2+nb2, 1);
      pnb = nb;
      gemv(N-j-nb, nb, one, A+nb2, lda, x+j2+nb2, 1, one, x+j2, 1);
      Mjoin(PATL,reftrsv)(AtlasLower, AtlasTrans, Diag, nb, A, lda, x+j2, 1);
      #ifndef TCPLX
         #undef j2
      #endif
   }
   if (x != X)
   {
      if (Nnb)
      {
         Mjoin(PATL,scal)(nb, none, x, 1);
         Mjoin(PATL,cpsc)(N, none, x, 1, X, incX);
      }
      else
         Mjoin(PATL,copy)(N, x, 1, X, incX);
      free(vp);
   }
   else if (Nnb)
      Mjoin(PATL,scal)(N-nb, none, x+nb2, 1);
   return(0);
}
#ifndef TCPLX
   #undef N2
   #undef lda2
   #undef nb2
   #undef one
   #undef none
#endif

void Mjoin(PATL,trsv)
(
   const enum ATLAS_UPLO  Uplo,
   const enum ATLAS_TRANS Trans,
   const enum ATLAS_DIAG  Diag,
   const int              N,
   const TYPE             *A,
   const int              lda,
   TYPE                   *X,
   const int              incX
)
/*
 * Purpose
 * =======
 *
 * Mjoin( PATL, trsv ) solves one of the systems of equations
 *
 *    A * x = b,   or   conjg( A  ) * x = b,   or
 *
 *    A'* x = b,   or   conjg( A' ) * x = b,
 *
 * where b and x are n-element vectors and  A is an n by n unit, or non-
 * unit, upper or lower triangular matrix.
 *
 * No test for  singularity  or  near-singularity  is included  in  this
 * routine. Such tests must be performed before calling this routine.
 *
 * This is a blocked version of the algorithm.  For a more detailed des-
 * cription of  the arguments of this function, see the reference imple-
 * mentation in the ATLAS/src/blas/reference directory.
 *
 * ---------------------------------------------------------------------
 */
{
   int ierr=1;
   #define NBSV 120  /* LCM(1,2,3,4,5,6,8), min NU cleanup in gemv kerns */
   if (N >= NBSV+NBSV)
   {
      #ifdef TCPLX
      if (Trans == AtlasConjTrans)
      {
         Mjoin(PATLU,scal)(N, ATL_rnone, X+1, incX+incX);
         Mjoin(PATL,trsv)(Uplo, AtlasTrans, Diag, N, A, lda, X, incX);
         Mjoin(PATLU,scal)(N, ATL_rnone, X+1, incX+incX);
         return;
      }
      else if (Trans == AtlasConj)
      {  
         Mjoin(PATLU,scal)(N, ATL_rnone, X+1, incX+incX);
         Mjoin(PATL,trsv)(Uplo, AtlasNoTrans, Diag, N, A, lda, X, incX);
         Mjoin(PATLU,scal)(N, ATL_rnone, X+1, incX+incX);
         return;
      }

      #endif
      if (Uplo == AtlasUpper)
      {
         if (Trans == AtlasNoTrans)
            ierr = ATL_trsvUN_k(Diag, NBSV, N, A, lda, X, incX);
         else
            ierr = ATL_trsvUT_k(Diag, NBSV, N, A, lda, X, incX);
      }
      else if (Trans == AtlasNoTrans)
         ierr = ATL_trsvLN_k(Diag, NBSV, N, A, lda, X, incX);
      else
         ierr = ATL_trsvLT_k(Diag, NBSV, N, A, lda, X, incX);
   }
   if (ierr)
      Mjoin(PATL,reftrsv)(Uplo, Trans, Diag, N, A, lda, X, incX);
}
@ROUT ATL_symv ATL_hemv
/*
 * Guess as to whether GEMV-based SYRK will beat ref.  Will on any arch
 * where the compiler is not too whoopy (ARM) or where vectorization provides
 * faster memory load as well as computation (x86 with vectorization).
 * Single precision complex has enough flops/load to be almost always
 * compute-bound enough that the auto-GEMV-tuning outweighs the double load.
 */
#if defined(ATL_GAS_ARM)
   #define USE_GEMV_BASED 1
#elif defined(SREAL)
   #ifdef ATL_SSE1
      #define USE_GEMV_BASED 1
   #endif
#elif defined(DREAL)
   #ifdef ATL_SSE2
      #define USE_GEMV_BASED 1
   #endif
#elif defined(SCPLX)
   #define USE_GEMV_BASED 1
#elif defined(DCPLX)
   #ifdef ATL_SSE2
      #define USE_GEMV_BASED 1
   #endif
#endif

#ifdef USE_GEMV_BASED
typedef void (*ATL_symvK_t)
   (const enum ATLAS_UPLO, const int, const SCALAR, const TYPE*, const int,
    const TYPE*, const int, const SCALAR, TYPE*, const int);

static void ATL_symvL
(
   ATL_symvK_t symvK,
   const int NB,
   ATL_CINT N,
   const TYPE *A,
   ATL_CINT lda,
   const TYPE *x,
@ROUT ATL_symv
   TYPE  *y
)
{
@ROUT ATL_hemv
   TYPE  *y,
   const TYPE *xt,
   TYPE  *yt
)
{
@ROUT ATL_symv
   #define one ATL_rone
   @define j2 @j@
   @define i2 @i@
   @define Mmb2 @Mmb@
   @define xt @x@
   @define yt @y@
@ROUT ATL_hemv
   const TYPE one[2] = {ATL_rone, ATL_rzero};
   ATL_INT Mmb2;
   @define j2 @j2@
   @define i2 @i2@
   @define Mmb2 @Mmb2@
   @define xt @xt@
   @define yt @yt@
@ROUT ATL_symv ATL_hemv
   ATL_INT Mmb, mr, MB, j;
   const size_t incA = (NB SHIFT)*lda;
   const size_t opsize = ((size_t)(N+8)*(N+4))*(sizeof(TYPE)>>1)SHIFT;
   void (*gemvT)(ATL_CINT, ATL_CINT, const SCALAR, const TYPE*, ATL_CINT,
                 const TYPE*, ATL_CINT, const SCALAR, TYPE*, ATL_CINT);
   void (*gemvN)(ATL_CINT, ATL_CINT, const SCALAR, const TYPE*, ATL_CINT,
                 const TYPE*, ATL_CINT, const SCALAR, TYPE*, ATL_CINT);

   if (opsize > MY_CE)
   {
      gemvT = Mjoin(PATL,gemvT);
      gemvN = Mjoin(PATL,gemvN_L2);
   }
   else if (opsize <= ATL_MulBySize(L1C_ELTS))
   {
      gemvT = Mjoin(PATL,gemvT_L1);
      gemvN = Mjoin(PATL,gemvN_L1);
   }
   else
   {
      gemvT = Mjoin(PATL,gemvT_L2);
      gemvN = Mjoin(PATL,gemvN_L2);
   }
/*
 * Choose MB such that A is retained in L2 cache for second GEMV call
 * If partial block is tiny, absorbe it into last block since cache is not
 * precise anyway.
 */
   MB = ATL_DivBySize(MY_CE) / NB;
   MB = (MB > N || MB < 240) ? N : MB;
@ROUT ATL_hemv `   Mmb2 = Mmb+Mmb;`
   for (j=0; j < N; j += NB, A += incA)
   {
@ROUT ATL_hemv `      const register size_t j2 = j+j;`
      register int i, nb=N-j;
      nb = (nb >= NB) ? NB : nb;
      symvK(AtlasLower, nb, one, A+@(j2), lda, x+@(j2), 1, one, y+@(j2), 1);
      for (i=j+nb; i < N; i += MB)
      {
@ROUT ATL_hemv `         const register size_t i2 = i+i;`
         register int mb = N-i;
         mb = (mb >= MB) ? MB : mb;
         gemvT(mb, nb, one, A+@(i2), lda, @(xt)+@(i2), 1, one, @(yt)+@(j2), 1);
         gemvN(mb, nb, one, A+@(i2), lda, x+@(j2), 1, one, y+@(i2), 1);
      }
   }
}
static void ATL_symvU
(
   ATL_symvK_t symvK,
   const int NB,
   ATL_CINT N,
   const TYPE *A,
   ATL_CINT lda,
   const TYPE *x,
@ROUT ATL_symv
   TYPE  *y
)
{
@ROUT ATL_hemv
   TYPE  *y,
   const TYPE *xt,
   TYPE  *yt
)
{
@ROUT ATL_hemv
   const TYPE one[2] = {ATL_rone, ATL_rzero};
   ATL_INT Mmb2;
@ROUT ATL_symv ATL_hemv
   ATL_INT Mmb, mr, MB, j;
   const size_t incA = (NB SHIFT)*lda;
   const size_t opsize = ((size_t)(N+8)*(N+4))*(sizeof(TYPE)>>1)SHIFT;
   void (*gemvT)(ATL_CINT, ATL_CINT, const SCALAR, const TYPE*, ATL_CINT,
                 const TYPE*, ATL_CINT, const SCALAR, TYPE*, ATL_CINT);
   void (*gemvN)(ATL_CINT, ATL_CINT, const SCALAR, const TYPE*, ATL_CINT,
                 const TYPE*, ATL_CINT, const SCALAR, TYPE*, ATL_CINT);

   if (opsize > MY_CE)
   {
      gemvT = Mjoin(PATL,gemvT);
      gemvN = Mjoin(PATL,gemvN_L2);
   }
   else if (opsize <= ATL_MulBySize(L1C_ELTS))
   {
      gemvT = Mjoin(PATL,gemvT_L1);
      gemvN = Mjoin(PATL,gemvN_L1);
   }
   else
   {
      gemvT = Mjoin(PATL,gemvT_L2);
      gemvN = Mjoin(PATL,gemvN_L2);
   }
/*
 * Choose MB such that A is retained in L2 cache for second GEMV call
 * If partial block is tiny, absorbe it into last block since cache is not
 * precise anyway.
 */
   MB = ATL_DivBySize(MY_CE) / NB;
   MB = (MB > N || MB < 240) ? N : MB;
@ROUT ATL_hemv `   Mmb2 = Mmb+Mmb;`
   for (j=0; j < N; j += NB, A += incA)
   {
@ROUT ATL_hemv `      const register size_t j2 = j+j;`
      register int i, nb=N-j;
      nb = (nb >= NB) ? NB : nb;
      for (i=0; i < j; i += MB)
      {
@ROUT ATL_hemv `         const register size_t i2 = i+i;`
         register int mb = j-i;
         mb = (mb >= MB) ? MB : mb;
         gemvT(mb, nb, one, A+@(i2), lda, @(xt)+@(i2), 1, one, @(yt)+@(j2), 1);
         gemvN(mb, nb, one, A+@(i2), lda, x+@(j2), 1, one, y+@(i2), 1);
      }
      symvK(AtlasUpper, nb, one, A+@(j2), lda, x+@(j2), 1, one, y+@(j2), 1);
   }
}
#endif

@ROUT ATL_symv
void Mjoin(PATL,symv)
(
   const enum ATLAS_UPLO Uplo,
   const int             N,
   const SCALAR          alpha,
   const TYPE            *A,
   const int             lda,
   const TYPE            *X,
   const int             incX,
   const SCALAR          beta,
   TYPE                  *Y,
   const int             incY
)
/*
 * Purpose
 * =======
 *
 * Mjoin( PATL, symv ) performs the matrix-vector operation
 *
 *    y := alpha * A * x + beta * y,
 *
 * where alpha and beta are scalars, x and y are n-element vectors and A
 * is an n by n symmetric matrix.
 *
 * This is a blocked version of the algorithm.  For a more detailed des-
 * cription of  the arguments of this function, see the reference imple-
 * mentation in the ATLAS/src/blas/reference directory.
 *
 * ---------------------------------------------------------------------
 */
{
   const int BETA0 = (beta == ATL_rzero);
   const int BETA1 = (beta == ATL_rone);
   const int ALPHA1 = (alpha == ATL_rone);
   const int ALPHA0 = (alpha == ATL_rzero);
   if (N <= 0 || (ALPHA0 && BETA1))
      return;
   if (ALPHA0)
   {
      if (BETA0)
         Mjoin(PATL,zero)(N, Y, incY);
      else
         Mjoin(PATL,scal)(N, beta, Y, incY);
      return;
   }
#ifdef USE_GEMV_BASED
   if (N >= 240)
   {
      void *vp=NULL;
      TYPE *x=(TYPE*)X, *y=Y;
      const size_t tX = (size_t)X, tY = (size_t)Y;
      const int COPYY = !(incY == 1 &&
                          (ATL_MulByCachelen(ATL_DivByCachelen(tY)) == tY));
      const int COPYX = !(incX == 1 && (COPYY || ALPHA1) &&
                          (ATL_MulByCachelen(ATL_DivByCachelen(tX)) == tX));
      TYPE calp=one, cbet=one;
      if (COPYX || COPYY)
      {
         TYPE *tp;
         tp = vp = malloc((COPYX+COPYY)*(ATL_Cachelen+ATL_MulBySize(N)));
         if (!vp)
         {
            Mjoin(PATL,refsymv)(Uplo, N, alpha, A, lda, X, incX, beta, Y, incY);
            return;
         }
         if (COPYX)
         {
            x = ATL_AlignPtr(tp);
            if (COPYY || alpha == ATL_rone)
               Mjoin(PATL,copy)(N, X, incX, x, 1);
            else
               Mjoin(PATL,cpsc)(N, alpha, X, incX, x, 1);
            tp = x + N;
         }
         if (COPYY)
         {
            calp = alpha;
            cbet = beta;
            y = ATL_AlignPtr(tp);
            Mjoin(PATL,zero)(N, y, 1);
         }
         else if (BETA0)
            Mjoin(PATL,zero)(N, y, 1);
         else if (!BETA1)
            Mjoin(PATL,scal)(N, beta, y, 1);
      }
      else if (BETA0)
         Mjoin(PATL,zero)(N, y, 1);
      else if (!BETA1)
         Mjoin(PATL,scal)(N, beta, y, 1);
      if (Uplo == AtlasLower)
         ATL_symvL(Mjoin(PATL,refsymv), 120, N, A, lda, x, y);
      else
         ATL_symvU(Mjoin(PATL,refsymv), 120, N, A, lda, x, y);
      if (COPYY)
         Mjoin(PATL,axpby)(N, calp, y, 1, cbet, Y, incY);
      free(vp);
      return;
   }
#endif
   Mjoin(PATL,refsymv)(Uplo, N, alpha, A, lda, X, incX, beta, Y, incY);
}
@ROUT ATL_hemv
void Mjoin(PATL,hemv)
(
   const enum ATLAS_UPLO Uplo,
   const int             N,
   const SCALAR          alpha,
   const TYPE            *A,
   const int             lda,
   const TYPE            *X,
   const int             incX,
   const SCALAR          beta,
   TYPE                  *Y,
   const int             incY
)
/*
 * Purpose
 * =======
 *
 * Mjoin( PATL, hemv ) performs the matrix-vector operation
 *
 *    y := alpha * A * x + beta * y,
 *
 * where alpha and beta are scalars, x and y are n-element vectors and A
 * is an n by n Hermitian matrix.
 *
 * This is a blocked version of the algorithm.  For a more detailed des-
 * cription of  the arguments of this function, see the reference imple-
 * mentation in the ATLAS/src/blas/reference directory.
 *
 * ---------------------------------------------------------------------
 */
{
   const int BETA0 = (*beta == ATL_rzero && beta[1] == ATL_rzero);
   const int BETA1 = (*beta == ATL_rone && beta[1] == ATL_rzero);
   const int ALPHA1 = (*alpha == ATL_rone && alpha[1] == ATL_rzero);
   const int ALPHA0 = (*alpha == ATL_rzero && alpha[1] == ATL_rzero);
   if (N <= 0 || (ALPHA0 && BETA1))
      return;
   if (ALPHA0)
   {
      if (BETA0)
         Mjoin(PATL,zero)(N, Y, incY);
      else
         Mjoin(PATL,scal)(N, beta, Y, incY);
      return;
   }
#ifdef USE_GEMV_BASED
   if (N >= 240)
   {
      void *vp=NULL;
      TYPE *x=(TYPE*)X, *y=Y, *xh, *yh;
      const size_t tX = (size_t)X, tY = (size_t)Y, N2 = N+N;
      const int COPYY = !(incY == 1 &&
                          (ATL_MulByCachelen(ATL_DivByCachelen(tY)) == tY));
      const int COPYX = !(incX == 1 && (COPYY || ALPHA1) &&
                          (ATL_MulByCachelen(ATL_DivByCachelen(tX)) == tX));
      const TYPE one[2] = {ATL_rone, ATL_rzero};
      const TYPE *calp=one, *cbet=one;
      TYPE *tp;
      tp = vp = malloc((COPYX+COPYY+2)*(ATL_Cachelen+ATL_MulBySize(N)));
      if (!vp)
      {
         Mjoin(PATL,refhemv)(Uplo, N, alpha, A, lda, X, incX, beta, Y, incY);
         return;
      }
      yh = ATL_AlignPtr(tp);
      Mjoin(PATL,zero)(N, yh, 1);
      tp = yh + N2;
      xh = ATL_AlignPtr(tp);
      tp = xh + N2;
      if (COPYX)
      {
         x = ATL_AlignPtr(tp);
         if (COPYY || ALPHA1)
         {
            register ATL_INT i;
            register const size_t incX2 = incX+incX;
            const TYPE *xx=X;
            for (i=0; i < N2; i += 2, xx += incX2)
            {
               xh[i] = x[i] = *xx;
               xh[i+1] = -(x[i+1] = xx[1]);
            }
         }
         else if (alpha[1] == ATL_rzero)
         {
            register ATL_INT i;
            register const size_t incX2 = incX+incX;
            register const TYPE ra=(*alpha), ia=alpha[1];
            const TYPE *xx=X;
            for (i=0; i < N2; i += 2, xx += incX2)
            {
               register TYPE rx = *xx, ix = xx[1];
               x[i] = rx*ra;
               x[i+1] = ix*ra;
               xh[i] = rx;
               xh[i+1] = -ix;
            }
         }
         else
         {
            register ATL_INT i;
            register const size_t incX2 = incX+incX;
            register const TYPE ra=(*alpha), ia=alpha[1];
            const TYPE *xx=X;
            for (i=0; i < N2; i += 2, xx += incX2)
            {
               register TYPE rx = *xx, ix = xx[1];
               x[i] = rx*ra - ix*ia;
               x[i+1] = rx*ia + ix*ra;
               xh[i] = rx;
               xh[i+1] = -ix;
            }
         }
         tp = x + N2;
      }
      else
         Mjoin(PATL,copyConj)(N, X, incX, xh, 1);
      if (COPYY)
      {
         calp = alpha;
         cbet = beta;
         y = ATL_AlignPtr(tp);
         Mjoin(PATL,zero)(N, y, 1);
      }
      else if (BETA0)
         Mjoin(PATL,zero)(N, y, 1);
      else if (!BETA1)
         Mjoin(PATL,scal)(N, beta, y, 1);
      if (Uplo == AtlasLower)
         ATL_symvL(Mjoin(PATL,refhemv), 120, N, A, lda, x, y, xh, yh);
      else
         ATL_symvU(Mjoin(PATL,refhemv), 120, N, A, lda, x, y, xh, yh);
      if (COPYY)
      {
         Mjoin(PATL,axpbyConj)(N, alpha, yh, 1, calp, y, 1);
         Mjoin(PATL,axpby)(N, one, y, 1, cbet, Y, incY);
      }
      else
         Mjoin(PATL,axpyConj)(N, alpha, yh, 1, Y, incY);
      free(vp);
      return;
   }
#endif
   Mjoin(PATL,refhemv)(Uplo, N, alpha, A, lda, X, incX, beta, Y, incY);
}
@ROUT s1nxtune
   @define fop @SYR@
   @define op @S1@
@ROUT s2nxtune
   @define fop @SYR2@
   @define op @S2@
   @define nv @2@
@ROUT ! s2nxtune
   @define nv @1@
@ROUT s1nxtune s2nxtune svnxtune hvnxtune tmnxtune tsnxtune
@ROUT @push
@extract -b @(topd)/cw.inc lang=c -define cwdate 2010

#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include "atlas_misc.h"
#include "atlas_tst.h"
#include "atlas_lvl2.h"
#include "atlas_level1.h"
#include "atlas_genparse.h"
#include "atlas_gentesttime.h"
int ATL_KERN_NX=16;

#if defined(__MINGW32__) || defined(__MINGW64__)
@extract -b @(topd)/Clint/atlconf.base rout=MinGWPATH

#endif

static double GetTime
(
   enum ATLAS_UPLO Uplo,/* which triangle? */
   int verb,            /* verbosity */
   int nreps,           /* number of reps to do for one timing sample */
   size_t flushelts,    /* size of area to flush to avoid cache reuse */
   ATL_CINT N,          /* matrix size */
   int NX               /* what to set ref/kernel crossover to */
)
{
   size_t setsz, nsets, accsz, Nt;
   double t0, t1;
   void *vp;
   TYPE *tp, *x, *y, *a;
   #ifdef TCPLX
      const TYPE one[2] = {ATL_rone, ATL_rzero};
   #else
      const TYPE one = ATL_rone;
   #endif
   int i, j;

   ATL_KERN_NX = NX;
   accsz = @(nv)*N + ((size_t)N)*(N>>1);
   setsz = @(nv)*N + ((size_t)N)*N;
   nsets = (flushelts + accsz-1)/accsz;
   nsets = (nsets) ? nsets : 1;
   Nt = nsets * setsz;
   tp = vp = malloc(ATL_MulBySize(Nt));
   assert(vp);
   Mjoin(PATL,gegen)(Nt, 1, tp, Nt, N+127*37);
   t0 = time00();
   for (j=0, i=nreps; i; i--)
   {
      x = tp + j*setsz;
   @iif nv = 2
      y = x + N;
      a = y + N;
   @endiif
   @iif nv = 1
      a = x + N;
   @endiif
   @ROUT
@ROUT s2nxtune
   #ifdef TCPLX
      Mjoin(PATL,her2)(Uplo, N, one, x, 1, y, 1, a, N);
   #else
      Mjoin(PATL,syr2)(Uplo, N, ATL_rone, x, 1, y, 1, a, N);
   #endif
@ROUT s1nxtune
   #ifdef TCPLX
      Mjoin(PATL,her)(Uplo, N, ATL_rone, x, 1, a, N);
   #else
      Mjoin(PATL,syr)(Uplo, N, ATL_rone, x, 1, a, N);
   #endif
@ROUT @pop
      if (++j == nsets)
         j = 0;
   }
   t1 = time00();
   t1 = (t1 - t0) / nreps;
   free(vp);
   return(t1);
}
static double GetTimes
(
   enum ATLAS_UPLO Uplo,/* which triangle? */
   int verb,            /* verbosity */
   int nsample,         /* number of samples to take */
   int nreps,           /* number of reps to do for one timing sample */
   size_t flushelts,    /* size of area to flush to avoid cache reuse */
   ATL_CINT N,          /* matrix size */
   int NX               /* what to set ref/kernel crossover to */
)
{
   int i;
   double *times, t0;

   times = malloc(nsample*sizeof(double));
   assert(times);
   for (i=0; i < nsample; i++)
   {
      times[i] = GetTime(Uplo, verb, nreps, flushelts, N, NX);
      if (verb > 1)
         printf("      %d: %e\n", i, times[i]);
   }
   SortDoubles(nsample, times);
   #ifdef WALL
      t0 = times[0];
   #else
      i = (nsample > 1) ? (nsample>>1)+1 : 0;
      t0 = times[i];
   #endif
   free(times);
   if (verb > 1)
      printf("      RETURNING TIME: %e\n", t0);
   return(t0);
}

#define NX0 16
int RecDoubleNX
(
   enum ATLAS_UPLO Uplo,/* which triangle? */
   int verb,            /* verbosity */
   int nsample,         /* number of samples to take */
   int nreps,           /* number of reps to do for one timing sample */
   size_t flushelts,    /* size of area to flush to avoid cache reuse */
   ATL_CINT N           /* matrix size */
)
{
   double t0, tL, tN;  /* 0, Last, Next */
   double tB, tE, tM;  /* beginning, end, middle timings */
   ATL_INT n0, nL, nN; 
   ATL_INT nB, nE, nM=0;

   t0 = GetTimes(Uplo, verb, nsample, nreps, flushelts, N, N);
   printf("\n   Time for N=NX=%d : %e\n", N, t0);
   printf("     N    NX    %% of N=%2d\n", NX0);
   printf("======  ====  ===========\n");
/*
 * Now halve NX until performance stops increasing
 */
   tL = t0;
   nL = N;
   do
   {
      nN = (nL>>4)<<3;
      tN = GetTimes(Uplo, verb, nsample, nreps, flushelts, N, nN);
      printf("%6d  %4d  %11.2f\n", N, nN, (tN/t0)*100.0);
      if (tN > tL) break;  /* stop if new time longer than last */
      nL = nN;
      tL = tN;
   }
   while (nN);  /* stop if NX = 0 */
   printf("\n");

   tE = tL;
   nE = nL;
   tB = tN;
   nB = nN;
   while (nE - nB > 8)
   {
      nM = nB + ((nE-nB)>>1);
      nM = (nM>>3) << 3;   /* keep mul of 8 for alignment, etc */
      tM = GetTimes(Uplo, verb, nsample, nreps, flushelts, N, nM);
      printf("%6d  %4d  %11.2f\n", N, nM, (tM/t0)*100.0);
      if (tE >= tB)
      {
         tE = tM;
         nE = nM;
      }
      else
      {
         tB = tM;
         nB = nM;
      }
   }
   if (tE < tB && tE < tM)
   {
      tM = tE;
      nM = nE;
   }
   else if (tB < tE && tB < tM)
   {
      tM = tB;
      nM = nB;
   }
   printf("NX selected as %d (%.2f%%)!\n", nM, (tM/t0)*100.0);
   return(nM);
}

void PrintUsage(char *name, int ierr, char *flag)
{
   if (ierr > 0)
      fprintf(stderr, "Bad argument #%d: '%s'\n",
              ierr, flag ? flag : "Not enough arguments");
   else if (ierr < 0)
      fprintf(stderr, "ERROR: %s\n", flag);

   fprintf(stderr, "USAGE: %s [flags]:\n", name);
   fprintf(stderr, "   -U <u/l>\n");
   fprintf(stderr, "   -n <N>\n");
   fprintf(stderr, "   -r <reps>\n");
   fprintf(stderr, "   -s <nsample>\n");
   fprintf(stderr, "   -v <verb>\n");
   fprintf(stderr, "   -C <flushKB>\n");
   fprintf(stderr, "   -o <outfile>\n");
   exit(ierr ? ierr : -1);
}

int GetFlags(int nargs, char **args, enum ATLAS_UPLO *Uplo, int *verb, 
             int *nsample, int *nreps, size_t *flushelts, char **outfile)
{
   int N=2000, i;
   char ch;
   char *of;

   *flushelts = L2SIZE;
   *nsample = 10;
   *nreps = 1;
   *verb = 1;
   *Uplo = AtlasUpper;
   of = NULL;
   for (i=1; i < nargs; i++)
   {
      if (args[i][0] != '-')
         PrintUsage(args[0], i, "No '-' preceeding flag!");
      switch(args[i][1])
      {
@multidef var N *nreps *verb *nsample
@whiledef ifl n r v s
      case '@(ifl)' :
         if (++i >= nargs)
            PrintUsage(args[0], i-1, "out of flags in -@(ifl) ");
         @(var) = atoi(args[i]);
         break;
   @undef var
@endwhile
      case 'U':
         if (++i >= nargs)
            PrintUsage(args[0], i-1, "out of flags in -C) ");
         ch = args[i][0];
         *Uplo = (ch == 'l' || ch == 'L') ? AtlasLower : AtlasUpper;
         break;
      case 'C' :
         if (++i >= nargs)
            PrintUsage(args[0], i-1, "out of flags in -C) ");
         *flushelts = atoll(args[i])*1024;
         break;
      case 'o' :
         if (++i >= nargs)
            PrintUsage(args[0], i-1, "out of flags in -C) ");
         of = args[i];
         break;
      default:
         PrintUsage(args[0], i, args[i]);
      }
   }
   if (of)
   {
      *outfile = DupString(of);
      #if defined(__MINGW32__) || defined(__MINGW64__)
         slashsub(*outfile);
         cygdrivesub(*outfile);
      #endif
   }
   else
   {
      of = malloc(sizeof(char)*32);
      assert(of);
      #if defined(__MINGW32__) || defined(__MINGW64__)
         sprintf(of, "res\atlas_%ssyrNX.h", Mstr(PRE));
      #else
         sprintf(of, "res/atlas_%ssyrNX.h", Mstr(PRE));
      #endif
      *outfile = of;
   }
   return(N);
}

void GenIncFile(char *outfile, int NX)
{
   FILE *fpout;
   fpout = fopen(outfile, "w");
   assert(fpout);
   fprintf(fpout, "#ifndef ATLAS_%s@(fop)_H\n   #define ATLAS_%s@(fop)_H\n",
           Mstr(PREU), Mstr(PREU));
   fprintf(fpout, "   #define ATL_@(op)NX %d\n#endif\n", NX);
   fclose(fpout);
}

int main(int nargs, char **args)
{
   size_t flushelts;
   char *outfile;
   int N, verb, nsample, nreps, NX;
   enum ATLAS_UPLO Uplo;

   N = GetFlags(nargs, args, &Uplo, &verb, &nsample, &nreps, &flushelts, 
                &outfile);
   NX = RecDoubleNX(Uplo, verb, nsample, nreps, flushelts, N);
   GenIncFile(outfile, NX);
   free(outfile);
   printf("\nNX=%d!\n", NX);
   return(0);
}
@ROUT ATL_L2AIsOverlapped
#include "atlas_misc.h"
/*
 * This function stores the matrix that was accesses last in the Level 2 BLAS.
 * It returns 1 if the current matrix is a proper subset of the prior matrix,
 * and 0 otherwise.  
 * NOTE: may want to amend later to allow 1 for large % overlap 
 */
#ifdef ATL_USEPTHREADS
/*
 * Need to write wrappers around mutex stuff so I can initialize
 * arrays on the first (and only first) call with thread safety
 */
#else
   int ATL_L2AIsOverlapped
      (int rank, int sz, size_t M, size_t N, size_t A, size_t lda)
   {
      static size_t Ao=0, Mo, No, ldao;
/*
 *    If original matrix could possibly contain this one; if lda is changing,
 *    this computation won't always work, but this case shouldn't be important
 *    enough to care about.
 */
      M *= sz;
      lda *= sz;
      if (Ao && Ao <= A && Mo >= M && No >= N && lda <= ldao)
      {
         size_t j, i;
         j = (A-Ao)/ldao;
         i = (A-(Ao+j*ldao));
         if (i+M <= Mo && j+N <= No)
            return(1);
      }
      Mo = M;
      No = N;
      ldao = lda;
      Ao = A;
      return(0);
   }
#endif
@ROUT r1k_gen_redesign
/*
 * Example GetR1Kern that will be generated.  Pseudo-coded here for design
 */
static ATL_r1kern_t ATL_GetR1Kern
(
   ATL_CINT M, ATL_CINT N,
   const void *A, 
   ATL_CINT lda,
   int *mu, 
   int *nu, 
   int *minM, 
   int *minN, 
   int *alignX, 
   int *ALIGNX2A,
   int *alignY, 
   int *FNU, 
   ATL_INT *CacheElts
)
