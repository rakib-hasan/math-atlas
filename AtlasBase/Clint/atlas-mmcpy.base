@ROUT ucpytest
#include "atlas_cpparse.h"
#include "atlas_cptesttime.h"

void PrintUsage(char *name, int ierr, char *flag)
{
   if (ierr > 0)
      fprintf(stderr, "Bad argument #%d: '%s'\n", ierr,
              flag?flag:"OUT-OF_ARGUMENTS");
   else if (ierr < 0)
      fprintf(stderr, "ERROR: %s\n", flag);
   fprintf(stderr, "USAGE: %s [flags:\n", name);
   fprintf(stderr, "   -i <copy.idx>: (stdin) list of user-supplied copies\n");
   fprintf(stderr, "   -o <cpyWORK.CPS>: (stdout) user copy kernels\n");
   exit(ierr ? ierr : -1);
}

ATL_cpnode_t *GetFlags(int nargs, char **args, char *PRE, char **FOUT)
/*
 * RETURNS: list of all kerns/blk factors to tune copies for
 */
{
   ATL_cpnode_t *cb=NULL, *cp;
   int i;
   int INDONE=0;
   char pre = 'd';

   *FOUT = NULL;
   for (i=1; i < nargs; i++)
   {
      if (args[i][0] != '-')
         PrintUsage(args[0], i, args[i]);

      switch(args[i][1])
      {
      case 'p':
         if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
         pre = tolower(args[i][0]);
         assert(pre == 's' || pre == 'd' || pre == 'z' || pre == 'c');
         break;
      case 'i':
        if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
        cb = ReadCPFile(args[i]);
        INDONE = 1;
        break;
      case 'o':
        if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
        *FOUT = args[i];
        break;
      default:
         PrintUsage(args[0], i, args[i]);
      }
   }
   if (!INDONE)
      cb = ReadCPFile(NULL);
   if (cb)
      PrefixStrAllNodes(cb, GetOffset(&cb->next, cb), GetOffset(&cb->rout, cb),
                       "CPYCASES/");
   *PRE = pre;
   return(cb);
}

int FailAnyClaimedCase(char pre, ATL_cpnode_t *cp)
{
   const unsigned int flg = cp->flag, TA=(flg>>CPF_TRANS)&1, 
      CBLK=(flg>>CPF_CBLK)&1;
   int ia;
   const int ialps[3] = {1,-1,2};
   const int ibets[4] = {1,-1,2,0};
   fprintf(stderr, "   TESTING %d-'%s':\n", cp->ID, cp->rout);
   if (!CBLK)  /* For A/B copy, NU is M or N unroll, while MU is ku */
   {
      for (ia=CPF_AL1; ia <= CPF_ALX; ia++)
      {
         int ialp;
         if (flg & (1<<ia) == 0)
            continue;
         ialp = ialps[ia-CPF_AL1];
         if (CPKernelFailsTest(pre, TA, 367, 233, ialp, 1, cp))
         {
            fprintf(stderr, "   FAILED %d: alpha=%d!\n", cp->ID, ialp);
            return(1);
         }
      }
   }
   else
   {
      for (ia=CPF_AL1; ia <= CPF_ALX; ia++)
      {
         int ib, ialp;
         if (flg & (1<<ia) == 0)
            continue;
         ialp = ialps[ia-CPF_AL1];
         for (ib=CPF_BE1; ib <= CPF_BE0; ib++)
         {
            int ibet; 
            if (flg & (1<<ib) == 0)
               continue;
            ibet=ibets[ib-CPF_BE1];
            if (CPKernelFailsTest(pre, TA, 367, 233, ialp, 1, cp))
            {
               fprintf(stderr, "   FAILED %d: alpha=%d, beta=%d!\n", 
                       cp->ID, ialp, ibet);
               return(1);
            }
         }
      }
   }
   fprintf(stderr, "   PASS:   %d-'%s'\n", cp->ID, cp->rout);
   return(0);
}
int main(int nargs, char **args)
{
   char *fnout;
   char pre;
   ATL_cpnode_t *cb, *cp;

   cb = GetFlags(nargs, args, &pre, &fnout);
   while (cb && FailAnyClaimedCase(pre, cb))
      cb = KillCPNode(cb);
   if (cb)
   {
      ATL_cpnode_t *prev=cb;
      cp = cb->next;
      while(cp)
      {
         ATL_cpnode_t *next = cp->next;
         if (FailAnyClaimedCase(pre, cp))
         {
            cp =  KillCPNode(cp);
            prev->next = cp;
         }
         else
            prev = cp;
         cp = next;
      }
   }
   fprintf(stderr, "\nSURVIVING COPY KERNELS, PRE='%c':\n", pre);
   if (fnout)
      WriteCPFile("stderr", cb);
   WriteCPFile(fnout, cb);
   return(0);
}
@rout cpytest
@extract -b @(topd)/cw.inc lang=C -def cwdate 2017 
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include "atlas_bitvec.h"
#ifndef TYPE
   #define ATL_CSZT const size_t
   #if defined(SREAL) || defined(SCPLX)
      #define TYPE float
   #elif defined(DREAL) || defined(DCPLX)
      #define TYPE double
   #endif
   #ifdef SREAL
      #define ATL_MulBySize(i_) ((i_)<<2)
      #define ATL_DivBySize(i_) ((i_)>>2)
   #elif defined(DREAL) || defined(SCPLX)
      #define ATL_MulBySize(i_) ((i_)<<3)
      #define ATL_DivBySize(i_) ((i_)>>3)
   #else
      #define ATL_MulBySize(i_) ((i_)<<4)
      #define ATL_DivBySize(i_) ((i_)>>4)
   #endif
   #if defined(SCPLX) || defined(DCPLX)
      #define SHIFT << 1
      #define TCPLX 1
   #else
      #define TREAL 1
      #define SHIFT
   #endif
   #ifdef TCPLX
      #define SCALAR TYPE*
      #define SCALAR_IS_ZERO(s_) ((s_)[0] == 0.0 && (s_)[1] == 0.0)
   #else
      #define SCALAR TYPE
      #define SCALAR_IS_ZERO(s_) ((s_) == 0.0)
   #endif
   #define ATL_Cachelen 128
   #define ATL_AlignPtr(vp) \
      (void*) ( ATL_Cachelen + (((((size_t) (vp))+127)>>7)<<7) )
#endif
#if defined(SREAL) || defined(SCPLX)
   #define FEPS 5.0e-7
#else
   #define FEPS 1.0e-15
#endif
#ifndef ATL_MU
   #define ATL_MU 1
#endif
#ifndef ATL_NU
   #define ATL_NU 1
#endif
#if TO_BLK
   #ifdef FromBlk_
      #undef FromBlk_
   #endif
#else
   #define FromBlk_
#endif
#ifdef Trans_
   #if Trans_ == 0
      #undef Trans_
   #endif
#endif
#ifdef Conj_
   #if Conj_ == 0
      #undef Conj_
   #endif
#endif
static int MA=0, NA=0, LDA=0, IA=0, JA=0;
#ifdef TCPLX
   @whiledef sc BETA ALPHA
   #ifdef @(sc)1
      TYPE @(sc)[2] = {1.0, 0.0};
   #elif defined(@(sc)N) || defined(@(sc)N1)
      TYPE @(sc)[2] = {-1.0, 0.0};
   #elif defined(@(sc)0)
      TYPE @(sc)[2] = {0.0, 0.0};
   #else
      @mif sc = "BETA
      TYPE @(sc)[2] = {-0.25, 0.75};
      @endmif
      @mif sc ! "BETA
      TYPE @(sc)[2] = { 1.55, -0.35};
      @endmif
   #endif
   @endwhile
#else
   @whiledef sc BETA ALPHA
   #ifdef @(sc)1
      TYPE @(sc) = 1.0;
   #elif defined(@(sc)N) || defined(@(sc)N1)
      TYPE @(sc) = -1.0;
   #elif defined(@(sc)0)
      TYPE @(sc) = 0.0;
   #else
      @mif sc = "BETA
      TYPE @(sc) = 0.25;
      @endmif
      @mif sc ! "BETA
      TYPE @(sc) = 1.08;
      @endmif
   #endif
   @endwhile
#endif

void PrintUsage(char *name, int ierr, char *flag)
{
   if (ierr > 0)
      fprintf(stderr, "Bad argument #%d: '%s'\n", ierr,
              flag?flag:"OUT-OF_ARGUMENTS");
   else if (ierr < 0)
      fprintf(stderr, "ERROR: %s\n", flag);

   fprintf(stderr, "USAGE: %s [flags]:\n", name);
   fprintf(stderr,"  -A <M> <N> <LDA>: set dimensions of col-major matrix\n");
   fprintf(stderr,"  -b <M> <N> : set dims of access-major block\n");
   fprintf(stderr,"  -B # <M1> <N1> <M2> <N2> ... <M#> <N#>\n");
   fprintf(stderr,"  -s # <sz> allocate sz for each block\n");
   fprintf(stderr,"  -S # <sz1> ... <szN>: allocate sz for each block\n");
   fprintf(stderr,"  -i I J : offset in array to access\n");
   exit(ierr ? ierr : 1);
}

unsigned int *GetFlags (int nargs, char **args)
/*
 * RETURNS: int array, 1st elt is # of blocks, then M,N pairs of block dims
 */
{
   unsigned int nblk=0, i, SZ=0;
   unsigned int *bD=NULL, *szs=NULL;

   IA = JA = -1;
   for (i=1; i < nargs; i++)
   {
      char ch;
      int k;
      if (args[i][0] != '-')
         PrintUsage(args[0], i, args[i]);

      switch(args[i][1])
      {
      case 's':
         if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
         SZ = atoi(args[i]);
         break;
      case 'S':
         if (szs)
            free(szs);
         szs = NULL;
         if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
         nblk = atoi(args[i]);
         if (bD)
            assert(bD[0] == nblk);
         else
         {
            bD = calloc(((nblk<<1)+nblk)+1,sizeof(int));
            assert(bD);
            bD[0] = nblk;
         }
         for (k=0; k < nblk; k++)
         {
            if (++i >= nargs)
               PrintUsage(args[0], i-1, NULL);
            bD[(k<<1)+k+1] = atoi(args[i]);
         }
         break;
      case 'B': /* -B # m1 n1 ... m# n# */
         if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
         nblk = atoi(args[i]);
         if (bD)
         {
            if (bD[3])
               assert(bD[0] == nblk);
            else
            {
               free(bD);
               bD = NULL;
            }
         }
         goto GET_BLKS;
      case 'b': /* -b m n */
         nblk = 1;
      GET_BLKS:
         if (!bD)
         {
            bD = calloc(((nblk<<1)+nblk)+1,sizeof(int));
            assert(bD);
         }
         *bD = nblk;
         nblk += nblk<<1;
         for (k=0; k < nblk; k += 3)
         {
            if (++i >= nargs)
               PrintUsage(args[0], i-1, NULL);
            bD[k+1] = atoi(args[i]);
            if (++i >= nargs)
               PrintUsage(args[0], i-1, NULL);
            bD[k+2] = atoi(args[i]);
         }
         break;
      case 'i': /* -i <I> <J> */
         if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
         IA = atoi(args[i]);
         if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
         JA = atoi(args[i]);
         break;
      case 'A': /* -A M N lda */
         if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
         MA = atoi(args[i]);
         if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
         NA = atoi(args[i]);
         if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
         LDA = atoi(args[i]);
         break;
      @beginskip
      case 'D': /* -D T/F */
        if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
         ch = args[i][0];
         ch = toupper(ch);
         assert(ch == 'F' || ch == 'T');
         *TOBLK = (ch == 'T');         
         break;
      @endskip
      default:
         PrintUsage(args[0], i, args[i]);
      }
   }
   if (IA == -1)  
   {
      #ifdef FromBlk_  /* want to check pre/post pad! */
         IA = 8;
         JA = 6;
      #else
         IA = JA = 0;
      #endif
   }
   if (bD == NULL)
   {
      bD = malloc(4*sizeof(int));
      assert(bD);
      bD[0] = 1;
      bD[1] = 3*ATL_MU;
      bD[2] = 5*ATL_NU;
      bD[3] = bD[1] * bD[2];
   }
   else if (!bD[3])
   {
      int nblk = bD[0];
      nblk += nblk<<1;
      if (SZ)
         for (i=0; i < nblk; i += 3)
            bD[3+i] = SZ;
      else
         for (i=0; i < nblk; i += 3)
         {
            int M=bD[1+i], N=bD[2+i];
            M = ((M+ATL_MU-1)/ATL_MU)*ATL_MU;
            N = ((N+ATL_NU-1)/ATL_NU)*ATL_NU;
            bD[3+i] = N*M;
         }
   }
   if (!NA)
   {
      int k, nblk=bD[0];
      nblk += nblk<<1;
      MA = bD[1];
      NA = bD[2];
      for (k=3; k < nblk; k += 3)
      {
         MA = Mmax(MA, bD[k+1]);
         NA = Mmax(NA, bD[k+2]);
      }
      #ifdef Trans_
         k = MA;
         MA = NA;
         NA = k;
      #endif
      #ifdef FromBlk_
         NA += NA;
      #endif
      MA += IA;
      NA += JA;
      LDA = MA + 7;
   }
   else
   {
      int k, nblk=bD[0];
      nblk += nblk<<1;
      for (k=0; k < nblk; k += 3)
      {
         #ifdef Trans_
            assert(IA + bD[k+2] <= MA);
            assert(JA + bD[k+1] <= NA);
         #else
            assert(IA + bD[k+1] <= MA);
            assert(JA + bD[k+2] <= NA);
         #endif
      }
      assert(LDA >= MA);
   }
   return(bD);
}

TYPE *getMat(size_t M, size_t N, size_t lda, int seed)
{
   int i, j;
   const int lda2 = lda SHIFT;
   const double mul = 1.0 / (lda2*N);
   TYPE *A, *A0;

   A0 = A = malloc(N*lda2*sizeof(TYPE));
   assert(A);
@skip   dumb_seed(seed);
   for (j=0; j < N; j++, A += lda2)
      for (i=0; i != lda2; i++) 
         A[i] = 1.0 + (mul*j)*lda2+(i*1e-1);
   return(A0);
}

#define AlignPtr(vp_) (void*) (((((size_t)(vp_))+127)>>7)<<7)
TYPE *getBlock(int sz, int pad)
{
   void *vp;
   TYPE *b;
   size_t ip;
   int i, SZ = (sz + pad + pad)SHIFT;
   double mul = 1.0 / SZ;

   vp = malloc(SZ*sizeof(TYPE) + 128);
   b = AlignPtr(vp);
   for (i=0; i < SZ; i++)
      b[i] = -(1.0+mul*i);
   return(vp);
}

#ifdef matC_
   #ifdef Trans_
      #error "No test of Transpose C matrix right now!"
   #endif
   #ifdef FromBlk_
      #ifdef TCPLX
         void ATL_USERCPMM
            (const size_t M, const size_t N, const SCALAR alpha, const TYPE *r,
             const TYPE *c, const SCALAR beta, TYPE *C, const size_t ldc);
         void ATL_GOODCPMM
            (const size_t M, const size_t N, const SCALAR alpha, const TYPE *r,
             const TYPE *c, const SCALAR beta, TYPE *C, const size_t ldc);
      #else
         void ATL_USERCPMM
            (const size_t M, const size_t N, const SCALAR alpha, const TYPE *b,
             const SCALAR beta, TYPE *C, const size_t ldc);
         void ATL_GOODCPMM
            (const size_t M, const size_t N, const SCALAR alpha, const TYPE *b,
             const SCALAR beta, TYPE *C, const size_t ldc);
      #endif
   #else /* ToBlock */
      #ifdef TCPLX
         void ATL_USERCPMM
            (const size_t M, const size_t N, const SCALAR alpha, const TYPE *C, 
             const size_t ldc, const SCALAR beta, TYPE *rb, TYPE *ib);
         void ATL_GOODCPMM
            (const size_t M, const size_t N, const SCALAR alpha, const TYPE *C, 
             const size_t ldc, const SCALAR beta, TYPE *rb, TYPE *ib);
      #else
         void ATL_USERCPMM
            (const size_t M, const size_t N, const SCALAR alpha, const TYPE *C, 
             const size_t ldc, const SCALAR beta, TYPE *b);
         void ATL_GOODCPMM
            (const size_t M, const size_t N, const SCALAR alpha, const TYPE *C, 
             const size_t ldc, const SCALAR beta, TYPE *b);
      #endif
   #endif
#else  /* Trans & NoTrans have same prototype */
   #ifdef FromBlk_
      #ifdef TCPLX
         void ATL_USERCPMM(ATL_CSZT K, ATL_CSZT N, const SCALAR alpha, 
                           TYPE *rb, TYPE *ib, const TYPE *A, ATL_CSZT lda);
         void ATL_GOODCPMM(ATL_CSZT K, ATL_CSZT N, const SCALAR alpha, 
                           TYPE *rb, TYPE *ib, const TYPE *A, ATL_CSZT lda);
      #else
         void ATL_USERCPMM(ATL_CSZT K, ATL_CSZT N, const SCALAR alpha, 
                           TYPE *b, const TYPE *A, ATL_CSZT lda);
         void ATL_GOODCPMM(ATL_CSZT K, ATL_CSZT N, const SCALAR alpha, 
                           TYPE *b, const TYPE *A, ATL_CSZT lda);
      #endif
   #else
      #ifdef TCPLX
         void ATL_USERCPMM(ATL_CSZT K, ATL_CSZT N, const SCALAR alpha, 
                           const TYPE *A, ATL_CSZT lda, TYPE *rb, TYPE *ib);
         void ATL_GOODCPMM(ATL_CSZT K, ATL_CSZT N, const SCALAR alpha, 
                           const TYPE *A, ATL_CSZT lda, TYPE *rb, TYPE *ib);
      #else
         void ATL_USERCPMM(ATL_CSZT K, ATL_CSZT N, const SCALAR alpha, 
                           const TYPE *A, ATL_CSZT lda, TYPE *b);
         void ATL_GOODCPMM(ATL_CSZT K, ATL_CSZT N, const SCALAR alpha, 
                           const TYPE *A, ATL_CSZT lda, TYPE *b);
      #endif
   #endif
#endif
void initMat(SCALAR beta, int M, int N, TYPE *A, size_t lda)
{
   size_t lda2 = lda SHIFT;
   unsigned int M2 = M SHIFT, i, j;
   if (SCALAR_IS_ZERO(beta))
   {
      TYPE nan = 0.0 / 0.0;
      for (j=0; j < N; j++, A += lda2)
         for (i=0; i < M2; i++)
            A[i] = nan;
   }
   else
   {
      const double mul = 1.0 / (((double)M2)*N);
      for (j=0; j < N; j++, A += lda2)
         for (i=0; i < M2; i++)
            A[i] = (i + j*lda2)*mul + 1.0;
   }
}

#ifdef matC_
   #define C_MAT 'C'
#else
   #define C_MAT 'A'
#endif
#ifdef FromBlk_
   #define C_DIR 'F'
#else
   #define C_DIR 'T'
#endif
#ifdef Trans_
   #ifdef Conj_
      #define C_TRANS 'C'
   #else
      #define C_TRANS 'T'
   #endif
#else
   #ifdef Conj_
      #define C_TRANS 'H'
   #else
      #define C_TRANS 'N'
   #endif
#endif

#ifdef FromBlk_
int doTests(unsigned int ntest, unsigned int *bD)
{
   int t;
   int nerr=0;
   const unsigned int I2 = IA SHIFT, M2 = MA SHIFT, LDA2 = LDA SHIFT;
   const double mul = 1.0 / (LDA2*NA);

   printf("RUN %u TESTS: MAT=%c, TA=%c MD=(%u,%u), LDA=%u, (%u,%u)\n", 
          ntest, C_MAT, C_TRANS, MA, NA, LDA, I2, JA);
   for (t=0; t < ntest; t++)
   {
      unsigned int T = (t<<1)+t, mb = bD[T], nb = bD[T+1], sz=bD[T+2];
      #ifdef Trans_
         const unsigned int nrow = nb, ncol=mb;
      #else
         const unsigned int nrow = mb, ncol=nb;
      #endif
      const unsigned int M0=(IA+nrow)SHIFT, N0=JA+ncol, N1=N0+ncol;
      const size_t offT = LDA2*ncol;
      unsigned int j;
      void *v0;
      TYPE *b0, *b1;
      TYPE *A, *a0, *a1, *A0;
      #ifdef TCPLX
         TYPE *rb, *ib;
      #endif
      
      assert(N0 <= NA);
      assert(N1 <= NA);
      assert(M0 <= (MA SHIFT));
      printf("   Test %u, D=(%u,%u), SZ=%u\n", t, mb, nb, sz);
      fflush(stdout);
      v0 = getBlock(sz, 0);
      b0 = AlignPtr(v0);
      A0 = A = getMat(MA, NA, LDA, MA+NA*LDA);
      a0 = A+((IA+JA*LDA)SHIFT);
      a1 = a0 + offT;

      initMat(BETA, nrow, ncol, a0, LDA);
      initMat(BETA, nrow, ncol, a1, LDA);
      #ifdef TCPLX
         #ifdef matC_
            ATL_GOODCPMM(mb, nb, ALPHA, b0+sz, b0, BETA, a0, LDA);
            ATL_USERCPMM(mb, nb, ALPHA, b0+sz, b0, BETA, a1, LDA);
         #else
            ATL_GOODCPMM(nb, mb, ALPHA, b0+sz, b0, a0, LDA);
            ATL_USERCPMM(nb, mb, ALPHA, b0+sz, b0, a1, LDA);
         #endif
      #else
         #ifdef matC_
            ATL_GOODCPMM(mb, nb, ALPHA, b0, BETA, a0, LDA);
            ATL_USERCPMM(mb, nb, ALPHA, b0, BETA, a1, LDA);
         #else
            ATL_GOODCPMM(nb, mb, ALPHA, b0, a0, LDA);
            ATL_USERCPMM(nb, mb, ALPHA, b0, a1, LDA);
         #endif
      #endif
      a0 = A;
      for (j=0; j < NA; j++, A += LDA2)
      {
         unsigned int i;
         for (i=0; i < M2; i++)
         {
            double got, exp;
            if (i >= I2 && i < M0)
            {
               if (j >= JA && j < N0)
               {
                  int nanE, nanG;
                  exp = A[i];
                  got = A[i+offT];
                  nanE = exp != exp;
                  nanG = got != got;
                  if (nanE || nanG)
                  {
                     if (!nanE || !nanG)
                     {
                        nerr++;
                        fprintf(stderr,
                                "      A(%u,%u),b(%u,%u)=%e, expected=%e\n", 
                                i, j, i-I2, j-JA, got, exp);
                     }
                  }
                  else
                  {
                     double diff;
                     diff = exp - got;
                     if (diff < 0.0)
                        diff = -diff;
                     if (diff > FEPS)
                     {
                        fprintf(stderr,
                                "      A(%u,%u),b(%u,%u)=%e, expected=%e\n", 
                                i, j, i-I2, j-JA, got, exp);
                        nerr++;
                     }
                     continue;
                  }
               }
               else if (j <= N1)  /* don't scope 2nd overwrittes submat */
                  continue;       /* since was scoped right above */
            }
            exp = 1.0 + (mul*j)*LDA2+(i*1e-1);
            got = A[i];
            if (exp != got)
            {
               fprintf(stderr, "      PAD ERR, A(%u,%u)=%e, expected=%e\n",
                       i, j, got, exp);
               nerr++;
            }
         }
      }
      free(A0);
      free(v0);
      if (nerr > 1)
         return(nerr);
      printf("   DONE Test %u\n", t);
   }
   return(nerr);
}
#else
int doTests(unsigned int ntest, unsigned int *bD)
{
   int t;
   TYPE *A, *a;
   int nerr=0, pad=32, pad2=pad SHIFT;

   A = getMat(MA, NA, LDA, MA+NA*LDA);
   a = A+((IA+JA*LDA)SHIFT);
   printf("RUN %u TESTS: MAT=%c, TA=%c MD=(%u,%u), LDA=%u\n", ntest, C_MAT, 
          C_TRANS, MA, NA, LDA);
   for (t=0; t < ntest; t++)
   {
      void *v0, *v1;
      TYPE *b0, *b1, *b2, *b3, *B0, *B1;
      unsigned int T = (t<<1)+t, mb = bD[T], nb = bD[T+1], sz=bD[T+2];
      unsigned int i, N;
      #ifdef TCPLX
         TYPE *rB0, *iB0, *rB1, *iB1;
      #endif
      printf("   Test %u, D=(%u,%u), SZ=%u\n", t, mb, nb, sz);
      v0 = getBlock(sz, pad);
      v1 = getBlock(sz, pad);
      b0 = AlignPtr(v0);
      b1 = AlignPtr(v1);
      B0 = b0 + pad2;
      B1 = b1 + pad2;
      b2 = B0 + (sz SHIFT);
      b3 = B1 + (sz SHIFT);
      #ifdef TCPLX
         #ifdef matC_
            ATL_GOODCPMM(mb, nb, ALPHA, a, LDA, BETA, B0+sz, B0);
            ATL_USERCPMM(mb, nb, ALPHA, a, LDA, BETA, B1+sz, B1);
         #else
            ATL_GOODCPMM(nb, mb, ALPHA, a, LDA, B0+sz, B0);
            ATL_USERCPMM(nb, mb, ALPHA, a, LDA, B1+sz, B1);
         #endif
      #else
         #ifdef matC_
            ATL_GOODCPMM(mb, nb, ALPHA, a, LDA, BETA, B0);
            ATL_USERCPMM(mb, nb, ALPHA, a, LDA, BETA, B1);
         #else
            ATL_GOODCPMM(nb, mb, ALPHA, a, LDA, B0);
            ATL_USERCPMM(nb, mb, ALPHA, a, LDA, B1);
         #endif
      #endif
      for (i=0; i < pad2; i++)
      {
         if (b0[i] != b1[i])
         {
            printf("      PREPAD  %d, expected=%e, got=%e\n", i, b0[i], b1[i]);
            nerr++;
         }
         if (b3[i] != b2[i])
         {
            printf("      POSTPAD %d, expected=%e, got=%e\n", i, b0[i], b1[i]);
            nerr++;
         }
      }
      for (N=sz SHIFT, i=0; i < N; i++)
      {
         TYPE diff = B0[i] - B1[i];

         diff = (diff >= 0.0) ? diff : -diff;
         if (B1[i] != B1[i])
         {
            fprintf(stderr, "      B[%u]: got NaN, expected=%e\n", i, B0[i]);
            if (B0[i] == B0[i])
               nerr++;
         }
         else if (diff > FEPS)
         {
            fprintf(stderr, "      B[%u]: got %e, expected=%e\n", i, 
                    B1[i], B0[i]);
            nerr++;
         }
      }
      free(v0);
      free(v1);
      if (nerr > 1)
         return(nerr);
      printf("   DONE Test %u\n", t);
   }
   free(A);
   return(nerr);
}
#endif

int main(int nargs, char **args)
{
   int *bD;
   int nerr = 0;
   bD = GetFlags(nargs, args);
   nerr = doTests(bD[0], bD+1);
   if (!nerr)
      printf("\nSUCCESS: PASS %u ALL TESTS\n", bD[0]);
   else
      printf("\nFAILED WITH %u ERRORS\n", nerr);
   free(bD);
   return(nerr);
}
@ROUT cpytest_shit
@extract -b @(topd)/cw.inc lang=C -def cwdate 2017 -def cwauth "Jakob Hinton" -def contrib "R. Clint Whaley"
/*
 * This copy sanity tester written by Jakob Hinton, and desperately needs
 * code review.
 * If functions by testing copy function ATL_USERCPMM against a known-good
 * implementation provided by ATL_GOODCP
 */
#include "atlas_misc.h"
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <math.h>


#if defined(SCPLX) || defined(DCPLX)
   #define IS_CPLX  1
#else
   #define IS_CPLX  0
#endif

#ifndef COPY_C
   #define CCOPY 0
#else
   #if COPY_C
      #define CCOPY 0
   #else
      #define CCOPY 1
   #endif
#endif
#if IS_TRANS == 1
   #define TRANST_
#endif

#ifdef BETAX
   #define beta 3.0
#endif

#ifdef BETA1
   #define beta 1.0
#endif

#ifdef BETA0
   #define beta 0.0
#endif

#ifdef ALPHAX
   #define alpha 0.5
#endif

#ifdef ALPHA1
   #define alpha 1.0
#endif

#ifdef ALPHA0
   #define alpha 0.0
#endif

/* function signature for cblk2C */
#if CCOPY == 1 && defined TCPLX && TO_BLK == 0

   void ATL_GOODCP
   (
      ATL_CSZT M,      /* number of rows in A */
      ATL_CSZT N,      /* number of columns in A */
      const SCALAR *a, /* scalar for b */
      const TYPE *rC,    /* real block stored in 1x1-major order */
      const TYPE *iC,    /* imag block stored in 1x1-major order */
      const SCALAR *b,  /* scalar for C */
      TYPE *C,           /* matrix to be copied to access-major format */
      ATL_CSZT ldc     /* stride between row elements */
   );
void ATL_USERCPMM
   (
      ATL_CSZT M,      /* number of rows in A */
      ATL_CSZT N,      /* number of columns in A */
      const SCALAR *a, /* scalar for b */
      const TYPE *rC,    /* real block stored in 1x1-major order */
      const TYPE *iC,    /* imag block stored in 1x1-major order */
      const SCALAR *b,  /* scalar for C */
      TYPE *C,           /* matrix to be copied to access-major format */
      ATL_CSZT ldc     /* stride between row elements */
   );


/* function signature for C2blk */
#elif CCOPY == 1 && !defined TCPLX && TO_BLK == 1

   void ATL_GOODCP
   (
      ATL_CSZT M,      /* number of rows in A */
      ATL_CSZT N,      /* number of columns in A */
      const SCALAR a,  /* scalar for C */
      const TYPE *C,     /* matrix to be copied to access-major format */
      ATL_CSZT ldc,    /* stride between row elements */
      const SCALAR b,   /* scalar for b */
      TYPE *B            /* matrix stored in 4x4-major order */
   );
   
   void ATL_USERCPMM
   (
      ATL_CSZT M,      /* number of rows in A */
      ATL_CSZT N,      /* number of columns in A */
      const SCALAR a,  /* scalar for C */
      const TYPE *C,     /* matrix to be copied to access-major format */
      ATL_CSZT ldc,    /* stride between row elements */
      const SCALAR b,   /* scalar for b */
      TYPE *B            /* matrix stored in 4x4-major order */
   );

/* function signature for blk2C */
#elif CCOPY == 1 && !defined TCPLX && TO_BLK == 0
  void ATL_USERCPMM
(
   const size_t M,      /* number of rows in A */
   const size_t N,      /* number of columns in A */
   const double a,  /* scalar for b */
   const double *b,     /* matrix stored in 1x1-major order */
   const double bta,   /* scalar for C */
   double *C,           /* matrix to be copied to access-major format */
   const size_t ldc     /* stride between row elements */
);

void ATL_GOODCP
(
   const size_t M,      /* number of rows in A */
   const size_t N,      /* number of columns in A */
   const double a,  /* scalar for b */
   const double *b,     /* matrix stored in 1x1-major order */
   const double bta,   /* scalar for C */
   double *C,           /* matrix to be copied to access-major format */
   const size_t ldc     /* stride between row elements */
);

/* function signature for cAN2blk, cAT2blk, cblk2AN, & cblk2AT */
#elif defined TCPLX && CCOPY == 0

   void ATL_GOODCP
   (
      ATL_CSZT K,          /* number of rows in A */
      ATL_CSZT N,          /* number of columns in A */
      const SCALAR a,      /* scalar for A */
      const TYPE *A,       /* col maj matrix */
      ATL_CSZT lda,        /* stride between row elements */
      TYPE *rA,            /* access-major block holding real vals */
      TYPE *iA             /* access-major block holding imag vals */
   );
   
   void ATL_USERCPMM
   (
      ATL_CSZT K,          /* number of rows in A */
      ATL_CSZT N,          /* number of columns in A */
      const SCALAR a,      /* scalar for A */
      const TYPE *A,       /* col maj matrix */
      ATL_CSZT lda,        /* stride between row elements */
      TYPE *rA,            /* access-major block holding real vals */
      TYPE *iA             /* access-major block holding imag vals */
   );

/* function signature for cC2blk */
#elif defined TCPLX && CCOPY == 1 && TO_BLK == 1

void ATL_GOODCP
(
   ATL_CSZT M,      /* number of rows in A */
   ATL_CSZT N,      /* number of columns in A */
   const SCALAR *a, /* scalar for b */
   const TYPE *C,     /* matrix to be copied to access-major format */
   ATL_CSZT ldc,    /* stride between row elements */
   const SCALAR *b,  /* scalar for C */
   TYPE *rC,          /* real block stored in 1x1-major order */
   TYPE *iC           /* imag block stored in 1x1-major order */
);

void ATL_USERCPMM
(
   ATL_CSZT M,      /* number of rows in A */
   ATL_CSZT N,      /* number of columns in A */
   const SCALAR *a, /* scalar for b */
   const TYPE *C,     /* matrix to be copied to access-major format */
   ATL_CSZT ldc,    /* stride between row elements */
   const SCALAR *b,  /* scalar for C */
   TYPE *rC,          /* real block stored in 1x1-major order */
   TYPE *iC           /* imag block stored in 1x1-major order */
);


/* function signature for AN2blk, AT2blk, blk2AN, & blk2AT */
#else
   void ATL_GOODCP
   (
      ATL_CSZT K,          /* number of rows in A */
      ATL_CSZT N,          /* number of columns in A */
      const SCALAR a,      /* scalar for A */
      const TYPE *A,       /* col maj matrix */
      ATL_CSZT lda,        /* stride between row elements */
      TYPE *b              /* access-major block */
   );
   
   void ATL_USERCPMM
   (
      ATL_CSZT K,          /* number of rows in A */
      ATL_CSZT N,          /* number of columns in A */
      const SCALAR a,      /* scalar for A */
      const TYPE *A,       /* col maj matrix */
      ATL_CSZT lda,        /* stride between row elements */
      TYPE *b              /* access-major block */
   );
#endif

/*if the tested cpy function into an access maj array has been writing past its 
  given parameters, this function will print an err and return each time it 
  does so.*/
int acc_buffercheckr
(
   TYPE *A,          /*this is the array we are checking to see if its buffer
                       was touched*/
   int SZ,           /*size of the array in the array that has no buffervals*/
   int bufferspace,  /*amount of space allocated around array, it is asuumed
                       that this space /2 is full of the buffer val at the 
                       front and back end of the access major array*/
   TYPE tst_val      /*this is the val padded into the outer rims of the array*/
)
{
   int i, j;
   int buffer_err = 0;
   for(i=0;i<bufferspace/2;i++)
   {
      /* check the 0 end of the buffer space */
      if(*(A + i) != tst_val)
      {
         fprintf(stderr, "ERROR pos [%d] has been edited and is outside the"
                 "given parameters for the routine being tstd\n",i);
         buffer_err++;
      }
      /* check the max index end of the buffer space */
      if(*(A + (SZ-1) - i) != tst_val)
      {
         fprintf(stderr, "ERROR pos [%d] has been edited and is outside the "
                 "given parameters for the routine being tstd\n",SZ - i);
         buffer_err++;
      }
   }
   return buffer_err;
}

/*if the tested cpy function into a col maj array has been writing past its 
  given parameters, this function will return each time it does so.*/
int col_buffercheckr
(
   TYPE *A,          /*this is the array we are checking to see if its buffer
                       was touched*/
   int K,
   int N,
   TYPE tst_val      /*this is the val padded into the outer rims of the array*/
)
{
   int i, j;
   int buffer_err = 0;
   int lda = K*3;
   for(i=0;i<K*3;i++)
   {
      for(j=0;j<N*3;j++)
      {
         /* this if statement checks if the current val is not in the buffzone*/
         if(i>=K && i<K*2 && j>=N && j<N*2);

         /* if it is in the buffer zone, then check if it has been violated */
         else
         {
            if(*(A + i + j*lda) != tst_val)
            {
               fprintf(stderr, "ERROR pos [%d] has been edited and is outside"
                       " the given parameters for the routine being tstd\n",
                       i+j*lda);
               buffer_err++;
            }
         }
      }
   }
   return buffer_err;
}


/*this function checks the correct array with the test one and makes note of
  any inconsitencies*/
int tst_checkr
(
   TYPE *A,            /*this is the good array that is being compared to the 
                         array of unknown quality*/
   TYPE *b,            /*this is the array being tsted*/
   ATL_CSZT sz         /*amount of elements*/
)
{
   int errcount = 0;
   ATL_SZT i;
   
   for(i = 0; i < sz; i++)
   {
      if(*(A + i) != *(b + i))
      {
         fprintf(stderr, "ERROR pos [%zu] does not match\n",i);
         fprintf(stderr, "correctarr == %f\n",*(A + i));
         fprintf(stderr, "tstarr == %f\n\n",*(b + i));
         errcount++;
      }
   }

   return errcount;
}

void PrintUsage(char *name, int iarg, char *arg)
{
    fprintf(stderr, "\nERROR around arg %d (%s).\n", iarg, arg ? arg:"unknown");
    fprintf(stderr, "USAGE: %s [flags], where flags are:\n", name);
    fprintf(stderr, "   -m <#> : set number of rows to #\n");
    fprintf(stderr, "   -n <#> : set number of col's to #\n");
    fprintf(stderr, "   -s <#> : set sz to #\n");
    fprintf(stderr, "   -k <#> : set k unrolling to #\n");
    fprintf(stderr, "   TOBLK=<1/0> : set whether copying into a blk\n");
    fprintf(stderr, "   CCOPY=<1/0> : set whether performing a c copy\n");
    fprintf(stderr, "   ISTRANS=<1/0> : set whether a trans is occuring\n");
    fprintf(stderr, "   BETA=<1/0/X> : set what beta is going to be\n");
    fprintf(stderr, "   ALPHA=<1/0/X> : set what alpha is going to be\n");
    exit(iarg ? iarg : -1);
}

void GetFlags(int nargs, char **args, int *K, int *N, int *SZ)
{
   int i; 
   int ku = 0;
   int SZchk;
   double SZchkDouble;

   *K = 0;
   *N = 0;
   *SZ = 0;
   for(i=1; i < nargs; i++)
   {
      if(args[i][0] != '-')
         PrintUsage(args[0], i, args[i]);
      switch (args[i][1])
      {
         case 'm':
            if(++i >= nargs)
               PrintUsage(args[0], i, "out of arguements");
            *K = atoi(args[i]);
            break;
         case 'n':
            if(++i >= nargs)
               PrintUsage(args[0], i, "out of arguements");
            *N = atoi(args[i]);
            break;
         case 'k':
            if(++i >= nargs)
               PrintUsage(args[0], i, "out of arguements");
            ku = atoi(args[i]);
            break;
         case 's':
            if(++i >= nargs)
               PrintUsage(args[0], i, "out of arguements");
            *SZ = atoi(args[i]);
            break;
         default:
            PrintUsage(args[0], i, args[i]);
      }
   }
   if(*K == 0 && *N == 0 && *SZ == 0)
   {
      *SZ = 16;
      *N = 4;
      *K = 4;
   }
   else if(*SZ == 0 && *K != 0 && *N != 0)
   {
      *SZ = *K * *N;
   }
   else if(*SZ != 0 && *K == 0 && *N == 0)
   {
      SZchkDouble = sqrt((double) *SZ);
      SZchk = SZchkDouble;
      if(SZchk == SZchkDouble)
      {
         *K = SZchk;
         *N = SZchk;
      }
      else
      {
         fprintf(stderr,"ERROR: SZ was given as %d but this value is not a "
                 "perfect square\n and no colomns/rows were specifed so block"
                 "size is ambiguous.\n", *SZ);
         exit(0);
      }
   }
   else if(*SZ == *K * *N);
   else
   {
      fprintf(stderr,"ERROR: SZ of block doesnt matchup with number of rows"
              " and columns\n");
      exit(0);
   }
   if(ku != 0)
   {
      *K = (*K / ku) * ku;
      *SZ = *K * *N;
   }
}

void copytest
(
   int blk,
   int transt,
   int ccopy,
   int cplx,
   int K,
   int N,
   SCALAR a,
   SCALAR b,
   ATL_CSZT SZ,
   int *chkarray
)
{
      int i, j;
      TYPE count = 0;
      TYPE count2 = 65656.56565;
      ATL_CSZT bufferrange = SZ*8;
      ATL_CSZT lda = K*3;
      TYPE bufferval = 12345.54321;
      TYPE *outarray1, *outarray2;
      ATL_CSZT lda2 = lda*2;

      /* C2blk || CT2blk */
      if(blk == 1 && cplx == 0 && ccopy == 1)
      {
         TYPE *tstarray = (TYPE *)malloc((SZ+bufferrange) * sizeof(TYPE));
     
         for(i=0;i<SZ+bufferrange;i++)
            tstarray[i] = --count;

         count = 0;

         for(i=K; i < K*2;i++)
         {
            for(j=N;j<N*2;j++)
            {
               *(tstarray + i + j*lda) = ++count;
            }
         }

         TYPE *outarray1 = (TYPE *)malloc(SZ * sizeof(TYPE));
         TYPE *outarray2 = (TYPE *)malloc((SZ+bufferrange) * sizeof(TYPE));
         
         count = 0;
      
         for(j = 0;j < SZ; j++)
         {
            *(outarray1 + j) = count;
            *(outarray2 + j + bufferrange/2) = count;
         }
         for(j=0;j<bufferrange/2;j++)
         {
            *(outarray2 + j) = bufferval;
            *(outarray2 + (SZ + bufferrange - 1) - j) = bufferval;
         }
  
#if !defined TCPLX && CCOPY == 1 && TO_BLK == 1
         if(transt == 1)
         {
            printf("beginning CT2blk\n");
            ATL_GOODCP(N, K, a, tstarray+(N*lda+K), lda, b, outarray1);
            ATL_USERCPMM(N, K, a, tstarray+(N*lda+K), lda, b, 
                         outarray2+bufferrange/2);
         }
         else
         {
            printf("beginning C2blk\n");
            ATL_GOODCP(K, N, a, tstarray+(N*lda+K), lda, b, outarray1);
            ATL_USERCPMM(K, N, a, tstarray+(N*lda+K), lda, b, 
                         outarray2+bufferrange/2);
         }
         chkarray[0] = tst_checkr(outarray1, outarray2+bufferrange/2, SZ);
         chkarray[1] = acc_buffercheckr(outarray2, SZ+bufferrange, bufferrange,
                                        bufferval);
#else
         chkarray[0] = -1;
#endif
         free(tstarray);
         free(outarray1);
         free(outarray2);
         return;
      }
      /* blk2C || blk2CT*/
      else if(blk == 0 && cplx == 0 && ccopy == 1)
      {
         TYPE *tstarray = (TYPE *)malloc((SZ + bufferrange) * sizeof(TYPE));
        
         for(i=0;i<SZ+bufferrange;i++)
            tstarray[i] = --count;

         count = 0;

         for(i=0;i<SZ;i++)
         {
            *(tstarray + i + bufferrange/2) = ++count;
         }
         
         TYPE *outarray1 = (TYPE *)malloc((SZ + bufferrange) * sizeof(TYPE));
         TYPE *outarray2 = (TYPE *)malloc((SZ + bufferrange) * sizeof(TYPE));
         
         count = 0;
      
         for(i=K; i < K*2;i++)
         {
            for(j=N;j < N*2;j++)
            {
               *(outarray1 + i + j*lda) = count;
               *(outarray2 + i + j*lda) = count;
            }
         }

         
         for(i=0;i<K*3;i++)
         {
            for(j=0;j<N*3;j++)
            {
               if(i>=K && i<K*2 && j>=N && j<N*2);
               else
               {
                  *(outarray1 + i + j*lda) = bufferval;                 
                  *(outarray2 + i + j*lda) = bufferval;                 
               }
            }
         }

#if !defined TCPLX && TO_BLK == 0 && CCOPY == 1
         if(transt == 1)
         {
            printf("beginning blk2CT\n");
            ATL_GOODCP(N, K, a, tstarray+bufferrange/2, b, 
                       outarray1+(N*lda+K), lda);
            ATL_USERCPMM(N, K, a, tstarray+bufferrange/2, b, 
                         outarray2+(N*lda+K), lda);
         }
         else
         {
            printf("beginning blk2C\n");
            ATL_GOODCP(K, N, a, tstarray+bufferrange/2, b, outarray1+(N*lda+K),
                       lda);
            ATL_USERCPMM(K, N, a, tstarray+bufferrange/2, b, 
                         outarray2+(N*lda+K), lda);
         }
         chkarray[0] = tst_checkr(outarray1, outarray2, SZ+bufferrange);
         chkarray[1] = col_buffercheckr(outarray2, K, N, bufferval);
#else
         chkarray[0] = -1;
#endif
         free(tstarray);
         free(outarray1);
         free(outarray2);
         return;
      }
      /* AN2blk || AT2blk */
      if(blk == 1 && cplx == 0 && ccopy == 0)
      {
         TYPE *tstarray = (TYPE *)malloc((SZ+bufferrange) * sizeof(TYPE));
     
         for(i=0;i<SZ+bufferrange;i++)
            tstarray[i] = --count;

         count = 0;

         for(i=K; i < K*2;i++)
            for(j=N;j<N*2;j++)
               *(tstarray + i + j*lda) = ++count;

         TYPE *outarray1 = (TYPE *)malloc(SZ * sizeof(TYPE));
         TYPE *outarray2 = (TYPE *)malloc((SZ+bufferrange) * sizeof(TYPE));
         
         count = 0;
      
         for(j = 0;j < SZ; j++)
         {
            *(outarray1 + j) = count;
            *(outarray2 + j + bufferrange/2) = count2;
         }
         for(j=0;j<bufferrange/2;j++)
         {
            *(outarray2 + j) = bufferval;
            *(outarray2 + (SZ + bufferrange - 1) - j) = bufferval;
         }
  
#if !defined TCPLX && CCOPY == 0
         if(transt == 1)
         {
            printf("beginning AT2blk\n");
            ATL_GOODCP(N, K, a, tstarray+(N*lda+K), lda, outarray1);
            ATL_USERCPMM(N, K, a, tstarray+(N*lda+K), lda, 
                         outarray2+bufferrange/2);
         }
         else
         {
            printf("beginning AN2blk\n");
            ATL_GOODCP(K, N, a, tstarray+(N*lda+K), lda, outarray1);
            ATL_USERCPMM(K, N, a, tstarray+(N*lda+K), lda, 
                         outarray2+bufferrange/2);
         }
         chkarray[0] = tst_checkr(outarray1, outarray2+bufferrange/2, SZ);
         chkarray[1] = acc_buffercheckr(outarray2, SZ+bufferrange, bufferrange,
                                        bufferval);
#else
         chkarray[0] = -1;
#endif
         free(tstarray);
         free(outarray1);
         free(outarray2);
         return;
      }
      /* blk2AN || blk2AT*/
      else if(blk == 0 && cplx == 0 && ccopy == 0)
      {
         TYPE *tstarray = (TYPE *)malloc((SZ + bufferrange) * sizeof(TYPE));
        
         for(i=0;i<SZ+bufferrange;i++)
         {
            *(tstarray + i) = --count;
         }

         count = 0;

         for(i=0;i<SZ;i++)
         {
            *(tstarray + i + bufferrange/2) = ++count;
         }
         
         TYPE *outarray1 = (TYPE *)malloc((SZ + bufferrange) * sizeof(TYPE));
         TYPE *outarray2 = (TYPE *)malloc((SZ + bufferrange) * sizeof(TYPE));
         
         count = 0;
      
         for(i=K; i < K*2;i++)
         {
            for(j=N;j < N*2;j++)
            {
               *(outarray1 + i + j*lda) = count;
               *(outarray2 + i + j*lda) = count2;
            }
         }

         
         for(i=0;i<K*3;i++)
         {
            for(j=0;j<N*3;j++)
            {
               if(i>=K && i<K*2 && j>=N && j<N*2);
               else
               {
                  *(outarray1 + i + j*lda) = bufferval;                 
                  *(outarray2 + i + j*lda) = bufferval;                 
               }
            }
         }

#if !defined TCPLX && CCOPY == 0
         if(transt == 1)
         {
            printf("beginning blk2AT\n");
            ATL_GOODCP(N, K, a, outarray1+(N*lda+K), lda, 
                       tstarray+bufferrange/2);
            ATL_USERCPMM(N, K, a, outarray2+(N*lda+K), lda, 
                         tstarray+bufferrange/2);
         }
         else
         {
            printf("beginning blk2AN\n");
            ATL_GOODCP(K, N, a, outarray1+(N*lda+K), lda, 
                       tstarray+bufferrange/2);
            ATL_USERCPMM(K, N, a, outarray2+(N*lda+K), lda, 
                         tstarray+bufferrange/2);
         }
         chkarray[0] = tst_checkr(outarray1, outarray2, SZ+bufferrange);
         chkarray[1] = col_buffercheckr(outarray2, K, N, bufferval);
#else
         chkarray[0] = -1;
#endif
         free(tstarray);
         free(outarray1);
         free(outarray2);
         return;
      }
      /* cAN2blk || cAT2blk */
      else if(blk == 1 && cplx == 1 && ccopy == 0)
      {
         TYPE *tstarray = (TYPE *)malloc((SZ+bufferrange) * 2 * sizeof(TYPE));

         for(i=0;i< (SZ+bufferrange) * 2;i++)
         {
            *(tstarray + i) = --count;
         }

         count = 0;

         for(i=K*2;i<K*4;i++)
         {
            for(j=N;j<N*2;j++)
            {
               *(tstarray + i + j*lda2) = ++count;
            }
         }

         TYPE *outarray1i = (TYPE *)malloc(SZ * sizeof(TYPE));
         TYPE *outarray2i = (TYPE *)malloc((SZ + bufferrange) * sizeof(TYPE));
         TYPE *outarray1r = (TYPE *)malloc(SZ * sizeof(TYPE));
         TYPE *outarray2r = (TYPE *)malloc((SZ + bufferrange) * sizeof(TYPE));
   
         count = 0;
      
         for(j = 0;j < SZ; j++)
         {
            *(outarray1r + j) = count;
            *(outarray1i + j) = count;
            *(outarray2r + j + bufferrange/2) = count2;
            *(outarray2i + j + bufferrange/2) = count2;
         }

         for(j=0;j<bufferrange/2;j++)
         {
            *(outarray2r + j) = bufferval;
            *(outarray2r + (SZ + bufferrange - 1) - j) = bufferval;
            *(outarray2i + j) = bufferval;
            *(outarray2i + (SZ + bufferrange - 1) - j) = bufferval;
         }

#if defined TCPLX && CCOPY == 0
         if(transt == 1)
         {
            printf("beginning cAT2blk\n");
            ATL_GOODCP(N, K, a, tstarray+(N*lda2+K*2), lda, outarray1r, 
                       outarray1i);
            ATL_USERCPMM(N, K, a, tstarray+(N*lda2+K*2), lda, 
                         outarray2r+bufferrange/2, outarray2i+bufferrange/2);
         }
         else
         {
            printf("beginning cAN2blk\n");
            ATL_GOODCP(K, N, a, tstarray+(N*lda2+K*2), lda, outarray1r, 
                       outarray1i);
            ATL_USERCPMM(K, N, a, tstarray+(N*lda2+K*2), lda, 
                         outarray2r+bufferrange/2, outarray2i+bufferrange/2);
         }

         chkarray[0] = tst_checkr(outarray1r, outarray2r+bufferrange/2, SZ);
         chkarray[1] = acc_buffercheckr(outarray2r, SZ+bufferrange, bufferrange,
                                        bufferval);
         
         chkarray[0] += tst_checkr(outarray1i, outarray2i+bufferrange/2, SZ);
         chkarray[1] += acc_buffercheckr(outarray2i, SZ+bufferrange, 
                                         bufferrange, bufferval);
#else
         chkarray[0] = -1;
#endif
         free(tstarray);
         free(outarray1i);
         free(outarray1r);
         free(outarray2r);
         free(outarray2i);
      }
      /* cblk2AN || cblk2AT */
      else if(blk == 0 && cplx == 1 && ccopy == 0)
      {
         TYPE *tstarrayi = (TYPE *)malloc((SZ + bufferrange) * sizeof(TYPE));
         TYPE *tstarrayr = (TYPE *)malloc((SZ + bufferrange) * sizeof(TYPE));

         for(i=0;i<SZ+bufferrange;i++)
         {
            *(tstarrayi + i) = --count;
            *(tstarrayr + i) = --count;
         }

         count = 0;

         for(i=0;i<SZ;i++)
         {
            *(tstarrayi + i + bufferrange/2) = ++count;
            *(tstarrayr + i + bufferrange/2) = ++count;
         }

         TYPE *outarray1 = (TYPE *)malloc((SZ + bufferrange)*2*sizeof(TYPE));
         TYPE *outarray2 = (TYPE *)malloc((SZ + bufferrange)*2*sizeof(TYPE));
         assert(outarray1 && outarray2);
         
         count = 0;
      
         for(i=K*2; i < K*4;i++)
         {
            for(j=N;j < N*2;j++)
            {
               *(outarray1 + i + j*lda2) = count;
               *(outarray2 + i + j*lda2) = count2;
            }
         }

         
         for(i=0;i<K*6;i++)
         {
            for(j=0;j<N*3;j++)
            {
               if(i>=K*2 && i<K*4 && j>=N && j<N*2);
               else
               {
                  *(outarray1 + i + j*lda2) = bufferval;                 
                  *(outarray2 + i + j*lda2) = bufferval;                 
               }
            }
         }
         
      
#if defined TCPLX && CCOPY == 0
         if(transt == 1)
         {
            printf("beginning cblk2AT\n");
            ATL_GOODCP(N, K, a, outarray1+N*lda2+K*2, lda, 
                       tstarrayr+bufferrange/2, tstarrayi+bufferrange/2);
            ATL_USERCPMM(N, K, a, outarray2+N*lda2+K*2, lda, 
                         tstarrayr+bufferrange/2, tstarrayi+bufferrange/2);
         }
         else
         {
            printf("beginning cblk2AN\n");
            ATL_GOODCP(K, N, a, outarray1+N*lda2+K*2, lda, 
                       tstarrayr+bufferrange/2, tstarrayi+bufferrange/2);
            ATL_USERCPMM(K, N, a, outarray2+N*lda2+K*2, lda, 
                         tstarrayr+bufferrange/2, tstarrayi+bufferrange/2);
         }
         chkarray[0] = tst_checkr(outarray1, outarray2, SZ+bufferrange);
         chkarray[1] = col_buffercheckr(outarray2, K*2, N, bufferval);
#else
         chkarray[0] = -1;
#endif
         free(tstarrayr);
         free(tstarrayi);
         free(outarray1);
         free(outarray2);
         return;
      }
      /* cC2blk || cCT2blk */
      else if(blk == 1 && cplx == 1 && ccopy == 1)
      {
         TYPE *tstarray = (TYPE *)malloc((SZ+bufferrange) * 2 * sizeof(TYPE));

         for(i=0;i< (SZ+bufferrange) * 2;i++)
         {
            *(tstarray + i) = --count;
         }

         count = 0;

         for(i=K*2;i<K*4;i++)
         {
            for(j=N;j<N*2;j++)
            {

               *(tstarray + i + j*lda2) = ++count;
            }
         }

         TYPE *outarray1i = (TYPE *)malloc(SZ * sizeof(TYPE));
         TYPE *outarray2i = (TYPE *)malloc((SZ + bufferrange) * sizeof(TYPE));
         TYPE *outarray1r = (TYPE *)malloc(SZ * sizeof(TYPE));
         TYPE *outarray2r = (TYPE *)malloc((SZ + bufferrange) * sizeof(TYPE));
   
         count = 0;
      
         for(j = 0;j < SZ; j++)
         {
            *(outarray1r + j) = count;
            *(outarray1i + j) = count;
            *(outarray2r + j + bufferrange/2) = count;
            *(outarray2i + j + bufferrange/2) = count;
         }

         for(j=0;j<bufferrange/2;j++)
         {
            *(outarray2r + j) = bufferval;
            *(outarray2r + (SZ + bufferrange - 1) - j) = bufferval;
            *(outarray2i + j) = bufferval;
            *(outarray2i + (SZ + bufferrange - 1) - j) = bufferval;
         }

#if defined TCPLX && CCOPY == 1 && TO_BLK == 1
   
         if(transt == 1)
         {
            printf("beginning cCT2blk\n");
            ATL_GOODCP(N, K, a, tstarray+(N*lda2+K*2), lda, b, outarray1r, 
                       outarray1i);
            ATL_USERCPMM(N, K, a, tstarray+(N*lda2+K*2), lda, b, 
                         outarray2r+bufferrange/2, outarray2i+bufferrange/2);
         }
         else
         {
            printf("beginning cC2blk\n");
            ATL_GOODCP(K, N, a, tstarray+(N*lda2+K*2), lda, b, outarray1r, 
                       outarray1i);
            ATL_USERCPMM(K, N, a, tstarray+(N*lda2+K*2), lda, b, 
                         outarray2r+bufferrange/2, outarray2i+bufferrange/2);
         }

         chkarray[0] = tst_checkr(outarray1r, outarray2r+bufferrange/2, SZ);
         chkarray[1] = acc_buffercheckr(outarray2r, SZ+bufferrange, 
                                        bufferrange, bufferval);
         
         chkarray[0] += tst_checkr(outarray1i, outarray2i+bufferrange/2, SZ);
         chkarray[1] += acc_buffercheckr(outarray2i, SZ+bufferrange, 
                                         bufferrange, bufferval);
#else
         chkarray[0] = -1;
#endif
         free(tstarray);
         free(outarray1i);
         free(outarray1r);
         free(outarray2r);
         free(outarray2i);
      }
      /* cblk2C || cblk2CT */
      else if(blk == 0 && cplx == 1 && ccopy == 1)
      {
         TYPE *tstarrayi = (TYPE *)malloc((SZ + bufferrange) * sizeof(TYPE));
         TYPE *tstarrayr = (TYPE *)malloc((SZ + bufferrange) * sizeof(TYPE));

         for(i=0;i<SZ+bufferrange;i++)
         {
            *(tstarrayi + i) = --count;
            *(tstarrayr + i) = --count;
         }

         count = 0;

         for(i=0;i<SZ;i++)
         {
            *(tstarrayi + i + bufferrange/2) = ++count;
            *(tstarrayr + i + bufferrange/2) = ++count;
         }

         TYPE *outarray1 = (TYPE *)malloc((SZ + bufferrange)*2*sizeof(TYPE));
         TYPE *outarray2 = (TYPE *)malloc((SZ + bufferrange)*2*sizeof(TYPE));
         assert(outarray1 && outarray2);
         
         count = 0;
      
         for(i=K*2; i < K*4;i++)
         {
            for(j=N;j < N*2;j++)
            {
               *(outarray1 + i + j*lda2) = count;
               *(outarray2 + i + j*lda2) = count;
            }
         }

         
         for(i=0;i<K*6;i++)
         {
            for(j=0;j<N*3;j++)
            {
               if(i>=K*2 && i<K*4 && j>=N && j<N*2);
               else
               {
                  *(outarray1 + i + j*lda2) = bufferval;                 
                  *(outarray2 + i + j*lda2) = bufferval;                 
               }
            }
         }
         
      
#if defined TCPLX && CCOPY == 1 && TO_BLK == 0
         if(transt == 1)
         {
            printf("beginning cblk2CT\n");
            ATL_GOODCP(N, K, a, tstarrayr+bufferrange/2, 
                       tstarrayi+bufferrange/2, b, outarray1+N*lda2+K*2, lda);
            ATL_USERCPMM(N, K, a, tstarrayr+bufferrange/2, 
                         tstarrayi+bufferrange/2, b, outarray2+N*lda2+K*2, lda);
         }
         else
         {
            printf("beginning cblk2C\n");
            ATL_GOODCP(K, N, a, tstarrayr+bufferrange/2, 
                       tstarrayi+bufferrange/2, b, outarray1+N*lda2+K*2, lda);
            ATL_USERCPMM(K, N, a, tstarrayr+bufferrange/2, 
                         tstarrayi+bufferrange/2, b, outarray2+N*lda2+K*2, lda);
         }
         chkarray[0] = tst_checkr(outarray1, outarray2, SZ+bufferrange);
         chkarray[1] = col_buffercheckr(outarray2, K*2, N, bufferval);
#else
         chkarray[0] = -1;
#endif
         free(tstarrayr);
         free(tstarrayi);
         free(outarray1);
         free(outarray2);
         return;
      }
      else
      {
         chkarray[0] = -1;
         return;
      }
}

int main (int nargs, char **args)
{
   int i, j, count = 0;

   /* 
    * The first val in this array will hold the number of incorrectly copied
    * vals the second val will hold the number of buffer violations 
    */
   int chkarray[2] = {0,0};
   int blk = 0, transt = 0, cplx = 0, ccopy = 0;
   int K, N, SZ; 

   SCALAR a;
   SCALAR b;

   GetFlags(nargs, args, &K, &N, &SZ);
   
   /* compile time flags will determine these runtime flags for what form of 
   copytest is occurring */
#if TO_BLK == 1
      blk = 1;
#endif

#if CCOPY == 1 
      ccopy = 1;
#endif

#ifdef TRANST_
      transt = 1;
#endif

   /* complex copytest takes alpha and beta as an array of 2 values each so 
      need to malloc, otherwise just treat as scalar */
#if IS_CPLX == 1
      cplx = 1;
      a = (TYPE *)malloc(2 * sizeof(TYPE));
      b = (TYPE *)malloc(2 * sizeof(TYPE));
      a[0] = alpha;
      a[1] = alpha;
      b[0] = beta;
      b[1] = beta;
#else
      a = alpha;
      b = beta;
#endif

   copytest(blk,transt,ccopy,cplx,K,N,a,b,SZ,chkarray);

   /* this is just a check that will occur if theres a combination of 
      compile time flags that arent accounted for */
   if(chkarray[0] == -1)
   {
      fprintf(stderr,"ERROR NO TESTING DONE, this is probably caused by a "
                     "compile time flag issue \n");
   }
   else if(chkarray[0] == 0 && chkarray[1] == 0)
      fprintf(stderr,"tst passed, both output blocks match and the buffer"
              "was not over-written!\n");
   else
   {
      fprintf(stderr,"tst failed, %d incorrectly copied position errors\n", 
              chkarray[0]);
      fprintf(stderr,"the tested copy routine wrote past the given size %d"
              " times\n", chkarray[1]);
   }
#if IS_CPLX == 1
   free(a);
   free(b);
#endif
}
@ROUT storage.idx scopy.idx dcopy.idx ccopy.idx zcopy.idx
#
# In this file, any line beginning with a '#' is ignored, but the # must be in
# column 0.  All multiple whitespace is reduced to one space (i.e. used only
# to distinguish where words begin/end).  Lines may be extended by putting '\'
# as the *last* character of line.
#
@ROUT storage.idx
# This file indexes the user-supplied storage schemes, and has the following
# format:
# The file has the following format (default values in []):
# ID=<id> FLAG=<bitfield> BLKSZF='iexp' EXTELTF='iexp'
# ID must be a unique >100 number identifying the storage scheme.  A copy
#    routine with a matching STGID must be found for both copy directions
#    in the appropriate [s,c,d,z]blkcpy.idx types.  The storage IDs that
#    are so far in use by ATLAS itself (<100) are:
#      0: access major storage as used in generator, details in struct
#      1: access major (unvectorized or m-vec) storage for A or B
#      2: access major (unvectorized or m-vec) storage for C
#      3: K-vectorized access major storage for A or B
#      4: K-vectorized access major storage for C
#      5: block major (ATLAS 3.10 or older code gen support)
# 'iexp': must contain in '' a valid ANSI C integer expression which computes
#         the indicated storage using only constants and the key-specific
#         variables.
# BLKSZF [((M+mu-1)/mu)*((N+nu-1)/nu)*mu*nu]
#        must contain in '' a valid ANSI C integer expression which computes
#        iexp computes the number of elements to store one block using this
#        storage pattern.  ATLAS assumes real & imag components stored 
#        separately, so complex size should be half of total size.
#        The only variables that can be used will be chosen by the search after
#        tuning and passed to a function with the following prototype:
#           int getsz(int M, int N, int mu, int nu, int vlen);
#        to allow ATLAS to allocate storage for an individual block. j
#        The expression may use the following variables, in addition
#        to any constants (these args themselved might be constants for some
#        storage formats):
#          M : number of rows chosen for block factor
#          N : number of cols chosen for block factor
#         mu : unroll&jam chosen for M dim
#         nu : unroll&jam chosen for N dim
#       vlen : length of vectorization employed
# EXTELTF: [4*mu*nu]
#          how many elements must be allocated past the end of allocated
#          block memory so that advanced loads don't seg fault.  This number
#          should be small.  The generated size function will have prototype:
#            int getsz(int mu, int nu, int vlen);
#
@ROUT scopy.idx dcopy.idx ccopy.idx zcopy.idx
# This file indexes the user-supplied copy routines for the storage schemes
# indexed in storage.ids, and has the following format (non-mandatory
# keys show the default in []):
# ID=<id> STGID=<stgid> CBLK=[0,1] TOBLK=[0,1] TRANS=[0,1] CONJ=[0,1] \
#    MU=<mu> NU=<nu> VLEN=<vlen> ROUT='rt' AUTH='name' \
#    COMP='gcc' CFLAGS='flags' ALPHA=lst BETA=lst
# ID: Mandatory.  Unique (in this file only) int >= 0.  
# STGID: Mandatory.  Number >0 matching and ID in storage.idx.  Predefined:
#    0: access major, scope TOBLKCBLK,VLEN,KVEC to determine what type
#    X: user defined type
# TOBLK: Mandatory. 
#         0: copies from STGID block storage to column-major
#         1: copies from column-major to STGID block storage
# MU/NU: [0] unrolling along 1st & 2nd dim (MU=KU for A/B!);
# TRANS: [0] Needed only for A/B storage, indicates transpose being done:
#    0: cols of matrix stored contiguously, rows strided (col-major)
#    1: rows of matrix stored contiguously, cols strided (row-major)
# ALPHA: mandatory.  What alpha cases handled by kern.  For A/B, full list
#        is 1,N,X, for C it is 0,1,N,X.
# BETA: mandatory for C ignored for A/B.  Full list is 0,1,N,X.
#
# NOTE: for a storage format to be used by ATLAS, enough copy funcs must
#       be supplied for use, and the number required varies by whether the
#       format is for GEMM's A/B or C matrix:
#       A&B: TOBLK=1 and for real TRANS=N&T, cplx TRANS=N&T&C&H
#            TOBLK=0 must be present for testing & custom uses.
#       C  : TOBLK=0 required. TOBLK=1 needed for testing & custom uses.
#
@ROUT scopy.idx 
   @define TP @ REAL=1 SINGLE=1@
@ROUT ccopy.idx 
   @define TP @ SINGLE=1@
@ROUT scopy.idx ccopy.idx 
@define VL @8@
@ROUT dcopy.idx
   @define TP @ REAL=1@
@ROUT zcopy.idx 
   @define TP @@
@ROUT dcopy.idx zcopy.idx 
@define VL @4@
@ROUT scopy.idx dcopy.idx
# This routine doesn't work for non-aligned C, and perf not good enough to fix
#ID=1 STGID=0 CBLK=1 TOBLK=0 MU=3 NU=3 KVEC=@(VL) VLEN=@(VL) SYRK=1@(TP) \
#     ALPHA=1,N,X BETA=0,N,1,X ROUT='ATL_skblk2C3x3.c' AUTH='R. Clint Whaley'
ID=2 STGID=0 TOBLK=1 MU=1 NU=4 VLEN=4 ALPHA=1,N,X@(TP) \
     ROUT='ATL_cpAN2blk4_avx2.c' AUTH='R. Clint Whaley'
ID=3 STGID=0 TOBLK=1 MU=1 NU=12 VLEN=4 ALPHA=1,N,X@(TP) \
     ROUT='ATL_cpAN2blk12_avx2.c' AUTH='R. Clint Whaley'
@ROUT cptst.c
/* 
 * This is a sanity check that takes a known-good copy implementation in
 * CPK_GOOD, and one to test in CPK_TEST.  It then applies these routines
 * on duplicate matrices, and looks for errors greater than expected due to
 * fp arithmetic.  This version specialized for col-major to blk copies.
 */
void cpyblksN(const int mb, const int nb, const size_t M, const size_t N, 
              SCALAR alpha, TYPE *A, size_t lda, TYPE *B, size_ldb, TYPE *wrk)
/*
 * B <-- alpha*A; A&B both MxN, copy by blocks
 */
{
   const size_t nmblks=M/mb, Mb=nmblks*mb, mr=M-Mb;
   const size_t nnblks=N/nb, Nb=nnblks*nb, nr=N-Nb;
   size_t i, j;
   const int NB=nb SHIFT;
   #ifdef TCPLX
      TYPE ralpha[2];
   #else
      TYPE ralpha = ATL_rone / alpha;
   #endif
   #ifdef TCPLX
      Mjoin(PATL,cplxinvert)(1, alpha, 1, ralpha, 1);
   #endif

   for (j=0; j < Nb; j += nb, A += lda*NB, B += ldb*NB)
   {
      for (i=0; i < Mb; i += mb)
      {
         mycpyN(mb, nb, alpha, A+(i SHIFT), lda, wrk);
         myrcpyN(mb, nb, ralpha, B+(i SHIFT), ldb, wrk);
      }
   }
}
int cntErr(int verb, int M, int N, TYPE *A, size_t lda, TYPE *E, size_t lde, 
           TYPE tol)
{
   int j, nerr=0;
   for (j=0; j < N; j++, A += lda SHIFT, E += lde SHIFT)
   {
      for (i=0; i < M; i++)
      {
         diff = A[i] - E[i];
         if (diff > tol)
         {
            
         }
      }
   }
}

int main(int nargs, char **args)
{
   int mb=28, nb=36, lda, m=27, n=33, N=nb+4;
   int lda=mb+55;
   size_t szA, szW, csz, lda=mb+55, lda2, i;
   #ifdef TCPLX
      TYPE alpha[2]={ATL_rone, ATL_rzero}, beta[2]={ATL_rone, ATL_rzero};
   #else
      TYPE alpha=ATL_rone, beta=ATL_rone;
   #endif
   TYPE *A, *G, *T;
   char *cp;

   lda2 = lda SHIFT:
   sz = N*lda2;
   A = malloc(sz*sizeof(TYPE))
   assert(A);
   for (i=0; i < sz; i++)
      A[i] = i;
   szW = mb * nb;
   csz = 2*(szW SHIFT)*sizeof(TYPE) + 3*ATL_Cachelen;
   cp = malloc(2*csz);
   assert(cp);
   cp = (char*)w;
   for (i=0; i < 2*csz; i++)
      cp[i] = 0xFF;
   T = ATL_AlignPtr(cp) + ATL_Cachelen;
   G = (TYPE*) (((char)T) + csz);

}
@ROUT cpysearch
#include "atlas_cpparse.h"
#include "atlas_cptesttime.h"
#include "atlas_mmparse.h"
#include "atlas_mmtesttime.h"
#include "atlas_mmgen.h"

void PrintUsage(char *name, int ierr, char *flag)
{
   if (ierr > 0)
      fprintf(stderr, "Bad argument #%d: '%s'\n", ierr,
              flag?flag:"OUT-OF_ARGUMENTS");
   else if (ierr < 0)
      fprintf(stderr, "ERROR: %s\n", flag);
   fprintf(stderr, "USAGE: %s [flags:\n", name);
@skip   fprintf(stderr, "   -p [s,d,c,z]: set type/precision prefix (d) \n");
   fprintf(stderr, "   -u <ucase.idx>: (none) user cases to try\n");
   fprintf(stderr, "   -i <cpyin.CPS>: (stdin) list of copy to search\n");
   fprintf(stderr, "   -o <cpyout.CPS>: (stdout) fastest copy kernels\n");
@skip   fprintf(stderr, "   -v <verb> : set verbosity (1)\n");
   exit(ierr ? ierr : -1);
}

ATL_cpnode_t *GetFlags(int nargs, char **args, int *VERB, char **FOUT, 
                       ATL_cpnode_t **UB)
/*
 * RETURNS: list of all kerns/blk factors to tune copies for
 */
{
   ATL_cpnode_t *cb=NULL, *cp, *ub=NULL;
   int i;

   *VERB = 0;
   *FOUT = NULL;
   for (i=1; i < nargs; i++)
   {
      if (args[i][0] != '-')
         PrintUsage(args[0], i, args[i]);

      switch(args[i][1])
      {
      case 'u':
        if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
        ub = ReadCPFile(args[i]);
        break;
      case 'i':
        if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
        cb = ReadCPFile(args[i]);
        assert(cb);
        break;
      case 'o':
        if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
        *FOUT = args[i];
        break;
      default:
         PrintUsage(args[0], i, args[i]);
      }
   }
   if (!cb)
      cb = ReadCPFile(NULL);
   *UB = ub;
   return(cb);
}

unsigned long GetRep(unsigned long reps, unsigned int mb, unsigned int nb)
{
   double ratio;
   unsigned long nrep;
   ratio = 16.0 / (((double)mb)*nb);
   nrep = reps*ratio;
   nrep = (nrep > 0) ? nrep : 1;
   return(nrep);
}

ATL_cpnode_t *GetWorkingKerns(char pre, int verb, ATL_cpnode_t *cb)
/*
 * Right now, just reads in all kerns.  Later, should eliminate kerns that
 * won't work with any cb.
 */
{
   ATL_cpnode_t *hb=NULL;
   int DOTEST=0;
@skip   hb = ReadCPFileWithPath(pre, "res", "cpywork_a1b0.sum");
   if (!hb)
   {
      hb = ReadCPFileWithPath(pre, "CPYCASES", "copy.idx");
      #if 0
      if (flag&(1<<CPF_CBLK))
         DOTEST = (CopyGetAlphaI(flag) == 1 && CopyGetBetaI(flag) == 0);
      else
         DOTEST = CopyGetAlphaI(flag) == 1;
      #endif
   }

@skip   hb = CopyApplyTypeScal2Hand(hb, flag);
   PrefixStrAllNodes(hb, GetOffset(&hb->next, hb), GetOffset(&hb->rout, hb),
                     "CPYCASES/");
   if (DOTEST)
   {
      hb = KillFailingCPNodes(pre, hb);
      WriteCPFileWithPath(pre, "res", "cpywrk_a1b0.sum", hb);
   }
@skip   hb = KillCPNodesByFlag(flag, 1<<CPF_CBLK, hb); /* kill wrong-mat kerns */
   return(hb);
}

ATL_cpnode_t *DoHandTimings
   (char pre, int verb, unsigned long rep4, ATL_cpnode_t *cb, ATL_cpnode_t *hb)
{
   ATL_cpnode_t *cp, *hp, *HB=NULL;
   unsigned long nrep;


   if (!hb)
   {
      printf("NO USER-SUPPLIED COPY ROUTINES!\n");
      return(NULL);
   }
   printf("FINDING BEST HAND-TUNED COPY:\n");
   for (cp=cb; cp; cp=cp->next)
   {
      double mf;
      ATL_cpnode_t *np=NULL;
      const unsigned int mb=cp->mb, nb=cp->nb, flag=cp->flag;
      int ialp, ibet=0;

      nrep = GetRep(rep4, mb, nb);
      ialp = CopyGetAlphaI(flag);
      if (flag & (1<<CPF_CBLK))
         ibet = CopyGetBetaI(flag);
/*
 *    Try any hand-tuned cases that work
 */
      hp = FindEquivUserCopy(hb, cp);
      if (hp)
      {
         printf("   TIMINGS B=(%d,%d), U=(%d,%d) TA=%c, reps=%lu:\n", 
                cp->mb, cp->nb, cp->mu, cp->nu, 
                (cp->flag&(1<<CPF_TRANS))?'T':'N', nrep);
         printf("      ID=%6d VL=%2d: mf=%.0f\n", 0, cp->vlen, cp->mflop[0]);
         do
         {
            double mf;

            mf = TimeCPKernel(verb, 0, hp, mb, nb, ialp, ibet, nrep, -1);
            printf("      ID=%6d VL=%2d: mf=%.0f\n", hp->ID, hp->vlen, mf);
            if (mf > cp->mflop[0])
            {
               if (np)
                  KillCPNode(np);
               np = CloneCPNode(hp);
               np->mflop[0] = mf;
               np->mb = mb;
               np->nb = nb;
               np->flag = CopyEncodeScal(flag, ialp, ibet);
            }
            hp = hp->next;
         }
         while( (hp = FindEquivUserCopy(hp, cp)) );
         printf("   DONE\n");
      }
      if (!np)
         np = CloneCPNode(cp);
      np->next = HB;
      HB = np;
   }
   if (hb)
      KillAllCPNodes(hb);
   return(ReverseCPQ(HB));
}

void DoGenTimings(char pre, int verb, unsigned long rep4, ATL_cpnode_t *cb)
{
   ATL_cpnode_t *cp;
   char *fnam;

@skip   fnam = GetCpySumNam(flag, 'g');
   printf("FINDING BEST GENERATED COPY:\n");
   for (cp=cb; cp; cp = cp->next)
   {
      double mf, mfB;
      unsigned long nrep;
      int ialp, ibet=0, flag=cp->flag;
      ialp = CopyGetAlphaI(flag);
      if (flag & (1<<CPF_CBLK))
         ibet = CopyGetBetaI(flag);

      nrep = GetRep(rep4, cp->mb, cp->nb);
      printf("   TIMINGS B=(%d,%d), U=(%d,%d), TA=%c, reps=%lu:\n", 
             cp->mb, cp->nb, cp->mu, cp->nu, (cp->flag&(1<<CPF_TRANS))?'T':'N',
             nrep);
      cp->vlen = 1;
      if (!cp->rout)
         cp->rout = DupString("ATL_tmp.c");
      if (cp->genstr)
         free(cp->genstr);
      cp->genstr = GetCopyGenStr(cp);
      mfB = TimeCPKernel(verb, 0, cp, cp->mb, cp->nb, ialp, ibet, nrep, -1);
      printf("      ID=     0 VL= 1: mf=%.0f\n", mfB);
      cp->mflop[0] = mfB;
/*
 *    See if we can use vectorized generator.
 *    Present vector generator only supports SSE/AVX for real GEMM C copy
 */
      #if defined(ATL_AVX) || defined(ATL_SSE2) || defined(ATL_SSE)
         if (!(cp->flag & CPF_ALLKERN) && (pre == 's' || pre == 'd') &&
             (cp->flag&(1<<CPF_CBLK)))
         {
            char *gens;
            int VL0=cp->vlen, VL = (pre == 's') ? 4 : 2;

         #if defined(ATL_SSE2) || defined(ATL_SSE1)
            #if defined(ATL_SSE2)
            if (cp->mu % VL == 0 && (pre == 'd' || pre == 's') && 
                !(cp->flag&CPF_ALLKERN))
            #else
            if (cp->mu % VL == 0 && pre == 's' && !(cp->flag&CPF_ALLKERN))
            #endif
            {
               gens = cp->genstr;
               cp->vlen = VL;
               cp->genstr = GetCopyGenStr(cp);
               mf = TimeCPKernel(verb, 0, cp, cp->mb, cp->nb, ialp, ibet, 
                                 nrep, -1);
               printf("      ID=     0 VL=%2d: mf=%.0f\n", VL, mf);
               if (mf > mfB)
               {
                  free(gens);
                  cp->mflop[0] = mfB = mf;
               }
               else
               {
                  free(cp->genstr);
                  cp->genstr = gens;
                  cp->vlen = VL0;
               }
            } /* end SSE if */
         #endif
         #ifdef ATL_AVX
            VL0 = cp->vlen;
            VL <<= 1;
            if (cp->mu % VL == 0)
            {
               gens = cp->genstr;
               cp->vlen = VL;
               cp->genstr = GetCopyGenStr(cp);
               mf = TimeCPKernel(verb, 0, cp, cp->mb, cp->nb, ialp, ibet, 
                                 nrep, -1);
               printf("      ID=     0 VL=%2d: mf=%.0f\n", VL, mf);
               if (mf > mfB)
               {
                  free(gens);
                  cp->mflop[0] = mfB = mf;
               }
               else
               {
                  free(cp->genstr);
                  cp->genstr = gens;
                  cp->vlen = VL0;
               }
            } /* end AVX if */
         #endif
         }    /* end if over trying old vec-basefile */
      #endif  /* end #if on Intel SSE/AVX */
   }
   printf("DONE GENERATED COPY SEARCH\n");
@skip   WriteCPFileWithPath(pre, "res", fnam, cb);
@skip   printf("DONE, output in: res/%c%s\n", pre, fnam);
}

void DoTimings
   (char *fnam, char pre, int verb, unsigned long rep4, ATL_cpnode_t *cb, 
    ATL_cpnode_t *ub)
{
   ATL_cpnode_t *cp, *fb;

   cp = TimeCPFile(pre, fnam, 0, verb, 0);
   if (cp)
   {
      KillAllCPNodes(cp);
      return;
   }
   DoGenTimings(pre, verb, rep4, cb);
   fb = DoHandTimings(pre, verb, rep4, cb, ub);
   if (!fb)
      fb = cb;
   for (cp=fb; cp; cp=cp->next)
   {
      if (cp->flag & (1L<<CPF_SYRK))
         cp->mflop[0] = 2e-6 / cp->mflop[0]; /* time per elt */
      else
         cp->mflop[0] = 1e-6 / cp->mflop[0]; /* time per elt */
   }
   WriteCPFile(fnam, fb);
   if (fb != cb)
      KillAllCPNodes(fb);
   printf("DONE, OUTPUT IN: %s.\n", fnam);
}

unsigned long GetReps4x4(int verb, double res)
/*
 * Find how many repititions to do for 4x4 copy to get timing interval to
 * around res seconds
 */
{
   ATL_cpnode_t *cp;
   double tim, mf;
   unsigned long nrep = 32;
   FILE *fp;

   fp = fopen("res/ncprep4x4.txt", "r");
   if (fp)
   {
      fscanf(fp, " %lu", &nrep);
      fclose(fp);
      return(nrep);
   }
   cp = GetCPNode();
   cp->mu = 4; 
   cp->nu = 1;
   cp->flag = (1<<CPF_BE0)|(1<<CPF_AL1)|(1<<CPF_CBLK)|
              (1<<CPF_SINGLE)|(1<<CPF_REAL);
   cp->rout = DupString("ATL_tmp.c");
   cp->genstr = GetCopyGenStr(cp);

   printf("FINDING NREP:\n");
   do
   {
      nrep += nrep;
      mf = TimeCPKernel(verb, 1, cp, 4, 4, 1, 0, nrep, -1);
      tim = (mf / 16e6) * nrep;
      printf("   NREP=%16lu, tim=%e\n", nrep, tim);
   }
   while (tim < res && nrep < 100000);
   printf("DONE.\n");
   KillCPNode(cp);
   fp = fopen("res/ncprep4x4.txt", "w");
   fprintf(fp, "%lu", nrep);
   fclose(fp);
   return(nrep);
}

int main(int nargs, char **args)
/*
 * For now read geAMMRES.sum, later add rkAMMRES.sum & SYRK.
 * Will use this info to find unique lists of AB & C copiers.
 * -> Later must extend for A & B using possibly different copiers.
 * It then finds the fastest working copy routine for each case, 
 * trying each of following:
 * (1) Codes generated from atlas-mmkg.base (all standard formats)
 * (2) atlas-mmg.base (vector ops, but only mu%vlen Cblk formats)
 * (3) User-contributed cases
 */
{
   ATL_cpnode_t *cb, *cp, *cb0, *ub;
   char *fout;
   unsigned long nrep;
   char pre;
   int verb, minSz, ialp, ibet=0;
   unsigned int flag;

   cb = GetFlags(nargs, args, &verb, &fout, &ub);
   pre = CopyGetPre(cb->flag);
   nrep = GetReps4x4(verb, 0.10);
   DoTimings(fout, pre, verb, nrep, cb, ub);

   KillAllCPNodes(cb);
   return(0);
}
@ROUT cpygen
#include "atlas_cpparse.h"
#include "atlas_mmgen.h"
#include "atlas_iopt.h"
void GenMake(ATL_cpnode_t *cb, char *path)
{
   FILE *fp;
   ATL_cpnode_t *cp;
   int len, CPLX;
   char *fnam;
   char pre;
   char UPR;
   char dcomp[7] = {'$','(', 'D', 'K', 'C',')', '\0'};
   char dflag[12] = {'$','(','D','K','C', 'F','L','A','G','S', ')', '\0'};
@skip   char *getd="fgrep 'BLDdir =' Make.inc | sed -e 's/   BLDdir = //'";

   if (!cb)
      return;
   pre = CopyGetPre(cb->flag);
   CPLX = pre == 'c' || pre == 'z';
   len = strlen(path) + 10;  /* /Makefile */
   fnam = malloc(len);
   assert(fnam);
   sprintf(fnam, "%s/Makefile", path);
   assert(!Sys2File("fgrep 'BLDdir =' Make.inc", fnam));
   fp = fopen(fnam, "a");
   assert(fp);
   free(fnam);
   fprintf(fp, "include $(BLDdir)/Make.inc\n");

   UPR = (pre == 'c' || pre == 's') ? 'S' : 'D';
   dflag[2] = dcomp[2] = UPR;
   fprintf(fp, "\n   objs =");
   for (cp=cb; cp; cp = cp->next)
   {
      fprintf(fp, " \\\n          %s.o", cp->rout);
      if (CPLX && !(cp->flag&(1<<CPF_CBLK)))  /* Need conjugate target? */
      {
         ConjCopyName(cp);
         fprintf(fp, " \\\n          %s.o", cp->rout);
         UnConjCopyName(cp);
      }
   }      
   PrintMakeTargs(fp, pre);
/*
 * Print compilation rules 
 */
   for (cp=cb; cp; cp = cp->next)
   {
      char ch = (cp->flag&(1<<CPF_ASM)) ? 'S' : 'c';
      if (cp->comp || cp->cflags)
      {
         fprintf(fp, "%s.o : %s.%c\n", cp->rout, cp->rout, ch);
         fprintf(fp, "\t%s $(CDEFS) %s -c %s.%c", cp->comp ? cp->comp:dcomp, 
                 cp->cflags ? cp->cflags : dflag, cp->rout, ch);
      }
      if (CPLX && !(cp->flag&(1<<CPF_CBLK)))  /* Need conjugate target? */
      {
         ConjCopyName(cp);
         fprintf(fp, "%s.o :", cp->rout);
         UnConjCopyName(cp);
         fprintf(fp, " %s.%c\n", cp->rout, ch);
         fprintf(fp, "\t%s $(CDEFS) %s -DConj_=1 -c %s.%c\\\n", 
                 cp->comp ? cp->comp:dcomp, cp->cflags ? cp->cflags:dflag,
                 cp->rout, ch);
         ConjCopyName(cp);
         fprintf(fp, "           -o %s.o\n", cp->rout);
         UnConjCopyName(cp);
      }
   }
/*
 * Print default rules
 */
   fprintf(fp, ".S.o:\n");
   fprintf(fp, "\t%s $(CDEFS) %s -c $*.S\n", dcomp, dflag);
   fprintf(fp, ".s.o:\n");
   fprintf(fp, "\t%s $(CDEFS) %s -c $*.s\n", dcomp, dflag);
   fprintf(fp, ".c.o:\n");
   fprintf(fp, "\t%s $(CDEFS) %s -c $*.c\n", dcomp, dflag);

   fclose(fp);
}

void GenCopy(ATL_cpnode_t *cb, char *path)
{
   ATL_cpnode_t *cp;
   char *sp, *typs, *untyp;
   int len, plen;
   char pre;

   if (!cb)
      return;

   plen = strlen(path);
   pre = CopyGetPre(cb->flag);
   untyp = "#ifdef SCALAR\n   #undef SCALAR\n#endif\n"
           "#ifdef TYPE\n   #undef TYPE\n#endif\n"
           "#ifdef SREAL\n   #undef SREAL\n#endif\n"
           "#ifdef DREAL\n   #undef DREAL\n#endif\n"
           "#ifdef SCPLX\n   #undef SCPLX\n#endif\n"
           "#ifdef DCPLX\n   #undef DCPLX\n#endif\n" 
           "#ifdef ALPHA1\n  #undef ALPHA1\n#endif\n" 
           "#ifdef ALPHAN\n  #undef ALPHAN\n#endif\n" 
           "#ifdef ALPHAN1\n  #undef ALPHAN1\n#endif\n" 
           "#ifdef ALPHAX\n  #undef ALPHAX\n#endif\n" 
           "#ifdef BETA1\n  #undef BETA1\n#endif\n" 
           "#ifdef BETAN\n  #undef BETAN\n#endif\n" 
           "#ifdef BETAN1\n  #undef BETAN1\n#endif\n" 
           "#ifdef BETAX\n  #undef BETAX\n#endif\n";
   if (pre == 'z')
      typs = "#define DCPLX 1\n#define TYPE double\n#define SCALAR TYPE*\n";
   else if (pre == 'c')
      typs = "#define SCPLX 1\n#define TYPE float\n#define SCALAR TYPE*\n";
   else if (pre == 'd')
      typs = "#define DREAL 1\n#define TYPE double\n#define SCALAR TYPE\n";
   else if (pre == 's')
      typs = "#define SREAL 1\n#define TYPE float\n#define SCALAR TYPE\n";

   for (cp=cb; cp; cp = cp->next)
   {
      char *nam, *fnam=NULL, *rt=cp->rout;
      char calp, cbet=0, fe = 'c';
      FILE *fp;

      calp = CopyGetAlphaC(cp->flag);
      if (cp->flag&(1<<CPF_CBLK))
         cbet = CopyGetBetaC(cp->flag);
      nam = GetCopyName(cp, 0);
      if (cp->ID)
      {
         char *onam;
         assert(rt);
         for (onam=rt; *onam; onam++);
         fe = onam[-1];
         if (fe != 'c' && fe != 'S' && fe != 's')
            fe = 'c';
         
         len = 10 + strlen(rt);
         cp->rout = malloc(len);
         assert(cp->rout);
         if (strncmp(rt, "CPYCASES/", 9))
            sprintf(cp->rout, "CPYCASES/%s", rt);
         else
            strcpy(cp->rout, rt);
      }
      else
      {
         char *gens=cp->genstr;
         cp->rout = "ATL_tmp.c";
         cp->genstr = GetCopyGenStr(cp);
         MMDoGenString(0, cp->genstr);
         free(cp->genstr);
         cp->genstr = gens;
      }
      if (rt)
         free(rt);
      if (fe == 's' || fe == 'S')
         cp->flag |= 1L<<CPF_ASM;
      len = strlen(path) + 1 + strlen(nam) + 2 + 1;
      fnam = malloc(len);
      sprintf(fnam, "%s/%s.%c", path, nam, fe);
      fp = fopen(fnam, "w");
      assert(fp);
      fprintf(fp, untyp);
      fprintf(fp, typs);
      if (cp->flag&(1<<CPF_CBLK))
      {
         fprintf(fp, "#define BETA%c\n", cbet);
         if (cbet == 'N')
            fprintf(fp, "#define BETAN1 1\n");
         fprintf(fp, "#define ATL_MU %u\n#define ATL_NU %u\n", cp->mu, cp->nu);
      }
      else
         fprintf(fp, "#define ATL_NU %u\n", cp->nu);
      fprintf(fp, "#define ALPHA%c 1\n", calp);
      if (calp == 'N')
         fprintf(fp, "#define ALPHAN1 1\n");
      fprintf(fp, "#define ATL_USERCPMM %s\n", nam);
      if (!(cp->flag&(1<<CPF_REAL)) && !(cp->flag&(1<<CPF_CBLK)))
      {  /* if complex A/B copy, need conj_! */
         char *rt = cp->rout;
         cp->rout = nam;
         fprintf(fp, "#ifdef Conj_\n   #undef ATL_USERCPMM\n");
         ConjCopyName(cp);
         fprintf(fp, "   #define ATL_USERCPMM %s\n#endif\n", nam);
         UnConjCopyName(cp);
         cp->rout = rt;
      }
      fprintf(fp, "\n");
      fclose(fp);
      len = 10 + strlen(cp->rout) + strlen(fnam);
      sp = malloc(len);
      assert(sp);
      sprintf(sp, "cat %s >> %s", cp->rout, fnam);
      free(fnam);
      if (system(sp))
      {
         fprintf(stderr, "ERROR IN CMD: '%s'\n", sp);
         assert(0);
      }
      free(sp);
      if (cp->ID)
         free(cp->rout);
      cp->rout = nam;
   }
}

void PrintUsage(char *name, int ierr, char *flag)
{
   if (ierr > 0)
      fprintf(stderr, "Bad argument #%d: '%s'\n", ierr,
              flag?flag:"OUT-OF_ARGUMENTS");
   else if (ierr < 0)
      fprintf(stderr, "ERROR: %s\n", flag);
   fprintf(stderr, "USAGE: %s [flags]:\n", name);
   fprintf(stderr, "   -i cpyout.sum: repeat for multiple\n");
   fprintf(stderr, "   -o <output path>\n");
@skip   fprintf(stderr, "   -v <verb> : set verbosity (1)\n");
   exit(ierr ? ierr : -1);
}

ATL_cpnode_t *GetFlags(int nargs, char **args, char **OUTD)
{
   ATL_cpnode_t *cb=NULL, *cp;
   char *outd=NULL;
   int i;

   for (i=1; i < nargs; i++)
   {
      if (args[i][0] != '-')
         PrintUsage(args[0], i, args[i]);

      switch(args[i][1])
      {
      case 'i':
        if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
        if (!cb)
           cb = ReadCPFile(args[i]);
        else
        {
           cp = ATL_LastCPNode(cb);
           cp->next = ReadCPFile(args[i]);
        }
        break;
      case 'o':
        if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
        outd = DupString(args[i]);
        break;
      default:
         PrintUsage(args[0], i, args[i]);
      }
   }
   if (!cb)
      cb = ReadCPFile(NULL);
   if (!outd)
      outd = DupString("tmp/");
   *OUTD = outd;
   return(cb);
}

int main(int nargs, char **args)
{
   ATL_cpnode_t *cb;
   char *outd;

   cb = GetFlags(nargs, args, &outd);
   assert(cb);
   GenCopy(cb, outd);   /* sets info for Protos&Make! */
   GenMake(cb, outd);
   free(outd);
   KillAllCPNodes(cb);
   return(0);
}
@ROUT cphgen
@beginskip
// NOTE: GenProto is view-specific, so don't put that here.
static int flag2PrIdx(int flag)
/*
 * Translates C matrix: a1b0:0, a1b1:1 a1bN:2, a1bX:3, aN, aX (aXbX=11)
 * A matrix: a1N:12 a1T:13, aNN:14 aNT:15,aXN:16 aXT:17.
 * so 18 choices, * 2 for TOBLK.
 */
{
   int i;
   if (flag & (1<<CPF_CBLK))
   {
      if (flag & (1<<CPF_AL1))
         i = 0;
      else 
         i = (flag & (1<<CPF_ALN)) ? 4 : 8;
      if (flag & (1<<CPF_BE1))
         i++;
      else if (flag & (1<<CPF_BEN))
         i += 2;
      else if (flag & (1<<CPF_BEX))
         i += 3;
   }
   else
   {
      if (flag & (1<<CPF_AL1))
         i = 0;
      else 
         i = (flag & (1<<CPF_ALN)) ? 2 : 4;
      if (flag & (1<<CPF_TRANS))
         i++;
      i += 12;
   }
   if (flag & (1<<CPF_TOBLK))
      i += 18;
   return(i);
}

@endskip
#include "atlas_mmgen.h"
#include "atlas_type.h"
void PrintProtos(FILE *fp, ATL_cpnode_t *cb)
{
   ATL_cpnode_t *cp;
   int i;
   char *args;

   if (!cb)
      return;
   cb = CloneCPQueue(cb);
   cb = CopyNoRep(cb, 24*24);
   if (cb->flag & (1<<CPF_CBLK))
   {
      if (cb->flag & (1<<CPF_TOBLK)) /* copy from C into blk */
      {
         if (cb->flag & (1<<CPF_REAL))
            args = "ATL_CSZT,ATL_CSZT,const SCALAR,const TYPE*,ATL_CSZT,"
                   "const SCALAR, TYPE *";
         else
            args = "ATL_CSZT,ATL_CSZT,const SCALAR,const TYPE*,ATL_CSZT,"
                   "const SCALAR, TYPE*,TYPE*";
      }
      else /* copy from block into C */
      {
         if (cb->flag & (1<<CPF_REAL))
            args = "ATL_CSZT,ATL_CSZT,const SCALAR,const TYPE*,"
                   "const SCALAR,TYPE*,ATL_CSZT";
         else
            args = "ATL_CSZT,ATL_CSZT,const SCALAR,const TYPE*,const TYPE*,"
                   "const SCALAR,TYPE*,ATL_CSZT";
      }
   }
   else if (cb->flag & (1<<CPF_TOBLK)) /* A2blk */
   {
      if (cb->flag & (1<<CPF_REAL))
         args = "ATL_CSZT,ATL_CSZT,const SCALAR,const TYPE*,ATL_CSZT,TYPE*";
      else
         args = "ATL_CSZT,ATL_CSZT,const SCALAR,const TYPE*,ATL_CSZT,"
                "TYPE*,TYPE*";
   }
   else /* blk2A */
   {
      if (cb->flag & (1<<CPF_REAL))
         args = "ATL_CSZT,ATL_CSZT,const SCALAR, const TYPE*,ATL_CSZT,TYPE*";
      else
         args = "ATL_CSZT,ATL_CSZT,const SCALAR, const TYPE*,ATL_CSZT,"
                "TYPE*,TYPE*";
   }
   for (cp=cb; cp; cp = cp->next)
      fprintf(fp, "void %s\n   (%s);\n", cp->rout, args);
@skip   fprintf(fp, "\n#endif\n");
   KillAllCPNodes(cb);
}

void PrintUsage(char *name, int ierr, char *flag)
{
   fprintf(stderr, 
      "This program generates copy header files for lists of kernels.\n"
      "It will generate seperate header file for each alpha/beta combo.\n");
   if (ierr > 0)
      fprintf(stderr, "Bad argument #%d: '%s'\n", ierr,
              flag?flag:"OUT-OF_ARGUMENTS");
   else if (ierr < 0)
      fprintf(stderr, "ERROR: %s\n", flag);
   fprintf(stderr, "USAGE: %s [flags:\n", name);
   fprintf(stderr, "   -p [d,s,c,z]\n");
   fprintf(stderr, "   -o /path : specify directory to generate into\n");
@ROUT cphgen printView
   fprintf(stderr,
"   -V [C,A]a=1,N,X Cb=0,1,N,X [A,C]d=I,F K=0,1 S=A,C,M,U <name> mmview.sum:\n"
          );
   fprintf(stderr, 
"      If args to left of = are omitted, these vals don't appear in the view.\n"
"      Args to right of = may be omitted, which means all values are set.\n"
"      <name> and <mmview> must appear in that order.\n"
"      A/Cd=[I,F]: copy Into or From col-major (I,F means both directions).\n"
"      A/Ca/b give the list of needed alpha/beta for that matrix copy.\n"
"      K : change how K-cleanup is done, default 1:\n"
"          0: Kerns self-clean, so no padding if MOD(kbB,ku)==0, else ku-pad\n"
"          1: Kernels use other kernels for K-cleanup.\n"
"      S=A,C,M,U: don't store [A,C] copyI, matmulI, or unrollings, resp.\n"
"      Suppressed copies will still be added to master list, just not in view\n"
"      <name> is a unique string that will be used in all header files.\n"
"      mmview.sum: list of amm kerns demanding the copies.\n");
@ROUT cphgen
   exit(ierr ? ierr : -1);
}

ATL_view_t *GetFlags(int nargs, char **args, char *PRE, char **PTH)
{
   ATL_view_t *vb=NULL;
   char *pth=NULL, *nm=NULL;
   int i;
   char pre='d', dir='I';

   for (i=1; i < nargs; i++)
   {
      ATL_view_t *vp;
      char *nam;
      int k, flag=0;

      if (args[i][0] != '-')
         PrintUsage(args[0], i, args[i]);

      switch(args[i][1])
      {
      case 'p':
         if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
         pre = tolower(args[i][0]);
         assert(pre == 's' || pre == 'd' || pre == 'z' || pre == 'c');
         break;
      case 'o':
         if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
         pth = DupString(args[i]);
         break;
@ROUT cphgen readView
      case 'V':    /* -V C/Aa=1,N,X Cb=0,1,N,X C/Ad=I,F K=[0,1] S=A,C,M,U */
         if (++i >= nargs)/*    <name> mmview.sum */
            PrintUsage(args[0], i-1, NULL);
         flag = 0;
         for (k=0; k < 7; k++)
         {
            char mt, wt;
            int st;
            mt = args[i][0];
            if (mt == 'S')
            {
               char *cp = args[i] + 1;
               assert(*cp == '=');
               do
               {
                  cp++;
                  switch(*cp)
                  {
                  case 'A':
                     flag |= 1<<CPV_NOACP;
                     break;
                  case 'C':
                     flag |= 1<<CPV_NOCCP;
                     break;
                  case 'M':
                     flag |= 1<<CPV_NOMMI;
                     break;
                  case 'U':
                     flag |= 1<<CPV_NOUNR;
                     break;
                  default:
                     PrintUsage(args[0], i-1, NULL);
                  }
                  cp++;
               }
               while(*cp == ',');
            }
            else if (mt == 'K')
            {
               char *cp = args[i] + 1;
               assert(*cp == '=');
               if (cp[1] == '0')
                  flag |= 1<<CPV_SELFK;
               else if (cp[1] == '1')
                  flag &= ~(1<<CPV_SELFK);
               else
                  PrintUsage(args[0], i-1, NULL);
            }
            else if (mt != 'C' && mt != 'A')
               break;
            else
            {
               wt = args[i][1];
               if (wt != 'a' && wt != 'b' && wt != 'd')
                  break;
               if (args[i][2] != '=')
                  break;
               if (wt == 'b')
               {
                  assert(mt == 'C');
                  flag |= CPV_ScalStr2bits(args[i]+3, CPV_BE1C);
               }
               else if (wt == 'a')
                  flag |= CPV_ScalStr2bits(args[i]+3, 
                          (mt=='C')?CPV_AL1C:CPV_AL1A);
               else if (wt == 'd')
                  flag |= CPV_DirStr2bits(args[i]+3,
                          (mt=='C')?CPV_C2BLK:CPV_A2BLK);
               else
                  PrintUsage(args[0], i-1, NULL);
            }
            if (++i >= nargs)
               PrintUsage(args[0], i-1, NULL);
         }
         nam = DupString(args[i]);
         if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
         vp = ATL_NewView(flag, nam, DupString(args[i]));
         vp->next = vb;
         vb = vp;
         break;
@ROUT cphgen
      default:
         PrintUsage(args[0], i, args[i]);
      }
   }
   assert(vb);
   if (!pth)
      pth = DupString("tmp");
   *PRE = pre;
   *PTH = pth;
   return(vb);
}

void GenHead
(
   char pre,        /* s,d,c,z */
   char mtx,        /* C,A,B */
   char dir,        /* 'F': FromC, i.e. C2blk, 'I': blk2C */
   char calp,       /* 1,N,X */
   char cbet,       /* C:0,1,N,X or A:T,N */
   char *nm,        /* view name */
   char *pnam,      /* name with path */
   char *nam,       /* name without path */
   ATL_cpnode_t *cb /* queue of copies to produce header for */
)
{
   ATL_cpnode_t *cp;
   FILE *fpp, *fpd;
   char *sp, *arrnm;
   int i, flag, N;

   assert(cb);
   sp = strstr(nam, "ZZZZ");
   assert(sp);
   sp[0] = 'p';
   sp[1] = 'e';
   sp[2] = 'r';
   sp[3] = 'f';
   fpp = fopen(pnam, "w");
   assert(fpp);
   PrintBegIfdef(fpp, nam);
   sp[0] = 'd';
   sp[1] = 'e';
   sp[2] = 'c';
   sp[3] = 'l';
   fpd = fopen(pnam, "w");
   assert(fpd);
   PrintBegIfdef(fpd, nam);
   sp[0] = 'Z';
   sp[1] = 'Z';
   sp[2] = 'Z';
   sp[3] = 'Z';

   fprintf(fpd, "\n#include \"atlas_amm.h\"\n");
   fprintf(fpd, "/*\n * Prototypes\n */\n");
   PrintProtos(fpd, cb);
   fprintf(fpd, "/*\n * Index array\n */\n");
   N = ATL_CountNumberOfCPNodes(cb);
   if (mtx == 'C')
   {
      fprintf(fpd, "static const %s_t ATL_AMM_%s_a%c_b%c[%d] =\n{\n",
              (dir=='F')?"cmat2ablk":"ablk2cmat", (dir=='F')?"BLK2C":"C2BLK",
              calp, cbet, N);
      fprintf(fpp, "static const float ATL_AMM_%sTIME_a%cb%c[%d] = \n{\n",
              (dir=='F')?"C2BLK":"BLK2C", calp, cbet, N);
   }
   else /* A or B */
   {
      char *bn;
      if (dir == 'F')
      {
         if (cbet == 'N')
            bn = (mtx == 'A') ? "AN2BLK" : "BN2BLK";
         else if (cbet == 'C')
            bn = (mtx == 'A') ? "AC2BLK" : "BC2BLK";
         else if (cbet == 'H')
            bn = (mtx == 'A') ? "AH2BLK" : "BH2BLK";
         else
            bn = (mtx == 'A') ? "AT2BLK" : "BT2BLK";
         fprintf(fpd,"static const cm2am_t ATL_AMM_%s_a%c[%d] =\n{\n",
                 bn, calp, N);
      }
      else
      {
         if (cbet == 'N')
            bn = (mtx == 'A') ? "BLK2AN" : "BLK2BN";
         else if (cbet == 'C')
            bn = (mtx == 'A') ? "BLK2AC" : "BLK2BC";
         else if (cbet == 'H')
            bn = (mtx == 'A') ? "BLK2AH" : "BLK2BH";
         else
            bn = (mtx == 'A') ? "BLK2AT" : "BLK2BT";
         if (mtx == 'A')
            bn = (cbet == 'N') ? "BLK2AN" : "BLK2AT";
         else
            bn = (cbet == 'N') ? "BLK2BN" : "BLK2BT";
         fprintf(fpd,"static const am2cm_t ATL_AMM_%s_a%c[%d] =\n{\n",
                 bn, calp, N);
      }
      fprintf(fpp, "static const float ATL_AMM_%stime_a%c[%d] = \n{\n",
              bn, calp, N);
   }
   for (i=0,cp=cb; cp; i++, cp = cp->next)
   {
      fprintf(fpd, "/* IDX=%3d */ %s%c\n", i, cp->rout, cp->next?',':' ');
      fprintf(fpp, "/* IDX=%3d */ %e%c\n", i, cp->mflop[0], cp->next?',':' ');
   }
   fprintf(fpd, "};\n\n");
   fprintf(fpp, "};\n\n");

   fprintf(fpp, "#endif  /* end ifdef guard */\n");
   fprintf(fpd, "#endif  /* end ifdef guard */\n");
   fclose(fpp);
   fclose(fpd);
}

@BEGINSKIP
void GenAllCHeadDir(char pre, char *path, ATL_view_t *vp, ATL_mmnode_t *mb,
                    ATL_cpnode_t *CB)
{
   int tlen, nlen, plen, ia, ib, d;
   char *nam, *tnam;
         /* atlas_<pre><nm>_[Into,From]Cxxxx_aXbX.h */
   char iscls[4]={1, -1, 2, 0};
   char cscls[4]={'1', 'N', 'X', '0'};

   plen = strlen(path) + 1;
   nlen = strlen(vp->nam);
   tlen = plen + 6 + 1 + nlen + 1 + 4 + 13 + 1;
   tnam = malloc(tlen*sizeof(char));
   assert(tnam);
   nam = tnam + plen;

   d = sprintf(tnam, "%s/atlas_%c%s_FromCZZZZ_aXbX.h", path, pre, vp->nam);
   assert(d < tlen);
   for (d=0; d < 2; d++)
   {
      const char dir = d ? 'I' : 'F';
      if (!(vp->flag &(1<<(CPV_C2BLK+d))))
         continue;
      if (d)
      {
         char *sp;
         sp = strstr(tnam, "FromC");
         sp[0] = 'I';
         sp[1] = 'n';
         sp[2] = 't';
         sp[3] = 'o';
      }
      for (ib=0; ib < 4; ib++)
      {
         const char cbet=cscls[ib];

         if (!(vp->flag &(1<<(CPV_BE1C+ib))))
            continue;
         nam[nlen+21] = cbet;
         for (ia=0; ia < 3; ia++)
         {
            ATL_cpnode_t *cb, *cp;
            const char calp=cscls[ia];
            int flag;

            if (!(vp->flag &(1<<(CPV_AL1C+ia))))
               continue;
            nam[nlen+19] = calp;
            flag = CopyEncode(pre, d?'F':'I', 'C', 'N');
            flag = CopyEncodeScal(flag, iscls[ia], iscls[ib]);
            cb = MMGetCopiesFromList(flag, mb, CB);
            for (cp=cb; cp; cp = cp->next)
            {
               if (cp->rout)
                  free(cp->rout);
               cp->rout = GetCopyName(cp,0);
            }
            GenHead(pre, 'C', dir, calp, cbet, vp->nam, tnam, nam, cb);
            KillAllCPNodes(cb);
         }
      }
   }
   free(tnam);
}

void GenAllAHeadDir(char pre, char *path, ATL_view_t *vp, ATL_mmnode_t *mb,
                    ATL_cpnode_t *CB)
{
   int tlen, nlen, plen, ia, it, d;
   const int nta = (pre == 'c' || pre == 'z') ? 4 : 2;
   char *nam, *tnam;
         /* atlas_<pre><nm>_[Into,From]A[T,N]xxxx_aX.h */
   char iscls[3]={1, -1, 2};
   char cscls[3]={'1', 'N', 'X'};
   char ctas[4] = {'N', 'T', 'C', 'H'};

   plen = strlen(path) + 1;
   nlen = strlen(vp->nam);
   tlen = plen + 6 + 1 + nlen + 1 + 4 + 12 + 1;
   tnam = malloc(tlen*sizeof(char));
   assert(tnam);
   nam = tnam + plen;

   d = sprintf(tnam, "%s/atlas_%c%s_FromANZZZZ_aX.h", path, pre, vp->nam);
   assert(d < tlen);
   for (d=0; d < 2; d++)
   {
      const char dir = d ? 'I' : 'F';
      if (!(vp->flag &(1<<(CPV_A2BLK+d))))
         continue;
      if (d)
      {
         char *sp;
         sp = strstr(tnam, "FromA");
         sp[0] = 'I';
         sp[1] = 'n';
         sp[2] = 't';
         sp[3] = 'o';
      }
      for (it=0; it < nta; it++)
      {
         const char cta = ctas[it];

         nam[nlen+13] = cta;
         for (ia=0; ia < 3; ia++)
         {
            ATL_cpnode_t *cb, *cp;
            const char calp=cscls[ia];
            int flag;

            if (!(vp->flag &(1<<(CPV_AL1A+ia))))
               continue;
            nam[nlen+20] = calp;
            flag = CopyEncode(pre, d?'F':'I', 'A', 'N');
            flag = CopyEncodeScal(flag, iscls[ia], 0);
            cb = MMGetCopiesFromList(flag, mb, CB);
            nam[nlen+12] = 'A';
            CopyFixTransByMtx('A', cta, cb);
            GenHead(pre, 'A', dir, calp, cta, vp->nam, tnam, nam, cb);
            KillAllCPNodes(cb);
            cb = MMGetCopiesFromList(flag & ~(1<<(CPF_ABLK)), mb, CB);
            nam[nlen+12] = 'B';
            CopyFixTransByMtx('B', cta, cb);
            GenHead(pre, 'B', dir, calp, cta, vp->nam, tnam, nam, cb);
            KillAllCPNodes(cb);
         }
      }
   }
   free(tnam);
}
@ENDSKIP

int *ReadMasterIdx(char pre, int *N)
{
   FILE *fp;
   int *flags;
   char fn[16]={'r','e','s','/',pre,'m','a','s','t','e','r','.','C','P','I',0};
   unsigned int i, n;

   fp = fopen(fn, "r");
   assert(fp);
   assert(fscanf(fp, "%u", &n) == 1);
   flags = malloc(n*sizeof(int));
   assert(flags);
   for (i=0; i < n; i++)
@skip   {
      assert(fscanf(fp, " %x '%*s' ", flags+i) == 1);
@skip      printf("flag[%u] = %x\n", i, flags[i]);
@skip   }

   *N = n;
   return(flags);
}

void DoMaster(char pre, FILE *fp, ATL_cpnode_t *cb)
{
   ATL_cpnode_t *cp;
   char *sp;
   int N, i;

   assert(cb);
   fprintf(fp, "#include \"atlas_amm.h\"\n/*\n * Prototypes\n */\n");
   PrintProtos(fp, cb);

   sp = CopyFlag2Str(cb->flag);
   fprintf(fp, "/*\n * Index array\n */\n");
   N = ATL_CountNumberOfCPNodes(cb);
   fprintf(fp, "#define ATL_Cpy%s ATL_%c%s\n", sp, pre, sp);
   fprintf(fp, "#ifndef ATL_DECL_\n");
   fprintf(fp, "   #ifndef ATL_MACRO_ONLY_\n");
   fprintf(fp, "      const extern ATL_cparr_t ATL_Cpy%s[%u];\n", sp, N+N);
   fprintf(fp, "   #endif\n");
   fprintf(fp, "#else\nconst ATL_cparr_t ATL_Cpy%s[%u] =\n{", sp, N+N);
   sp = "\n";
   for (i=0,cp=cb; cp; cp = cp->next, i++)
   {
      ATL_cpflt_t mf, *mfp;
      ATL_iptr_t imf=0;

      mf = 1.0 / (cp->mflop[0]*cp->mb*cp->nb);
      mfp = (ATL_cpflt_t*) &imf;
      *mfp = mf;
      fprintf(fp, "%s   (ATL_cparr_t)%s, ", sp, cp->rout);
      if (sizeof(imf) > sizeof(int))
         fprintf(fp, "0x%lxL", imf);
      else
         fprintf(fp, "0x%x", (int)imf);
      fprintf(fp, "/*%u:%.3e*/", i, (float)mf);
      sp = ",\n";
   }
   fprintf(fp, "\n};\n");
   fprintf(fp, "#endif /* end else of ifndef ATL_DECL */\n");
   fprintf(fp, "\n");
}

void GenMasterFiles(char pre, char *path)
{
   int *flags;
   char *fn;
   int i, pL, L, N;

   pL = strlen(path);
   L = pL + 32;

   fn = malloc(pL+32);
   assert(fn);
   flags = ReadMasterIdx(pre, &N);
   for (i=0; i < N; i++)
   {
      char *sp;
      ATL_cpnode_t *cb;
      FILE *fp;
      const int NC = (pre == 'z' || pre == 'c') ? 2 : 1;
      int k, ic;

      sp = CopyFlag2Str(flags[i]);
      k = sprintf(fn, "res/%ccpyPERF_%s.CPS", pre, sp);
      assert(k < L);
      cb = ReadCPFile(fn);
      assert(cb);
      for (ic=0; ic < NC; ic++)
      {
         if (ic)
         {
            ATL_cpnode_t *cp;
            sp = CopyFlag2Str(flags[i]|(1<<CPF_CONJ));
            for (cp=cb; cp; cp = cp->next)
            {
               cp->flag |= 1<<CPF_CONJ;
               ConjCopyName(cp);
            }
         }
         k = sprintf(fn, "%s/atlas_%c%s.h", path, pre, sp);
         assert(k < L);
         fp = fopen(fn, "w");
         assert(fp);
         sp = fn + pL;
         while (*sp == '/')
            sp++;
         while (*sp != '.')
         {
            *sp = toupper(*sp);
            sp++;
         }
         *sp++ = '_';
         *sp++ = 'H';
         *sp = '\0';
         sp = fn + pL + 1;
         fprintf(fp, "#ifndef %s\n", sp);
         fprintf(fp, "   #define %s 1\n\n", sp);
         DoMaster(pre, fp, cb);
         fprintf(fp, "#endif /* end multiple inclusion guard */\n");
         fclose(fp);
      }
      KillAllCPNodes(cb);
   }
   free(fn);
   free(flags);
}

unsigned int MMIdxCount(ATL_mmnode_t *mb, ATL_mmnode_t *want)
/*
 * RETURNS: index (from 1) of want in mb, 0 if not found
 */
{
   ATL_mmnode_t *mp;
   int i;
   for (i=0, mp=mb; mp; mp = mp->next, i++)
      if (MMKernCompsSame(mp, want))
         return(i+1);
   return(0);
}

double FlopCount(ATL_mmnode_t *mp)
{
   double cnt;
   switch(mp->blask)
   {
   case 1:
      cnt = ((1.0*mp->mbB)*mp->nbB)*mp->kbB;
      break;
   default:
      cnt = ((2.0*mp->mbB)*mp->nbB)*mp->kbB;
   }
   return(cnt);
}
void GenViewFile(char pre, char *path, ATL_view_t *vp, ATL_mmnode_t *mb,
                 ATL_mmnode_t *ML)
{
   ATL_mmnode_t *mp, *MB, *maxPerf=NULL;
   FILE *fpout;
   #define NTHRSH 11
   int THRSH[NTHRSH] = {25, 33, 50, 66, 75, 80, 85, 90, 95, 98, 99};
   ATL_mmnode_t *mpT[NTHRSH];
   char *sp, *fn, *VN;
   char *mnms[10] = {"m", "n", "k", "amm", "A2b", "B2b", "b2C", 
                    "b2A", "b2B", "C2b"};
   char *nms[10]={"MB", "NB", "KB", "AMMI",
                "A2BLK", "B2BLK", "BLK2C", "BLK2A", "BLK2B", "C2BLK"};
   int nbits[10], idxT[NTHRSH];
   char **cpnms = nms + 4;
   int *cpidxs[6], *cpnbits=nbits+4;
   double mfMax=0.0;
   int i, d, plen, vlen, len, N, nint, nbit, nkvec, idxMax=0;
   int minMB, minNB, minKB, maxMB, maxNB, maxKB, minKID, maxKID, tbits;
   const unsigned int vflag=vp->flag;
   char upr = pre;
/*
 * Need these because the frontend machine could conceivably have a smaller
 * int type than the machine being compiled for.  Would need to have the
 * tuned machine do the generation to avoid this assertion.  I also assume
 * both machines have same float, but ATLAS typically assumes IEEE storage
 * so this is less risky
 */
   #if (ATL_ISIZE < ATL_FSIZE)
      #error "Integer shorter than float!"
   #endif
   assert(ATL_ISIZE <= sizeof(int));
   assert(mb);
   assert(vp);
   if (pre == 'c')
      upr = 's';
   else if (pre == 'z')
      upr = 'd';
   plen = strlen(path);
   vlen = strlen(vp->nam);
   @beginskip
   VN = malloc(vlen+1);
   assert(VN);
   for (d=0; d < vlen; d++)
      VN[d] = toupper(vp->nam[d]);
   VN[d] = '\0';
   @endskip
   VN = vp->nam;
   len = plen + 8 + 1 + vlen + 8;
   len = (len < 33) ? 33 : len;  /* need room for cpyPERF_<str>.CPS */
   fn = malloc(len*sizeof(char));
   assert(fn);
   d = sprintf(fn, "%s/atlas_%c%s_view.h", path, pre, vp->nam);
   assert(d < len);
   fpout = fopen(fn, "w");
   assert(fpout);
   for (mp=mb, N=nkvec=0; mp; mp = mp->next, N++)
      if (FLAG_IS_SET(mb->flag, MMF_KVEC))
         nkvec++;
@skip   N = ATL_CountNumberOfMMNodes(mb);
   sp = fn + plen + 1;
   for (i=0; sp[i]; i++)
      sp[i] = toupper(sp[i]);
   sp[i-2] = '_';
   sp[i-1] = 'H';
   fprintf(fpout, "#ifndef %s\n   #define %s 1\n\n", sp, sp);

   for (d=0; d < 2; d++)
   {
      unsigned int m;
      for (m=0; m < 3; m++)
      {
         int FIND=0, i, flag;
         i = d+(d<<1) + m; /* i = 3*d+m */
         flag = (pre == 'd' || pre == 's') ? (1<<CPF_REAL) : 0;
         flag |= (pre == 's' || pre == 'c') ? (1<<CPF_SINGLE) : 0;
         if (m == 2) /* C idx */
         {
            int b;
            flag |= 1<<CPF_CBLK;
            flag |= (d) ? (1<<CPF_TOBLK) : 0;
            for (b=0; b < 4; b++)
            {
               if (vflag & 1<<(CPV_BE1C+b))
               {
                  flag |= 1<<CPF_BE1+b;
                  break;
               }
            }
            for (b=0; b < 3; b++)
            {
               if (vflag & 1<<(CPV_AL1C+b))
               {
                  flag |= 1<<CPF_AL1+b;
                  break;
               }
            }
            if (vflag & (1<<CPV_BE1C))
               flag |= 1<<CPF_BE1;
            else if (vflag & (1<<CPV_BENC))
               flag |= 1<<CPF_BEN;
            else if (vflag & (1<<CPV_BEXC))
               flag |= 1<<CPF_BEX;
            if ((vflag&(CPV_ALLBEC)) && (vflag&(CPV_ALLALC)))
            {
               if (!d && (vflag&(1<<CPV_BLK2C)))
                  FIND = 1;
               else if (d && (vflag&(1<<CPV_C2BLK)))
                  FIND = 1;
            }
         }
         else /* A or B */
         {
            int b;

            flag |= (m == 0) ? (1<<CPF_ABLK) : 0;
            flag |= (d) ? 0 : (1<<CPF_TOBLK);
            for (b=0; b < 3; b++)
            {
               if (vflag & 1<<(CPV_AL1A+b))
               {
                  flag |= 1<<(CPF_AL1+b);
                  break;
               }
            }
            if (vflag & CPV_ALLALA)
            {
               if (!d && (vflag&(1<<CPV_A2BLK)))
                  FIND = 1;
               else if (d && (vflag&(1<<CPV_BLK2A)))
                  FIND = 1;
            }
         }
/*
 *       If view uses this mtx,dir setting, allocate an N+1 iarray, with
 *       1st entry being the minimum value found, rest being offset from min.
 */
         if (FIND)
         {
            int min, k;
            ATL_cpnode_t *cb;
            //cpflags[i] = flag;
            sp = CopyFlag2Str(flag);
            k = sprintf(fn, "res/%ccpyPERF_%s.CPS", pre, sp);
            assert(k < len);
            cb = ReadCPFile(fn);
            if (!cb)
            {
               fprintf(stderr, "Missing or empty file '%s'\n", fn);
               assert(cb);
            }
            cpidxs[i] = MMGetCopyIdxsFromList(flag, mb, cb, ML);
            KillAllCPNodes(cb);
            assert(cpidxs[i]);
            assert(cpidxs[i][0] == N);
            min = cpidxs[i][1];
            for (k=1; k < N; k++)
               min = Mmin(min, cpidxs[i][k+1]);
            for (k=1; k <= N; k++)
               cpidxs[i][k] -= min;
            cpidxs[i][0] = min;
            min = cpidxs[i][1];  /* now actually maximum */
            for (k=2; k <= N; k++)
               min = Mmax(min, cpidxs[i][k]);
            cpnbits[i] = ATL_numBitsNeeded(min);
         }
         else
         {
            cpidxs[i] = NULL;
            cpnbits[i] = 0;
         }
      }
   }
   for (tbits=i=0; i < 6; i++)
   {
      fprintf(fpout, "#define ATL_VW%s_MIN_%s      %3u\n", VN, cpnms[i], 
              cpidxs[i] ? cpidxs[i][0] : 0);
      fprintf(fpout, "#define ATL_VW%s_NBIT_%s     %3u\n", VN, 
              cpnms[i], cpnbits[i]);
      tbits += cpnbits[i];
   }
   maxMB = minMB = mb->mbB;
   maxNB = minNB = mb->nbB;
   maxKB = minKB = mb->kbB;
   if (vflag&(1<<CPV_NOMMI))
   {
      MB = NULL;
      maxKID = minKID = 0;
   }
   else
   {
      MB = ReadMMFileWithPath(upr, "res", "FNLK1.sum");
      assert(MB);
      maxKID = minKID = MMIdxCount(MB, mb);
      assert(maxKID);
      maxKID--;
   }
   for (i=0; i < NTHRSH; i++)
      mpT[i] = NULL;
   mfMax = mb->mflop[0];
   idxMax = 0;
   maxPerf = mb;
   for (i=1, mp=mb->next; mp; mp = mp->next, i++)
   {
      int b;
      ATL_mmnode_t p;

      if (mp->mflop[0] > mfMax)
      {
         mfMax = mp->mflop[0];
         idxMax = i;
         maxPerf = mp;
      }
      b = mp->mbB;
      maxMB = Mmax(b, maxMB);
      minMB = Mmin(b, minMB);
      b = mp->nbB;
      maxNB = Mmax(b, maxNB);
      minNB = Mmin(b, minNB);
      b = mp->kbB;
      maxKB = Mmax(b, maxKB);
      minKB = Mmin(b, minKB);
      if (MB)
      {
         b = MMIdxCount(MB, mp);
         assert(b);
         b--;
         maxKID = Mmax(b, maxKID);
         minKID = Mmin(b, minKID);
      }
   }
   nbits[0] = ATL_numBitsNeeded(maxMB-minMB);  /* now set vals to */
   nbits[1] = ATL_numBitsNeeded(maxNB-minNB);  /* number of bits needed */
   nbits[2] = ATL_numBitsNeeded(maxKB-minKB);  /* to store offsets from min */
   nbits[3] = ATL_numBitsNeeded(maxKID-minKID);
   tbits += nbits[0] + nbits[1] + nbits[2] + nbits[3];
   fprintf(fpout, "#define ATL_VW%s_MIN_AMMI  %8u\n", VN, minKID);
   fprintf(fpout, "#define ATL_VW%s_NBIT_AMMI %8u\n", VN, nbits[3]);
   fprintf(fpout, "#define ATL_VW%s_MIN_MB    %8u\n", VN, minMB);
   fprintf(fpout, "#define ATL_VW%s_NBIT_MB   %8u\n", VN, nbits[0]);
   fprintf(fpout, "#define ATL_VW%s_MIN_NB    %8u\n", VN, minNB);
   fprintf(fpout, "#define ATL_VW%s_NBIT_NB   %8u\n", VN, nbits[1]);
   fprintf(fpout, "#define ATL_VW%s_MIN_KB    %8u\n", VN, minKB);
   fprintf(fpout, "#define ATL_VW%s_NBIT_KB   %8u\n", VN, nbits[2]);
   fprintf(fpout, "#define ATL_VW%s_NKVEC     %8u\n", VN, nkvec);
   fprintf(fpout, "\n");
   mp = maxPerf;
   i = idxMax;
   fprintf(fpout, "#define ATL_VW%s_BEST_IDX  %8u\n", VN, idxMax);
   fprintf(fpout, "#define ATL_VW%s_BEST_MB   %8u\n", VN, mp->mbB);
   fprintf(fpout, "#define ATL_VW%s_BEST_NB   %8u\n", VN, mp->nbB);
   fprintf(fpout, "#define ATL_VW%s_BEST_KB   %8u\n", VN, mp->kbB);
   fprintf(fpout, "#define ATL_VW%s_BEST_MU   %8u\n", VN, mp->mu);
   fprintf(fpout, "#define ATL_VW%s_BEST_NU   %8u\n", VN, mp->nu);
   fprintf(fpout, "#define ATL_VW%s_BEST_KU   %8u\n", VN, mp->ku);
   fprintf(fpout, "#define ATL_VW%s_BEST_LCMU %8u\n", VN, 
            ATL_iLCM(ATL_iLCM(mp->mu,mp->nu),mp->ku));
   fprintf(fpout, "#define ATL_VW%s_BEST_LCMN %8u\n", VN, 
           ATL_iLCM(mp->mu,mp->nu));
   fprintf(fpout, "#define ATL_VW%s_BEST_AMMI %8u\n", VN, 
           MMIdxCount(MB?MB:mb, mp));
   fprintf(fpout, "#define ATL_VW%s_BEST_A2BKI %7u\n", VN, 
           cpidxs[0]?cpidxs[0][i+1]+cpidxs[0][0]:0);
   fprintf(fpout, "#define ATL_VW%s_BEST_B2BKI %7u\n", VN, 
           cpidxs[1]?cpidxs[1][i+1]+cpidxs[1][0]:0);
   fprintf(fpout, "#define ATL_VW%s_BEST_BK2CI %7u\n", VN, 
           cpidxs[2]?cpidxs[2][i+1]+cpidxs[2][0]:0);
   fprintf(fpout, "#define ATL_VW%s_BEST_BK2AI %7u\n", VN, 
           cpidxs[3]?cpidxs[3][i+1]+cpidxs[3][0]:0);
   fprintf(fpout, "#define ATL_VW%s_BEST_BK2BI %7u\n", VN, 
           cpidxs[4]?cpidxs[4][i+1]+cpidxs[4][0]:0);
   fprintf(fpout, "#define ATL_VW%s_BEST_C2BKI %7u\n", VN, 
           cpidxs[5]?cpidxs[5][i+1]+cpidxs[5][0]:0);
   fprintf(fpout, "\n");
   for (i=0,mp=mb; mp->next; i++, mp = mp->next);
   fprintf(fpout, "#define ATL_VW%s_LAST_IDX  %8u\n", VN, i);
   fprintf(fpout, "#define ATL_VW%s_LAST_MB   %8u\n", VN, mp->mbB);
   fprintf(fpout, "#define ATL_VW%s_LAST_NB   %8u\n", VN, mp->nbB);
   fprintf(fpout, "#define ATL_VW%s_LAST_KB   %8u\n", VN, mp->kbB);
   fprintf(fpout, "#define ATL_VW%s_LAST_MU   %8u\n", VN, mp->mu);
   fprintf(fpout, "#define ATL_VW%s_LAST_NU   %8u\n", VN, mp->nu);
   fprintf(fpout, "#define ATL_VW%s_LAST_KU   %8u\n", VN, mp->ku);
   fprintf(fpout, "#define ATL_VW%s_LAST_LCMU %8u\n", VN, 
            ATL_iLCM(ATL_iLCM(mp->mu,mp->nu),mp->ku));
   fprintf(fpout, "#define ATL_VW%s_LAST_LCMN %8u\n", VN, 
           ATL_iLCM(mp->mu,mp->nu));
   fprintf(fpout, "#define ATL_VW%s_LAST_AMMI %8u\n", VN, 
           MMIdxCount(MB?MB:mb, mp));
   fprintf(fpout, "#define ATL_VW%s_LAST_A2BKI %7u\n", VN, 
           cpidxs[0]?cpidxs[0][i+1]+cpidxs[0][0]:0);
   fprintf(fpout, "#define ATL_VW%s_LAST_B2BKI %7u\n", VN, 
           cpidxs[1]?cpidxs[1][i+1]+cpidxs[1][0]:0);
   fprintf(fpout, "#define ATL_VW%s_LAST_BK2CI %7u\n", VN, 
           cpidxs[2]?cpidxs[2][i+1]+cpidxs[2][0]:0);
   fprintf(fpout, "#define ATL_VW%s_LAST_BK2AI %7u\n", VN, 
           cpidxs[3]?cpidxs[3][i+1]+cpidxs[3][0]:0);
   fprintf(fpout, "#define ATL_VW%s_LAST_BK2BI %7u\n", VN, 
           cpidxs[4]?cpidxs[4][i+1]+cpidxs[4][0]:0);
   fprintf(fpout, "#define ATL_VW%s_LAST_C2BKI %7u\n", VN, 
           cpidxs[5]?cpidxs[5][i+1]+cpidxs[5][0]:0);
   fprintf(fpout, "\n");

   if (tbits > (ATL_ISIZE<<3))
   {
      for (nbit=nint=i=0; i < 9; i++)
      {
         nbit += nbits[i];
         if (nbit > (ATL_ISIZE<<3))
         {
            nbit = nbits[i];
            nint++;
         }
      }
      if (nbit)
         nint++;
   }
   else
      nint = 1;
   fprintf(fpout, "#define ATL_VW%s_NINT     %u\n", VN, ++nint);
   if (nint == 2)
      fprintf(fpout, "#define ATL_VW%s_IDXMUL(i_) ((i_)+(i_))\n", VN);
   else if (nint == 3)
      fprintf(fpout, "#define ATL_VW%s_IDXMUL(i_) ((i_)+((i_)<<1))\n", VN);
   else if (nint == 4)
      fprintf(fpout, "#define ATL_VW%s_IDXMUL(i_) ((i_)<<2)\n", VN);
   else
      fprintf(fpout, "#define ATL_VW%s_IDXMUL(i_) ((i_)*%u)\n", VN, nint);
   fprintf(fpout, "#define ATL_VW%s_NCASES   %u\n", VN, N);
   fprintf(fpout, "#define ATL_VW%s_MAX_MB   %u\n", VN, maxMB);
   fprintf(fpout, "#define ATL_VW%s_MAX_NB   %u\n", VN, maxNB);
   fprintf(fpout, "#define ATL_VW%s_MAX_KB   %u\n", VN, maxKB);
   fprintf(fpout, "#define ATL_VIEW_%s ATL_%cVIEW_%s\n", VN, pre, VN);

   fprintf(fpout,"\n#ifndef ATL_DECL_\n   const extern unsigned int "
           "ATL_%cVIEW_%s[%u];\n", pre, VN, nint*N);
   fprintf(fpout, "#else\nconst unsigned int ATL_%cVIEW_%s[%u] =\n{", 
           pre, VN, nint*N);
   sp = "\n";
   for (i=0, mp=mb; mp; mp = mp->next, i++)
   {
      int k, iv=0, ammI;
      float *timepflop;
/*
 *    Setup threshhold blocking factors, don't go past max perf kernel
 */
      for (k=0; k < NTHRSH; k++)
      {
         if (!mpT[k] && THRSH[k]*0.01*mfMax < mp->mflop[0])
         {
            if (i < idxMax)
            {
               mpT[k] = mp;
               idxT[k] = i;
            }
            else
            {
               mpT[k] = maxPerf;
               idxT[k] = idxMax;
            }
         }
      }
      timepflop = (float*) &k;
      *timepflop = 1.0 / (mp->mflop[0]*FlopCount(mp));
      if (MB)
      {
         ammI = MMIdxCount(MB, mp);
         assert(ammI);
         ammI--;
      }
      else
         ammI = 0;
      fprintf(fpout, "%s/* %u:SPF=%e B=(%u,%u,%u) ammI=%u",
              sp, i, *timepflop, mp->mbB, mp->nbB, mp->kbB, ammI);
      if (cpidxs[0] || cpidxs[1] || cpidxs[2])
         fprintf(fpout, " [A,B]2b=%u,%u b2C=%u", 
                 cpidxs[0]?cpidxs[0][i+1]+cpidxs[0][0]:0,
                 cpidxs[1]?cpidxs[1][i+1]+cpidxs[1][0]:0,
                 cpidxs[2]?cpidxs[2][i+1]+cpidxs[2][0]:0);
      if (cpidxs[3] || cpidxs[4] || cpidxs[5])
         fprintf(fpout, " b2[A,B]=%u,%u C2b=%u",
                 cpidxs[3]?cpidxs[3][i+1]+cpidxs[3][0]:0,
                 cpidxs[4]?cpidxs[4][i+1]+cpidxs[4][0]:0,
                 cpidxs[5]?cpidxs[5][i+1]+cpidxs[5][0]:0);
     fprintf(fpout, " */\n");
     @beginskip
      fprintf(fpout, "%s/* %u:SPF=%e B=(%u,%u,%u) ammI=%u [A,B]2blkI=%u,%u "
              "blk2CI=%u blk2[A,B]I=%u,%u C2blkI=%u */\n",
              sp, i, *timepflop, mp->mbB, mp->nbB, mp->kbB, ammI,
              cpidxs[0]?cpidxs[0][i+1]:0,cpidxs[1]?cpidxs[1][i+1]:0,
              cpidxs[2]?cpidxs[2][i+1]:0,cpidxs[3]?cpidxs[3][i+1]:0,
              cpidxs[4]?cpidxs[4][i+1]:0,cpidxs[5]?cpidxs[5][i+1]:0);
     @endskip
      fprintf(fpout, "0x%x", k);
//<ammtime><mb><nb><kb><kernI><a2blkI><b2blkI><blk2cI><blk2aI><blk2bI><c2blkI>
      for (nbit=k=0; k < 10; k++)
      {
         const unsigned int nvbits = nbits[k];
         if (nvbits)
         {
            int v;
            switch(k)
            {
            case 0:
               v = mp->mbB - minMB;
               break;
            case 1:
               v = mp->nbB - minNB;
               break;
            case 2:
               v = mp->kbB - minKB;
               break;
            case 3:
               v = ammI - minKID; 
               break;
            default:
               v = cpidxs[k-4] ? cpidxs[k-4][i+1] : 0;
            }
            if (nbit+nvbits > (ATL_ISIZE<<3))
            {
               fprintf(fpout, ",0x%x", iv);
               iv = 0;
               nbit = 0;
            }
            iv |= v << nbit;
            nbit += nvbits;
         }
         sp = ",\n";
      }
      if (nbit != 0)
         fprintf(fpout, ",0x%x", iv);
   }
   KillAllMMNodes(MB);
   for (d=0; d < 6; d++)
      free(cpidxs[d]);
   fprintf(fpout, "\n};\n");
   fprintf(fpout, "#endif /* end else of ifndef ATL_DECL_ */\n\n");

   for (i=1,nbit=d=0; d < 10; d++)
   {
      const unsigned int nvbits = nbits[d];

      if (!nvbits)
         fprintf(fpout, "#define ATL_GetVW%s%s(id_) ATL_VW%s_MIN_%s\n", 
                 VN, nms[d], VN, nms[d]);
      else
      {
         fprintf(fpout,"#define ATL_GetVW%s%s(id_) \\\n   ", VN, nms[d]);
         if (nbit+nvbits > (ATL_ISIZE<<3))
         {
            i++;
            nbit = 0;
         }
         fprintf(fpout, "((((ATL_VIEW_%s[ATL_VW%s_IDXMUL(id_)+%u])>>%u)&0x%x)+"
                 "ATL_VW%s_MIN_%s)\n", VN, VN, i, nbit, (1<<nvbits)-1, 
                 VN, nms[d]);
      }
      nbit += nvbits;
   }
   @BEGINSKIP
   if (nbits[0])
      fprintf(fpout,"#define ATL_GetVW%sMB(id_) \\\n   (((ATL_VIEW_%s[ATL_VW%s_"
              "IDXMUL(id_)+%u])&0x%x)+ATL_VW%s_MIN_MB)\n", VN, VN, VN, 
              1, (1<<nbits[0])-1, VN);
   else
      fprintf(fpout, "#define ATL_GetVW%sMB(id_) ATL_VW%s_MIN_MB\n", VN, VN);
   if (!nbits[1])
      fprintf(fpout, "#define ATL_GetVW%sNB(id_) ATL_VW%s_MIN_NB\n", VN, VN);
   else
   {
      i = nbits[0];
      d = i / (ATL_ISIZE<<3);
      i -= d*(ATL_ISIZE<<3);
      if (i+nbits[1] > (ATL_ISIZE<<3))
      {
         i = 0;
         d++;
      }
      fprintf(fpout,"#define ATL_GetVW%sNB(id_) \\\n   (((ATL_VIEW_%s[ATL_VW%s_"
              "IDXMUL(id_)+%u]>>%u)&0x%x)+ATL_VW%s_MIN_NB)\n", VN, VN, VN, 
              d+1, i, (1<<nbits[1])-1, VN);
   }
   if (!nbits[2])
      fprintf(fpout, "#define ATL_GetVW%sKB(id_) ATL_VW%s_MIN_KB\n", VN, VN);
   else
   {
      i = nbits[0]+nbits[1]; /* amount to shift off */
      d = i / (ATL_ISIZE<<3);
      i -= d*(ATL_ISIZE<<3);
      if (i+nbits[2] > (ATL_ISIZE<<3))
      {
         i = 0;
         d++;
      }
      fprintf(fpout,"#define ATL_GetVW%sKB(id_) \\\n   (((ATL_VIEW_%s[ATL_VW%s_"
              "IDXMUL(id_)+%u]>>%u)&0x%x)+ATL_VW%s_MIN_KB)\n", VN, VN, VN, 
              d+1, i, (1<<nbits[2])-1, VN);
   }
   @ENDSKIP
   fprintf(fpout, "#define ATL_GetVW%sInfo(id_, spf_, m_, n_, k_, amm_, "
           "A2b_, B2b_, b2C_, \\\n"
           "                        b2A_, b2B_, C2b_) \\\n{ \\\n", VN);
   fprintf(fpout,"   const unsigned int *ip_=ATL_VIEW_%s+ATL_VW%s_IDXMUL(id_); \\\n",
           VN, VN);
   fprintf(fpout,"   unsigned int v_=ip_[1]; \\\n");
   fprintf(fpout, "   spf_ = *((float*)ip_); \\\n");
   for (i=1,nbit=d=0; d < 10; d++)
   {
      const unsigned int nvbits = nbits[d];
      if (nbit+nvbits > (ATL_ISIZE<<3))
      {
         fprintf(fpout, "   v_ = ip_[%u]; \\\n", ++i);
         nbit = 0;
      }
      fprintf(fpout, "   %s_ = ATL_VW%s_MIN_%s", mnms[d], VN, nms[d]);
      if (!nvbits)
         fprintf(fpout, "; \\\n");
      else
      {
         fprintf(fpout, " + (v_ & 0x%x); \\\n", (1<<nvbits)-1);
         fprintf(fpout, "   v_ >>= %u; \\\n", nvbits);
      }
      nbit += nvbits;
   }
   fprintf(fpout, "} /* end ATL_GetViewInfo */\n");

   fprintf(fpout, "/*\n * Percent of max perf macros\n */\n");
   for (i=0; i <= NTHRSH; i++)
   {
      const int cnt=(i < NTHRSH) ? THRSH[i]:100;
      mp = (i < NTHRSH) ? mpT[i] : maxPerf;
      fprintf(fpout, "#define ATL_VW%s_%dLCMU %d\n", VN, cnt,
              ATL_iLCM(ATL_iLCM(mp->mu,mp->nu),mp->ku));
      fprintf(fpout, "#define ATL_VW%s_%dLCMMN %d\n", VN, cnt,
              ATL_iLCM(mp->mu,mp->nu));
      fprintf(fpout, "#define ATL_VW%s_%dMB %d\n", VN, cnt, mp->mbB);
      fprintf(fpout, "#define ATL_VW%s_%dNB %d\n", VN, cnt, mp->nbB);
      fprintf(fpout, "#define ATL_VW%s_%dKB %d\n", VN, cnt, mp->kbB);
      fprintf(fpout, "#define ATL_VW%s_%dIDX %d\n",VN, cnt, 
              (i < NTHRSH) ? idxT[i] : idxMax);
   }

   fprintf(fpout, "/*\n * Generic names for first-included view\n */\n");
   fprintf(fpout, "#ifndef ATL_VIEW_TABLE\n");
   fprintf(fpout, "   #define ATL_VIEW_TABLE ATL_VIEW_%s\n", VN);
   fprintf(fpout, "   #define ATL_GetViewInfo ATL_GetVW%sInfo\n", VN);
   @whiledef vm NKVEC MAX_KB MAX_NB MAX_MB IDXMUL NINT NCASES
   fprintf(fpout, "   #define ATL_VIEW_@(vm) ATL_VW%s_@(vm)\n", VN);
   @endwhile
   @whiledef vm A2BLK B2BLK BLK2C BLK2A BLK2B C2BLK AMMI KB NB MB
   fprintf(fpout, "   #define ATL_VIEW_MIN_@(vm) ATL_VW%s_MIN_@(vm)\n", VN);
   fprintf(fpout, "   #define ATL_VIEW_NBIT_@(vm) ATL_VW%s_NBIT_@(vm)\n", VN);
   @endwhile
   fprintf(fpout, "#endif\n /* end generic name redef guard */\n");

   fprintf(fpout, "\n#endif /* end multiple inclusion guard */\n");
   fclose(fpout);
   free(fn);
@skip   free(VN);
//<ammtime><mb><nb><kb><kernI><a2blkI><b2blkI><blk2cI><blk2aI><blk2bI><c2blkI>
}

@beginskip
void GenViews(char pre, char *path, ATL_view_t *vp, ATL_mmnode_t *mb)
{
   const int vflag = vp->flag;
   int plen, vlen, d;
   char *tfn, *fn;

   plen = strlen(path);
   if (path[plen-1] == '/')  /* avoid double / */
      path[--plen] = '\0';
   vlen = strlen(vp->nam);
   tlen = plen + 1 + 6 + vlen + 12 + 3;
   tlen = (tlen > 26) ? tlen : 26;
   tfn = malloc(tlen*sizeof(char));
   assert(tfn);
   for (d=CPV_C2BLK; d <= CPV_BLK2A; d++)
   {
      int flag, ia;
      const int alpb = (d <= CPV_BLK2C) ? CPV_AL1C : CPV_AL1Al

      if (!(vflag & d))     /* if this view doesn't contain */
         continue;          /* this mtx/dir, skip rest */
      if (d==CPV_C2BLK)
         flag = (1<<CPF_TOBLK)|(1<<CPF_CBLK);
      else if (d == CPV_BLK2C)
         flag = (1<<CPF_CBLK);
      else
         flag = (d == CPV_A2BLK) ? (1<<CPF_TOBLK) : 0 ;
      for (ia=0; ia < 3; ia++)
      {
         int nta, it;
         if (!(vflag & (1<<(alpb+ia))))
            continue;
         if (flag&(1<<CPF_CBLK))
            nta = 1;
         else
            nta = (pre == 'c' || pre == 'z') ? 4 : 2;
         flag |= CPF_AL1+ia;
         for (it=0; it < nta; it++)
         {
            const int nb = (flag&(1<<CPF_CBLK)) ? 4 : 1;
            int ib;

            if (!(flag&(1<<CPF_CBLK)))
               flag |= ((it&1)<<CPF_TRANS) | ((it&2)<<(CPF_CONJ-1));
            for (ib=0; ib < nb; ib++)
            {
               ATL_cpnode_t *cmb;
               if (flag&(1<<CPF_CBLK))
               {
                  if (!(vflag & (1<<(CPV_BE1C+ib))))
                     continue;
                  flag |= 1<<(CPF_BE1+ib);
               }
            }
         }
      }
   }
}
@endskip

int main(int nargs, char **args)
{
   ATL_view_t *vb, *vp;
   char *path, *nm;
   char pre, dir, upr;
   ATL_cpnode_t *cb;
   ATL_mmnode_t *ML;

   vb = GetFlags(nargs, args, &pre, &path);
   if (pre == 'c')
      upr = 's';
   else if (pre == 'z')
      upr = 'd';
   else
      upr = pre;
   ML = ReadMMFileWithPath(upr, "res", "FNLK1.sum");
   assert(ML);

   GenMasterFiles(pre, path);
   cb = ReadCPFileWithPath(pre, "res", "cpyPERF.CPS");
   for (vp=vb; vp; vp = vp->next)
   {
      ATL_mmnode_t *mb;
      mb = ReadMMFile(vp->fnam);
      GenViewFile(pre, path, vp, mb, (vp->flag & (1<<CPV_SELFK)) ? NULL : ML);
@skip      GenAllCHeadDir(pre, path, vp, mb, cb);
@skip      GenAllAHeadDir(pre, path, vp, mb, cb);
      KillAllMMNodes(mb);
   }

   KillAllViews(vb);
   KillAllCPNodes(cb);
   KillAllMMNodes(ML);
   free(path);
   return(0);
}
@ROUT cpyfvw
#include "atlas_mmgen.h"
#define uint unsigned int
void GetAllCopy(char pre, ATL_view_t *vb, int minSz)
{
   int d;
   ATL_cpnode_t *cb=NULL, *cbC=NULL, *cp;
   ATL_mmnode_t *ML;
   char upr;

   if (pre == 'c')
      upr = 's';
   else if (pre == 'z')
      upr = 'd';
   else
      upr = pre;
   ML = ReadMMFileWithPath(upr, "res", "FNLK1.sum");
   assert(ML);
   for (d=0; d < 2; d++)  /* 0: M2BLK, 1: BLK2M */
   {
      int a;
      for (a=0; a < 3; a++) /* 0:alp=1, 1:alp=-1, 2:alp=X */
      {
         ATL_view_t *vp;
         for (vp=vb; vp; vp = vp->next) /* scope all input views */
         {
            const int vflg=vp->flag;
            int flg;
            int b;
            ATL_mmnode_t *MLV = (vp->flag & (1<<CPV_SELFK)) ? NULL : ML;

            flg = (d) ? 0 : (1<<CPF_TOBLK);
            flg |= 1<<(CPF_AL1+a);
            if (pre == 'd')
               flg |= (1<<CPF_REAL);
            else if (pre == 's')
               flg |= (1<<CPF_REAL) | (1<<CPF_SINGLE);
            else if (pre == 'c')
               flg |= (1<<CPF_SINGLE);
/*
 *          Add copies A needs from all views (TRANS added later) 
 */
            if ((vflg&(1<<(CPV_A2BLK+d))) && (vflg&(1<<(CPV_AL1A+a))))
            {
               ATL_mmnode_t *mb;
               ATL_cpnode_t *bb;
               mb = ReadMMFile(vp->fnam);
               if (!mb)
               {
                  fprintf(stderr, "NO KERNS FROM VIEW FILE '%s'!\n", vp->fnam);
                  assert(mb);
               }
               bb = GetAllCopyNodesFromMM(flg, mb, MLV);
               if (bb)
               {
                  cp = ATL_LastCPNode(bb);
                  cp->next = cb;
                  cb = bb;
                  bb = GetAllCopyNodesFromMM(flg|(1<<CPF_ABLK), mb, MLV);
                  cp = ATL_LastCPNode(bb);
                  cp->next = cb;
                  cb = bb;
               }
               KillAllMMNodes(mb);
            }

            if (!(vflg&(1<<(CPV_AL1C+a))))
               continue;
            if (!(vflg&(1<<(CPV_C2BLK+d))))
               continue;
            flg |= 1<<CPF_CBLK;
            for (b=0; b < 4; b++) /* 0:beta=1, 1:beta=N, 2:beta=X, 3:beta=0 */
            {
               flg &= ~CPF_ALLBET;
               flg |= 1<<(CPF_BE1+b);
               if (vflg & (1<<(CPV_BE1C+b)))
               {
                  ATL_mmnode_t *mb;
                  ATL_cpnode_t *bb;
                  mb = ReadMMFile(vp->fnam);
                  assert(mb);
                  bb = GetAllCopyNodesFromMM(flg, mb, MLV);
                  if (bb)
                  {
                     cp = ATL_LastCPNode(bb);
                     cp->next = cbC;
                     cbC = bb;
                  }
                  KillAllMMNodes(mb);
               }
            }
         }  /* end search thru views */
      }
   }
/*
 * Having added all copies from views that matched, get rid of dups
 */
   if (cb)
   {
      ATL_cpnode_t *b, *last;
      cb = CopyNoRep(cb, minSz);
      last = b = CloneCPQueue(cb);
      for (cp=b; cp; cp = cp->next)
      {
         cp->flag |= 1<<CPF_TRANS;
         last = cp;
      }
      last->next = cb;
      cb = b;
      @BEGINSKIP
      if (pre == 'z' || pre == 'c')  /* need CONJ dups too! */
      {
         last = b = CloneCPQueue(cb);
         for (cp=b; cp; cp = cp->next)
         {
            cp->flag |= 1<<CPF_CONJ;
            last = cp;
         }
         last->next = cb;
         cb = b;
      }
      @ENDSKIP
   }
   cbC = CopyNoRep(cbC, minSz);
   if (cb)
   {
      cp = ATL_LastCPNode(cb);
      cp->next = cbC;
   }
   else
      cb = cbC;
   for (cp=cb; cp; cp = cp->next)
   {
      if (!cp->ID && cp->rout)  /* generated filenames should be */
      {                         /* regenerated & set to ouput name */
         free(cp->rout);
         cp->rout = NULL;
      }
   }
/*
 * Check if current views same as last time
 */
   cbC = ReadCPFileWithPath(pre, "res", "cpylst.CPS");
   if (cbC)
   {
      int SAME;
      SAME = ATL_CountNumberOfCPNodes(cb) == ATL_CountNumberOfCPNodes(cbC);
      if (SAME)  /* if same # of entries, same list if */
      {          /* every kernel in cbC matches a kernel in cb */
         for (cp=cb; cp; cp = cp->next)
         {
            ATL_cpnode_t *km;
            km = FindEquivCopy(cbC, cp);
            if (km)
            {
               cbC = RemoveCPNodeFromQ(cbC, km);
               KillCPNode(km);
            }
            else
            {
               SAME = 0;
               break;
            }
         }
         if (cbC)
         {
            KillAllCPNodes(cbC);
            SAME = 0;
         }
      }
      if (!SAME)
      {
         char ln[18];
         WriteCPFileWithPath(pre, "res", "cpylst.CPS", cb);
         printf("UPDATED: res/%ccpylst.CPS!\n\n", pre);
         strcpy(ln, "res/XcpyPERF.CPS");
         ln[4] = pre;
         remove(ln);
      }
      else
         printf("UNCHANGED: res/%ccpylst.CPS!\n\n", pre);
      KillAllCPNodes(cbC);
   }
   else
   {
      WriteCPFileWithPath(pre, "res", "cpylst.CPS", cb);
      printf("CREATED NEW res/%ccpylst.CPS!\n\n", pre);
   }
   KillAllCPNodes(cb);
   KillAllMMNodes(ML);
}

void PrintUsage(char *name, int ierr, char *flag)
{
   if (ierr > 0)
      fprintf(stderr, "Bad argument #%d: '%s'\n", ierr,
              flag?flag:"OUT-OF_ARGUMENTS");
   else if (ierr < 0)
      fprintf(stderr, "ERROR: %s\n", flag);

   fprintf(stderr, 
"This routine takes a list of views, and finds the minimal list of copy\n"
"routines needed to provide copy for all kernels, output in Xcpylist.CPS\n"
"which can then be read by xcpysearch for tuning\n\n");

   fprintf(stderr,"USAGE: %s [flags:\n", name);
   fprintf(stderr,"   -p [d,s,c,z]\n");
   fprintf(stderr,"   -z <minsz>: (24*24) demand mb*nb>minsz\n");
   fprintf(stderr,
   "   -V [C,A]a=1,N,X Cb=0,1,N,X [A,C]d=I,F S=A,C,M,U <name> mmview.sum:\n");
   fprintf(stderr,
"      If args to left of = are omitted, these vals don't appear in the view.\n"
"      Args to right of = may be omitted, which means all values are set.\n"
"      <name> and <mmview> must appear in that order.\n"
"      A/Cd=[I,F]: copy Into or From col-major (I,F means both directions).\n"
"      A/Ca/b give the list of needed alpha/beta for that matrix copy.\n"
"      S=A,C,M,U: don't store [A,C] copyI, matmulI, or unrollings, resp.\n"
"      Suppressed copies will still be added to master list, just not in view\n"
"      <name> is a unique string that will be used in all header files.\n"
"      mmview.sum: list of amm kerns demanding the copies.\n");
   exit(ierr ? ierr : -1);
}

ATL_view_t *GetFlags(int nargs, char **args, char *PRE, int *MINSZ)
{
   ATL_view_t *vb=NULL, *vp;
   int i, minSz=24*24;
   char pre='d';

   for (i=1; i < nargs; i++)
   {
      char *nam;
      int k, flag;
      if (args[i][0] != '-')
         PrintUsage(args[0], i, args[i]);

      switch(args[i][1])
      {
      case 'p':
         if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
         pre = tolower(args[i][0]);
         assert(pre == 's' || pre == 'd' || pre == 'z' || pre == 'c');
         break;
      case 'z':
         if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
         minSz = atoi(args[i]);
         break;
      @extract -b @(basd)/atlas-mmcpy.base rout=readview
      default:
         PrintUsage(args[0], i, args[i]);
      }
   }
   assert(vb);
   *PRE = pre;
   *MINSZ = minSz;
   return(vb);
}

int main(int nargs, char **args)
{
   ATL_view_t *vb;
   int minSz;
   char pre;

   vb = GetFlags(nargs, args, &pre, &minSz);
   GetAllCopy(pre, vb, minSz);
   KillAllViews(vb);
   return(0);
}
@ROUT cpydrv
#include "atlas_mmgen.h"
#define uint unsigned int

ATL_cpnode_t **SplitList(char pre, ATL_cpnode_t *cb, int *NLIST, uint **FLAGS)
/*
 * Splits cb according to GetCopyMatches, returns number of non-NULL lists
 * in *NLIST, and the non-NULL flag values in FLGS.
 * RETURNS: *NLIST-length array of lists
 */
{
@skip   char fn[32]={'c','p','y','P','E','R','F','_'};
@skip   char *sp;
   int ik; /* loop over kernels, which can be incoherent */
   int nlist=0, nalloc;
   int *flags;
   ATL_cpnode_t **lists;

   nalloc = 8;
   lists = malloc(nalloc*sizeof(ATL_cpnode_t *));
   flags = malloc(nalloc*sizeof(int));
   assert(lists && flags);

   CopyApplyBlasRules(cb);
   for (ik=CPF_SYRK-1; ik <= CPF_TRSM; ik++)
   {
      int ic; /* CBLK unset or set */
      for (ic=0; ic < 2; ic++)
      {
         const int B0=(ic)?CPF_BE1:0, BN=(ic)?CPF_BE0:1;
         int id; /* TOBLK unset or set */
         for (id=0; id < 2; id++)
         {
            int ia;
            for (ia=CPF_AL1; ia <= CPF_ALX; ia++)
            {
               int ib;

               for (ib=B0; ib <= BN; ib++)
               {
                  const int HN = (ic || pre == 'd' || pre == 's') ? 0 : 1;
                  int ih;
                  for (ih=0; ih <= HN; ih++)
                  {
                     ATL_cpnode_t *bp;
                     int flag;
                     flag = (id<<CPF_TOBLK)|(ic<<CPF_CBLK)|(1<<ia);
                     flag |= (ik >= CPF_SYRK) ? (1<<ik) : 0;
                     if (ic)
                        flag |= 1<<ib;
                     else
                        flag |= (ib<<CPF_TRANS)|(ih<<CPF_CONJ);
                     bp = GetCopyMatches(cb, flag);
                     if (bp)
                     {
                        if (nlist == nalloc)
                        {
                           nalloc = nlist + 4;
                           lists = realloc(lists,nalloc*sizeof(ATL_cpnode_t *));
                           flags = realloc(flags,nalloc*sizeof(int));
                        }
                        lists[nlist] = bp;
                        flags[nlist++] = flag;
                     }
                  }
               }
            }
         }
      }
   }
   *NLIST = nlist;
   *FLAGS = flags;
   return(lists);
}

unsigned int CountRegion(int N, ATL_cpnode_t **cbs)
{
   const uint mask=(CPF_ALLKERN|(1<<CPF_CBLK)|(1<<CPF_TOBLK)), 
              flag=(cbs[0]->flag)&mask;
   uint i;

   for (i=1; i < N; i++)
      if (flag != ((cbs[i]->flag)&mask))
         return(i);
   return(N);
}

uint *CountMoveShared(const uint N,  ATL_cpnode_t **cbs)
{
   uint *cnts;
   ATL_cpnode_t *cp=cbs[0];
   uint i, ioff, nxtoff;

   cnts = malloc(N*sizeof(uint));
   assert(cnts);
   ioff = GetOffset(&cp->flag, cp);
   nxtoff = GetOffset(&cp->next, cp);
   for (i=0; i < N; i++)
   {
      uint j;
/*
 *    Mark all files duplicated between i and remaining lists
 */
      for (j=i+1; j < N; j++)
         CopyMarkDup_cohere(cbs[i], cbs[j]);
/*
 *    Move all duplicated entries to beginning of list
 */
      cbs[i] = CopySortMarkedFirst(cbs[i]);
      cnts[i] = CountListMaskALL(cbs[i], (1<<CPF_TMP), nxtoff, ioff);
   }
   return(cnts);
}

void SortByCount(uint N, uint *nshar,  ATL_cpnode_t **cbs, uint *flgs)
{
   uint i;
   for (i=0; i < N-1; i++)
   {
      uint imin=i, min=nshar[i], j;
      for (j=i+1; j < N; j++)
      {
         if (nshar[j] < min)
         {
            imin = j;
            min = nshar[j];
         }
      }
      if (imin != i)
      {
         void *vp = cbs[i];
         j = imin;
         cbs[i] = cbs[j];
         cbs[j] = vp;
         nshar[j] = nshar[i];
         nshar[i] = min;
         min = flgs[i];
         flgs[i] = flgs[j];
         flgs[j] = min;
      }
   }
}

void DictateOrders(const uint N, ATL_cpnode_t **cbs)
{
   uint i;
   for (i=0; i < N-1; i++)
   {
      uint j;
      for (j=i+1; j < N; j++)
         cbs[j] = CopyDictateOrder(cbs[i], cbs[j]);
   }
}

void CohereLists(const uint N, ATL_cpnode_t **cbs, uint *flgs)
/*
 * cbs already sorted in precedence: kernel, mtx (C/A), dir.
 * The indices of a given kernel must match in all kern,mtx,dir lists, despite
 * the fact that views may make it so these lists contain different numbers
 * and types of cp funcs.  The idea that shared funcs between kern,mtx,dir lists
 * share the same index regardless of file length means that the lists COHERE.
 *
 * Therefore, to make the files within a given region cohere, we figure out
 * how many files are in the region, and then within this region we sort
 * the lists from least number of shared files to most.
 * Each list is sorted so all shared files come first, and then the files
 * with least number of shared kernels dictate where all longer lists locate
 * their corresponding files.
 */
{
   int n, i=0;
   do
   {
      unsigned int *nshar;

      n = CountRegion(N-i, cbs);
      nshar = CountMoveShared(n, cbs);
      SortByCount(n, nshar, cbs, flgs);
      free(nshar);
      DictateOrders(n, cbs);

      cbs += n;
      flgs += n;
      i += n;
   }
   while (i < N);
}
void CreateMasterIdx(char pre)
{
   ATL_cpnode_t *cb, **cbs, *cp;
   FILE *fp;
   unsigned int *flgs;
   unsigned int N, i;
   const unsigned int msk=~((1<<CPF_MVEC)|(1<<CPF_NVEC)|(1<<CPF_ASM)|
      (1<<CPF_TMP));
   char fn[32]={'r','e','s','/',pre,'m','a','s','t','e','r','.','C','P','I',0};

   cb = ReadCPFileWithPath(pre, "res", "cpyPERF.CPS");
   assert(cb);
   for (cp=cb; cp; cp = cp->next)
   {
      if (cp->rout)
         free(cp->rout);
      cp->rout = GetCopyName(cp, 0);
   }
   cbs = SplitList(pre, cb, &N, &flgs);
   KillAllCPNodes(cb);
   CohereLists(N, cbs, flgs);
/*
 * Write out master list of used copy kernels
 */
   fp = fopen(fn, "w");
   assert(fp);
   fprintf(fp, "%u\n", N);
   for (i=0; i < N; i++)
   {
      char *sp;
      unsigned int flag;
      cb = cbs[i];
      flag = cb->flag & msk;
      sp = CopyFlag2Str(flag);
      fprintf(fp, "%x '%s'\n", flag, sp);
      sprintf(fn+5, "cpyPERF_%s.CPS", sp);
      WriteCPFile(fn, cb);
   }
   fclose(fp);

   for (i=0; i < N; i++)
      KillAllCPNodes(cbs[i]);
   free(cbs);
   free(flgs);
}

void PrintUsage(char *name, int ierr, char *flag)
{
   fprintf(stderr, 
"This program is a driver for searching & generating all copy kernels.\n"
"Output file of cumulative views: res/<pre>full.CPS, used for xcpygen.\n"
"Delete this file if you get kerns you don't need in a prior search.\n"
"You can either invoke this driver routine multiple times, or repeat\n"
"the -V flag.\n");

   if (ierr > 0)
      fprintf(stderr, "Bad argument #%d: '%s'\n", ierr,
              flag?flag:"OUT-OF_ARGUMENTS");
   else if (ierr < 0)
      fprintf(stderr, "ERROR: %s\n", flag);

   fprintf(stderr,"USAGE: %s [flags:\n", name);
   fprintf(stderr,"   -p [d,s,c,z]\n");
   fprintf(stderr, "   -o /path : specify directory to generate into\n");
   @extract -b @(basd)/atlas-mmcpy.base rout=printview
   @BEGINSKIP
   fprintf(stderr,
   "   -V [C,A]a=1,N,X Cb=0,1,N,X [A,C]d=I,F <name> mmview.sum:\n");
   fprintf(stderr, 
"      Any of the = args may be ommitted, which means all values are set.\n"
"      <name> and <mmview> must appear in that order.\n"
"      A/Cd=[I,F]: copy Into or From col-major (I,F means both directions).\n"
"      A/Ca/b give the list of needed alpha/beta for that matrix copy.\n"
"      <name> is a unique string that will be used in all header files.\n"
"      mmview.sum: list of amm kerns demanding the copies.\n");
   @ENDSKIP
   exit(ierr ? ierr : -1);
}

ATL_view_t *GetFlags
   (int nargs, char **args, char *PRE, char **PTH)
{
   ATL_view_t *vb=NULL, *vp;
   char *pth=NULL;
   int i, minSz=24*24;
   char pre='d';

   for (i=1; i < nargs; i++)
   {
      char *nam;
      int k, flag;
      if (args[i][0] != '-')
         PrintUsage(args[0], i, args[i]);

      switch(args[i][1])
      {
      case 'p':
         if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
         pre = tolower(args[i][0]);
         assert(pre == 's' || pre == 'd' || pre == 'z' || pre == 'c');
         break;
      case 'o':
         if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
         pth = DupString(args[i]);
         break;
      @extract -b @(basd)/atlas-mmcpy.base rout=readview
      default:
         PrintUsage(args[0], i, args[i]);
      }
   }
   assert(vb);
   if (!pth)
      pth = DupString("tmp");
   *PTH = pth;
   *PRE = pre;
   return(vb);
}

@BEGINSKIP
void DoSearch(char pre)
{
   char *ln;
   ln = DupString("./xcpysearch -i res/Xcpylst.CPS -o res/XcpyPERF.CPS");
   ln[20] = ln[39] = pre;
   assert(!Sys2File(ln, "stdout"));
   free(ln);
}
@ENDSKIP

void DoGen(char pre, char *path)
{
   char *ln;
   ln = NewMergedString("./xcpygen -i res/XcpyPERF.CPS -o ", path);
   ln[17] = pre;
   assert(!Sys2File(ln, NULL));
   free(ln);
}

void DoGenH(char pre, char *path, ATL_view_t *vb)
{
   ATL_view_t *vp;
   int plen;

   plen=strlen(path);
   for (vp=vb; vp; vp = vp->next)
   {
      char *ln, *sp, *va;
      int len, d;

      va = View2Args(vp);
      len = 20 + strlen(va) + plen;
      ln = malloc(len*sizeof(char));
      assert(ln);
      d = sprintf(ln, "./xcphgen -p %c %s -o %s", pre, va, path);
      assert(d < len);
      assert(!Sys2File(ln, NULL));
      free(va);
      free(ln);
   }
}

/*
 * xcpydrv -Vs -o cpylst.CPS | xcpysearch -o cpyPERF.CPS | xcpygen/xcphgen
 */
int main(int nargs, char **args)
{
   ATL_view_t *vb=NULL, *vp;  /* view base & ptr */
   ATL_cpnode_t *cb=NULL, *op;   /* cpsearch output files */
   char *path, *ln;
   char pre;

   vb = GetFlags(nargs, args, &pre, &path);
@skip   cb = GetAllCopy(pre, vb, inSz);
@skip   KillAllCPNodes(cb);
@skip   DoSearch(pre);
   CreateMasterIdx(pre);
   DoGen(pre, path);
   DoGenH(pre, path, vb);
   KillAllViews(vb);
   free(path);
   return(0);
}
