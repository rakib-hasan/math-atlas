@ROUT storage.idx scopy.idx dcopy.idx ccopy.idx zcopy.idx
#
# In this file, any line beginning with a '#' is ignored, but the # must be in
# column 0.  All multiple whitespace is reduced to one space (i.e. used only
# to distinguish where words begin/end).  Lines may be extended by putting '\'
# as the *last* character of line.
#
@ROUT storage.idx
# This file indexes the user-supplied storage schemes, and has the following
# format:
# The file has the following format (default values in []):
# ID=<id> FLAG=<bitfield> BLKSZF='iexp' EXTELTF='iexp'
# ID must be a unique >100 number identifying the storage scheme.  A copy
#    routine with a matching STGID must be found for both copy directions
#    in the appropriate [s,c,d,z]blkcpy.idx types.  The storage IDs that
#    are so far in use by ATLAS itself (<100) are:
#      0: access major storage as used in generator, details in struct
#      1: access major (unvectorized or m-vec) storage for A or B
#      2: access major (unvectorized or m-vec) storage for C
#      3: K-vectorized access major storage for A or B
#      4: K-vectorized access major storage for C
#      5: block major (ATLAS 3.10 or older code gen support)
# 'iexp': must contain in '' a valid ANSI C integer expression which computes
#         the indicated storage using only constants and the key-specific
#         variables.
# BLKSZF [((M+mu-1)/mu)*((N+nu-1)/nu)*mu*nu]
#        must contain in '' a valid ANSI C integer expression which computes
#        iexp computes the number of elements to store one block using this
#        storage pattern.  ATLAS assumes real & imag components stored 
#        separately, so complex size should be half of total size.
#        The only variables that can be used will be chosen by the search after
#        tuning and passed to a function with the following prototype:
#           int getsz(int M, int N, int mu, int nu, int vlen);
#        to allow ATLAS to allocate storage for an individual block. j
#        The expression may use the following variables, in addition
#        to any constants (these args themselved might be constants for some
#        storage formats):
#          M : number of rows chosen for block factor
#          N : number of cols chosen for block factor
#         mu : unroll&jam chosen for M dim
#         nu : unroll&jam chosen for N dim
#       vlen : length of vectorization employed
# EXTELTF: [4*mu*nu]
#          how many elements must be allocated past the end of allocated
#          block memory so that advanced loads don't seg fault.  This number
#          should be small.  The generated size function will have prototype:
#            int getsz(int mu, int nu, int vlen);
#
@ROUT scopy.idx dcopy.idx ccopy.idx zcopy.idx
# This file indexes the user-supplied copy routines for the storage schemes
# indexed in storage.ids, and has the following format (non-mandatory
# keys show the default in []):
# ID=<id> STGID=<stgid> TOBLK=[0,1] TRANS=[0,1] CONJ=[0,1] MU=<mu> NU=<nu> \
#         VLEN=<vlen> ROUT='rt' AUTH='name' COMP='gcc' CFLAGS='flags'
# ID: Mandatory.  Unique (in this file only) int >= 0.  
# STGID: Mandatory.  Number >0 matching and ID in storage.idx.  Predefined:
#    1: access major (unvectorized or m-vec) storage for A or B
#    2: access major (unvectorized or m-vec) storage for C
#    3: K-vectorized access major storage for A or B
#    4: K-vectorized access major storage for C
#    5 : KB-major for A or B
#    6 : MB-major for C
#    7 : uses original col-major C directly (like ATLAS 3.10 kernel)
# TOBLK: Mandatory. 
#         0: copies from STGID block storage to column-major
#         1: copies from column-major to STGID block storage
# MU/NU: [0] unrolling along rows/cols
# TRANS: [n] Needed only for A/B storage, indicates transpose being done:
#    N: cols of matrix stored contiguously, rows strided (col-major)
#    T: rows of matrix stored contiguously, cols strided (row-major)
#
# NOTE: for a storage format to be used by ATLAS, enough copy funcs must
#       be supplied for use, and the number required varies by whether the
#       format is for GEMM's A/B or C matrix:
#       A&B: TOBLK=1 and for real TRANS=N&T, cplx TRANS=N&T&C&H
#            TOBLK=0 must be present for testing & custom uses.
#       C  : TOBLK=0 required. TOBLK=1 needed for testing & custom uses.
#
@ROUT cptst.c
/* 
 * This is a sanity check that takes a known-good copy implementation in
 * CPK_GOOD, and one to test in CPK_TEST.  It then applies these routines
 * on duplicate matrices, and looks for errors greater than expected due to
 * fp arithmetic.  This version specialized for col-major to blk copies.
 */
void cpyblksN(const int mb, const int nb, const size_t M, const size_t N, 
              SCALAR alpha, TYPE *A, size_t lda, TYPE *B, size_ldb, TYPE *wrk)
/*
 * B <-- alpha*A; A&B both MxN, copy by blocks
 */
{
   const size_t nmblks=M/mb, Mb=nmblks*mb, mr=M-Mb;
   const size_t nnblks=N/nb, Nb=nnblks*nb, nr=N-Nb;
   size_t i, j;
   const int NB=nb SHIFT;
   #ifdef TCPLX
      TYPE ralpha[2];
   #else
      TYPE ralpha = ATL_rone / alpha;
   #endif
   #ifdef TCPLX
      Mjoin(PATL,cplxinvert)(1, alpha, 1, ralpha, 1);
   #endif

   for (j=0; j < Nb; j += nb, A += lda*NB, B += ldb*NB)
   {
      for (i=0; i < Mb; i += mb)
      {
         mycpyN(mb, nb, alpha, A+(i SHIFT), lda, wrk);
         myrcpyN(mb, nb, ralpha, B+(i SHIFT), ldb, wrk);
      }
   }
}
int cntErr(int verb, int M, int N, TYPE *A, size_t lda, TYPE *E, size_t lde, 
           TYPE tol)
{
   int j, nerr=0;
   for (j=0; j < N; j++, A += lda SHIFT, E += lde SHIFT)
   {
      for (i=0; i < M; i++)
      {
         diff = A[i] - E[i];
         if (diff > tol)
         {
            
         }
      }
   }
}
int main(int nargs, char **args)
{
   int mb=28, nb=36, lda, m=27, n=33, N=nb+4;
   int lda=mb+55;
   size_t szA, szW, csz, lda=mb+55, lda2, i;
   #ifdef TCPLX
      TYPE alpha[2]={ATL_rone, ATL_rzero}, beta[2]={ATL_rone, ATL_rzero};
   #else
      TYPE alpha=ATL_rone, beta=ATL_rone;
   #endif
   TYPE *A, *G, *T;
   char *cp;

   lda2 = lda SHIFT:
   sz = N*lda2;
   A = malloc(sz*sizeof(TYPE))
   assert(A);
   for (i=0; i < sz; i++)
      A[i] = i;
   szW = mb * nb;
   csz = 2*(szW SHIFT)*sizeof(TYPE) + 3*ATL_Cachelen;
   cp = malloc(2*csz);
   assert(cp);
   cp = (char*)w;
   for (i=0; i < 2*csz; i++)
      cp[i] = 0xFF;
   T = ATL_AlignPtr(cp) + ATL_Cachelen;
   G = (TYPE*) (((char)T) + csz);

}
@ROUT cpysearch
#include "atlas_cpparse.h"
#include "atlas_mmtesttime.h"
#include "atlas_mmgen.h"

int main(int nargs, char **args)
/*
 * For now read geAMMRES.sum, later add rkAMMRES.sum & SYRK.
 * Will use this info to find unique lists of AB & C copiers.
 * -> Later must extend for A & B using possibly different copiers.
 * It then finds the fastest working copy routine for each case, 
 * trying each of following:
 * (1) Codes generated from atlas-mmkg.base (all standard formats)
 * (2) atlas-mmg.base (vector ops, but only mu%vlen Cblk formats)
 * (3) User-contributed cases
 * It creates as output cpAMMRES.sum, which is a list of all required
 * copy kernels.
 */
{
   char pre='d';
   ATL_cpnode_t *cb, *cp;
   ATL_mmnode_t *mb, *mp;
   cb = ReadCPFileWithPath(pre, "./", "copy.idx");
   if (!cb)
   {
      printf("NO USER-SUPPLIED COPY ROUTINES!\n");
      return(0);
   }
   mb = ReadMMFileWithPath(pre, "res", "geAMMRES.sum");
   assert(mb);

   KillAllMMNodes(mb);
   KillAllCPNodes(cb);
   return(0);
}
