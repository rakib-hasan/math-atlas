@ROUT !
   @define pre @@(@pre)@
   @PRE S C
      @define typ @float@
      @define sz @4@
   @PRE D Z
      @define sz @8@
      @define typ @double@
   @PRE !
#define ATL_VLEN @(vl)
#if !defined(SREAL) && !defined(DREAL) && !defined(SCPLX) && !defined(DCPLX)
   @PRE C `   #define SCPLX 1`
   @PRE S `   #define SREAL 1`
   @PRE D `   #define DREAL 1`
   @PRE Z `   #define DCPLX 1`
#endif
@ifdef ! TRI
   @iexp TRI 0
@endifdef
@SKIP TRI = 1 means lower triangular C (SYRK)
@iif TRI = 1
   @iif mu ! nu
      @abort "mu (@(mu)) must equal nu (@(nu))!"
   @endiif
@endiif
@ROUT amm
@beginskip
Should be called with VEC=[NO,MDIM,KDIM], TYPE=[SREAL,DREAL] and 
following defines:
   mu : m (scalar) unrolling
   nu : n (scalar) unrolling
   ku : k (scalar) unrolling
   vl : vector length to use
The following can be optionally defined:
   kb : compile-time constant K loop bound to use
   kp : # of kits to peel, must be a multiple of vku!
   bc : don't define or set to 1 to use ATL_vbcast, 0 to use vld/vsplat
   pf : bit vec describing prefetch strategy
   pfLS : line size to assume for prefetch (64 bytes by default)
   bc : now used a bitvector, default 1, with following meanings:
    BPOS: SET MEANING
      0 : use bcast (else use splat) for B load (ignored for K-vec)
      1 : use only 1 register for B loads (ignored if using splat)
      2 : nnu=1 (else need N-loop)
      3 : nmu=1 (else need M-loop)

pf bit location meanings:
   prefC always done as just next mu*nu block
   pfA/B : can prefetch next mu/nu A/B within K-loop
   nA/nB : can prefetch next block outside K-loop 
   take pf integer bitvec bit/additive means:
      0/1   : prefetch C before K-loop
      1/2   : prefetch next block of A before K-loop
      2/4   : prefetch next block of B before K-loop
      3/8   : prefetch next mu*K iter of A inside K-loop
      4/16  : prefetch next nu*K iter of B inside K-loop
      5/32  : pref of C should use ATL_pfl1 instead of ATL_pfl2
      6/64  : pref of next blk of A should use ATL_pfl1 not ATL_pfl2
      7/128 : pref of next blk of B should use ATL_pfl1 not ATL_pfl2
      8/256 : pref of C should use ATL_pflX instead of ATL_pflX
      9/512 : pref of next blk of A should use ATL_pflX not ATL_pfl2
     10/1024: pref of next blk of B should use ATL_pflX not ATL_pfl2
     11/2048: K-loop pref of A use ATL_pfl1 not ATL_pfl2
     12/4096: K-loop pref of B use ATL_pfl1 not ATL_pfl2
     13/8192: K-loop pref of A use ATL_pflX not ATL_pfl2
    14/16384: K-loop pref of B use ATL_pflX not ATL_pfl2

   We'll put pf bitvec in rout name, and then the search will find that
   we want to pref everything to L1 for small NB, only C &  block of A for
   medium size, and no pref for large, for instance.

During tuning, think about several regions for prefetch:
1. pref pfnA&B to L1:  m*n + 2*k*(m+n) < L1
   -> n^2 + 4n^2 < L2 ==> nb <= sqrt(L1/5)
2. pref B to L1, A to L2: m*n + 2*k*n + m*k < L1
   -> n^2 + 2n^2 + n^2 < L1 ==> nb <= sqrt(L1/4)
3. pref A&B to L2 so long as all 5 blocks fit (L2 size not known)
4. pref only one of nA/B to L2
5. No prefetch of next blocks (maybe internal prefetch)
@endskip
@SKIP extract info from bc, then set it to bcast value
@ifdef ! bc
   @iexp bc 1
@endifdef
@skip if ((bc&1) == 0 && (bc&2) == 2) bc ^= 2
@iif @iexp @(bc) 1 & 0 = @(bc) 2 & 2 = &
   @iexp bc @(bc) 2 ^
@endiif
@iexp B1R @(bc) 2 & 0 !
@iexp DONLOOP @(bc) 4 & 0 =
@iexp DOMLOOP @(bc) 8 & 0 =
@iexp bc @(bc) 1 &
@print bc=@(bc) B1R=@(B1R) DO_N,M=@(DONLOOP),@(DONLOOP)
@SKIP KVEC & UNVEC can't use splat, so define bcast!
@VEC KDIM NO
@ifdef bc
   @undef bc
@endifdef
@iexp bc 0 1 +
@VEC MDIM
@ifdef ! bc
   @iexp bc 0 1 +
@endifdef
@VEC !
@ifdef ! pf
   @define pf @1@
@endifdef
@ifdef ! pfLS
   @define pfLS @64@
@endifdef
@iif pfLS = 0
   @define pfLS @64@
@endiif
@iexp pfLS @(sz) @(pfLS) /
@iexp kk @(pf) 32 &
@iif kk ! 0
   @define pfC @ATL_pfl1W@
@endiif
@iexp kk @(pf) 256 &
@iif kk ! 0
   @define pfC @ATL_pflXW@
@endiif
@ifdef ! pfC
   @define pfC @ATL_pfl2W@
@endifdef
@iexp kk @(pf) 64 &
@iif kk ! 0
   @define pfA @ATL_pfl1R@
@endiif
@iexp kk @(pf) 512 &
@iif kk ! 0
   @define pfA @ATL_pflXR@
@endiif
@ifdef ! pfA
   @define pfA @ATL_pfl2R@
@endifdef
@iexp kk @(pf) 128 &
@iif kk ! 0
   @define pfB @ATL_pfl1R@
@endiif
@iexp kk @(pf) 1024 &
@iif kk ! 0
   @define pfB @ATL_pflXR@
@endiif
@ifdef ! pfB
   @define pfB @ATL_pfl2R@
@endifdef
@iexp kk @(pf) 8 &
@iif kk ! 0
   @define pfAk @ATL_pfl2R@
   @iexp kk @(pf) 2048 &
   @iif kk ! 0
      @undef pfAk
      @define pfAk @ATL_pfl1R@
   @endiif
   @iexp kk @(pf) 8192 &
   @iif kk ! 0
      @undef pfAk
      @define pfAk @ATL_pflXR@
   @endiif
@endiif
@iexp kk @(pf) 16 &
@iif kk ! 0
   @define pfBk @ATL_pfl2R@
   @iexp kk @(pf) 4096 &
   @iif kk ! 0
      @undef pfBk
      @define pfBk @ATL_pfl1R@
   @endiif
   @iexp kk @(pf) 16384 &
   @iif kk ! 0
      @undef pfBk
      @define pfBk @ATL_pflXR@
   @endiif
@endiif
@SKIP npfC = (pf&1) * ((mu*nu + pfLS -1) / pfLS)
@iexp npfC 1 @(pf) & @(pfLS) @(nu) @(mu) * @(pfLS) + -1 + / *
@iexp npfA @(pfLS) 1 @(pf) r 1 & @(mu) @(nu) * * /
@iexp npfB @(pfLS) 2 @(pf) r 1 & @(mu) @(nu) * * /
@iexp npf @(npfC) @(npfA) +
@iif npfA ! 0
   @iexp npfA @(npfA) @(npfC) +
@endiif
@iif npfB ! 0
   @iexp npf @(npf) @(npfB) +
   @iexp npfB @(npf) 0 +
@endiif
@skip bc = (bc != 0 || (vl < 2) || nu%vl != 0);
@iexp bc 0 @(bc) ! 2 @(vl) < | @(vl) @(nu) % 0 ! |
@iif TRI = 1
   @VEC KDIM
      @iif ku ! vl
         @abort "ku (@(ku)) must equal vlen (@(vl))!"
      @endiif
   @VEC JJJJJ
      @iif ku ! 1
         @abort "ku must be 1, but it is @(ku)!"
      @endiif
   @VEC !
@endiif
#ifndef TYPE
   #define TYPE @(typ)
#endif
#include "atlas_simd.h"
@iexp pf @(pf) 31 &
@iif pf ! 0
#include "atlas_prefetch.h"
@endiif
@ifdef ! vl
   @abort "vl must be defined!"
@endifdef
@ifdef ! mu
   @abort "mu must be defined!"
@endifdef
@ifdef ! nu
   @abort "nu must be defined!"
@endifdef
@ifdef ! ku
   @abort "ku must be defined!"
@endifdef
@ifdef ! kb
   @define kb @0@
@endifdef
@iif kb = 0
   @addkeys KCON=no
@endiif
@iif kb ! 0
   @addkeys KCON=yes
@endiif
@iexp vku @(ku) 0 +
@iexp vmu @(mu) 0 +
@iexp vnu @(nu) 0 +
@VEC MDIM
   @iexp vmu @(vl) @(mu) /
   @iexp kk @(vmu) @(vl) *
   @iif kk ! mu
      @abort "MU=@(mu) illegal with VLEN=@(vl)!"
   @endiif
@VEC KDIM
   @iexp vku @(vl) @(ku) /
   @iif @iexp @(vku) @(vl) * @(ku) !
      @abort "KU=@(ku) illegal with VLEN=@(vl)!"
   @endiif
@VEC NO
   @iif vl ! 1
      @abort "vl must be 1 for scalar code!"
   @endiif
@VEC !
@ifdef ! kp
   @VEC KDIM `@define kp @@(vl)@`
   @VEC ! KDIM `@define kp @1@`
@endifdef
@VEC KDIM 
   @iexp vkp @(vl) @(kp) /
   @iexp kk @(vkp) @(vl) *
   @iif kk != ku
      @abort "KP (@(kp)) must be a multiple of ku*VLEN (@(ku)*@(vl))"
   @endiif
@VEC ! KDIM
   @define vkp @@(kp)@
@VEC !
@define KB @K@
@ifdef ! kp
   @VEC KDIM
      @define kp @@(vl)@
   @VEC ! KDIM
      @define kp @@(vku)@
   @VEC !
@endifdef
@iif vkp < 1
   @abort "K-peel (kp) must be >= 1!"
@endiif
@iexp kk @(ku) @(kp) /
@iexp kk @(kk) @(ku) *
@iif kp ! kk
   @abort "K-peel (@(kp)) must be a multiple of KU=@(ku)!"
@endiif
@VEC KDIM
@SKIP FOR KVEC, kb = CEIL(kb/vlen)*vlen
@iif kb ! 0
   @iexp kb @(vl) @(kb) @(vl) -1 + + / @(vl) *
   @undef KB
   @define KB @@(kb)@
   @iif @iexp @(vku) @(kb) %
      @abort "VKU=@(vku) must be multiple of @(kb)!"
   @endiif
@endiif
@VEC !
@iif kb > 0
#define ATL_KBCONST 1
#ifndef ATL_MM_KB
   #ifdef KB
      #define ATL_MM_KB KB
   #else
      #define ATL_MM_KB @(kb)
   #endif
#endif
@endiif
@iif kb = 0
#ifndef ATL_MM_KB 
   #ifdef KB
      #if KB > 0
         #define ATL_KBCONST 1
         #define ATL_MM_KB KB
      #else
         #define ATL_KBCONST 0
         #define ATL_MM_KB K
      #endif
   #else
      #define ATL_KBCONST 0
      #define ATL_MM_KB K
   #endif
#else
   #if ATL_MM_KB > 0
      #define ATL_KBCONST 1
   #else
      #undef ATL_MM_KB
      #define ATL_MM_KB K
      #define ATL_KBCONST 0
   #endif
#endif
@endiif
@VEC ! NO
#ifdef BETA1
   #define ATL_vbeta(p_, d_) \
   { \
      ATL_vld(rA0, p_); \
      ATL_vadd(d_, d_, rA0); \
      ATL_vst(p_, d_); \
   }
#elif defined(BETA0)
   #define ATL_vbeta(p_, d_) ATL_vst(p_, d_)
#else
   #define ATL_vbeta(p_, d_) \
   { \
      ATL_vld(rA0, p_); \
      ATL_vsub(d_, d_, rA0); \
      ATL_vst(p_, d_); \
   }
#endif
@VEC MDIM
   @iif bc = 0
      @BEGINPROC ldB spc d i_
      @beginindent 1 @(spc)
      @define j @@
      @define kk @@
@BEGINSKIP
         1-D must be able to do 2 memops/MAC to get peak, and a 2x2 2-D block
         must do a load for every MAC, so there will never be any "holes" to
         do extra memory operations like prefetch or advanced load for these
         cases.  1-D handles this with special code; to create a hole for 2x2
         we therefore don't count the last B load as memory load.  We do:
            IF (vmu != 2 || nu != 2 || i_ == nu-1)
               mo++  // mo is count of memory ops done with last MAC
         but this the same as
            mo = mo + 1*(vmu != 2 || nu != 2 || i_ == nu-1)
         which was obvious to you from the line below, of course.
@ENDSKIP
         @iexp mo 2 @(vmu) ! 2 @(nu) ! | @(i_) 1 @(nu) - = 1 * @(mo) +
         @iexp j @(vl) @(i_) /
         @iexp i_ @(vl) @(j) * @(i_) -
   ATL_vsplat@(i_)(@(d), vB@(j));
@SKIP    if ((i_+1)%vl == 0, add another vector to stack of vBs to load (lb)
         @iexp kk @(vl) 1 @(i_) + %
         @iif kk = 0
@SKIP    Keep macro stack in old->new order by reversing if non-empty
@SKIP    so we can add newest to bottom.
            @whiledef lb
               @define lb2 @@(lb)@
            @endwhile
            @define lb @@(j)@
            @whiledef lb2
               @define lb @@(lb2)@
            @endwhile
         @endiif
         @undef j
         @undef kk
      @endindent
      @ENDPROC
   @endiif
   @iif bc ! 0
      @BEGINPROC ldB spc d i_
      @beginindent 1 @(spc)
         @iexp mo 2 @(vmu) ! 2 @(nu) ! | @(i_) 1 @(nu) - = 1 * @(mo) +
         @iif ib < 0
            @iif i_ ! 0
   ATL_vbcast(@(d), pB+@(i_));
            @endiif
            @iif i_ = 0
   ATL_vbcast(@(d), pB);
            @endiif
         @endiif
         @iif ib > -1
            @iif ib ! 0
   ATL_vbcast(@(d), pB+@(ib));
             @endiif
            @iif ib = 0
   ATL_vbcast(@(d), pB);
             @endiif
            @iexp ib @(ib) 1 +
         @endiif
      @endindent
      @ENDPROC
   @endiif
@VEC KDIM
@BEGINSKIP
ARGS:
   nv : vvrsum # to use
   nr : actual number of registers remaining to be summed
   ir : base register number (0 <= ir < mu*nu)
ASSUMES: mu, nu, exreg
@ENDSKIP
   @BEGINPROC vvrsum nv nr ir
      @define k @0@
      @define kl @0@
      @define i @0@
      @define j @0@
      @declare "   ATL_vvrsum@(nv)(" y n ");"
         @iexp kl @(ir) @(nr) +
         @iexp k @(ir)
         @iwhile k < kl
            @iexp j @(mu) @(k) /
            @iexp i @(mu) @(k) %
               rC@(i)_@(j)
            @iexp k @(k) 1 +
         @endiwhile
         @iif nr < nv
            @iexp kl @(ir) @(nv) +
            @iwhile k < kl
               @(exreg)
            @iexp k @(k) 1 +
         @endiwhile
         @endiif
      @enddeclare
      @iexp j @(mu) @(ir) /
      @iexp i @(mu) @(ir) %
      @iexp kl @(j) @(mu) *
      @iexp kl @(kl) @(i) +
   ATL_vbeta(pC+@(kl), rC@(i)_@(j));
      @undef i
      @undef j
      @undef k
      @undef kl
   @ENDPROC
@VEC KDIM NO
   @BEGINPROC ldB spc d i_
   @beginindent 1 @(spc)
      @iexp i_ @(vl) @(i_) *
      @iexp mo 2 @(vmu) ! 2 @(nu) ! | @(i_) 1 @(nu) - = 1 * @(mo) +
      @iif ib < 0
         @iif i_ ! 0
   ATL_vld(@(d), pB+@(i_));
         @endiif
         @iif i_ = 0
   ATL_vld(@(d), pB);
         @endiif
      @endiif
      @iif ib > -1 
         @iif ib ! 0
   ATL_vld(@(d), pB+@(ib));
         @endiif
         @iif ib = 0
   ATL_vld(@(d), pB);
         @endiif
         @iexp ib @(ib) @(vl) +
      @endiif
   @endindent
   @ENDPROC
@VEC NO KDIM
   @define ldB @ATL_vld@
   @iexp bmul @(vl) 0 +
@VEC MDIM
   @define ldB @ATL_vbcast@
   @iexp bmul 1 0 +
@VEC NO
   @BEGINPROC storeC spc
   @define kk @dum@
   @define i @dum@
   @define j @dum@
   @beginindent 1 @(spc)
      @iexp kk 0 0 +
      @iexp j 0 0 +
      @iwhile j < @(nu)
         @iexp i 0 0 +
         @iwhile i < @(vmu)
   #ifdef BETA0
      pC[@(kk)] = rC@(i)_@(j);
   #elif defined(BETA1)
      pC[@(kk)] += rC@(i)_@(j);
   #else
      pC[@(kk)] = rC@(i)_@(j) - pC[@(kk)];
   #endif
            @iexp kk @(kk) 1 +
            @iexp i @(i) 1 +
         @endiwhile
         @iexp j @(j) 1 +
      @endiwhile
   @endindent
   @undef kk
   @undef j
   @undef k
   @ENDPROC
@VEC MDIM
   @BEGINPROC storeC spc
   @define kk @dum@
   @define i @dum@
   @define j @dum@
   @beginindent 1 @(spc)
      @iexp kk 0 0 +
      @iexp j 0 0 +
      @iwhile j < @(nu)
         @iexp i 0 0 +
         @iwhile i < @(vmu)
   ATL_vbeta(pC+@(kk), rC@(i)_@(j));
            @iexp kk @(kk) @(vl) +
            @iexp i @(i) 1 +
         @endiwhile
         @iexp j @(j) 1 +
      @endiwhile
   @endindent
   @undef kk
   @undef j
   @ENDPROC
@VEC KDIM
   @BEGINPROC storeC spc
      @define nr @dum@
      @define nf @dum@
      @define k @dum@
      @define ll @dum@
      @define vl2 @dum@

      @beginindent 1 @(spc)
         @iexp nf @(vl) @(mu) @(nu) * / @(vl) *
         @iexp nr @(nf) @(mu) @(nu) * -
         @iexp k 0
         @iwhile k < nf
            @callproc vvrsum @(vl) @(vl) @(k)
            @iexp k @(k) @(vl) +
         @endiwhile
         @iif nr = 1
            @callproc vvrsum 1 1 @(k)
         @endiif
         @iif nr > 1
            @iexp ll @(vl)
            @iwhile nr > 0
               @iexp vl2 2 @(ll) /
            @print nr=@(nr) ll=@(ll) vl2=@(vl2)
               @iif nr > vl2
                  @callproc vvrsum @(ll) @(nr) @(k)
                  @iexp nr 0
               @endiif
               @iif nr } vl2
                  @callproc vvrsum @(vl2) @(vl2) @(k)
                  @iexp nr @(vl2) @(nr) -
                  @iexp k @(k) @(vl2) +
               @endiif
               @iexp ll @(vl2)
            @endiwhile
         @endiif
      @endindent
      @undef k
      @undef nf
      @undef nr
      @undef ll
      @undef vl2
   @ENDPROC
@VEC KDIM
   @iexp incAk @(mu) @(vl) *
   @iexp incBk @(nu) @(vl) *
@VEC MDIM NO
   @iexp incAk @(mu)
   @iexp incBk @(nu)
@VEC !
@iexp TWOD 1 0 +
@iif vmu = 1
   @iexp TWOD 0 0 +
@endiif
@iif vnu = 1
   @iexp TWOD 0 0 +
@endiif
@skip NOKLOOP = (kb == ku);
@iexp NOKLOOP @(kb) @(ku) =
@iif NOKLOOP = 0
   @iexp ia -1 0 +
   @iexp ib -1 0 +
@endiif
@iif NOKLOOP ! 0
   @iexp ia 0 0 +
   @iexp ib 0 0 +
@endiif
@ifdef lb
   @abort "lb cannot be defined!"
@endifdef
@ifdef lb2
   @abort "lb2 cannot be defined!"
@endifdef

#ifndef ATL_CSZT
   #include <stddef.h>
   #define ATL_CSZT const size_t
#endif
@skip Helper func for DoIter[0].  
@skip IN: pfLS,npfA,npfB, npfC, ipb, ipa, mu, nu, IN_K; 
@skip IN/OUT: mo, ipf
@BEGINPROC DoPref
   @define kk @dum@
   @define jj @dum@
   @SKIP commented out, now handled in ldB
   @BEGINSKIP
   @SKIP if (vmu == 2 && vnu == 2 && mo = 1) mo = 0
   @iexp kk @(vmu) 2 = @(vnu) 2 = @(mo) 1 = & &
   @iif kk ! 0
      @iexp mo 0 0 +
   @endiif
   @ENDSKIP
   @iif mo = 0
      @iif ipf < npfC
         @iexp kk @(ipf) @(pfLS) *
               @(pfC)(pC+@(kk));
         @iexp ipf @(ipf) 1 +
         @iexp mo @(mo) 1 +
      @endiif
      @skip if (mo = 0 && ipf < npfA)
      @iexp kk @(mo) 0 = @(npfA) @(ipf) < &
      @iif kk ! 0
         @iexp kk @(npfC) @(ipf) - @(pfLS) *
               @(pfA)(pAn+@(kk));
         @iexp ipf @(ipf) 1 +
         @iif ipf = npfA
               pAn += incAN;
         @endiif
         @iexp mo @(mo) 1 +
      @endiif
      @skip if (mo == 0 && ipf < npfB)
      @iexp kk @(mo) 0 = @(npfB) @(ipf) < &
      @iif kk ! 0
         @iexp kk @(npfA) @(ipf) - @(pfLS) *
               @(pfB)(pBn+@(kk));
         @iexp ipf @(ipf) 1 +
         @iif ipf = npfB
               pBn += incBN;
         @endiif
         @iexp mo @(mo) 1 +
      @endiif
@SKIP Handle prefetch of next k loop traversal, if it exists
      @iif mo = 0
         @ifdef pfBk
            @SKIP if (NOKLOOP == 0 && IN_K != 0)
            @iexp kk 0 @(NOKLOOP) = 0 @(IN_K) ! &
            @iif kk ! 0
               @(pfBk)(pB+incBn);
                  @undef pfBk
               @iexp mo @(mo) 1 +
            @endiif
            @iexp jj @(kb) @(nu) *
            @SKIP if (NOKLOOP != 0 && ipb%pfLS == 0 && ipb < incBn)
            @iexp kk @(pfLS) @(ipb) % 0 = @(NOKLOOP) 0 ! & @(jj) @(ipb) < &
            @iif kk ! 0
               @iexp jj @(jj) @(ipb) +
            @(pfBk)(pB+@(jj));
               @iexp ipb @(ipb) @(pfLS) +
               @iexp mo @(mo) 1 +
            @iexp kk @(jj) @(ipb) <
            @endiif
         @endifdef
      @endiif
      @iif mo = 0
         @ifdef pfAk
            @SKIP if (NOKLOOP == 0 && IN_K != 0)
            @iexp kk 0 @(NOKLOOP) = 0 @(IN_K) ! &
            @iif kk ! 0
               @(pfAk)(pA+incAm);
                  @undef pfAk
               @iexp mo @(mo) 1 +
            @endiif
            @iexp jj @(kb) @(mu) *
            @SKIP if (NOKLOOP != 0 && ipa%pfLS == 0 && ipa < incAm)
            @iexp kk @(pfLS) @(ipa) % 0 = @(NOKLOOP) 0 ! & @(jj) @(ipa) < &
            @iif kk ! 0
               @iexp jj @(jj) @(ipa) +
            @(pfAk)(pA+@(jj));
               @iexp ipa @(ipa) @(pfLS) +
               @iexp mo @(mo) 1 +
            @endiif
         @endifdef
      @endiif
      @iif IN_K ! 0
         @ifdef pfAk
            @iif mo = 0
            @(pfAk)(pA+incAm);
               @undef pfAk
               @iexp mo @(mo) 1 +
            @endiif
         @endifdef
      @endiif
   @endiif
   @undef jj
   @undef kk
@ENDPROC
@beginskip
Perform initial iteration use vmul.  1-D scheduled to make it obvious
the non-unit dimension can be directly loaded from memory, rather than
really using registers.  This allows total number of registers to be:
   MAX(MU,NU) + 1
ASSUMES DEFINED: ldB, incBk, bmul, incAk, vmu, vnu, vl
@endskip
@BEGINPROC DoIter0_k
@SKIP define internal vars, so they can popped off to leave caller unchanged
   @define DN @0@
   @define i @0@
   @define j @0@
   @define kk @0@
@SKIP 1-D with NU=1
   @iif vnu = 1
      @iexp DN 1 0 +
         @callproc ldB 9 rB0 0
         @iexp i 0 0 +
         @iwhile i < @(vmu)
         ATL_vld(rC@(i)_0, pA+@(ia));
            @iexp ia @(ia) @(vl) +
         ATL_vmul(rC@(i)_0, rC@(i)_0, rB0);
            @iexp mo 0 0 +
            @callproc DoPref
            @iexp i @(i) 1 +
         @endiwhile
   @endiif
@SKIP 1-D with VMU=1
   @iif DN = 0
      @iif vmu = 1
         @iexp DN 1 0 +
         ATL_vld(rA0, pA+@(ia));
         @iexp ia @(ia) @(vl) +
@skip         @iexp ia @(ia) @(incAk) +
         @iexp j 0 0 +
         @iwhile j < @(vnu)
            @callproc ldB 6 rC0_@(j) @(j)
         ATL_vmul(rC0_@(j), rC0_@(j), rA0);
            @iexp mo 0 0 +
            @callproc DoPref
            @iexp j @(j) 1 +
            @skip if (bc==0 && j%vl==0)
            @iexp kk @(bc) 0 = @(vl) @(j) % 0 = &
            @ifdef lb
             ATL_vld(vB@(lb), pB+@(ib));
                @undef lb
                @iexp ib @(ib) @(vl) +
            @endifdef
         @endiwhile
      @endiif
   @endiif
@SKIP 2-D case assumes all but last rB already loaded unless B1R is set
   @iif DN = 0
      @define jb @0@
         ATL_vld(rA0, pA);
      @iexp ia @(ia) @(vl) +
      @iexp i 0 1 +
      @iwhile i < @(vmu)
         ATL_vld(rA@(i), pA+@(ia));
         @iexp ia @(ia) @(vl) +
         @iexp i @(i) 1 +
      @endiwhile
      @iif B1R = 0
         @callproc ldB 6 rB@(jl) @(jl)
      @endiif
      @ifdef lb
         ATL_vld(vB@(lb), pB+@(ib));  // A01
         @undef lb
         @iexp ib @(ib) @(vl) +
      @endifdef
      @iexp j 0 0 +
      @iwhile j < @(vnu)
         @iexp jb 0 @(B1R) = @(j) *
         @iif B1R ! 0
            @callproc ldB 9 rB0 @(j)
         @endiif
         @iexp i 0 0 +
         @iwhile i < @(vmu)
         ATL_vmul(rC@(i)_@(j), rA@(i), rB@(jb));
            @iexp mo 0 0 +
            @iif j = jl
            ATL_vld(rA@(i), pA+@(ia));
               @iexp ia @(ia) @(vl) +
               @iexp mo @(mo) 1 +
            @endiif
            @iif mo = 0
               @ifdef lb
            ATL_vld(vB@(lb), pB+@(ib));  // A02 i=@(i) j=@(j)
                  @undef lb
                  @iexp mo @(mo) 1 +
                  @iexp ib @(ib) @(vl) +
               @endifdef
            @endiif
            @skip if (i == il && j != jl && !B1R)
            @iif @iexp @(i) @(il) = @(j) @(jl) ! & @(B1R) 0 = &
               @callproc ldB 9 rB@(j) @(j)
            @endiif
            @callproc DoPref
            @iexp i @(i) 1 +
         @endiwhile
         @iexp j @(j) 1 +
      @endiwhile
      @undef jb
   @endiif
@SKIP pop our defs so caller's macros of same name aren't changed
   @undef DN
   @undef i
   @undef j
   @undef kk
@ENDPROC
@SKIP Do normal iteration
@SKIP ASSUMES DEFINED: ldB, incBk, bmul, incAk, vmu, vnu, vl, jpf
@BEGINPROC DoIter_k
@SKIP define internal vars, so they can popped off to leave caller unchanged
   @define DN @0@
   @define i @0@
   @define j @0@
   @define kk @0@
@SKIP 1-D with NU=1
   @iif vnu = 1
      @iexp DN 1 0 +
         @callproc ldB 9 rB0 0
         @iexp i 0 0 +
         @iwhile i < @(vmu)
            ATL_vld(rA0, pA+@(ia));
            @iexp ia @(ia) @(vl) +
            ATL_vmac(rC@(i)_0, rA0, rB0);
            @iexp mo 0 0 +
            @callproc DoPref
            @iexp i @(i) 1 +
         @endiwhile
   @endiif
@SKIP 1-D with MU=1
   @iif DN = 0
      @iif vmu = 1
         @iexp DN 1 0 +
            ATL_vld(rA0, pA+@(ia));
            @iexp ia @(ia) @(vl) +
         @iexp j 0 0 +
         @iwhile j < @(vnu)
            @callproc ldB 9 rB0 @(j)
            ATL_vmac(rC0_@(j), rA0, rB0);
            @iexp mo 0 0 +
            @callproc DoPref
            @iexp j @(j) 1 +
            @skip if (bc==0 && j%vl==0)
            @iexp kk @(bc) 0 = @(vl) @(j) % 0 = &
            @iif kk ! 0
               @iexp kk @(vl) @(j) / -1 +
             ATL_vld(vB@(kk), pB+@(ib)); // 01
               @iexp ib @(ib) @(vl) +
            @endiif
         @endiwhile
      @endiif
   @endiif
@SKIP 2-D case assumes all but last rB already loaded unless B1R true
   @iif DN = 0
      @define jb @0@
      @iexp j 0 0 +
      @iwhile j < @(vnu)
         @iexp jb 0 @(B1R) = @(j) *
         @iif B1R ! 0
            @callproc ldB 12 rB0 @(jl)
         @endiif
         @iexp i 0 0 +
         @iwhile i < @(vmu)
            @iexp mo 0 0 +
            ATL_vmac(rC@(i)_@(j), rA@(i), rB@(jb));
            @skip if ((i|j) == 0 && !B1R)
            @iif @iexp @(i) @(j) | 0 = @(B1R) 0 = &
               @iexp kk @(jl) @(bmul) *
               @callproc ldB 12 rB@(jl) @(jl)
                  @ifdef lb
               ATL_vld(vB@(lb), pB+@(ib)); // 02
                     @undef lb
                     @iexp ib @(ib) @(vl) +
                     @iexp mo 1 0 +
                  @endifdef
            @endiif
            @iif j = jl
               ATL_vld(rA@(i), pA+@(ia));
               @iexp ia @(ia) @(vl) +
               @iexp mo 1 0 +
            @endiif
            @skip if (j != jl && i == il && !B1R
            @iif @iexp @(j) @(jl) ! @(i) @(il) = & @(B1R) 0 = &
               @callproc ldB 12 rB@(j) @(j)
            @endiif
            @iif mo = 0
               @ifdef lb
               ATL_vld(vB@(lb), pB+@(ib)); // 03
                  @undef lb
                  @iexp ib @(ib) @(vl) +
                  @SKIP if (vmu !=2 && vnu != 2) mo++
                  @iexp kk @(vmu) 2 ! @(vnu) 2 ! |
                  @iif kk ! 0
                     @iexp mo 1 0 +
                  @endiif
               @endifdef
            @endiif
            @callproc DoPref
            @iexp i @(i) 1 +
         @endiwhile
         @iexp j @(j) 1 +
      @endiwhile
      @undef jb
   @endiif
@SKIP pop our defs so caller's macros of same name aren't changed
   @undef DN
   @undef i
   @undef j
   @undef kk
@ENDPROC
@BEGINPROC DoIter0
@SKIP define internal vars, so they can popped off to leave caller unchanged
   @define DN @0@
   @define i @0@
   @define j @0@
   @define kk @0@
@SKIP 1-D with NU=1
   @iif vnu = 1
      @iexp DN 1 0 +
         @(ldB)(rB0, pB);
         pB += @(incBk);
         @iexp i 0 0 +
         @iwhile i < @(vmu)
            @iexp kk @(i) @(vl) *
         ATL_vld(rC@(i)_0, pA+@(kk));
         ATL_vmul(rC@(i)_0, rC@(i)_0, rB0);
            @iexp mo 0 0 +
            @callproc DoPref
            @iexp i @(i) 1 +
         @endiwhile
         pA += @(incAk);
   @endiif
@SKIP 1-D with VMU=1
   @iif DN = 0
      @iif vmu = 1
         @iexp DN 1 0 +
         ATL_vld(rA0, pA);
         pA += @(incAk);
         @iexp j 0 0 +
         @iwhile j < @(vnu)
            @callproc ldB 6 rC0_@(j) @(j)
         ATL_vmul(rC0_@(j), rC0_@(j), rA0);
            @iexp mo 0 0 +
            @callproc DoPref
            @iexp j @(j) 1 +
            @skip if (bc==0 && j%vl==0)
            @iexp kk @(bc) 0 = @(vl) @(j) % 0 = &
            @iif kk ! 0
               @iexp kk @(vl) @(j) / -1 +
               @iexp jj @(kk) @(vl) *
             ATL_vld(vB@(kk), pB+@(jj));
            @endiif
         @endiwhile
         pB += @(incBk);
      @endiif
   @endiif
@SKIP 2-D case assumes all but last rB already loaded unless B1R is true
   @iif DN = 0
      @define jb @0@
         ATL_vld(rA0, pA);
      @iexp i 0 1 +
      @iwhile i < @(vmu)
         @iexp kk @(i) @(vl) *
         ATL_vld(rA@(i), pA+@(kk));
         @iexp i @(i) 1 +
      @endiwhile
      @iif B1R = 0
         @callproc ldB 6 rB@(jl) @(jl)
      @endiif
         pA += @(incAk);
      @ifdef lb
         @iexp jj @(vl) @(lb) *
         ATL_vld(vB@(lb), pB+@(jj)); // di0_00
         @undef lb
      @endifdef
      @iif B1R = 0
         pB += @(incBk);
      @endiif
      @iexp j 0 0 +
      @iwhile j < @(vnu)
         @iif B1R ! 0
            @callproc ldB 6 rB0 @(j)
            @iif @iexp @(vnu) -1 + @(j) =
               pB += @(incBk); // di0_02
            @endiif
         @endiif
         @iexp jb 0 @(B1R) = @(j) *
         @iexp i 0 0 +
         @iwhile i < @(vmu)
         ATL_vmul(rC@(i)_@(j), rA@(i), rB@(jb));
            @iexp mo 0 0 +
            @iif j = jl
               @iexp kk @(i) @(vl) *
            ATL_vld(rA@(i), pA+@(kk));
               @iexp mo @(mo) 1 +
                  @iif i = il
            pA += @(incAk);
                  @endiif
            @endiif
            @iif mo = 0
               @ifdef lb
                  @iexp kk @(lb) @(vl) *
               ATL_vld(vB@(lb), pB+@(kk)); // di0_01: lb=@(lb) jl=@(jl)
                  @iexp kk @(kk) @(vl) +
                  @iif kk = incBk
               pB += @(incBk); // di0_02
                  @endiif
                  @undef lb
                  @iexp mo @(mo) 1 +
               @endifdef
            @endiif
            @iif B1R = 0
               @iif i = il
                  @iif j ! jl
                     @iexp kk @(j) @(bmul) *
            @callproc ldB 9 rB@(j) @(j)
                  @endiif
               @endiif
            @endiif
            @callproc DoPref
            @iexp i @(i) 1 +
         @endiwhile
         @iexp j @(j) 1 +
      @endiwhile
      @undef jb
   @endiif
@SKIP pop our defs so caller's macros of same name aren't changed
   @undef DN
   @undef i
   @undef j
   @undef kk
@ENDPROC
@SKIP Do normal iteration
@SKIP ASSUMES DEFINED: ldB, incBk, bmul, incAk, vmu, vnu, vl, jpf
@BEGINPROC DoIter
@SKIP define internal vars, so they can popped off to leave caller unchanged
   @define DN @0@
   @define i @0@
   @define j @0@
   @define kk @0@
@SKIP 1-D with NU=1
   @iif vnu = 1
      @iexp DN 1 0 +
            @(ldB)(rB0, pB);
            pB += @(incBk);
         @iexp i 0 0 +
         @iwhile i < @(vmu)
            @iexp kk @(i) @(vl) *
            ATL_vld(rA0, pA+@(kk));
            ATL_vmac(rC@(i)_0, rA0, rB0);
            @iexp mo 0 0 +
            @callproc DoPref
            @iexp i @(i) 1 +
         @endiwhile
            pA += @(incAk);
   @endiif
@SKIP 1-D with MU=1
   @iif DN = 0
      @iif vmu = 1
         @iexp DN 1 0 +
            ATL_vld(rA0, pA);
            pA += @(incAk);
         @iexp j 0 0 +
         @iwhile j < @(vnu)
            @callproc ldB 9 rB0 @(j)
            ATL_vmac(rC0_@(j), rA0, rB0);
            @iexp mo 0 0 +
            @callproc DoPref
            @iexp j @(j) 1 +
            @skip if (bc==0 && j%vl==0)
            @iexp kk @(bc) 0 = @(vl) @(j) % 0 = &
            @iif kk ! 0
               @iexp kk @(vl) @(j) / -1 +
               @iexp jj @(kk) @(vl) *
             ATL_vld(vB@(kk), pB+@(jj));
            @endiif
         @endiwhile
            pB += @(incBk);
      @endiif
   @endiif
@SKIP 2-D case assumes all but last rB already loaded
   @iif DN = 0
      @define jb @0@
      @iexp j 0 0 +
      @iwhile j < @(vnu)
         @iexp jb 0 @(B1R) = @(j) *
         @iif B1R ! 0
            @callproc ldB 12 rB0 @(j)
            @iif jl = j
               pB += @(incBk);
            @endiif
         @endiif
         @iexp i 0 0 +
         @iwhile i < @(vmu)
            @iexp mo 0 0 +
            ATL_vmac(rC@(i)_@(j), rA@(i), rB@(jb));
            @skip if ((i|j|B1R) == 0)
            @iif @iexp @(i) @(j) | @(B1R) | 0 =
                  @iexp kk @(jl) @(bmul) *
               @callproc ldB 12 rB@(jl) @(jl)
                  @ifdef lb
                     @iexp kk @(lb) @(vl) *
               ATL_vld(vB@(lb), pB+@(kk));
                     @undef lb
                     @iexp mo 1 0 +
                  @endifdef
               pB += @(incBk);
            @endiif
            @iif j = jl
               @iexp kk @(i) @(vl) *
               ATL_vld(rA@(i), pA+@(kk));
               @iexp mo 1 0 +
               @iif i = il
               pA += @(incAk);
               @endiif
            @endiif
            @skip if (j != jl && i == il && !B1R)
            @iif @iexp @(j) @(jl) ! @(i) @(il) = & @(B1R) 0 = &
               @iexp kk @(j) @(bmul) *
               @callproc ldB 12 rB@(j) @(j)
            @endiif
            @iif mo = 0
               @ifdef lb
                  @iexp kk @(lb) @(vl) *
               ATL_vld(vB@(lb), pB+@(kk));
                  @undef lb
                  @iexp mo 1 0 +
               @endifdef
            @endiif
            @callproc DoPref
            @iexp i @(i) 1 +
         @endiwhile
         @iexp j @(j) 1 +
      @endiwhile
      @undef jb
   @endiif
@SKIP pop our defs so caller's macros of same name aren't changed
   @undef DN
   @undef i
   @undef j
   @undef kk
@ENDPROC
void ATL_USERMM
(
   ATL_CSZT nmus,
   ATL_CSZT nnus,
   ATL_CSZT K,
   const @(typ) *pA, /* @(mu)*KB*nmus-length access-major array of A */
   const @(typ) *pB, /* @(nu)*KB*nnus-length access-major array of B */
   @(typ) *pC,   /* @(mu)*@(nu)*nnus*nmus-length access-major array of C */
   const @(typ) *pAn, /* next block of A */
   const @(typ) *pBn, /* next block of B */
   const @(typ) *pCn  /* next block of C */
)
/*
 * Performs a GEMM with M,N,K unrolling (& jam) of (@(mu),@(nu),@(ku)).
@VEC KDIM ` * Vectorization of VLEN=@(vl) along K dim, vec unroll=(@(vmu),@(vnu),@(vku)).`
@VEC MDIM ` * Vectorization of VLEN=@(vl) along M dim, vec unroll=(@(vmu),@(vnu),@(vku)).`
@VEC NO   ` * Code is not vectorized (VLEN=@(vl)).`
@iif kb = 0
 * You may set compile-time constant K dim by defining ATL_MM_KB.
@endiif
 */
{
   @declare "   register ATL_VTYPE " y n ";"
      @iif bc = 0
         @iexp kk @(vl) @(vnu) /
         @iexp j 0 0 +
         @iwhile j < @(kk)
            vB@(j)
            @iexp j @(j) 1 +
         @endiwhile
      @endiif
      @iif B1R ! 0
         rB0
      @endiif
      @iexp j 0 0 +
      @iwhile j < @(vnu)
         @iif @iexp 0 @(TWOD) ! 0 @(B1R) = &
            rB@(j)
         @endiif
         @iexp i 0 0 +
         @iwhile i < @(vmu)
            rC@(i)_@(j)
            @iexp i @(i) 1 +
         @endiwhile
         @iexp j @(j) 1 +
      @endiwhile
      @iif TWOD = 0
         rA0 
         @iif B1R = 0
            rB0
         @endiif
      @endiif
      @iif TWOD ! 0
         @iexp i 0 0 +
         @iwhile i < @(vmu)
            rA@(i)
            @iexp i @(i) 1 +
         @endiwhile
      @endiif
      @SKIP if (mu*nu < vlen && mu != 1 && nu != 1
      @iif @iexp @(vl) @(mu) @(nu) * < @(mu) 1 ! & @(nu) 1 ! &
         rtmp
         @define exreg @rtmp@
      @endiif
   @enddeclare
   @iif @iexp @(vl) @(mu) @(nu) * > 
      @define exreg @rC0_0@
   @endiif
   @ifdef ! exreg
      @iif @iexp @(mu) 1 = @(nu) 1 = |
         @define exreg @rB0@
      @endiif
   @endifdef
   @declare "   const @(typ) " y n ";"
    *pB0=pB *pA0=pA
   @enddeclare
   @iif npfA > 0
   const int incAN = (ATL_MM_KB * @(mu)) / nnus;
   @endiif
   @iif npfB > 0
   const int incBN = (ATL_MM_KB * @(nu)) / nmus;
   @endiif
@skip   const @(typ) *pfA;
   int i, j, k;
   #if ATL_KBCONST == 0
      int incAm = @(mu)*K, incBn = @(nu)*K;
   #else
      #define incAm (@(mu)*ATL_MM_KB)
      #define incBn (@(nu)*ATL_MM_KB)
   #endif

   @SKIP if (npfA > 0 & npfB > 0)
   @iexp kk 0 @(npfA) > 0 @(npfB) > &
   @iif kk ! 0
   pAn = (pAn != pA) ? pAn : pC;
   pBn = (pBn != pB) ? pBn : pC;
   @endiif
   @iif kk = 0
      @iif npfA > 0
         if (pAn == pA)
            pAn = (pBn != pB) ? pBn : pCn;
      @endiif
      @iif npfB > 0
         if (pBn == pB)
            pBn = (pAn != pA) ? pAn : pCn;
      @endiif
   @endiif
   @iexp mo 0 0 +
   @iexp ipf 0 0 +
   @iexp ipa 0 0 +
   @iexp ipb 0 0 +
   @iexp jl @(vnu) -1 +
   @iexp il @(vmu) -1 +
   @iif vnu > 2
      @iexp jpf 0 1 +
   @endiif
   @iif vnu < 3
      @iexp jpf 0 -1 +
   @endiif
   @iexp jpf 0 -1 +
@iif @iexp @(DOMLOOP)
   for (i=0; i < nmus; i++)
   {
@endiif
@print NOK=@(NOKLOOP) ib=@(ib) ia=@(ia)
   @iif bc = 0
      @iexp j 0 0 +
      @iwhile j < @(vnu)
         @iexp kk @(vl) @(j) /
      ATL_vld(vB@(kk), pB+@(j));
         @iexp j @(j) @(vl) +
      @endiwhile
      @iif NOKLOOP ! 0
         @iexp ib @(ib) @(nu) +
      @endiif
      @iif NOKLOOP = 0
      pB += @(incBk);
      @endiif
   @endiif
   @iif @iexp 1 @(vmu) > 0 @(B1R) = &
      @iexp j 0 0 +
      @iwhile j < @(jl)
         @callproc ldB 3 rB@(j) @(j)
         @ifdef lb
            @iif ib < 0
               @iexp kk @(vl) @(lb) *
      ATL_vld(vB@(lb), pB+@(kk)); // h0
            @endiif
            @iif ib > -1 
      ATL_vld(vB@(lb), pB+@(ib));  // h1
               @iexp ib @(ib) @(vl) +
            @endiif
            @undef lb
         @endifdef
         @iexp j @(j) 1 +
      @endiwhile
   @endiif
   @iif @iexp @(DONLOOP)
      @iif TRI = 0
      for (j=0; j < nnus; j++)
      @endiif
      @iif TRI = 1
      for (j=0; j <= i; j++)
      @endiif
      {
   @endiif
         /* Peel K=0 iteration to avoid zero of rCxx and extra add  */
   @iif NOKLOOP ! 0
      @iexp IN_K 0 0 +
         @CALLPROC DoIter0_k
      @VEC KDIM `@iexp incK @(vl) 0 +`
      @VEC ! KDIM `@iexp incK 1 0 +`
      @iexp k 0 @(incK) +
      @iwhile ipf < npf
            /* Peel K=@(k) iteration for prefetch  */
         @CALLPROC DoIter_k
         @iexp k @(k) @(incK) +
      @endiwhile
      @iexp IN_K 1 0 +
      @iwhile k < kb
            /* K=@(k) iteration */
         @CALLPROC DoIter_k
         @iexp k @(k) @(incK) +
      @endiwhile
   @endiif
   @iif NOKLOOP = 0
      @iexp IN_K 0 0 +
      @iexp npeel 1 0 +
      @VEC KDIM `@iexp kmul @(vl)`
      @VEC ! KDIM `@iexp kmul 1`
      @CALLPROC DoIter0
      @iwhile ipf < npf
/*
 *       Peel K=@(npeel) iter to allow prefetch of C or next blocks of A&B
 */
         @iexp kk @(kmul) @(npeel) *
         if (K == @(kk))
            goto KDONE;
            @CALLPROC DoIter
         @iexp npeel @(npeel) 1 +
      @endiwhile
      @SKIP peel until npeel%vku == 0
      @iif @iexp @(vku) @(npeel) % 0 !
         @iexp nep @(vku) @(npeel) % @(vku) -
/*
 *       Peeled @(npeel) iters, peel another @(nep) to make mul of vku=@(vku)
 */
         @iexp ii 0
         @iwhile ii < nep
         /* ku mulpeel @(ii) of @(nep) */
         @iexp kk @(kmul) @(npeel) *
         if (K == @(kk))
            goto KDONE;
            @CALLPROC DoIter
            @iexp npeel @(npeel) 1 +
            @iexp ii @(ii) 1 +
         @endiwhile
      @endiif
         @iexp kk @(kmul) @(npeel) *
         for (k=@(kk); k < ATL_MM_KB; k += @(ku))
         {
            @iexp IN_K 0 1 +
            @iexp kk 0
            @iwhile kk < @(vku)
            @iif kk > 0

            @endiif
            @CALLPROC DoIter
               @iexp kk @(kk) 1 +
            @endiwhile
         }
      @iif npeel > 1
KDONE:
      @endiif
   @endiif
         @CALLPROC storeC 6
         @VEC KDIM   `@iexp kk @(vl) @(mu) @(nu) * @(vl) + -1 + / @(vl) *`
         @VEC ! KDIM `@iexp kk @(mu) @(nu) *`
   @iif @iexp @(DOMLOOP) @(DONLOOP) |
         pC += @(kk);
      @iif NOKLOOP ! 0
         pB += incBn;
      @endiif
      @iif ku ! kb
         pA = pA0;
      @endiif
   @endiif
   @iif @iexp @(DONLOOP)
      }  /* end of loop over N */
   @endiif
   @iif @iexp @(DOMLOOP)
      pB = pB0;
      pA0 += incAm;
      pA = pA0;
   }  /* end of loop over M */
   @endiif
}
@ROUT blk2C C2blk
#include <stddef.h>
@ifdef ! cpvl
   @iexp cpvl 1
@endifdef
@iif vl = 0
   @iexp vl 1
@endiif
@iif cpvl > 1
#define ATL_VLEN @(vl)
#include "atlas_simd.h"
@endiif
#if defined(__STDC_VERSION__) && (__STDC_VERSION__/100 >= 1999)
   #define INLINE inline
#endif
@SKIP LEGAL: alpha=[1,-1,X], beta=[0,1,-1,X]
@SKIP if (alpha==1) && (beta==0 || beta==1)) -> char same as #
@ifdef ! rtnm
   @define rtnm @ATL_USERCPMM@
@endifdef
@PRE S D
@SKIP blksz = ((mu*nu+vlen-1)/vlen)*vlen
@iexp bs @(vl) @(mu) @(nu) * @(vl) + -1 + / @(vl) *
// HERE vl=@(vl), mu=@(mu), nu=@(nu) bs=@(bs)
@SKIP IN: mu, nu, beta, alpha
@BEGINPROC doDiBlock n_
   @define i @dum@
   @define j @dum@
   @define k @dum@
   @define c @dum@
   @define r @dum@
   @iexp j 0
   @iwhile j < @(n_)
      @iexp i 0
      @iwhile i < @(n_)
         @iexp k @(j) @(mu) * @(i) +
@ROUT blk2C
         @iexp r @(i)
         @iexp c @(j)
         @iif j { i
@ROUT C2blk
         @iif j > i
            @iexp r @(j)
            @iexp c @(i)
         @endiif
         @iif j { i
            @iexp r @(i)
            @iexp c @(j)
         @endiif
@ROUT blk2C C2blk
         @iif alpha = 1
            @iif beta = 0
@ROUT blk2C `            C@(c)[@(r)] = p[@(k)];`
@ROUT C2blk `            p[@(k)] = C@(c)[@(r)];`
            @endiif
            @iif beta = 1
@ROUT blk2C `            C@(c)[@(r)] += p[@(k)];`
@ROUT C2blk `            p[@(k)] += C@(c)[@(r)];`
            @endiif
            @iif beta = -1
@ROUT blk2C `            C@(c)[@(r)] = p[@(k)] - C@(c)[@(r)];`
@ROUT C2blk `            p[@(k)] = C@(c)[@(r)] - p[@(k)];`
            @endiif
            @iif @iexp @(beta) 0 ! @(beta) 1 ! & @(beta) -1 ! &
@ROUT blk2C `            C@(c)[@(r)] = beta*C@(c)[@(r)] + p[@(k)];`
@ROUT C2blk `            p[@(k)] = beta*p[@(k)] + C@(c)[@(r)];`
            @endiif
         @endiif
         @iif alpha = -1
            @iif beta = 0
@ROUT blk2C `            C@(c)[@(r)] = -p[@(k)];`
@ROUT C2blk `            p[@(k)] = -C@(c)[@(r)];`
            @endiif
            @iif beta = 1
@ROUT blk2C `            C@(c)[@(r)] -= p[@(k)];`
@ROUT C2blk `            p[@(k)] -= C@(c)[@(r)];`
            @endiif
            @iif beta = -1
@ROUT blk2C `            C@(c)[@(r)] = -C@(c)[@(r)] - p[@(k)];`
@ROUT C2blk `            p[@(k)] = -C@(c)[@(r)] - p[@(k)];`
            @endiif
            @iif @iexp @(beta) 0 ! @(beta) 1 ! & @(beta) -1 ! &
@ROUT blk2C `            C@(c)[@(r)] = beta*C@(c)[@(r)] - p[@(k)];`
@ROUT C2blk `            p[@(k)] = beta*p[@(k)] - C@(c)[@(r)];`
            @endiif
         @endiif
         @iif @iexp @(alpha) 1 ! @(alpha) -1 ! &
            @iif beta = 0
@ROUT blk2C `            C@(c)[@(r)] = alpha*p[@(k)];`
@ROUT C2blk `            p[@(k)] = alpha*C@(c)[@(r)];`
            @endiif
            @iif beta = 1
@ROUT blk2C `            C@(c)[@(r)] += alpha*p[@(k)];`
@ROUT C2blk `            p[@(k)] += alpha*C@(c)[@(r)];`
            @endiif
            @iif beta = -1
@ROUT blk2C `            C@(c)[@(r)] = alpha*p[@(k)] - C@(c)[@(r)];`
@ROUT C2blk `            p[@(k)] = alpha*C@(c)[@(r)] - p[@(k)];`
            @endiif
            @iif @iexp @(beta) 0 ! @(beta) 1 ! & @(beta) -1 ! &
@ROUT blk2C `            C@(c)[@(r)] = beta*C@(c)[@(r)] + alpha*p[@(k)];`
@ROUT C2blk `            p[@(k)] = beta*p[@(k)] + alpha*C@(c)[@(r)];`
            @endiif
         @endiif
@ROUT blk2C 
         @endiif
@ROUT blk2C C2blk
         @iexp i @(i) 1 +
      @endiwhile
      @iif n_ = mu
            C@(j) += @(mu);
      @endiif
      @iexp j @(j) 1 +
   @endiwhile
   @undef k
   @undef i
   @undef j
   @undef c
   @undef r
@ENDPROC
@BEGINPROC doBlock m_ n_
   @define i @dum@
   @define j @dum@
   @define k @dum@
   @iexp j 0
   @iwhile j < @(n_)
      @iexp i 0
      @iwhile i < @(m_)
         @iexp k @(j) @(mu) * @(i) +
         @iif alpha = 1
            @iif beta = 0
@ROUT blk2C `            C@(j)[@(i)] = p[@(k)];`
@ROUT C2blk `            p[@(k)] = C@(j)[@(i)];`
            @endiif
            @iif beta = 1
@ROUT blk2C `            C@(j)[@(i)] += p[@(k)];`
@ROUT C2blk `            p[@(k)] += C@(j)[@(i)];`
            @endiif
            @iif beta = -1
@ROUT blk2C `            C@(j)[@(i)] = p[@(k)] - C@(j)[@(i)];`
@ROUT C2blk `            p[@(k)] = C@(j)[@(i)] - p[@(k)];`
            @endiif
            @iif @iexp @(beta) 0 ! @(beta) 1 ! & @(beta) -1 ! &
@ROUT blk2C `            C@(j)[@(i)] = beta*C@(j)[@(i)] + p[@(k)];`
@ROUT C2blk `            p[@(k)] = beta*p[@(k)] + C@(j)[@(i)];`
            @endiif
         @endiif
         @iif alpha = -1
            @iif beta = 0
@ROUT blk2C `            C@(j)[@(i)] = -p[@(k)];`
@ROUT C2blk `            p[@(k)] = -C@(j)[@(i)];`
            @endiif
            @iif beta = 1
@ROUT blk2C `            C@(j)[@(i)] -= p[@(k)];`
@ROUT C2blk `            p[@(k)] -= C@(j)[@(i)];`
            @endiif
            @iif beta = -1
@ROUT blk2C `            C@(j)[@(i)] = -C@(j)[@(i)] - p[@(k)];`
@ROUT C2blk `            p[@(k)] = -C@(j)[@(i)] - p[@(k)];`
            @endiif
            @iif @iexp @(beta) 0 ! @(beta) 1 ! & @(beta) -1 ! &
@ROUT blk2C `            C@(j)[@(i)] = beta*C@(j)[@(i)] - p[@(k)];`
@ROUT C2blk `            p[@(k)] = beta*p[@(k)] - C@(j)[@(i)];`
            @endiif
         @endiif
         @iif @iexp @(alpha) 1 ! @(alpha) -1 ! &
            @iif beta = 0
@ROUT blk2C `            C@(j)[@(i)] = alpha*p[@(k)];`
@ROUT C2blk `            p[@(k)] = alpha*C@(j)[@(i)];`
            @endiif
            @iif beta = 1
@ROUT blk2C `            C@(j)[@(i)] += alpha*p[@(k)];`
@ROUT C2blk `            p[@(k)] += alpha*C@(j)[@(i)];`
            @endiif
            @iif beta = -1
@ROUT blk2C `            C@(j)[@(i)] = alpha*p[@(k)] - C@(j)[@(i)];`
@ROUT C2blk `            p[@(k)] = alpha*C@(j)[@(i)] - p[@(k)];`
            @endiif
            @iif @iexp @(beta) 0 ! @(beta) 1 ! & @(beta) -1 ! &
@ROUT blk2C `            C@(j)[@(i)] = beta*C@(j)[@(i)] + alpha*p[@(k)];`
@ROUT C2blk `            p[@(k)] = beta*p[@(k)] + alpha*C@(j)[@(i)];`
            @endiif
         @endiif
         @iexp i @(i) 1 +
      @endiwhile
      @iif m_ = mu
            C@(j) += @(mu);
      @endiif
      @iexp j @(j) 1 +
   @endiwhile
   @undef k
   @undef i
   @undef j
@ENDPROC
@iif cpvl = 1
void @(rtnm)
(
   const size_t M,      /* number of rows in A */
   const size_t N,      /* number of columns in A */
   @ROUT blk2C
   const @(typ) alpha,  /* scalar for b */
   const @(typ) *b,     /* matrix stored in @(mu)x@(nu)-major order */
   const @(typ) beta,   /* scalar for C */
   @(typ) *C,           /* matrix to be copied to access-major format */
   const size_t ldc     /* stride between row elements */
   @ROUT C2blk
   const @(typ) alpha,  /* scalar for C */
   const @(typ) *C,     /* matrix to be copied to access-major format */
   const size_t ldc,    /* stride between row elements */
   const @(typ) beta,   /* scalar for b */
   @(typ) *b            /* matrix stored in @(mu)x@(nu)-major order */
   @ROUT C2blk blk2C
)
@endiif
@iif cpvl > 1
static INLINE void a2c_1(const size_t M, const size_t N, const @(typ) alpha, 
                         const @(typ) *b, const SCALAR beta, 
                         @(typ) *C, ATL_CSZT ldc)
@endiif
{
   const unsigned int mf = M/@(mu), nf = N/@(nu);
   const unsigned int m = mf*@(mu), n = nf*@(nu), mr = M-m, nr = N-n;
@iif TRI = 1
   unsigned int pansz = @(bs);
   const size_t incC0 = (ldc+1)*@(nu);
@endiif
@iif TRI = 0
   const unsigned int pansz = (nr) ? (nf+1)*@(bs) : nf*@(bs); // bs=@(bs)
   const size_t incC = ldc*@(nu) - m;
@endiif
   unsigned int i, j;
@ROUT blk2C `   @declare "   @(typ) " n n ";"`
@ROUT C2blk `   @declare "   const @(typ) " n n ";"`
      *C0=C
      @define j @1@
      @iwhile j < @(nu)
         @iexp i @(j) -1 +
         *C@(j)=C@(i)+ldc
         @iexp j @(j) 1 +
      @endiwhile
   @enddeclare
@iif TRI = 1
   for (j=0; j < nf; j++)
@endiif
@iif TRI = 0
   for (j=nf; j; j--, b += @(bs))
@endiif
   {
@ROUT blk2C `      const @(typ) *p = b;`
@ROUT C2blk `      @(typ) *p = b;`
@iif TRI = 1
      unsigned int psz = pansz+@(bs), incC = incC0 - (mf-j)*@(mu);

      @callproc doDiBlock @(nu)
      p += pansz;
      for (i=j+1; i < mf; i++, p += psz, psz += @(bs))
@endiif
@iif TRI = 0
      for (i=mf; i; i--, p += pansz)
@endiif
      {
         @callproc doBlock @(mu) @(nu)
      }
      switch(mr)
      {
   @iexp m 1
   @iwhile m < @(mu)
      case @(m):
      @callproc doBlock @(m) @(nu)
      @iexp m @(m) 1 +
         break;
   @endiwhile
      default:;
      }
   @iexp j 0
   @iwhile j < @(nu)
      C@(j) += incC;
      @iexp j @(j) 1 +
   @endiwhile
@iif TRI = 1
      pansz += @(bs);
      b += pansz;
@endiif
   }
@iif nu > 1
   switch(nr)
   {
@ROUT blk2C `      const @(typ) *p;`
@ROUT C2blk `      @(typ) *p;`
   @iexp n 1
   @iwhile n < @(nu)
   case @(n):
      p = b;
@iif TRI = 1
         @callproc doDiBlock @(n)
      break;
@endiif
@iif TRI = 0
      for (i=0; i < mf; i++, p += pansz)
      {
         @callproc doBlock @(mu) @(n)
      }
      switch(mr)
      {
   @iexp m 1
   @iwhile m < @(mu)
      case @(m):
      @callproc doBlock @(m) @(n)
      @iexp m @(m) 1 +
         break;
   @endiwhile
      default:;
      }
      break;
@endiif
      @iexp n @(n) 1 +
   @endiwhile
   default:;
   }
@endiif
}
@iif TRI = 1
@SKIP this proc handles only one element
@SKIP IN : alpha, beta, C, b 
@BEGINPROC doElementT r_ c_ k_
   @iif alpha = 1
      @iif beta = 0
@ROUT blk2C `            C@(c_)[@(r_)] = b[@(k_)];`
@ROUT C2blk `            b[@(k_)] = C@(c_)[@(r_)];`
      @endiif
      @iif beta = 1
@ROUT blk2C `            C@(c_)[@(r_)] += b[@(k_)];`
@ROUT C2blk `            b[@(k_)] += C@(c_)[@(r_)];`
      @endiif
      @iif beta = -1
@ROUT blk2C `            C@(c_)[@(r_)] = b[@(k_)] - C@(c_)[@(r_)];`
@ROUT C2blk `            b[@(k_)] = C@(c_)[@(r_)] - b[@(k_)];`
      @endiif
      @iif @iexp @(beta) 0 ! @(beta) 1 ! & @(beta) -1 ! &
@ROUT blk2C `            C@(c_)[@(r_)] = beta*C@(c_)[@(r_)] + b[@(k_)];`
@ROUT C2blk `            b[@(k_)] = beta*b[@(k_)] + C@(c_)[@(r_)];`
      @endiif
   @endiif
   @iif alpha = -1
      @iif beta = 0
@ROUT blk2C `            C@(c_)[@(r_)] = -b[@(k_)];`
@ROUT C2blk `            b[@(k_)] = -C@(c_)[@(r_)];`
      @endiif
      @iif beta = 1
@ROUT blk2C `            C@(c_)[@(r_)] -= b[@(k_)];`
@ROUT C2blk `            b[@(k_)] -= C@(c_)[@(r_)];`
      @endiif
      @iif beta = -1
@ROUT blk2C `            C@(c_)[@(r_)] = -C@(c_)[@(r_)] - b[@(k_)];`
@ROUT C2blk `            b[@(k_)] = -C@(c_)[@(r_)] - b[@(k_)];`
      @endiif
      @iif @iexp @(beta) 0 ! @(beta) 1 ! & @(beta) -1 ! &
@ROUT blk2C `            C@(c_)[@(r_)] = beta*C@(c_)[@(r_)] - b[@(k_)];`
@ROUT C2blk `            b[@(k_)] = beta*b[@(k_)] - C@(c_)[@(r_)];`
      @endiif
   @endiif
   @iif @iexp @(alpha) 1 ! @(alpha) -1 ! &
      @iif beta = 0
@ROUT blk2C `            C@(c_)[@(r_)] = alpha*b[@(k_)];`
@ROUT C2blk `            b[@(k_)] = alpha*C@(c_)[@(r_)];`
      @endiif
      @iif beta = 1
@ROUT blk2C `            C@(c_)[@(r_)] += alpha*b[@(k_)];`
@ROUT C2blk `            b[@(k_)] += alpha*C@(c_)[@(r_)];`
      @endiif
      @iif beta = -1
@ROUT blk2C `            C@(c_)[@(r_)] = alpha*b[@(k_)] - C@(c_)[@(r_)];`
@ROUT C2blk `            b[@(k_)] = alpha*C@(c_)[@(r_)] - b[@(k_)];`
      @endiif
      @iif @iexp @(beta) 0 ! @(beta) 1 ! & @(beta) -1 ! &
@ROUT blk2C `            C@(c_)[@(r_)] = beta*C@(c_)[@(r_)] + alpha*b[@(k_)];`
@ROUT C2blk `            b[@(k_)] = beta*b[@(k_)] + alpha*C@(c_)[@(r_)];`
      @endiif
   @endiif
@ENDPROC
@SKIP handles square block 
@BEGINPROC doBlockT m_ n_
   @define i @dum@
   @define j @dum@
   @define k @dum@
   @iexp j 0
   @iwhile j < @(n_)
      @iexp i 0
      @iwhile i < @(m_)
         @iexp k @(i) @(mu) * @(j) +
         @callproc doElementT @(i) @(j) @(k)  
         @iexp i @(i) 1 +
      @endiwhile
      @iif m_ = mu
            C@(j) += @(mu);
      @endiif
      @iexp j @(j) 1 +
   @endiwhile
   @undef k
   @undef i
   @undef j
@ENDPROC
@skip handles diagonal block
@BEGINPROC doDiBlockT n_
   @define i @dum@
   @define j @dum@
   @define k @dum@
   @iexp j 0
   @iwhile j < @(n_)
      @iexp i 0
      @iwhile i < @(n_)
         @iexp k @(i) @(mu) * @(j) +
@ROUT blk2C
         @iexp r @(i)
         @iexp c @(j)
         @iif j } i
      @callproc doElementT @(r) @(c) @(k)
         @endiif
@ROUT C2blk
         @iif j < i
            @iexp r @(j)
            @iexp c @(i)
         @endiif
         @iif j } i
            @iexp r @(i)
            @iexp c @(j)
         @endiif
      @callproc doElementT @(r) @(c) @(k)
@ROUT blk2C C2blk
         @iexp i @(i) 1 +
      @endiwhile
      @iif n_ = mu
            C@(j) += @(mu);
      @endiif
      @iexp j @(j) 1 +
   @endiwhile
   @undef k
   @undef i
   @undef j
@ENDPROC
@ROUT C2blk `#if 0`
#ifndef Mjoin
   #define Mjoin(pre, nam) my_join(pre, nam)
   #define my_join(pre, nam) pre ## nam
#endif
/*
 * The block is assumed to store L, this function does a transpose while
 * copying so that it is transferred with Upper portion of C
 */
void Mjoin(ATL_USERCPMM,_L2UT)
(
   const size_t M,      /* number of rows in A */
   const size_t N,      /* number of columns in A */
   @ROUT blk2C
   const @(typ) alpha,  /* scalar for b */
   const @(typ) *b,     /* matrix stored in @(mu)x@(nu)-major order */
   const @(typ) beta,   /* scalar for C */
   @(typ) *C,           /* matrix to be copied to access-major format */
   const size_t ldc     /* stride between row elements */
   @ROUT C2blk
   const @(typ) alpha,  /* scalar for C */
   const @(typ) *C,     /* matrix to be copied to access-major format */
   const size_t ldc,    /* stride between row elements */
   const @(typ) beta,   /* scalar for b */
   @(typ) *b            /* matrix stored in @(mu)x@(nu)-major order */
   @ROUT C2blk blk2C
)
{
   const unsigned int mf = M/@(mu), nf = N/@(nu);
   const unsigned int m = mf*@(mu), n = nf*@(nu), mr = M-m, nr = N-n;
   const size_t incC0 = ldc*@(nu);
   unsigned int i, j;
@ROUT blk2C `   @declare "   @(typ) " n n ";"`
@ROUT C2blk `   @declare "   const @(typ) " n n ";"`
      *C0=C
      @define j @1@
      @iwhile j < @(nu)
         @iexp i @(j) -1 +
         *C@(j)=C@(i)+ldc
         @iexp j @(j) 1 +
      @endiwhile
   @enddeclare
   for (j=0; j < nf; j++)
   {
      unsigned int incC = incC0 - (j+1)*@(mu);
      for (i=0; i < j; i++, b += @(bs))
      {
         @callproc doBlockT @(mu) @(nu)
      }
      @callproc doDiBlockT @(nu)
   @iexp j 0
   @iwhile j < @(nu)
      C@(j) += incC;
      @iexp j @(j) 1 +
   @endiwhile
      b += @(bs);
   }
@iif nu > 1
   switch(nr)
   {
   @iexp n 1
   @iwhile n < @(nu)
   case @(n):
      for (i=0; i < mf; i++, b += @(bs))
      {
         @callproc doBlockT @(mu) @(n)
      }
      switch(mr)
      {
   @iexp m 1
   @iwhile m < @(mu)
      case @(m):
      @skip Assumption for sryk  m = n" 
      @callproc doDiBlockT @(m) 
      @iexp m @(m) 1 +
         break;
   @endiwhile
      default:;
      }
      break;
      @iexp n @(n) 1 +
   @endiwhile
   default:;
   }
@endiif
}
@ROUT C2blk `#endif`
@endiif
@PRE C Z
   @iexp betX 0 @(beta) ! 1 @(beta) ! & -1 @(beta) ! &
   @iexp alpX 0 @(alpha) ! 1 @(alpha) ! & -1 @(alpha) ! &
@SKIP blksz = ((mu*nu+vlen-1)/vlen)*vlen
@iexp bs @(vl) @(mu) @(nu) * @(vl) + -1 + / @(vl) *
// HERE vl=@(vl), mu=@(mu), nu=@(nu) bs=@(bs)
@SKIP IN: mu, nu, beta, alpha
@BEGINPROC doDiBlock n_
   @define i @dum@
   @define ir @dum@
   @define ii @dum@
   @define j @dum@
   @define k @dum@
   @iexp j 0
   @iwhile j < @(n_)
      @iexp i 0
      @iwhile i < @(n_)
@ROUT C2blk 
         @iif j > i
            @iexp ir @(j) @(j) +
            @define h @@(i)@
         @endiif
         @iif j { i
            @iexp ir @(i) @(i) +
            @define h @@(j)@
         @endiif
         @iexp ii @(ir) 1 +
         @iexp k @(j) @(mu) * @(i) +
@ROUT blk2C 
         @iexp ir @(i) @(i) +
         @iexp ii @(ir) 1 +
         @iexp k @(j) @(mu) * @(i) +
         @iif j { i
@ROUT blk2C C2blk
         @iif alpha = 1
            @iif beta = 0
@ROUT blk2C 
            C@(j)[@(ir)] = pr[@(k)];  // i=@(i), j=@(j), ir=@(ir), k=@(k);
            C@(j)[@(ii)] = pi[@(k)];
@ROUT C2blk 
            pr[@(k)] = C@(h)[@(ir)];
            pi[@(k)] = C@(h)[@(ii)];
@ROUT blk2C C2blk
            @endiif
            @iif beta = 1
@ROUT blk2C 
            C@(j)[@(ir)] += pr[@(k)];
            C@(j)[@(ii)] += pi[@(k)];
@ROUT C2blk 
            pr[@(k)] += C@(h)[@(ir)];
@ROUT blk2C C2blk
            @endiif
            @iif beta = -1
@ROUT blk2C 
            C@(j)[@(ir)] = pr[@(k)] - C@(j)[@(ir)];
            C@(j)[@(ii)] = pi[@(k)] - C@(j)[@(ii)];
@ROUT C2blk 
            pr[@(k)] = C@(h)[@(ir)] - pr[@(k)];
            pi[@(k)] = C@(h)[@(ii)] - pi[@(k)];
@ROUT blk2C C2blk
            @endiif
            @iif @iexp @(beta) 0 ! @(beta) 1 ! & @(beta) -1 ! &
@ROUT blk2C 
            { 
               const register @(typ) rc=C@(j)[@(ir)], ic=C@(j)[@(ii)];
               register @(typ) rr=pr[@(k)], ir=pi[@(k)];
               rr += rc * rb;
               ir += ic * rb;
               rr -= ic * ib;
               ir += rc * ib;
               C@(j)[@(ir)] = rr;
               C@(j)[@(ii)] = ir;
            }
@ROUT C2blk 
            { 
               const register @(typ) rc=pr[@(k)], ic=pi[@(k)];
               register @(typ) rr=C@(h)[@(ir)], ir=C@(h)[@(ii)];
               rr += rc * rb;
               ir += ic * rb;
               rr -= ic * ib;
               ir += rc * ib;
               pr[@(k)] = rr;
               pi[@(k)] = ic;
            }
@ROUT blk2C C2blk
            @endiif
         @endiif
         @iif alpha = -1
            @iif beta = 0
@ROUT blk2C 
            C@(j)[@(ir)] = -pr[@(k)];
            C@(j)[@(ii)] = -pi[@(k)];
@ROUT C2blk 
            pr[@(k)] = -C@(h)[@(ir)];
            pi[@(k)] = -C@(h)[@(ii)];
@ROUT blk2C C2blk
            @endiif
            @iif beta = 1
@ROUT blk2C 
            C@(j)[@(ir)] -= pr[@(k)];
            C@(j)[@(ii)] -= pi[@(k)];
@ROUT C2blk 
            pr[@(k)] -= C@(h)[@(ir)];
            pi[@(k)] -= C@(h)[@(ii)];
@ROUT blk2C C2blk
            @endiif
            @iif beta = -1
@ROUT blk2C 
            C@(j)[@(ir)] = -C@(j)[@(ir)] - pr[@(k)];
            C@(j)[@(ii)] = -C@(j)[@(ii)] - pi[@(k)];
@ROUT C2blk 
            pr[@(k)] = -C@(h)[@(ir)] - pr[@(k)];
            pi[@(k)] = -C@(h)[@(ii)] - pi[@(k)];
@ROUT blk2C C2blk
            @endiif
            @iif @iexp @(beta) 0 ! @(beta) 1 ! & @(beta) -1 ! &
@ROUT blk2C 
            { 
               const register @(typ) rc=C@(j)[@(ir)], ic=C@(j)[@(ii)];
               register @(typ) rr = -pr[@(k)], ir = -pi[@(k)];
               rr += rc * rb;
               ir += ic * rb;
               rr -= ic * ib;
               ir += rc * ib;
               C@(j)[@(ir)] = rr;
               C@(j)[@(ii)] = ir;
            }
@ROUT C2blk 
            { 
               const register @(typ) rc=pr[@(k)], ic=pi[@(k)];
               register @(typ) rr = -C@(h)[@(ir)], ir = -C@(h)[@(ii)];
               rr += rc * rb;
               ir += ic * rb;
               rr -= ic * ib;
               ir += rc * ib;
               pr[@(k)] = rr;
               pi[@(k)] = ic;
            }
@ROUT blk2C C2blk
            @endiif
         @endiif
         @iif @iexp @(alpha) 1 ! @(alpha) -1 ! &
            @iif beta = 0
@ROUT blk2C 
            { 
               const register @(typ) rc=pr[@(k)], ic=pi[@(k)];
               register @(typ) rr, ir;
               rr = rc * ra;
               ir = ic * ra;
               rr -= ic * ia;
               ir += rc * ia;
               C@(j)[@(ir)] = rr;
               C@(j)[@(ii)] = ir;
            }
@ROUT C2blk 
            { 
               const register @(typ) rc=C@(h)[@(ir)], ic=C@(h)[@(ii)];
               register @(typ) rr, ir;
               rr  = rc * ra;
               ir  = ic * ra;
               rr -= ic * ia;
               ir += rc * ia;
               pr[@(k)] = rr;
               pi[@(k)] = ir;
            }
@ROUT blk2C C2blk
            @endiif
            @iif beta = 1
@ROUT blk2C 
            { 
               const register @(typ) rc=pr[@(k)], ic=pi[@(k)];
               register @(typ) rr=C@(j)[@(ir)], ir=C@(j)[@(ii)];
               rr += rc * ra;
               ir += ic * ra;
               rr -= ic * ia;
               ir += rc * ia;
               C@(j)[@(ir)] = rr;
               C@(j)[@(ii)] = ir;
            }
@ROUT C2blk 
            { 
               const register @(typ) rc=C@(h)[@(ir)], ic=C@(h)[@(ii)];
               register @(typ) rr=pr[@(k)], ir=pi[@(k)];
               rr += rc * ra;
               ir += ic * ra;
               rr -= ic * ia;
               ir += rc * ia;
               pr[@(k)] = rr;
               pi[@(k)] = ir;
            }
@ROUT blk2C C2blk
            @endiif
            @iif beta = -1
@ROUT blk2C 
            { 
               const register @(typ) rc=pr[@(k)], ic=pi[@(k)];
               register @(typ) rr = -C@(j)[@(ir)], ir = -C@(j)[@(ii)];
               rr += rc * ra;
               ir += ic * ra;
               rr -= ic * ia;
               ir += rc * ia;
               C@(j)[@(ir)] = rr;
               C@(j)[@(ii)] = ir;
            }
@ROUT C2blk 
            { 
               const register @(typ) rc=C@(h)[@(ir)], ic=C@(h)[@(ii)];
               const register @(typ) rr = -pr[@(k)], ir = -pi[@(k)];
               rr += rc * ra;
               ir += ic * ra;
               rr -= ic * ia;
               ir += rc * ia;
               pr[@(k)] = rr;
               pi[@(k)] = ir;
            }
@ROUT blk2C C2blk
            @endiif
            @iif @iexp @(beta) 0 ! @(beta) 1 ! & @(beta) -1 ! &
@ROUT blk2C 
            {
               register @(typ) rc=C@(j)[@(ir)], ic=C@(j)[@(ii)];
               register @(typ) rB=pr[@(k)], iB=pi[@(k)], r0, i0, r1, i1;
               r0  = rb * rc;
               r1  = ra * rB;
               i0  = rb * ic;
               i1  = ra * iB;
               r0 -= ib * ic;
               i1 += ib * rc;
               r1 -= ia * iB;
               i1 += ia * rB;
               C@(j)[@(ir)] = r0 + r1;
               C@(j)[@(ii)] = i0 + i1;
            }
@ROUT C2blk 
            {
               register @(typ) rB=C@(h)[@(ir)], iB=C@(h)[@(ii)];
               register @(typ) rc=pr[@(k)], ic=pi[@(k)], r0, i0, r1, i1;
               r0  = rb * rc;
               r1  = ra * rB;
               i0  = rb * ic;
               i1  = ra * iB;
               r0 -= ib * ic;
               i1 += ib * rc;
               r1 -= ia * iB;
               i1 += ia * rB;
               pr[@(k)] = r0 + r1;
               pi[@(k)] = i0 + i1;
            }
@ROUT blk2C C2blk
            @endiif
         @endiif
@ROUT blk2C
         @endiif
@ROUT blk2C C2blk
         @iexp i @(i) 1 +
      @endiwhile
      @iexp i @(mu) @(mu) +
      @iif n_ = mu
            C@(j) += @(i);
      @endiif
@ROUT C2blk `      @undef h`
      @iexp j @(j) 1 +
   @endiwhile
   @undef k
   @undef ii
   @undef ir
   @undef j
@ENDPROC
@BEGINPROC doBlock m_ n_
   @define i @dum@
   @define ir @dum@
   @define ii @dum@
   @define j @dum@
   @define k @dum@
   @iexp j 0
   @iwhile j < @(n_)
      @iexp i 0
      @iwhile i < @(m_)
         @iexp ir @(i) @(i) +
         @iexp ii @(ir) 1 +
         @iexp k @(j) @(mu) * @(i) +
         @iif alpha = 1
            @iif beta = 0
@ROUT blk2C 
            C@(j)[@(ir)] = pr[@(k)];
            C@(j)[@(ii)] = pi[@(k)];
@ROUT C2blk 
            pr[@(k)] = C@(j)[@(ir)];
            pi[@(k)] = C@(j)[@(ii)];
@ROUT blk2C C2blk
            @endiif
            @iif beta = 1
@ROUT blk2C 
            C@(j)[@(ir)] += pr[@(k)];
            C@(j)[@(ii)] += pi[@(k)];
@ROUT C2blk 
            pr[@(k)] += C@(j)[@(ir)];
@ROUT blk2C C2blk
            @endiif
            @iif beta = -1
@ROUT blk2C 
            C@(j)[@(ir)] = pr[@(k)] - C@(j)[@(ir)];
            C@(j)[@(ii)] = pi[@(k)] - C@(j)[@(ii)];
@ROUT C2blk 
            pr[@(k)] = C@(j)[@(ir)] - pr[@(k)];
            pi[@(k)] = C@(j)[@(ii)] - pi[@(k)];
@ROUT blk2C C2blk
            @endiif
            @iif @iexp @(beta) 0 ! @(beta) 1 ! & @(beta) -1 ! &
@ROUT blk2C 
            { 
               const register @(typ) rc=C@(j)[@(ir)], ic=C@(j)[@(ii)];
               register @(typ) rr=pr[@(k)], ir=pi[@(k)];
               rr += rc * rb;
               ir += ic * rb;
               rr -= ic * ib;
               ir += rc * ib;
               C@(j)[@(ir)] = rr;
               C@(j)[@(ii)] = ir;
            }
@ROUT C2blk 
            { 
               const register @(typ) rc=pr[@(k)], ic=pi[@(k)];
               register @(typ) rr=C@(j)[@(ir)], ir=C@(j)[@(ii)];
               rr += rc * rb;
               ir += ic * rb;
               rr -= ic * ib;
               ir += rc * ib;
               pr[@(k)] = rr;
               pi[@(k)] = ic;
            }
@ROUT blk2C C2blk
            @endiif
         @endiif
         @iif alpha = -1
            @iif beta = 0
@ROUT blk2C 
            C@(j)[@(ir)] = -pr[@(k)];
            C@(j)[@(ii)] = -pi[@(k)];
@ROUT C2blk 
            pr[@(k)] = -C@(j)[@(ir)];
            pi[@(k)] = -C@(j)[@(ii)];
@ROUT blk2C C2blk
            @endiif
            @iif beta = 1
@ROUT blk2C 
            C@(j)[@(ir)] -= pr[@(k)];
            C@(j)[@(ii)] -= pi[@(k)];
@ROUT C2blk 
            pr[@(k)] -= C@(j)[@(ir)];
            pi[@(k)] -= C@(j)[@(ii)];
@ROUT blk2C C2blk
            @endiif
            @iif beta = -1
@ROUT blk2C 
            C@(j)[@(ir)] = -C@(j)[@(ir)] - pr[@(k)];
            C@(j)[@(ii)] = -C@(j)[@(ii)] - pi[@(k)];
@ROUT C2blk 
            pr[@(k)] = -C@(j)[@(ir)] - pr[@(k)];
            pi[@(k)] = -C@(j)[@(ii)] - pi[@(k)];
@ROUT blk2C C2blk
            @endiif
            @iif @iexp @(beta) 0 ! @(beta) 1 ! & @(beta) -1 ! &
@ROUT blk2C 
            { 
               const register @(typ) rc=C@(j)[@(ir)], ic=C@(j)[@(ii)];
               register @(typ) rr = -pr[@(k)], ir = -pi[@(k)];
               rr += rc * rb;
               ir += ic * rb;
               rr -= ic * ib;
               ir += rc * ib;
               C@(j)[@(ir)] = rr;
               C@(j)[@(ii)] = ir;
            }
@ROUT C2blk 
            { 
               const register @(typ) rc=pr[@(k)], ic=pi[@(k)];
               register @(typ) rr = -C@(j)[@(ir)], ir = -C@(j)[@(ii)];
               rr += rc * rb;
               ir += ic * rb;
               rr -= ic * ib;
               ir += rc * ib;
               pr[@(k)] = rr;
               pi[@(k)] = ic;
            }
@ROUT blk2C C2blk
            @endiif
         @endiif
         @iif @iexp @(alpha) 1 ! @(alpha) -1 ! &
            @iif beta = 0
@ROUT blk2C 
            { 
               const register @(typ) rc=pr[@(k)], ic=pi[@(k)];
               register @(typ) rr, ir;
               rr = rc * ra;
               ir = ic * ra;
               rr -= ic * ia;
               ir += rc * ia;
               C@(j)[@(ir)] = rr;
               C@(j)[@(ii)] = ir;
            }
@ROUT C2blk 
            { 
               const register @(typ) rc=C@(j)[@(ir)], ic=C@(j)[@(ii)];
               register @(typ) rr, ir;
               rr  = rc * ra;
               ir  = ic * ra;
               rr -= ic * ia;
               ir += rc * ia;
               pr[@(k)] = rr;
               pi[@(k)] = ir;
            }
@ROUT blk2C C2blk
            @endiif
            @iif beta = 1
@ROUT blk2C 
            { 
               const register @(typ) rc=pr[@(k)], ic=pi[@(k)];
               register @(typ) rr=C@(j)[@(ir)], ir=C@(j)[@(ii)];
               rr += rc * ra;
               ir += ic * ra;
               rr -= ic * ia;
               ir += rc * ia;
               C@(j)[@(ir)] = rr;
               C@(j)[@(ii)] = ir;
            }
@ROUT C2blk 
            { 
               const register @(typ) rc=C@(j)[@(ir)], ic=C@(j)[@(ii)];
               register @(typ) rr=pr[@(k)], ir=pi[@(k)];
               rr += rc * ra;
               ir += ic * ra;
               rr -= ic * ia;
               ir += rc * ia;
               pr[@(k)] = rr;
               pi[@(k)] = ir;
            }
@ROUT blk2C C2blk
            @endiif
            @iif beta = -1
@ROUT blk2C 
            { 
               const register @(typ) rc=pr[@(k)], ic=pi[@(k)];
               register @(typ) rr = -C@(j)[@(ir)], ir = -C@(j)[@(ii)];
               rr += rc * ra;
               ir += ic * ra;
               rr -= ic * ia;
               ir += rc * ia;
               C@(j)[@(ir)] = rr;
               C@(j)[@(ii)] = ir;
            }
@ROUT C2blk 
            { 
               const register @(typ) rc=C@(j)[@(ir)], ic=C@(j)[@(ii)];
               register @(typ) rr = -pr[@(k)], ir = -pi[@(k)];
               rr += rc * ra;
               ir += ic * ra;
               rr -= ic * ia;
               ir += rc * ia;
               pr[@(k)] = rr;
               pi[@(k)] = ir;
            }
@ROUT blk2C C2blk
            @endiif
            @iif @iexp @(beta) 0 ! @(beta) 1 ! & @(beta) -1 ! &
@ROUT blk2C 
            {
               register @(typ) rc=C@(j)[@(ir)], ic=C@(j)[@(ii)];
               register @(typ) rB=pr[@(k)], iB=pi[@(k)], r0, i0, r1, i1;
               r0  = rb * rc;
               r1  = ra * rB;
               i0  = rb * ic;
               i1  = ra * iB;
               r0 -= ib * ic;
               i1 += ib * rc;
               r1 -= ia * iB;
               i1 += ia * rB;
               C@(j)[@(ir)] = r0 + r1;
               C@(j)[@(ii)] = i0 + i1;
            }
@ROUT C2blk 
            {
               register @(typ) rB=C@(j)[@(ir)], iB=C@(j)[@(ii)];
               register @(typ) rc=pr[@(k)], ic=pi[@(k)], r0, i0, r1, i1;
               r0  = rb * rc;
               r1  = ra * rB;
               i0  = rb * ic;
               i1  = ra * iB;
               r0 -= ib * ic;
               i1 += ib * rc;
               r1 -= ia * iB;
               i1 += ia * rB;
               pr[@(k)] = r0 + r1;
               pi[@(k)] = i0 + i1;
            }
@ROUT blk2C C2blk
            @endiif
         @endiif
         @iexp i @(i) 1 +
      @endiwhile
      @iexp i @(mu) @(mu) +
      @iif m_ = mu
            C@(j) += @(i);
      @endiif
      @iexp j @(j) 1 +
   @endiwhile
   @undef k
   @undef ii
   @undef ir
   @undef j
@ENDPROC
@ROUT blk2C C2blk
@iif cpvl = 1
void @(rtnm)
(
   const size_t M,      /* number of rows in A */
   const size_t N,      /* number of columns in A */
   const @(typ) *alpha, /* scalar for b */
   @ROUT blk2C
   const @(typ) *rC,    /* real block stored in @(mu)x@(nu)-major order */
   const @(typ) *iC,    /* imag block stored in @(mu)x@(nu)-major order */
   const @(typ) *beta,  /* scalar for C */
   @(typ) *C,           /* matrix to be copied to access-major format */
   const size_t ldc     /* stride between row elements */
   @ROUT C2blk
   const @(typ) *C,     /* matrix to be copied to access-major format */
   const size_t ldc,    /* stride between row elements */
   const @(typ) *beta,  /* scalar for C */
   @(typ) *rC,          /* real block stored in @(mu)x@(nu)-major order */
   @(typ) *iC           /* imag block stored in @(mu)x@(nu)-major order */
   @ROUT C2blk blk2C
)
@endiif
@iif cpvl > 1
static INLINE void a2c_1(const size_t M, const size_t N, const @(typ) alpha, 
                         const @(typ) *b, const SCALAR beta, 
                         @(typ) *C, ATL_CSZT ldc)
@endiif
{
   const unsigned int mf = M/@(mu), nf = N/@(nu);
   const unsigned int m = mf*@(mu), n = nf*@(nu), mr = M-m, nr = N-n;
@iif TRI = 1
   unsigned int pansz = @(bs);
   const size_t ldc2 = ldc+ldc, incC0 = (ldc2+2)*@(nu);
@endiif
@iif TRI = 0
   const unsigned int pansz = (nr) ? (nf+1)*@(bs) : nf*@(bs); // bs=@(bs)
   const size_t incC = (ldc*@(nu) - m)<<1, ldc2 = ldc+ldc;
@endiif
   unsigned int i, j;
   @iif alpX ! 0
   const register @(typ) ra=(*alpha), ia=alpha[1];
   @endiif
   @iif betX ! 0
   const register @(typ) rb=(*beta), ib=beta[1];
   @endiif
@ROUT blk2C `   @declare "   @(typ) " n n ";"`
@ROUT C2blk `   @declare "   const @(typ) " n n ";"`
      *C0=C
      @define j @1@
      @iwhile j < @(nu)
         @iexp i @(j) -1 +
         *C@(j)=C@(i)+ldc2
         @iexp j @(j) 1 +
      @endiwhile
   @enddeclare
@iif TRI = 1
   for (j=0; j < nf; j++)
@endiif
@iif TRI = 0
   for (j=nf; j; j--, rC += @(bs), iC += @(bs))
@endiif
   {
@ROUT blk2C `      const @(typ) *pr = rC, *pi = iC;`
@ROUT C2blk `      @(typ) *pr = rC, *pi = iC;`
@iif TRI = 1
      unsigned int psz = pansz+@(bs), incC = incC0 - (mf-j)*(@(mu)+@(mu));
      @callproc doDiBlock @(nu)
      pr += pansz; pi += pansz;
      for (i=j+1; i < mf; i++, pr += psz, pi += psz, psz += @(bs))
@endiif
@iif TRI = 0
      for (i=mf; i; i--, pr += pansz, pi += pansz)
@endiif
      {
         @callproc doBlock @(mu) @(nu)
      }
      switch(mr)
      {
   @iexp m 1
   @iwhile m < @(mu)
      case @(m):
      @callproc doBlock @(m) @(nu)
      @iexp m @(m) 1 +
         break;
   @endiwhile
      default:;
      }
   @iexp j 0
   @iwhile j < @(nu)
      C@(j) += incC;
      @iexp j @(j) 1 +
   @endiwhile
@iif TRI = 1
      pansz += @(bs);
      rC += pansz;
      iC += pansz;
@endiif
   }
@iif nu > 1
   switch(nr)
   {
@ROUT blk2C `      const @(typ) *pr, *pi;`
@ROUT C2blk `      @(typ) *pr, *pi;`
   @iexp n 1
   @iwhile n < @(nu)
   case @(n):
      pr = rC; pi = iC;
@iif TRI = 1
      @callproc doDiBlock @(n)
      break;
@endiif
@iif TRI = 0
      for (i=0; i < mf; i++, pr += pansz, pi += pansz)
      {
         @callproc doBlock @(mu) @(n)
      }
      switch(mr)
      {
   @iexp m 1
   @iwhile m < @(mu)
      case @(m):
      @callproc doBlock @(m) @(n)
      @iexp m @(m) 1 +
         break;
   @endiwhile
      default:;
      }
      break;
@endiif
      @iexp n @(n) 1 +
   @endiwhile
   default:;
   }
@endiif
}
@iif TRI = 1
@SKIP handles single element of sub-block
@BEGINPROC doElementT c_ ir_ ii_ k_ 
         @iif alpha = 1
            @iif beta = 0
@ROUT blk2C 
            C@(c_)[@(ir_)] = rC[@(k_)];
            #ifdef Conj_
               C@(c_)[@(ii_)] = -iC[@(k_)];
            #else
               C@(c_)[@(ii_)] = iC[@(k_)];
            #endif
@ROUT C2blk 
            rC[@(k_)] = C@(c_)[@(ir_)];
            #ifdef Conj_
               iC[@(k_)] = -C@(c_)[@(ii_)];
            #else
               iC[@(k_)] = C@(c_)[@(ii_)];
            #endif
@ROUT blk2C C2blk
            @endiif
            @iif beta = 1
@ROUT blk2C 
            C@(c_)[@(ir_)] += rC[@(k_)];
            #ifdef Conj_
               C@(c_)[@(ii_)] -= iC[@(k_)];
            #else
               C@(c_)[@(ii_)] += iC[@(k_)];
            #endif
@ROUT C2blk 
            rC[@(k_)] += C@(c_)[@(ir_)];
@ROUT blk2C C2blk
            @endiif
            @iif beta = -1
@ROUT blk2C 
            C@(c_)[@(ir_)] = rC[@(k_)] - C@(c_)[@(ir_)];
            #ifdef Conj_
               C@(c_)[@(ii_)] = -iC[@(k_)] - C@(c_)[@(ii_)];
            #else
               C@(c_)[@(ii_)] = iC[@(k_)] - C@(c_)[@(ii_)];
            #endif
@ROUT C2blk 
            rC[@(k_)] = C@(c_)[@(ir_)] - rC[@(k_)];
            #ifdef Conj_
               iC[@(k_)] = C@(c_)[@(ii_)] + iC[@(k_)];
            #else
               iC[@(k_)] = C@(c_)[@(ii_)] - iC[@(k_)];
            #endif
@ROUT blk2C C2blk
            @endiif
            @iif @iexp @(beta) 0 ! @(beta) 1 ! & @(beta) -1 ! &
@ROUT blk2C 
            { 
               const register @(typ) rc=C@(c_)[@(ir_)], ic=C@(c_)[@(ii_)];
               register @(typ) rr=rC[@(k_)];
               #ifdef Conj_
                  register @(typ) ir = -iC[@(k_)];
               #else
                  register @(typ) ir =  iC[@(k_)];
               #endif
               rr += rc * rb;
               ir += ic * rb;
               rr -= ic * ib;
               ir += rc * ib;
               C@(c_)[@(ir_)] = rr;
               C@(c_)[@(ii_)] = ir;
            }
@ROUT C2blk 
            { 
               const register @(typ) rc=rC[@(k_)], ic=iC[@(k_)];
               register @(typ) rr=C@(c_)[@(ir_)];
               #ifdef Conj_
                  register @(typ) ir = -C@(c_)[@(ii_)];
               #else
                  register @(typ) ir =  C@(c_)[@(ii_)];
               #endif
               rr += rc * rb;
               ir += ic * rb;
               rr -= ic * ib;
               ir += rc * ib;
               rC[@(k_)] = rr;
               iC[@(k_)] = ic;
            }
@ROUT blk2C C2blk
            @endiif
         @endiif
         @iif alpha = -1
            @iif beta = 0
@ROUT blk2C 
            C@(c_)[@(ir_)] = -rC[@(k_)];
            #ifdef Conj_
               C@(c_)[@(ii_)] = iC[@(k_)];
            #else
               C@(c_)[@(ii_)] = -iC[@(k_)];
            #endif
@ROUT C2blk 
            rC[@(k_)] = -C@(c_)[@(ir_)];
            #ifdef Conj_
               iC[@(k_)] = C@(c_)[@(ii_)];
            #else
               iC[@(k_)] = -C@(c_)[@(ii_)];
            #endif
@ROUT blk2C C2blk
            @endiif
            @iif beta = 1
@ROUT blk2C 
            C@(c_)[@(ir_)] -= rC[@(k_)];
            #ifdef Conj_
               C@(c_)[@(ii_)] += iC[@(k_)];
            #else
               C@(c_)[@(ii_)] -= iC[@(k_)];
            #endif
@ROUT C2blk 
            rC[@(k_)] -= C@(c_)[@(ir_)];
            #ifdef Conj_
               iC[@(k_)] += C@(c_)[@(ii_)];
            #else
               iC[@(k_)] -= C@(c_)[@(ii_)];
            #endif
@ROUT blk2C C2blk
            @endiif
            @iif beta = -1
@ROUT blk2C 
            C@(c_)[@(ir_)] = -C@(c_)[@(ir_)] - rC[@(k_)];
            #ifdef Conj_
               C@(c_)[@(ii_)] = iC[@(k_)] - C@(c_)[@(ii_)];
            #else
               C@(c_)[@(ii_)] = -C@(c_)[@(ii_)] - iC[@(k_)];
            #endif
@ROUT C2blk 
            rC[@(k_)] = -C@(c_)[@(ir_)] - rC[@(k_)];
            #ifdef Conj_
               iC[@(k_)] = C@(c_)[@(ii_)] - iC[@(k_)];
            #else
               iC[@(k_)] = -C@(c_)[@(ii_)] - iC[@(k_)];
            #endif
@ROUT blk2C C2blk
            @endiif
            @iif @iexp @(beta) 0 ! @(beta) 1 ! & @(beta) -1 ! &
@ROUT blk2C 
            { 
               const register @(typ) rc=C@(c_)[@(ir_)], ic=C@(c_)[@(ii_)];
               register @(typ) rr = -rC[@(k_)];
               #ifdef Conj_
                  register @(typ) ir = iC[@(k_)];
               #else
                  register @(typ) ir = -iC[@(k_)];
               #endif
               rr += rc * rb;
               ir += ic * rb;
               rr -= ic * ib;
               ir += rc * ib;
               C@(c_)[@(ir_)] = rr;
               C@(c_)[@(ii_)] = ir;
            }
@ROUT C2blk 
            { 
               const register @(typ) rc=rC[@(k_)], ic=iC[@(k_)];
               register @(typ) rr = -C@(c_)[@(ir_)];
               #ifdef Conj_
                  register @(typ) ir =  C@(c_)[@(ii_)];
               #else
                  register @(typ) ir = -C@(c_)[@(ii_)];
               #endif
               rr += rc * rb;
               ir += ic * rb;
               rr -= ic * ib;
               ir += rc * ib;
               rC[@(k_)] = rr;
               iC[@(k_)] = ic;
            }
@ROUT blk2C C2blk
            @endiif
         @endiif
         @iif @iexp @(alpha) 1 ! @(alpha) -1 ! &
            @iif beta = 0
@ROUT blk2C 
            { 
               const register @(typ) rc=rC[@(k_)];
               #ifdef Conj_
                  const register @(typ) ic = -iC[@(k_)];
               #else
                  const register @(typ) ic =  iC[@(k_)];
               #endif
               register @(typ) rr, ir;
               rr = rc * ra;
               ir = ic * ra;
               rr -= ic * ia;
               ir += rc * ia;
               C@(c_)[@(ir_)] = rr;
               C@(c_)[@(ii_)] = ir;
            }
@ROUT C2blk 
            { 
               const register @(typ) rc=C@(c_)[@(ir_)];
               #ifdef Conj_
                  const register @(typ) ic = -C@(c_)[@(ii_)];
               #else
                  const register @(typ) ic =  C@(c_)[@(ii_)];
               #endif
               register @(typ) rr, ir;
               rr  = rc * ra;
               ir  = ic * ra;
               rr -= ic * ia;
               ir += rc * ia;
               rC[@(k_)] = rr;
               iC[@(k_)] = ir;
            }
@ROUT blk2C C2blk
            @endiif
            @iif beta = 1
@ROUT blk2C 
            { 
               const register @(typ) rc=rC[@(k_)];
               #ifdef Conj_
                  const register @(typ) ic = -iC[@(k_)];
               #else
                  const register @(typ) ic =  iC[@(k_)];
               #endif
               register @(typ) rr=C@(c_)[@(ir_)], ir=C@(c_)[@(ii_)];
               rr += rc * ra;
               ir += ic * ra;
               rr -= ic * ia;
               ir += rc * ia;
               C@(c_)[@(ir_)] = rr;
               C@(c_)[@(ii_)] = ir;
            }
@ROUT C2blk 
            { 
               const register @(typ) rc=C@(c_)[@(ir_)];
               #ifdef Conj_
                  const register @(typ) ic = -C@(c_)[@(ii_)];
               #else
                  const register @(typ) ic =  C@(c_)[@(ii_)];
               #endif
               register @(typ) rr=rC[@(k_)], ir=iC[@(k_)];
               rr += rc * ra;
               ir += ic * ra;
               rr -= ic * ia;
               ir += rc * ia;
               rC[@(k_)] = rr;
               iC[@(k_)] = ir;
            }
@ROUT blk2C C2blk
            @endiif
            @iif beta = -1
@ROUT blk2C 
            { 
               const register @(typ) rc=rC[@(k_)];
               #ifdef Conj_
                  const register @(typ) ic = -iC[@(k_)];
               #else
                  const register @(typ) ic =  iC[@(k_)];
               #endif
               register @(typ) rr = -C@(c_)[@(ir_)], ir = -C@(c_)[@(ii_)];
               rr += rc * ra;
               ir += ic * ra;
               rr -= ic * ia;
               ir += rc * ia;
               C@(c_)[@(ir_)] = rr;
               C@(c_)[@(ii_)] = ir;
            }
@ROUT C2blk 
            { 
               const register @(typ) rc=C@(c_)[@(ir_)];
               #ifdef Conj_
                  const register @(typ) ic = -C@(c_)[@(ii_)];
               #else
                  const register @(typ) ic =  C@(c_)[@(ii_)];
               #endif
               register @(typ) rr = -rC[@(k_)], ir = -iC[@(k_)];
               rr += rc * ra;
               ir += ic * ra;
               rr -= ic * ia;
               ir += rc * ia;
               rC[@(k_)] = rr;
               iC[@(k_)] = ir;
            }
@ROUT blk2C C2blk
            @endiif
            @iif @iexp @(beta) 0 ! @(beta) 1 ! & @(beta) -1 ! &
@ROUT blk2C 
            {
               register @(typ) rc=C@(c_)[@(ir_)], ic=C@(c_)[@(ii_)];
               register @(typ) rB=rC[@(k_)], r0, i0, r1, i1;
               #ifdef Conj_
                  register @(typ) iB = -iC[@(k_)];
               #else
                  register @(typ) iB =  iC[@(k_)];
               #endif
               r0  = rb * rc;
               r1  = ra * rB;
               i0  = rb * ic;
               i1  = ra * iB;
               r0 -= ib * ic;
               i1 += ib * rc;
               r1 -= ia * iB;
               i1 += ia * rB;
               C@(c_)[@(ir_)] = r0 + r1;
               C@(c_)[@(ii_)] = i0 + i1;
            }
@ROUT C2blk 
            {
               register @(typ) rB=C@(c_)[@(ir_)];
               #ifdef Conj_
                  register @(typ) iB = -C@(c_)[@(ii_)];
               #else
                  register @(typ) iB =  C@(c_)[@(ii_)];
               #endif
               register @(typ) rc=rC[@(k_)], ic=iC[@(k_)], r0, i0, r1, i1;
               r0  = rb * rc;
               r1  = ra * rB;
               i0  = rb * ic;
               i1  = ra * iB;
               r0 -= ib * ic;
               i1 += ib * rc;
               r1 -= ia * iB;
               i1 += ia * rB;
               rC[@(k_)] = r0 + r1;
               iC[@(k_)] = i0 + i1;
            }
@ROUT blk2C C2blk
            @endiif
         @endiif
@ENDPROC
@BEGINPROC doBlockT m_ n_
   @define i @dum@
   @define ir @dum@
   @define ii @dum@
   @define j @dum@
   @define k @dum@
   @iexp j 0
   @iwhile j < @(n_)
      @iexp i 0
      @iwhile i < @(m_)
         @iexp ir @(i) @(i) +
         @iexp ii @(ir) 1 +
         @iexp k @(i) @(mu) * @(j) +
            @callproc doElementT @(j) @(ir) @(ii) @(k) 
         @iexp i @(i) 1 +
      @endiwhile
      @iexp i @(mu) @(mu) +
      @iif m_ = mu
            C@(j) += @(i);
      @endiif
      @iexp j @(j) 1 +
   @endiwhile
   @undef k
   @undef ii
   @undef ir
   @undef j
@ENDPROC
@BEGINPROC doDiBlockT n_
   @define i @dum@
   @define ir @dum@
   @define ii @dum@
   @define j @dum@
   @define k @dum@
   @iexp j 0
   @iwhile j < @(n_)
      @iexp i 0
      @iwhile i < @(n_)
@ROUT C2blk 
         @iif j < i
            @iexp ir @(j) @(j) +
            @define h @@(i)@
         @endiif
         @iif j } i
            @iexp ir @(i) @(i) +
            @define h @@(j)@
         @endiif
         @iexp ii @(ir) 1 +
         @iexp k @(i) @(mu) * @(j) +
            @callproc doElementT @(h) @(ir) @(ii) @(k) 
@ROUT blk2C 
         @iexp ir @(i) @(i) +
         @iexp ii @(ir) 1 +
         @iexp k @(i) @(mu) * @(j) +
         @iif j } i
            @callproc doElementT @(j) @(ir) @(ii) @(k) 
         @endiif
@ROUT blk2C C2blk
         @iexp i @(i) 1 +
      @endiwhile
      @iexp i @(mu) @(mu) +
      @iif n_ = mu
            C@(j) += @(i);
      @endiif
@ROUT C2blk `      @undef h`
      @iexp j @(j) 1 +
   @endiwhile
   @undef k
   @undef ii
   @undef ir
   @undef j
@ENDPROC
@ROUT C2blk `#if 0`
#ifndef Mjoin
   #define Mjoin(pre, nam) my_join(pre, nam)
   #define my_join(pre, nam) pre ## nam
#endif
/*
 * The block is assumed to store L, this function does a transpose while
 * copying so that it is transferred with Upper portion of C
 */
#ifdef Conj_
void Mjoin(ATL_USERCPMM,_L2UH)
#else
void Mjoin(ATL_USERCPMM,_L2UT)
#endif
(
   const size_t M,      /* number of rows in A */
   const size_t N,      /* number of columns in A */
   const @(typ) *alpha, /* scalar for b */
   @ROUT blk2C
   const @(typ) *rC,    /* real block stored in @(mu)x@(nu)-major order */
   const @(typ) *iC,    /* imag block stored in @(mu)x@(nu)-major order */
   const @(typ) *beta,  /* scalar for C */
   @(typ) *C,           /* matrix to be copied to access-major format */
   const size_t ldc     /* stride between row elements */
   @ROUT C2blk
   const @(typ) *C,     /* matrix to be copied to access-major format */
   const size_t ldc,    /* stride between row elements */
   const @(typ) *beta,  /* scalar for C */
   @(typ) *rC,          /* real block stored in @(mu)x@(nu)-major order */
   @(typ) *iC           /* imag block stored in @(mu)x@(nu)-major order */
   @ROUT C2blk blk2C
)
{
   const unsigned int mf = M/@(mu), nf = N/@(nu);
   const unsigned int m = mf*@(mu), n = nf*@(nu), mr = M-m, nr = N-n;
   const size_t ldc2 = ldc+ldc, incC0 = ldc2*@(nu);
   unsigned int i, j;
   @iif alpX ! 0
   const register @(typ) ra=(*alpha), ia=alpha[1];
   @endiif
   @iif betX ! 0
   const register @(typ) rb=(*beta), ib=beta[1];
   @endiif
@ROUT blk2C `   @declare "   @(typ) " n n ";"`
@ROUT C2blk `   @declare "   const @(typ) " n n ";"`
      *C0=C
      @define j @1@
      @iwhile j < @(nu)
         @iexp i @(j) -1 +
         *C@(j)=C@(i)+ldc2
         @iexp j @(j) 1 +
      @endiwhile
   @enddeclare
   for (j=0; j < nf; j++)
   {
      unsigned int incC = incC0 - (((j+1)*@(mu))<<1);
      for (i=0; i < j; i++, rC += @(bs), iC += @(bs)) 
      {
         @callproc doBlockT @(mu) @(nu)
      }
      @callproc doDiBlockT @(nu)
   @iexp j 0
   @iwhile j < @(nu)
      C@(j) += incC;
      @iexp j @(j) 1 +
   @endiwhile
      rC += @(bs);
      iC += @(bs);
   }
@iif nu > 1
   switch(nr)
   {
   @iexp n 1
   @iwhile n < @(nu)
   case @(n):
      for (i=0; i < mf; i++, rC += @(bs), iC += @(bs))
      {
         @callproc doBlockT @(mu) @(n)
      }
      switch(mr)
      {
   @iexp m 1
   @iwhile m < @(mu)
      case @(m):
      @skip Assumption: sryk  m = n 
      @callproc doDiBlockT @(m) 
      @iexp m @(m) 1 +
         break;
   @endiwhile
      default:;
      }
      break;
      @iexp n @(n) 1 +
   @endiwhile
   default:;
   }
@endiif
}
@ROUT C2blk `#endif`
@endiif
@ROUT blk2C_x87
@BEGINPROC GetAOff i_ j_
   @define of @1@
@iif @iexp @(i_) 0 = @(j_) 0 = &
   @define ao @(pA)@
@endiif
@iif @(j_) = 0
   @define al @@(i_)*SZ(pA)@
@endiif
@iif @(j_) = 1
   @iif (i_) = 0
      @define al @(pA,lda)@
   @endiif
   @iif (i_) ! 0
      @define al @@(i_)*SZ(pA,lda)@
   @endiif
@endiif
@iif @(j_) = 2
   @iif (i_) = 0
      @define al @(pA,lda,2)@
   @endiif
   @iif (i_) ! 0
      @define al @@(i_)*SZ(pA,lda,2)@
   @endiif
@endiif
@iif @(j_) = 3
   @iif (i_) = 0
      @define al @(pA,lda3)@
   @endiif
   @iif (i_) ! 0
      @define al @@(i_)*SZ(pA,lda3)@
   @endiif
@endiif
@iif @(j_) = 4
   @iif (i_) = 0
      @define al @(pA,lda,4)@
   @endiif
   @iif (i_) ! 0
      @define al @@(i_)*SZ(pA,lda,4)@
   @endiif
@endiif
@ENDPROC
#include "atlas_asm.h"
/*
 *                            rdi       rsi             xmm0            rdx
 * void ATL_ATL_USERCPMM(size_t M, size_t N, const TYPE alpha, const TYPE *w,
 *                                  xmm1       rcx         r8
 *                       const TYPE beta, TYPE *A, size_t lda);
 *                       
 */
#define M    %rdi
#deifne N    %rsi
#define pW   %rdx
#define pA   %rcx
#define lda  %rax  /* comes in r8 */
#define lda3 %r8  
#define Mr   %r9
#define Nr   %r10
#define II   %r11
.text
.global ATL_asmdecor(ATL_USERCPMM)
ALIGN16
ATL_asmdecor(ATL_USERCPMM):
   mov M, Mr
/*
 * M = M / 12  -> (M/4) /3;
 */
   shr $2, M   /* M /= 4 */
   mov M, %rax
   movabsq $-6148914691236517205, M
   mulq M
   shrq M
/*
 * rax = 12*(M/12)
 */
   lea (M,M,2), %rax /* rax = 3*(M/12) */
   shl $2, %rax      /* rax = 12*(M/12) */
   sub %rax, Mr      /* Mr = M - (M/12)*12 */

   shr $2, N  /* N /= 4 */
   mov N, %rax
   shl $2, %rax
   sub %rax, Nr     /* Nr = N - (N/4)*4 */

   mov %r8, lda
   lea (%r8,%r8,2), lda3
   #ifdef ALPHAX
      movlpd %xmm0, -8(%rsp)
      fldl -8(%esp)              /* ST={alpha} */
      #ifdef BETAX
         movlpd %xmm1, -8(%rsp)
         fldl -8(%esp)           /* ST={beta,alpha} */
         #define SCAN 2
      #else
         #define SCAN 1
      #endif
   #elif defined(BETAX)
      #define SCAN 1
      movlpd %xmm1, -8(%rsp)
      fldl -8(%esp)              /* ST={beta} */
   #else
      #define SCAN 0
   #endif
   #if SCAN == 1
      #define ST4 %st4
      #define ST5 %st5
      #define ST6 %st6
   #elif SCAN == 2
      #define ST4 %st5
      #define ST5 %st6
      #define ST6 %st7
   #endif
   cmp $0, N
   je CLEAN_N
   cmp $0, M
   je CLEAN_N
   LOOPN:
      mov M, II
      LOOPM:
         fldl (pW)          /* ST={p[0],[bet],[alp]} */
         #ifdef BETAX
            fmul %st1, %st  /* ST={bet*p[0],[bet],[alp]} */
         #elif defined(BETAN) || defined(BETAN1)
            fchs
         #endif
         fldl 8(pW)         /* ST={p[1], bet*p[0],[bet],[alp]} */
         #ifdef BETAX
            fmul %st2, %st  /* ST={bet*p[1],bet*p[0],[bet],[alp]} */
         #elif defined(BETAN) || defined(BETAN1)
            fchs
         #endif
         fldl 16(pW)        /* ST={p[2], bet*p[1],bet*p[0],[bet],[alp]} */
         #ifdef BETAX
            fmul %st3, %st  /* ST={bet*p[2],bet*p[1],bet*p[0],[bet],[alp]} */
         #elif defined(BETAN) || defined(BETAN1)
            fchs
         #endif
         fldl (pA)  /* ST={A[0],{bet*p[2],bet*p[1],bet*p[0],[bet],[alp]} */
         #ifdef ALPHAX
            fmul ST4, %st
         #elif defined(BETAN) || defined(BETAN1)
            fchs
         #endif
         fldl 8(pA)
         #ifdef ALPHAX
            fmul ST5, %st
         #elif defined(ALPHAN) || defined(ALPHAN1)
            fchs
         #endif
         fldl 16(pA)
         #ifdef ALPHAX
            fmul ST6, %st /*{A[2],A[1],A[0],p[2],p[1],p[0],[bet],[alp] */
         #elif defined(ALPHAN) || defined(ALPHAN1)
            fchs
         #endif
         dec II
      jne LOOPM
      dec N
   jne LOOPN

