@ifdef ! incd
   @define incd @/home/rwhaley/Base/ATLAS@
@endifdef
@ifdef ! incd
   @define BASEdir @/home/petitet/Base/ATLAS/ant/@
@endifdef
@extract -addkeys -b @(BASEdir)include/atlas.inc lan=C
@rout l1blastst
@define rname @l1blastst@
/*
 * =====================================================================
 * Include files
 * =====================================================================
 */
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <assert.h>
#include <math.h>
#ifdef GCCWIN
   ___main(){} __main(){} MAIN__(){} _MAIN_(){}
   #ifndef isdigit
      #define isdigit(ch_) ( ((ch_)=='0')||((ch_)=='1')||((ch_)=='2')|| \
                             ((ch_)=='3')||((ch_)=='4')||((ch_)=='5')|| \
                             ((ch_)=='6')||((ch_)=='7')||((ch_)=='8')|| \
                             ((ch_)=='9') )
   #endif
#else
   #include <ctype.h>
#endif
 
#include "atlas_misc.h"

#define    ATL_isf77amax           ATL_sf77amax
#define    ATL_idf77amax           ATL_df77amax
#define    ATL_icf77amax           ATL_cf77amax
#define    ATL_izf77amax           ATL_zf77amax

#include "atlas_tst.h"
/*
 * =====================================================================
 * #define macro constants
 * =====================================================================
 */
#define    MEGA                     1000000.0
#if defined( SREAL ) || defined( SCPLX )
#define    THRESH                        50.0f
#else
#define    THRESH                        50.0
#endif
 
/* #define    ATLAS_DEBUG */
/*
 * =====================================================================
 * # macro functions
 * =====================================================================
 *
 * The following and mutually exclusive  macros  allow to select various
 * BLAS implementations to test the ATLAS implementation against:
 *
 *    USE_F77_BLAS     : Fortran 77 BLAS interface,
 *    USE_L1_REFERENCE : C ATLAS reference implementation,
 *
 * If none of these macros is defined at compile time, the  ATLAS imple-
 * mentation is to be tested against itself,  after all this is the only
 * version we are sure to have available.
 *
 * By default the mono-threaded  ATLAS  routines are tested. To test the
 * multi-threaded ATLAS routines, define the following macro: 
 *    USE_L1_PTHREADS  : multi-threaded ATLAS implementation.
 */

#ifndef USE_L1_REFERENCE
   #define USE_F77_BLAS
#endif

#if defined(ATL_USEPTHREADS) && !defined(ATL_MIKE)
   #define USE_L1_PTHREADS
#endif
/*
 * =====================================================================
 */
#if   defined( USE_F77_BLAS ) /* Trusted BLAS version to test against */
#define  TP1      Mjoin( PATL,    f77 )
#ifdef TREAL
#define  TSC      TP1
#define  TCS      TP1
#else
#define  TSC      Mjoin( Mjoin( PATLU, PRE ), f77 )
#define  TCS      Mjoin( Mjoin( PATL,  UPR ), f77 )
#endif
#ifdef SREAL
#define  TDS      Mjoin( ATL_,  dsf77 )
#define  TSD      Mjoin( ATL_, sdsf77 )
#endif
#elif defined( USE_L1_REFERENCE )
#include "atlas_reflevel1.h"
#define  TP1      Mjoin( PATL,    ref )
#ifdef TREAL
#define  TSC      TP1
#define  TCS      TP1
#else
#define  TSC      Mjoin( Mjoin( PATLU, PRE ), ref )
#define  TCS      Mjoin( Mjoin( PATL,  UPR ), ref )
#endif
#ifdef SREAL
#define  TDS      Mjoin( ATL_,  dsref )
#define  TSD      Mjoin( ATL_, sdsref )
#endif
#else /* defined( USE_L1_ATLAS ) */  /* use ATLAS itself !! (default) */
#include "atlas_level1.h"
#define  TP1      PATL
#ifdef TREAL
#define  TSC      TP1
#define  TCS      TP1
#else
#define  TSC      Mjoin( PATLU, PRE )
#define  TCS      Mjoin( PATL,  UPR )
#endif
#ifdef SREAL
#define  TDS      Mjoin( ATL_,  ds )
#define  TSD      Mjoin( ATL_, sds )
#endif
#endif

#define  trusted_rotg(                         A,  B,  C,  S         ) \
Mjoin( TP1, rotg )(                            A,  B,  C,  S         )

#ifdef TREAL
#define  trusted_rotmg(                        D1, D2, X1, Y1, PARAM ) \
Mjoin( TP1, rotmg )(                           D1, D2, X1, Y1, PARAM )
#endif

#define trusted_nrm2(    N,     X, iX                                ) \
Mjoin( TSC, nrm2 )(      N,     X, iX                                )
#define trusted_asum(    N,     X, iX                                ) \
Mjoin( TSC, asum )(      N,     X, iX                                )
#if   defined( USE_F77_BLAS )
#define trusted_amax(    N,     X, iX                                ) \
Mjoin( TP1, amax )(      N,     X, iX                                )
#elif defined( USE_L1_REFERENCE )
#define trusted_amax(    N,     X, iX                                ) \
Mjoin( Mjoin( ATL_i, PRE ), refamax ) \
                  (      N,     X, iX                                )
#else
#define trusted_amax(    N,     X, iX                                ) \
Mjoin( Mjoin( ATL_i, PRE ), amax) \
                  (      N,     X, iX                                )
#endif
#define trusted_scal(    N, al, X, iX                                ) \
Mjoin( TP1, scal )(      N, al, X, iX                                )

#ifdef TCPLX
#if   defined( USE_F77_BLAS ) || defined( USE_L1_REFERENCE )
#define trusted_rscal(   N, al, X, iX                                ) \
Mjoin( TCS, scal ) (     N, al, X, iX                                )
#else
#define trusted_rscal(   N, al, X, iX                                ) \
Mjoin( TP1, scal ) (     N, al, X, iX                                )
#endif
#endif

#define trusted_axpy(    N, al, X, iX, Y, iY                         ) \
Mjoin( TP1, axpy )(      N, al, X, iX, Y, iY                         )
#define trusted_copy(    N,     X, iX, Y, iY                         ) \
Mjoin( TP1, copy )(      N,     X, iX, Y, iY                         )
#define trusted_swap(    N,     X, iX, Y, iY                         ) \
Mjoin( TP1, swap )(      N,     X, iX, Y, iY                         )
#define trusted_rot(     N,     X, iX, Y, iY,          C,  S         ) \
Mjoin( TCS, rot )(       N,     X, iX, Y, iY,          C,  S         )
 
#ifdef TREAL
#define trusted_rotm(    N,     X, iX, Y, iY,                  PARAM ) \
Mjoin( TP1, rotm )(      N,     X, iX, Y, iY,                  PARAM )
#define trusted_dot(     N,     X, iX, Y, iY                         ) \
Mjoin( TP1, dot )(       N,     X, iX, Y, iY                         )
#else
#define trusted_dotc(    N,     X, iX, Y, iY,                  DOT   ) \
Mjoin( TP1, dotc_sub )(  N,     X, iX, Y, iY,                  DOT   )
#define trusted_dotu(    N,     X, iX, Y, iY,                  DOT   ) \
Mjoin( TP1, dotu_sub )(  N,     X, iX, Y, iY,                  DOT   )
#endif

#ifdef SREAL
#define trusted_dsdot(   N,     X, iX, Y, iY                         ) \
Mjoin( TDS, dot )(       N,     X, iX, Y, iY                         )
#define trusted_sdsdot(  N, B,  X, iX, Y, iY                         ) \
Mjoin( TSD, dot )(       N, B,  X, iX, Y, iY                         )
#endif
/*
 * ATLAS version of the BLAS to test.
 */
#if defined( USE_L1_PTHREADS )
   #include "atlas_pthreads.h"
   #include "atlas_ptlvl1.h"
   #define  AP1      Mjoin( PATL,   pt  )
   #ifdef TREAL
      #define  ASC      AP1
      #define  ACS      AP1
   #else
      #define  ASC      Mjoin( Mjoin( PATLU, PRE ),  t )
      #define  ACS      Mjoin( Mjoin( PATL,  UPR ),  t )
   #endif
   #ifdef SREAL
      #define  ADS      Mjoin( ATL_,   dst )
      #define  ASD      Mjoin( ATL_,  sdst )
   #endif
#else 
   #ifdef ATL_MIKE
      #include "atlas_pthreads.h"
   #endif
   #include "atlas_level1.h"
   #define  AP1      PATL
   #ifdef TREAL
      #define  ASC      AP1
      #define  ACS      AP1
   #else
      #define  ASC      Mjoin( PATLU, PRE )
      #define  ACS      Mjoin( PATL,  UPR )
   #endif
   #ifdef SREAL
      #define  ADS      Mjoin( ATL_,  ds )
      #define  ASD      Mjoin( ATL_, sds )
   #endif
#endif

#define  test_rotg(                            A,  B,  C,  S         ) \
Mjoin( AP1, rotg )(                            A,  B,  C,  S         )

#ifdef TREAL
#define  test_rotmg(                           D1, D2, X1, Y1, PARAM ) \
Mjoin( AP1, rotmg )(                           D1, D2, X1, Y1, PARAM )
#endif

#define test_nrm2(       N,     X, iX                                ) \
Mjoin( ASC, nrm2 )(      N,     X, iX                                )
#define test_asum(       N,     X, iX                                ) \
Mjoin( ASC, asum )(      N,     X, iX                                )
#if defined( USE_L1_PTHREADS )
#define test_amax(       N,     X, iX                                ) \
Mjoin( Mjoin( ATL_i, PRE ), tamax ) \
                  (      N,     X, iX                                )
#else
#define test_amax(       N,     X, iX                                ) \
Mjoin( Mjoin( ATL_i, PRE ), amax ) \
                  (      N,     X, iX                                )
#endif
#define test_scal(       N, al, X, iX                                ) \
Mjoin( AP1, scal )(      N, al, X, iX                                )

#ifdef TCPLX
#if   defined( USE_L1_PTHREADS )
#define test_rscal(      N, al, X, iX                                ) \
Mjoin( ACS, scal ) (     N, al, X, iX                                )
#else
#define test_rscal(      N, al, X, iX                                ) \
Mjoin( AP1, scal ) (     N, al, X, iX                                )
#endif
#endif

#define test_axpy(       N, al, X, iX, Y, iY                         ) \
Mjoin( AP1, axpy )(      N, al, X, iX, Y, iY                         )
#define test_copy(       N,     X, iX, Y, iY                         ) \
Mjoin( AP1, copy )(      N,     X, iX, Y, iY                         )
#define test_swap(       N,     X, iX, Y, iY                         ) \
Mjoin( AP1, swap )(      N,     X, iX, Y, iY                         )
#define test_rot(        N,     X, iX, Y, iY,          C,  S         ) \
Mjoin( ACS, rot )(       N,     X, iX, Y, iY,          C,  S         )
 
#ifdef TREAL
#define test_rotm(       N,     X, iX, Y, iY,                  PARAM ) \
Mjoin( AP1, rotm )(      N,     X, iX, Y, iY,                  PARAM )
   #ifdef ATL_MIKE
      TYPE Mjoin(PRE,dot_mike)(const int N, TYPE *X, const int incX, 
                               TYPE *Y, const int incY);
      #define test_dot(        N,     X, iX, Y, iY                         ) \
         Mjoin(PRE,dot_mike)(N, X, iX, Y, iY)
   #else
      #define test_dot(        N,     X, iX, Y, iY                         ) \
         Mjoin( AP1, dot )(       N,     X, iX, Y, iY                         )
   #endif
#else
#define test_dotc(       N,     X, iX, Y, iY,                  DOT   ) \
Mjoin( AP1, dotc_sub )(  N,     X, iX, Y, iY,                  DOT   )
#define test_dotu(       N,     X, iX, Y, iY,                  DOT   ) \
Mjoin( AP1, dotu_sub )(  N,     X, iX, Y, iY,                  DOT   )
#endif

#ifdef SREAL
#define test_dsdot(      N,     X, iX, Y, iY                         ) \
Mjoin( ADS, dot )(       N,     X, iX, Y, iY                         )
#define test_sdsdot(     N, B,  X, iX, Y, iY                         ) \
Mjoin( ASD, dot )(       N, B,  X, iX, Y, iY                         )
#endif
/*
 * =====================================================================
 * macro functions
 * =====================================================================
 */
#ifdef TCPLX
#define Mabs1(X) (Mabs(*X) + Mabs(*(X+1)))
#else
#define Mabs1(X) (Mabs(X))
#endif

#ifdef  ATL_NTHREADS
#define LCSIZE          ATL_NTHREADS * L2SIZE
#else
#define LCSIZE          L2SIZE
#endif
/*
 * =====================================================================
 * typedef definitions
 * =====================================================================
 */
enum LVL1_ROUT /* 16 + 1 = 17 */
{
   AXPY=0, COPY, SWAP, ROT, ROTM, DOTU, DOTC, DSDOT, SDSDOT, ROTG,
   ROTMG, NRM2, ASUM, AMAX, SCAL, RSCAL, ALLROUTS
};
/*
 * =====================================================================
 * Prototypes for the testing routines
 * =====================================================================
 */
double     opbl1
(  const enum LVL1_ROUT,           const int );
TYPE rotgtst
(  const int CACHESIZE,
   const enum LVL1_ROUT,           const int,      const TYPE,
   double *,       double *,       double *,       double * );
#ifdef TREAL
TYPE rotmgtst
(  const int CACHESIZE,
   const enum LVL1_ROUT,           const int,      const TYPE,
   double *,       double *,       double *,       double * );
#endif
TYPE       sumtst
(  const int CACHESIZE,
   const enum LVL1_ROUT,           const int,      const int,
   const int,      const TYPE,     double *,       double *,
   double *,       double * );
TYPE       nrmtst
(  const int CACHESIZE,
   const enum LVL1_ROUT,           const int,      const int,
   const int,      const TYPE,     double *,       double *,
   double *,       double * );
TYPE       maxtst
(  const int CACHESIZE,
   const enum LVL1_ROUT,           const int,      const int,
   const int,      const TYPE,     double *,       double *,
   double *,       double * );
TYPE       scltst
(  const int CACHESIZE,
   const enum LVL1_ROUT,           const int,      const int,
   const SCALAR,   const int,      const TYPE,     double *,
   double *,       double *,       double * );
#ifdef TCPLX
TYPE       rsctst
(  const int CACHESIZE,
   const enum LVL1_ROUT,           const int,      const int,
   const SCALAR,   const int,      const TYPE,     double *,
   double *,       double *,       double * );
#endif
TYPE       xpytst
(  const int CACHESIZE,
   const enum LVL1_ROUT,           const int,      const int,
   const SCALAR,   const int,      const int,      const TYPE,
   double *,       double *,       double *,       double * );
TYPE       cpytst
(  const int CACHESIZE,
   const enum LVL1_ROUT,           const int,      const int,
   const int,      const int,      const TYPE,     double *,
   double *,       double *,       double * );
TYPE       swptst
(  const int CACHESIZE,
   const enum LVL1_ROUT,           const int,      const int,
   const int,      const int,      const TYPE,     double *,
   double *,       double *,       double * );
TYPE       dottst
(  const int CACHESIZE,
   const enum LVL1_ROUT,           const int,      const int,
   const int,      const int,      const TYPE,     double *,
   double *,       double *,       double * );
TYPE       rottst
(  const int CACHESIZE,
   const enum LVL1_ROUT,           const int,      const int,
   const int,      const int,      const TYPE,     const TYPE,
   const TYPE,     double *,       double *,       double *,
   double * );
#ifdef TREAL
TYPE       rotmtst
(  const int CACHESIZE,
   const enum LVL1_ROUT,           const int,      const int,
   const int,      const int,      const TYPE *,   const TYPE,
   double *,       double *,       double *,       double * );
#endif

int        rotgcase
(  const int CACHESIZE,
   const enum LVL1_ROUT,           const int,      const int,
   const TYPE,     double *,       double *,       double *,
   double * );
#ifdef TREAL
int        rotmgcase
(  const int CACHESIZE,
   const enum LVL1_ROUT,           const int,      const int,
   const TYPE,     double *,       double *,       double *,
   double * );
#endif
int        sumcase
(  const int CACHESIZE,
   const enum LVL1_ROUT,           const int,      const int,
   const int,      const int,      const TYPE,     double *,
   double *,       double *,       double * );
int        nrmcase
(  const int CACHESIZE,
   const enum LVL1_ROUT,           const int,      const int,
   const int,      const int,      const TYPE,     double *,
   double *,       double *,       double * );
int        maxcase
(  const int CACHESIZE,
   const enum LVL1_ROUT,           const int,      const int,
   const int,      const int,      const TYPE,     double *,
   double *,       double *,       double * );
int        sclcase
(  const int CACHESIZE,
   const enum LVL1_ROUT,           const int,      const int,
   const int,      const SCALAR,   const int,      const TYPE,
   double *,       double *,       double *,       double * );
#ifdef TCPLX
int        rsccase
(  const int CACHESIZE,
   const enum LVL1_ROUT,           const int,      const int,
   const int,      const SCALAR,   const int,      const TYPE,
   double *,       double *,       double *,       double * );
#endif
int        xpycase
(  const int CACHESIZE,
   const enum LVL1_ROUT,           const int,      const int,
   const int,      const SCALAR,   const int,      const int,
   const TYPE,     double *,       double *,       double *,
   double * );
int        cpycase
(  const int CACHESIZE,
   const enum LVL1_ROUT,           const int,      const int,
   const int,      const int,      const int,      const TYPE,
   double *,       double *,       double *,       double * );
int        swpcase
(  const int CACHESIZE,
   const enum LVL1_ROUT,           const int,      const int,
   const int,      const int,      const int,      const TYPE,
   double *,       double *,       double *,       double * );
int        dotcase
(  const int CACHESIZE,
   const enum LVL1_ROUT,           const int,      const int,
   const int,      const int,      const int,      const TYPE,
   double *,       double *,       double *,       double * );
int        rotcase
(  const int CACHESIZE,
   const enum LVL1_ROUT,           const int,      const int,
   const int,      const int,      const int,      const TYPE,
   const TYPE,     const TYPE,     double *,       double *,
   double *,       double * );
#ifdef TREAL
int        rotmcase
(  const int CACHESIZE,
   const enum LVL1_ROUT,           const int,      const int,
   const int,      const int,      const int,      const TYPE *,
   const TYPE,     double *,       double *,       double *,
   double * );
#endif

void       RunrotgCase
(  const int CACHESIZE,
   const enum LVL1_ROUT,           const int,     const int,
   const TYPE,     int *,          int * );
#ifdef TREAL
void       RunrotmgCase
(  const int CACHESIZE,
   const enum LVL1_ROUT,           const int,     const int,
   const TYPE,     int *,          int * );
#endif
void       RunsumCase
(  const int CACHESIZE,
   const enum LVL1_ROUT,           const int,      const int,
   const int,      const int,      const int,      const int,
   const int *,    const TYPE,     int *,          int * );
void       RunnrmCase
(  const int CACHESIZE,  
   const enum LVL1_ROUT,           const int,      const int,
   const int,      const int,      const int,      const int,
   const int *,    const TYPE,     int *,          int * );
void       RunmaxCase
(  const int CACHESIZE,
   const enum LVL1_ROUT,           const int,      const int,
   const int,      const int,      const int,      const int,
   const int *,    const TYPE,     int *,          int * );
void       RunsclCase
(  const int CACHESIZE,
   const enum LVL1_ROUT,           const int,      const int,
   const int,      const int,      const int,      const int,
   const TYPE *,   const int,      const int *,    const TYPE,
   int *,          int * );
#ifdef TCPLX
void       RunrscCase
(  const int CACHESIZE,
   const enum LVL1_ROUT,           const int,      const int,
   const int,      const int,      const int,      const int,
   const TYPE *,   const int,      const int *,    const TYPE,
   int *,          int * );
#endif
void       RunxpyCase
(  const int CACHESIZE,
   const enum LVL1_ROUT,           const int,      const int,
   const int,      const int,      const int,      const int,
   const TYPE *,   const int,      const int *,    const int,
   const int *,    const TYPE,     int *,          int * );
void       RuncpyCase
(  const int CACHESIZE,
   const enum LVL1_ROUT,           const int,      const int,
   const int,      const int,      const int,      const int,
   const int *,    const int,      const int *,    const TYPE,
   int *,          int * );
void       RunswpCase
(  const int CACHESIZE,
   const enum LVL1_ROUT,           const int,      const int,
   const int,      const int,      const int,      const int,
   const int *,    const int,      const int *,    const TYPE,
   int *,          int * );
void       RundotCase
(  const int CACHESIZE,
   const enum LVL1_ROUT,           const int,      const int,
   const int,      const int,      const int,      const int,
   const int *,    const int,      const int *,    const TYPE,
   int *,          int * );
void       RunrotCase
(  const int CACHESIZE,
   const enum LVL1_ROUT,           const int,      const int,
   const int,      const int,      const int,      const int,
   const int *,    const int,      const int *,    const int,
   const TYPE *,   const TYPE,     int *,          int * );
#ifdef TREAL
void       RunrotmCase
(  const int CACHESIZE,
   const enum LVL1_ROUT,           const int,      const int,
   const int,      const int,      const int,      const int,
   const int *,    const int,      const int *,    const TYPE,
   int *,          int * );
#endif

void       RunCases
(  const int,      const int,      const int,      const int,
   const int,      const int,      const int,      const TYPE *,
   const int,      const int *,    const int,      const int *,
   const int,      const enum LVL1_ROUT * );

void       PrintUsage
(  char * );

void       GetFlags
(  int,            char **,        int *,          enum LVL1_ROUT **,
   int *,          int *,          int *,          int *,   
   int *,          int *,          int *,          TYPE **,
   int *,          int **,         int *,          int ** );
 
int        main
(  int,             char ** );
/*
 * =====================================================================
 */
double opbl1
(
   const enum LVL1_ROUT       ROUT,
   const int                  N
)
{
   double                     adds = 0.0, en, muls = 0.0;
 
   if( N <= 0 ) return( 0.0 );
 
   en = (double)(N);

                        /* Approximate count for rotation computation */
   if(      ROUT == ROTG   ) { muls = 8.0;           adds = 6.0;        }
        /* Approximate count for modified-Givens rotation computation */
   else if( ROUT == ROTMG  ) { muls = 9.0;           adds = 3.0;        }
                            /* Square root counted as 9 muls + 8 adds */
   else if( ROUT == NRM2   ) { muls = en+9.0;        adds = en-1.0+8.0; }
                                  /* Absolute value counted as 1 adds */
   else if( ROUT == ASUM   ) { muls = 0.0;           adds = 2.0 * en;   }
                           /* Absolute value + test counted as 2 adds */
   else if( ROUT == AMAX   ) { muls = 0.0;           adds = 2.0 * en;   }
   else if( ROUT == SCAL   ) { muls = en;            adds = 0.0;        }
                         /* A little bit of cheating for real scaling */
   else if( ROUT == RSCAL  ) { muls = 0.0;           adds = en;         }
   else if( ROUT == AXPY   ) { muls = en;            adds = en;         }
                        /* Count copy just like adds for practicality */
   else if( ROUT == COPY   ) { muls = 0.0;           adds = en;         }
                        /* Count swap just like adds for practicality */
   else if( ROUT == SWAP   ) { muls = 0.0;           adds = 2.0 * en;   }
#ifdef TREAL
   else if( ROUT == ROT    ) { muls = 4.0*en;        adds = 2.0 * en;   }
#else
   else if( ROUT == ROT    ) { muls = (4.0*en)/3.0;  adds = 2.0 * en;   }
#endif
   else if( ROUT == ROTM   ) { muls = 4.0*en;        adds = 2.0 * en;   }
   else if( ROUT == DOTU   ) { muls = en;            adds = en - 1.0;   }
   else if( ROUT == DOTC   ) { muls = en;            adds = en - 1.0;   }
   else if( ROUT == DSDOT  ) { muls = en;            adds = en - 1.0;   }
   else if( ROUT == SDSDOT ) { muls = en;            adds = en;         }

#ifdef TREAL
   return(       muls +       adds );
#else
   return( 6.0 * muls + 2.0 * adds );
#endif
}                                                                               
/*
 * =====================================================================
 * tst functions
 * =====================================================================
 */
TYPE rotgtst
(
   const int                  CACHESIZE,
   const enum LVL1_ROUT       ROUT,
   const int                  TEST,
   const TYPE                 EPSILON,
   double                     * TTRUST0,
   double                     * TTEST0,
   double                     * MFTRUST0,
   double                     * MFTEST0
)
{
   double                     l2ret, ops, t0, ttest, ttrust;
   TYPE                       residA, residB, residC, residS;
#ifdef TREAL
   TYPE                       te_A, tr_A, te_B, tr_B, te_C, tr_C, te_S, tr_S;
#else
   TYPE                       te_A[2], tr_A[2], te_B[2], tr_B[2], te_C, tr_C,
                              te_S[2], tr_S[2], diff[2];
#endif
   int                        Aseed, Bseed;
 
   *TTRUST0 = *TTEST0 = *MFTEST0 = *MFTRUST0 = 0.0; ops = opbl1( ROUT, 0 );
/*
 * Generate random operands
 */
   Aseed = 129;
   Bseed = 213;
/*
 * Allocate L2 cache space, X, Y and Y0
 */
   l2ret = ATL_flushcache( CACHESIZE );
 
#ifdef TREAL
   Mjoin( PATL, gegen )( 1, 1, &te_A, 1, Aseed );
   Mjoin( PATL, gegen )( 1, 1, &tr_A, 1, Aseed );
   Mjoin( PATL, gegen )( 1, 1, &te_B, 1, Bseed );
   Mjoin( PATL, gegen )( 1, 1, &tr_B, 1, Bseed );
#else
   Mjoin( PATL, gegen )( 1, 1, te_A, 1, Aseed );
   Mjoin( PATL, gegen )( 1, 1, tr_A, 1, Aseed );
   Mjoin( PATL, gegen )( 1, 1, te_B, 1, Bseed );
   Mjoin( PATL, gegen )( 1, 1, tr_B, 1, Bseed );
#endif
/*
 * Start timing operations for the trusted routine with cold caches.
 */
   l2ret  = ATL_flushcache( -1 );
   t0     = time00();
#ifdef TREAL
   trusted_rotg( &tr_A, &tr_B, &tr_C, &tr_S );
#else
   trusted_rotg(  tr_A,  tr_B, &tr_C,  tr_S );
#endif
   ttrust = time00() - t0;
   if( ttrust > 0.0 )
   { *TTRUST0 = ttrust; *MFTRUST0 = ops / ( ttrust * MEGA ); }
/*
 * Start timing operations for the tested routine with cold caches.
 */
   l2ret  = ATL_flushcache( -1 );      
   t0    = time00();
#ifdef TREAL
   test_rotg( &te_A, &te_B, &te_C, &te_S );
#else
   test_rotg(  te_A,  te_B, &te_C,  te_S );
#endif
   ttest = time00() - t0;
   if( ttest  > 0.0 )
   { *TTEST0  = ttest;  *MFTEST0  = ops / ( ttest  * MEGA ); }
/*
 * if timing only, I am done ... so leave.
 */
   l2ret  = ATL_flushcache( 0 );

   if( !( TEST ) ) { return( ATL_rzero ); 
     }
/*
 * else perform error check - Ensure the difference of the output operands
 * is relatively tiny enough
 */
#ifdef TREAL
   residA = Mabs1( tr_A - te_A ) / ( 2.0 * Mmax( 1.0, ops ) * EPSILON );
   residB = Mabs1( tr_B - te_B ) / ( 2.0 * Mmax( 1.0, ops ) * EPSILON );
   residC = Mabs1( tr_C - te_C ) / ( 2.0 * Mmax( 1.0, ops ) * EPSILON );
   residS = Mabs1( tr_S - te_S ) / ( 2.0 * Mmax( 1.0, ops ) * EPSILON );
#else
   diff[0] = tr_A[0] - te_A[0]; diff[1] = tr_A[1] - te_A[1];
   residA = Mabs1( diff ) / ( Mmax( 1.0, ops ) * EPSILON );
   diff[0] = tr_B[0] - te_B[0]; diff[1] = tr_B[1] - te_B[1];
   residB = Mabs1( diff ) / ( Mmax( 1.0, ops ) * EPSILON );
   residC = Mabs(  tr_C - te_C ) / ( Mmax( 1.0, ops ) * EPSILON );
   diff[0] = tr_S[0] - te_S[0]; diff[1] = tr_S[1] - te_S[1];
   residS = Mabs1( diff ) / ( Mmax( 1.0, ops ) * EPSILON );
#endif
 
   if( ( residA > THRESH ) || ( residA != residA ) )
   {
#ifdef TREAL
      (void) fprintf( stderr, "ERROR:  residA=%f, tr_A=%f, te_A=%f, eps=%e\n",
                      residA, tr_A, te_A, EPSILON );
#else
      (void) fprintf( stderr,
 "ERROR:  residA=%f, tr_A[0]=%f, tr_A[1]=%f, te_A[0]=%f, te_A[1]=%f, eps=%e\n",
 residA, tr_A[0], tr_A[1], te_A[0], te_A[1], EPSILON );
#endif
   }
 
   if( ( residB > THRESH ) || ( residB != residB ) )
   {
#ifdef TREAL
      (void) fprintf( stderr, "ERROR:  residB=%f, tr_B=%f, te_B=%f, eps=%e\n",
                      residB, tr_B, te_B, EPSILON );
#else
      (void) fprintf( stderr,
 "ERROR:  residB=%f, tr_B[0]=%f, tr_B[1]=%f, te_B[0]=%f, te_B[1]=%f, eps=%e\n",
 residB, tr_B[0], tr_B[1], te_B[0], te_B[1], EPSILON );
#endif
   }
 
   if( ( residC > THRESH ) || ( residC != residC ) )
   {
      (void) fprintf( stderr, "ERROR:  residC=%f, tr_C=%f, te_C=%f, eps=%e\n",
                      residC, tr_C, te_C, EPSILON );
   }
 
   if( ( residS > THRESH ) || ( residS != residS ) )
   {
#ifdef TREAL
      (void) fprintf( stderr, "ERROR:  residS=%f, tr_S=%f, te_S=%f, eps=%e\n",
                      residS, tr_S, te_S, EPSILON );
#else
      (void) fprintf( stderr,
 "ERROR:  residS=%f, tr_S[0]=%f, tr_S[1]=%f, te_S[0]=%f, te_S[1]=%f, eps=%e\n",
 residS, tr_S[0], tr_S[1], te_S[0], te_S[1], EPSILON );
#endif
   }

   
   return( Mmax( Mmax( Mmax( residA, residB ), residC ), residS ) );
}

#ifdef TREAL
TYPE rotmgtst
(
   const int                  CACHESIZE,
   const enum LVL1_ROUT       ROUT,
   const int                  TEST,
   const TYPE                 EPSILON,
   double                     * TTRUST0,
   double                     * TTEST0,
   double                     * MFTRUST0,
   double                     * MFTEST0
)
{
   double                     l2ret, ops, t0, ttest, ttrust;
   TYPE                       residD1, residD2, residX1, residP;
   TYPE                       te_D1, tr_D1, te_D2, tr_D2, te_X1, tr_X1,
                              te_Y1, tr_Y1, te_PARAM[5], tr_PARAM[5];
   int                        D1seed, D2seed, X1seed, Y1seed;
 
   *TTRUST0 = *TTEST0 = *MFTEST0 = *MFTRUST0 = 0.0; ops = opbl1( ROUT, 0 );
/*
 * Generate random operands
 */
   D1seed = 129; D2seed = 213; X1seed = 319; Y1seed = 222;
 
   Mjoin( PATL, gegen )( 1, 1, &te_D1, 1, D1seed ); te_D1 = Mabs( te_D1 );
   Mjoin( PATL, gegen )( 1, 1, &tr_D1, 1, D1seed ); tr_D1 = Mabs( tr_D1 );
   Mjoin( PATL, gegen )( 1, 1, &te_D2, 1, D2seed );
   Mjoin( PATL, gegen )( 1, 1, &tr_D2, 1, D2seed );
   Mjoin( PATL, gegen )( 1, 1, &te_X1, 1, X1seed );
   Mjoin( PATL, gegen )( 1, 1, &tr_X1, 1, X1seed );
   Mjoin( PATL, gegen )( 1, 1, &te_Y1, 1, Y1seed );
   Mjoin( PATL, gegen )( 1, 1, &tr_Y1, 1, Y1seed );

   te_PARAM[0] = ATL_rzero; tr_PARAM[0] = ATL_rzero;
   te_PARAM[1] = ATL_rzero; tr_PARAM[1] = ATL_rzero;
   te_PARAM[2] = ATL_rzero; tr_PARAM[2] = ATL_rzero;
   te_PARAM[3] = ATL_rzero; tr_PARAM[3] = ATL_rzero;
   te_PARAM[4] = ATL_rzero; tr_PARAM[4] = ATL_rzero;

   /* Allocate L2 cache space */
   l2ret = ATL_flushcache( CACHESIZE );
/*
 * Start cold cache timing operations for the trusted routine
 */
   l2ret = ATL_flushcache( -1 ); /* flush */
   t0     = time00();
   trusted_rotmg( &tr_D1, &tr_D2, &tr_X1, tr_Y1, tr_PARAM );
   ttrust = time00() - t0;
   if( ttrust > 0.0 )
   { *TTRUST0 = ttrust; *MFTRUST0 = ops / ( ttrust * MEGA ); }
/*
 * Start cold cache timing operations for the tested routine
 */
   l2ret = ATL_flushcache( -1 ); /* flush */
   t0    = time00();
   test_rotmg( &te_D1, &te_D2, &te_X1, te_Y1, te_PARAM );
   ttest = time00() - t0;
   if( ttest  > 0.0 )
   { *TTEST0  = ttest;  *MFTEST0  = ops / ( ttest  * MEGA ); }
/*
 * if timing only, I am done ... so leave.
 */
   l2ret = ATL_flushcache( 0 ); /* dealloc */ 
   if( !( TEST ) ) { return( ATL_rzero ); }
/*
 * else perform error check - Ensure the difference of the output operands
 * is relatively tiny enough
 */
   residD1 = Mabs( tr_D1 - te_D1 ) / ( 2.0 * Mmax( 1.0, ops ) * EPSILON );
   residD2 = Mabs( tr_D2 - te_D2 ) / ( 2.0 * Mmax( 1.0, ops ) * EPSILON );
   residX1 = Mabs( tr_X1 - te_X1 ) / ( 2.0 * Mmax( 1.0, ops ) * EPSILON );
   residP  = Mabs( tr_PARAM[0] - te_PARAM[0] ) +
             Mabs( tr_PARAM[1] - te_PARAM[1] ) +
             Mabs( tr_PARAM[2] - te_PARAM[2] ) +
             Mabs( tr_PARAM[3] - te_PARAM[3] ) +
             Mabs( tr_PARAM[4] - te_PARAM[4] );
   residP  = residP / ( 2.0 * Mmax( 1.0, ops ) * EPSILON );
 
   if( ( residD1 > THRESH ) || ( residD1 != residD1 ) )
   {
      (void) fprintf( stderr,
                      "ERROR:  residD1=%f, tr_D1=%f, te_D1=%f, eps=%e\n",
                      residD1, tr_D1, te_D1, EPSILON );
   }

   if( ( residD2 > THRESH ) || ( residD2 != residD2 ) )
   {
      (void) fprintf( stderr,
                      "ERROR:  residD2=%f, tr_D2=%f, te_D2=%f, eps=%e\n",
                      residD2, tr_D2, te_D2, EPSILON );
   }
 
   if( ( residX1 > THRESH ) || ( residX1 != residX1 ) )
   {
      (void) fprintf( stderr,
                      "ERROR:  residX1=%f, tr_X1=%f, te_X1=%f, eps=%e\n",
                      residX1, tr_X1, te_X1, EPSILON );
   }
 
   if( ( residP > THRESH ) || ( residP != residP ) )
   {
      (void) fprintf( stderr,
      "ERROR:  residP=%f, tr_P=%f,%f,%f,%f,%f, te_P=%f,%f,%f,%f,%f, eps=%e\n",
      residP, tr_PARAM[0], tr_PARAM[1], tr_PARAM[2], tr_PARAM[3], tr_PARAM[4],
      te_PARAM[0], te_PARAM[1], te_PARAM[2], te_PARAM[3], te_PARAM[4],
      EPSILON );
   }
 
   return( Mmax( Mmax( Mmax( residD1, residD2 ), residX1 ), residP ) );
} 
#endif

TYPE sumtst
(
   const int                  CACHESIZE,
   const enum LVL1_ROUT       ROUT,
   const int                  TEST,
   const int                  N,
   const int                  INCX,
   const TYPE                 EPSILON,
   double                     * TTRUST0,
   double                     * TTEST0,
   double                     * MFTRUST0,
   double                     * MFTEST0
)
{
   double                     l2ret, ops, t0, ttest, ttrust;
   TYPE                       normX, te_sum, tr_sum, resid;
   TYPE                       * X = NULL, * x;
   const int                  aincX = Mabs( INCX );
   int                        Xseed;
 
   *TTRUST0 = *TTEST0 = *MFTEST0 = *MFTRUST0 = 0.0;
   if( N == 0 ) { return( ATL_rzero ); }

   ops = opbl1( ROUT, N );
/*
 * Allocate L2 cache space, X, Y and Y0
 */
   l2ret = ATL_flushcache( CACHESIZE );
   X     = (TYPE *)malloc( ATL_MulBySize( N ) * aincX );
 
   if( X == NULL )
   {
      l2ret = ATL_flushcache( 0 );
      if( X ) free( X );
      return( ATL_rnone );
   }
/*
 * Generate random operands
 */
   Xseed = N  * aincX * 27 + 213;
 
   Mjoin( PATL, gegen )( 1,  N, X,  aincX, Xseed );
/*
 * Start cold cache timing operations for the trusted routine
 */
   x = X;  if( INCX < 0 ) x = X  + ( ( ( 1 - N ) * INCX ) SHIFT );
 
   l2ret  = ATL_flushcache( -1 );
   t0     = time00();
   tr_sum = trusted_asum( N, x, INCX );
   ttrust = time00() - t0;
   if( ttrust > 0.0 )
   { *TTRUST0 = ttrust; *MFTRUST0 = ops / ( ttrust * MEGA ); }
/*
 * Start cold cache timing operations for the tested routine
 */
   x = X; if( INCX < 0 ) x = X + ( ( ( 1 - N ) * INCX ) SHIFT );
 
   l2ret  = ATL_flushcache( -1 );
   t0     = time00();
   te_sum = test_asum( N, x, INCX );
   ttest  = time00() - t0;
   if( ttest  > 0.0 )
   { *TTEST0  = ttest;  *MFTEST0  = ops / ( ttest  * MEGA ); }
/*
 * if timing only, I am done ... so leave.
 */
   l2ret = ATL_flushcache( 0 );
 
   if( !( TEST ) ) { free( X ); return( ATL_rzero ); }
/*
 * else perform error check 
 */
   normX = Mjoin( PATL, infnrm )( N, X, aincX );
   if( normX == ATL_rzero ) normX = ATL_rone;

   free( X );

   resid = tr_sum - te_sum;
   resid = Mabs( resid ) / ( EPSILON * Mmax( normX, ATL_rone ) * N );
 
   if( ( resid > THRESH ) || ( resid != resid ) )
   {
      (void) fprintf( stderr,
      "ERROR:  resid=%f, tr_sum=%f, te_sum=%f, normX=%f, eps=%e\n",
      resid, tr_sum, te_sum, normX, EPSILON );
   }
 
   return( resid );
} 

TYPE nrmtst
(
   const int                  CACHESIZE,
   const enum LVL1_ROUT       ROUT,
   const int                  TEST,
   const int                  N,
   const int                  INCX,
   const TYPE                 EPSILON,
   double                     * TTRUST0,
   double                     * TTEST0,
   double                     * MFTRUST0,
   double                     * MFTEST0
)
{
   double                     l2ret, ops, t0, ttest, ttrust;
   TYPE                       normX, te_nrm, tr_nrm, resid;
   TYPE                       * X = NULL, * x;
   const int                  aincX = Mabs( INCX );
   int                        Xseed;
 
   *TTRUST0 = *TTEST0 = *MFTEST0 = *MFTRUST0 = 0.0;
   if( N == 0 ) { return( ATL_rzero ); }

   ops = opbl1( ROUT, N );
/*
 * Allocate L2 cache space, X, Y and Y0
 */
   l2ret = ATL_flushcache( CACHESIZE );
   X     = (TYPE *)malloc( ATL_MulBySize( N ) * aincX );
 
   if( X == NULL )
   {
      l2ret = ATL_flushcache( 0 );
      if( X ) free( X );
      return( ATL_rnone );
   }
/*
 * Generate random operands
 */
   Xseed = N  * aincX * 27 + 213;
 
   Mjoin( PATL, gegen )( 1,  N, X,  aincX, Xseed );
/*
 * Start cold cache timing operations for the trusted routine
 */
   x = X;  if( INCX < 0 ) x = X  + ( ( ( 1 - N ) * INCX ) SHIFT );
 
   l2ret  = ATL_flushcache( -1 );
   t0     = time00();
   tr_nrm = trusted_nrm2( N, x, INCX );
   ttrust = time00() - t0;
   if( ttrust > 0.0 )
   { *TTRUST0 = ttrust; *MFTRUST0 = ops / ( ttrust * MEGA ); }
/*
 * Start cold cache timing operations for the tested routine
 */
   x = X; if( INCX < 0 ) x = X + ( ( ( 1 - N ) * INCX ) SHIFT );
 
   l2ret  = ATL_flushcache( -1 );
   t0     = time00();
   te_nrm = test_nrm2( N, x, INCX );
   ttest  = time00() - t0;
   if( ttest  > 0.0 )
   { *TTEST0  = ttest;  *MFTEST0  = ops / ( ttest  * MEGA ); }
/*
 * if timing only, I am done ... so leave.
 */
   l2ret  = ATL_flushcache( 0 );
 
   if( !( TEST ) ) { free( X ); return( ATL_rzero ); }
/*
 * else perform error check 
 */
   normX = Mjoin( PATL, infnrm )( N, X, aincX );
   if( normX == ATL_rzero ) normX = ATL_rone;

   free( X );

   resid = tr_nrm - te_nrm;
   resid = Mabs( resid ) / ( EPSILON * Mmax( normX, ATL_rone ) * N );
 
   if( ( resid > THRESH ) || ( resid != resid ) )
   {
      (void) fprintf( stderr,
      "ERROR:  resid=%f, tr_nrm=%f, te_nrm=%f, normX=%f, eps=%e\n",
      resid, tr_nrm, te_nrm, normX, EPSILON );
   }
 
   return( resid );
} 

TYPE maxtst
(
   const int                  CACHESIZE,
   const enum LVL1_ROUT       ROUT,
   const int                  TEST,
   const int                  N,
   const int                  INCX,
   const TYPE                 EPSILON,
   double                     * TTRUST0,
   double                     * TTEST0,
   double                     * MFTRUST0,
   double                     * MFTEST0
)
{
   TYPE                       * X = NULL, * x;
   double                     l2ret, ops, t0, ttest, ttrust;
   TYPE                       resid;
   const int                  aincX = Mabs( INCX );
   int                        te_max, tr_max, Xseed;
 
   *TTRUST0 = *TTEST0 = *MFTEST0 = *MFTRUST0 = 0.0;
   if( N == 0 ) { return( ATL_rzero ); }

   ops = opbl1( ROUT, N );
/*
 * Allocate L2 cache space, X, Y and Y0
 */
   l2ret = ATL_flushcache( CACHESIZE );
   X     = (TYPE *)malloc( ATL_MulBySize( N ) * aincX );
 
   if( X == NULL )
   {
      l2ret = ATL_flushcache( 0 );
      if( X ) free( X );
      return( ATL_rnone );
   }
/*
 * Generate random operands
 */
   Xseed = N  * aincX * 27 + 213;
 
   Mjoin( PATL, gegen )( 1,  N, X,  aincX, Xseed );
/*
 * Start cold cache timing operations for the trusted routine
 */
   x = X;  if( INCX < 0 ) x = X  + ( ( ( 1 - N ) * INCX ) SHIFT );
 
   l2ret  = ATL_flushcache( -1 );
   t0     = time00();
   tr_max = trusted_amax( N, x, INCX );
   ttrust = time00() - t0;
   if( ttrust > 0.0 )
   { *TTRUST0 = ttrust; *MFTRUST0 = ops / ( ttrust * MEGA ); }
/*
 * Start cold cache timing operations for the tested routine
 */
   x = X; if( INCX < 0 ) x = X + ( ( ( 1 - N ) * INCX ) SHIFT );
 
   l2ret  = ATL_flushcache( -1 );
   t0     = time00();
   te_max = test_amax( N, x, INCX );
   ttest  = time00() - t0;
   if( ttest  > 0.0 )
   { *TTEST0  = ttest;  *MFTEST0  = ops / ( ttest  * MEGA ); }
/*
 * if timing only, I am done ... so leave.
 */
   l2ret = ATL_flushcache( 0 );
 
   if( !( TEST ) ) { free( X ); return( ATL_rzero ); }
/*
 * else perform error check 
 */
   free( X );

   resid = ( (TYPE)(tr_max - te_max) ) / ( EPSILON ); 
 
   if( ( resid > THRESH ) || ( resid != resid ) )
   {
      (void) fprintf( stderr,
      "ERROR:  resid=%f, tr_max=%d, te_max=%d, eps=%e\n",
      resid, tr_max, te_max, EPSILON );
   }
 
   return( resid );
} 

TYPE scltst
(
   const int                  CACHESIZE,
   const enum LVL1_ROUT       ROUT,
   const int                  TEST,
   const int                  N,
   const SCALAR               ALPHA,
   const int                  INCX,
   const TYPE                 EPSILON,
   double                     * TTRUST0,
   double                     * TTEST0,
   double                     * MFTRUST0,
   double                     * MFTEST0
)
{
   double                     l2ret, ops, t0, ttest, ttrust;
   TYPE                       normD, normX, resid;
   TYPE                       * X = NULL, * X0, * XD = NULL, * x;
   const int                  aincX = Mabs( INCX );
   int                        Xseed;
 
   *TTRUST0 = *TTEST0 = *MFTEST0 = *MFTRUST0 = 0.0;
   if( N == 0 ) { return( ATL_rzero ); }
 
   if( SCALAR_IS_ONE( ALPHA ) ) ops = 0.0; else ops = opbl1( ROUT, N );
/*
 * Allocate L2 cache space, X, Y and Y0
 */
   l2ret = ATL_flushcache( CACHESIZE );
   X = (TYPE *)malloc( ATL_MulBySize( N ) * aincX * 2 );
 
   if( X == NULL )
   {
      l2ret = ATL_flushcache( 0 );
      if( X ) free( X );
      return( ATL_rnone );
   }
 
   X0 = X + N * ( aincX SHIFT );
/*
 * Generate random operands
 */
   Xseed = N * aincX * 27 + 213;
 
   Mjoin( PATL, gegen )( 1,  N, X,  aincX, Xseed );
   Mjoin( PATL, gegen )( 1,  N, X0, aincX, Xseed );
/*
 * Compute the norm of X for later use in testing
 */
   if( TEST )
   {
      normX = Mjoin( PATL, infnrm )( N, X, aincX );
      if( Mabs1( ALPHA ) > ATL_rone ) normX *= Mabs1( ALPHA );
      if( normX == ATL_rzero ) normX = ATL_rone;
   }
   else { normX = ATL_rone; }
/*
 * Start cold cache timing operations for the trusted routine
 */
   x = X0; if( INCX < 0 ) x = X0 + ( ( ( 1 - N ) * INCX ) SHIFT );
 
   l2ret  = ATL_flushcache( -1 );
   t0     = time00();
   trusted_scal( N, ALPHA, x, INCX );
   ttrust = time00() - t0;
   if( ttrust > 0.0 )
   { *TTRUST0 = ttrust; *MFTRUST0 = ops / ( ttrust * MEGA ); }
/*
 * Start cold cache timing operations for the tested routine
 */
   x = X; if( INCX < 0 ) x = X + ( ( ( 1 - N ) * INCX ) SHIFT );
 
   l2ret  = ATL_flushcache( -1 );
   t0     = time00();
   test_scal( N, ALPHA, x, INCX );
   ttest  = time00() - t0;
   if( ttest  > 0.0 )
   { *TTEST0  = ttest;  *MFTEST0  = ops / ( ttest  * MEGA ); }
/*
 * if timing only, I am done ... so leave.
 */
   l2ret  = ATL_flushcache( 0 );
 
   if( !( TEST ) ) { free( X ); return( ATL_rzero ); }
/*
 * else perform error check - Ensure the difference of the output operands
 * is relatively tiny enough
 */
   XD = (TYPE *)malloc( ATL_MulBySize( N ) );
   if( XD == NULL ) { free( X ); return( ATL_rnone ); }
 
   Mjoin( PATL, vdiff )( N, X, aincX, X0, aincX, XD, 1 );
 
   normD = Mjoin( PATL, infnrm )( N, XD, 1 );
   resid = normD / ( EPSILON * Mmax( normX, ATL_rone ) * N );
 
   if( ( resid > THRESH ) || ( resid != resid ) )
   {
      (void) fprintf( stderr,
      "ERROR:  resid=%f, normD=%f, normX=%f, eps=%e\n",
      resid, normD, normX, EPSILON );
#ifdef ATLAS_DEBUG
      Mjoin( PATL, geprint )( "X_trusted", 1, N, X0, aincX );
      Mjoin( PATL, geprint )( "X_test",    1, N, X,  aincX );
#endif
   }
 
   free( X  );
   free( XD );
 
   return( resid );
}

#ifdef TCPLX

TYPE rsctst
(
   const int                  CACHESIZE,
   const enum LVL1_ROUT       ROUT,
   const int                  TEST,
   const int                  N,
   const SCALAR               ALPHA,
   const int                  INCX,
   const TYPE                 EPSILON,
   double                     * TTRUST0,
   double                     * TTEST0,
   double                     * MFTRUST0,
   double                     * MFTEST0
)
{
   double                     l2ret, ops, t0, ttest, ttrust;
   TYPE                       normD, normX, resid, Calph[2];
   TYPE                       * X = NULL, * X0, * XD = NULL, * x;
   const int                  aincX = Mabs( INCX );
   int                        Xseed;
 
   *TTRUST0 = *TTEST0 = *MFTEST0 = *MFTRUST0 = 0.0;
   if( N == 0 ) { return( ATL_rzero ); }
 
   if( *ALPHA == ATL_rone ) ops = 0.0; else ops = opbl1( ROUT, N );
/*
 * Allocate L2 cache space, X, Y and Y0
 */
   l2ret = ATL_flushcache( CACHESIZE );
   X  = (TYPE *)malloc( ATL_MulBySize( N ) * aincX * 2 );
 
   if( X == NULL )
   {
      l2ret  = ATL_flushcache( 0 );
      if( X  ) free( X  );
      return( ATL_rnone );
   }
 
   X0 = X + N * ( aincX SHIFT );
/*
 * Generate random operands
 */
   Xseed = N * aincX * 27 + 213;
 
   Mjoin( PATL, gegen )( 1,  N, X,  aincX, Xseed );
   Mjoin( PATL, gegen )( 1,  N, X0, aincX, Xseed );

   Calph[0] = *ALPHA; Calph[1] = ATL_rzero;
/*
 * Compute the norm of X for later use in testing
 */
   if( TEST )
   {
      normX = Mjoin( PATL, infnrm )( N, X, aincX );
      if( Mabs( *ALPHA ) > ATL_rone ) normX *= Mabs( *ALPHA );
      if( normX == ATL_rzero ) normX = ATL_rone;
   }
   else { normX = ATL_rone; }
/*
 * Start cold cache timing operations for the trusted routine
 */
   x = X0; if( INCX < 0 ) x = X0 + ( ( ( 1 - N ) * INCX ) SHIFT );
 
   l2ret = ATL_flushcache( -1 );
#if   defined( USE_F77_BLAS ) || defined( USE_L1_REFERENCE )
   t0 = time00(); trusted_rscal( N, Calph[0], x, INCX ); ttrust = time00() - t0;
#else
   t0 = time00(); trusted_rscal( N, Calph,    x, INCX ); ttrust = time00() - t0;
#endif
   if( ttrust > 0.0 )
   { *TTRUST0 = ttrust; *MFTRUST0 = ops / ( ttrust * MEGA ); }
/*
 * Start cold cache timing operations for the tested routine
 */
   x = X; if( INCX < 0 ) x = X + ( ( ( 1 - N ) * INCX ) SHIFT );
 
   l2ret = ATL_flushcache( -1 );
#if   defined( USE_L1_PTHREADS )
   t0 = time00(); test_rscal( N, Calph[0], x, INCX ); ttest = time00() - t0;
#else
   t0 = time00(); test_rscal( N, Calph,    x, INCX ); ttest = time00() - t0;
#endif
   if( ttest  > 0.0 )
   { *TTEST0  = ttest;  *MFTEST0  = ops / ( ttest  * MEGA ); }
/*
 * if timing only, I am done ... so leave.
 */
   l2ret  = ATL_flushcache( 0 );
 
   if( !( TEST ) ) { free( X ); return( ATL_rzero ); }
/*
 * else perform error check - Ensure the difference of the output operands
 * is relatively tiny enough
 */
   XD = (TYPE *)malloc( ATL_MulBySize( N ) );
   if( XD == NULL ) { free( X ); return( ATL_rnone ); }
 
   Mjoin( PATL, vdiff )( N, X, aincX, X0, aincX, XD, 1 );
 
   normD = Mjoin( PATL, infnrm )( N, XD, 1 );
   resid = normD / ( EPSILON * Mmax( normX, ATL_rone ) * N );
 
   if( ( resid > THRESH ) || ( resid != resid ) )
   {
      (void) fprintf( stderr,
      "ERROR:  resid=%f, normD=%f, normX=%f, eps=%e\n",
      resid, normD, normX, EPSILON );
#ifdef ATLAS_DEBUG
      Mjoin( PATL, geprint )( "X_trusted", 1, N, X0, aincX );
      Mjoin( PATL, geprint )( "X_test",    1, N, X,  aincX );
#endif
   }
 
   free( X  );
   free( XD );
 
   return( resid );
}

#endif


TYPE xpytst
(
   const int                  CACHESIZE,
   const enum LVL1_ROUT       ROUT,
   const int                  TEST,
   const int                  N,
   const SCALAR               ALPHA,
   const int                  INCX,
   const int                  INCY,
   const TYPE                 EPSILON,
   double                     * TTRUST0,
   double                     * TTEST0,
   double                     * MFTRUST0,
   double                     * MFTEST0
)
{
   double                     l2ret, ops, t0, ttest, ttrust;
   TYPE                       normD, normX, normY, resid;
   TYPE                       * X = NULL, * Y = NULL, * Y0, * YD = NULL,
                              * x, * y;
   const int                  aincX = Mabs( INCX ), aincY = Mabs( INCY );
   int                        Xseed, Yseed;
 
   *TTRUST0 = *TTEST0 = *MFTEST0 = *MFTRUST0 = 0.0;
   if( N == 0 ) { return( ATL_rzero ); }
 
   ops = opbl1( ROUT, N );
/*
 * Allocate L2 cache space, X, Y and Y0
 */
   l2ret = ATL_flushcache( CACHESIZE );
   X  = (TYPE *)malloc( ATL_MulBySize( N ) * aincX     );
   Y  = (TYPE *)malloc( ATL_MulBySize( N ) * aincY * 2 );
 
   if( ( X == NULL ) || ( Y == NULL ) )
   {
      l2ret = ATL_flushcache( 0 );
      if( X ) free( X );
      if( Y ) free( Y );
      return( ATL_rnone );
   }
 
   Y0 = Y + N * ( aincY SHIFT );
/*
 * Generate random operands
 */
   Xseed = N  * aincX * 27 + 213;
   Yseed = N  * aincY;
 
   Mjoin( PATL, gegen )( 1,  N, X,  aincX, Xseed );
   Mjoin( PATL, gegen )( 1,  N, Y,  aincY, Yseed );
   Mjoin( PATL, gegen )( 1,  N, Y0, aincY, Yseed );
/*
 * Compute the norm of Y for later use in testing
 */
   if( TEST )
   {
      normY = Mjoin( PATL, infnrm )( N, Y, aincY );
      if( normY == ATL_rzero ) normY = ATL_rone;
   }
   else { normY = ATL_rone; }
/*
 * Start cold cache timing operations for the trusted routine
 */
   x = X;  if( INCX < 0 ) x = X  + ( ( ( 1 - N ) * INCX ) SHIFT );
   y = Y0; if( INCY < 0 ) y = Y0 + ( ( ( 1 - N ) * INCY ) SHIFT );

   l2ret  = ATL_flushcache( -1 );
   t0     = time00();
   trusted_axpy( N, ALPHA, x, INCX, y, INCY );
   ttrust = time00() - t0;
   if( ttrust > 0.0 )
   { *TTRUST0 = ttrust; *MFTRUST0 = ops / ( ttrust * MEGA ); }
/*
 * Start cold cache timing operations for the tested routine
 */
   x = X; if( INCX < 0 ) x = X + ( ( ( 1 - N ) * INCX ) SHIFT );
   y = Y; if( INCY < 0 ) y = Y + ( ( ( 1 - N ) * INCY ) SHIFT );
 
   l2ret = ATL_flushcache( -1 );
   t0    = time00();
   test_axpy( N, ALPHA, x, INCX, y, INCY );
   ttest = time00() - t0;
   if( ttest  > 0.0 )
   { *TTEST0  = ttest;  *MFTEST0  = ops / ( ttest  * MEGA ); }
/*
 * if timing only, I am done ... so leave.
 */
   l2ret  = ATL_flushcache( 0 );
 
   if( !( TEST ) ) { free( X ); free( Y ); return( ATL_rzero ); }
/*
 * else perform error check - Ensure the difference of the output operands
 * is relatively tiny enough
 */
   normX = Mjoin( PATL, infnrm )( N, X, aincX );
   if( Mabs1( ALPHA ) > ATL_rone ) normX *= Mabs1( ALPHA );
   if( normX == ATL_rzero ) normX = ATL_rone;

   free( X );

   YD = (TYPE *)malloc( ATL_MulBySize( N ) );
   if( YD == NULL ) { free( Y ); return( ATL_rnone ); }
 
   Mjoin( PATL, vdiff )( N, Y, aincY, Y0, aincY, YD, 1 );
 
   normD = Mjoin( PATL, infnrm )( N, YD, 1 );
   resid = normD / ( EPSILON * Mmax( normX, ATL_rone ) *
                     Mmax( normY, ATL_rone ) * N );
 
   if( ( resid > THRESH ) || ( resid != resid ) )
   {
      (void) fprintf( stderr,
      "ERROR:  resid=%f, normD=%f, normX=%f, normY=%f, eps=%e\n",
      resid, normD, normX, normY, EPSILON );
#ifdef ATLAS_DEBUG
      Mjoin( PATL, geprint )( "Y_trusted", 1, N, Y0, aincY );
      Mjoin( PATL, geprint )( "Y_test",    1, N, Y,  aincY );
#endif
   }
 
   free( Y  );
   free( YD );
 
   return( resid );
}

TYPE cpytst
(
   const int                  CACHESIZE,
   const enum LVL1_ROUT       ROUT,
   const int                  TEST,
   const int                  N,
   const int                  INCX,
   const int                  INCY,
   const TYPE                 EPSILON,
   double                     * TTRUST0,
   double                     * TTEST0,
   double                     * MFTRUST0,
   double                     * MFTEST0
)
{
   double                     l2ret, ops, t0, ttest, ttrust;
   TYPE                       normD, normY, resid;
   TYPE                       * X = NULL, * Y = NULL, * Y0,
                              * YD = NULL, * x, * y;
   const int                  aincX = Mabs( INCX ), aincY = Mabs( INCY );
   int                        Xseed, Yseed;
 
   *TTRUST0 = *TTEST0 = *MFTEST0 = *MFTRUST0 = 0.0;
   if( N == 0 ) { return( ATL_rzero ); }
 
   ops = opbl1( ROUT, N );
/*
 * Allocate L2 cache space, X, Y and Y0
 */
   l2ret = ATL_flushcache( CACHESIZE );
   X  = (TYPE   *)malloc( ATL_MulBySize( N   ) * aincX     );
   Y  = (TYPE   *)malloc( ATL_MulBySize( N   ) * aincY * 2 );
 
   if( ( X == NULL ) || ( Y == NULL ) )
   {
      l2ret  = ATL_flushcache( 0 );
      if( X  ) free( X  );
      if( Y  ) free( Y  );
      return( ATL_rnone );
   }
 
   Y0 = Y + N * ( aincY SHIFT );
/*
 * Generate random operands
 */
   Xseed = N  * aincX * 27 + 213;
   Yseed = N  * aincY;
 
   Mjoin( PATL, gegen )( 1,  N, X,  aincX, Xseed );
   Mjoin( PATL, gegen )( 1,  N, Y,  aincY, Yseed );
   Mjoin( PATL, gegen )( 1,  N, Y0, aincY, Yseed );
/*
 * Compute the norm of Y for later use in testing
 */
   if( TEST )
   {
      normY = Mjoin( PATL, infnrm )( N, Y, aincY );
      if( normY == ATL_rzero ) normY = ATL_rone;
   }
/*
 * Start cold cache timing operations for the trusted routine
 */
   x = X;  if( INCX < 0 ) x = X  + ( ( ( 1 - N ) * INCX ) SHIFT );
   y = Y0; if( INCY < 0 ) y = Y0 + ( ( ( 1 - N ) * INCY ) SHIFT );

   l2ret  = ATL_flushcache( -1 );
   t0     = time00();
   trusted_copy( N, x, INCX, y, INCY );
   ttrust = time00() - t0;
   if( ttrust > 0.0 )
   { *TTRUST0 = ttrust; *MFTRUST0 = ops / ( ttrust * MEGA ); }
/*
 * Start cold cache timing operations for the tested routine
 */
   x = X; if( INCX < 0 ) x = X + ( ( ( 1 - N ) * INCX ) SHIFT );
   y = Y; if( INCY < 0 ) y = Y + ( ( ( 1 - N ) * INCY ) SHIFT );
 
   l2ret = ATL_flushcache( -1 );
   t0    = time00();
   test_copy( N, x, INCX, y, INCY );
   ttest = time00() - t0;
   if( ttest  > 0.0 )
   { *TTEST0  = ttest;  *MFTEST0  = ops / ( ttest  * MEGA ); }
/*
 * if timing only, I am done ... so leave.
 */
   l2ret  = ATL_flushcache( 0 );
 
   if( !( TEST ) ) { free( X ); free( Y ); return( ATL_rzero ); }
/*
 * else perform error check - Ensure the difference of the output operands
 * is relatively tiny enough
 */
   free( X );

   YD = (TYPE *)malloc( ATL_MulBySize( N ) );
   if( YD == NULL ) { free( Y ); return( ATL_rnone ); }
 
   Mjoin( PATL, vdiff )( N, Y, aincY, Y0, aincY, YD, 1 );
 
   normD = Mjoin( PATL, infnrm )( N, YD, 1 );
   resid = normD / ( EPSILON * N );
 
   if( ( resid > THRESH ) || ( resid != resid ) )
   {
      (void) fprintf( stderr,
      "ERROR:  resid=%f, normD=%f, eps=%e\n", resid, normD, EPSILON );
#ifdef ATLAS_DEBUG
      Mjoin( PATL, geprint )( "Y_trusted", 1, N, Y0, aincY );
      Mjoin( PATL, geprint )( "Y_test",    1, N, Y,  aincY );
#endif
   }
 
   free( Y  );
   free( YD );
 
   return( resid );
}

TYPE swptst
(
   const int                  CACHESIZE,
   const enum LVL1_ROUT       ROUT,
   const int                  TEST,
   const int                  N,
   const int                  INCX,
   const int                  INCY,
   const TYPE                 EPSILON,
   double                     * TTRUST0,
   double                     * TTEST0,
   double                     * MFTRUST0,
   double                     * MFTEST0
)
{
   double                     l2ret, ops, t0, ttest, ttrust;
   TYPE                       normDX, normDY, normX, normY, resid;
   TYPE                       * X = NULL, * X0, * XD = NULL, * Y = NULL,
                              * Y0, * YD = NULL, * x, * y;
   const int                  aincX = Mabs( INCX ), aincY = Mabs( INCY );
   int                        Xseed, Yseed;
 
   *TTRUST0 = *TTEST0 = *MFTEST0 = *MFTRUST0 = 0.0;
   if( N == 0 ) { return( ATL_rzero ); }
 
   ops = opbl1( ROUT, N );
/*
 * Allocate L2 cache space, X, Y and Y0
 */
   l2ret = ATL_flushcache( CACHESIZE );
   X  = (TYPE   *)malloc( ATL_MulBySize( N   ) * aincX * 2 );
   Y  = (TYPE   *)malloc( ATL_MulBySize( N   ) * aincY * 2 );
 
   if( ( X == NULL ) || ( Y == NULL ) )
   {
      l2ret = ATL_flushcache( 0 );
      if( X ) free( X );
      if( Y ) free( Y );
      return( ATL_rnone );
   }
 
   X0 = X + N * ( aincX SHIFT );
   Y0 = Y + N * ( aincY SHIFT );
/*
 * Generate random operands
 */
   Xseed = N  * aincX * 27 + 213;
   Yseed = N  * aincY;
 
   Mjoin( PATL, gegen )( 1,  N, X,  aincX, Xseed );
   Mjoin( PATL, gegen )( 1,  N, X0, aincX, Xseed );
   Mjoin( PATL, gegen )( 1,  N, Y,  aincY, Yseed );
   Mjoin( PATL, gegen )( 1,  N, Y0, aincY, Yseed );
/*
 * Compute the norm of Y for later use in testing
 */
   if( TEST )
   {
      normX = Mjoin( PATL, infnrm )( N, X, aincX );
      if( normX == ATL_rzero ) normX = ATL_rone;
      normY = Mjoin( PATL, infnrm )( N, Y, aincY );
      if( normY == ATL_rzero ) normY = ATL_rone;
   }
/*
 * Start cold cache timing operations for the trusted routine
 */
   x = X0; if( INCX < 0 ) x = X0 + ( ( ( 1 - N ) * INCX ) SHIFT );
   y = Y0; if( INCY < 0 ) y = Y0 + ( ( ( 1 - N ) * INCY ) SHIFT );
 
   l2ret  = ATL_flushcache( -1 );
   t0     = time00();
   trusted_swap( N, x, INCX, y, INCY );
   ttrust = time00() - t0;
   if( ttrust > 0.0 )
   { *TTRUST0 = ttrust; *MFTRUST0 = ops / ( ttrust * MEGA ); }
/*
 * Start cold cache timing operations for the tested routine
 */
   x = X; if( INCX < 0 ) x = X + ( ( ( 1 - N ) * INCX ) SHIFT );
   y = Y; if( INCY < 0 ) y = Y + ( ( ( 1 - N ) * INCY ) SHIFT );
 
   l2ret = ATL_flushcache( -1 );
   t0    = time00();
   test_swap( N, x, INCX, y, INCY );
   ttest = time00() - t0;
   if( ttest  > 0.0 )
   { *TTEST0  = ttest;  *MFTEST0  = ops / ( ttest  * MEGA ); }
/*
 * if timing only, I am done ... so leave.
 */
   l2ret  = ATL_flushcache( 0 );
 
   if( !( TEST ) ) { free( X ); free( Y ); return( ATL_rzero ); }
/*
 * else perform error check - Ensure the difference of the output operands
 * is relatively tiny enough
 */
   XD = (TYPE *)malloc( ATL_MulBySize( N ) );
   if( XD == NULL ) { free( Y ); free( X ); return( ATL_rnone ); }
   YD = (TYPE *)malloc( ATL_MulBySize( N ) );
   if( YD == NULL ) { free( XD ); free( Y ); free( X ); return( ATL_rnone ); }
 
   Mjoin( PATL, vdiff )( N, X, aincX, X0, aincX, XD, 1 );
   Mjoin( PATL, vdiff )( N, Y, aincY, Y0, aincY, YD, 1 );
 
   normDX = Mjoin( PATL, infnrm )( N, XD, 1 );
   normDY = Mjoin( PATL, infnrm )( N, YD, 1 );
   resid  = Mmax( normDX, normDY ) / ( EPSILON * N );
 
   if( ( resid > THRESH ) || ( resid != resid ) )
   {
      (void) fprintf( stderr,
                      "ERROR:  resid=%f, normDX=%f, normDY=%f, eps=%e\n",
                      resid, normDX, normDY, EPSILON );
#ifdef ATLAS_DEBUG
      Mjoin( PATL, geprint )( "X_trusted", 1, N, X0, aincX );
      Mjoin( PATL, geprint )( "X_test",    1, N, X,  aincX );
      Mjoin( PATL, geprint )( "Y_trusted", 1, N, Y0, aincY );
      Mjoin( PATL, geprint )( "Y_test",    1, N, Y,  aincY );
#endif
   }
 
   free( X  );
   free( Y  );
   free( XD );
   free( YD );
 
   return( resid );
} 


TYPE dottst
(
   const int                  CACHESIZE,
   const enum LVL1_ROUT       ROUT,
   const int                  TEST,
   const int                  N,
   const int                  INCX,
   const int                  INCY,
   const TYPE                 EPSILON,
   double                     * TTRUST0,
   double                     * TTEST0,
   double                     * MFTRUST0,
   double                     * MFTEST0
)
{
   double                     l2ret, ops, t0, ttest=0.0, ttrust=0.0;
   TYPE                       normX, normY, resid = ATL_rzero;
#ifdef TREAL
   TYPE                       te_dot=ATL_rzero, tr_dot= ATL_rzero;
#ifdef SREAL
   double                     te_ddot=0.0, tr_ddot=0.0;
   float                      b = ATL_rone;
#endif
#else
   TYPE                       te_dotx[2], tr_dotx[2];
#endif
   TYPE                       * X = NULL, * Y = NULL, * x, * y;
   const int                  aincX = Mabs( INCX ), aincY = Mabs( INCY );
   int                        Xseed, Yseed;
 
   *TTRUST0 = *TTEST0 = *MFTEST0 = *MFTRUST0 = 0.0;
   if( N == 0 ) { return( ATL_rzero ); }
 
   ops = opbl1( ROUT, N );
/*
 * Allocate L2 cache space, X, Y and Y0
 */
   l2ret = ATL_flushcache( CACHESIZE );
   X  = (TYPE   *)malloc( ATL_MulBySize( N ) * aincX );
   Y  = (TYPE   *)malloc( ATL_MulBySize( N ) * aincY );
 
   if( ( X == NULL ) || ( Y == NULL ) )
   {
      l2ret = ATL_flushcache( 0 );
      if( X ) free( X );
      if( Y ) free( Y );
      return( ATL_rnone );
   }
/*
 * Generate random operands
 */
   Xseed = N  * aincX * 27 + 213;
   Yseed = N  * aincY;
 
   Mjoin( PATL, gegen )( 1, N, X, aincX, Xseed );
   Mjoin( PATL, gegen )( 1, N, Y, aincY, Yseed );
/*
 * Start cold cache timing operations for the trusted routine
 */
   x = X; if( INCX < 0 ) x = X + ( ( ( 1 - N ) * INCX ) SHIFT );
   y = Y; if( INCY < 0 ) y = Y + ( ( ( 1 - N ) * INCY ) SHIFT );

#ifdef TREAL
   if( ( ROUT == DOTU ) || ( ROUT == DOTC ) )
   {
      l2ret  = ATL_flushcache( -1 );
      t0     = time00();
      tr_dot = trusted_dot( N, x, INCX, y, INCY );
      ttrust = time00() - t0;
   }
#ifdef SREAL
   else if( ROUT == DSDOT )
   {
      l2ret   = ATL_flushcache( -1 );
      t0      = time00();
      tr_ddot = trusted_dsdot( N, x, INCX, y, INCY );
      ttrust  = time00() - t0;
   }
   else if( ROUT == SDSDOT )
   {
      Mjoin( PATL, gegen )( 1, 1, &b, 1, 297 );
      l2ret  = ATL_flushcache( -1 );
      t0     = time00();
      tr_dot = trusted_sdsdot( N, b, x, INCX, y, INCY );
      ttrust = time00() - t0;
   }
#endif
#else
   if( ROUT == DOTU )
   {
      l2ret  = ATL_flushcache( -1 );
      t0     = time00();
      trusted_dotu( N, x, INCX, y, INCY, tr_dotx );
      ttrust = time00() - t0;
   }
   else if( ROUT == DOTC )
   {
      l2ret  = ATL_flushcache( -1 );
      t0     = time00();
      trusted_dotc( N, x, INCX, y, INCY, tr_dotx );
      ttrust = time00() - t0;
   }
#endif
   if( ttrust > 0.0 )
   { *TTRUST0 = ttrust; *MFTRUST0 = ops / ( ttrust * MEGA ); }
/*
 * Start cold cache timing operations for the tested routine
 */
   x = X; if( INCX < 0 ) x = X + ( ( ( 1 - N ) * INCX ) SHIFT );
   y = Y; if( INCY < 0 ) y = Y + ( ( ( 1 - N ) * INCY ) SHIFT );

#ifdef TREAL
   if( ( ROUT == DOTU ) || ( ROUT == DOTC ) )
   {
      l2ret  = ATL_flushcache( -1 );
      t0     = time00();
      te_dot = test_dot( N, x, INCX, y, INCY );
      ttest  = time00() - t0;
   }
#ifdef SREAL
   else if( ROUT == DSDOT )
   {
      l2ret   = ATL_flushcache( -1 );
      t0      = time00();
      te_ddot = test_dsdot( N, x, INCX, y, INCY );
      ttest   = time00() - t0;
   }
   else if( ROUT == SDSDOT )
   {
      l2ret  = ATL_flushcache( -1 );
      t0     = time00();
      te_dot = test_sdsdot( N, b, x, INCX, y, INCY );
      ttest  = time00() - t0;
   }
#endif
#else
   if( ROUT == DOTU )
   {
      l2ret = ATL_flushcache( -1 );
      t0    = time00();
      test_dotu( N, x, INCX, y, INCY, te_dotx );
      ttest = time00() - t0;
   }
   else if( ROUT == DOTC )
   {
      l2ret = ATL_flushcache( -1 );
      t0    = time00();
      test_dotc( N, x, INCX, y, INCY, te_dotx );
      ttest = time00() - t0;
   }
#endif
   if( ttest  > 0.0 )
   { *TTEST0  = ttest;  *MFTEST0  = ops / ( ttest  * MEGA ); }
/*
 * if timing only, I am done ... so leave.
 */ 
   l2ret  = ATL_flushcache( 0 );
 
   if( !( TEST ) ) { free( X ); free( Y ); return( ATL_rzero ); }
/*
 * else perform error check - Ensure the difference of the output operands
 * is relatively tiny enough
 */
   normX =  Mjoin( PATL, infnrm )( N, X, aincX );
   if( normX == ATL_rzero ) normX = ATL_rone;
   free( X );

   normY =  Mjoin( PATL, infnrm )( N, Y, aincY );
   if( normY == ATL_rzero ) normY = ATL_rone;
   free( Y );

#if   defined( SREAL )
   if( ( ROUT == DOTU ) || ( ROUT == DOTC ) || ( ROUT == SDSDOT ) )
   {
      resid = tr_dot - te_dot;
      resid = Mabs( resid ) / ( EPSILON * Mmax( normX, ATL_rone ) *
                                Mmax( normY, ATL_rone ) * N );

      if( ( resid > THRESH ) || ( resid != resid ) )
      {
         (void) fprintf( stderr,
         "ERROR:  resid=%f, tr_dot=%f, te_dot=%f, normX=%f, normY=%f, eps=%e\n",
         resid, tr_dot, te_dot, normX, normY, EPSILON );
      } 
   }
   else if( ROUT == DSDOT  )
   {
      resid = (TYPE)( tr_ddot - te_ddot );
      resid = Mabs( resid ) / ( EPSILON * Mmax( normX, ATL_rone ) *
                                Mmax( normY, ATL_rone ) * N );

      if( ( resid > THRESH ) || ( resid != resid ) )
      {
         (void) fprintf( stderr,
      "ERROR:  resid=%f, tr_ddot=%f, te_ddot=%f, normX=%f, normY=%f, eps=%e\n",
      resid, tr_ddot, te_ddot, normX, normY, EPSILON );
      } 
   }
#elif defined( DREAL )
   resid = tr_dot - te_dot;
   resid = Mabs( resid ) / ( EPSILON * Mmax( normX, ATL_rone ) *
                             Mmax( normY, ATL_rone ) * N );

   if( ( resid > THRESH ) || ( resid != resid ) )
   {
      (void) fprintf( stderr,
      "ERROR:  resid=%f, tr_dot=%f, te_dot=%f, normX=%f, normY=%f, eps=%e\n",
      resid, tr_dot, te_dot, normX, normY, EPSILON );
   } 
#else
   resid = Mabs( te_dotx[0] - tr_dotx[0] ) + Mabs( te_dotx[1] - tr_dotx[1] );
   resid = Mabs( resid ) / ( EPSILON * Mmax( normX, ATL_rone ) *
                             Mmax( normY, ATL_rone ) * N );

   if( ( resid > THRESH ) || ( resid != resid ) )
   {
      (void) fprintf( stderr, 
   "ERROR:  resid=%f, tr_dot=%f,%f, te_dot=%f,%f, normX=%f, normY=%f, eps=%e\n",
   resid, tr_dotx[0], tr_dotx[1], te_dotx[0], te_dotx[1], normX, normY,
   EPSILON );
   } 
#endif
 
   return( resid );
}

TYPE rottst
(
   const int                  CACHESIZE,
   const enum LVL1_ROUT       ROUT,
   const int                  TEST,
   const int                  N,
   const int                  INCX,
   const int                  INCY,
   const TYPE                 CO,
   const TYPE                 SI,
   const TYPE                 EPSILON,
   double                     * TTRUST0,
   double                     * TTEST0,
   double                     * MFTRUST0,
   double                     * MFTEST0
)
{
   double                     l2ret, ops, t0, ttest, ttrust;
   TYPE                       normDX, normDY, normX, normY, resid;
   TYPE                       * X = NULL, * X0, * XD = NULL, * Y = NULL,
                              * Y0, * YD = NULL, * x, * y;
   const int                  aincX = Mabs( INCX ), aincY = Mabs( INCY );
   int                        Xseed, Yseed;
 
   *TTRUST0 = *TTEST0 = *MFTEST0 = *MFTRUST0 = 0.0;
   if( N == 0 ) { return( ATL_rzero ); }

   if( CO == ATL_rone ) ops = 0.0; else ops = opbl1( ROUT, N ); 
/*
 * Allocate L2 cache space, X, Y and Y0
 */
   l2ret = ATL_flushcache( CACHESIZE );
   X  = (TYPE *)malloc( ATL_MulBySize( N ) * aincX * 2 );
   Y  = (TYPE *)malloc( ATL_MulBySize( N ) * aincY * 2 );
 
   if( ( X == NULL ) || ( Y == NULL ) )
   {
      l2ret  = ATL_flushcache( 0 );
      if( X ) free( X );
      if( Y ) free( Y );
      return( ATL_rnone );
   }
 
   X0 = X + N * ( aincX SHIFT );
   Y0 = Y + N * ( aincY SHIFT );
/*
 * Generate random operands
 */
   Xseed = N  * aincX * 27 + 213;
   Yseed = N  * aincY;
 
   Mjoin( PATL, gegen )( 1,  N, X,  aincX, Xseed );
   Mjoin( PATL, gegen )( 1,  N, X0, aincX, Xseed );
   Mjoin( PATL, gegen )( 1,  N, Y,  aincY, Yseed );
   Mjoin( PATL, gegen )( 1,  N, Y0, aincY, Yseed );
/*
 * Compute the norm of X and Y for later use in testing
 */
   if( TEST )
   {
      normX = Mjoin( PATL, infnrm )( N, X, aincX );
      if( normX == ATL_rzero ) normX = ATL_rone;
      normY = Mjoin( PATL, infnrm )( N, Y, aincY );
      if( normY == ATL_rzero ) normY = ATL_rone;
   }
   else { normX = ATL_rone; normY = ATL_rone; }
/*
 * Start cold cache timing operations for the trusted routine
 */
   x = X0; if( INCX < 0 ) x = X0 + ( ( ( 1 - N ) * INCX ) SHIFT );
   y = Y0; if( INCY < 0 ) y = Y0 + ( ( ( 1 - N ) * INCY ) SHIFT );
 
   l2ret  = ATL_flushcache( -1 );
   t0     = time00();
   trusted_rot( N, x, INCX, y, INCY, CO, SI );
   ttrust = time00() - t0;
   if( ttrust > 0.0 )
   { *TTRUST0 = ttrust; *MFTRUST0 = ops / ( ttrust * MEGA ); }
/*
 * Start cold cache timing operations for the tested routine
 */
   x = X; if( INCX < 0 ) x = X + ( ( ( 1 - N ) * INCX ) SHIFT );
   y = Y; if( INCY < 0 ) y = Y + ( ( ( 1 - N ) * INCY ) SHIFT );
 
   l2ret = ATL_flushcache( -1 );
   t0    = time00();
   test_rot( N, x, INCX, y, INCY, CO, SI );
   ttest = time00() - t0;
   if( ttest  > 0.0 )
   { *TTEST0  = ttest;  *MFTEST0  = ops / ( ttest  * MEGA ); }
/*
 * if timing only, I am done ... so leave.
 */
   l2ret  = ATL_flushcache( 0 );
 
   if( !( TEST ) ) { free( X ); free( Y ); return( ATL_rzero ); }
/*
 * else perform error check - Ensure the difference of the output operands
 * is relatively tiny enough
 */
   XD = (TYPE *)malloc( ATL_MulBySize( N ) );
   if( XD == NULL ) { free( X ); free( Y ); return( ATL_rnone ); }

   YD = (TYPE *)malloc( ATL_MulBySize( N ) );
   if( YD == NULL ) { free( XD ); free( X ); free( Y ); return( ATL_rnone ); }
 
   Mjoin( PATL, vdiff )( N, X, aincX, X0, aincX, XD, 1 );
   Mjoin( PATL, vdiff )( N, Y, aincY, Y0, aincY, YD, 1 );
 
   normDX = Mjoin( PATL, infnrm )( N, XD, 1 );
   normDY = Mjoin( PATL, infnrm )( N, YD, 1 );

   resid = Mmax( normDX, normDY ) / ( EPSILON * Mmax( normX, ATL_rone ) *
                                      Mmax( normY, ATL_rone ) * N );

   if( ( resid > THRESH ) || ( resid != resid ) )
   {
      (void) fprintf( stderr,
      "ERROR:  resid=%f, normDX=%f, normDY=%f, eps=%e\n",
      resid, normDX, normDY, EPSILON );
#ifdef ATLAS_DEBUG
      Mjoin( PATL, geprint )( "X_trusted", 1, N, X0, aincX );
      Mjoin( PATL, geprint )( "Y_trusted", 1, N, Y0, aincY );
      Mjoin( PATL, geprint )( "X_test",    1, N, X,  aincX );
      Mjoin( PATL, geprint )( "Y_test",    1, N, Y,  aincY );
#endif
   }
 
   free( YD );
   free( XD );
   free( Y  );
   free( X );
 
   return( resid );
} 

#ifdef TREAL
TYPE rotmtst
(
   const int                  CACHESIZE,
   const enum LVL1_ROUT       ROUT,
   const int                  TEST,
   const int                  N,
   const int                  INCX,
   const int                  INCY,
   const TYPE                 * PARAM,
   const TYPE                 EPSILON,
   double                     * TTRUST0,
   double                     * TTEST0,
   double                     * MFTRUST0,
   double                     * MFTEST0
)
{
   double                     l2ret, ops, t0, ttest, ttrust;
   TYPE                       normDX, normDY, normX, normY, resid;
   TYPE                       * X = NULL, * X0, * XD = NULL, * Y = NULL,
                              * Y0, * YD = NULL, * x, * y;
   const int                  aincX = Mabs( INCX ), aincY = Mabs( INCY );
   int                        Xseed, Yseed;
 
   *TTRUST0 = *TTEST0 = *MFTEST0 = *MFTRUST0 = 0.0;
   if( N == 0 ) { return( ATL_rzero ); }
 
   ops = opbl1( ROUT, N );
/*
 * Allocate L2 cache space, X, Y and Y0
 */
   l2ret = ATL_flushcache( CACHESIZE );
   X  = (TYPE *)malloc( ATL_MulBySize( N ) * aincX * 2 );
   Y  = (TYPE *)malloc( ATL_MulBySize( N ) * aincY * 2 );
 
   if( ( X == NULL ) || ( Y == NULL ) )
   {
      l2ret  = ATL_flushcache( 0 );
      if( X ) free( X );
      if( Y ) free( Y );
      return( ATL_rnone );
   }
 
   X0 = X + N * ( aincX SHIFT );
   Y0 = Y + N * ( aincY SHIFT );
/*
 * Generate random operands
 */
   Xseed = N  * aincX * 27 + 213;
   Yseed = N  * aincY;
 
   Mjoin( PATL, gegen )( 1,  N, X,  aincX, Xseed );
   Mjoin( PATL, gegen )( 1,  N, X0, aincX, Xseed );
   Mjoin( PATL, gegen )( 1,  N, Y,  aincY, Yseed );
   Mjoin( PATL, gegen )( 1,  N, Y0, aincY, Yseed );
/*
 * Compute the norm of X and Y for later use in testing
 */
   if( TEST )
   {
      normX = Mjoin( PATL, infnrm )( N, X, aincX );
      if( normX == ATL_rzero ) normX = ATL_rone;
      normY = Mjoin( PATL, infnrm )( N, Y, aincY );
      if( normY == ATL_rzero ) normY = ATL_rone;
   }
   else { normX = ATL_rone; normY = ATL_rone; }
/*
 * Start cold cache timing operations for the trusted routine
 */
   x = X0; if( INCX < 0 ) x = X0 + ( ( ( 1 - N ) * INCX ) SHIFT );
   y = Y0; if( INCY < 0 ) y = Y0 + ( ( ( 1 - N ) * INCY ) SHIFT );
 
   l2ret  = ATL_flushcache( -1 );
   t0     = time00();
   trusted_rotm( N, x, INCX, y, INCY, PARAM );
   ttrust = time00() - t0;
   if( ttrust > 0.0 )
   { *TTRUST0 = ttrust; *MFTRUST0 = ops / ( ttrust * MEGA ); }
/*
 * Start cold cache timing operations for the tested routine
 */
   x = X; if( INCX < 0 ) x = X + ( ( ( 1 - N ) * INCX ) SHIFT );
   y = Y; if( INCY < 0 ) y = Y + ( ( ( 1 - N ) * INCY ) SHIFT );
 
   l2ret = ATL_flushcache( -1 );
   t0    = time00();
   test_rotm( N, x, INCX, y, INCY, PARAM );
   ttest = time00() - t0;
   if( ttest  > 0.0 )
   { *TTEST0  = ttest;  *MFTEST0  = ops / ( ttest  * MEGA ); }
/*
 * if timing only, I am done ... so leave.
 */
   l2ret  = ATL_flushcache( 0 );
 
   if( !( TEST ) ) { free( X ); free( Y ); return( ATL_rzero ); }
/*
 * else perform error check - Ensure the difference of the output operands
 * is relatively tiny enough
 */
   XD = (TYPE *)malloc( ATL_MulBySize( N ) );
   if( XD == NULL ) { free( X ); free( Y ); return( ATL_rnone ); }

   YD = (TYPE *)malloc( ATL_MulBySize( N ) );
   if( YD == NULL ) { free( XD ); free( X ); free( Y ); return( ATL_rnone ); }
 
   Mjoin( PATL, vdiff )( N, X, aincX, X0, aincX, XD, 1 );
   Mjoin( PATL, vdiff )( N, Y, aincY, Y0, aincY, YD, 1 );
 
   normDX = Mjoin( PATL, infnrm )( N, XD, 1 );
   normDY = Mjoin( PATL, infnrm )( N, YD, 1 );

   resid = Mmax( normDX, normDY ) / ( EPSILON * Mmax( normX, ATL_rone ) *
                                      Mmax( normY, ATL_rone ) * N );

   if( ( resid > THRESH ) || ( resid != resid ) )
   {
      (void) fprintf( stderr,
      "ERROR:  resid=%f, normDX=%f, normDY=%f, eps=%e\n",
      resid, normDX, normDY, EPSILON );
#ifdef ATLAS_DEBUG
      Mjoin( PATL, geprint )( "X_trusted", 1, N, X0, aincX );
      Mjoin( PATL, geprint )( "Y_trusted", 1, N, Y0, aincY );
      Mjoin( PATL, geprint )( "X_test",    1, N, X,  aincX );
      Mjoin( PATL, geprint )( "Y_test",    1, N, Y,  aincY );
#endif
   }
 
   free( YD );
   free( XD );
   free( Y  );
   free( X );
 
   return( resid );
} 
#endif

/*
 * =====================================================================
 * case functions
 * =====================================================================
 */
int rotgcase
(
   const int                  CACHESIZE,
   const enum LVL1_ROUT       ROUT,
   const int                  TEST,
   const int                  MFLOP,
   const TYPE                 EPSILON,
   double                     * TTRUST0,
   double                     * TTEST0,
   double                     * MFTRUST0,
   double                     * MFTEST0
)
{ 
   TYPE                       resid = ATL_rzero;
   int                        passed;
 
   resid = rotgtst( CACHESIZE, ROUT, TEST, EPSILON, TTRUST0, TTEST0,
		    MFTRUST0, MFTEST0 );
   if( resid > THRESH ) (void) fprintf( stderr, "   resid=%f\n", resid );

   if( resid < ATL_rzero ) passed = -1;
   else                    passed = ( resid < THRESH );
 
   return( passed ); 
}

#ifdef TREAL
int rotmgcase
(
   const int                  CACHESIZE,
   const enum LVL1_ROUT       ROUT,
   const int                  TEST,
   const int                  MFLOP,
   const TYPE                 EPSILON,
   double                     * TTRUST0,
   double                     * TTEST0,
   double                     * MFTRUST0,
   double                     * MFTEST0
)
{
   TYPE                       resid = ATL_rzero;
   int                        passed;
 
   resid = rotmgtst( CACHESIZE, ROUT, TEST, EPSILON, TTRUST0, TTEST0,
		     MFTRUST0, MFTEST0 );
   if( resid > THRESH ) (void) fprintf( stderr, "   resid=%f\n", resid );
 
   if( resid < ATL_rzero ) passed = -1;
   else                    passed = ( resid < THRESH );
 
   return( passed );
} 
#endif

int sumcase
(
   const int                  CACHESIZE,
   const enum LVL1_ROUT       ROUT,
   const int                  TEST,
   const int                  MFLOP,
   const int                  N,
   const int                  INCX,
   const TYPE                 EPSILON,
   double                     * TTRUST0,
   double                     * TTEST0,
   double                     * MFTRUST0,
   double                     * MFTEST0
)
{
   double                     flops, ttrust, ttest, mftrust, mftest, t0;
   TYPE                       * stX, * x, * X, * X0 = NULL;
   TYPE                       resid = ATL_rzero, te_sum, tr_sum;
   unsigned long              ir, reps;
   int                        aincX, incx, lX, passed, Xseed;
 
   if( ( MEGA * MFLOP <= ( flops = opbl1( ROUT, N ) ) ) || ( TEST ) )
   {
      resid = sumtst( CACHESIZE, ROUT, TEST, N, INCX, EPSILON, TTRUST0, 
		      TTEST0, MFTRUST0, MFTEST0 );
      if( resid > THRESH ) (void) fprintf( stderr, "   resid=%f\n", resid );
   }
   if( resid < ATL_rzero ) passed = -1;
   else                    passed = ( resid < THRESH );
 
   if( MEGA * MFLOP <= flops ) return( passed );
 
   incx = INCX * ( N  SHIFT ), aincX = Mabs( INCX );
 
   lX = N * aincX * ( ( ATL_DivBySize( LCSIZE ) + N - 1 ) / N );
 
   X0 = (TYPE *)malloc( ATL_MulBySize( lX ) );
 
   if( X0 == NULL ) { if( X0 ) free( X0 ); return( -1 ); }
 
   if( INCX < 1 ) { X = X0 + ( lX SHIFT ); stX = X0; }
   else           { X = X0; stX = X0 + ( lX SHIFT ); }
 
   Xseed = N * aincX + 127 * 50 + 77;
 
   reps  = ( MEGA * MFLOP ) / flops;
/*
 * Generate the random data and time the trusted routine
 */
   x = X;
 
   Mjoin( PATL, gegen )( lX, 1, X0, lX, Xseed );
 
   t0 = time00();
   for( ir = reps; ir; ir-- )
   {
      tr_sum = trusted_asum( N, x, INCX );
      x += incx; if( x == stX ) { x = X; }
   }
   ttrust = time00() - t0;
   if( ttrust > 0.0 ) mftrust = ( reps * flops ) / ( MEGA * ttrust );
   else               mftrust = 0.0;
   ttrust /= reps; *TTRUST0 = ttrust; *MFTRUST0 = mftrust;
/*
 * Generate the random data and time the tested routine
 */
   x = X;
 
   Mjoin( PATL, gegen )( lX, 1, X0, lX, Xseed );

   t0 = time00();
   for( ir = reps; ir; ir-- )
   {
      te_sum = test_asum( N, x, INCX );
      x += incx; if( x == stX ) { x = X; }
   }
   ttest = time00() - t0;
   if( ttest  > 0.0 ) mftest  = ( reps * flops ) / ( MEGA * ttest  );
   else               mftest  = 0.0;
   ttest  /= reps; *TTEST0  = ttest;  *MFTEST0  = mftest;
/*
 * release the memory and exit
 */
   free( X0 );
 
   return( passed );
}

int nrmcase
(
   const int                  CACHESIZE,
   const enum LVL1_ROUT       ROUT,
   const int                  TEST,
   const int                  MFLOP,
   const int                  N,
   const int                  INCX,
   const TYPE                 EPSILON,
   double                     * TTRUST0,
   double                     * TTEST0,
   double                     * MFTRUST0,
   double                     * MFTEST0
)
{
   double                     flops, ttrust, ttest, mftrust, mftest, t0;
   TYPE                       resid = ATL_rzero, te_nrm, tr_nrm;
   TYPE                       * stX, * x, * X, * X0 = NULL;
   unsigned long              ir, reps;
   int                        aincX, incx, lX, passed, Xseed;
 
   if( ( MEGA * MFLOP <= ( flops = opbl1( ROUT, N ) ) ) || ( TEST ) )
   {
      resid = nrmtst( CACHESIZE, ROUT, TEST, N, INCX, EPSILON, TTRUST0,
		      TTEST0, MFTRUST0, MFTEST0 );
      if( resid > THRESH ) (void) fprintf( stderr, "   resid=%f\n", resid );
   }
   if( resid < ATL_rzero ) passed = -1;
   else                    passed = ( resid < THRESH );
 
   if( MEGA * MFLOP <= flops ) return( passed );
 
   incx = INCX * ( N  SHIFT ), aincX = Mabs( INCX );
 
   lX = N * aincX * ( ( ATL_DivBySize( LCSIZE ) + N - 1 ) / N );
 
   X0 = (TYPE *)malloc( ATL_MulBySize( lX ) );
 
   if( X0 == NULL ) { if( X0 ) free( X0 ); return( -1 ); }
 
   if( INCX < 1 ) { X = X0 + ( lX SHIFT ); stX = X0; }
   else           { X = X0; stX = X0 + ( lX SHIFT ); }
 
   Xseed = N * aincX + 127 * 50 + 77;
 
   reps  = ( MEGA * MFLOP ) / flops;
/*
 * Generate the random data and time the trusted routine
 */
   x = X;
 
   Mjoin( PATL, gegen )( lX, 1, X0, lX, Xseed );
 
   t0 = time00();
   for( ir = reps; ir; ir-- )
   {
      tr_nrm = trusted_nrm2( N, x, INCX );
      x += incx; if( x == stX ) { x = X; }
   }
   ttrust = time00() - t0;
   if( ttrust > 0.0 ) mftrust = ( reps * flops ) / ( MEGA * ttrust );
   else               mftrust = 0.0;
   ttrust /= reps; *TTRUST0 = ttrust; *MFTRUST0 = mftrust;
/*
 * Generate the random data and time the tested routine
 */
   x = X;
 
   Mjoin( PATL, gegen )( lX, 1, X0, lX, Xseed );

   t0 = time00();
   for( ir = reps; ir; ir-- )
   {
      te_nrm = test_nrm2( N, x, INCX );
      x += incx; if( x == stX ) { x = X; }
   }
   ttest = time00() - t0;
   if( ttest  > 0.0 ) mftest  = ( reps * flops ) / ( MEGA * ttest  );
   else               mftest  = 0.0;
   ttest  /= reps; *TTEST0  = ttest;  *MFTEST0  = mftest;
/*
 * release the memory and exit
 */
   free( X0 );
 
   return( passed );
}

int maxcase
(
   const int                  CACHESIZE,
   const enum LVL1_ROUT       ROUT,
   const int                  TEST,
   const int                  MFLOP,
   const int                  N,
   const int                  INCX,
   const TYPE                 EPSILON,
   double                     * TTRUST0,
   double                     * TTEST0,
   double                     * MFTRUST0,
   double                     * MFTEST0
)
{
   double                     flops, ttrust, ttest, mftrust, mftest, t0;
   TYPE                       resid = ATL_rzero;
   TYPE                       * stX, * x, * X, * X0 = NULL;
   unsigned long              ir, reps;
   int                        aincX, incx, lX, passed, te_max, tr_max, Xseed;
 
   if( ( MEGA * MFLOP <= ( flops = opbl1( ROUT, N ) ) ) || ( TEST ) )
   {
      resid = maxtst( CACHESIZE, ROUT, TEST, N, INCX, EPSILON, TTRUST0,
		      TTEST0, MFTRUST0, MFTEST0 );
      if( resid > THRESH ) (void) fprintf( stderr, "   resid=%f\n", resid );
   }
   if( resid < ATL_rzero ) passed = -1;
   else                    passed = ( resid < THRESH );
 
   if( MEGA * MFLOP <= flops ) return( passed );
 
   incx = INCX * ( N  SHIFT ), aincX = Mabs( INCX );
 
   lX = N * aincX * ( ( ATL_DivBySize( LCSIZE ) + N - 1 ) / N );
 
   X0 = (TYPE *)malloc( ATL_MulBySize( lX ) );
 
   if( X0 == NULL ) { if( X0 ) free( X0 ); return( -1 ); }
 
   if( INCX < 1 ) { X = X0 + ( lX SHIFT ); stX = X0; }
   else           { X = X0; stX = X0 + ( lX SHIFT ); }
 
   Xseed = N * aincX + 127 * 50 + 77;
 
   reps  = ( MEGA * MFLOP ) / flops;
/*
 * Generate the random data and time the trusted routine
 */
   x = X;
 
   Mjoin( PATL, gegen )( lX, 1, X0, lX, Xseed );
 
   t0 = time00();
   for( ir = reps; ir; ir-- )
   {
      tr_max = trusted_amax( N, x, INCX );
      x += incx; if( x == stX ) { x = X; }
   }
   ttrust = time00() - t0;
   if( ttrust > 0.0 ) mftrust = ( reps * flops ) / ( MEGA * ttrust );
   else               mftrust = 0.0;
   ttrust /= reps; *TTRUST0 = ttrust; *MFTRUST0 = mftrust;
/*
 * Generate the random data and time the tested routine
 */
   x = X;
 
   Mjoin( PATL, gegen )( lX, 1, X0, lX, Xseed );

   t0 = time00();
   for( ir = reps; ir; ir-- )
   {
      te_max = test_amax( N, x, INCX );
      x += incx; if( x == stX ) { x = X; }
   }
   ttest = time00() - t0;
   if( ttest  > 0.0 ) mftest  = ( reps * flops ) / ( MEGA * ttest  );
   else               mftest  = 0.0;
   ttest  /= reps; *TTEST0  = ttest;  *MFTEST0  = mftest;
/*
 * release the memory and exit
 */
   free( X0 );
 
   return( passed );
}

int sclcase
(
   const int                  CACHESIZE,
   const enum LVL1_ROUT       ROUT,
   const int                  TEST,
   const int                  MFLOP,
   const int                  N,
   const SCALAR               ALPHA,
   const int                  INCX,
   const TYPE                 EPSILON,
   double                     * TTRUST0,
   double                     * TTEST0,
   double                     * MFTRUST0,
   double                     * MFTEST0
)
{
   double                     flops, ttrust, ttest, mftrust, mftest, t0;
   TYPE                       resid = ATL_rzero;
   TYPE                       * stX, * x, * X, * X0 = NULL;
   unsigned long              ir, reps;
   int                        aincX, incx, lX, passed, Xseed;

   if( ( MEGA * MFLOP <= ( flops = opbl1( ROUT, N ) ) ) || ( TEST ) )
   {
      resid = scltst( CACHESIZE, ROUT, TEST, N, ALPHA, INCX, EPSILON,
		      TTRUST0, TTEST0, MFTRUST0, MFTEST0 );
      if( resid > THRESH ) (void) fprintf( stderr, "   resid=%f\n", resid );
   }
   if( resid < ATL_rzero ) passed = -1;
   else                    passed = ( resid < THRESH );

   if( ( MEGA * MFLOP <= flops ) || ( SCALAR_IS_ONE( ALPHA ) ) )
      return( passed ); 
 
   incx = INCX * ( N  SHIFT ), aincX = Mabs( INCX );
 
   lX = N * aincX * ( ( ATL_DivBySize( LCSIZE ) + N - 1 ) / N );
 
   X0 = (TYPE *)malloc( ATL_MulBySize( lX ) );
 
   if( X0 == NULL ) { if( X0 ) free( X0 ); return( -1 ); }
 
   if( INCX < 1 ) { X = X0 + ( lX SHIFT ); stX = X0; }
   else           { X = X0; stX = X0 + ( lX SHIFT ); }
 
   Xseed = N * aincX + 127 * 50 + 77;
 
   reps  = ( MEGA * MFLOP ) / flops;
/*
 * Generate the random data and time the trusted routine
 */
   x = X;
 
   Mjoin( PATL, gegen )( lX, 1, X0, lX, Xseed );
 
   t0 = time00();
   for( ir = reps; ir; ir-- )
   {
      trusted_scal( N, ALPHA, x, INCX );
      x += incx; if( x == stX ) { x = X; }
   }
   ttrust = time00() - t0;
   if( ttrust > 0.0 ) mftrust = ( reps * flops ) / ( MEGA * ttrust );
   else               mftrust = 0.0;
   ttrust /= reps; *TTRUST0 = ttrust; *MFTRUST0 = mftrust;
/*
 * Generate the random data and time the tested routine
 */
   x = X;
 
   Mjoin( PATL, gegen )( lX, 1, X0, lX, Xseed );

   t0 = time00();
   for( ir = reps; ir; ir-- )
   {
      test_scal( N, ALPHA, x, INCX );
      x += incx; if( x == stX ) { x = X; }
   }
   ttest = time00() - t0;
   if( ttest  > 0.0 ) mftest  = ( reps * flops ) / ( MEGA * ttest  );
   else               mftest  = 0.0;
   ttest  /= reps; *TTEST0  = ttest;  *MFTEST0  = mftest;
/*
 * release the memory and exit
 */
   free( X0 );
 
   return( passed );
}

#ifdef TCPLX
int rsccase
(
   const int                  CACHESIZE,
   const enum LVL1_ROUT       ROUT,
   const int                  TEST,
   const int                  MFLOP,
   const int                  N,
   const SCALAR               ALPHA,
   const int                  INCX,
   const TYPE                 EPSILON,
   double                     * TTRUST0,
   double                     * TTEST0,
   double                     * MFTRUST0,
   double                     * MFTEST0
)
{
   double                     flops, ttrust, ttest, mftrust, mftest, t0;
   TYPE                       resid = ATL_rzero, Calph[2];
   TYPE                       * stX, * x, * X, * X0 = NULL;
   unsigned long              ir, reps;
   int                        aincX, incx, lX, passed, Xseed;

   if( ( MEGA * MFLOP <= ( flops = opbl1( ROUT, N ) ) ) || ( TEST ) )
   {
      resid = rsctst( CACHESIZE, ROUT, TEST, N, ALPHA, INCX, EPSILON,
		      TTRUST0, TTEST0, MFTRUST0, MFTEST0 );
      if( resid > THRESH ) (void) fprintf( stderr, "   resid=%f\n", resid );
   }
   if( resid < ATL_rzero ) passed = -1;
   else                    passed = ( resid < THRESH );
 
   if( ( MEGA * MFLOP <= flops ) || ( *ALPHA == ATL_rone ) ) return( passed );
 
   incx = INCX * ( N  SHIFT ), aincX = Mabs( INCX );
 
   lX = N * aincX * ( ( ATL_DivBySize( LCSIZE ) + N - 1 ) / N );
 
   X0 = (TYPE *)malloc( ATL_MulBySize( lX ) );
 
   if( X0 == NULL ) { if( X0 ) free( X0 ); return( -1 ); }
 
   if( INCX < 1 ) { X = X0 + ( lX SHIFT ); stX = X0; }
   else           { X = X0; stX = X0 + ( lX SHIFT ); }
 
   Xseed = N * aincX + 127 * 50 + 77;
 
   reps  = ( MEGA * MFLOP ) / flops;

   Calph[0] = *ALPHA; Calph[1] = ATL_rzero;
/*
 * Generate the random data and time the trusted routine
 */
   x = X;
 
   Mjoin( PATL, gegen )( lX, 1, X0, lX, Xseed );
 
   t0 = time00();
   for( ir = reps; ir; ir-- )
   {
#if   defined( USE_F77_BLAS ) || defined( USE_L1_REFERENCE )
      trusted_rscal( N, Calph[0], x, INCX );
#else
      trusted_rscal( N, Calph,    x, INCX );
#endif
      x += incx; if( x == stX ) { x = X; }
   }
   ttrust = time00() - t0;
   if( ttrust > 0.0 ) mftrust = ( reps * flops ) / ( MEGA * ttrust );
   else               mftrust = 0.0;
   ttrust /= reps; *TTRUST0 = ttrust; *MFTRUST0 = mftrust;
/*
 * Generate the random data and time the tested routine
 */
   x = X;
 
   Mjoin( PATL, gegen )( lX, 1, X0, lX, Xseed );

   t0 = time00();
   for( ir = reps; ir; ir-- )
   {
#if   defined( USE_L1_PTHREADS )
      test_rscal( N, Calph[0], x, INCX );
#else
      test_rscal( N, Calph,    x, INCX );
#endif
      x += incx; if( x == stX ) { x = X; }
      if( Calph[0] != ATL_rzero ) Calph[0] = ATL_rone / Calph[0];
   }
   ttest = time00() - t0;
   if( ttest  > 0.0 ) mftest  = ( reps * flops ) / ( MEGA * ttest  );
   else               mftest  = 0.0;
   ttest  /= reps; *TTEST0  = ttest;  *MFTEST0  = mftest;
/*
 * release the memory and exit
 */
   free( X0 );
 
   return( passed );
}
#endif

int xpycase
(
   const int                  CACHESIZE,
   const enum LVL1_ROUT       ROUT,
   const int                  TEST,
   const int                  MFLOP,
   const int                  N,
   const SCALAR               ALPHA,
   const int                  INCX,
   const int                  INCY,
   const TYPE                 EPSILON,
   double                     * TTRUST0,
   double                     * TTEST0,
   double                     * MFTRUST0,
   double                     * MFTEST0
)
{
   double                     flops, ttrust, ttest, mftrust, mftest, t0;
   TYPE                       resid = ATL_rzero;
   TYPE                       * stX, * stY, * x, * y, * X, * X0 = NULL,
                              * Y, * Y0 = NULL;
   unsigned long              ir, reps;
   int                        aincX, aincY, incx, incy, lX, lY, passed,
                              Xseed, Yseed;
 
   if( ( MEGA * MFLOP <= ( flops = opbl1( ROUT, N ) ) ) || ( TEST ) )
   {
      resid = xpytst( CACHESIZE, ROUT, TEST, N, ALPHA, INCX, INCY, EPSILON,
		      TTRUST0, TTEST0, MFTRUST0, MFTEST0 );
      if( resid > THRESH ) (void) fprintf( stderr, "   resid=%f\n", resid );
   }
   if( resid < ATL_rzero ) passed = -1;
   else                    passed = ( resid < THRESH );
 
   if( MEGA * MFLOP <= flops ) return( passed );

   incy = INCY * ( N  SHIFT ); aincY = Mabs( INCY );
   incx = INCX * ( N  SHIFT ), aincX = Mabs( INCX );
 
   lY = N * aincY * ( ( ATL_DivBySize( LCSIZE ) + N - 1 ) / N );
   lX = N * aincX * ( ( ATL_DivBySize( LCSIZE ) + N - 1 ) / N );

   Y0 = (TYPE *)malloc( ATL_MulBySize( lY ) );
   X0 = (TYPE *)malloc( ATL_MulBySize( lX ) );
 
   if( ( Y0 == NULL ) || ( X0 == NULL ) )
   {
      if( Y0 ) free( Y0 );
      if( X0 ) free( X0 );
      return( -1 );
   }
 
   if( INCY < 1 ) { Y = Y0 + ( lY SHIFT ); stY = Y0; }
   else           { Y = Y0; stY = Y0 + ( lY SHIFT ); }
   if( INCX < 1 ) { X = X0 + ( lX SHIFT ); stX = X0; }
   else           { X = X0; stX = X0 + ( lX SHIFT ); }
 
   Yseed = N * aincY;
   Xseed = N * aincX + 127 * 50 + 77;
 
   reps  = ( MEGA * MFLOP ) / flops;
/*
 * Generate the random data and time the trusted routine
 */
   y = Y; x = X;
 
   Mjoin( PATL, gegen )( lY, 1, Y0, lY, Yseed );
   Mjoin( PATL, gegen )( lX, 1, X0, lX, Xseed );

   t0 = time00();
   for( ir = reps; ir; ir-- )
   {
      trusted_axpy( N, ALPHA, x, INCX, y, INCY );
      y += incy; if( y == stY ) { y = Y; }
      x += incx; if( x == stX ) { x = X; }
   }
   ttrust = time00() - t0;
   if( ttrust > 0.0 ) mftrust = ( reps * flops ) / ( MEGA * ttrust );
   else               mftrust = 0.0;
   ttrust /= reps; *TTRUST0 = ttrust; *MFTRUST0 = mftrust;
/*
 * Generate the random data and time the tested routine
 */
   y = Y; x = X;
 
   Mjoin( PATL, gegen )( lY, 1, Y0, lY, Yseed );
   Mjoin( PATL, gegen )( lX, 1, X0, lX, Xseed );
 
   t0 = time00();
   for( ir = reps; ir; ir-- )
   {
      test_axpy( N, ALPHA, x, INCX, y, INCY );
      y += incy; if( y == stY ) { y = Y; }
      x += incx; if( x == stX ) { x = X; }
   }
   ttest = time00() - t0;
   if( ttest  > 0.0 ) mftest  = ( reps * flops ) / ( MEGA * ttest  );
   else               mftest  = 0.0;
   ttest  /= reps; *TTEST0  = ttest;  *MFTEST0  = mftest;
/*
 * release the memory and exit
 */
   free( Y0 );
   free( X0 );
 
   return( passed );
}

int cpycase
(
   const int                  CACHESIZE,
   const enum LVL1_ROUT       ROUT,
   const int                  TEST,
   const int                  MFLOP,
   const int                  N,
   const int                  INCX,
   const int                  INCY,
   const TYPE                 EPSILON,
   double                     * TTRUST0,
   double                     * TTEST0,
   double                     * MFTRUST0,
   double                     * MFTEST0
)
{
   double                     flops, ttrust, ttest, mftrust, mftest, t0;
   TYPE                       resid = ATL_rzero;
   TYPE                       * stX, * stY, * x, * y, * X, * X0 = NULL,
                              * Y, * Y0 = NULL;
   unsigned long              ir, reps;
   int                        aincX, aincY, incx, incy, lX, lY, passed,
                              Xseed, Yseed;
 
   if( ( MEGA * MFLOP <= ( flops = opbl1( ROUT, N ) ) ) || ( TEST ) )
   {
      resid = cpytst( CACHESIZE, ROUT, TEST, N, INCX, INCY, EPSILON, TTRUST0,
		      TTEST0, MFTRUST0, MFTEST0 );
      if( resid > THRESH ) (void) fprintf( stderr, "   resid=%f\n", resid );
   }
   if( resid < ATL_rzero ) passed = -1;
   else                    passed = ( resid < THRESH );
 
   if( MEGA * MFLOP <= flops ) return( passed );

   incy = INCY * ( N  SHIFT ); aincY = Mabs( INCY );
   incx = INCX * ( N  SHIFT ), aincX = Mabs( INCX );
 
   lY = N * aincY * ( ( ATL_DivBySize( LCSIZE ) + N - 1 ) / N );
   lX = N * aincX * ( ( ATL_DivBySize( LCSIZE ) + N - 1 ) / N );

   Y0 = (TYPE *)malloc( ATL_MulBySize( lY ) );
   X0 = (TYPE *)malloc( ATL_MulBySize( lX ) );
 
   if( ( Y0 == NULL ) || ( X0 == NULL ) )
   {
      if( Y0 ) free( Y0 );
      if( X0 ) free( X0 );
      return( -1 );
   }
 
   if( INCY < 1 ) { Y = Y0 + ( lY SHIFT ); stY = Y0; }
   else           { Y = Y0; stY = Y0 + ( lY SHIFT ); }
   if( INCX < 1 ) { X = X0 + ( lX SHIFT ); stX = X0; }
   else           { X = X0; stX = X0 + ( lX SHIFT ); }
 
   Yseed = N * aincY;
   Xseed = N * aincX + 127 * 50 + 77;
 
   reps  = ( MEGA * MFLOP ) / flops;
/*
 * Generate the random data and time the trusted routine
 */
   y = Y; x = X;
 
   Mjoin( PATL, gegen )( lY, 1, Y0, lY, Yseed );
   Mjoin( PATL, gegen )( lX, 1, X0, lX, Xseed );

   t0 = time00();
   for( ir = reps; ir; ir-- )
   {
      trusted_copy( N, x, INCX, y, INCY );
      y += incy; if( y == stY ) { y = Y; }
      x += incx; if( x == stX ) { x = X; }
   }
   ttrust = time00() - t0;
   if( ttrust > 0.0 ) mftrust = ( reps * flops ) / ( MEGA * ttrust );
   else               mftrust = 0.0;
   ttrust /= reps; *TTRUST0 = ttrust; *MFTRUST0 = mftrust;
/*
 * Generate the random data and time the tested routine
 */
   y = Y; x = X;
 
   Mjoin( PATL, gegen )( lY, 1, Y0, lY, Yseed );
   Mjoin( PATL, gegen )( lX, 1, X0, lX, Xseed );
 
   t0 = time00();
   for( ir = reps; ir; ir-- )
   {
      test_copy( N, x, INCX, y, INCY );
      y += incy; if( y == stY ) { y = Y; }
      x += incx; if( x == stX ) { x = X; }
   }
   ttest = time00() - t0;
   if( ttest  > 0.0 ) mftest  = ( reps * flops ) / ( MEGA * ttest  );
   else               mftest  = 0.0;
   ttest  /= reps; *TTEST0  = ttest;  *MFTEST0  = mftest;
/*
 * release the memory and exit
 */
   free( Y0 );
   free( X0 );
 
   return( passed );
}

int swpcase
(
   const int                  CACHESIZE,
   const enum LVL1_ROUT       ROUT,
   const int                  TEST,
   const int                  MFLOP,
   const int                  N,
   const int                  INCX,
   const int                  INCY,
   const TYPE                 EPSILON,
   double                     * TTRUST0,
   double                     * TTEST0,
   double                     * MFTRUST0,
   double                     * MFTEST0
)
{
   double                     flops, ttrust, ttest, mftrust, mftest, t0;
   TYPE                       resid = ATL_rzero;
   TYPE                       * stX, * stY, * x, * y, * X, * X0 = NULL,
                              * Y, * Y0 = NULL;
   unsigned long              ir, reps;
   int                        aincX, aincY, incx, incy, lX, lY, passed,
                              Xseed, Yseed;
 
   if( ( MEGA * MFLOP <= ( flops = opbl1( ROUT, N ) ) ) || ( TEST ) )
   {
      resid = swptst( CACHESIZE, ROUT, TEST, N, INCX, INCY, EPSILON, TTRUST0,
		      TTEST0, MFTRUST0, MFTEST0 );
      if( resid > THRESH ) (void) fprintf( stderr, "   resid=%f\n", resid );
   }
   if( resid < ATL_rzero ) passed = -1;
   else                    passed = ( resid < THRESH );
 
   if( MEGA * MFLOP <= flops ) return( passed );
 
   incy = INCY * ( N  SHIFT ); aincY = Mabs( INCY );
   incx = INCX * ( N  SHIFT ), aincX = Mabs( INCX );
 
   lY = N * aincY * ( ( ATL_DivBySize( LCSIZE ) + N - 1 ) / N );
   lX = N * aincX * ( ( ATL_DivBySize( LCSIZE ) + N - 1 ) / N );
 
   Y0 = (TYPE *)malloc( ATL_MulBySize( lY ) );
   X0 = (TYPE *)malloc( ATL_MulBySize( lX ) );
 
   if( ( Y0 == NULL ) || ( X0 == NULL ) )
   {
      if( Y0 ) free( Y0 );
      if( X0 ) free( X0 );
      return( -1 );
   }
 
   if( INCY < 1 ) { Y = Y0 + ( lY SHIFT ); stY = Y0; }
   else           { Y = Y0; stY = Y0 + ( lY SHIFT ); }
   if( INCX < 1 ) { X = X0 + ( lX SHIFT ); stX = X0; }
   else           { X = X0; stX = X0 + ( lX SHIFT ); }
 
   Yseed = N * aincY;
   Xseed = N * aincX + 127 * 50 + 77;
 
   reps  = ( MEGA * MFLOP ) / flops;
/*
 * Generate the random data and time the trusted routine
 */
   y = Y; x = X;
 
   Mjoin( PATL, gegen )( lY, 1, Y0, lY, Yseed );
   Mjoin( PATL, gegen )( lX, 1, X0, lX, Xseed );
 
   t0 = time00();
   for( ir = reps; ir; ir-- )
   {
      trusted_swap( N, x, INCX, y, INCY );
      y += incy; if( y == stY ) { y = Y; }
      x += incx; if( x == stX ) { x = X; }
   }
   ttrust = time00() - t0;
   if( ttrust > 0.0 ) mftrust = ( reps * flops ) / ( MEGA * ttrust );
   else               mftrust = 0.0;
   ttrust /= reps; *TTRUST0 = ttrust; *MFTRUST0 = mftrust;
/*
 * Generate the random data and time the tested routine
 */
   y = Y; x = X;
 
   Mjoin( PATL, gegen )( lY, 1, Y0, lY, Yseed );
   Mjoin( PATL, gegen )( lX, 1, X0, lX, Xseed );
 
   t0 = time00();
   for( ir = reps; ir; ir-- )
   {
      test_swap( N, x, INCX, y, INCY );
      y += incy; if( y == stY ) { y = Y; }
      x += incx; if( x == stX ) { x = X; }
   }
   ttest = time00() - t0;
   if( ttest  > 0.0 ) mftest  = ( reps * flops ) / ( MEGA * ttest  );
   else               mftest  = 0.0;
   ttest  /= reps; *TTEST0  = ttest;  *MFTEST0  = mftest;
/*
 * release the memory and exit
 */
   free( Y0 );
   free( X0 );
 
   return( passed );
} 

int dotcase
(
   const int                  CACHESIZE,
   const enum LVL1_ROUT       ROUT,
   const int                  TEST,
   const int                  MFLOP,
   const int                  N,
   const int                  INCX,
   const int                  INCY,
   const TYPE                 EPSILON,
   double                     * TTRUST0,
   double                     * TTEST0,
   double                     * MFTRUST0,
   double                     * MFTEST0
)
{
   double                     flops, ttrust=0.0, ttest=0.0, mftrust, mftest, t0;
   TYPE                       resid = ATL_rzero;
#ifdef TREAL
   TYPE                       dot;
#ifdef SREAL
   double                     ddot;
   float                      b = 0.5;
#endif
#else
   TYPE                       dotx[2];
#endif
   TYPE                       * stX, * stY, * x, * y, * X, * X0 = NULL,
                              * Y, * Y0 = NULL;
   unsigned long              ir, reps;
   int                        aincX, aincY, incx, incy, lX, lY, passed,
                              Xseed, Yseed;
 
   if( ( MEGA * MFLOP <= ( flops = opbl1( ROUT, N ) ) ) || ( TEST ) )
   {
      resid = dottst( CACHESIZE, ROUT, TEST, N, INCX, INCY, EPSILON, TTRUST0,
		      TTEST0, MFTRUST0, MFTEST0 );
      if( resid > THRESH ) (void) fprintf( stderr, "   resid=%f\n", resid );
   }
   if( resid < ATL_rzero ) passed = -1;
   else                    passed = ( resid < THRESH );
 
   if( MEGA * MFLOP <= flops ) return( passed );
 
   incy = INCY * ( N  SHIFT ); aincY = Mabs( INCY );
   incx = INCX * ( N  SHIFT ), aincX = Mabs( INCX );
 
   lY = N * aincY * ( ( ATL_DivBySize( LCSIZE ) + N - 1 ) / N );
   lX = N * aincX * ( ( ATL_DivBySize( LCSIZE ) + N - 1 ) / N );
 
   Y0 = (TYPE *)malloc( ATL_MulBySize( lY ) );
   X0 = (TYPE *)malloc( ATL_MulBySize( lX ) );
 
   if( ( Y0 == NULL ) || ( X0 == NULL ) )
   {
      if( Y0 ) free( Y0 );
      if( X0 ) free( X0 );
      return( -1 );
   }
 
   if( INCY < 1 ) { Y = Y0 + ( lY SHIFT ); stY = Y0; }
   else           { Y = Y0; stY = Y0 + ( lY SHIFT ); }
   if( INCX < 1 ) { X = X0 + ( lX SHIFT ); stX = X0; }
   else           { X = X0; stX = X0 + ( lX SHIFT ); }
 
   Yseed = N * aincY;
   Xseed = N * aincX + 127 * 50 + 77;
 
   reps  = ( MEGA * MFLOP ) / flops;
/*
 * Generate the random data and time the trusted routine
 */
   y = Y; x = X;
 
   Mjoin( PATL, gegen )( lY, 1, Y0, lY, Yseed );
   Mjoin( PATL, gegen )( lX, 1, X0, lX, Xseed );

#ifdef TREAL
   if( ( ROUT == DOTU ) || ( ROUT == DOTC ) )
   { 
      t0 = time00();
      for( ir = reps; ir; ir-- )
      {
         dot = trusted_dot( N, x, INCX, y, INCY );
         y += incy; if( y == stY ) { y = Y; }
         x += incx; if( x == stX ) { x = X; }
      }
      ttrust = time00() - t0;
   }
#ifdef SREAL
   else if( ROUT == DSDOT )
   {
      t0 = time00();
      for( ir = reps; ir; ir-- )
      {
         ddot = trusted_dsdot( N, x, INCX, y, INCY );
         y += incy; if( y == stY ) { y = Y; }
         x += incx; if( x == stX ) { x = X; }
      }
      ttrust = time00() - t0;
   } 
   else if( ROUT == SDSDOT )
   {
      t0 = time00();
      for( ir = reps; ir; ir-- )
      {
         ddot = trusted_sdsdot( N, b, x, INCX, y, INCY );
         y += incy; if( y == stY ) { y = Y; }
         x += incx; if( x == stX ) { x = X; }
      }
      ttrust = time00() - t0;
   }
#endif
#else
   if( ROUT == DOTU )
   {
      t0 = time00();
      for( ir = reps; ir; ir-- )
      {
         trusted_dotu( N, x, INCX, y, INCY, dotx );
         y += incy; if( y == stY ) { y = Y; }
         x += incx; if( x == stX ) { x = X; }
      }
      ttrust = time00() - t0;
   }
   else if( ROUT == DOTC )
   {
      t0 = time00();
      for( ir = reps; ir; ir-- )
      {
         trusted_dotc( N, x, INCX, y, INCY, dotx );
         y += incy; if( y == stY ) { y = Y; }
         x += incx; if( x == stX ) { x = X; }
      }
      ttrust = time00() - t0;
   }
#endif
   if( ttrust > 0.0 ) mftrust = ( reps * flops ) / ( MEGA * ttrust );
   else               mftrust = 0.0;
   ttrust /= reps; *TTRUST0 = ttrust; *MFTRUST0 = mftrust;
/*
 * Generate the random data and time the tested routine
 */
   y = Y; x = X;
 
   Mjoin( PATL, gegen )( lY, 1, Y0, lY, Yseed );
   Mjoin( PATL, gegen )( lX, 1, X0, lX, Xseed );

#ifdef TREAL
   if( ( ROUT == DOTU ) || ( ROUT == DOTC ) )
   {
      t0 = time00();
      for( ir = reps; ir; ir-- )
      {
         dot = test_dot( N, x, INCX, y, INCY );
         y += incy; if( y == stY ) { y = Y; }
         x += incx; if( x == stX ) { x = X; }
      }
      ttest = time00() - t0;
   }
#ifdef SREAL
   else if( ROUT == DSDOT )
   {
      t0 = time00();
      for( ir = reps; ir; ir-- )
      {
         ddot = test_dsdot( N, x, INCX, y, INCY );
         y += incy; if( y == stY ) { y = Y; }
         x += incx; if( x == stX ) { x = X; }
      }
      ttest = time00() - t0;
   }
   else if( ROUT == SDSDOT )
   {
      t0 = time00();
      for( ir = reps; ir; ir-- )
      {
         ddot = test_sdsdot( N, b, x, INCX, y, INCY );
         y += incy; if( y == stY ) { y = Y; }
         x += incx; if( x == stX ) { x = X; }
      }
      ttest = time00() - t0;
   }
#endif
#else
   if( ROUT == DOTU )
   {
      t0 = time00();
      for( ir = reps; ir; ir-- )
      {
         test_dotu( N, x, INCX, y, INCY, dotx );
         y += incy; if( y == stY ) { y = Y; }
         x += incx; if( x == stX ) { x = X; }
      }
      ttest = time00() - t0;
   }
   else if( ROUT == DOTC )
   {
      t0 = time00();
      for( ir = reps; ir; ir-- )
      {
         test_dotc( N, x, INCX, y, INCY, dotx );
         y += incy; if( y == stY ) { y = Y; }
         x += incx; if( x == stX ) { x = X; }
      }
      ttest = time00() - t0;
   }
#endif
   if( ttest  > 0.0 ) mftest  = ( reps * flops ) / ( MEGA * ttest  );
   else               mftest  = 0.0;
   ttest  /= reps; *TTEST0  = ttest;  *MFTEST0  = mftest;
/*
 * release the memory and exit
 */
   free( Y0 );
   free( X0 );
 
   return( passed );
}

int rotcase
(
   const int                  CACHESIZE,
   const enum LVL1_ROUT       ROUT,
   const int                  TEST,
   const int                  MFLOP,
   const int                  N,
   const int                  INCX,
   const int                  INCY,
   const TYPE                 CO,
   const TYPE                 SI,
   const TYPE                 EPSILON,
   double                     * TTRUST0,
   double                     * TTEST0,
   double                     * MFTRUST0,
   double                     * MFTEST0
)
{
   double                     flops, ttrust, ttest, mftrust, mftest, t0;
   TYPE                       resid = ATL_rzero;
   TYPE                       * stX, * stY, * x, * y, * X, * X0 = NULL,
                              * Y, * Y0 = NULL;
   unsigned long              ir, reps;
   int                        aincX, aincY, incx, incy, lX, lY, passed,
                              Xseed, Yseed;
 
   if( ( MEGA * MFLOP <= ( flops = opbl1( ROUT, N ) ) ) || ( TEST ) )
   {
      resid = rottst( CACHESIZE, ROUT, TEST, N, INCX, INCY, CO, SI, EPSILON,
		      TTRUST0, TTEST0, MFTRUST0, MFTEST0 );
      if( resid > THRESH ) (void) fprintf( stderr, "   resid=%f\n", resid );
   }
   if( resid < ATL_rzero ) passed = -1;
   else                    passed = ( resid < THRESH );
 
   if( ( MEGA * MFLOP <= flops ) || ( CO == ATL_rone ) ) return( passed );
 
   incy = INCY * ( N  SHIFT ); aincY = Mabs( INCY );
   incx = INCX * ( N  SHIFT ), aincX = Mabs( INCX );
 
   lY = N * aincY * ( ( ATL_DivBySize( LCSIZE ) + N - 1 ) / N );
   lX = N * aincX * ( ( ATL_DivBySize( LCSIZE ) + N - 1 ) / N );
 
   Y0 = (TYPE *)malloc( ATL_MulBySize( lY ) );
   X0 = (TYPE *)malloc( ATL_MulBySize( lX ) );
 
   if( ( Y0 == NULL ) || ( X0 == NULL ) )
   {
      if( Y0 ) free( Y0 );
      if( X0 ) free( X0 );
      return( -1 );
   }
 
   if( INCY < 1 ) { Y = Y0 + ( lY SHIFT ); stY = Y0; }
   else           { Y = Y0; stY = Y0 + ( lY SHIFT ); }
   if( INCX < 1 ) { X = X0 + ( lX SHIFT ); stX = X0; }
   else           { X = X0; stX = X0 + ( lX SHIFT ); }
 
   Yseed = N * aincY;
   Xseed = N * aincX + 127 * 50 + 77;
 
   reps  = ( MEGA * MFLOP ) / flops;
/*
 * Generate the random data and time the trusted routine
 */
   y = Y; x = X;
 
   Mjoin( PATL, gegen )( lY, 1, Y0, lY, Yseed );
   Mjoin( PATL, gegen )( lX, 1, X0, lX, Xseed );
 
   t0 = time00();
   for( ir = reps; ir; ir-- )
   {
      trusted_rot( N, x, INCX, y, INCY, CO, SI );
      y += incy; if( y == stY ) { y = Y; }
      x += incx; if( x == stX ) { x = X; }
   }
   ttrust = time00() - t0;
   if( ttrust > 0.0 ) mftrust = ( reps * flops ) / ( MEGA * ttrust );
   else               mftrust = 0.0;
   ttrust /= reps; *TTRUST0 = ttrust; *MFTRUST0 = mftrust;
/*
 * Generate the random data and time the tested routine
 */
   y = Y; x = X;
 
   Mjoin( PATL, gegen )( lY, 1, Y0, lY, Yseed );
   Mjoin( PATL, gegen )( lX, 1, X0, lX, Xseed );
 
   t0 = time00();
   for( ir = reps; ir; ir-- )
   {
      test_rot( N, x, INCX, y, INCY, CO, SI );
      y += incy; if( y == stY ) { y = Y; }
      x += incx; if( x == stX ) { x = X; }
   }
   ttest = time00() - t0;
   if( ttest  > 0.0 ) mftest  = ( reps * flops ) / ( MEGA * ttest  );
   else               mftest  = 0.0;
   ttest  /= reps; *TTEST0  = ttest;  *MFTEST0  = mftest;
/*
 * release the memory and exit
 */
   free( Y0 );
   free( X0 );
 
   return( passed );
}

#ifdef TREAL
int rotmcase
(
   const int                  CACHESIZE,
   const enum LVL1_ROUT       ROUT,
   const int                  TEST,
   const int                  MFLOP,
   const int                  N,
   const int                  INCX,
   const int                  INCY,
   const TYPE                 * PARAM,
   const TYPE                 EPSILON,
   double                     * TTRUST0,
   double                     * TTEST0,
   double                     * MFTRUST0,
   double                     * MFTEST0
)
{
   double                     flops, ttrust, ttest, mftrust, mftest, t0;
   TYPE                       resid = ATL_rzero;
   TYPE                       * stX, * stY, * x, * y, * X, * X0 = NULL,
                              * Y, * Y0 = NULL;
   unsigned long              ir, reps;
   int                        aincX, aincY, incx, incy, lX, lY, passed,
                              Xseed, Yseed;
 
   if( ( MEGA * MFLOP <= ( flops = opbl1( ROUT, N ) ) ) || ( TEST ) )
   {
      resid = rotmtst( CACHESIZE, ROUT, TEST, N, INCX, INCY, PARAM, EPSILON,
		       TTRUST0, TTEST0, MFTRUST0, MFTEST0 );
      if( resid > THRESH ) (void) fprintf( stderr, "   resid=%f\n", resid );
   }
   if( resid < ATL_rzero ) passed = -1;
   else                    passed = ( resid < THRESH );
 
#ifdef SREAL
   if( ( MEGA * MFLOP <= flops ) || ( PARAM[0] == -2.0f ) ) return( passed );
#else
   if( ( MEGA * MFLOP <= flops ) || ( PARAM[0] == -2.0  ) ) return( passed );
#endif
 
   incy = INCY * ( N  SHIFT ); aincY = Mabs( INCY );
   incx = INCX * ( N  SHIFT ), aincX = Mabs( INCX );
 
   lY = N * aincY * ( ( ATL_DivBySize( LCSIZE ) + N - 1 ) / N );
   lX = N * aincX * ( ( ATL_DivBySize( LCSIZE ) + N - 1 ) / N );
 
   Y0 = (TYPE *)malloc( ATL_MulBySize( lY ) );
   X0 = (TYPE *)malloc( ATL_MulBySize( lX ) );
 
   if( ( Y0 == NULL ) || ( X0 == NULL ) )
   {
      if( Y0 ) free( Y0 );
      if( X0 ) free( X0 );
      return( -1 );
   }
 
   if( INCY < 1 ) { Y = Y0 + ( lY SHIFT ); stY = Y0; }
   else           { Y = Y0; stY = Y0 + ( lY SHIFT ); }
   if( INCX < 1 ) { X = X0 + ( lX SHIFT ); stX = X0; }
   else           { X = X0; stX = X0 + ( lX SHIFT ); }
 
   Yseed = N * aincY;
   Xseed = N * aincX + 127 * 50 + 77;
 
   reps  = ( MEGA * MFLOP ) / flops;
/*
 * Generate the random data and time the trusted routine
 */
   y = Y; x = X;
 
   Mjoin( PATL, gegen )( lY, 1, Y0, lY, Yseed );
   Mjoin( PATL, gegen )( lX, 1, X0, lX, Xseed );
 
   t0 = time00();
   for( ir = reps; ir; ir-- )
   {
      trusted_rotm( N, x, INCX, y, INCY, PARAM );
      y += incy; if( y == stY ) { y = Y; }
      x += incx; if( x == stX ) { x = X; }
   }
   ttrust = time00() - t0;
   if( ttrust > 0.0 ) mftrust = ( reps * flops ) / ( MEGA * ttrust );
   else               mftrust = 0.0;
   ttrust /= reps; *TTRUST0 = ttrust; *MFTRUST0 = mftrust;
/*
 * Generate the random data and time the tested routine
 */
   y = Y; x = X;
 
   Mjoin( PATL, gegen )( lY, 1, Y0, lY, Yseed );
   Mjoin( PATL, gegen )( lX, 1, X0, lX, Xseed );
 
   t0 = time00();
   for( ir = reps; ir; ir-- )
   {
      test_rotm( N, x, INCX, y, INCY, PARAM );
      y += incy; if( y == stY ) { y = Y; }
      x += incx; if( x == stX ) { x = X; }
   }
   ttest = time00() - t0;
   if( ttest  > 0.0 ) mftest  = ( reps * flops ) / ( MEGA * ttest  );
   else               mftest  = 0.0;
   ttest  /= reps; *TTEST0  = ttest;  *MFTEST0  = mftest;
/*
 * release the memory and exit
 */
   free( Y0 );
   free( X0 );
 
   return( passed );
}
#endif

/*
 * =====================================================================
 * Run functions
 * =====================================================================
 */
void RunrotgCase
(
   const int                  CACHESIZE,
   const enum LVL1_ROUT       ROUT,
   const int                  TEST,
   const int                  MFLOP,
   const TYPE                 EPSILON,
   int                        * NPASSED,
   int                        * NTESTS
)
{
   double                     t0, mftrust, mftest, ttrust, ttest;
   char                       * pass, * form;
   int                        ires;

   (void) fprintf( stdout, "\n%s\n",
                   "------------ ROTG -----------" );
   (void) fprintf( stdout, "%s",
                   "TST#   TIME MFLOP  SpUp  TEST\n" );
   (void) fprintf( stdout, "%s",
                   "==== ====== ===== ===== =====\n" );
   form = "%4d %6.2f %5.1f %5.2f %5s\n";
 
   ires = rotgcase( CACHESIZE, ROUT, TEST, MFLOP, EPSILON, &ttrust, &ttest,
		    &mftrust, &mftest );
 
   if(     !( TEST ) ) pass = "SKIP ";
   else if( ires < 0 ) pass = "NoMEM";
   else if( ires     ) pass = "PASS ";
   else                pass = "FAIL ";
 
   if( ires > 0 ) (*NPASSED)++;
 
   if( ( mftrust > 0.0 ) && ( mftest > 0.0 ) ) t0 = mftest / mftrust;
   else                                        t0 = 0.0;
 
   (void) fprintf( stdout, form, *NTESTS, ttrust, mftrust, 1.0, "-----" );
   (void) fprintf( stdout, form, *NTESTS, ttest,  mftest,  t0,  pass    );
   (*NTESTS)++;
} 

#ifdef TREAL
void RunrotmgCase
(
   const int CACHESIZE,
   const enum LVL1_ROUT       ROUT,
   const int                  TEST,
   const int                  MFLOP,
   const TYPE                 EPSILON,
   int                        * NPASSED,
   int                        * NTESTS
)
{
   double                     t0, mftrust, mftest, ttrust, ttest;
   char                       * pass, * form;
   int                        ires;
 
   (void) fprintf( stdout, "\n%s\n",
                   "----------- ROTMG -----------" );
   (void) fprintf( stdout, "%s",
                   "TST#   TIME MFLOP  SpUp  TEST\n" );
   (void) fprintf( stdout, "%s",
                   "==== ====== ===== ===== =====\n" );
   form = "%4d %6.2f %5.1f %5.2f %5s\n";
 
   ires = rotmgcase( CACHESIZE, ROUT, TEST, MFLOP, EPSILON, &ttrust,
		     &ttest, &mftrust, &mftest );
 
   if(     !( TEST ) ) pass = "SKIP ";
   else if( ires < 0 ) pass = "NoMEM";
   else if( ires     ) pass = "PASS ";
   else                pass = "FAIL ";
 
   if( ires > 0 ) (*NPASSED)++;
 
   if( ( mftrust > 0.0 ) && ( mftest > 0.0 ) ) t0 = mftest / mftrust;
   else                                        t0 = 0.0;
 
   (void) fprintf( stdout, form, *NTESTS, ttrust, mftrust, 1.0, "-----" );
   (void) fprintf( stdout, form, *NTESTS, ttest,  mftest,  t0,  pass    );
   (*NTESTS)++;
} 
#endif

void RunsumCase
(
   const int                  CACHESIZE,
   const enum LVL1_ROUT       ROUT,
   const int                  TEST,
   const int                  MFLOP,
   const int                  N0,
   const int                  NN,
   const int                  NINC,
   const int                  NINCX,
   const int                  * INCXS,
   const TYPE                 EPSILON,
   int                        * NPASSED,
   int                        * NTESTS
)
{
   double                     t0, mftrust, mftest, ttrust, ttest;
   char                       * pass, * form;
   int                        ires, ix, n, nn;
 
   (void) fprintf( stdout, "\n%s\n",
                   "---------------- ASUM -----------------" );
   (void) fprintf( stdout, "%s",
                   "TST#    N INCX   TIME MFLOP  SpUp  TEST\n" );
   (void) fprintf( stdout, "%s",
                   "==== ==== ==== ====== ===== ===== =====\n" );
   form = "%4d %4d %4d %6.2f %5.1f %5.2f %5s\n";
 
   for( nn = N0; nn <= NN; nn += NINC )
   {
      n = nn;
 
      for( ix = 0; ix < NINCX; ix++ )
      {
         ires = sumcase( CACHESIZE, ROUT, TEST, MFLOP, n, INCXS[ix],
			 EPSILON, &ttrust, &ttest, &mftrust, &mftest );

         if(     !( TEST ) ) pass = "SKIP ";
         else if( ires < 0 ) pass = "NoMEM";
         else if( ires     ) pass = "PASS ";
         else                pass = "FAIL ";
 
         if( ires > 0 ) (*NPASSED)++;
 
         if( ( mftrust > 0.0 ) && ( mftest > 0.0 ) ) t0 = mftest / mftrust;
         else                                        t0 = 0.0;

         (void) fprintf( stdout, form, *NTESTS, n, INCXS[ix], ttrust, mftrust,
                         1.0, "-----" );
         (void) fprintf( stdout, form, *NTESTS, n, INCXS[ix], ttest,  mftest,
                         t0,  pass    );
         (*NTESTS)++;
      }
   }
} 

void RunnrmCase
(
   const int                  CACHESIZE,
   const enum LVL1_ROUT       ROUT,
   const int                  TEST,
   const int                  MFLOP,
   const int                  N0,
   const int                  NN,
   const int                  NINC,
   const int                  NINCX,
   const int                  * INCXS,
   const TYPE                 EPSILON,
   int                        * NPASSED,
   int                        * NTESTS
)
{
   double                     t0, mftrust, mftest, ttrust, ttest;
   char                       * pass, * form;
   int                        ires, ix, n, nn;
 
   (void) fprintf( stdout, "\n%s\n",
                   "---------------- NRM2 -----------------" );
   (void) fprintf( stdout, "%s",
                   "TST#    N INCX   TIME MFLOP  SpUp  TEST\n" );
   (void) fprintf( stdout, "%s",
                   "==== ==== ==== ====== ===== ===== =====\n" );
   form = "%4d %4d %4d %6.2f %5.1f %5.2f %5s\n";
 
   for( nn = N0; nn <= NN; nn += NINC )
   {
      n = nn;
 
      for( ix = 0; ix < NINCX; ix++ )
      {
         ires = nrmcase( CACHESIZE, ROUT, TEST, MFLOP, n, INCXS[ix],
			 EPSILON, &ttrust, &ttest, &mftrust, &mftest );

         if(     !( TEST ) ) pass = "SKIP ";
         else if( ires < 0 ) pass = "NoMEM";
         else if( ires     ) pass = "PASS ";
         else                pass = "FAIL ";
 
         if( ires > 0 ) (*NPASSED)++;
 
         if( ( mftrust > 0.0 ) && ( mftest > 0.0 ) ) t0 = mftest / mftrust;
         else                                        t0 = 0.0;

         (void) fprintf( stdout, form, *NTESTS, n, INCXS[ix], ttrust, mftrust,
                         1.0, "-----" );
         (void) fprintf( stdout, form, *NTESTS, n, INCXS[ix], ttest,  mftest,
                         t0,  pass    );
         (*NTESTS)++;
      }
   }
} 

void RunmaxCase
(
   const int                  CACHESIZE,
   const enum LVL1_ROUT       ROUT,
   const int                  TEST,
   const int                  MFLOP,
   const int                  N0,
   const int                  NN,
   const int                  NINC,
   const int                  NINCX,
   const int                  * INCXS,
   const TYPE                 EPSILON,
   int                        * NPASSED,
   int                        * NTESTS
)
{
   double                     t0, mftrust, mftest, ttrust, ttest;
   char                       * pass, * form;
   int                        ires, ix, n, nn;
 
   (void) fprintf( stdout, "\n%s\n",
                   "---------------- AMAX -----------------" );
   (void) fprintf( stdout, "%s",
                   "TST#    N INCX   TIME MFLOP  SpUp  TEST\n" );
   (void) fprintf( stdout, "%s",
                   "==== ==== ==== ====== ===== ===== =====\n" );
   form = "%4d %4d %4d %6.2f %5.1f %5.2f %5s\n";
 
   for( nn = N0; nn <= NN; nn += NINC )
   {
      n = nn;
 
      for( ix = 0; ix < NINCX; ix++ )
      {
         ires = maxcase( CACHESIZE, ROUT, TEST, MFLOP, n, INCXS[ix],
			 EPSILON, &ttrust,  &ttest, &mftrust, &mftest );

         if(     !( TEST ) ) pass = "SKIP ";
         else if( ires < 0 ) pass = "NoMEM";
         else if( ires     ) pass = "PASS ";
         else                pass = "FAIL ";
 
         if( ires > 0 ) (*NPASSED)++;
 
         if( ( mftrust > 0.0 ) && ( mftest > 0.0 ) ) t0 = mftest / mftrust;
         else                                        t0 = 0.0;

         (void) fprintf( stdout, form, *NTESTS, n, INCXS[ix], ttrust, mftrust,
                         1.0, "-----" );
         (void) fprintf( stdout, form, *NTESTS, n, INCXS[ix], ttest,  mftest,
                         t0,  pass    );
         (*NTESTS)++;
      }
   }
} 

void RunsclCase
(
   const int                  CACHESIZE,
   const enum LVL1_ROUT       ROUT,
   const int                  TEST,
   const int                  MFLOP,
   const int                  N0,
   const int                  NN,
   const int                  NINC,
   const int                  NALPHA,
   const TYPE                 * ALPHAS,
   const int                  NINCX,
   const int                  * INCXS,
   const TYPE                 EPSILON,
   int                        * NPASSED,
   int                        * NTESTS
)
{
   double                     t0, mftrust, mftest, ttrust, ttest;
   char                       * pass, * form;
   int                        al, ires, ix, n, nn;
 
#ifdef TREAL
   (void) fprintf( stdout, "\n%s\n",
                   "------------------ SCAL ---------------------" );
   (void) fprintf( stdout, "%s",
                   "TST#    N ALPHA INCX   TIME MFLOP  SpUp  TEST\n" );
   (void) fprintf( stdout, "%s",
                   "==== ==== ===== ==== ====== ===== ===== =====\n" );
   form = "%4d %4d %5.1f %4d %6.2f %5.1f %5.2f %5s\n";
#else
   (void) fprintf( stdout, "\n%s\n",
             "--------------------- SCAL ------------------------" );
   (void) fprintf( stdout, "%s",
             "TST#    N       ALPHA INCX   TIME MFLOP  SpUp  TEST\n" );
   (void) fprintf( stdout, "%s",
             "==== ==== ===== ===== ==== ====== ===== ===== =====\n" );
   form = "%4d %4d %5.1f %5.1f %4d %6.2f %5.1f %5.2f %5s\n";
#endif
 
   for( nn = N0; nn <= NN; nn += NINC )
   {
      n = nn;
 
      for( ix = 0; ix < NINCX; ix++ )
      {
         for( al = 0; al < NALPHA; al++ )
         {
#ifdef TREAL
            ires = sclcase( CACHESIZE, ROUT, TEST, MFLOP, n, ALPHAS[al],
			    INCXS[ix], EPSILON, &ttrust, &ttest, &mftrust,
			    &mftest );
#else
            ires = sclcase( CACHESIZE, ROUT, TEST, MFLOP, n, ALPHAS+2*al,
			    INCXS[ix], EPSILON, &ttrust, &ttest, &mftrust,
			    &mftest );
#endif
            if(     !( TEST ) ) pass = "SKIP ";
            else if( ires < 0 ) pass = "NoMEM";
            else if( ires     ) pass = "PASS ";
            else                pass = "FAIL ";
 
            if( ires > 0 ) (*NPASSED)++;

            if( ( mftrust > 0.0 ) && ( mftest > 0.0 ) ) t0 = mftest / mftrust;
            else                                        t0 = 0.0;
#ifdef TREAL
            (void) fprintf( stdout, form, *NTESTS, n, ALPHAS[al], INCXS[ix],
                            ttrust, mftrust, 1.0, "-----" );
            (void) fprintf( stdout, form, *NTESTS, n, ALPHAS[al], INCXS[ix],
                            ttest,  mftest,  t0,  pass    );
#else
            (void) fprintf( stdout, form, *NTESTS, n, ALPHAS[2*al],
                            ALPHAS[2*al+1], INCXS[ix], ttrust, mftrust,
                            1.0, "-----" );
            (void) fprintf( stdout, form, *NTESTS, n, ALPHAS[2*al],
                            ALPHAS[2*al+1], INCXS[ix], ttest,  mftest,
                            t0,  pass    );
#endif
            (*NTESTS)++;
         }
      }
   }
} 

#ifdef TCPLX

void RunrscCase
(
   const int                  CACHESIZE,
   const enum LVL1_ROUT       ROUT,
   const int                  TEST,
   const int                  MFLOP,
   const int                  N0,
   const int                  NN,
   const int                  NINC,
   const int                  NALPHA,
   const TYPE                 * ALPHAS,
   const int                  NINCX,
   const int                  * INCXS,
   const TYPE                 EPSILON,
   int                        * NPASSED,
   int                        * NTESTS
)
{
   double                     t0, mftrust, mftest, ttrust, ttest;
   char                       * pass, * form;
   int                        al, ires, ix, n, nn;
 
   (void) fprintf( stdout, "\n%s\n",
                   "------------------ RSCAL --------------------" );
   (void) fprintf( stdout, "%s",
                   "TST#    N ALPHA INCX   TIME MFLOP  SpUp  TEST\n" );
   (void) fprintf( stdout, "%s",
                   "==== ==== ===== ==== ====== ===== ===== =====\n" );
   form = "%4d %4d %5.1f %4d %6.2f %5.1f %5.2f %5s\n";
 
   for( nn = N0; nn <= NN; nn += NINC )
   {
      n = nn;
 
      for( ix = 0; ix < NINCX; ix++ )
      {
         for( al = 0; al < NALPHA; al++ )
         {
            ires = rsccase( CACHESIZE, ROUT, TEST, MFLOP, n, ALPHAS+2*al,
			    INCXS[ix], EPSILON, &ttrust, &ttest, &mftrust, &mftest );

            if(     !( TEST ) ) pass = "SKIP ";
            else if( ires < 0 ) pass = "NoMEM";
            else if( ires     ) pass = "PASS ";
            else                pass = "FAIL ";
 
            if( ires > 0 ) (*NPASSED)++;

            if( ( mftrust > 0.0 ) && ( mftest > 0.0 ) ) t0 = mftest / mftrust;
            else                                        t0 = 0.0;

            (void) fprintf( stdout, form, *NTESTS, n, ALPHAS[2*al], INCXS[ix],
                            ttrust, mftrust, 1.0, "-----" );
            (void) fprintf( stdout, form, *NTESTS, n, ALPHAS[2*al], INCXS[ix],
                            ttest,  mftest,  t0,  pass    );
            (*NTESTS)++;
         }
      }
   }
} 
#endif

void RunxpyCase
(
   const int                  CACHESIZE,
   const enum LVL1_ROUT       ROUT,
   const int                  TEST,
   const int                  MFLOP,
   const int                  N0,
   const int                  NN,
   const int                  NINC,
   const int                  NALPHA,
   const TYPE                 * ALPHAS,
   const int                  NINCX,
   const int                  * INCXS,
   const int                  NINCY,
   const int                  * INCYS,
   const TYPE                 EPSILON,
   int                        * NPASSED,
   int                        * NTESTS
) 
{
   double                     t0, mftrust, mftest, ttrust, ttest;
   char                       * pass, * form;
   int                        al, ires, ix, iy, n, nn;

#ifdef TREAL 
   (void) fprintf( stdout, "\n%s\n",
                   "--------------------- AXPY -----------------------" );
   (void) fprintf( stdout, "%s",
                   "TST#    N ALPHA INCX INCY   TIME MFLOP  SpUp  TEST\n" );
   (void) fprintf( stdout, "%s",
                   "==== ==== ===== ==== ==== ====== ===== ===== =====\n" );
   form = "%4d %4d %5.1f %4d %4d %6.2f %5.1f %5.2f %5s\n";
#else
   (void) fprintf( stdout, "\n%s\n",
             "------------------------ AXPY --------------------------" );
   (void) fprintf( stdout, "%s",
             "TST#    N       ALPHA INCX INCY   TIME MFLOP  SpUp  TEST\n" );
   (void) fprintf( stdout, "%s",
             "==== ==== ===== ===== ==== ==== ====== ===== ===== =====\n" );
   form = "%4d %4d %5.1f %5.1f %4d %4d %6.2f %5.1f %5.2f %5s\n";
#endif

   for( nn = N0; nn <= NN; nn += NINC )
   {
      n = nn;
 
      for( iy = 0; iy < NINCY; iy++ )
      {
         for( ix = 0; ix < NINCX; ix++ )
         {
            for( al = 0; al < NALPHA; al++ )
            {
#ifdef TREAL
               ires = xpycase( CACHESIZE, ROUT, TEST, MFLOP, n, ALPHAS[al],
			       INCXS[ix], INCYS[iy], EPSILON, &ttrust, &ttest,
			       &mftrust, &mftest );
#else
               ires = xpycase( CACHESIZE, ROUT, TEST, MFLOP, n, ALPHAS+2*al,
			       INCXS[ix], INCYS[iy], EPSILON, &ttrust, &ttest,
			       &mftrust, &mftest );
#endif
               if(     !( TEST ) ) pass = "SKIP ";
               else if( ires < 0 ) pass = "NoMEM";
               else if( ires     ) pass = "PASS ";
               else                pass = "FAIL ";
 
               if( ires > 0 ) (*NPASSED)++;
 
               if( ( mftrust > 0.0 ) && ( mftest > 0.0 ) )
                  t0 = mftest / mftrust;
               else 
                  t0 = 0.0;
#ifdef TREAL
               (void) fprintf( stdout, form, *NTESTS, n, ALPHAS[al], INCXS[ix],
                               INCYS[iy], ttrust, mftrust, 1.0, "-----" );
               (void) fprintf( stdout, form, *NTESTS, n, ALPHAS[al], INCXS[ix],
                               INCYS[iy], ttest,  mftest,  t0,  pass    );
#else
               (void) fprintf( stdout, form, *NTESTS, n, ALPHAS[2*al],
                               ALPHAS[2*al+1], INCXS[ix], INCYS[iy], ttrust,
                               mftrust, 1.0, "-----" );
               (void) fprintf( stdout, form, *NTESTS, n, ALPHAS[2*al],
                               ALPHAS[2*al+1], INCXS[ix], INCYS[iy], ttest,
                               mftest,  t0,  pass    );
#endif
               (*NTESTS)++;
            }
         }
      }
   }
}

void RuncpyCase
(
   const int                  CACHESIZE,
   const enum LVL1_ROUT       ROUT,
   const int                  TEST,
   const int                  MFLOP,
   const int                  N0,
   const int                  NN,
   const int                  NINC,
   const int                  NINCX,
   const int                  * INCXS,
   const int                  NINCY,
   const int                  * INCYS,
   const TYPE                 EPSILON,
   int                        * NPASSED,
   int                        * NTESTS
) 
{
   double                     t0, mftrust, mftest, ttrust, ttest;
   char                       * pass, * form;
   int                        ires, ix, iy, n, nn;
 
   (void) fprintf( stdout, "\n%s\n",
                   "------------------ COPY --------------------" );
   (void) fprintf( stdout, "%s",
                   "TST#    N INCX INCY   TIME MFLOP  SpUp  TEST\n" );
   (void) fprintf( stdout, "%s",
                   "==== ==== ==== ==== ====== ===== ===== =====\n" );
   form = "%4d %4d %4d %4d %6.2f %5.1f %5.2f %5s\n";

   for( nn = N0; nn <= NN; nn += NINC )
   {
      n = nn;
 
      for( iy = 0; iy < NINCY; iy++ )
      {
         for( ix = 0; ix < NINCX; ix++ )
         {
            ires = cpycase( CACHESIZE, ROUT, TEST, MFLOP, n, INCXS[ix],
			    INCYS[iy], EPSILON, &ttrust, &ttest, &mftrust, &mftest );
            if(     !( TEST ) ) pass = "SKIP ";
            else if( ires < 0 ) pass = "NoMEM";
            else if( ires     ) pass = "PASS ";
            else                pass = "FAIL ";
 
            if( ires > 0 ) (*NPASSED)++;
 
            if( ( mftrust > 0.0 ) && ( mftest > 0.0 ) ) t0 = mftest / mftrust;
            else                                        t0 = 0.0;

            (void) fprintf( stdout, form, *NTESTS, n, INCXS[ix], INCYS[iy],
                            ttrust, mftrust, 1.0, "-----" );
            (void) fprintf( stdout, form, *NTESTS, n, INCXS[ix], INCYS[iy],
                            ttest,  mftest,  t0,  pass    );
            (*NTESTS)++;
         }
      }
   }
}

void RunswpCase
(
   const int                  CACHESIZE,
   const enum LVL1_ROUT       ROUT,
   const int                  TEST,
   const int                  MFLOP,
   const int                  N0,
   const int                  NN,
   const int                  NINC,
   const int                  NINCX,
   const int                  * INCXS,
   const int                  NINCY,
   const int                  * INCYS,
   const TYPE                 EPSILON,
   int                        * NPASSED,
   int                        * NTESTS
)
{
   double                     t0, mftrust, mftest, ttrust, ttest;
   char                       * pass, * form;
   int                        ires, ix, iy, n, nn;
 
   (void) fprintf( stdout, "\n%s\n",
                   "------------------ SWAP --------------------" );
   (void) fprintf( stdout, "%s",
                   "TST#    N INCX INCY   TIME MFLOP  SpUp  TEST\n" );
   (void) fprintf( stdout, "%s",
                   "==== ==== ==== ==== ====== ===== ===== =====\n" );
   form = "%4d %4d %4d %4d %6.2f %5.1f %5.2f %5s\n";
 
   for( nn = N0; nn <= NN; nn += NINC )
   {
      n = nn;
 
      for( iy = 0; iy < NINCY; iy++ )
      {
         for( ix = 0; ix < NINCX; ix++ )
         {
            ires = swpcase( CACHESIZE, ROUT, TEST, MFLOP, n, INCXS[ix],
			    INCYS[iy], EPSILON, &ttrust, &ttest, &mftrust, &mftest );
            if(     !( TEST ) ) pass = "SKIP ";
            else if( ires < 0 ) pass = "NoMEM";
            else if( ires     ) pass = "PASS ";
            else                pass = "FAIL ";
 
            if( ires > 0 ) (*NPASSED)++;
 
            if( ( mftrust > 0.0 ) && ( mftest > 0.0 ) ) t0 = mftest / mftrust;
            else                                        t0 = 0.0;
 
            (void) fprintf( stdout, form, *NTESTS, n, INCXS[ix], INCYS[iy],
                            ttrust, mftrust, 1.0, "-----" );
            (void) fprintf( stdout, form, *NTESTS, n, INCXS[ix], INCYS[iy],
                            ttest,  mftest,  t0,  pass    );
            (*NTESTS)++;
         }
      }
   }
} 

void RundotCase
(
   const int                  CACHESIZE,
   const enum LVL1_ROUT       ROUT,
   const int                  TEST,
   const int                  MFLOP,
   const int                  N0,
   const int                  NN,
   const int                  NINC,
   const int                  NINCX,
   const int                  * INCXS,
   const int                  NINCY,
   const int                  * INCYS,
   const TYPE                 EPSILON,
   int                        * NPASSED,
   int                        * NTESTS
) 
{
   double                     t0, mftrust, mftest, ttrust, ttest;
   char                       * pass, * form;
   int                        ires, ix, iy, n, nn;
 
#ifdef TREAL
   if( ( ROUT == DOTU ) || ( ROUT == DOTC ) )
   {
      (void) fprintf( stdout, "\n%s\n",
                      "------------------ DOT ---------------------" );
   }
#ifdef SREAL
   else if( ROUT == DSDOT )
   {
      (void) fprintf( stdout, "\n%s\n",
                      "----------------- DSDOT --------------------" );
   }
   else if( ROUT == SDSDOT )
   {
      (void) fprintf( stdout, "\n%s\n",
                      "---------------- SDSDOT --------------------" );
   }
#endif
#else
   if( ROUT == DOTU )
   {
      (void) fprintf( stdout, "\n%s\n",
                      "------------------ DOTU --------------------" );
   }
   else if( ROUT == DOTC )
   {
      (void) fprintf( stdout, "\n%s\n",
                      "------------------ DOTC --------------------" );
   }
#endif
   (void) fprintf( stdout, "%s",
                   "TST#    N INCX INCY   TIME MFLOP  SpUp  TEST\n" );
   (void) fprintf( stdout, "%s",
                   "==== ==== ==== ==== ====== ===== ===== =====\n" );
   form = "%4d %4d %4d %4d %6.2f %5.1f %5.2f %5s\n";

   for( nn = N0; nn <= NN; nn += NINC )
   {
      n = nn;
 
      for( iy = 0; iy < NINCY; iy++ )
      {
         for( ix = 0; ix < NINCX; ix++ )
         {
            ires = dotcase( CACHESIZE, ROUT, TEST, MFLOP, n, INCXS[ix],
			    INCYS[iy], EPSILON, &ttrust, &ttest, &mftrust, &mftest );
            if(     !( TEST ) ) pass = "SKIP ";
            else if( ires < 0 ) pass = "NoMEM";
            else if( ires     ) pass = "PASS ";
            else                pass = "FAIL ";
 
            if( ires > 0 ) (*NPASSED)++;
 
            if( ( mftrust > 0.0 ) && ( mftest > 0.0 ) ) t0 = mftest / mftrust;
            else                                        t0 = 0.0;

            (void) fprintf( stdout, form, *NTESTS, n, INCXS[ix], INCYS[iy],
                            ttrust, mftrust, 1.0, "-----" );
            (void) fprintf( stdout, form, *NTESTS, n, INCXS[ix], INCYS[iy],
                            ttest,  mftest,  t0,  pass    );
            (*NTESTS)++;
         }
      }
   }
}

void RunrotCase
(
   const int                  CACHESIZE,
   const enum LVL1_ROUT       ROUT,
   const int                  TEST,
   const int                  MFLOP,
   const int                  N0,
   const int                  NN,
   const int                  NINC,
   const int                  NINCX,
   const int                  * INCXS,
   const int                  NINCY,
   const int                  * INCYS,
   const int                  NALPHA,
   const TYPE                 * ALPHAS,
   const TYPE                 EPSILON,
   int                        * NPASSED,
   int                        * NTESTS
) 
{
   double                     t0, mftrust, mftest, ttrust, ttest;
   TYPE                       co, si;
   char                       * pass, * form;
   int                        al, ires, ix, iy, n, nn;
 
   (void) fprintf( stdout, "\n%s\n",
                   "----------------------- ROT --------------------------" );
   (void) fprintf( stdout, "%s",
                   "TST#    N INCX INCY    C    S   TIME MFLOP  SpUp  TEST\n" );
   (void) fprintf( stdout, "%s",
                   "==== ==== ==== ==== ==== ==== ====== ===== ===== =====\n" );
   form = "%4d %4d %4d %4d %4.1f %4.1f %6.2f %5.1f %5.2f %5s\n";

   for( nn = N0; nn <= NN; nn += NINC )
   {
      n = nn;
 
      for( iy = 0; iy < NINCY; iy++ )
      {
         for( ix = 0; ix < NINCX; ix++ )
         {
            for( al = 0; al < NALPHA; al++ )
            {
#ifdef TREAL
               if(      ALPHAS[al] == ATL_rzero       )
               { co = ATL_rzero; }
               else if( Mabs( ALPHAS[al] ) > ATL_rone )
               { co = ATL_rone / ALPHAS[al]; }
               else
               { co = ALPHAS[al]; }
               si = (TYPE)(sqrt( (double)(ATL_rone - co * co) ));
               if( Mabs( ALPHAS[al] ) > ATL_rone ) si = -si;
#else
               if(      ALPHAS[2*al] == ATL_rzero       )
               { co = ATL_rzero; }
               else if( Mabs( ALPHAS[2*al] ) > ATL_rone )
               { co = ATL_rone / ALPHAS[2*al]; }
               else
               { co = ALPHAS[2*al]; }
               si = (TYPE)(sqrt( (double)(ATL_rone - co * co) ));
               if( Mabs( ALPHAS[2*al] ) > ATL_rone ) si = -si;
#endif
               ires = rotcase( CACHESIZE, ROUT, TEST, MFLOP, n, INCXS[ix],
			       INCYS[iy], co, si, EPSILON, &ttrust, &ttest,
			       &mftrust, &mftest );
               if(     !( TEST ) ) pass = "SKIP ";
               else if( ires < 0 ) pass = "NoMEM";
               else if( ires     ) pass = "PASS ";
               else                pass = "FAIL ";
 
               if( ires > 0 ) (*NPASSED)++;
 
               if( ( mftrust > 0.0 ) && ( mftest > 0.0 ) )
                  t0 = mftest / mftrust;
               else
                  t0 = 0.0;

               (void) fprintf( stdout, form, *NTESTS, n, INCXS[ix], INCYS[iy],
                               co, si, ttrust, mftrust, 1.0, "-----" );
               (void) fprintf( stdout, form, *NTESTS, n, INCXS[ix], INCYS[iy],
                               co, si, ttest,  mftest,  t0,  pass    );
               (*NTESTS)++;
            }
         }
      }
   }
}

#ifdef TREAL
void RunrotmCase
(
   const int                  CACHESIZE,
   const enum LVL1_ROUT       ROUT,
   const int                  TEST,
   const int                  MFLOP,
   const int                  N0,
   const int                  NN,
   const int                  NINC,
   const int                  NINCX,
   const int                  * INCXS,
   const int                  NINCY,
   const int                  * INCYS,
   const TYPE                 EPSILON,
   int                        * NPASSED,
   int                        * NTESTS
) 
{
   double                     t0, mftrust, mftest, ttrust, ttest;
   TYPE                       param[5];
   char                       * pass, * form;
   int                        ires, ix, iy, n, nn;
 
   (void) fprintf( stdout, "\n%s\n",
   "----------------------------- ROTM ---------------------------------" );
   (void) fprintf( stdout, "%s",
   "TST#    N INCX INCY P[0] P[1] P[2] P[3] P[4]  TIME MFLOP  SpUp  TEST\n" );
   (void) fprintf( stdout, "%s",
   "==== ==== ==== ==== ==== ==== ==== ==== ==== ====== ===== ===== =====\n" );
   form = 
   "%4d %4d %4d %4d %4.1f %4.1f %4.1f %4.1f %4.1f %6.2f %5.1f %5.2f %5s\n";

   for( nn = N0; nn <= NN; nn += NINC )
   {
      n = nn;
 
      for( iy = 0; iy < NINCY; iy++ )
      {
         for( ix = 0; ix < NINCX; ix++ )
         {
#ifdef SREAL
            param[0] = ATL_rone; param[1] =  0.567f;
            param[2] =  0.123f;  param[3] = -0.222f; param[4] = -0.988f;
#else
            param[0] = ATL_rone; param[1] =  0.567;
            param[2] =  0.123;   param[3] = -0.222;  param[4] = -0.988;
#endif
            ires = rotmcase( CACHESIZE, ROUT, TEST, MFLOP, n, INCXS[ix],
			     INCYS[iy], param, EPSILON, &ttrust, &ttest,
			     &mftrust, &mftest );
            if(     !( TEST ) ) pass = "SKIP ";
            else if( ires < 0 ) pass = "NoMEM";
            else if( ires     ) pass = "PASS ";
            else                pass = "FAIL ";
 
            if( ires > 0 ) (*NPASSED)++;
 
            if( ( mftrust > 0.0 ) && ( mftest > 0.0 ) )
               t0 = mftest / mftrust;
            else
               t0 = 0.0;

            (void) fprintf( stdout, form, *NTESTS, n, INCXS[ix], INCYS[iy],
                            param[0], param[1], param[2], param[3], param[4],
                            ttrust, mftrust, 1.0, "-----" );
            (void) fprintf( stdout, form, *NTESTS, n, INCXS[ix], INCYS[iy],
                            param[0], param[1], param[2], param[3], param[4],
                            ttest,  mftest,  t0,  pass    );
            (*NTESTS)++;
         }
      }
   }
}
#endif

void RunCases
(
   const int                  TEST,
   const int                  CACHESIZE,
   const int                  MFLOP,
   const int                  N0,
   const int                  NN,
   const int                  NINC,
   const int                  NALPHA,
   const TYPE                 * ALPHAS,
   const int                  NINCX,
   const int                  * INCXS,
   const int                  NINCY,
   const int                  * INCYS,
   const int                  NROUT,
   const enum LVL1_ROUT       * ROUTS
)
{
   TYPE                       eps;
   int                        ro, ntests=0, np=0;

   eps = Mjoin( PATL, epsilon )();
 
   for( ro = 0; ro < NROUT; ro++ )
   {
      if( ROUTS[ro] == ROTG )
      {
         RunrotgCase( CACHESIZE, ROUTS[ro], TEST, MFLOP, eps, &np, &ntests );
      }
#ifdef TREAL
      else if( ROUTS[ro] == ROTMG )
      {
         RunrotmgCase( CACHESIZE, ROUTS[ro], TEST, MFLOP, eps, &np, &ntests );
      }
#endif
      else if( ROUTS[ro] == ASUM  )
      {
         RunsumCase( CACHESIZE, ROUTS[ro], TEST, MFLOP, N0, NN, NINC, NINCX,
		     INCXS, eps, &np, &ntests );
      }
      else if( ROUTS[ro] == NRM2  )
      {
         RunnrmCase( CACHESIZE, ROUTS[ro], TEST, MFLOP, N0, NN, NINC, NINCX,
		     INCXS, eps, &np, &ntests );
      }
      else if( ROUTS[ro] == AMAX  )
      {
         RunmaxCase( CACHESIZE, ROUTS[ro], TEST, MFLOP, N0, NN, NINC, NINCX,
		     INCXS, eps, &np, &ntests );
      }
      else if( ROUTS[ro] == SCAL )
      {
         RunsclCase( CACHESIZE, ROUTS[ro], TEST, MFLOP, N0, NN, NINC, NALPHA,
		     ALPHAS, NINCX, INCXS, eps, &np, &ntests );
      }
#ifdef TCPLX
      else if( ROUTS[ro] == RSCAL )
      {
         RunrscCase( CACHESIZE, ROUTS[ro], TEST, MFLOP, N0, NN, NINC, NALPHA,
		     ALPHAS, NINCX, INCXS, eps, &np, &ntests );
      }
#endif
      else if(  ROUTS[ro] == AXPY )
      {
         RunxpyCase( CACHESIZE, ROUTS[ro], TEST, MFLOP, N0, NN, NINC, NALPHA,
		     ALPHAS, NINCX, INCXS, NINCY, INCYS, eps, &np, &ntests );
      }
      else if(  ROUTS[ro] == COPY )
      {
         RuncpyCase( CACHESIZE, ROUTS[ro], TEST, MFLOP, N0, NN, NINC, NINCX,
		     INCXS, NINCY, INCYS, eps, &np, &ntests );
      }
      else if(  ROUTS[ro] == SWAP )
      {
         RunswpCase( CACHESIZE, ROUTS[ro], TEST, MFLOP, N0, NN, NINC, NINCX,
		     INCXS, NINCY, INCYS, eps, &np, &ntests );
      }
      else if( ROUTS[ro] == ROT  )
      {
         RunrotCase( CACHESIZE, ROUTS[ro], TEST, MFLOP, N0, NN, NINC, NINCX,
		     INCXS, NINCY, INCYS, NALPHA, ALPHAS, eps, &np, &ntests );
      }
#ifdef TREAL
      else if( ROUTS[ro] == ROTM )
      {
         RunrotmCase( CACHESIZE, ROUTS[ro], TEST, MFLOP, N0, NN, NINC, NINCX,
		      INCXS, NINCY, INCYS, eps, &np, &ntests );
      }
#endif
      else if( ( ROUTS[ro] == DOTC  ) || ( ROUTS[ro] == DOTU   ) ||
               ( ROUTS[ro] == DSDOT ) || ( ROUTS[ro] == SDSDOT ) )
      {
         RundotCase( CACHESIZE, ROUTS[ro], TEST, MFLOP, N0, NN, NINC, NINCX,
		     INCXS, NINCY, INCYS, eps, &np, &ntests );
      }
   }
 
   if( TEST )
      (void) fprintf( stdout, "\n%d tests run, %d passed\n\n", ntests, np );
   else
      (void) fprintf( stdout, "\n%d tests run, all skipped\n\n", ntests );
} 
/*
 * =====================================================================
 * Main functions
 * =====================================================================
 */
void PrintUsage( char * nam )
{
   (void) fprintf( stderr, "ATLAS usage:\n" );
   (void) fprintf( stderr, "    %s [-options ...]\n\n", nam );
   (void) fprintf( stderr, "where options include:\n" );

   (void) fprintf( stderr, "   -h                                   " );
   (void) fprintf( stderr, ". print this message                   \n" );

   (void) fprintf( stderr, "   -R <rout>                            " );
   (void) fprintf( stderr, ". select  one  or all routines to test.\n" );
   (void) fprintf( stderr, "                                        " );
#if   defined( TREAL )
   (void) fprintf( stderr, "  rout must be in {rotg,rot,nrm2,amax, \n" );
   (void) fprintf( stderr, "                                        " );
   (void) fprintf( stderr, "  asum,scal,axpy,copy,swap,dot,rotmg,  \n" );
   (void) fprintf( stderr, "                                        " );
#if   defined( SREAL )
   (void) fprintf( stderr, "  rotm,dot,dsdot,sdsdot}.              \n" );
#elif defined( DREAL )
   (void) fprintf( stderr, "  rotm,dot}.                           \n" );
#endif
#else
   (void) fprintf( stderr, "  rout must be in {rotg,rot,nrm2,amax, \n" );
   (void) fprintf( stderr, "                                        " );
   (void) fprintf( stderr, "  asum,scal,rscal,axpy,copy,swap,dotc, \n" );
   (void) fprintf( stderr, "                                        " );
   (void) fprintf( stderr, "  dotu}.                               \n" );
#endif
   (void) fprintf( stderr, "                                        " );
   (void) fprintf( stderr, "  Default is -R axpy.  Ex: -R swap     \n" );

   (void) fprintf( stderr, "   -R <nrout> <rout1> ... <routN>       " );
   (void) fprintf( stderr, ". same as above for more than one rou- \n" );
   (void) fprintf( stderr, "                                        " );
   (void) fprintf( stderr, "  tine. Ex: -R 3 nrm2 copy rotg        \n" );

   (void) fprintf( stderr, "   -n <n>                               " );
   (void) fprintf( stderr, ". select one value for the parameter N.\n" );
   (void) fprintf( stderr, "                                        " );
   (void) fprintf( stderr, "  Ex: -n 100                           \n" );

   (void) fprintf( stderr, "   -N <n1> <nN> <ninc>                  " );
   (void) fprintf( stderr, ". select the values of N, from n1 to nN\n" );
   (void) fprintf( stderr, "                                        " );
   (void) fprintf( stderr, "  by increment of ninc. n1 > 0.        \n" );
   (void) fprintf( stderr, "                                        " );
   (void) fprintf( stderr, "  Ex: -N 100 1000 100                  \n" );

#ifdef TREAL
   (void) fprintf( stderr, "   -a <nalphas> <a1> ... <aN>           " );
   (void) fprintf( stderr, ". select the values of  alpha.  Default\n" );
   (void) fprintf( stderr, "                                        " );
   (void) fprintf( stderr, "  is -a 1 1.0. Ex: -a 3 -1.0 0.0 1.0   \n" );
#else
   (void) fprintf( stderr, "   -a <nalphas> <a1r> <a1i> ...  <aNi>  " );
   (void) fprintf( stderr, ". select the values of alpha, where a1r\n" );
   (void) fprintf( stderr, "                                        " );
   (void) fprintf( stderr, "  and  a1i  are the  real and imaginary\n" );
   (void) fprintf( stderr, "                                        " );
   (void) fprintf( stderr, "  parts of a1. Default is -a 1 1.0 0.0 \n" );
#endif

   (void) fprintf( stderr, "   -X <nincXs>  <incX0>  ... <incX1>    " );
   (void) fprintf( stderr, ". select  the values  of the  increment\n" );
   (void) fprintf( stderr, "                                        " );
   (void) fprintf( stderr, "  INCX. Default is 1; Ex: -X 2 1 -1    \n" );

   (void) fprintf( stderr, "   -Y <nincYs>  <incY0>  ... <incYN>    " );
   (void) fprintf( stderr, ". same  as  above for the the values of\n" );
   (void) fprintf( stderr, "                                        " );
   (void) fprintf( stderr, "  INCY.                                \n" );

   (void) fprintf( stderr, "   -T <0/1>                             " );
   (void) fprintf( stderr, ". disable computational check.  Default\n" );
   (void) fprintf( stderr, "                                        " );
   (void) fprintf( stderr, "  is -T 1                              \n" );

   (void) fprintf( stderr, "   -F <mflops>                          " );
   (void) fprintf( stderr, ". perform at least mflops per measure. \n" );

   (void) fprintf( stderr, "   -C <CacheSize>                       " );
   (void) fprintf( stderr, ". select how much memory in kilobytes\n" );
   (void) fprintf( stderr, "                                        " );
   (void) fprintf( stderr, "  to flush to clear the caches. Put 1\n" );
   (void) fprintf( stderr, "                                        " );
   (void) fprintf( stderr, "  for no cache flushing. Default is the\n" );
   (void) fprintf( stderr, "                                        " );
   (void) fprintf( stderr, "  size of the biggest cache.\n" );


   (void) fprintf( stderr, "\n" );
   exit( -1 );
}

void GetFlags
(
   int                        NARGS,
   char                       * ARGS[],
   int                        * NROUT,
   enum LVL1_ROUT             ** ROUTS,
   int                        * TEST,
   int                        * CACHESIZE,
   int                        * MFLOP,
   int                        * N0,
   int                        * NN,
   int                        * NINC,
   int                        * NALPHA,
   TYPE                       ** ALPHAS,
   int                        * NINCX,
   int                        ** INCXS,
   int                        * NINCY,
   int                        ** INCYS
)
{
   int                        i = 1, j;
/*
 * Set up defaults
 */
   *NROUT      = -1;                         /* No routine to be tested */
   *TEST       = 1;                               /* Enable the testing */
   *MFLOP      = 0;                /* smallest number of flops possible */
#ifdef L2SIZE
   *CACHESIZE = L2SIZE;               /* Size of largest cache to flush */
#else
   *CACHESIZE = 4*1024*1024;
#endif
   *N0         = -1; 
   *NALPHA     = -1;
   *NINCX      = *NINCY = -1;
   fprintf(stdout, "\n\n");
   for (i=0; i < NARGS; i++) fprintf(stdout, "%s ", ARGS[i]);
   fprintf(stdout, "\n\n");
 
   for( i = 1; i < NARGS; )
   {
      if( ARGS[i][0] != '-' ) PrintUsage( ARGS[0] );
 
      switch( ARGS[i++][1] )
      {
         case 'h':
            PrintUsage( ARGS[0] );
            break;
         case 'T':
            if( ARGS[i] == NULL ) PrintUsage( ARGS[0] );
            *TEST = atoi( ARGS[i++] );
            break;
         case 'F':
            if( ARGS[i] == NULL ) PrintUsage( ARGS[0] );
            *MFLOP = atoi( ARGS[i++] );
            if( *MFLOP < 0      ) PrintUsage( ARGS[0] );
            break;
         case 'C':
            if( ARGS[i] == NULL ) PrintUsage( ARGS[0] );
	    *CACHESIZE = 1024*atoi(ARGS[i++]);
            break;
         case 'N':
            if( ARGS[i] == NULL ) PrintUsage( ARGS[0] );
            *N0 = atoi( ARGS[i++] );
            if( *N0 < 0         ) PrintUsage( ARGS[0] );
            if( ARGS[i] == NULL ) PrintUsage( ARGS[0] );
            *NN = atoi( ARGS[i++] );
            if( *NN < 0         ) PrintUsage( ARGS[0] );
            if( ARGS[i] == NULL ) PrintUsage( ARGS[0] );
            *NINC = atoi( ARGS[i++] );
            if( *NINC <= 0      ) PrintUsage( ARGS[0] );
            break;
         case 'n':
            if( ARGS[i] == NULL ) PrintUsage( ARGS[0] );
            *N0 = *NN = atoi( ARGS[i++] ); *NINC = 1;
            if( *N0 < 0         ) PrintUsage( ARGS[0] );
            break;

         case 'a':
            if( ARGS[i] == NULL ) PrintUsage( ARGS[0] );
            *NALPHA = atoi( ARGS[i++] );
            if( *NALPHA <= 0    ) PrintUsage( ARGS[0] );
            *ALPHAS = (TYPE *)malloc( ATL_MulBySize( *NALPHA ) );
            ATL_assert( *ALPHAS );
            for( j = 0; j < (*NALPHA SHIFT); j++ )
            {
               if( ARGS[i] == NULL ) PrintUsage( ARGS[0] );
               (*ALPHAS)[j] = (TYPE)atof( ARGS[i++] );
            }
            break;

         case 'X':
            if( ARGS[i] == NULL ) PrintUsage( ARGS[0] );
            *NINCX = atoi( ARGS[i++] );
            if( *NINCX <= 0     ) PrintUsage( ARGS[0] );
            *INCXS = (int *)malloc( *NINCX * sizeof( int ) );
            ATL_assert( *INCXS );
            for( j = 0; j < *NINCX; j++ )
            {
               if( ARGS[i] == NULL ) PrintUsage( ARGS[0] );
               (*INCXS)[j] = atoi( ARGS[i++] );
            }
            break;
         case 'Y':
            if( ARGS[i] == NULL ) PrintUsage( ARGS[0] );
            *NINCY = atoi( ARGS[i++] );
            if( *NINCY <= 0     ) PrintUsage( ARGS[0] );
            *INCYS = (int *)malloc( *NINCY * sizeof( int ) );
            ATL_assert( *INCYS );
            for( j = 0; j < *NINCY; j++ )
            {
               if( ARGS[i] == NULL ) PrintUsage( ARGS[0] );
               (*INCYS)[j] = atoi( ARGS[i++] );
            }
            break;

         case 'R':
            if( ARGS[i] == NULL ) PrintUsage( ARGS[0] );
 
            if( ( strcmp( ARGS[i], "ALL"  ) == 0 ) ||
                ( strcmp( ARGS[i], "all"  ) == 0 ) )
            {
#if   defined( SREAL )
               *NROUT = 14;
#elif defined( DREAL ) 
               *NROUT = 12;
#elif defined( TCPLX )
               *NROUT = 12;
#endif
               *ROUTS = (enum LVL1_ROUT *)malloc( (*NROUT) *
                                                  sizeof( enum LVL1_ROUT ) );
               ATL_assert( *ROUTS );

               (*ROUTS)[ 0] = AXPY;  (*ROUTS)[ 1] = COPY;  (*ROUTS)[ 2] = SWAP;
               (*ROUTS)[ 3] = ROTG;  (*ROUTS)[ 4] = ROT;   (*ROUTS)[ 5] = SCAL;
               (*ROUTS)[ 6] = NRM2;  (*ROUTS)[ 7] = ASUM;  (*ROUTS)[ 8] = AMAX;
#if   defined( SREAL )
               (*ROUTS)[ 9] = ROTMG; (*ROUTS)[10] = ROTM;  (*ROUTS)[11] = DOTC;
               (*ROUTS)[12] = DSDOT; (*ROUTS)[13] = SDSDOT;
#elif defined( DREAL ) 
               (*ROUTS)[ 9] = ROTMG; (*ROUTS)[10] = ROTM;  (*ROUTS)[11] = DOTC;
#elif defined( TCPLX )
               (*ROUTS)[ 9] = DOTC;  (*ROUTS)[10] = DOTU;  (*ROUTS)[11] = RSCAL;
#endif
               i++;
            }
            else
            {
               if( isdigit( *ARGS[i] ) ) { *NROUT = atoi( ARGS[i++] ); }
               else                      { *NROUT = 1;                 }
               *ROUTS = (enum LVL1_ROUT *)malloc( (*NROUT) *
                                                  sizeof( enum LVL1_ROUT ) );
               ATL_assert( *ROUTS );
 
               for( j = 0; j < *NROUT; j++ )
               {
                  if( ARGS[i] == NULL ) PrintUsage( ARGS[0] );
 
                  if(      ( strcmp( ARGS[i], "AXPY"   ) == 0 ) ||
                           ( strcmp( ARGS[i], "axpy"   ) == 0 ) )
                     (*ROUTS)[j] = AXPY;
                  else if( ( strcmp( ARGS[i], "COPY"   ) == 0 ) ||
                           ( strcmp( ARGS[i], "copy"   ) == 0 ) )
                     (*ROUTS)[j] = COPY;
                  else if( ( strcmp( ARGS[i], "SWAP"   ) == 0 ) ||
                           ( strcmp( ARGS[i], "swap"   ) == 0 ) )
                     (*ROUTS)[j] = SWAP;
                  else if( ( strcmp( ARGS[i], "ROTG"   ) == 0 ) ||
                           ( strcmp( ARGS[i], "rotg"   ) == 0 ) )
                     (*ROUTS)[j] = ROTG;
                  else if( ( strcmp( ARGS[i], "ROT"    ) == 0 ) ||
                           ( strcmp( ARGS[i], "rot"    ) == 0 ) )
                     (*ROUTS)[j] = ROT;
                  else if( ( strcmp( ARGS[i], "SCAL"   ) == 0 ) ||
                           ( strcmp( ARGS[i], "scal"   ) == 0 ) )
                     (*ROUTS)[j] = SCAL;
                  else if( ( strcmp( ARGS[i], "NRM2"   ) == 0 ) ||
                           ( strcmp( ARGS[i], "nrm2"   ) == 0 ) )
                     (*ROUTS)[j] = NRM2;
                  else if( ( strcmp( ARGS[i], "ASUM"   ) == 0 ) ||
                           ( strcmp( ARGS[i], "asum"   ) == 0 ) )
                     (*ROUTS)[j] = ASUM;
                  else if( ( strcmp( ARGS[i], "AMAX"   ) == 0 ) ||
                           ( strcmp( ARGS[i], "amax"   ) == 0 ) )
                     (*ROUTS)[j] = AMAX;
#if   defined( SREAL )
                  else if( ( strcmp( ARGS[i], "ROTMG"  ) == 0 ) ||
                           ( strcmp( ARGS[i], "rotmg"  ) == 0 ) )
                     (*ROUTS)[j] = ROTMG;
                  else if( ( strcmp( ARGS[i], "ROTM"   ) == 0 ) ||
                           ( strcmp( ARGS[i], "rotm"   ) == 0 ) )
                     (*ROUTS)[j] = ROTM;
                  else if( ( strcmp( ARGS[i], "DOT"    ) == 0 ) ||
                           ( strcmp( ARGS[i], "dot"    ) == 0 ) )
                     (*ROUTS)[j] = DOTC;
                  else if( ( strcmp( ARGS[i], "DSDOT"  ) == 0 ) ||
                           ( strcmp( ARGS[i], "dsdot"  ) == 0 ) )
                     (*ROUTS)[j] = DSDOT;
                  else if( ( strcmp( ARGS[i], "SDSDOT" ) == 0 ) ||
                           ( strcmp( ARGS[i], "sdsdot" ) == 0 ) )
                     (*ROUTS)[j] = SDSDOT;
#elif defined( DREAL ) 
                  else if( ( strcmp( ARGS[i], "ROTMG"  ) == 0 ) ||
                           ( strcmp( ARGS[i], "rotmg"  ) == 0 ) )
                     (*ROUTS)[j] = ROTMG;
                  else if( ( strcmp( ARGS[i], "ROTM"   ) == 0 ) ||
                           ( strcmp( ARGS[i], "rotm"   ) == 0 ) )
                     (*ROUTS)[j] = ROTM;
                  else if( ( strcmp( ARGS[i], "DOT"    ) == 0 ) ||
                           ( strcmp( ARGS[i], "dot"    ) == 0 ) )
                     (*ROUTS)[j] = DOTC;
#elif defined( TCPLX )
                  else if( ( strcmp( ARGS[i], "DOTC"   ) == 0 ) ||
                           ( strcmp( ARGS[i], "dotc"   ) == 0 ) )
                     (*ROUTS)[j] = DOTC;
                  else if( ( strcmp( ARGS[i], "DOTU"   ) == 0 ) ||
                           ( strcmp( ARGS[i], "dotu"   ) == 0 ) )
                     (*ROUTS)[j] = DOTU;
                  else if( ( strcmp( ARGS[i], "RSCAL"  ) == 0 ) ||
                           ( strcmp( ARGS[i], "rscal"  ) == 0 ) )
                     (*ROUTS)[j] = RSCAL;
#endif
                  else PrintUsage( ARGS[0] );
                  i++;
               }
            }
            break;
         default:
            PrintUsage( ARGS[0] );
            break;
      }
   }
/*
 * Finish setting up defaults if the user has not selected
 */
   if( *NROUT == -1 )
   {
      *NROUT = 1;
      *ROUTS = (enum LVL1_ROUT *)malloc( sizeof( enum LVL1_ROUT ) );
      ATL_assert( *ROUTS );
      (*ROUTS)[0] = AXPY;
   }

   if( *N0 == -1 ) { *N0 = 100; *NN = 1000; *NINC = 100; }
 
   if( *NALPHA == -1 )
   {
      *NALPHA = 1;
      *ALPHAS = (TYPE *)malloc( ATL_MulBySize( 1 ) );
      ATL_assert( *ALPHAS );
#ifdef TREAL
      (*ALPHAS)[0] = ATL_rone;
#else
      (*ALPHAS)[0] = ATL_rone;
      (*ALPHAS)[1] = ATL_rzero;
#endif
   }

   if( *NINCX == -1 )
   {
      *NINCX = 1;
      *INCXS = (int *)malloc(sizeof(int));
      ATL_assert( *INCXS );
      (*INCXS)[0] = 1;
   }
   if( *NINCY == -1 )
   {
      *NINCY = 1;
      *INCYS = (int *)malloc( sizeof( int ) );
      ATL_assert( *INCYS );
      (*INCYS)[0] = 1;
   }
}

int main( int NARGS, char **ARGS )
{
   int                        mflopmin, ninc, nstart, nstop, nalphas,
                              cachesize, nincx, nincy, nrout, test;
   int                        * incxs  = NULL, * incys = NULL;
   TYPE                       * alphas = NULL;
   enum LVL1_ROUT             * routs  = NULL;

   GetFlags( NARGS, ARGS, &nrout, &routs, &test, &cachesize, &mflopmin, 
             &nstart, &nstop, &ninc, &nalphas, &alphas, &nincx, &incxs, 
             &nincy, &incys );
 
   RunCases( test, cachesize, mflopmin, nstart, nstop, ninc, nalphas, 
             alphas, nincx, incxs, nincy, incys, nrout, routs );
 
   if( alphas ) free( alphas );
   if( incxs  ) free( incxs  );
   if( incys  ) free( incys  );
   if( routs  ) free( routs  );

   return( 0 );
} 
@rout l2blastst
@define rname @l2blastst@
/*
 * =====================================================================
 * Include files
 * =====================================================================
 */
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <assert.h>
#ifdef GCCWIN
   ___main(){} __main(){} MAIN__(){} _MAIN_(){}
   #ifndef isdigit
      #define isdigit(ch_) ( ((ch_)=='0')||((ch_)=='1')||((ch_)=='2')|| \
                             ((ch_)=='3')||((ch_)=='4')||((ch_)=='5')|| \
                             ((ch_)=='6')||((ch_)=='7')||((ch_)=='8')|| \
                             ((ch_)=='9') )
   #endif
#else
   #include <ctype.h>
#endif

#include "atlas_misc.h"
#include "atlas_tst.h"
/*
 * =====================================================================
 * #define macro constants
 * =====================================================================
 */
#define    MEGA                     1000000.0
#if defined( SREAL ) || defined( SCPLX )
#define    THRESH                        50.0f
#else
#define    THRESH                        50.0
#endif

/* #define    ATLAS_DEBUG */
/*
 * =====================================================================
 * # macro functions
 * =====================================================================
 *
 * The following and mutually exclusive  macros  allow to select various
 * BLAS implementations to test the ATLAS implementation against:
 *
 *    USE_F77_BLAS     : Fortran 77 BLAS interface,
 *    USE_L2_REFERENCE : C ATLAS reference implementation,
 *
 * If none of these macros is defined at compile time, the  ATLAS imple-
 * mentation is to be tested against itself,  after all this is the only
 * version we are sure to have available.
 *
 * By default the mono-threaded  ATLAS  routines are tested. To test the
 * multi-threaded ATLAS routines, define the following macro:
 *    USE_L2_PTHREADS  : multi-threaded ATLAS implementation.
 */
#ifndef USE_L2_REFERENCE
   #define USE_F77_BLAS
#endif

#ifdef ATL_USEPTHREADS
   #define USE_L2_PTHREADS
   #include "atlas_tlvl2.h"
#endif
/*
 * =====================================================================
 */
#if   defined( USE_F77_BLAS ) /* Trusted BLAS version to test against */
#define  TP2      Mjoin( PATL,   f77 ) 
#elif defined( USE_L2_REFERENCE )
#include "atlas_reflevel2.h"
#define  TP2      Mjoin( PATL,   ref ) 
#else /* defined( USE_L2_ATLAS ) */  /* use ATLAS itself !! (default) */
#include "atlas_level2.h"
#define  TP2      PATL
#endif

#define trusted_gbmv(   TA,      M, N, KL, KU, al, A, lA, X, iX, be, Y, iY) \
Mjoin( TP2, gbmv )(     TA,      M, N, KL, KU, al, A, lA, X, iX, be, Y, iY)
#define trusted_gemv(   TA,      M, N,         al, A, lA, X, iX, be, Y, iY) \
Mjoin( TP2, gemv )(     TA,      M, N,         al, A, lA, X, iX, be, Y, iY)

#ifdef TREAL
#define trusted_sbmv(UP,         N,    K,      al, A, lA, X, iX, be, Y, iY) \
Mjoin( TP2, sbmv )(  UP,         N,    K,      al, A, lA, X, iX, be, Y, iY)
#define trusted_spmv(UP,         N,            al, A,     X, iX, be, Y, iY) \
Mjoin( TP2, spmv )(  UP,         N,            al, A,     X, iX, be, Y, iY)
#define trusted_symv(UP,         N,            al, A, lA, X, iX, be, Y, iY) \
Mjoin( TP2, symv )(  UP,         N,            al, A, lA, X, iX, be, Y, iY)
#else
#define trusted_sbmv(UP,         N,    K,      al, A, lA, X, iX, be, Y, iY) \
Mjoin( TP2, hbmv )(  UP,         N,    K,      al, A, lA, X, iX, be, Y, iY)
#define trusted_spmv(UP,         N,            al, A,     X, iX, be, Y, iY) \
Mjoin( TP2, hpmv )(  UP,         N,            al, A,     X, iX, be, Y, iY)
#define trusted_symv(UP,         N,            al, A, lA, X, iX, be, Y, iY) \
Mjoin( TP2, hemv )(  UP,         N,            al, A, lA, X, iX, be, Y, iY)
#endif

#define trusted_tbmv(UP, TA, DI, N,    K,          A, lA, X, iX) \
Mjoin( TP2, tbmv )(  UP, TA, DI, N,    K,          A, lA, X, iX)
#define trusted_tpmv(UP, TA, DI, N,                A,     X, iX) \
Mjoin( TP2, tpmv )(  UP, TA, DI, N,                A,     X, iX)
#define trusted_trmv(UP, TA, DI, N,                A, lA, X, iX) \
Mjoin( TP2, trmv )(  UP, TA, DI, N,                A, lA, X, iX)

#define trusted_tbsv(UP, TA, DI, N,    K,          A, lA, X, iX) \
Mjoin( TP2, tbsv )(  UP, TA, DI, N,    K,          A, lA, X, iX)
#define trusted_tpsv(UP, TA, DI, N,                A,     X, iX) \
Mjoin( TP2, tpsv )(  UP, TA, DI, N,                A,     X, iX)
#define trusted_trsv(UP, TA, DI, N,                A, lA, X, iX) \
Mjoin( TP2, trsv )(  UP, TA, DI, N,                A, lA, X, iX)

#ifdef TREAL
   #define trusted_geru(M, N, al, X, iX, Y, iY, A, lA) \
      Mjoin(TP2,ger)(M, N, al, X, iX, Y, iY, A, lA)
   #define trusted_gerc(M, N, al, X, iX, Y, iY, A, lA) \
      Mjoin(TP2,ger)(M, N, al, X, iX, Y, iY, A, lA)
   #define trusted_ger2u(M, N, al, X, iX, Y, iY, beta, W, iW, Z, iZ, A, lA) \
      ger2_ger(0, M, N, al, X, iX, Y, iY, beta, W, iW, Z, iZ, A, lA)
   #define trusted_ger2c(M, N, al, X, iX, Y, iY, beta, W, iW, Z, iZ, A, lA) \
      ger2_ger(0, M, N, al, X, iX, Y, iY, beta, W, iW, Z, iZ, A, lA)
#else
   #define trusted_geru(M, N, al, X, iX, Y, iY, A, lA) \
      Mjoin(TP2,geru)(M, N, al, X, iX, Y, iY, A, lA)
   #define trusted_gerc(M, N, al, X, iX, Y, iY, A, lA) \
      Mjoin(TP2,gerc)(M, N, al, X, iX, Y, iY, A, lA)
   #define trusted_ger2c(M, N, al, X, iX, Y, iY, beta, W, iW, Z, iZ, A, lA) \
      ger2_ger(1, M, N, al, X, iX, Y, iY, beta, W, iW, Z, iZ, A, lA)
   #define trusted_ger2u(M, N, al, X, iX, Y, iY, beta, W, iW, Z, iZ, A, lA) \
      ger2_ger(0, M, N, al, X, iX, Y, iY, beta, W, iW, Z, iZ, A, lA)
#endif

#ifdef TREAL
#define  trusted_spr(UP,         N,            al, X, iX,            A    ) \
Mjoin( TP2, spr )(   UP,         N,            al, X, iX,            A    )
#define  trusted_syr(UP,         N,            al, X, iX,            A, lA) \
Mjoin( TP2, syr )(   UP,         N,            al, X, iX,            A, lA)
#else
#define  trusted_spr(UP,         N,            al, X, iX,            A    ) \
Mjoin( TP2, hpr )(   UP,         N,            al, X, iX,            A    )
#define  trusted_syr(UP,         N,            al, X, iX,            A, lA) \
Mjoin( TP2, her )(   UP,         N,            al, X, iX,            A, lA)
#endif

#ifdef TREAL
#define trusted_spr2(UP,         N,            al, X, iX, Y, iY,     A    ) \
Mjoin( TP2, spr2 )(  UP,         N,            al, X, iX, Y, iY,     A    )
#define trusted_syr2(UP,         N,            al, X, iX, Y, iY,     A, lA) \
Mjoin( TP2, syr2 )(  UP,         N,            al, X, iX, Y, iY,     A, lA)
#else
#define trusted_spr2(UP,         N,            al, X, iX, Y, iY,     A    ) \
Mjoin( TP2, hpr2 )(  UP,         N,            al, X, iX, Y, iY,     A    )
#define trusted_syr2(UP,         N,            al, X, iX, Y, iY,     A, lA) \
Mjoin( TP2, her2 )(  UP,         N,            al, X, iX, Y, iY,     A, lA)
#endif
/*
 * ATLAS version of the BLAS to test.
 */
#if defined( USE_L2_PTHREADS ) && !defined(ATL_MIKE)
   #include "atlas_pthreads.h"
@skip   #include "atlas_ptlvl2.h"
   #include "atlas_tlvl2.h"
   #define  AP2 PATL
   #define  AP3 Mjoin(PATL, t) 
#else
   #ifdef ATL_MIKE
      #include "atlas_pthreads.h"
   #endif
   #include "atlas_level2.h"
   #define  AP2 PATL
   #define  AP3 PATL
#endif

#define test_gbmv(      TA,      M, N, KL, KU, al, A, lA, X, iX, be, Y, iY) \
Mjoin( AP2, gbmv )(     TA,      M, N, KL, KU, al, A, lA, X, iX, be, Y, iY)
#define test_gemv(      TA,      M, N,         al, A, lA, X, iX, be, Y, iY) \
Mjoin( AP3, gemv )(     TA,      M, N,         al, A, lA, X, iX, be, Y, iY)

#ifdef TREAL
#define test_sbmv(   UP,         N,    K,      al, A, lA, X, iX, be, Y, iY) \
Mjoin( AP2, sbmv )(  UP,         N,    K,      al, A, lA, X, iX, be, Y, iY)
#define test_spmv(   UP,         N,            al, A,     X, iX, be, Y, iY) \
Mjoin( AP2, spmv )(  UP,         N,            al, A,     X, iX, be, Y, iY)
#define test_symv(   UP,         N,            al, A, lA, X, iX, be, Y, iY) \
Mjoin( AP2, symv )(  UP,         N,            al, A, lA, X, iX, be, Y, iY)
#else
#define test_sbmv(   UP,         N,    K,      al, A, lA, X, iX, be, Y, iY) \
Mjoin( AP2, hbmv )(  UP,         N,    K,      al, A, lA, X, iX, be, Y, iY)
#define test_spmv(   UP,         N,            al, A,     X, iX, be, Y, iY) \
Mjoin( AP2, hpmv )(  UP,         N,            al, A,     X, iX, be, Y, iY)
#define test_symv(   UP,         N,            al, A, lA, X, iX, be, Y, iY) \
Mjoin( AP2, hemv )(  UP,         N,            al, A, lA, X, iX, be, Y, iY)
#endif

#define test_tbmv(   UP, TA, DI, N,    K,          A, lA, X, iX) \
Mjoin( AP2, tbmv )(  UP, TA, DI, N,    K,          A, lA, X, iX)
#define test_tpmv(   UP, TA, DI, N,                A,     X, iX) \
Mjoin( AP2, tpmv )(  UP, TA, DI, N,                A,     X, iX)
#define test_trmv(   UP, TA, DI, N,                A, lA, X, iX) \
Mjoin( AP2, trmv )(  UP, TA, DI, N,                A, lA, X, iX)

#define test_tbsv(   UP, TA, DI, N,    K,          A, lA, X, iX) \
Mjoin( AP2, tbsv )(  UP, TA, DI, N,    K,          A, lA, X, iX)
#define test_tpsv(   UP, TA, DI, N,                A,     X, iX) \
Mjoin( AP2, tpsv )(  UP, TA, DI, N,                A,     X, iX)
#define test_trsv(   UP, TA, DI, N,                A, lA, X, iX) \
Mjoin( AP2, trsv )(  UP, TA, DI, N,                A, lA, X, iX)

#ifdef TREAL
   #define test_geru(M, N, al, X, iX, Y, iY, A, lA) \
      Mjoin(AP3,ger)(M, N, al, X, iX, Y, iY, A, lA)
   #define test_gerc(M, N, al, X, iX, Y, iY, A, lA) \
      Mjoin(AP3,ger)(M, N, al, X, iX, Y, iY, A, lA)
   #define test_ger2u(M, N, al, X, iX, Y, iY, beta, W, iW, Z, iZ, A, lA) \
      Mjoin(AP2,ger2)(M, N, al, X, iX, Y, iY, beta, W, iW, Z, iZ, A, lA)
   #define test_ger2c(M, N, al, X, iX, Y, iY, beta, W, iW, Z, iZ, A, lA) \
      Mjoin(AP2,ger2)(M, N, al, X, iX, Y, iY, beta, W, iW, Z, iZ, A, lA)
#else
   #define test_geru(M, N, al, X, iX, Y, iY, A, lA) \
      Mjoin(AP3,geru)(M, N, al, X, iX, Y, iY, A, lA)
   #define test_gerc(M, N,  al, X, iX, Y, iY, A, lA) \
      Mjoin(AP3,gerc)(M, N, al, X, iX, Y, iY, A, lA)
   #define test_ger2c(M, N, al, X, iX, Y, iY, beta, W, iW, Z, iZ, A, lA) \
      Mjoin(AP2,ger2c)(M, N, al, X, iX, Y, iY, beta, W, iW, Z, iZ, A, lA)
   #define test_ger2u(M, N, al, X, iX, Y, iY, beta, W, iW, Z, iZ, A, lA) \
      Mjoin(AP2,ger2u)(M, N, al, X, iX, Y, iY, beta, W, iW, Z, iZ, A, lA)
#endif

#ifdef TREAL
#define  test_spr(   UP,         N,            al, X, iX,            A    ) \
Mjoin( AP2, spr )(   UP,         N,            al, X, iX,            A    )
#define  test_syr(   UP,         N,            al, X, iX,            A, lA) \
Mjoin( AP2, syr )(   UP,         N,            al, X, iX,            A, lA)
#else
#define  test_spr(   UP,         N,            al, X, iX,            A    ) \
Mjoin( AP2, hpr )(   UP,         N,            al, X, iX,            A    )
#define  test_syr(   UP,         N,            al, X, iX,            A, lA) \
Mjoin( AP2, her )(   UP,         N,            al, X, iX,            A, lA)
#endif

#ifdef TREAL
#define test_spr2(   UP,         N,            al, X, iX, Y, iY,     A    ) \
Mjoin( AP2, spr2 )(  UP,         N,            al, X, iX, Y, iY,     A    )
#define test_syr2(   UP,         N,            al, X, iX, Y, iY,     A, lA) \
Mjoin( AP2, syr2 )(  UP,         N,            al, X, iX, Y, iY,     A, lA)
#else
#define test_spr2(   UP,         N,            al, X, iX, Y, iY,     A    ) \
Mjoin( AP2, hpr2 )(  UP,         N,            al, X, iX, Y, iY,     A    )
#define test_syr2(   UP,         N,            al, X, iX, Y, iY,     A, lA) \
Mjoin( AP2, her2 )(  UP,         N,            al, X, iX, Y, iY,     A, lA)
#endif
/*
 * =====================================================================
 * macro functions
 * =====================================================================
 */
#ifdef TCPLX
#define Mabs1(X) (Mabs(*X) + Mabs(*(X+1)))
#else
#define Mabs1(X) (Mabs(X))
#endif

#ifdef  ATL_NTHREADS
#define LCSIZE          ATL_NTHREADS * L2SIZE
#else
#define LCSIZE          L2SIZE
#endif
/*
 * =====================================================================
 * typedef definitions
 * =====================================================================
 */
enum LVL2_ROUT /* 17 + 1 = 18 */
{
   GEMV=0, GBMV, SBMV, SPMV, SYMV, TBMV, TPMV, TRMV, TBSV, TPSV, TRSV,
   GERU,   GERC, GER2U, GER2C, SYR,  SPR,  SYR2, SPR2,
   ALLROUTS
};
/*
 * =====================================================================
 * Prototypes for the testing routines
 * =====================================================================
 */
double     opbl2
(  const enum LVL2_ROUT,           const int,      const int,
   const int,      const int );
void       tbddom
(  const enum ATLAS_UPLO,          const int,      const int,
   TYPE *,         const int );
void       tpddom
(  const enum ATLAS_UPLO,          const int,      TYPE * );
void       trddom
(  const enum ATLAS_UPLO,          const int,      TYPE *,
   const int );

TYPE       gmvtst
(  const int CACHESIZE,
   const enum LVL2_ROUT,           const int,      const enum ATLAS_TRANS,
   const int,      const int,      const int,      const int,
   const SCALAR,   const int,      const int,      const SCALAR,
   const int,      const TYPE,     double *,       double *,
   double *,       double * );
TYPE       smvtst
(  const int CACHESIZE,
   const enum LVL2_ROUT,           const int,      const enum ATLAS_UPLO,
   const int,      const int,      const SCALAR,   const int,
   const int,      const SCALAR,   const int,      const TYPE,
   double *,       double *,       double *,       double * );
TYPE       tmvtst
(  const int CACHESIZE,
   const enum LVL2_ROUT,           const int,      const enum ATLAS_UPLO,
   const enum ATLAS_TRANS,         const enum ATLAS_DIAG,
   const int,      const int,      const int,      const int,
   const TYPE,     double *,       double *,       double *,
   double * );
TYPE       tsvtst
(  const int CACHESIZE,
   const enum LVL2_ROUT,           const int,      const enum ATLAS_UPLO,
   const enum ATLAS_TRANS,         const enum ATLAS_DIAG,
   const int,      const int,      const int,      const int,
   const TYPE,     double *,       double *,       double *,
   double * );
TYPE       gr1tst
(  const int CACHESIZE,
   const enum LVL2_ROUT,           const int,      const int,
   const int,      const SCALAR,   const int,      const int,
   const int,      const TYPE,     double *,       double *,
   double *,       double * );
TYPE       sr1tst
(  const int CACHESIZE,
   const enum LVL2_ROUT,           const int,      const enum ATLAS_UPLO,
   const int,      const TYPE,     const int,      const int,
   const TYPE,     double *,       double *,       double *,
   double * );
TYPE       sr2tst
(  const int CACHESIZE,
   const enum LVL2_ROUT,           const int,      const enum ATLAS_UPLO,
   const int,      const SCALAR,   const int,      const int,
   const int,      const TYPE,     double *,       double *,
   double *,       double * );

int        gmvcase
(  const int CACHESIZE,  
   const enum LVL2_ROUT,           const int,      const int,
   const enum ATLAS_TRANS,         const int,      const int,
   const int,      const int,      const SCALAR,   const int,
   const int,      const SCALAR,   const int,      const TYPE,
   double *,       double *,       double *,       double * );
int        smvcase
(  const int CACHESIZE,
   const enum LVL2_ROUT,           const int,      const int,
   const enum ATLAS_UPLO,          const int,      const int,
   const SCALAR,   const int,      const int,      const SCALAR,
   const int,      const TYPE,     double *,       double *,
   double *,       double * );
int        tmvcase
(  const int CACHESIZE,
   const enum LVL2_ROUT,           const int,      const int,
   const enum ATLAS_UPLO,          const enum ATLAS_TRANS,
   const enum ATLAS_DIAG,          const int,      const int,
   const int,      const int,      const TYPE,     double *,
   double *,       double *,       double * );
int        tsvcase
(  const int CACHESIZE,
   const enum LVL2_ROUT,           const int,      const int,
   const enum ATLAS_UPLO,          const enum ATLAS_TRANS,
   const enum ATLAS_DIAG,          const int,      const int,
   const int,      const int,      const TYPE,     double *,
   double *,       double *,       double * );
int        gr1case
(  const int CACHESIZE,
   const enum LVL2_ROUT,           const int,      const int,
   const int,      const int,      const SCALAR,   const int,
   const int,      const int,      const TYPE,     double *,
   double *,       double *,       double * );
int        sr1case
(  const int CACHESIZE,
   const enum LVL2_ROUT,           const int,      const int,
   const enum ATLAS_UPLO,          const int,      const TYPE,
   const int,      const int,      const TYPE,     double *,
   double *,       double *,       double * );
int        sr2case
(  const int CACHESIZE,
   const enum LVL2_ROUT,           const int,      const int,
   const enum ATLAS_UPLO,          const int,      const SCALAR,
   const int,      const int,      const int,      const TYPE,
   double *,       double *,       double *,       double * );

void       RungbmCase
(  const int CACHESIZE,
   const enum LVL2_ROUT,           const int,      const int,
   const int,      const int,      const enum ATLAS_TRANS *,
   int,            int,            int,            int,
   int,            int,            int,            int,
   int,            int,            int,            int,
   const int,      const TYPE *,   const int,      const TYPE *,
   const int,      const int *,    const int,      const int *,
   const TYPE,     int *,          int * );
void       RungemCase
(  const int CACHESIZE,
   const enum LVL2_ROUT,           const int,      const int,
   const int,      const int,      const enum ATLAS_TRANS *,
   int,            int,            int,            int,
   int,            int,            const int,      const TYPE *,
   const int,      const TYPE *,   const int,      const int *,
   const int,      const int *,    const TYPE,     int *,
   int * );
void       RunsbCase
(  const int CACHESIZE,
   const enum LVL2_ROUT,           const int,      const int,
   const int,      const int,      const enum ATLAS_UPLO *,
   int,            int,            int,            int,
   int,            int,            int,            int,
   int,            const int,      const TYPE *,   const int,
   const TYPE *,   const int,      const int *,    const int,
   const int *,    const TYPE,     int *,          int * );
void       RunspCase
(  const int CACHESIZE,
   const enum LVL2_ROUT,           const int,      const int,
   const int,      const enum ATLAS_UPLO *,        const int,
   const int,      const int,      const int,      const TYPE *,
   const int,      const TYPE *,   const int,      const int *,
   const int,      const int *,    const TYPE,     int *,
   int * ); 
void       RunsyCase
(  const int CACHESIZE,
   const enum LVL2_ROUT,           const int,      const int,
   const int,      const int,      const enum ATLAS_UPLO *,
   int,            int,            int,            const int,
   const TYPE *,   const int,      const TYPE *,   const int,
   const int *,    const int,      const int *,    const TYPE,
   int *,          int * );
void       RuntbCase
(   const int CACHESIZE,
    const enum LVL2_ROUT,           const int,      const int,
   const int,      const int,      const enum ATLAS_UPLO *,
   const int,      const enum ATLAS_TRANS *,       const int,
   const enum ATLAS_DIAG *,        int,            int,
   int,            int,            int,            int,
   int,            int,            int,            const int,
   const int *,    const TYPE,     int *,          int * );
void       RuntpCase
(  const int CACHESIZE,
   const enum LVL2_ROUT,           const int,      const int,
   const int,      const enum ATLAS_UPLO *,        const int,
   const enum ATLAS_TRANS *,       const int,      const enum ATLAS_DIAG *,
   const int,      const int,      const int,      const int,
   const int *,    const TYPE,     int *,          int * );
void       RuntrCase
(  const int CACHESIZE,
   const enum LVL2_ROUT,           const int,      const int,
   const int,      const int,      const enum ATLAS_UPLO *,
   const int,      const enum ATLAS_TRANS *,       const int,
   const enum ATLAS_DIAG *,        int,            int,
   int,            const int,      const int *,    const TYPE,
   int *,          int * );
void       Rungr1Case
(  const int CACHESIZE,
   const enum LVL2_ROUT,           const int,      const int,
   const int,      int,            int,            int,
   int,            int,            int,            const int,
   const TYPE *,   const int,      const int *,    const int,
   const int *,    const TYPE,     int *,          int * );
void       Runsp1Case
(  const int CACHESIZE,
   const enum LVL2_ROUT,           const int,      const int,
   const int,      const enum ATLAS_UPLO *,        const int,
   const int,      const int,      const int,      const TYPE *,
   const int,      const int *,    const TYPE,     int *,
   int * );
void       Runsr1Case
(  const int CACHESIZE,
   const enum LVL2_ROUT,           const int,      const int,
   const int,      const int,      const enum ATLAS_UPLO *,
   int,            int,            int,            const int,
   const TYPE *,   const int,      const int *,    const TYPE,
   int *,          int * );
void       Runsp2Case
(  const int CACHESIZE,
   const enum LVL2_ROUT,           const int,      const int,
   const int,      const enum ATLAS_UPLO *,        const int,
   const int,      const int,      const int,      const TYPE *,
   const int,      const int *,    const int,      const int *,
   const TYPE,     int *,          int * );
void       Runsr2Case
(  const int CACHESIZE,
   const enum LVL2_ROUT,           const int,      const int,
   const int,      const int,      const enum ATLAS_UPLO *,
   int,            int,            int,            const int,
   const TYPE *,   const int,      const int *,    const int,
   const int *,    const TYPE,     int *,          int * ); 
void       RunCases
(  const int,      const int,      const int,      const int,
   const int,
   const enum ATLAS_UPLO *,        const int,      const enum ATLAS_TRANS *,
   const int,      const enum ATLAS_DIAG *,        const int,
   const int,      const int,      const int,      const int,
   const int,      const int,      const int,      const int,
   const int,      const int,      const int,      const int,
   const TYPE *,   const int,      const TYPE *,   const int,
   const int *,    const int,      const int *,    const int,
   const enum LVL2_ROUT * );

void       PrintUsage
(  char * );

void       GetFlags
(  int,            char **,        int *,          enum LVL2_ROUT **,
   int *,          int *,          int *,          int *,
   int *,          enum ATLAS_UPLO **,             int *,
   enum ATLAS_TRANS **,            int *,          enum ATLAS_DIAG **,
   int *,          int *,          int *,          int *,
   int *,          int *,          int *,          int *,
   int *,          int *,          int *,          int *,
   int *,          TYPE **,        int *,          TYPE **,
   int *,          int **,         int *,          int ** );

int        main
(  int,            char ** );
/*
 * =====================================================================
 */
void ger2_ger
   (ATL_INT CONJ, ATL_CINT M, ATL_CINT N, const SCALAR alpha, 
    const TYPE *X, ATL_CINT incX, const TYPE *Y, ATL_CINT incY, 
    const SCALAR beta, const TYPE *W, ATL_CINT incW, const TYPE *Z, 
    ATL_CINT incZ, TYPE *A, ATL_CINT lda)
/*
 * Performs A <- alpha*X*Y + beta*W*Z using two calls to GER
 */
{
   #ifdef TREAL
      test_geru(M, N, alpha, X, incX, Y, incY, A, lda);
      test_geru(M, N,  beta, W, incW, Z, incZ, A, lda);
   #else
      if (CONJ)
      {
         test_gerc(M, N, alpha, X, incX, Y, incY, A, lda);
         test_gerc(M, N,  beta, W, incW, Z, incZ, A, lda);
      }
      else
      {
         test_geru(M, N, alpha, X, incX, Y, incY, A, lda);
         test_geru(M, N,  beta, W, incW, Z, incZ, A, lda);
      }
   #endif
}
            
double opbl2
(
   const enum LVL2_ROUT       ROUT,
   const int                  M,
   const int                  N,
   const int                  KKL,
   const int                  KKU
)
{
   int                        j;
   double                     i0, i1, adds = 0.0, em, en, ek, kl, ku,
                              muls = 0.0;

   if( ( M <= 0 ) || ( N <= 0 ) ) return( 0.0 );

   kl = (double)( Mmax( 0, Mmin( M - 1, KKL ) ) );
   ku = (double)( Mmax( 0, Mmin( N - 1, KKU ) ) );
   em = (double)(M);
   en = (double)(N);
   ek = kl;

   if(      ROUT == GEMV )
   {
      muls = em * ( en + 1.0 );
      adds = em * en;

   }
   else if( ROUT == GBMV )
   {
      for( j = 0; j < N; j++ )
      {
         i1 = (double)(j) + kl; i0 = em - 1.0; i1 = Mmin( i1, i0 );
         i0 = (double)(j) - ku; i0 = Mmax( i0, 0.0 );
         i1 -= i0 - 1;
         muls += Mmax( i1, 0.0 );
      }
      adds = muls;
/*  
 *    muls = em * ( en + 1.0 ) - ( em - 1.0 - kl ) * ( em - kl ) / 2.0 -
 *                               ( en - 1.0 - ku ) * ( en - ku ) / 2.0;
 *    adds = em * ( en + 1.0 ) - ( em - 1.0 - kl ) * ( em - kl ) / 2.0 -
 *                               ( en - 1.0 - ku ) * ( en - ku ) / 2.0;
 */
   }
   else if( ( ROUT == SPMV ) || ( ROUT == SYMV ) )
   {                       /* ( ( ROUT == HPMV ) || ( ROUT == HEMV ) ) */
      muls = em * ( em + 1.0 );
      adds = em * em;
   }
   else if( ROUT == SBMV )
   {                                               /* ( ROUT == HBMV ) */
      muls = em * ( em + 1.0 ) - ( em - 1.0 - ek ) * ( em - ek );
      adds = em * em           - ( em - 1.0 - ek ) * ( em - ek );
   }
   else if( ( ROUT == TPMV ) || ( ROUT == TRMV ) )
   {
      muls = em * ( em + 1.0 ) / 2.0;
      adds = ( em - 1.0 ) * em / 2.0;
   }
   else if( ROUT == TBMV )
   {
      muls = em * ( em + 1.0 ) / 2.0 - ( em - ek - 1.0 ) * ( em - ek ) / 2.0;
      adds = ( em - 1.0 ) * em / 2.0 - ( em - ek - 1.0 ) * ( em - ek ) / 2.0;
   }
   else if( ( ROUT == TPSV ) || ( ROUT == TRSV ) )
   {
      muls = em * ( em + 1.0 ) / 2.0;
      adds = ( em - 1.0 ) * em / 2.0;
   }
   else if( ROUT == TBSV )
   {
      muls = em * ( em + 1.0 ) / 2.0 - ( em - ek - 1.0 ) * ( em - ek ) / 2.0;
      adds = ( em - 1.0 ) * em / 2.0 - ( em - ek - 1.0 ) * ( em - ek ) / 2.0;
   }
   else if( ( ROUT == GERC ) || ( ROUT == GERU ) || 
            ( ROUT == GER2C ) || ( ROUT == GER2U ) ) /* ( ROUT == GER  ) */
   {
      muls = em * en + Mmin( em, en );
      adds = em * en;
      if (ROUT == GER2C || ROUT == GER2U)
      {
         muls *= 2;
         adds *= 2;
      }
   }
   else if( ( ROUT == SPR ) || ( ROUT == SYR ) )
   {                         /* ( ( ROUT == HPR ) || ( ROUT == HER ) ) */
      muls = em * ( em + 1.0 ) / 2.0 + em;
      adds = em * ( em + 1.0 ) / 2.0;
   }
   else if( ( ROUT == SPR2 ) || ( ROUT == SYR2 ) )
   {                       /* ( ( ROUT == HPR2 ) || ( ROUT == HER2 ) ) */
      muls = em * ( em + 1.0 ) + 2.0 * em;
      adds = em * ( em + 1.0 );
   }
#ifdef TREAL
   return(       muls +       adds );
#else
   return( 6.0 * muls + 2.0 * adds );
#endif
}

void tbddom
(
   const enum ATLAS_UPLO      UPLO,
   const int                  N,
   const int                  K,
   TYPE                       * A,
   const int                  LDA
)
{
/*
 * Scale strictly lower (resp. upper) part of triangular band matrix by 1 / N
 * to make it diagonally dominant.
 */
   int                        i, i0, i1, iaij, j, jaj, l, lda2 = ( LDA SHIFT );
   TYPE                       alpha;

   if( N <= 0 ) return;

   alpha = ATL_rone / (TYPE)(N);

   if( UPLO == AtlasUpper )
   {
      for( j = 0, jaj  = 0; j < N; j++, jaj += lda2 )
      {
         l       = K - j;
         i0      = ( j - K > 0 ? j - K : 0 );

         for( i = i0, iaij = ((l+i0) SHIFT)+jaj; i < j; i++, iaij += (1 SHIFT) )
         {
            A[iaij  ] *= alpha;
#ifdef TCPLX
            A[iaij+1] *= alpha;
#endif
         }
         if( A[iaij  ] >= ATL_rzero ) A[iaij  ] += ATL_rone;
         else                         A[iaij  ] -= ATL_rone;
#ifdef TCPLX
         if( A[iaij+1] >= ATL_rzero ) A[iaij+1] += ATL_rone;
         else                         A[iaij+1] -= ATL_rone;
#endif
      }
   }
   else
   {
      for( j = N-1, jaj = (N-1)*lda2; j >= 0; j--, jaj -= lda2 )
      {
         if( A[jaj  ] >= ATL_rzero ) A[jaj  ] += ATL_rone;
         else                        A[jaj  ] -= ATL_rone;
#ifdef TCPLX
         if( A[jaj+1] >= ATL_rzero ) A[jaj+1] += ATL_rone;
         else                        A[jaj+1] -= ATL_rone;
#endif
         i1   = ( N - 1 > j + K ? j + K : N - 1 );
         for( i  = j+1, iaij = (1 SHIFT)+jaj; i <= i1; i++, iaij += (1 SHIFT) )
         {
            A[iaij  ] *= alpha;
#ifdef TCPLX
            A[iaij+1] *= alpha;
#endif
         }
      }
   }
}

void tpddom
(
   const enum ATLAS_UPLO      UPLO,
   const int                  N,
   TYPE                       * A
)
{
/*
 * Scale strictly lower (resp. upper) part of triangular packed matrix by 1 / N
 * to make it diagonally dominant.
 */
   int                        i, iaij, j;
   TYPE                       alpha;

   if( N <= 0 ) return;

   alpha = ATL_rone / (TYPE)(N);

   if( UPLO == AtlasUpper )
   {
      for( j = 0, iaij= 0; j < N; j++ )
      {
         for( i = 0; i < j; i++, iaij += (1 SHIFT) )
         {
            A[iaij  ] *= alpha;
#ifdef TCPLX
            A[iaij+1] *= alpha;
#endif
         }
         if( A[iaij  ] >= ATL_rzero ) A[iaij  ] += ATL_rone;
         else                         A[iaij  ] -= ATL_rone;
#ifdef TCPLX
         if( A[iaij+1] >= ATL_rzero ) A[iaij+1] += ATL_rone;
         else                         A[iaij+1] -= ATL_rone;
#endif
         iaij += (1 SHIFT);
      }
   }
   else
   {
      for( j = N-1, iaij = ((((N-1)*(N+2)) >> 1) SHIFT); j >= 0; j-- )
      {
         if( A[iaij  ] >= ATL_rzero ) A[iaij  ] += ATL_rone;
         else                         A[iaij  ] -= ATL_rone;
#ifdef TCPLX
         if( A[iaij+1] >= ATL_rzero ) A[iaij+1] += ATL_rone;
         else                         A[iaij+1] -= ATL_rone;
#endif
         iaij += (1 SHIFT);
         for( i = j+1; i < N; i++, iaij += (1 SHIFT) )
         {
            A[iaij  ] *= alpha;
#ifdef TCPLX
            A[iaij+1] *= alpha;
#endif
         }
         iaij -= ( ( N - j ) << (1 SHIFT) ) + (1 SHIFT);
      }
   }
}

void trddom
(
   const enum ATLAS_UPLO      UPLO,
   const int                  N,
   TYPE                       * A,
   const int                  LDA
)
{
/*
 * Scale strictly lower (resp. upper) part of triangular matrix by 1 / N
 * to make it diagonally dominant.
 */
   int                        i, iaij, j, jaj, lda2 = ( LDA SHIFT ),
                              ldap12 = (( LDA + 1 ) SHIFT);
   TYPE                       alpha;
 
   if( N <= 0 ) return;
 
   alpha = ATL_rone / (TYPE)(N);

   if( UPLO == AtlasUpper )
   {
      for( j = 0, jaj = 0; j < N; j++, jaj += lda2 )
      {
         for( i = 0, iaij = jaj; i < j; i++, iaij += (1 SHIFT) )
         {
            A[iaij  ] *= alpha;
#ifdef TCPLX
            A[iaij+1] *= alpha;
#endif
         }
         if( A[iaij  ] >= ATL_rzero ) A[iaij  ] += ATL_rone;
         else                         A[iaij  ] -= ATL_rone;
#ifdef TCPLX
         if( A[iaij+1] >= ATL_rzero ) A[iaij+1] += ATL_rone;
         else                         A[iaij+1] -= ATL_rone;
#endif
      }
   }
   else
   {
      for( j = N-1, jaj = (N-1)*ldap12; j >= 0; j--, jaj -= ldap12 )
      {
         if( A[jaj  ] >= ATL_rzero ) A[jaj  ] += ATL_rone;
         else                        A[jaj  ] -= ATL_rone;
#ifdef TCPLX
         if( A[jaj+1] >= ATL_rzero ) A[jaj+1] += ATL_rone;
         else                        A[jaj+1] -= ATL_rone;
#endif
         for( i = j+1, iaij = jaj+(1 SHIFT); i < N; i++, iaij += (1 SHIFT) )
         {
            A[iaij  ] *= alpha;
#ifdef TCPLX
            A[iaij+1] *= alpha;
#endif
         }
      }
   }
}
/*
 * =====================================================================
 * tst functions
 * =====================================================================
 */
TYPE gmvtst
(
   const int                  CACHESIZE,
   const enum LVL2_ROUT       ROUT,
   const int                  TEST, 
   const enum ATLAS_TRANS     TRANS,
   const int                  M,
   const int                  N, 
   const int                  KL,
   const int                  KU, 
   const SCALAR               ALPHA,
   const int                  LDA,
   const int                  INCX, 
   const SCALAR               BETA,
   const int                  INCY,
   const TYPE                 EPSILON,
   double                     * TTRUST0,
   double                     * TTEST0,
   double                     * MFTRUST0,
   double                     * MFTEST0
)
{
   double                     l2ret, ops, t0, ttest, ttrust;
   TYPE                       normA, normD, normY, normX, resid;
   TYPE                       * A  = NULL, * X = NULL, * Y = NULL, * Y0,
                              * YD = NULL, * x, * y;
   const int                  aincX = Mabs( INCX ), aincY = Mabs( INCY );
   int                        nY, nX, Aseed, Xseed, Yseed;

   *TTRUST0 = *TTEST0 = *MFTEST0 = *MFTRUST0 = 0.0;
   if( ( M == 0 ) || ( N == 0 ) ) { return( ATL_rzero ); }

@beginskip
   if( TRANS == AtlasNoTrans ) { mA = M; nA = N; }
   else                        { mA = N; nA = M; }
@endskip
   if( TRANS == AtlasNoTrans ) { nY = M; nX = N; }
   else                        { nY = N; nX = M; }

   ops = opbl2( ROUT, M, N, KL, KU );
/*
 * Allocate L2 cache space, A, X, Y and Y0
 */
   if (CACHESIZE > 0)
      l2ret = ATL_flushcache( CACHESIZE );
   A  = (TYPE *)malloc( ATL_MulBySize( LDA ) * N        );
   X  = (TYPE *)malloc( ATL_MulBySize( nX  ) * aincX     );
   Y  = (TYPE *)malloc( ATL_MulBySize( nY  ) * aincY * 2 );

   if( ( A == NULL ) || ( X == NULL ) || ( Y == NULL ) )
   {
      if (CACHESIZE > 0)
         l2ret  = ATL_flushcache( 0 );
      if( A  ) free( A  );
      if( X  ) free( X  );
      if( Y  ) free( Y  );
      return( ATL_rnone );
   }

   Y0 = Y + nY * ( aincY SHIFT );
/*
 * Generate random operands
 */
   Aseed = M * N + LDA;
   Xseed = nX  * aincX * 27 + 213;
   Yseed = nY  * aincY;

   if( ROUT == GBMV ) Mjoin( PATL, gegen )( KL+KU+1, N, A, LDA, Aseed );
   else               Mjoin( PATL, gegen )( M,      N, A, LDA, Aseed );
   Mjoin( PATL, gegen )( 1,  nX, X,  aincX, Xseed );
   Mjoin( PATL, gegen )( 1,  nY, Y,  aincY, Yseed );
   Mjoin( PATL, gegen )( 1,  nY, Y0, aincY, Yseed );
/*
 * Compute the norm of Y for later use in testing 
 */
   if( TEST )
   {
      normY = Mjoin( PATL, infnrm )( nY, Y, aincY );
      if( Mabs1( BETA ) > ATL_rone ) normY *= Mabs1( BETA  );
      if( normY == ATL_rzero ) normY = ATL_rone;
   }
   else { normY = ATL_rone; }
/*
 * Start cold cache timing operations for the trusted routine
 */
   x = X;  if( INCX < 0 ) x = X  + ( ( ( 1 - nX ) * INCX ) SHIFT );
   y = Y0; if( INCY < 0 ) y = Y0 + ( ( ( 1 - nY ) * INCY ) SHIFT );

   if( ROUT == GBMV )
   {
      if (CACHESIZE > 0)
         l2ret  = ATL_flushcache( -1 );
      t0     = time00();
      trusted_gbmv( TRANS, M, N, KL, KU, ALPHA, A, LDA, x, INCX, BETA, y,
                    INCY );
      ttrust = time00() - t0;
   }
   else
   {
      if (CACHESIZE > 0)
         l2ret  = ATL_flushcache( -1 );
      t0     = time00();
      trusted_gemv( TRANS, M, N, ALPHA, A, LDA, x, INCX, BETA, y, INCY );
      ttrust = time00() - t0;
   }
   if( ttrust > 0.0 )
   { *TTRUST0 = ttrust; *MFTRUST0 = ops / ( ttrust * MEGA ); }
/*
 * Start cold cache timing operations for the tested routine
 */
   x = X; if( INCX < 0 ) x = X + ( ( ( 1 - nX ) * INCX ) SHIFT );
   y = Y; if( INCY < 0 ) y = Y + ( ( ( 1 - nY ) * INCY ) SHIFT );

   if( ROUT == GBMV )
   {
      if (CACHESIZE > 0)
         l2ret = ATL_flushcache( -1 );
      t0    = time00();
      test_gbmv( TRANS, M, N, KL, KU, ALPHA, A, LDA, x, INCX, BETA, y, INCY );
      ttest = time00() - t0;
   }
   else
   {
      if (CACHESIZE > 0)
         l2ret = ATL_flushcache( -1 );
      t0    = time00();
      test_gemv( TRANS, M, N, ALPHA, A, LDA, x, INCX, BETA, y, INCY );
      ttest = time00() - t0;
   }
   if( ttest  > 0.0 )
   { *TTEST0  = ttest;  *MFTEST0  = ops / ( ttest  * MEGA ); }
/*
 * if timing only, I am done ... so leave.
 */
   if (CACHESIZE > 0)
      l2ret  = ATL_flushcache( 0 );

   if( !( TEST ) ) { free( A ); free( X ); free( Y ); return( ATL_rzero ); }
/*
 * else perform error check
 */
   if( ROUT == GBMV )
      normA = Mjoin( PATL, gbnrm1 )( M, N, KL, KU, A, LDA );
   else
      normA = Mjoin( PATL, genrm1 )( M, N,         A, LDA );
   if( normA == ATL_rzero ) normA = ATL_rone;

   free( A  );

   normX = Mjoin( PATL, infnrm )( nX, X, aincX );
   if( Mabs1( ALPHA ) > ATL_rone ) normX *= Mabs1( ALPHA );
   if( normX == ATL_rzero ) normX = ATL_rone;

   free( X );
/*
 * Ensure the difference of the output operands is relatively tiny enough
 */
   YD = (TYPE *)malloc( ATL_MulBySize( nY ) );
   if( YD == NULL ) { free( Y ); return( ATL_rnone ); }

   Mjoin( PATL, vdiff )( nY, Y, aincY, Y0, aincY, YD, 1 );

   normD = Mjoin( PATL, infnrm )( nY, YD, 1 );
   resid = normD / ( Mmax( normA, ATL_rone ) * Mmax( normX, ATL_rone ) *
                     Mmax( normY, ATL_rone ) * EPSILON * Mmax( M, N ) );

   if( ( resid > THRESH ) || ( resid != resid ) )
   {
      (void) fprintf( stderr, 
      "ERROR:  resid=%f, normD=%f, normA=%f, normX=%f, normY=%f, eps=%e\n",
      resid, normD, normA, normX, normY, EPSILON );
#ifdef ATLAS_DEBUG
      Mjoin( PATL, geprint )( "Y_trusted", 1, nY, Y0, aincY );
      Mjoin( PATL, geprint )( "Y_test",    1, nY, Y,  aincY );
#endif
   }

   free( Y  );
   free( YD );

   return( resid );
}

TYPE smvtst
(
   const int                  CACHESIZE,
   const enum LVL2_ROUT       ROUT,
   const int                  TEST, 
   const enum ATLAS_UPLO      UPLO,
   const int                  N, 
   const int                  K,
   const SCALAR               ALPHA,
   const int                  LDA,
   const int                  INCX, 
   const SCALAR               BETA,
   const int                  INCY,
   const TYPE                 EPSILON,
   double                     * TTRUST0,
   double                     * TTEST0,
   double                     * MFTRUST0,
   double                     * MFTEST0
)
{
   double                     l2ret, ops, t0, ttest, ttrust;
   TYPE                       normA, normD, normY, normX, resid;
   TYPE                       * A  = NULL, * X = NULL, * Y = NULL, * Y0,
                              * YD = NULL, * x, * y;
   const int                  aincX = Mabs( INCX ), aincY = Mabs( INCY );
   int                        lA, Aseed, Xseed, Yseed;

   *TTRUST0 = *TTEST0 = *MFTEST0 = *MFTRUST0 = 0.0;
   if( N == 0 ) { return( ATL_rzero ); }

   if( ROUT == SPMV ) lA = ( N * ( N + 1 ) ) >> 1;   /* ( ROUT == HPMV ) */
   else               lA = LDA * N;

   ops = opbl2( ROUT, N, N, K, K );
/*
 * Allocate L2 cache space, A, X, Y and Y0
 */
   if (CACHESIZE > 0)
      l2ret = ATL_flushcache( CACHESIZE );
   A  = (TYPE *)malloc( ATL_MulBySize( lA )              );
   X  = (TYPE *)malloc( ATL_MulBySize( N  ) * aincX      );
   Y  = (TYPE *)malloc( ATL_MulBySize( N  ) * aincY * 2  );

   if( ( A == NULL ) || ( X == NULL ) || ( Y == NULL ) )
   {
      if (CACHESIZE > 0)
         l2ret = ATL_flushcache( 0 );
      if( A ) free( A );
      if( X ) free( X );
      if( Y ) free( Y );
      return( ATL_rnone );
   }

   Y0 = Y + N * ( aincY SHIFT );
/*
 * Generate random operands
 */
   Aseed = N * N + LDA;
   Xseed = N * aincX * 27 + 213;
   Yseed = N * aincY;

   if(      ROUT == SBMV )       /* ( ROUT == HBMV ) */
      Mjoin( PATL, gegen )( K+1, N, A, LDA, Aseed );
   else if( ROUT == SPMV )       /* ( ROUT == HPMV ) */
      Mjoin( PATL, gegen )( lA,  1, A, lA,  Aseed );
   else /* if( ROUT == SYMV ) */ /* ( ROUT == HEMV ) */
      Mjoin( PATL, gegen )( N,   N, A, LDA, Aseed );

   Mjoin( PATL, gegen )( 1, N, X,  aincX, Xseed );
   Mjoin( PATL, gegen )( 1, N, Y,  aincY, Yseed );
   Mjoin( PATL, gegen )( 1, N, Y0, aincY, Yseed );
/*
 * Compute the norm of Y for later use in testing 
 */
   if( TEST )
   {
      normY = Mjoin( PATL, infnrm )( N, Y, aincY );
      if( Mabs1( BETA ) > ATL_rone ) normY *= Mabs1( BETA  );
      if( normY == ATL_rzero ) normY = ATL_rone;
   }
   else { normY = ATL_rone; } 
/*
 * Start cold cache timing operations for the trusted routine
 */
   x = X;  if( INCX < 0 ) x = X  + ( ( ( 1 - N ) * INCX ) SHIFT );
   y = Y0; if( INCY < 0 ) y = Y0 + ( ( ( 1 - N ) * INCY ) SHIFT );

   if(      ROUT == SBMV ) /* ( ROUT == HBMV ) */
   {
      if (CACHESIZE > 0)
         l2ret  = ATL_flushcache( -1 );
      t0     = time00();
      trusted_sbmv( UPLO, N, K, ALPHA, A, LDA, x, INCX, BETA, y, INCY );
      ttrust = time00() - t0;
   }
   else if( ROUT == SPMV ) /* ( ROUT == HPMV ) */
   {
      if (CACHESIZE > 0)
         l2ret  = ATL_flushcache( -1 );
      t0     = time00();
      trusted_spmv( UPLO, N,    ALPHA, A,      x, INCX, BETA, y, INCY );
      ttrust = time00() - t0;
   }
   else /* if( ROUT == SYMV ) */ /* ( ROUT == HEMV ) */
   {
      if (CACHESIZE > 0)
         l2ret  = ATL_flushcache( -1 );
      t0     = time00();
      trusted_symv( UPLO, N,    ALPHA, A, LDA, x, INCX, BETA, y, INCY );
      ttrust = time00() - t0;
   }
   if( ttrust > 0.0 )
   { *TTRUST0 = ttrust; *MFTRUST0 = ops / ( ttrust * MEGA ); }
/*
 * Start cold cache timing operations for the tested routine
 */
   x = X; if( INCX < 0 ) x = X + ( ( ( 1 - N ) * INCX ) SHIFT );
   y = Y; if( INCY < 0 ) y = Y + ( ( ( 1 - N ) * INCY ) SHIFT );

   if(      ROUT == SBMV ) /* ( ROUT == HBMV ) */
   {
      if (CACHESIZE > 0)
         l2ret = ATL_flushcache( -1 );
      t0    = time00();
      test_sbmv( UPLO, N, K, ALPHA, A, LDA, x, INCX, BETA, y, INCY );
      ttest = time00() - t0;
   }
   else if( ROUT == SPMV ) /* ( ROUT == HPMV ) */
   {
      if (CACHESIZE > 0)
         l2ret = ATL_flushcache( -1 );
      t0    = time00();
      test_spmv( UPLO, N,    ALPHA, A,      x, INCX, BETA, y, INCY );
      ttest = time00() - t0;
   }
   else /* if( ROUT == SYMV ) */ /* ( ROUT == HEMV ) */
   {
      if (CACHESIZE > 0)
         l2ret = ATL_flushcache( -1 );
      t0    = time00();
      test_symv( UPLO, N,    ALPHA, A, LDA, x, INCX, BETA, y, INCY );
      ttest = time00() - t0;
   }
   if( ttest  > 0.0 )
   { *TTEST0  = ttest;  *MFTEST0  = ops / ( ttest  * MEGA ); }
/*
 * if timing only, I am done ... so leave.
 */
   if (CACHESIZE > 0)
      l2ret  = ATL_flushcache( 0 );

   if( !( TEST ) ) { free( A ); free( X ); free( Y ); return( ATL_rzero ); }
/*
 * else perform error check
 */
#ifdef TREAL
   if(      ROUT == SBMV ) normA = Mjoin( PATL, sbnrm )( UPLO, N, K, A, LDA );
   else if( ROUT == SPMV ) normA = Mjoin( PATL, spnrm )( UPLO, N,    A      );
   else                    normA = Mjoin( PATL, synrm )( UPLO, N,    A, LDA );
#else
   if(      ROUT == SBMV ) normA = Mjoin( PATL, hbnrm )( UPLO, N, K, A, LDA );
   else if( ROUT == SPMV ) normA = Mjoin( PATL, hpnrm )( UPLO, N,    A      );
   else                    normA = Mjoin( PATL, henrm )( UPLO, N,    A, LDA );
#endif
   if( normA == ATL_rzero ) normA = ATL_rone;

   free( A  );

   normX = Mjoin( PATL, infnrm )( N, X, aincX );
   if( Mabs1( ALPHA ) >  ATL_rone ) normX *= Mabs1( ALPHA );
   if( normX == ATL_rzero ) normX = ATL_rone;

   free( X  );
/*
 * Ensure the difference of the output operands is relatively tiny enough
 */
   YD = (TYPE *)malloc( ATL_MulBySize( N ) );
   if( YD == NULL ) { free( Y ); return( ATL_rnone ); }

   Mjoin( PATL, vdiff )( N, Y, aincY, Y0, aincY, YD, 1 );

   normD = Mjoin( PATL, infnrm )( N, YD, 1 );
   resid = normD / ( Mmax( normA, ATL_rone ) * Mmax( normX, ATL_rone ) *
                     Mmax( normY, ATL_rone ) * EPSILON * (TYPE)(N) );

   if( ( resid > THRESH ) || ( resid != resid ) )
   {
      (void) fprintf( stderr, 
      "ERROR:  resid=%f, normD=%f, normA=%f, normX=%f, normY=%f, eps=%e\n",
      resid, normD, normA, normX, normY, EPSILON );
#ifdef ATLAS_DEBUG
      Mjoin( PATL, geprint )( "Y_trusted", 1, N, Y0, aincY );
      Mjoin( PATL, geprint )( "Y_test",    1, N, Y,  aincY );
#endif
   }

   free( Y  );
   free( YD );

   return( resid );
}

TYPE tmvtst
(
   const int                  CACHESIZE,
   const enum LVL2_ROUT       ROUT,
   const int                  TEST,
   const enum ATLAS_UPLO      UPLO,
   const enum ATLAS_TRANS     TRANS, 
   const enum ATLAS_DIAG      DIAG,
   const int                  N,
   const int                  K,
   const int                  LDA,
   const int                  INCX,
   const TYPE                 EPSILON,
   double                     * TTRUST0,
   double                     * TTEST0, 
   double                     * MFTRUST0,
   double                     * MFTEST0
)
{
   double                     l2ret, ops, t0, ttest, ttrust;
   TYPE                       normA, normD, normX, resid;
   TYPE                       * A = NULL, * X = NULL, * X0, * XD = NULL, * x;
   const int                  aincX = Mabs( INCX );
   int                        lA, Aseed, Xseed;

   *TTRUST0 = *TTEST0 = *MFTEST0 = *MFTRUST0 = 0.0;
   if( N == 0 ) { return( ATL_rzero ); }

   if( ROUT == TPMV ) lA = ( N * ( N + 1 ) ) >> 1;
   else               lA = LDA * N;

   ops = opbl2( ROUT, N, N, K, K );
/*
 * Allocate L2 cache space, A, X and X0
 */
   if (CACHESIZE > 0)
      l2ret = ATL_flushcache( CACHESIZE );
   A  = (TYPE *)malloc( ATL_MulBySize( lA )             );
   X  = (TYPE *)malloc( ATL_MulBySize( N  ) * aincX * 2 );

   if( ( A == NULL ) || ( X == NULL ) )
   {
      if (CACHESIZE > 0)
         l2ret = ATL_flushcache( 0 );
      if( A ) free( A );
      if( X ) free( X );
      return( ATL_rnone );
   }
   X0 = X + N * ( aincX SHIFT );
/*
 * Generate random operands
 */
   Aseed = N * N + LDA;
   Xseed = N * aincX * 27 + 213;

   if(      ROUT == TBMV ) Mjoin( PATL, gegen )( K+1, N, A,  LDA, Aseed );
   else if( ROUT == TPMV ) Mjoin( PATL, gegen )( lA,  1, A,  lA,  Aseed );
   else                    Mjoin( PATL, gegen )( N,   N, A,  LDA, Aseed );
   Mjoin( PATL, gegen )( 1, N, X,  aincX, Xseed );
   Mjoin( PATL, gegen )( 1, N, X0, aincX, Xseed );
/*
 * Compute the norm of X for later use in testing
 */
   if( TEST )
   {
      normX = Mjoin( PATL, infnrm )( N, X, aincX );
      if( normX == ATL_rzero ) normX = ATL_rone;
   }
   else { normX = ATL_rone; } 
/*
 * Start cold cache timing operations for the trusted routine
 */
   x = X0; if( INCX < 0 ) x = X0 + ( ( ( 1 - N ) * INCX ) SHIFT );

   if(      ROUT == TBMV )
   {
      if (CACHESIZE > 0)
         l2ret  = ATL_flushcache( -1 );
      t0     = time00();
      trusted_tbmv( UPLO, TRANS, DIAG, N, K, A, LDA, x, INCX );
      ttrust = time00() - t0;
   }
   else if( ROUT == TPMV )
   {
      if (CACHESIZE > 0)
         l2ret  = ATL_flushcache( -1 );
      t0     = time00();
      trusted_tpmv( UPLO, TRANS, DIAG, N,    A,      x, INCX );
      ttrust = time00() - t0;
   }
   else /* if( ROUT == TRMV ) */
   {
      if (CACHESIZE > 0)
         l2ret  = ATL_flushcache( -1 );
      t0     = time00();
      trusted_trmv( UPLO, TRANS, DIAG, N,    A, LDA, x, INCX );
      ttrust = time00() - t0;
   }
   if( ttrust > 0.0 )
   { *TTRUST0 = ttrust; *MFTRUST0 = ops / ( ttrust * MEGA ); }
/*
 * Start cold cache timing operations for the tested routine
 */
   x = X;  if( INCX < 0 ) x = X  + ( ( ( 1 - N ) * INCX ) SHIFT );

   if(      ROUT == TBMV )
   {
      if (CACHESIZE > 0)
         l2ret = ATL_flushcache( -1 );
      t0    = time00();
      test_tbmv( UPLO, TRANS, DIAG, N, K, A, LDA, x, INCX );
      ttest = time00() - t0;
   }
   else if( ROUT == TPMV )
   {
      if (CACHESIZE > 0)
         l2ret = ATL_flushcache( -1 );
      t0    = time00();
      test_tpmv( UPLO, TRANS, DIAG, N,    A,      x, INCX );
      ttest = time00() - t0;
   }
   else /* if( ROUT == TRMV ) */
   {
      if (CACHESIZE > 0)
         l2ret = ATL_flushcache( -1 );
      t0    = time00();
      test_trmv( UPLO, TRANS, DIAG, N,    A, LDA, x, INCX );
      ttest = time00() - t0;
   }
   if( ttest > 0.0 )
   { *TTEST0  = ttest;  *MFTEST0  = ops / ( ttest  * MEGA ); }
/*
 * if timing only, I am done ... so leave.
 */
   if (CACHESIZE > 0)
      l2ret  = ATL_flushcache( 0 );

   if( !( TEST ) ) { free( A ); free( X ); return( ATL_rzero ); }
/*
 * else perform error check
 */
   if(      ROUT == TBMV )
      normA = Mjoin( PATL, tbnrm1 )( UPLO, DIAG, N, K, A, LDA );
   else if( ROUT == TPMV )
      normA = Mjoin( PATL, tpnrm1 )( UPLO, DIAG, N,    A      );
   else /* if( ROUT == TRMV ) */
      normA = Mjoin( PATL, trnrm1 )( UPLO, DIAG, N,    A, LDA );
   if( normA == ATL_rzero ) normA = ATL_rone; 

   free( A  );
/*
 * Ensure the difference of the output operands is relatively tiny enough
 */
   XD = (TYPE * )malloc( ATL_MulBySize( N ) );
   if( XD == NULL ) { free( X ); return( -1 ); }

   Mjoin( PATL, vdiff )( N, X, aincX, X0, aincX, XD, 1 );
   normD = Mjoin( PATL, infnrm )( N, XD, 1 );
   resid = normD / ( Mmax( normA, ATL_rone ) * Mmax( normX, ATL_rone ) *
                     EPSILON * N );

   if( ( resid > THRESH ) || ( resid != resid ) )
   {
      (void) fprintf(stderr, 
      "ERROR:   resid=%f, normD=%f, normA=%f, normX=%f, eps=%e\n",
      resid, normD, normA, normX, EPSILON );
#ifdef ATLAS_DEBUG
      Mjoin( PATL, geprint )( "X_trusted", 1, N, X0, aincX );
      Mjoin( PATL, geprint )( "X_test",    1, N, X,  aincX );
#endif
   }

   free( X  );
   free( XD );

   return( resid );
}

TYPE tsvtst
(
   const int                  CACHESIZE,
   const enum LVL2_ROUT       ROUT,
   const int                  TEST,
   const enum ATLAS_UPLO      UPLO,
   const enum ATLAS_TRANS     TRANS, 
   const enum ATLAS_DIAG      DIAG,
   const int                  N,
   const int                  K,
   const int                  LDA,
   const int                  INCX,
   const TYPE                 EPSILON,
   double                     * TTRUST0,
   double                     * TTEST0, 
   double                     * MFTRUST0,
   double                     * MFTEST0
)
{
   double                     l2ret, ops, t0, ttest, ttrust;
   TYPE                       normA, normD, normX, resid;
   TYPE                       * A = NULL, * X = NULL, * X0, * XD = NULL, * x;
   const int                  aincX = Mabs( INCX );
   int                        lA, Aseed, Xseed;

   *TTRUST0 = *TTEST0 = *MFTEST0 = *MFTRUST0 = 0.0;
   if( N == 0 ) { return( ATL_rzero ); }

   if( ROUT == TPSV ) lA = ( N * ( N + 1 ) ) >> 1;
   else               lA = LDA * N;

   ops = opbl2( ROUT, N, N, K, K );
/*
 * Allocate L2 cache space, A, X and X0
 */
   if (CACHESIZE > 0)
      l2ret = ATL_flushcache( CACHESIZE );
   A  = (TYPE   *)malloc( ATL_MulBySize( lA )             );
   X  = (TYPE   *)malloc( ATL_MulBySize( N  ) * aincX * 2 );

   if( ( A == NULL ) || ( X == NULL ) )
   {
      if (CACHESIZE > 0)
         l2ret = ATL_flushcache( 0 );
      if( A ) free( A );
      if( X ) free( X );
      return( ATL_rnone );
   }
   X0 = X + N * ( aincX SHIFT );
/*
 * Generate random operands
 */
   Aseed = N * N + LDA;
   Xseed = N * aincX * 27 + 213;

   if(      ROUT == TBSV )
   {
      Mjoin( PATL, gegen )( K+1, N, A, LDA, Aseed );
      tbddom( UPLO, N, K, A, LDA );
   }
   else if( ROUT == TPSV )
   {
      Mjoin( PATL, gegen )( lA,  1, A, lA,  Aseed );
      tpddom( UPLO, N,    A      );
   } 
   else
   {
      Mjoin( PATL, gegen )( N,   N, A, LDA, Aseed );
      trddom( UPLO, N,    A, LDA );
   }
   Mjoin( PATL, gegen )( 1, N, X,  aincX, Xseed );
   Mjoin( PATL, gegen )( 1, N, X0, aincX, Xseed );
/*
 * Compute the norm of X for later use in testing
 */
   if( TEST )
   {
      normX = Mjoin( PATL, infnrm )( N, X, aincX );
      if( normX == ATL_rzero ) normX = ATL_rone;
   }
   else { normX = ATL_rone; }
/*
 * Start cold cache timing operations for the trusted routine
 */
   x = X0; if( INCX < 0 ) x = X0 + ( ( ( 1 - N ) * INCX ) SHIFT );

   if(      ROUT == TBSV )
   {
      if (CACHESIZE > 0)
         l2ret  = ATL_flushcache( -1 );
      t0     = time00();
      trusted_tbsv( UPLO, TRANS, DIAG, N, K, A, LDA, x, INCX );
      ttrust = time00() - t0;
   }
   else if( ROUT == TPSV )
   {
      if (CACHESIZE > 0)
         l2ret  = ATL_flushcache( -1 );
      t0     = time00();
      trusted_tpsv( UPLO, TRANS, DIAG, N,    A,      x, INCX );
      ttrust = time00() - t0;
   }
   else /* if( ROUT == TRSV ) */
   {
      if (CACHESIZE > 0)
         l2ret  = ATL_flushcache( -1 );
      t0     = time00();
      trusted_trsv( UPLO, TRANS, DIAG, N,    A, LDA, x, INCX );
      ttrust = time00() - t0;
   }
   if( ttrust > 0.0 )
   { *TTRUST0 = ttrust; *MFTRUST0 = ops / ( ttrust * MEGA ); }
/*
 * Start cold cache timing operations for the tested routine
 */
   x = X;  if( INCX < 0 ) x = X  + ( ( ( 1 - N ) * INCX ) SHIFT );

   if(      ROUT == TBSV )
   {
      if (CACHESIZE > 0)
         l2ret = ATL_flushcache( -1 );
      t0    = time00();
      test_tbsv( UPLO, TRANS, DIAG, N, K, A, LDA, x, INCX );
      ttest = time00() - t0;
   }
   else if( ROUT == TPSV )
   {
      if (CACHESIZE > 0)
         l2ret = ATL_flushcache( -1 );
      t0    = time00();
      test_tpsv( UPLO, TRANS, DIAG, N,    A,      x, INCX );
      ttest = time00() - t0;
   }
   else /* if( ROUT == TRSV ) */
   {
      if (CACHESIZE > 0)
         l2ret = ATL_flushcache( -1 );
      t0    = time00();
      test_trsv( UPLO, TRANS, DIAG, N,    A, LDA, x, INCX );
      ttest = time00() - t0;
   }
   if( ttest > 0.0 )
   { *TTEST0  = ttest;  *MFTEST0  = ops / ( ttest  * MEGA ); }
/*
 * if timing only, I am done ... so leave.
 */
   if (CACHESIZE > 0)
      l2ret  = ATL_flushcache( 0 );

   if( !( TEST ) ) { free( A ); free( X ); return( ATL_rzero ); }
/*
 * else perform error check
 */
   if(      ROUT == TBSV )
      normA = Mjoin( PATL, tbnrm1 )( UPLO, DIAG, N, K, A, LDA );
   else if( ROUT == TPSV )
      normA = Mjoin( PATL, tpnrm1 )( UPLO, DIAG, N,    A      );
   else /* if( ROUT == TRSV ) */
      normA = Mjoin( PATL, trnrm1 )( UPLO, DIAG, N,    A, LDA );
   if( normA == ATL_rzero ) normA = ATL_rone; 

   free( A  );
/*
 * Ensure the difference of the output operands is relatively tiny enough
 */
   XD = (TYPE * )malloc( ATL_MulBySize( N ) );
   if( XD == NULL ) { free( X ); return( -1 ); }

   Mjoin( PATL, vdiff )( N, X, aincX, X0, aincX, XD, 1 );
   normD = Mjoin( PATL, infnrm )( N, XD, 1 );
   resid = normD / ( Mmax( normA, ATL_rone ) * Mmax( normX, ATL_rone ) *
                     EPSILON * N );

   if( ( resid > THRESH ) || ( resid != resid ) )
   {
      (void) fprintf(stderr, 
      "ERROR:   resid=%f, normD=%f, normA=%f, normX=%f, eps=%e\n",
      resid, normD, normA, normX, EPSILON );
#ifdef ATLAS_DEBUG
      Mjoin( PATL, geprint )( "X_trusted", 1, N, X0, aincX );
      Mjoin( PATL, geprint )( "X_test",    1, N, X,  aincX );
#endif
   }

   free( X  );
   free( XD );

   return( resid );
}

@define rr @@
@define rr @2@
@whiledef rt r1 r2
   @addkeys RANK=@(rt)
TYPE g@(rt)tst
(
   const int                  CACHESIZE,
   const enum LVL2_ROUT       ROUT,
   const int                  TEST,
   const int                  M,
   const int                  N,
   const SCALAR               ALPHA,
   const int                  INCX,
   const int                  INCY,
@RANK R2
   const SCALAR               BETA,
   const int                  INCW,
   const int                  INCZ,
@RANK !
   const int                  LDA,
   const TYPE                 EPSILON,
   double                     * TTRUST0,
   double                     * TTEST0,
   double                     * MFTRUST0,
   double                     * MFTEST0
)
{
   double                     l2ret, ops, t0, ttest, ttrust;
   TYPE                       normA, normD, normY, normX, resid;
   TYPE                       * A = NULL, * A0, * X = NULL, * Y = NULL, * x,
                              * y;
@RANK R2
   TYPE *W, *Z, *w, *z;
   const int aincW = Mabs(INCW), aincZ = Mabs(INCZ);
   int Wseed, Zseed;
@RANK !
   const int                  aincX = Mabs( INCX ), aincY = Mabs( INCY );
   int                        Aseed, Xseed, Yseed;

   *TTRUST0 = *TTEST0 = *MFTEST0 = *MFTRUST0 = 0.0;
   if( ( M == 0 ) || ( N == 0 ) ) { return( ATL_rzero ); }

   ops = opbl2( ROUT, M, N, 0, 0 ); 
/*
 * Allocate L2 cache space, A, A0, X and Y
 */
   if (CACHESIZE > 0)
      l2ret = ATL_flushcache( CACHESIZE );
   A  = (TYPE *)malloc( ATL_MulBySize( LDA ) * N * 2 );
   X  = (TYPE *)malloc( ATL_MulBySize( M   ) * aincX );
   Y  = (TYPE *)malloc( ATL_MulBySize( N   ) * aincY );
@RANK R2
   W  = (TYPE *)malloc( ATL_MulBySize( M   ) * aincW );
   Z  = (TYPE *)malloc( ATL_MulBySize( N   ) * aincZ );
@RANK !
 
@RANK R2
   if(!A || !X || !Y || !W || !Z)
@RANK R1
   if( ( A == NULL ) || ( X == NULL ) || ( Y == NULL ) )
@RANK !
   {
      if (CACHESIZE > 0)
         l2ret = ATL_flushcache( 0 );
      if( A ) free( A );
      if( X ) free( X );
      if( Y ) free( Y );
@RANK R2
      if( W ) free( W );
      if( Z ) free( Z );
@RANK !
      return( ATL_rnone );
   }

   A0 = A + LDA * ( N SHIFT );
/*
 * Generate random operands
 */
   Aseed = M * N + LDA;
   Xseed = M * aincX * 27 + 213;
   Yseed = N * aincY;

   Mjoin( PATL, gegen )( M, N, A,  LDA,   Aseed );
   Mjoin( PATL, gegen )( M, N, A0, LDA,   Aseed );
   Mjoin( PATL, gegen )( 1, M, X,  aincX, Xseed );
   Mjoin( PATL, gegen )( 1, N, Y,  aincY, Yseed );
@RANK R2
   Wseed = 0x0F83888| Xseed;
   Zseed = 0xF2994732 | Yseed;
   Mjoin( PATL, gegen )( 1, M, W,  aincW, Wseed );
   Mjoin( PATL, gegen )( 1, N, Z,  aincZ, Zseed );
@RANK !
/*
 * Compute the norm of A for later use in testing
 */
   if( TEST )
   {
      normA = Mjoin( PATL, genrm1 )( M, N, A, LDA );
      if( Mabs1( ALPHA ) > ATL_rone ) normA *= Mabs1( ALPHA );
@RANK R2 `      if( Mabs1( BETA  ) > ATL_rone ) normA *= Mabs1( BETA  );`
      if( normA == ATL_rzero ) normA = ATL_rone;
   }
   else { normA = ATL_rone; }
/*
 * Start cold cache timing operations for the trusted routine
 */
   x = X; if( INCX < 0 ) x = X + ( ( ( 1 - M ) * INCX ) SHIFT );
   y = Y; if( INCY < 0 ) y = Y + ( ( ( 1 - N ) * INCY ) SHIFT );
@RANK R2
   w = W; if( INCW < 0 ) w = W + ( ( ( 1 - M ) * INCW ) SHIFT );
   z = Z; if( INCZ < 0 ) z = Z + ( ( ( 1 - N ) * INCZ ) SHIFT );
@RANK !

   if( ROUT == GER@(rr)C ) /* ( ROUT == GER ) */
   {
      if (CACHESIZE > 0)
         l2ret  = ATL_flushcache( -1 );
      t0     = time00();
@RANK R1
      trusted_gerc( M, N, ALPHA, x, INCX, y, INCY, A0, LDA );
@RANK R2
      trusted_ger2c( M, N, ALPHA, x, INCX, y, INCY, BETA, w, INCW, 
                     z, INCZ, A0, LDA );
@RANK !
      ttrust = time00() - t0;
   }
   else /* if ( ROUT == GERU ) */ /* ( ROUT == GER  ) */
   {
      if (CACHESIZE > 0)
         l2ret  = ATL_flushcache( -1 );
      t0     = time00();
@RANK R1
      trusted_geru( M, N, ALPHA, x, INCX, y, INCY, A0, LDA );
@RANK R2
      trusted_ger2u( M, N, ALPHA, x, INCX, y, INCY, BETA, w, INCW, 
                     z, INCZ, A0, LDA );
@RANK !
      ttrust = time00() - t0;
   }
   if( ttrust > 0.0 )
   { *TTRUST0 = ttrust; *MFTRUST0 = ops / ( ttrust * MEGA ); }
/*
 * Start cold cache timing operations for the tested routine
 */
   x = X; if( INCX < 0 ) x = X + ( ( ( 1 - M ) * INCX ) SHIFT );
   y = Y; if( INCY < 0 ) y = Y + ( ( ( 1 - N ) * INCY ) SHIFT );
@RANK R2
   w = W; if( INCW < 0 ) w = W + ( ( ( 1 - M ) * INCW ) SHIFT );
   z = Z; if( INCZ < 0 ) z = Z + ( ( ( 1 - N ) * INCZ ) SHIFT );
@RANK !

   if( ROUT == GER@(rr)C ) /* ( ROUT == GER ) */
   {
      if (CACHESIZE > 0)
         l2ret = ATL_flushcache( -1 );
      t0    = time00();
@RANK R1
      test_gerc( M, N, ALPHA, x, INCX, y, INCY, A, LDA );
@RANK R2
      test_ger2c( M, N, ALPHA, x, INCX, y, INCY, BETA, w, INCW, 
                     z, INCZ, A, LDA );
@RANK !
      ttest = time00() - t0;
   }
   else /* if ( ROUT == GERU ) */ /* ( ROUT == GER  ) */
   {
      if (CACHESIZE > 0)
         l2ret = ATL_flushcache( -1 );
      t0    = time00();
@RANK R1
      test_geru( M, N, ALPHA, x, INCX, y, INCY, A, LDA );
@RANK R2
      test_ger2u( M, N, ALPHA, x, INCX, y, INCY, BETA, w, INCW, 
                  z, INCZ, A, LDA );
@RANK !
      ttest = time00() - t0;
   }
   if( ttest  > 0.0 )
   { *TTEST0  = ttest;  *MFTEST0  = ops / ( ttest  * MEGA ); }
/*
 * if timing only, I am done ... so leave.
 */
   if (CACHESIZE > 0)
      l2ret  = ATL_flushcache( 0 );
 
   if( !( TEST ) ) { free( A ); free( X ); free( Y ); return( ATL_rzero ); }
/*
 * else perform error check
 */
   normX = Mjoin( PATL, infnrm )( M, X, aincX );
   if( normX == ATL_rzero ) normX = ATL_rone;
   free( X  );

   normY = Mjoin( PATL, infnrm )( N, Y, aincY );
   if( normY == ATL_rzero ) normY = ATL_rone;
   free( Y  );
/*
 * Ensure the difference of the output operands is relatively tiny enough
 */
   normD = Mjoin( PATL, gediffnrm1 )( M, N, A, LDA, A0, LDA );
   resid = normD / ( Mmax( normA, ATL_rone ) * Mmax( normX, ATL_rone ) *
                     Mmax( normY, ATL_rone ) * EPSILON * Mmax( M, N ) );

   if( ( resid > THRESH ) || ( resid != resid ) )
   {
      (void) fprintf( stderr, 
      "ERROR:   resid=%f, normD=%f, normA=%f, normX=%f, normY=%f, eps=%e\n",
      resid, normD, normA, normX, normY, EPSILON );
#ifdef ATLAS_DEBUG
      Mjoin( PATL, geprint )( "A_trusted", M, N, A0, LDA );
      Mjoin( PATL, geprint )( "A_test",    M, N, A,  LDA );
#endif
   }

   free( A  );

   return( resid );
}
   @undef rr
   @killkeys RANK
@endwhile

TYPE sr1tst
(
   const int                  CACHESIZE,
   const enum LVL2_ROUT       ROUT,
   const int                  TEST,
   const enum ATLAS_UPLO      UPLO,
   const int                  N,
   const TYPE                 ALPHA,
   const int                  INCX,
   const int                  LDA,
   const TYPE                 EPSILON,
   double                     * TTRUST0,
   double                     * TTEST0,
   double                     * MFTRUST0,
   double                     * MFTEST0
)
{
   double                     l2ret, ops, t0, ttest, ttrust;
   TYPE                       normA, normD, normX, resid;
   TYPE                       * A = NULL, * A0, * X = NULL, * x;
   const int                  aincX = Mabs( INCX );
   int                        lA, Aseed, Xseed;

   *TTRUST0 = *TTEST0 = *MFTEST0 = *MFTRUST0 = 0.0;
   if( N == 0 ) { return( ATL_rzero ); }

   if( ROUT == SPR ) lA = ( N * ( N + 1 ) ) >> 1; /* ( ROUT == HER ) */
   else              lA = LDA * N;

   ops = opbl2( ROUT, N, N, 0, 0 ); 
/*
 * Allocate L2 cache space, A, A0 and X
 */
   if (CACHESIZE > 0)
      l2ret = ATL_flushcache( CACHESIZE );
   A  = (TYPE *)malloc( ATL_MulBySize( lA ) * 2     );
   X  = (TYPE *)malloc( ATL_MulBySize( N  ) * aincX );
 
   if( ( A == NULL ) || ( X == NULL ) )
   {
      if (CACHESIZE > 0)
         l2ret = ATL_flushcache( 0 );
      if( A ) free( A );
      if( X ) free( X );
      return( ATL_rnone );
   }

   A0 = A + ( lA SHIFT );
/*
 * Generate random operands
 */
   Aseed = N * N + LDA;
   Xseed = N * aincX * 27 + 213;

   if(      ROUT == SPR ) /* ( ROUT == HPR ) */
   {
      Mjoin( PATL, gegen )( lA, 1, A,  lA,  Aseed );
      Mjoin( PATL, gegen )( lA, 1, A0, lA,  Aseed );
   }
   else /* if( ROUT == SYR ) */ /* ( ROUT == HER ) */ 
   {
      Mjoin( PATL, gegen )( N,  N, A,  LDA, Aseed );
      Mjoin( PATL, gegen )( N,  N, A0, LDA, Aseed );
   }
   Mjoin( PATL, gegen )( 1, N, X,  aincX, Xseed );
/*
 * Compute the norm of A for later use in testing
 */
   if( TEST )
   {
#ifdef TREAL
      if(      ROUT == SPR )
         normA = Mjoin( PATL, spnrm )( UPLO, N, A      );
      else /* if( ROUT == SYR ) */
         normA = Mjoin( PATL, synrm )( UPLO, N, A, LDA );
#else
      if(      ROUT == SPR )
         normA = Mjoin( PATL, hpnrm )( UPLO, N, A      );
      else /* if( ROUT == SYR ) */
         normA = Mjoin( PATL, henrm )( UPLO, N, A, LDA );
#endif
      if( Mabs( ALPHA ) > ATL_rone ) normA *= Mabs( ALPHA );
      if( normA == ATL_rzero ) normA = ATL_rone;
   }
   else { normA = ATL_rone; }
/*
 * Start cold cache timing operations for the trusted routine
 */
   x = X; if( INCX < 0 ) x = X + ( ( ( 1 - N ) * INCX ) SHIFT );

   if( ROUT == SPR ) /* ( ROUT == HPR ) */
   {
      if (CACHESIZE > 0)
         l2ret  = ATL_flushcache( -1 );
      t0     = time00();
      trusted_spr( UPLO, N, ALPHA,  x, INCX, A0      );
      ttrust = time00() - t0;
   }
   else /* if( ROUT == SYR ) */ /* ( ROUT == HER ) */
   {
      if (CACHESIZE > 0)
         l2ret  = ATL_flushcache( -1 );
      t0     = time00();
      trusted_syr( UPLO, N, ALPHA,  x, INCX, A0, LDA );
      ttrust = time00() - t0;
   }
   if( ttrust > 0.0 )
   { *TTRUST0 = ttrust; *MFTRUST0 = ops / ( ttrust * MEGA ); }
/*
 * Start cold cache timing operations for the tested routine
 */
   x = X; if( INCX < 0 ) x = X + ( ( ( 1 - N ) * INCX ) SHIFT );

   if( ROUT == SPR ) /* ( ROUT == HPR ) */
   {
      if (CACHESIZE > 0)
         l2ret = ATL_flushcache( -1 );
      t0    = time00();
      test_spr( UPLO, N, ALPHA,  x, INCX, A      );
      ttest = time00() - t0;
   }
   else /* if( ROUT == SYR ) */ /* ( ROUT == HER ) */
   {
      if (CACHESIZE > 0)
         l2ret = ATL_flushcache( -1 );
      t0    = time00();
      test_syr( UPLO, N, ALPHA,  x, INCX, A, LDA );
      ttest = time00() - t0;
   }
   if( ttest  > 0.0 )
   { *TTEST0  = ttest;  *MFTEST0  = ops / ( ttest  * MEGA ); }
/*
 * if timing only, I am done ... so leave.
 */
   if (CACHESIZE > 0)
      l2ret  = ATL_flushcache( 0 );
 
   if( !( TEST ) ) { free( A ); free( X ); return( ATL_rzero ); }
/*
 * else perform error check
 */
   normX = Mjoin( PATL, infnrm )( N, X, aincX );
   if( normX == ATL_rzero ) normX = ATL_rone;
   free( X  );
/*
 * Ensure the difference of the output operands is relatively tiny enough
 */
   if(      ROUT == SPR ) /* ( ROUT == HPR ) */
      normD = Mjoin( PATL, gediffnrm1 )( lA, 1, A, lA,  A0, lA  );
   else /* if( ROUT == SYR ) */ /* ( ROUT == HER ) */
      normD = Mjoin( PATL, gediffnrm1 )( N,  N, A, LDA, A0, LDA );

   resid = normD / ( Mmax( normA, ATL_rone ) * Mmax( normX, ATL_rone ) *
                     EPSILON * N );

   if( ( resid > THRESH ) || ( resid != resid ) )
   {
      (void) fprintf( stderr, 
      "ERROR:    resid=%f, normD=%f, normA=%f, normX=%f, eps=%e\n",
      resid, normD, normA, normX, EPSILON );
#ifdef ATLAS_DEBUG
      if(      ROUT == SPR )
      {
         Mjoin( PATL, geprint )( "A_trusted", lA, 1, A0, lA  );
         Mjoin( PATL, geprint )( "A_test",    lA, 1, A,  lA  );
      }
      else /* if( ROUT == SYR ) */
      {
         Mjoin( PATL, geprint )( "A_trusted", N,  N, A0, LDA );
         Mjoin( PATL, geprint )( "A_test",    N,  N, A,  LDA );
      }
#endif
   }

   free( A  );

   return( resid );
}

TYPE sr2tst
(
   const int                  CACHESIZE,
   const enum LVL2_ROUT       ROUT,
   const int                  TEST,
   const enum ATLAS_UPLO      UPLO,
   const int                  N,
   const SCALAR               ALPHA,
   const int                  INCX,
   const int                  INCY,
   const int                  LDA,
   const TYPE                 EPSILON,
   double                     * TTRUST0,
   double                     * TTEST0,
   double                     * MFTRUST0,
   double                     * MFTEST0
)
{
   double                     l2ret, ops, t0, ttest, ttrust;
   TYPE                       normA, normD, normY, normX, resid;
   TYPE                       * A = NULL, * A0, * X = NULL, * Y = NULL,
                              * x, * y;
   const int                  aincX = Mabs( INCX ), aincY = Mabs( INCY );
   int                        lA, Aseed, Xseed, Yseed;

   *TTRUST0 = *TTEST0 = *MFTEST0 = *MFTRUST0 = 0.0;
   if( N == 0 ) { return( ATL_rzero ); }

   if( ROUT == SPR2 ) lA = ( N * ( N + 1 ) ) >> 1;
   else               lA = LDA * N;

   ops = opbl2( ROUT, N, N, 0, 0 ); 
/*
 * Allocate L2 cache space, A, A0, X and Y
 */
   if (CACHESIZE > 0)
      l2ret = ATL_flushcache( CACHESIZE );
   A = (TYPE *)malloc( ATL_MulBySize( lA ) * 2     );
   X = (TYPE *)malloc( ATL_MulBySize( N  ) * aincX );
   Y = (TYPE *)malloc( ATL_MulBySize( N  ) * aincY );
 
   if( ( A == NULL ) || ( X == NULL ) || ( Y == NULL ) )
   {
      if (CACHESIZE > 0)
         l2ret = ATL_flushcache( 0 );
      if( A ) free( A );
      if( X ) free( X );
      if( Y ) free( Y );
      return( ATL_rnone );
   }

   A0 = A + ( lA SHIFT );
/*
 * Generate random operands
 */
   Aseed = N * N + LDA;
   Xseed = N * aincX * 27 + 213;
   Yseed = N * aincY;

   if(      ROUT == SPR2 )
   {
      Mjoin( PATL, gegen )( lA, 1, A,  lA,  Aseed );
      Mjoin( PATL, gegen )( lA, 1, A0, lA,  Aseed );
   }
   else /* if( ROUT == SYR2 ) */
   {
      Mjoin( PATL, gegen )( N,  N, A,  LDA, Aseed );
      Mjoin( PATL, gegen )( N,  N, A0, LDA, Aseed );
   }
   Mjoin( PATL, gegen )( 1, N, X,  aincX, Xseed );
   Mjoin( PATL, gegen )( 1, N, Y,  aincY, Yseed );
/*
 * Compute the norm of A for later use in testing
 */
   if( TEST )
   {
#ifdef TREAL
      if(      ROUT == SPR2 )
         normA = Mjoin( PATL, spnrm )( UPLO, N, A      );
      else /* if( ROUT == SYR2 ) */
         normA = Mjoin( PATL, synrm )( UPLO, N, A, LDA );
#else
      if(      ROUT == SPR2 )
         normA = Mjoin( PATL, hpnrm )( UPLO, N, A      );
      else /* if( ROUT == HER2 ) */
         normA = Mjoin( PATL, henrm )( UPLO, N, A, LDA );
#endif
      if( Mabs1( ALPHA ) > ATL_rone ) normA *= Mabs1( ALPHA );
      if( normA == ATL_rzero ) normA = ATL_rone;
   }
   else { normA = ATL_rone; }
/*
 * Start cold cache timing operations for the trusted routine
 */
   x = X; if( INCX < 0 ) x = X + ( ( ( 1 - N ) * INCX ) SHIFT );
   y = Y; if( INCY < 0 ) y = Y + ( ( ( 1 - N ) * INCY ) SHIFT );

   if( ROUT == SPR2 )
   {
      if (CACHESIZE > 0)
         l2ret  = ATL_flushcache( -1 );
      t0     = time00();
      trusted_spr2( UPLO, N, ALPHA, x, INCX, y, INCY, A0      );
      ttrust = time00() - t0;
   }
   else /* if( ROUT == SYR2 ) */
   {
      if (CACHESIZE > 0)
         l2ret  = ATL_flushcache( -1 );
      t0     = time00();
      trusted_syr2( UPLO, N, ALPHA, x, INCX, y, INCY, A0, LDA );
      ttrust = time00() - t0;
   }
   if( ttrust > 0.0 )
   { *TTRUST0 = ttrust; *MFTRUST0 = ops / ( ttrust * MEGA ); }
/*
 * Start cold cache timing operations for the tested routine
 */
   x = X; if( INCX < 0 ) x = X + ( ( ( 1 - N ) * INCX ) SHIFT );
   y = Y; if( INCY < 0 ) y = Y + ( ( ( 1 - N ) * INCY ) SHIFT );

   if( ROUT == SPR2 )
   {
      if (CACHESIZE > 0)
         l2ret = ATL_flushcache( -1 );
      t0    = time00();
      test_spr2( UPLO, N, ALPHA, x, INCX, y, INCY, A      );
      ttest = time00() - t0;
   }
   else /* if( ROUT == SYR2 ) */
   {
      if (CACHESIZE > 0)
         l2ret = ATL_flushcache( -1 );
      t0    = time00();
      test_syr2( UPLO, N, ALPHA, x, INCX, y, INCY, A, LDA );
      ttest = time00() - t0;
   }
   if( ttest  > 0.0 )
   { *TTEST0  = ttest;  *MFTEST0  = ops / ( ttest  * MEGA ); }
/*
 * if timing only, I am done ... so leave.
 */
   if (CACHESIZE > 0)
      l2ret  = ATL_flushcache( 0 );
 
   if( !( TEST ) ) { free( A ); free( X ); free( Y ); return( ATL_rzero ); }
/*
 * else perform error check
 */
   normX = Mjoin( PATL, infnrm )( N, X, aincX );
   if( normX == ATL_rzero ) normX = ATL_rone;
   free( X  );

   normY = Mjoin( PATL, infnrm )( N, Y, aincY );
   if( normY == ATL_rzero ) normY = ATL_rone;
   free( Y  );
/*
 * Ensure the difference of the output operands is relatively tiny enough
 */
   if(      ROUT == SPR2 )
      normD = Mjoin( PATL, gediffnrm1 )( lA, 1, A, lA,  A0, lA  );
   else /* if( ROUT == SYR2 ) */
      normD = Mjoin( PATL, gediffnrm1 )( N,  N, A, LDA, A0, LDA );
   resid = normD / ( Mmax( normA, ATL_rone ) * Mmax( normX, ATL_rone ) *
                     Mmax( normY, ATL_rone ) * EPSILON * N );

   if( ( resid > THRESH ) || ( resid != resid ) )
   {
      (void) fprintf( stderr, 
      "ERROR:    resid=%f, normD=%f, normA=%f, normX=%f, normY=%f, eps=%e\n",
      resid, normD, normA, normX, normY, EPSILON );
#ifdef ATLAS_DEBUG
      if(      ROUT == SPR2 )
      {
         Mjoin( PATL, geprint )( "A_trusted", lA, 1, A0, lA  );
         Mjoin( PATL, geprint )( "A_test",    lA, 1, A,  lA  );
      }
      else /* if( ROUT == SYR2 ) */
      {
         Mjoin( PATL, geprint )( "A_trusted", N,  N, A0, LDA );
         Mjoin( PATL, geprint )( "A_test",    N,  N, A,  LDA );
      }
#endif
   }

   free( A  );

   return( resid );
}
/*
 * =====================================================================
 * case functions
 * =====================================================================
 */
int gmvcase
(
   const int                  CACHESIZE,
   const enum LVL2_ROUT       ROUT,
   const int                  TEST,
   const int                  MFLOP,
   const enum ATLAS_TRANS     TRANS,
   const int                  M,
   const int                  N,
   const int                  KL,
   const int                  KU,
   const SCALAR               ALPHA,
   const int                  LDA,
   const int                  INCX, 
   const SCALAR               BETA,
   const int                  INCY,
   const TYPE                 EPSILON,
   double                     * TTRUST0, 
   double                     * TTEST0,
   double                     * MFTRUST0,
   double                     * MFTEST0
)
{
   double                     flops, ttrust, ttest, mftrust, mftest, t0;
   TYPE                       resid = ATL_rzero;
#ifdef TREAL
   TYPE                       bet,  beta,    nbeta;
#else
   TYPE                       *bet, beta[2], nbeta[2];
#endif
   TYPE                       * a, * stA, * stX, * stY, * x, * y, * A,
                              * A0 = NULL, * X, * X0 = NULL, * Y, * Y0 = NULL;
   unsigned long              ir, reps;
   int                        aincX, aincY, inca, incx, incy, lX, lY, lA,
                              mA, nA, nY, nX, passed, Aseed, Xseed, Yseed;

   if( ( MEGA * MFLOP <= ( flops = opbl2( ROUT, M, N, KL, KU ) ) ) || ( TEST ) )
   {
      resid = gmvtst( CACHESIZE, ROUT, TEST, TRANS, M, N, KL, KU, ALPHA,
		      LDA, INCX, BETA, INCY, EPSILON, TTRUST0, TTEST0,
MFTRUST0, MFTEST0 );
      if( resid > THRESH ) (void) fprintf( stderr, "   resid=%f\n", resid );
   }
   if( resid < ATL_rzero ) passed = -1;
   else                    passed = ( resid < THRESH );

   if( MEGA * MFLOP <= flops ) return( passed );

   if( ROUT == GBMV )
   {
      mA = KL + 1 + KU;
      nA = N;
@skip      if( TRANS == AtlasNoTrans ) { mA = KL + 1 + KU; nA = N; }
@skip      else                        { mA = KL + 1 + KU; nA = M; }
      if( TRANS == AtlasNoTrans ) { nY = M; nX = N; }
      else                        { nY = N; nX = M; }
   }
   else
   {
      mA = M;
      nA = N;
@skip      if( TRANS == AtlasNoTrans ) { mA = M; nA = N; }
@skip      else                        { mA = N; nA = M; }
      if( TRANS == AtlasNoTrans ) { nY = M; nX = N; }
      else                        { nY = N; nX = M; }
   }
 
   incy = INCY * ( nY  SHIFT ); aincY = Mabs( INCY );
   incx = INCX * ( nX  SHIFT ), aincX = Mabs( INCX );
   inca = LDA  * ( nA SHIFT ); 

   lY = M * aincY * ( ( ATL_DivBySize( LCSIZE ) + nY      - 1 ) / nY          );
   lX = N * aincX * ( ( ATL_DivBySize( LCSIZE ) + nX      - 1 ) / nX          );
   lA =     inca  * ( ( ATL_DivBySize( LCSIZE ) + 2*mA*nA - 1 ) / ( mA * nA ) );

   Y0 = (TYPE *)malloc( ATL_MulBySize( lY ) );
   X0 = (TYPE *)malloc( ATL_MulBySize( lX ) );
   A0 = (TYPE *)malloc( ATL_MulBySize( lA ) );

   if( ( Y0 == NULL ) || ( X0 == NULL ) || ( A0 == NULL ) )
   {
      if( Y0 ) free( Y0 );
      if( X0 ) free( X0 );
      if( A0 ) free( A0 );
      return( -1 );
   }

   if( INCY < 1 ) { Y = Y0 + ( lY SHIFT ); stY = Y0; }
   else           { Y = Y0; stY = Y0 + ( lY SHIFT ); }
   if( INCX < 1 ) { X = X0 + ( lX SHIFT ); stX = X0; }
   else           { X = X0; stX = X0 + ( lX SHIFT ); }
   A = A0; stA = A0 + ( lA SHIFT );

#ifdef TREAL
   beta   =  BETA;
   nbeta  = -BETA;
#else
   *beta  =    *BETA; beta [1] =  BETA[1];
   *nbeta = -(*BETA); nbeta[1] = -BETA[1];
#endif

   Yseed = nY * aincY;
   Xseed = nX * aincX + 127 * 50 + 77;
   Aseed = N * M     + 513 *  7 + 90;

   reps  = ( MEGA * MFLOP ) / flops;
/*
 * Generate the random data and time the trusted routine
 */
   bet = beta; y = Y; x = X; a = A;

   Mjoin( PATL, gegen )( lY, 1, Y0, lY, Yseed );
   Mjoin( PATL, gegen )( lX, 1, X0, lX, Xseed );
   Mjoin( PATL, gegen )( lA, 1, A0, lA, Aseed );

   if( ROUT == GBMV )
   {
      t0 = time00();
      for( ir = reps; ir; ir-- )
      {
         trusted_gbmv( TRANS, M, N, KL, KU, ALPHA, a, LDA, x, INCX,
                       (SCALAR)(bet), y, INCY );
         y += incy;
         if( y == stY )
         { y = Y; if( bet == beta ) bet = nbeta; else bet = beta; }
         x += incx; if( x == stX ) { x = X; }
         a += inca; if( a == stA ) { a = A; }
      }
      ttrust = time00() - t0;
   }
   else
   {
      t0 = time00();
      for( ir = reps; ir; ir-- )
      {
         trusted_gemv( TRANS, M, N,         ALPHA, a, LDA, x, INCX,
                       (SCALAR)(bet), y, INCY );
         y += incy;
         if( y == stY )
         { y = Y; if( bet == beta ) bet = nbeta; else bet = beta; }
         x += incx; if( x == stX ) { x = X; }
         a += inca; if( a == stA ) { a = A; }
      }
      ttrust = time00() - t0;
   }
   if( ttrust > 0.0 ) mftrust = ( reps * flops ) / ( MEGA * ttrust );
   else               mftrust = 0.0;
   ttrust /= reps; *TTRUST0 = ttrust; *MFTRUST0 = mftrust;
/*
 * Generate the random data and time the tested routine
 */
   bet = beta; y = Y; x = X; a = A;

   Mjoin( PATL, gegen )( lY, 1, Y0, lY, Yseed );
   Mjoin( PATL, gegen )( lX, 1, X0, lX, Xseed );
   Mjoin( PATL, gegen )( lA, 1, A0, lA, Aseed );

   if( ROUT == GBMV )
   {
      t0 = time00();
      for( ir = reps; ir; ir-- )
      {
         test_gbmv( TRANS, M, N, KL, KU, ALPHA, a, LDA, x, INCX,
                    (SCALAR)(bet), y, INCY );
         y += incy;
         if( y == stY )
         { y = Y; if( bet == beta ) bet = nbeta; else bet = beta; }
         x += incx; if( x == stX ) { x = X; }
         a += inca; if( a == stA ) { a = A; }
      }
      ttest = time00() - t0;
   }
   else
   {
      t0 = time00();
      for( ir = reps; ir; ir-- )
      {
         test_gemv( TRANS, M, N,         ALPHA, a, LDA, x, INCX,
                    (SCALAR)(bet), y, INCY );
         y += incy;
         if( y == stY )
         { y = Y; if( bet == beta ) bet = nbeta; else bet = beta; }
         x += incx; if( x == stX ) { x = X; }
         a += inca; if( a == stA ) { a = A; }
      } 
      ttest = time00() - t0;
   }
   if( ttest  > 0.0 ) mftest  = ( reps * flops ) / ( MEGA * ttest  );
   else               mftest  = 0.0;
   ttest  /= reps; *TTEST0  = ttest;  *MFTEST0  = mftest;
/*
 * release the memory and exit
 */
   free( Y0 );
   free( X0 );
   free( A0 );

   return( passed );
}

int smvcase
(
   const int                  CACHESIZE,
   const enum LVL2_ROUT       ROUT,
   const int                  TEST,
   const int                  MFLOP,
   const enum ATLAS_UPLO      UPLO,
   const int                  N,
   const int                  K,
   const SCALAR               ALPHA,
   const int                  LDA,
   const int                  INCX, 
   const SCALAR               BETA,
   const int                  INCY,
   const TYPE                 EPSILON,
   double                     * TTRUST0, 
   double                     * TTEST0,
   double                     * MFTRUST0,
   double                     * MFTEST0
)
{
   double                     flops, ttrust, ttest, mftrust, mftest, t0;
   TYPE                       resid = ATL_rzero;
#ifdef TREAL
   TYPE                       bet,   beta,    nbeta;
#else
   TYPE                       * bet, beta[2], nbeta[2];
#endif
   TYPE                       * a, * stA, * stX, * stY, * x, * y, * A,
                              * A0 = NULL, * X, * X0 = NULL, * Y, * Y0 = NULL;
   unsigned long              ir, reps;
   int                        aincX, aincY, inca, incx, incy, lX, lY, lA,
                              mA, nA, passed, Aseed, Xseed, Yseed;

   if( ( MEGA * MFLOP <= ( flops = opbl2( ROUT, N, N, K, K ) ) ) || ( TEST ) )
   {
      resid = smvtst( CACHESIZE, ROUT, TEST, UPLO, N, K, ALPHA, LDA, INCX,
		      BETA, INCY, EPSILON, TTRUST0, TTEST0, MFTRUST0,
		      MFTEST0 );
      if( resid > THRESH ) (void) fprintf( stderr, "   resid=%f\n", resid );
   }
   if( resid < ATL_rzero ) passed = -1;
   else                    passed = ( resid < THRESH );
 
   if( MEGA * MFLOP <= flops ) return( passed );

   if(      ROUT == SBMV ) { mA = K + 1;                  nA = N; }
   else if( ROUT == SPMV ) { mA = ( N * ( N + 1 ) ) >> 1; nA = 1; }
   else                    { mA = N;                      nA = N; }

   incy = INCY * ( N  SHIFT ); aincY = Mabs( INCY );
   incx = INCX * ( N  SHIFT ); aincX = Mabs( INCX );
   if( ROUT == SPMV ) inca = ( mA SHIFT );
   else               inca = LDA  * ( nA SHIFT );

   lY = N * aincY * ( ( ATL_DivBySize( LCSIZE ) + N       - 1 ) / N           );
   lX = N * aincX * ( ( ATL_DivBySize( LCSIZE ) + N       - 1 ) / N           );
   lA =     inca  * ( ( ATL_DivBySize( LCSIZE ) + 2*mA*nA - 1 ) / ( mA * nA ) );

   Y0 = (TYPE *)malloc( ATL_MulBySize( lY ) );
   X0 = (TYPE *)malloc( ATL_MulBySize( lX ) );
   A0 = (TYPE *)malloc( ATL_MulBySize( lA ) );

   if( ( Y0 == NULL ) || ( X0 == NULL ) || ( A0 == NULL ) )
   {
      if( Y0 ) free( Y0 );
      if( X0 ) free( X0 );
      if( A0 ) free( A0 );
      return( -1 );
   }

   if( INCY < 1 ) { Y = Y0 + ( lY SHIFT ); stY = Y0; }
   else           { Y = Y0; stY = Y0 + ( lY SHIFT ); }
   if( INCX < 1 ) { X = X0 + ( lX SHIFT ); stX = X0; }
   else           { X = X0; stX = X0 + ( lX SHIFT ); }
   A = A0; stA = A0 + ( lA SHIFT );

#ifdef TREAL
   beta   =  BETA;
   nbeta  = -BETA;
#else
   *beta  =    *BETA; beta [1] =  BETA[1];
   *nbeta = -(*BETA); nbeta[1] = -BETA[1];
#endif

   Yseed = N * aincY;
   Xseed = N * aincX + 127 * 50 + 77;
   Aseed = N * N     + 513 *  7 + 90;

   reps = ( MEGA * MFLOP ) / flops;
/*
 * Generate the random data and time the trusted routine
 */
   bet = beta; y = Y; x = X; a = A;

   Mjoin( PATL, gegen )( lY, 1, Y0, lY, Yseed );
   Mjoin( PATL, gegen )( lX, 1, X0, lX, Xseed );
   Mjoin( PATL, gegen )( lA, 1, A0, lA, Aseed );

   if(      ROUT == SBMV )
   {
      t0 = time00();
      for( ir = reps; ir; ir-- )
      {
         trusted_sbmv( UPLO, N, K, ALPHA, a, LDA, x, INCX, (SCALAR)(bet),
                       y, INCY );
         y += incy;
         if( y == stY )
         { y = Y; if( bet == beta ) bet = nbeta; else bet = beta; }
         x += incx; if( x == stX ) { x = X; }
         a += inca; if( a == stA ) { a = A; }
      }
      ttrust = time00() - t0;
   }
   else if( ROUT == SPMV )
   {
      t0 = time00();
      for( ir = reps; ir; ir-- )
      {
         trusted_spmv( UPLO, N, ALPHA, a, x, INCX, (SCALAR)(bet), y, INCY );
         y += incy;
         if( y == stY )
         { y = Y; if( bet == beta ) bet = nbeta; else bet = beta; }
         x += incx; if( x == stX ) { x = X; }
         a += inca; if( a == stA ) { a = A; }
      }
      ttrust = time00() - t0;
   }
   else
   {
      t0 = time00();
      for( ir = reps; ir; ir-- )
      {
         trusted_symv( UPLO, N,    ALPHA, a, LDA, x, INCX, (SCALAR)(bet),
                       y, INCY );
         y += incy;
         if( y == stY )
         { y = Y; if( bet == beta ) bet = nbeta; else bet = beta; }
         x += incx; if( x == stX ) { x = X; }
         a += inca; if( a == stA ) { a = A; }
      }
      ttrust = time00() - t0;
   }
   if( ttrust > 0.0 ) mftrust = ( reps * flops ) / ( MEGA * ttrust );
   else               mftrust = 0.0;
   ttrust /= reps; *TTRUST0 = ttrust; *MFTRUST0 = mftrust;
/*
 * Generate the random data and time the tested routine
 */
   bet = beta; y = Y; x = X; a = A;

   Mjoin( PATL, gegen )( lY, 1, Y0, lY, Yseed );
   Mjoin( PATL, gegen )( lX, 1, X0, lX, Xseed );
   Mjoin( PATL, gegen )( lA, 1, A0, lA, Aseed );

   if(      ROUT == SBMV )
   {
      t0 = time00();
      for( ir = reps; ir; ir-- )
      {
         test_sbmv( UPLO, N, K, ALPHA, a, LDA, x, INCX, (SCALAR)(bet),
                    y, INCY );
         y += incy;
         if( y == stY )
         { y = Y; if( bet == beta ) bet = nbeta; else bet = beta; }
         x += incx; if( x == stX ) { x = X; }
         a += inca; if( a == stA ) { a = A; }
      }
      ttest = time00() - t0;
   }
   else if( ROUT == SPMV )
   {
      t0 = time00();
      for( ir = reps; ir; ir-- )
      {
         test_spmv( UPLO, N,    ALPHA, a, x, INCX, (SCALAR)(bet),
                    y, INCY );
         y += incy;
         if( y == stY )
         { y = Y; if( bet == beta ) bet = nbeta; else bet = beta; }
         x += incx; if( x == stX ) { x = X; }
         a += inca; if( a == stA ) { a = A; }
      }
      ttest = time00() - t0;
   }
   else
   {
      t0 = time00();
      for( ir = reps; ir; ir-- )
      {
         test_symv( UPLO, N,    ALPHA, a, LDA, x, INCX, (SCALAR)(bet),
                    y, INCY );
         y += incy;
         if( y == stY )
         { y = Y; if( bet == beta ) bet = nbeta; else bet = beta; }
         x += incx; if( x == stX ) { x = X; }
         a += inca; if( a == stA ) { a = A; }
      } 
      ttest = time00() - t0;
   }
   if( ttest  > 0.0 ) mftest  = ( reps * flops ) / ( MEGA * ttest  );
   else               mftest  = 0.0;
   ttest  /= reps; *TTEST0  = ttest;  *MFTEST0  = mftest;
/*
 * release the memory and exit
 */
   free( Y0 );
   free( X0 );
   free( A0 );

   return( passed );
}

int tmvcase
(
   const int                  CACHESIZE,
   const enum LVL2_ROUT       ROUT,
   const int                  TEST,
   const int                  MFLOP,
   const enum ATLAS_UPLO      UPLO, 
   const enum ATLAS_TRANS     TRANS,
   const enum ATLAS_DIAG      DIAG, 
   const int                  N,
   const int                  K,
   const int                  LDA,
   const int                  INCX, 
   const TYPE                 EPSILON,
   double                     * TTRUST0,
   double                     * TTEST0, 
   double                     * MFTRUST0,
   double                     * MFTEST0
)
{
   double                     flops, ttrust, ttest, mftrust, mftest, t0;
   TYPE                       resid = ATL_rzero;
   TYPE                       * a, * stA, * stX, * x, * A, * A0 = NULL, * X,
                              * X0 = NULL;
   unsigned long              ir, reps;
   int                        aincX, inca, incx, lX, lA, mA, nA, passed,
                              Aseed, Xseed;

   if( ( MEGA * MFLOP <= ( flops = opbl2( ROUT, N, N, K, K ) ) ) || ( TEST ) )
   { 
      resid = tmvtst( CACHESIZE, ROUT, TEST, UPLO, TRANS, DIAG, N, K, LDA,
		      INCX, EPSILON, TTRUST0, TTEST0, MFTRUST0, MFTEST0 );
      if( resid > THRESH ) (void) fprintf( stderr, "   resid=%f\n", resid );
   }
   if( resid < ATL_rzero ) passed = -1;
   else                    passed = ( resid < THRESH );
 
   if( MEGA * MFLOP <= flops ) return( passed );

   if(      ROUT == TBMV ) { mA = K + 1;                  nA = N; }
   else if( ROUT == TPMV ) { mA = ( N * ( N + 1 ) ) >> 1; nA = 1; }
   else                    { mA = N;                      nA = N; }
 
   incx = INCX * ( N  SHIFT ); aincX = Mabs( INCX );
   if( ROUT == TPMV ) inca = ( mA SHIFT );
   else               inca = LDA  * ( nA SHIFT );
 
   lX = N * aincX * ( ( ATL_DivBySize( LCSIZE ) + N       - 1 ) / N           );
   lA =     inca  * ( ( ATL_DivBySize( LCSIZE ) + 2*mA*nA - 1 ) / ( mA * nA ) );

   X0 = (TYPE *)malloc( ATL_MulBySize( lX ) );
   A0 = (TYPE *)malloc( ATL_MulBySize( lA ) );
 
   if( ( X0 == NULL ) || ( A0 == NULL ) )
   {
      if( X0 ) free( X0 );
      if( A0 ) free( A0 );
      return( -1 );
   }
 
   if( INCX < 1 ) { X = X0 + ( lX SHIFT ); stX = X0; }
   else           { X = X0; stX = X0 + ( lX SHIFT ); }
   A = A0; stA = A0 + ( lA SHIFT );

   Xseed = N * aincX + 127 * 50 + 77;
   Aseed = N * N     + 513 *  7 + 90;
 
   reps = ( MEGA * MFLOP ) / flops;
/*
 * Generate the random data and time the trusted routine
 */
   x = X; a = A;

   Mjoin( PATL, gegen )( lX, 1, X0, lX, Xseed );
   Mjoin( PATL, gegen )( lA, 1, A0, lA, Aseed );

   if(      ROUT == TBMV )
   {
      t0 = time00();
      for( ir = reps; ir; ir-- )
      {
         trusted_tbmv( UPLO, TRANS, DIAG, N, K, a, LDA, x, INCX );
         x += incx; if( x == stX ) { x = X; }
         a += inca; if( a == stA ) { a = A; }
      }
      ttrust = time00() - t0;
   }
   else if( ROUT == TPMV )
   {
      t0 = time00();
      for( ir = reps; ir; ir-- )
      {
         trusted_tpmv( UPLO, TRANS, DIAG, N, a, x, INCX );
         x += incx; if( x == stX ) { x = X; }
         a += inca; if( a == stA ) { a = A; }
      }
      ttrust = time00() - t0;
   }
   else
   {
      t0 = time00();
      for( ir = reps; ir; ir-- )
      {
         trusted_trmv( UPLO, TRANS, DIAG, N, a, LDA, x, INCX );
         x += incx; if( x == stX ) { x = X; }
         a += inca; if( a == stA ) { a = A; }
      }
      ttrust = time00() - t0;
   }
   if( ttrust > 0.0 ) mftrust = ( reps * flops ) / ( MEGA * ttrust );
   else               mftrust = 0.0;
   ttrust /= reps; *TTRUST0 = ttrust; *MFTRUST0 = mftrust;
/*
 * Generate the random data and time the tested routine
 */
   x = X; a = A;

   Mjoin( PATL, gegen )( lX, 1, X0, lX, Xseed );
   Mjoin( PATL, gegen )( lA, 1, A0, lA, Aseed );
 
   if(      ROUT == TBMV )
   {
      t0 = time00();
      for( ir = reps; ir; ir-- )
      {
         test_tbmv( UPLO, TRANS, DIAG, N, K, a, LDA, x, INCX );
         x += incx; if( x == stX ) { x = X; }
         a += inca; if( a == stA ) { a = A; }
      }
      ttest = time00() - t0;
   }
   else if( ROUT == TPMV )
   {
      t0 = time00();
      for( ir = reps; ir; ir-- )
      {
         test_tpmv( UPLO, TRANS, DIAG, N, a, x, INCX );
         x += incx; if( x == stX ) { x = X; }
         a += inca; if( a == stA ) { a = A; }
      }
      ttest = time00() - t0;
   }
   else
   {
      t0 = time00();
      for( ir = reps; ir; ir-- )
      {
         test_trmv( UPLO, TRANS, DIAG, N, a, LDA, x, INCX );
         x += incx; if( x == stX ) { x = X; }
         a += inca; if( a == stA ) { a = A; }
      }
      ttest = time00() - t0;
   }
   if( ttest  > 0.0 ) mftest  = ( reps * flops ) / ( MEGA * ttest  );
   else               mftest  = 0.0;
   ttest  /= reps; *TTEST0  = ttest;  *MFTEST0  = mftest;
/*
 * release the memory and exit
 */
   free( X0 );
   free( A0 ); 
 
   return( passed );
}

int tsvcase
(
   const int                  CACHESIZE,
   const enum LVL2_ROUT       ROUT,
   const int                  TEST,
   const int                  MFLOP,
   const enum ATLAS_UPLO      UPLO, 
   const enum ATLAS_TRANS     TRANS,
   const enum ATLAS_DIAG      DIAG, 
   const int                  N,
   const int                  K,
   const int                  LDA,
   const int                  INCX, 
   const TYPE                 EPSILON,
   double                     * TTRUST0,
   double                     * TTEST0, 
   double                     * MFTRUST0,
   double                     * MFTEST0
)
{
   double                     flops, ttrust, ttest, mftrust, mftest, t0;
   TYPE                       resid = ATL_rzero;
   TYPE                       * a, * stA, * stX, * x, * A, * A0 = NULL, * X,
                              * X0 = NULL;
   unsigned long              ir, reps;
   int                        aincX, inca, incx, lX, lA, mA, nA, passed,
                              Aseed, Xseed;

   if( ( MEGA * MFLOP <= ( flops = opbl2( ROUT, N, N, K, K ) ) ) || ( TEST ) )
   { 
      resid = tsvtst( CACHESIZE, ROUT, TEST, UPLO, TRANS, DIAG, N, K, LDA,
		      INCX, EPSILON, TTRUST0, TTEST0, MFTRUST0, MFTEST0 );
      if( resid > THRESH ) (void) fprintf( stderr, "   resid=%f\n", resid );
   }
   if( resid < ATL_rzero ) passed = -1;
   else                    passed = ( resid < THRESH );
 
   if( MEGA * MFLOP <= flops ) return( passed );

   if(      ROUT == TBSV ) { mA = K + 1;                  nA = N; }
   else if( ROUT == TPSV ) { mA = ( N * ( N + 1 ) ) >> 1; nA = 1; }
   else                    { mA = N;                      nA = N; }
 
   incx = INCX * ( N  SHIFT ); aincX = Mabs( INCX );
   if( ROUT == TPSV ) inca = ( mA SHIFT );
   else               inca = LDA  * ( nA SHIFT );
 
   lX = N * aincX * ( ( ATL_DivBySize( LCSIZE ) + N       - 1 ) / N           );
   lA =     inca  * ( ( ATL_DivBySize( LCSIZE ) + 2*mA*nA - 1 ) / ( mA * nA ) );
 
   X0 = (TYPE *)malloc( ATL_MulBySize( lX ) );
   A0 = (TYPE *)malloc( ATL_MulBySize( lA ) );
 
   if( ( X0 == NULL ) || ( A0 == NULL ) )
   {
      if( X0 ) free( X0 );
      if( A0 ) free( A0 );
      return( -1 );
   }
 
   if( INCX < 1 ) { X = X0 + ( lX SHIFT ); stX = X0; }
   else           { X = X0; stX = X0 + ( lX SHIFT ); }
   A = A0; stA = A0 + ( lA SHIFT );
 
   Xseed = N * aincX + 127 * 50 + 77;
   Aseed = N * N     + 513 *  7 + 90;
 
   reps = ( MEGA * MFLOP ) / flops;
/*
 * Generate the random data and time the trusted routine
 */
   Mjoin( PATL, gegen )( lX, 1, X0, lX, Xseed );
   Mjoin( PATL, gegen )( lA, 1, A0, lA, Aseed );

   a = A;

   if(      ROUT == TBSV )
   do { tbddom( UPLO, N, K, a, LDA ); a += inca; } while( a != stA ); 
   else if( ROUT == TPSV )
   do { tpddom( UPLO, N,    a      ); a += inca; } while( a != stA ); 
   else
   do { trddom( UPLO, N,    a, LDA ); a += inca; } while( a != stA ); 

   x = X; a = A;

   if(      ROUT == TBSV )
   {
      t0 = time00();
      for( ir = reps; ir; ir-- )
      {
         trusted_tbsv( UPLO, TRANS, DIAG, N, K, a, LDA, x, INCX );
         x += incx; if( x == stX ) { x = X; }
         a += inca; if( a == stA ) { a = A; }
      }
      ttrust = time00() - t0;
   }
   else if( ROUT == TPSV )
   {
      t0 = time00();
      for( ir = reps; ir; ir-- )
      {
         trusted_tpsv( UPLO, TRANS, DIAG, N, a, x, INCX );
         x += incx; if( x == stX ) { x = X; }
         a += inca; if( a == stA ) { a = A; }
      }
      ttrust = time00() - t0;
   }
   else
   {
      t0 = time00();
      for( ir = reps; ir; ir-- )
      {
         trusted_trsv( UPLO, TRANS, DIAG, N, a, LDA, x, INCX );
         x += incx; if( x == stX ) { x = X; }
         a += inca; if( a == stA ) { a = A; }
      }
      ttrust = time00() - t0;
   }
   if( ttrust > 0.0 ) mftrust = ( reps * flops ) / ( MEGA * ttrust );
   else               mftrust = 0.0;
   ttrust /= reps; *TTRUST0 = ttrust; *MFTRUST0 = mftrust;
/*
 * Generate the random data and time the tested routine
 */
   Mjoin( PATL, gegen )( lX, 1, X0, lX, Xseed );
   Mjoin( PATL, gegen )( lA, 1, A0, lA, Aseed );
 
   a = A;
 
   if(      ROUT == TBSV )
   do { tbddom( UPLO, N, K, a, LDA ); a += inca; } while( a != stA );
   else if( ROUT == TPSV )
   do { tpddom( UPLO, N,    a      ); a += inca; } while( a != stA );
   else
   do { trddom( UPLO, N,    a, LDA ); a += inca; } while( a != stA );
 
   x = X; a = A;
 
   if(      ROUT == TBSV )
   {
      t0 = time00();
      for( ir = reps; ir; ir-- )
      {
         test_tbsv( UPLO, TRANS, DIAG, N, K, a, LDA, x, INCX );
         x += incx; if( x == stX ) { x = X; }
         a += inca; if( a == stA ) { a = A; }
      }
      ttest = time00() - t0;
   }
   else if( ROUT == TPSV )
   {
      t0 = time00();
      for( ir = reps; ir; ir-- )
      {
         test_tpsv( UPLO, TRANS, DIAG, N, a, x, INCX );
         x += incx; if( x == stX ) { x = X; }
         a += inca; if( a == stA ) { a = A; }
      }
      ttest = time00() - t0;
   }
   else
   {
      t0 = time00();
      for( ir = reps; ir; ir-- )
      {
         test_trsv( UPLO, TRANS, DIAG, N, a, LDA, x, INCX );
         x += incx; if( x == stX ) { x = X; }
         a += inca; if( a == stA ) { a = A; }
      }
      ttest = time00() - t0;
   }
   if( ttest  > 0.0 ) mftest  = ( reps * flops ) / ( MEGA * ttest  );
   else               mftest  = 0.0;
   ttest  /= reps; *TTEST0  = ttest;  *MFTEST0  = mftest;
/*
 * release the memory and exit
 */
   free( X0 );
   free( A0 ); 
 
   return( passed );
}

@define rr @@
@define rr @2@
@whiledef rt r1 r2
   @addkeys RANK=@(rt)
int g@(rt)case
(
   const int                  CACHESIZE,
   const enum LVL2_ROUT       ROUT,
   const int                  TEST,
   const int                  MFLOP,
   const int                  M, 
   const int                  N,
   const SCALAR               ALPHA,
   const int                  INCX,
   const int                  INCY,
@RANK R2
   const SCALAR               BETA,
   const int                  INCW,
   const int                  INCZ,
@RANK !
   const int                  LDA,
   const TYPE                 EPSILON,
   double                     * TTRUST0,
   double                     * TTEST0,
   double                     * MFTRUST0,
   double                     * MFTEST0
)
{
   double                     flops, ttrust, ttest, mftrust, mftest, t0;
   TYPE                       resid = ATL_rzero;
#ifdef TREAL
   TYPE                       alph,  alpha,    nalpha;
#else
   TYPE                       *alph, alpha[2], nalpha[2];
#endif
   TYPE                       * a, * stA, * stX, * stY, * x, * y, * A,
                              * A0 = NULL, * X, * X0 = NULL, * Y, * Y0 = NULL;
   unsigned long              ir, reps;
   int                        aincX, aincY, inca, incx, incy, lX, lY, lA,
                              passed, Aseed, Xseed, Yseed;
@RANK R2
   int incw, aincW, incz, aincZ, lW, lZ, Wseed, Zseed;
   TYPE *W0, *Z0, *W, *Z, *w, *z, *stW, *stZ;
   #ifdef TREAL
      TYPE  bet,  beta,    nbeta;
   #else
      TYPE *bet, beta[2], nbeta[2];
   #endif
@RANK !

   if( ( MEGA * MFLOP <= ( flops = opbl2( ROUT, M, N, 0, 0 ) ) ) || ( TEST ) )
   { 
@RANK R1
      resid = gr1tst( CACHESIZE, ROUT, TEST, M, N, ALPHA, INCX, INCY, LDA,
		      EPSILON, TTRUST0, TTEST0, MFTRUST0, MFTEST0 );
@RANK R2
      resid = gr2tst( CACHESIZE, ROUT, TEST, M, N, ALPHA, INCX, INCY, BETA, 
                      INCW, INCZ, LDA, EPSILON, TTRUST0, TTEST0, MFTRUST0, 
                      MFTEST0 );
@RANK !
      if( resid > THRESH ) (void) fprintf( stderr, "   resid=%f\n", resid );
   }
   if( resid < ATL_rzero ) passed = -1;
   else                    passed = ( resid < THRESH );
 
   if( MEGA * MFLOP <= flops ) return( passed );

   incy = INCY * ( N  SHIFT ); aincY = Mabs( INCY );
   incx = INCX * ( M  SHIFT ), aincX = Mabs( INCX );
   inca = LDA  * ( N SHIFT );
 
   lY = N * aincY * ( ( ATL_DivBySize( LCSIZE ) + N     - 1 ) / N         );
   lX = M * aincX * ( ( ATL_DivBySize( LCSIZE ) + M     - 1 ) / M         );
   lA =     inca  * ( ( ATL_DivBySize( LCSIZE ) + 2*M*N - 1 ) / ( M * N ) );
 
   Y0 = (TYPE *)malloc( ATL_MulBySize( lY ) );
   X0 = (TYPE *)malloc( ATL_MulBySize( lX ) );
   A0 = (TYPE *)malloc( ATL_MulBySize( lA ) );
@RANK R2
   incw = INCW * ( M  SHIFT ), aincW = Mabs( INCW );
   incz = INCZ * ( N  SHIFT ); aincZ = Mabs( INCZ );
   lW = M * aincW * ( ( ATL_DivBySize( LCSIZE ) + M     - 1 ) / M         );
   lZ = N * aincZ * ( ( ATL_DivBySize( LCSIZE ) + N     - 1 ) / N         );
   W0 = (TYPE *)malloc( ATL_MulBySize( lW ) );
   Z0 = (TYPE *)malloc( ATL_MulBySize( lZ ) );
 
   if( !Y0 || !X0 || !A0 || !W0 || !Z0)
@RANK R1
   if( ( Y0 == NULL ) || ( X0 == NULL ) || ( A0 == NULL ) )
@RANK !
   {
@RANK R2
      if( W0 ) free( W0 );
      if( Z0 ) free( Z0 );
@RANK !
      if( Y0 ) free( Y0 );
      if( X0 ) free( X0 );
      if( A0 ) free( A0 );
      return( -1 );
   }
 
   if( INCY < 1 ) { Y = Y0 + ( lY SHIFT ); stY = Y0; }
   else           { Y = Y0; stY = Y0 + ( lY SHIFT ); }
   if( INCX < 1 ) { X = X0 + ( lX SHIFT ); stX = X0; }
   else           { X = X0; stX = X0 + ( lX SHIFT ); }
@RANK R2
   if( INCW < 1 ) { W = W0 + ( lW SHIFT ); stW = W0; }
   else           { W = W0; stW = W0 + ( lX SHIFT ); }
   if( INCZ < 1 ) { Z = Z0 + ( lZ SHIFT ); stZ = Z0; }
   else           { Z = Z0; stZ = Z0 + ( lY SHIFT ); }
@RANK !
   A = A0; stA = A0 + ( lA SHIFT );

#ifdef TREAL
   alpha  =  ALPHA;
   nalpha = -ALPHA;
#else
   *alpha  =  ALPHA[0]; alpha [1] =  ALPHA[1];
   *nalpha = -ALPHA[0]; nalpha[1] = -ALPHA[1];
#endif
@RANK R2
#ifdef TREAL
   beta   =  BETA ;
   nbeta  = -BETA ;
#else
   *beta   =  BETA [0]; beta  [1] =  BETA [1];
   *nbeta  = -BETA [0]; nbeta [1] = -BETA [1];
#endif
@RANK !

   Yseed = N * aincY;
   Xseed = M * aincX + 127 * 50 + 77;
   Aseed = N * M     + 513 *  7 + 90;
 
   reps = ( MEGA * MFLOP ) / flops;
/*
 * Generate the random data and time the trusted routine
 */
   alph = alpha; y = Y; x = X; a = A;

   Mjoin( PATL, gegen )( lY, 1, Y0, lY, Yseed );
   Mjoin( PATL, gegen )( lX, 1, X0, lX, Xseed );
   Mjoin( PATL, gegen )( lA, 1, A0, lA, Aseed );
@RANK R2
   bet = beta; z = Z; w = W;  
   Wseed = lY | 0xAC39E; Zseed = 0xFF00003 | (Yseed+78);
   Mjoin( PATL, gegen )( lW, 1, W0, lW, Wseed );
   Mjoin( PATL, gegen )( lZ, 1, Z0, lZ, Zseed );
@RANK !

   if( ROUT == GER@(rr)U )
   {
      t0 = time00();
      for( ir = reps; ir; ir-- )
      {
@RANK R1
         trusted_geru( M, N, (SCALAR)(alph), x, INCX, y, INCY, a, LDA );
@RANK R2
         trusted_ger2u( M, N, (SCALAR)(alph), x, INCX, y, INCY, 
                        (SCALAR)(bet), w, INCW, z, INCZ, a, LDA );
         w += incw; if( w == stW ) { w = W; }
         z += incz; if( z == stZ ) { z = Z; }
@RANK !
         y += incy; if( y == stY ) { y = Y; }
         x += incx; if( x == stX ) { x = X; }
         a += inca;
         if( a == stA )
@RANK R1
         { a = A; if( alph == alpha ) alph = nalpha; else alph = alpha; }
@RANK R2
         { 
            a = A; 
            if( alph == alpha ) alph = nalpha; 
            else alph = alpha; 
            if( bet  == beta  ) bet  = nbeta ; 
            else bet  = beta ; 
         }
@RANK !
      }
      ttrust = time00() - t0;
   }
   else
   {
      t0 = time00();
      for( ir = reps; ir; ir-- )
      {
@RANK R1
         trusted_gerc( M, N, (SCALAR)(alph), x, INCX, y, INCY, a, LDA );
@RANK R2
         trusted_ger2u( M, N, (SCALAR)(alph), x, INCX, y, INCY, 
                        (SCALAR)(bet), w, INCW, z, INCZ, a, LDA );
         w += incw; if( w == stW ) { w = W; }
         z += incz; if( z == stZ ) { z = Z; }
@RANK !
         y += incy; if( y == stY ) { y = Y; }
         x += incx; if( x == stX ) { x = X; }
         a += inca;
         if( a == stA )
@RANK R1
         { a = A; if( alph == alpha ) alph = nalpha; else alph = alpha; }
@RANK R2
         { 
            a = A; 
            if( alph == alpha ) alph = nalpha; 
            else alph = alpha; 
            if( bet  == beta  ) bet  = nbeta ; 
            else bet  = beta ; 
         }
@RANK !
      }
      ttrust = time00() - t0;
   }
   if( ttrust > 0.0 ) mftrust = ( reps * flops ) / ( MEGA * ttrust );
   else               mftrust = 0.0;
   ttrust /= reps; *TTRUST0 = ttrust; *MFTRUST0 = mftrust;
/*
 * Generate the random data and time the tested routine
 */
   alph = alpha; y = Y; x = X; a = A;

   Mjoin( PATL, gegen )( lY, 1, Y0, lY, Yseed );
   Mjoin( PATL, gegen )( lX, 1, X0, lX, Xseed );
   Mjoin( PATL, gegen )( lA, 1, A0, lA, Aseed );
@RANK R2
   bet = beta; z = Z; w = W;
   Mjoin( PATL, gegen )( lW, 1, W0, lW, Wseed );
   Mjoin( PATL, gegen )( lZ, 1, Z0, lZ, Zseed );
@RANK !

   if( ROUT == GERU )
   {
      t0 = time00();
      for( ir = reps; ir; ir-- )
      {
@RANK R1
         test_geru( M, N, (SCALAR)(alph), x, INCX, y, INCY, a, LDA );
@RANK R2
         test_ger2u( M, N, (SCALAR)(alph), x, INCX, y, INCY, 
                     (SCALAR)(bet), w, INCW, z, INCZ, a, LDA );
         w += incw; if( w == stW ) { w = W; }
         z += incz; if( z == stZ ) { z = Z; }
@RANK !
         y += incy; if( y == stY ) { y = Y; }
         x += incx; if( x == stX ) { x = X; }
         a += inca;
         if( a == stA )
@RANK R1
         { a = A; if( alph == alpha ) alph = nalpha; else alph = alpha; }
@RANK R2
         { 
            a = A; 
            alph = (alph == alpha) ? nalpha : alpha;
            bet = (bet == beta) ? nbeta : beta;
         }
@RANK !
      }
      ttest = time00() - t0;
   }
   else
   {
      t0 = time00();
      for( ir = reps; ir; ir-- )
      {
@RANK R1
         test_gerc( M, N, (SCALAR)(alph), x, INCX, y, INCY, a, LDA );
@RANK R2
         test_ger2c( M, N, (SCALAR)(alph), x, INCX, y, INCY, 
                     (SCALAR)(bet), w, INCW, z, INCZ, a, LDA );
         w += incw; if( w == stW ) { w = W; }
         z += incz; if( z == stZ ) { z = Z; }
@RANK !
         y += incy; if( y == stY ) { y = Y; }
         x += incx; if( x == stX ) { x = X; }
         a += inca;
         if( a == stA )
@RANK R1
         { a = A; if( alph == alpha ) alph = nalpha; else alph = alpha; }
@RANK R2
         { 
            a = A; 
            alph = (alph == alpha) ? nalpha : alpha;
            bet = (bet == beta) ? nbeta : beta;
         }
@RANK !
      }
      ttest = time00() - t0;
   }
   if( ttest  > 0.0 ) mftest  = ( reps * flops ) / ( MEGA * ttest  );
   else               mftest  = 0.0;
   ttest  /= reps; *TTEST0  = ttest;  *MFTEST0  = mftest;
/*
 * release the memory and exit
 */
@RANK R2
   free( Z0 );
   free( W0 );
@RANK !
   free( Y0 );
   free( X0 );
   free( A0 );
 
   return( passed );
} 
   @undef rr
   @killkeys RANK
@endwhile

int sr1case
(
   const int                  CACHESIZE,
   const enum LVL2_ROUT       ROUT,
   const int                  TEST,
   const int                  MFLOP,
   const enum ATLAS_UPLO      UPLO,
   const int                  N,
   const TYPE                 ALPHA,
   const int                  INCX,
   const int                  LDA,
   const TYPE                 EPSILON,
   double                     * TTRUST0,
   double                     * TTEST0,
   double                     * MFTRUST0,
   double                     * MFTEST0
)
{ 
   double                     flops, ttrust, ttest, mftrust, mftest, t0;
   TYPE                       alph,  alpha, nalpha, resid = ATL_rzero;
   TYPE                       * a, * stA, * stX, * x, * A, * A0 = NULL, * X,
                              * X0 = NULL;
   unsigned long              ir, reps;
   int                        aincX, inca, incx, lX, lA, mA, nA, passed,
                              Aseed, Xseed;

   if( ( MEGA * MFLOP <= ( flops = opbl2( ROUT, N, N, 0, 0 ) ) ) || ( TEST ) )
   { 
      resid = sr1tst( CACHESIZE, ROUT, TEST, UPLO, N, ALPHA, INCX, LDA,
		     EPSILON, TTRUST0, TTEST0, MFTRUST0, MFTEST0 );
      if( resid > THRESH ) (void) fprintf( stderr, "   resid=%f\n", resid );
   }
   if( resid < ATL_rzero ) passed = -1;
   else                    passed = ( resid < THRESH );
 
   if( MEGA * MFLOP <= flops ) return( passed );

   if( ROUT == SPR ) { mA = ( N * ( N + 1 ) ) >> 1; nA = 1; }
   else              { mA = N;                      nA = N; }
 
   incx = INCX * ( N  SHIFT ); aincX = Mabs( INCX );
   if( ROUT == SPR ) inca = ( mA SHIFT );
   else              inca = LDA  * ( nA SHIFT );
 
   lX = N * aincX * ( ( ATL_DivBySize( LCSIZE ) + N       - 1 ) / N           );
   lA =     inca  * ( ( ATL_DivBySize( LCSIZE ) + 2*mA*nA - 1 ) / ( mA * nA ) );
 
   X0 = (TYPE *)malloc( ATL_MulBySize( lX ) );
   A0 = (TYPE *)malloc( ATL_MulBySize( lA ) );
 
   if( ( X0 == NULL ) || ( A0 == NULL ) )
   {
      if( X0 ) free( X0 );
      if( A0 ) free( A0 );
      return( -1 );
   }
 
   if( INCX < 1 ) { X = X0 + ( lX SHIFT ); stX = X0; }
   else           { X = X0; stX = X0 + ( lX SHIFT ); }
   A = A0; stA = A0 + ( lA SHIFT );

   alpha  =  ALPHA;
   nalpha = -ALPHA;

   Xseed = N * aincX + 127 * 50 + 77;
   Aseed = N * N     + 513 *  7 + 90;

   reps = ( MEGA * MFLOP ) / flops;
/*
 * Generate the random data and time the trusted routine
 */
   alph = alpha; x = X; a = A;

   Mjoin( PATL, gegen )( lX, 1, X0, lX, Xseed );
   Mjoin( PATL, gegen )( lA, 1, A0, lA, Aseed );

   if(      ROUT == SPR )
   {
      t0 = time00();
      for( ir = reps; ir; ir-- )
      {
#ifdef TREAL
         trusted_spr( UPLO, N, (SCALAR)(alph), x, INCX, a      );
#else
         trusted_spr( UPLO, N, (TYPE  )(alph), x, INCX, a      );
#endif
         x += incx; if( x == stX ) { x = X; }
         a += inca;
         if( a == stA )
         { a = A; if( alph == alpha ) alph = nalpha; else alph = alpha; }
      }
      ttrust = time00() - t0;
   }
   else
   {
      t0 = time00();
      for( ir = reps; ir; ir-- )
      {
#ifdef TREAL
         trusted_syr( UPLO, N, (SCALAR)(alph), x, INCX, a, LDA );
#else
         trusted_syr( UPLO, N, (TYPE  )(alph), x, INCX, a, LDA );
#endif
         x += incx; if( x == stX ) { x = X; }
         a += inca;
         if( a == stA )
         { a = A; if( alph == alpha ) alph = nalpha; else alph = alpha; }
      }
      ttrust = time00() - t0;
   }
   if( ttrust > 0.0 ) mftrust = ( reps * flops ) / ( MEGA * ttrust );
   else               mftrust = 0.0;
   ttrust /= reps; *TTRUST0 = ttrust; *MFTRUST0 = mftrust;
/*
 * Generate the random data and time the tested routine
 */
   alph = alpha; x = X; a = A;

   Mjoin( PATL, gegen )( lX, 1, X0, lX, Xseed );
   Mjoin( PATL, gegen )( lA, 1, A0, lA, Aseed );

   if(      ROUT == SPR )
   {
      t0 = time00();
      for( ir = reps; ir; ir-- )
      {
#ifdef TREAL
         test_spr( UPLO, N, (SCALAR)(alph), x, INCX, a      );
#else
         test_spr( UPLO, N, (TYPE  )(alph), x, INCX, a      );
#endif
         x += incx; if( x == stX ) { x = X; }
         a += inca;
         if( a == stA )
         { a = A; if( alph == alpha ) alph = nalpha; else alph = alpha; }
      }
      ttest = time00() - t0;
   }
   else
   {
      t0 = time00();
      for( ir = reps; ir; ir-- )
      {
#ifdef TREAL
         test_syr( UPLO, N, (SCALAR)(alph), x, INCX, a, LDA );
#else
         test_syr( UPLO, N, (TYPE  )(alph), x, INCX, a, LDA );
#endif
         x += incx; if( x == stX ) { x = X; }
         a += inca;
         if( a == stA )
         { a = A; if( alph == alpha ) alph = nalpha; else alph = alpha; }
      }
      ttest = time00() - t0;
   }
   if( ttest  > 0.0 ) mftest  = ( reps * flops ) / ( MEGA * ttest  );
   else               mftest  = 0.0;
   ttest  /= reps; *TTEST0  = ttest;  *MFTEST0  = mftest;
/*
 * release the memory and exit
 */
   free( X0 );
   free( A0 );
 
   return( passed );
}

int sr2case
(
   const int                  CACHESIZE,
   const enum LVL2_ROUT       ROUT,
   const int                  TEST,
   const int                  MFLOP,
   const enum ATLAS_UPLO      UPLO,
   const int                  N,
   const SCALAR               ALPHA,
   const int                  INCX,
   const int                  INCY,
   const int                  LDA,
   const TYPE                 EPSILON,
   double                     * TTRUST0,
   double                     * TTEST0,
   double                     * MFTRUST0,
   double                     * MFTEST0
)
{
   double                     flops, ttrust, ttest, mftrust, mftest, t0;
   TYPE                       resid = ATL_rzero;
#ifdef TREAL
   TYPE                       alph,  alpha,    nalpha;
#else
   TYPE                       *alph, alpha[2], nalpha[2];
#endif
   TYPE                       * a, * stA, * stX, * stY, * x, * y, * A,
                              * A0 = NULL, * X, * X0 = NULL, * Y, * Y0 = NULL;
   unsigned long              ir, reps;
   int                        aincX, aincY, inca, incx, incy, lX, lY, lA,
                              mA, nA, passed, Aseed, Xseed, Yseed;

   if( ( MEGA * MFLOP <= ( flops = opbl2( ROUT, N, N, 0, 0 ) ) ) || ( TEST ) )
   { 
      resid = sr2tst( CACHESIZE, ROUT, TEST, UPLO, N, ALPHA, INCX, INCY, LDA,
                      EPSILON, TTRUST0, TTEST0, MFTRUST0, MFTEST0 );
      if( resid > THRESH ) (void) fprintf( stderr, "   resid=%f\n", resid );
   }
   if( resid < ATL_rzero ) passed = -1;
   else                    passed = ( resid < THRESH );
 
   if( MEGA * MFLOP <= flops ) return( passed );

   if( ROUT == SPR2 ) { mA = ( N * ( N + 1 ) ) >> 1; nA = 1; }
   else               { mA = N;                      nA = N; }
 
   incy = INCY * ( N  SHIFT ); aincY = Mabs( INCY );
   incx = INCX * ( N  SHIFT ); aincX = Mabs( INCX );
   if( ROUT == SPR2 ) inca = ( mA SHIFT );
   else               inca = LDA  * ( nA SHIFT );
 
   lY = N * aincY * ( ( ATL_DivBySize( LCSIZE ) + N       - 1 ) / N           );
   lX = N * aincX * ( ( ATL_DivBySize( LCSIZE ) + N       - 1 ) / N           );
   lA =     inca  * ( ( ATL_DivBySize( LCSIZE ) + 2*mA*nA - 1 ) / ( mA * nA ) );
 
   Y0 = (TYPE *)malloc( ATL_MulBySize( lY ) );
   X0 = (TYPE *)malloc( ATL_MulBySize( lX ) );
   A0 = (TYPE *)malloc( ATL_MulBySize( lA ) );
 
   if( ( Y0 == NULL ) || ( X0 == NULL ) || ( A0 == NULL ) )
   {
      if( Y0 ) free( Y0 );
      if( X0 ) free( X0 );
      if( A0 ) free( A0 );
      return( -1 );
   }
 
   if( INCY < 1 ) { Y = Y0 + ( lY SHIFT ); stY = Y0; }
   else           { Y = Y0; stY = Y0 + ( lY SHIFT ); }
   if( INCX < 1 ) { X = X0 + ( lX SHIFT ); stX = X0; }
   else           { X = X0; stX = X0 + ( lX SHIFT ); }
   A = A0; stA = A0 + ( lA SHIFT );
 
#ifdef TREAL
   alpha   =  ALPHA;
   nalpha  = -ALPHA;
#else
   *alpha  =  (*ALPHA); alpha [1] =  ALPHA[1];
   *nalpha = -(*ALPHA); nalpha[1] = -ALPHA[1];
#endif
 
   Yseed = N * aincY;
   Xseed = N * aincX + 127 * 50 + 77;
   Aseed = N * N     + 513 *  7 + 90;
 
   reps = ( MEGA * MFLOP ) / flops;
/*
 * Generate the random data and time the trusted routine
 */
   alph = alpha; y = Y; x = X; a = A;

   Mjoin( PATL, gegen )( lY, 1, Y0, lY, Yseed );
   Mjoin( PATL, gegen )( lX, 1, X0, lX, Xseed );
   Mjoin( PATL, gegen )( lA, 1, A0, lA, Aseed );

   if(      ROUT == SPR2 )
   {
      t0 = time00();
      for( ir = reps; ir; ir-- )
      {
         trusted_spr2( UPLO, N, (SCALAR)(alph), x, INCX, y, INCY, a      );
         y += incy; if( y == stY ) { y = Y; }
         x += incx; if( x == stX ) { x = X; }
         a += inca;
         if( a == stA )
         { a = A; if( alph == alpha ) alph = nalpha; else alph = alpha; }
      }
      ttrust = time00() - t0;
   }
   else
   {
      t0 = time00();
      for( ir = reps; ir; ir-- )
      {
         trusted_syr2( UPLO, N, (SCALAR)(alph), x, INCX, y, INCY, a, LDA );
         y += incy; if( y == stY ) { y = Y; }
         x += incx; if( x == stX ) { x = X; }
         a += inca;
         if( a == stA )
         { a = A; if( alph == alpha ) alph = nalpha; else alph = alpha; }
      }
      ttrust = time00() - t0;
   }
   if( ttrust > 0.0 ) mftrust = ( reps * flops ) / ( MEGA * ttrust );
   else               mftrust = 0.0;
   ttrust /= reps; *TTRUST0 = ttrust; *MFTRUST0 = mftrust;
/*
 * Generate the random data and time the tested routine
 */
   alph = alpha; y = Y; x = X; a = A;
 
   Mjoin( PATL, gegen )( lY, 1, Y0, lY, Yseed );
   Mjoin( PATL, gegen )( lX, 1, X0, lX, Xseed );
   Mjoin( PATL, gegen )( lA, 1, A0, lA, Aseed );

   if(      ROUT == SPR2 )
   {
      t0 = time00();
      for( ir = reps; ir; ir-- )
      {
         test_spr2( UPLO, N, (SCALAR)(alph), x, INCX, y, INCY, a      );
         y += incy; if( y == stY ) { y = Y; }
         x += incx; if( x == stX ) { x = X; }
         a += inca;
         if( a == stA )
         { a = A; if( alph == alpha ) alph = nalpha; else alph = alpha; }
      }
      ttest = time00() - t0;
   }
   else
   {
      t0 = time00();
      for( ir = reps; ir; ir-- )
      {
         test_syr2( UPLO, N, (SCALAR)(alph), x, INCX, y, INCY, a, LDA );
         y += incy; if( y == stY ) { y = Y; }
         x += incx; if( x == stX ) { x = X; }
         a += inca;
         if( a == stA )
         { a = A; if( alph == alpha ) alph = nalpha; else alph = alpha; }
      }
      ttest = time00() - t0;
   }
   if( ttest  > 0.0 ) mftest  = ( reps * flops ) / ( MEGA * ttest  );
   else               mftest  = 0.0;
   ttest  /= reps; *TTEST0  = ttest;  *MFTEST0  = mftest;
/*
 * release the memory and exit
 */
   free( Y0 );
   free( X0 );
   free( A0 );
 
   return( passed );
}

void RungbmCase
(
   const int                  CACHESIZE,
   const enum LVL2_ROUT       ROUT,
   const int                  TEST,
   const int                  MFLOP,
   const int                  LDA_IS_M,
   const int                  NTRAN,
   const enum ATLAS_TRANS     * TRANS,
   int                        M0,
   int                        MN,
   int                        MINC,
   int                        N0,
   int                        NN,
   int                        NINC,
   int                        KL0,
   int                        KLN,
   int                        KLINC,
   int                        KU0,
   int                        KUN,
   int                        KUINC,
   const int                  NALPHA,
   const TYPE                 * ALPHAS,
   const int                  NBETA,
   const TYPE                 * BETAS,
   const int                  NINCX,
   const int                  * INCXS,
   const int                  NINCY,
   const int                  * INCYS,
   const TYPE                 EPSILON,
   int                        * NPASSED,
   int                        * NTESTS
)
{
   double                     t0, mftrust, mftest, ttrust, ttest;
   char                       * pass, * form;
   int                        al, be, ires, ix, iy, kkl, kku, lda, m, mm, n,
                              nn, ta, msame=0;
   char                       ctran;

   if( M0 == -1 ) { M0 = MN = MINC = NN; msame = 1; }

#ifdef TREAL
   (void) fprintf( stdout, "\n%s%s%s\n",
                   "---------------------------------- ", "GBMV",
                   " -----------------------------------" );
   (void) fprintf( stdout, "%s%s",
                   "TST# T    M    N   KL   KU ALPHA  LDA INCX  BETA",
                   " INCY  TIME MFLOP SpUp TEST\n" );
   (void) fprintf( stdout, "%s%s",
                   "==== = ==== ==== ==== ==== ===== ==== ==== =====",
                   " ==== ===== ===== ==== ====\n" );
form = "%4d %c %4d %4d %4d %4d %5.1f %4d %4d %5.1f %4d %5.2f %5.1f %4.2f %4s\n";
#else
   (void) fprintf( stdout, "\n%s%s%s\n",
                   "----------------------------------- ", "GBMV",
                   " ---------------------------------------" );
   (void) fprintf( stdout, "%s%s",
                   "TST# T    M    N   KL   KU    ALPHA  LDA INCX",
                   "     BETA INCY TIME MFLOP SpUp TEST\n" );
   (void) fprintf( stdout, "%s%s",
                   "==== = ==== ==== ==== ==== ======== ==== ====",
                   " ======== ==== ==== ===== ==== ====\n" );
form =
"%4d %c %4d %4d %4d %4d %4.1f%4.1f %4d %4d %4.1f%4.1f %4d %4.1f %5.1f %4.2f %4s\n";
#endif 

   for( mm = M0; mm <= MN; mm += MINC )
   {
      for( nn = N0; nn <= NN; nn += NINC )
      {
         n = nn; if( msame ) m = n; else m = mm;
 
         for( kkl = KL0; kkl <= KLN; kkl += KLINC )
         {
            for( kku = KU0; kku <= KUN; kku += KUINC )
            {
               if( LDA_IS_M ) lda = kkl+1+kku;
               else           lda = KLN+1+KUN;

               for( ta = 0; ta < NTRAN; ta++ )
               {
                  if(      TRANS[ta] == AtlasNoTrans   ) ctran = 'N';
                  else if( TRANS[ta] == AtlasTrans     ) ctran = 'T';
                  else                                   ctran = 'C';
 
                  for( iy = 0; iy < NINCY; iy++ )
                  {
                     for( ix = 0; ix < NINCX; ix++ )
                     {
                        for( al = 0; al < NALPHA; al++ )
                        {
                           for( be = 0; be < NBETA; be++ )
                           {
#ifdef TREAL
                              ires = gmvcase( CACHESIZE, ROUT, TEST, MFLOP,
					      TRANS[ta], m, n, kkl, kku,
					      ALPHAS[al], lda,
                                              INCXS[ix], BETAS[be], INCYS[iy],
                                              EPSILON, &ttrust, &ttest,
                                              &mftrust, &mftest );
#else
                              ires = gmvcase( CACHESIZE, ROUT, TEST, MFLOP,
					      TRANS[ta], m, n, kkl, kku,
					      ALPHAS+2*al, lda,
                                              INCXS[ix], BETAS+2*be, INCYS[iy],
                                              EPSILON, &ttrust, &ttest,
                                              &mftrust, &mftest );
#endif
                              if(     !( TEST ) ) pass = "SKIP";
                              else if( ires < 0 ) pass = "NoMEM";
                              else if( ires     ) pass = "PASS";
                              else                pass = "FAIL";
 
                              if( ires > 0 ) (*NPASSED)++;
 
                              if( ( mftrust > 0.0 ) && ( mftest > 0.0 ) )
                                 t0 = mftest / mftrust;
                              else t0 = 0.0;
#ifdef TREAL
                              (void) fprintf( stdout, form, *NTESTS, ctran, m,
                                              n, kkl, kku, ALPHAS[al], lda,
                                              INCXS[ix], BETAS[be], INCYS[iy],
                                              ttrust, mftrust, 1.0, "----" );
                              (void) fprintf( stdout, form, *NTESTS, ctran, m,
                                              n, kkl, kku, ALPHAS[al], lda,
                                              INCXS[ix], BETAS[be], INCYS[iy],
                                              ttest,  mftest,  t0,  pass );
#else
                              (void) fprintf( stdout, form, *NTESTS, ctran,
                                              m, n, kkl, kku, ALPHAS[2*al], 
                                              ALPHAS[2*al+1], lda, INCXS[ix],
                                              BETAS[2*be], BETAS[2*be+1],
                                              INCYS[iy], ttrust, mftrust, 1.0,
                                              "----" );
                              (void) fprintf( stdout, form, *NTESTS, ctran,
                                              m, n, kkl, kku, ALPHAS[2*al],
                                              ALPHAS[2*al+1], lda, INCXS[ix],
                                              BETAS[2*be], BETAS[2*be+1],
                                              INCYS[iy], ttest,  mftest,  t0,
                                              pass );
#endif
                              (*NTESTS)++; 
                           }
                        }
                     }
                  }
               }
            }
         }
      }
   }
}

void RungemCase
(
   const int                  CACHESIZE,
   const enum LVL2_ROUT       ROUT,
   const int                  TEST,
   const int                  MFLOP,
   const int                  LDA_IS_M,
   const int                  NTRAN,
   const enum ATLAS_TRANS     * TRANS,
   int                        M0,
   int                        MN,
   int                        MINC,
   int                        N0,
   int                        NN,
   int                        NINC,
   const int                  NALPHA,
   const TYPE                 * ALPHAS,
   const int                  NBETA,
   const TYPE                 * BETAS,
   const int                  NINCX,
   const int                  * INCXS,
   const int                  NINCY,
   const int                  * INCYS,
   const TYPE                 EPSILON,
   int                        * NPASSED,
   int                        * NTESTS
)
{
   double                     t0, mftrust, mftest, ttrust, ttest;
   char                       * pass, * form;
   int                        al, be, ires, ix, iy, lda, m, mm, msame=0, n,
                              nn, ta;
   char                       ctran;
 
   if( M0 == -1 ) { M0 = MN = MINC = NN; msame = 1; }

#ifdef TREAL
   (void) fprintf( stdout, "\n%s%s%s\n",
                   "------------------------------- ", "GEMV",
                   " --------------------------------" );
   (void) fprintf( stdout, "%s%s",
                   "TST# TR    M    N ALPHA  LDA INCX  BETA INCY",
                   "   TIME MFLOP  SpUp  TEST\n" );
   (void) fprintf( stdout, "%s%s",
                   "==== == ==== ==== ===== ==== ==== ===== ====",
                   " ====== ===== ===== =====\n" );
form = "%4d  %c %4d %4d %5.1f %4d %4d %5.1f %4d %6.2f %5.1f %5.2f %5s\n";
#else
   (void) fprintf( stdout, "\n%s%s%s\n",
                   "----------------------------------- ", "GEMV",
                   " ------------------------------------" );
   (void) fprintf( stdout, "%s%s",
                   "TST# TR    M    N     ALPHA  LDA INCX      BETA",
                   " INCY   TIME MFLOP  SpUp  TEST\n" );
   (void) fprintf( stdout, "%s%s",
                   "==== == ==== ==== ==== ==== ==== ==== ==== ====",
                   " ==== ====== ===== ===== =====\n" );
form =
"%4d  %c %4d %4d %4.1f %4.1f %4d %4d %4.1f %4.1f %4d %6.2f %5.1f %5.2f %5s\n";
#endif

   for( mm = M0; mm <= MN; mm += MINC )
   {
      for( nn = N0; nn <= NN; nn += NINC )
      {
         n = nn; if( msame ) m = n; else m = mm;
 
         for( ta = 0; ta < NTRAN; ta++ )
         {
            if(      TRANS[ta] == AtlasNoTrans ) ctran = 'N';
            else if( TRANS[ta] == AtlasTrans   ) ctran = 'T';
            else                                 ctran = 'C';
 
            if( LDA_IS_M ) lda = m; 
            else lda = MN; 

            for( iy = 0; iy < NINCY; iy++ )
            {
               for( ix = 0; ix < NINCX; ix++ )
               {
                  for( al = 0; al < NALPHA; al++ )
                  {
                     for( be = 0; be < NBETA; be++ )
                     {
#ifdef TREAL
                        ires = gmvcase( CACHESIZE, ROUT, TEST, MFLOP,
					TRANS[ta], m, n, 0, 0, ALPHAS[al],
					lda, INCXS[ix], BETAS[be], INCYS[iy],
                                        EPSILON, &ttrust, &ttest, &mftrust,
                                        &mftest );
#else
                        ires = gmvcase( CACHESIZE, ROUT, TEST, MFLOP,
					TRANS[ta], m, n, 0, 0, ALPHAS+2*al,
					lda, INCXS[ix], BETAS+2*be, INCYS[iy],
                                        EPSILON, &ttrust, &ttest, &mftrust,
                                        &mftest );
#endif
                        if(     !( TEST ) ) pass = "SKIP ";
                        else if( ires < 0 ) pass = "NoMEM";
                        else if( ires     ) pass = "PASS ";
                        else                pass = "FAIL ";
 
                        if( ires > 0 ) (*NPASSED)++;

                        if( ( mftrust > 0.0 ) && ( mftest > 0.0 ) )
                           t0 = mftest / mftrust;
                        else t0 = 0.0;
#ifdef TREAL
                        (void) fprintf( stdout, form, *NTESTS, ctran, m,
                                        n, ALPHAS[al], lda, INCXS[ix],
                                        BETAS[be], INCYS[iy], ttrust,
                                        mftrust, 1.0, "-----" );
                        (void) fprintf( stdout, form, *NTESTS, ctran, m,
                                        n, ALPHAS[al], lda, INCXS[ix],
                                        BETAS[be], INCYS[iy], ttest,
                                        mftest,  t0,  pass );
#else
                        (void) fprintf( stdout, form, *NTESTS, ctran, m,
                                        n, ALPHAS[2*al], ALPHAS[2*al+1],
                                        lda, INCXS[ix], BETAS[2*be],
                                        BETAS[2*be+1], INCYS[iy], ttrust,
                                        mftrust, 1.0, "-----" );
                        (void) fprintf( stdout, form, *NTESTS, ctran, m,
                                        n, ALPHAS[2*al], ALPHAS[2*al+1],
                                        lda, INCXS[ix], BETAS[2*be],
                                        BETAS[2*be+1], INCYS[iy], ttest,
                                        mftest,  t0,  pass );
#endif
                        (*NTESTS)++; 
                     }
                  }
               }
            }
         }
      }
   }
}

void RunsbCase
(
   const int                  CACHESIZE,
   const enum LVL2_ROUT       ROUT,
   const int                  TEST,
   const int                  MFLOP,
   const int                  LDA_IS_M,
   const int                  NUPLO,
   const enum ATLAS_UPLO      * UPLOS,
   int                        N0,
   int                        NN,
   int                        NINC,
   int                        KL0,
   int                        KLN,
   int                        KLINC,
   int                        KU0,
   int                        KUN,
   int                        KUINC,
   const int                  NALPHA,
   const TYPE                 * ALPHAS,
   const int                  NBETA,
   const TYPE                 * BETAS,
   const int                  NINCX,
   const int                  * INCXS,
   const int                  NINCY,
   const int                  * INCYS,
   const TYPE                 EPSILON,
   int                        * NPASSED,
   int                        * NTESTS
)
{
   double                     t0, mftrust, mftest, ttrust, ttest;
   char                       * pass, * form;
   int                        al, be, ires, ix, iy, kkl, kku, lda, nn, up;
   char                       cuplo;
 
#ifdef TREAL
   (void) fprintf( stdout, "\n%s%s%s\n",
                   "------------------------------- ", "SBMV",
                   " --------------------------------" );
   (void) fprintf( stdout, "%s%s",
                   "TST# UP    N    K ALPHA  LDA INCX  BETA INCY",
                   "   TIME MFLOP  SpUp  TEST\n" );
   (void) fprintf( stdout, "%s%s",
                   "==== == ==== ==== ===== ==== ==== ===== ====",
                   " ====== ===== ===== =====\n" );
   form = "%4d  %c %4d %4d %5.1f %4d %4d %5.1f %4d %6.2f %5.1f %5.2f %5s\n";
#else
   (void) fprintf( stdout, "\n%s%s%s\n",
                   "------------------------------------ ", "HBMV",
                   " -----------------------------------" );
   (void) fprintf( stdout, "%s%s",
                   "TST# UP    N    K     ALPHA  LDA INCX      BETA",
                   " INCY   TIME MFLOP  SpUp  TEST\n" );
   (void) fprintf( stdout, "%s%s",
                   "==== == ==== ==== ==== ==== ==== ==== ==== ====",
                   " ==== ====== ===== ===== =====\n" );
form =
"%4d  %c %4d %4d %4.1f %4.1f %4d %4d %4.1f %4.1f %4d %6.2f %5.1f %5.2f %5s\n";
#endif
   for( nn = N0; nn <= NN; nn += NINC )
   {
      for( up = 0; up < NUPLO; up++ )
      {
         if( UPLOS[up] == AtlasLower )
         {
            cuplo = 'L';
 
            for( kkl = KL0; kkl <= KLN; kkl += KLINC )
            {
               if( LDA_IS_M ) lda = kkl+1;
               else           lda = KLN+1;

               for( ix = 0; ix < NINCX; ix++ )
               {
                  for( iy = 0; iy < NINCY; iy++ )
                  {
                     for( al = 0; al < NALPHA; al++ )
                     {
                        for( be = 0; be < NBETA; be++ )
                        {
#ifdef TREAL
                           ires = smvcase( CACHESIZE, ROUT, TEST, MFLOP,
					   UPLOS[up], nn,
                                           kkl, ALPHAS[al], lda, INCXS[ix],
                                           BETAS[be], INCYS[iy], EPSILON,
                                           &ttrust, &ttest, &mftrust, &mftest );
#else
                           ires = smvcase( CACHESIZE, ROUT, TEST, MFLOP,
					   UPLOS[up], nn,
                                           kkl, ALPHAS+2*al, lda, INCXS[ix],
                                           BETAS+2*be, INCYS[iy], EPSILON,
                                           &ttrust, &ttest, &mftrust, &mftest );
#endif
                           if(     !( TEST ) ) pass = "SKIP ";
                           else if( ires < 0 ) pass = "NoMEM";
                           else if( ires     ) pass = "PASS ";
                           else                pass = "FAIL ";
 
                           if( ires > 0 ) (*NPASSED)++;
 
                           if( ( mftrust > 0.0 ) && ( mftest > 0.0 ) )
                              t0 = mftest / mftrust;
                           else t0 = 0.0;
#ifdef TREAL
                           (void) fprintf( stdout, form, *NTESTS, cuplo, nn,
                                           kkl, ALPHAS[al], lda, INCXS[ix],
                                           BETAS[be], INCYS[iy], ttrust,
                                           mftrust, 1.0, "-----" );
                           (void) fprintf( stdout, form, *NTESTS, cuplo, nn,
                                           kkl, ALPHAS[al], lda, INCXS[ix],
                                           BETAS[be], INCYS[iy], ttest,
                                           mftest,  t0,  pass );
#else
                           (void) fprintf( stdout, form, *NTESTS, cuplo, nn,
                                           kkl, ALPHAS[2*al], ALPHAS[2*al+1],
                                           lda, INCXS[ix], BETAS[2*be],
                                           BETAS[2*be+1], INCYS[iy], ttrust,
                                           mftrust, 1.0, "-----" );
                           (void) fprintf( stdout, form, *NTESTS, cuplo, nn,
                                           kkl, ALPHAS[2*al], ALPHAS[2*al+1],
                                           lda, INCXS[ix], BETAS[2*be],
                                           BETAS[2*be+1], INCYS[iy], ttest,
                                           mftest,  t0,  pass );
#endif
                           (*NTESTS)++;  
                        }
                     }
                  }
               }
            }
         }
         else 
         {
            cuplo = 'U';
 
            for( kku = KU0; kku <= KUN; kku += KUINC )
            {
               if( LDA_IS_M ) lda = 1+kku;
               else           lda = 1+KUN;

               for( ix = 0; ix < NINCX; ix++ )
               {
                  for( iy = 0; iy < NINCY; iy++ )
                  {
                     for( al = 0; al < NALPHA; al++ )
                     {
                        for( be = 0; be < NBETA; be++ )
                        {
#ifdef TREAL
                           ires = smvcase( CACHESIZE, ROUT, TEST, MFLOP,
					   UPLOS[up], nn,
                                           kku, ALPHAS[al], lda, INCXS[ix],
                                           BETAS[be], INCYS[iy], EPSILON,
                                           &ttrust, &ttest, &mftrust, &mftest );
#else
                           ires = smvcase( CACHESIZE, ROUT, TEST, MFLOP,
					   UPLOS[up], nn,
                                           kku, ALPHAS+2*al, lda, INCXS[ix],
                                           BETAS+2*be, INCYS[iy], EPSILON,
                                           &ttrust, &ttest, &mftrust, &mftest );
#endif
                           if(     !( TEST ) ) pass = "SKIP ";
                           else if( ires < 0 ) pass = "NoMEM";
                           else if( ires     ) pass = "PASS ";
                           else                pass = "FAIL ";
 
                           if( ires > 0 ) (*NPASSED)++;
 
                           if( ( mftrust > 0.0 ) && ( mftest > 0.0 ) )
                              t0 = mftest / mftrust;
                           else t0 = 0.0;
#ifdef TREAL
                           (void) fprintf( stdout, form, *NTESTS, cuplo, nn,
                                           kku, ALPHAS[al], lda, INCXS[ix],
                                           BETAS[be], INCYS[iy], ttrust,
                                           mftrust, 1.0, "-----" );
                           (void) fprintf( stdout, form, *NTESTS, cuplo, nn,
                                           kku, ALPHAS[al], lda, INCXS[ix],
                                           BETAS[be], INCYS[iy], ttest,
                                           mftest,  t0,  pass );
#else
                           (void) fprintf( stdout, form, *NTESTS, cuplo, nn,
                                           kku, ALPHAS[2*al], ALPHAS[2*al+1],
                                           lda, INCXS[ix], BETAS[2*be],
                                           BETAS[2*be+1], INCYS[iy], ttrust,
                                           mftrust, 1.0, "-----" );
                           (void) fprintf( stdout, form, *NTESTS, cuplo, nn,
                                           kku, ALPHAS[2*al], ALPHAS[2*al+1],
                                           lda, INCXS[ix], BETAS[2*be],
                                           BETAS[2*be+1], INCYS[iy], ttest,
                                           mftest,  t0,  pass );
#endif
                           (*NTESTS)++;
                        }
                     }
                  }
               }
            }
         }
      }
   }
}

void RunspCase
(
   const int                  CACHESIZE,
   const enum LVL2_ROUT       ROUT,
   const int                  TEST,
   const int                  MFLOP,
   const int                  NUPLO,
   const enum ATLAS_UPLO      * UPLOS,
   const int                  N0,
   const int                  NN,
   const int                  NINC,
   const int                  NALPHA,
   const TYPE                 * ALPHAS,
   const int                  NBETA,
   const TYPE                 * BETAS,
   const int                  NINCX,
   const int                  * INCXS,
   const int                  NINCY,
   const int                  * INCYS,
   const TYPE                 EPSILON,
   int                        * NPASSED,
   int                        * NTESTS
)
{
   double                     t0, mftrust, mftest, ttrust, ttest;
   char                       * pass, * form;
   int                        al, be, ires, ix, iy, nn, up;
   char                       cuplo;

#ifdef TREAL
   (void) fprintf( stdout, "\n%s%s%s\n",
                   "-------------------------- ", "SPMV",
                   " ---------------------------" );
   (void) fprintf( stdout, "%s%s",
                   "TST# UP    N ALPHA INCX  BETA INCY",
                   "   TIME MFLOP  SpUp  TEST\n" );
   (void) fprintf( stdout, "%s%s",
                   "==== == ==== ===== ==== ===== ====",
                   " ====== ===== ===== =====\n" );
   form = "%4d  %c %4d %5.1f %4d %5.1f %4d %6.2f %5.1f %5.2f %5s\n";
#else
   (void) fprintf( stdout, "\n%s%s%s\n",
                   "------------------------------ ", "HPMV",
                   " -------------------------------" );
   (void) fprintf( stdout, "%s%s",
                   "TST# UP    N     ALPHA INCX      BETA",
                   " INCY   TIME MFLOP  SpUp  TEST\n" );
   (void) fprintf( stdout, "%s%s",
                   "==== == ==== ==== ==== ==== ==== ====",
                   " ==== ====== ===== ===== =====\n" );
   form = "%4d  %c %4d %4.1f %4.1f %4d %4.1f %4.1f %4d %6.2f %5.1f %5.2f %5s\n";
#endif
   for( nn = N0; nn <= NN; nn += NINC )
   {
      for( up = 0; up < NUPLO; up++ )
      {
         if( UPLOS[up] == AtlasLower ) cuplo = 'L';
         else                          cuplo = 'U';
 
         for( ix = 0; ix < NINCX; ix++ )
         {
            for( iy = 0; iy < NINCY; iy++ )
            {
               for( al = 0; al < NALPHA; al++ )
               {
                  for( be = 0; be < NBETA; be++ )
                  {
#ifdef TREAL
                     ires = smvcase( CACHESIZE, ROUT, TEST, MFLOP,
				     UPLOS[up], nn, 0,
                                     ALPHAS[al], 1, INCXS[ix], BETAS[be],
                                     INCYS[iy], EPSILON, &ttrust, &ttest,
                                     &mftrust, &mftest );
#else
                     ires = smvcase( CACHESIZE, ROUT, TEST, MFLOP,
				     UPLOS[up], nn, 0,
                                     ALPHAS+2*al, 1, INCXS[ix], BETAS+2*be,
                                     INCYS[iy], EPSILON, &ttrust, &ttest,
                                     &mftrust, &mftest );
#endif
                     if(     !( TEST ) ) pass = "SKIP ";
                     else if( ires < 0 ) pass = "NoMEM";
                     else if( ires     ) pass = "PASS ";
                     else                pass = "FAIL ";
 
                     if( ires > 0 ) (*NPASSED)++;
 
                     if( ( mftrust > 0.0 ) && ( mftest > 0.0 ) )
                        t0 = mftest / mftrust;
                     else t0 = 0.0;
#ifdef TREAL
                     (void) fprintf( stdout, form, *NTESTS, cuplo, nn,
                                     ALPHAS[al], INCXS[ix], BETAS[be],
                                     INCYS[iy], ttrust, mftrust, 1.0,
                                     "-----" );
                     (void) fprintf( stdout, form, *NTESTS, cuplo, nn,
                                     ALPHAS[al], INCXS[ix], BETAS[be],
                                     INCYS[iy], ttest, mftest, t0, pass );
#else
                     (void) fprintf( stdout, form, *NTESTS, cuplo, nn,
                                     ALPHAS[2*al], ALPHAS[2*al+1],
                                     INCXS[ix], BETAS[2*be], BETAS[2*be+1],
                                     INCYS[iy], ttrust, mftrust, 1.0,
                                     "-----" );
                     (void) fprintf( stdout, form, *NTESTS, cuplo, nn,
                                     ALPHAS[2*al], ALPHAS[2*al+1],
                                     INCXS[ix], BETAS[2*be], BETAS[2*be+1],
                                     INCYS[iy], ttest, mftest, t0, pass );
#endif
                     (*NTESTS)++;
                  }
               }
            }
         }
      }
   }
} 

void RunsyCase
(
   const int                  CACHESIZE,
   const enum LVL2_ROUT       ROUT,
   const int                  TEST,
   const int                  MFLOP,
   const int                  LDA_IS_M,
   const int                  NUPLO,
   const enum ATLAS_UPLO      * UPLOS,
   int                        N0,
   int                        NN,
   int                        NINC,
   const int                  NALPHA,
   const TYPE                 * ALPHAS,
   const int                  NBETA,
   const TYPE                 * BETAS,
   const int                  NINCX,
   const int                  * INCXS,
   const int                  NINCY,
   const int                  * INCYS,
   const TYPE                 EPSILON,
   int                        * NPASSED,
   int                        * NTESTS
)
{
   double                     t0, mftrust, mftest, ttrust, ttest;
   char                       * pass, * form;
   int                        al, be, ires, ix, iy, lda, nn, up;
   char                       cuplo;

#ifdef TREAL
   (void) fprintf( stdout, "\n%s%s%s\n",
                   "----------------------------- ", "SYMV",
                   " -----------------------------" );
   (void) fprintf( stdout, "%s%s",
                   "TST# UP    N ALPHA  LDA INCX  BETA INCY",
                   "   TIME MFLOP  SpUp  TEST\n" );
   (void) fprintf( stdout, "%s%s",
                   "==== == ==== ===== ==== ==== ===== ====",
                   " ====== ===== ===== =====\n" );
   form = "%4d  %c %4d %5.1f %4d %4d %5.1f %4d %6.2f %5.1f %5.2f %5s\n";
#else
   (void) fprintf( stdout, "\n%s%s%s\n",
                   "--------------------------------- ", "HEMV",
                   " ---------------------------------" );
   (void) fprintf( stdout, "%s%s",
                   "TST# UP    N     ALPHA  LDA INCX      BETA",
                   " INCY   TIME MFLOP  SpUp  TEST\n" );
   (void) fprintf( stdout, "%s%s",
                   "==== == ==== ==== ==== ==== ==== ==== ====",
                   " ==== ====== ===== ===== =====\n" );
form =
"%4d  %c %4d %4.1f %4.1f %4d %4d %4.1f %4.1f %4d %6.2f %5.1f %5.2f %5s\n";
#endif
   for( nn = N0; nn <= NN; nn += NINC )
   {
      if( LDA_IS_M ) lda = Mmax( 1, nn ); else lda = NN;

      for( up = 0; up < NUPLO; up++ )
      {
         if( UPLOS[up] == AtlasLower ) cuplo = 'L';
         else                          cuplo = 'U';
 
         for( ix = 0; ix < NINCX; ix++ )
         {
            for( iy = 0; iy < NINCY; iy++ )
            {
               for( al = 0; al < NALPHA; al++ )
               {
                  for( be = 0; be < NBETA; be++ )
                  {
#ifdef TREAL
                     ires = smvcase( CACHESIZE, ROUT, TEST, MFLOP,
				     UPLOS[up], nn,
                                     0, ALPHAS[al], lda, INCXS[ix],
                                     BETAS[be], INCYS[iy], EPSILON, &ttrust,
                                     &ttest, &mftrust, &mftest );
#else
                     ires = smvcase( CACHESIZE, ROUT, TEST, MFLOP,
				     UPLOS[up], nn,
                                     0, ALPHAS+2*al, lda, INCXS[ix],
                                     BETAS+2*be, INCYS[iy], EPSILON, &ttrust,
                                     &ttest, &mftrust, &mftest );
#endif
                     if(     !( TEST ) ) pass = "SKIP ";
                     else if( ires < 0 ) pass = "NoMEM";
                     else if( ires     ) pass = "PASS ";
                     else                pass = "FAIL ";
 
                     if( ires > 0 ) (*NPASSED)++;
 
                     if( ( mftrust > 0.0 ) && ( mftest > 0.0 ) )
                        t0 = mftest / mftrust;
                     else t0 = 0.0;
#ifdef TREAL
                     (void) fprintf( stdout, form, *NTESTS, cuplo, nn,
                                     ALPHAS[al], lda, INCXS[ix],
                                     BETAS[be], INCYS[iy], ttrust,
                                     mftrust, 1.0, "-----" );
                     (void) fprintf( stdout, form, *NTESTS, cuplo, nn,
                                     ALPHAS[al], lda, INCXS[ix],
                                     BETAS[be], INCYS[iy], ttest,
                                     mftest,  t0,  pass );
#else
                     (void) fprintf( stdout, form, *NTESTS, cuplo, nn,
                                     ALPHAS[2*al], ALPHAS[2*al+1],
                                     lda, INCXS[ix], BETAS[2*be],
                                     BETAS[2*be+1], INCYS[iy], ttrust,
                                     mftrust, 1.0, "-----" );
                     (void) fprintf( stdout, form, *NTESTS, cuplo, nn,
                                     ALPHAS[2*al], ALPHAS[2*al+1],
                                     lda, INCXS[ix], BETAS[2*be],
                                     BETAS[2*be+1], INCYS[iy], ttest,
                                     mftest,  t0,  pass );
#endif
                     (*NTESTS)++;
                  }
               }
            }
         }
      }
   }
} 

void RuntbCase
(
   const int                  CACHESIZE,
   const enum LVL2_ROUT       ROUT,
   const int                  TEST,
   const int                  MFLOP,
   const int                  LDA_IS_M,
   const int                  NUPLO,
   const enum ATLAS_UPLO      * UPLOS,
   const int                  NTRAN,
   const enum ATLAS_TRANS     * TRANS,
   const int                  NDIAG,
   const enum ATLAS_DIAG      * DIAGS,
   int                        N0,
   int                        NN,
   int                        NINC,
   int                        KL0,
   int                        KLN,
   int                        KLINC,
   int                        KU0,
   int                        KUN,
   int                        KUINC,
   const int                  NINCX,
   const int                  * INCXS,
   const TYPE                 EPSILON,
   int                        * NPASSED,
   int                        * NTESTS
)
{
   double                     t0, mftrust, mftest, ttrust, ttest;
   char                       * pass, * form;
   int                        di, ires, ix, kkl, kku, lda, nn, ta, up;
   char                       ctran, cdiag, cuplo;

   if( ROUT == TBMV )
      (void) fprintf( stdout, "\n%s%s%s\n", "-----------------------------",
                      " TBMV ", "------------------------------" );
   else
      (void) fprintf( stdout, "\n%s%s%s\n", "-----------------------------",
                      " TBSV ", "------------------------------" );

   (void) fprintf( stdout, "%s%s",
                   "TST# UPLO TRAN DIAG    N    K  LDA INCX   TIME",
                   "  MFLOP  SpUp  TEST\n" );
   (void) fprintf( stdout, "%s%s",
                   "==== ==== ==== ==== ==== ==== ==== ==== ======",
                   " ====== ===== =====\n" );
   form = "%4d    %c    %c    %c %4d %4d %4d %4d %6.2f %6.1f %5.2f %5s\n"; 

   for( nn = N0; nn <= NN; nn += NINC )
   {
      for( up = 0; up < NUPLO; up++ )
      {
         if( UPLOS[up] == AtlasLower )
         {
            cuplo = 'L';

            for( kkl = KL0; kkl <= KLN; kkl += KLINC )
            {
               if( LDA_IS_M ) lda = kkl+1;
               else           lda = KLN+1;
 
               for( ta = 0; ta < NTRAN; ta++ )
               {
                  if(      TRANS[ta] == AtlasNoTrans ) ctran = 'N';
                  else if( TRANS[ta] == AtlasTrans   ) ctran = 'T';
                  else                                 ctran = 'C';
 
                  for( di = 0; di < NDIAG; di++ )
                  {
                     if( DIAGS[di] == AtlasUnit ) cdiag = 'U';
                     else                         cdiag = 'N';
 
                     for( ix = 0; ix < NINCX; ix++ )
                     {
                        if( ROUT == TBMV )
                           ires = tmvcase( CACHESIZE, ROUT, TEST, MFLOP,
					   UPLOS[up],
                                           TRANS[ta], DIAGS[di], nn, kkl,
                                           lda, INCXS[ix], EPSILON, &ttrust,
                                           &ttest, &mftrust, &mftest );
                        else
                           ires = tsvcase( CACHESIZE, ROUT, TEST, MFLOP,
					   UPLOS[up],
                                           TRANS[ta], DIAGS[di], nn, kkl,
                                           lda, INCXS[ix], EPSILON, &ttrust,
                                           &ttest, &mftrust, &mftest );
 
                        if(     !( TEST ) ) pass = "SKIP ";
                        else if( ires < 0 ) pass = "NoMEM";
                        else if( ires     ) pass = "PASS ";
                        else                pass = "FAIL ";
 
                        if( ires > 0 ) (*NPASSED)++;
 
                        if( ( mftrust > 0.0 ) && ( mftest > 0.0 ) )
                           t0 = mftest / mftrust;
                        else t0 = 0.0;
 
                        (void) fprintf( stdout, form, *NTESTS, cuplo, ctran,
                                        cdiag, nn, kkl, lda, INCXS[ix], ttrust,
                                        mftrust, 1.0, "-----" );
                        (void) fprintf( stdout, form, *NTESTS, cuplo, ctran,
                                        cdiag, nn, kkl, lda, INCXS[ix], ttest,
                                        mftest,  t0, pass );
                        (*NTESTS)++;
                     }
                  }
               }
            }
         }
         else
         {
            cuplo = 'U';

            for( kku = KU0; kku <= KUN; kku += KUINC )
            {
               if( LDA_IS_M ) lda = 1+kku;
               else           lda = 1+KUN;
 
               for( ta = 0; ta < NTRAN; ta++ )
               {
                  if(      TRANS[ta] == AtlasNoTrans ) ctran = 'N';
                  else if( TRANS[ta] == AtlasTrans   ) ctran = 'T';
                  else                                 ctran = 'C';
 
                  for( di = 0; di < NDIAG; di++ )
                  {
                     if( DIAGS[di] == AtlasUnit ) cdiag = 'U';
                     else                         cdiag = 'N';
 
                     for( ix = 0; ix < NINCX; ix++ )
                     {
                        if( ROUT == TBMV )
                           ires = tmvcase( CACHESIZE, ROUT, TEST, MFLOP,
					   UPLOS[up],
                                           TRANS[ta], DIAGS[di], nn, kku,
                                           lda, INCXS[ix], EPSILON, &ttrust,
                                           &ttest, &mftrust, &mftest );
                        else
                           ires = tsvcase( CACHESIZE, ROUT, TEST, MFLOP,
					   UPLOS[up],
                                           TRANS[ta], DIAGS[di], nn, kku,
                                           lda, INCXS[ix], EPSILON, &ttrust,
                                           &ttest, &mftrust, &mftest );
 
                        if(     !( TEST ) ) pass = "SKIP ";
                        else if( ires < 0 ) pass = "NoMEM";
                        else if( ires     ) pass = "PASS ";
                        else                pass = "FAIL ";
 
                        if( ires > 0 ) (*NPASSED)++;
 
                        if( ( mftrust > 0.0 ) && ( mftest > 0.0 ) )
                           t0 = mftest / mftrust;
                        else t0 = 0.0;
 
                        (void) fprintf( stdout, form, *NTESTS, cuplo, ctran,
                                        cdiag, nn, kku, lda, INCXS[ix], ttrust,
                                        mftrust, 1.0, "-----" );
                        (void) fprintf( stdout, form, *NTESTS, cuplo, ctran,
                                        cdiag, nn, kku, lda, INCXS[ix], ttest,
                                        mftest,  t0, pass );
                        (*NTESTS)++;
                     }
                  }
               }
            }
         }
      }
   } 
}

void RuntpCase
(
   const int                  CACHESIZE,
   const enum LVL2_ROUT       ROUT,
   const int                  TEST,
   const int                  MFLOP,
   const int                  NUPLO,
   const enum ATLAS_UPLO      * UPLOS,
   const int                  NTRAN,
   const enum ATLAS_TRANS     * TRANS,
   const int                  NDIAG,
   const enum ATLAS_DIAG      * DIAGS,
   const int                  N0,
   const int                  NN,
   const int                  NINC,
   const int                  NINCX,
   const int                  * INCXS,
   const TYPE                 EPSILON,
   int                        * NPASSED,
   int                        * NTESTS
)
{
   double                     t0, mftrust, mftest, ttrust, ttest;
   char                       * pass, * form;
   int                        nn, up, ta, di, ix, ires;
   char                       ctran, cdiag, cuplo;

   if( ROUT == TPMV )
      (void) fprintf( stdout, "\n%s%s%s\n", "------------------------",
                      " TPMV ", "-------------------------" );
   else
      (void) fprintf( stdout, "\n%s%s%s\n", "------------------------",
                      " TPSV ", "-------------------------" );
   (void) fprintf( stdout, "%s%s", "TST# UPLO TRAN DIAG    N INCX   TIME",
                   "  MFLOP  SpUp  TEST\n" );
   (void) fprintf( stdout, "%s%s", "==== ==== ==== ==== ==== ==== ======",
                   " ====== ===== =====\n" );
   form = "%4d    %c    %c    %c %4d %4d %6.2f %6.1f %5.2f %5s\n";

   for( nn = N0; nn <= NN; nn += NINC )
   {
      for( up = 0; up < NUPLO; up++ )
      {
         if( UPLOS[up] == AtlasUpper ) cuplo = 'U';
         else                          cuplo = 'L';
 
         for( ta = 0; ta < NTRAN; ta++ )
         {
            if(      TRANS[ta] == AtlasNoTrans   ) ctran = 'N';
            else if( TRANS[ta] == AtlasTrans     ) ctran = 'T';
            else if( TRANS[ta] == AtlasConjTrans ) ctran = 'C';
            else                                   ctran = 'N'; 
 
            for( di = 0; di < NDIAG; di++ )
            {
               if( DIAGS[di] == AtlasUnit ) cdiag = 'U';
               else                         cdiag = 'N';
 
               for( ix = 0; ix < NINCX; ix++ )
               {
                  if( ROUT == TPMV )
                     ires = tmvcase( CACHESIZE, ROUT, TEST, MFLOP,
				     UPLOS[up], TRANS[ta],
                                     DIAGS[di], nn, 0, 1, INCXS[ix], EPSILON,
                                     &ttrust, &ttest, &mftrust, &mftest );
                  else
                     ires = tsvcase( CACHESIZE, ROUT, TEST, MFLOP,
				     UPLOS[up], TRANS[ta],
                                     DIAGS[di], nn, 0, 1, INCXS[ix], EPSILON,
                                     &ttrust, &ttest, &mftrust, &mftest );
 
                  if(     !( TEST ) ) pass = "SKIP ";
                  else if( ires < 0 ) pass = "NoMEM";
                  else if( ires     ) pass = "PASS ";
                  else                pass = "FAIL ";
 
                  if( ires > 0 ) (*NPASSED)++;
 
                  if( ( mftrust > 0.0 ) && ( mftest > 0.0 ) )
                     t0 = mftest / mftrust;
                  else t0 = 0.0;
 
                  (void) fprintf( stdout, form, *NTESTS, cuplo, ctran,
                                  cdiag, nn, INCXS[ix], ttrust, mftrust,
                                  1.0, "-----" );
                  (void) fprintf( stdout, form, *NTESTS, cuplo, ctran,
                                  cdiag, nn, INCXS[ix], ttest,  mftest,
                                  t0, pass );
                  (*NTESTS)++;
               }
            }
         }
      }
   } 
} 

void RuntrCase
(
   const int                  CACHESIZE,
   const enum LVL2_ROUT       ROUT,
   const int                  TEST,
   const int                  MFLOP,
   const int                  LDA_IS_M,
   const int                  NUPLO,
   const enum ATLAS_UPLO      * UPLOS,
   const int                  NTRAN,
   const enum ATLAS_TRANS     * TRANS,
   const int                  NDIAG,
   const enum ATLAS_DIAG      * DIAGS,
   int                        N0,
   int                        NN,
   int                        NINC,
   const int                  NINCX,
   const int                  * INCXS,
   const TYPE                 EPSILON,
   int                        * NPASSED,
   int                        * NTESTS
)
{
   double                     t0, mftrust, mftest, ttrust, ttest;
   char                       * pass, * form;
   int                        nn, up, ta, di, ix, ires, lda;
   char                       ctran, cdiag, cuplo;

   if( ROUT == TRMV )
      (void) fprintf( stdout, "\n%s%s%s\n", "--------------------------",
                      " TRMV ", "----------------------------" );
   else 
      (void) fprintf( stdout, "\n%s%s%s\n", "--------------------------",
                      " TRSV ", "----------------------------" );

   (void) fprintf( stdout, "%s%s", "TST# UPLO TRAN DIAG    N  LDA INCX   TIME",
                   "  MFLOP  SpUp  TEST\n" );
   (void) fprintf( stdout, "%s%s", "==== ==== ==== ==== ==== ==== ==== ======",
                   " ====== ===== =====\n" );
   form = "%4d    %c    %c    %c %4d %4d %4d %6.2f %6.1f %5.2f %5s\n";
 
   for( nn = N0; nn <= NN; nn += NINC )
   {
      if( LDA_IS_M ) lda = Mmax( 1, nn ); else lda = NN;

      for( up = 0; up < NUPLO; up++ )
      {
         if( UPLOS[up] == AtlasUpper ) cuplo = 'U';
         else                          cuplo = 'L';
 
         for( ta = 0; ta < NTRAN; ta++ )
         {
            if(      TRANS[ta] == AtlasNoTrans   ) ctran = 'N';
            else if( TRANS[ta] == AtlasTrans     ) ctran = 'T';
            else if( TRANS[ta] == AtlasConjTrans ) ctran = 'C';
            else                                   ctran = 'N'; 
 
            for( di = 0; di < NDIAG; di++ )
            {
               if( DIAGS[di] == AtlasUnit ) cdiag = 'U';
               else                         cdiag = 'N';
 
               for( ix = 0; ix < NINCX; ix++ )
               {
                  if( ROUT == TRMV )
                     ires = tmvcase( CACHESIZE, ROUT, TEST, MFLOP, UPLOS[up],
				     TRANS[ta], DIAGS[di], nn, 0, lda,
				     INCXS[ix], EPSILON,
                                     &ttrust, &ttest, &mftrust, &mftest );
                  else
                     ires = tsvcase( CACHESIZE, ROUT, TEST, MFLOP, UPLOS[up],
				     TRANS[ta], DIAGS[di], nn, 0, lda,
				     INCXS[ix], EPSILON, &ttrust, &ttest,
				     &mftrust, &mftest );

                  if(     !( TEST ) ) pass = "SKIP ";
                  else if( ires < 0 ) pass = "NoMEM";
                  else if( ires     ) pass = "PASS ";
                  else                pass = "FAIL ";
 
                  if( ires > 0 ) (*NPASSED)++;
 
                  if( ( mftrust > 0.0 ) && ( mftest > 0.0 ) )
                     t0 = mftest / mftrust;
                  else t0 = 0.0;
 
                  (void) fprintf( stdout, form, *NTESTS, cuplo, ctran, cdiag,
                                  nn, lda, INCXS[ix], ttrust, mftrust, 1.0,
                                  "-----" );
                  (void) fprintf( stdout, form, *NTESTS, cuplo, ctran, cdiag,
                                  nn, lda, INCXS[ix], ttest,  mftest,  t0,
                                  pass );
                  (*NTESTS)++;
               }
            }
         }
      }
   }
}

void Rungr1Case
(  const int                  CACHESIZE,
   const enum LVL2_ROUT       ROUT,
   const int                  TEST,
   const int                  MFLOP,
   const int                  LDA_IS_M,
   int                        M0,
   int                        MN,
   int                        MINC,
   int                        N0,
   int                        NN,
   int                        NINC,
   const int                  NALPHA,
   const TYPE                 * ALPHAS,
   const int                  NINCX,
   const int                  * INCXS,
   const int                  NINCY,
   const int                  * INCYS,
   const TYPE                 EPSILON,
   int                        * NPASSED,
   int                        * NTESTS
)
{
   double                     t0, mftrust, mftest, ttrust, ttest;
   char                       * pass, * form;
   int                        al, ires, ix, iy, lda, m, mm, msame=0, n, nn;

   if( M0 == -1 ) { M0 = MN = MINC = NN; msame = 1; }

#ifdef TREAL
   (void) fprintf( stdout, "\n%s%s%s\n",
                   "------------------------------ ", "GER1",
                   " -----------------------------" );
   (void) fprintf( stdout, "%s%s",
                   "TST#     M     N ALPHA INCX INCY   LDA   TIME",
                   "  MFLOP  SpUp  TEST\n" );
   (void) fprintf( stdout, "%s%s",
                   "==== ===== ===== ===== ==== ==== ===== ======",
                   " ====== ===== =====\n" );
   form = "%4d %5d %5d %5.1f %4d %4d %5d %6.2f %6.1f %5.2f %5s\n";
#else
   if( ROUT == GERC )
      (void) fprintf( stdout, "\n%s%s%s\n",
                      "-------------------------------- ", "GER1C",
                      " --------------------------------" );
   else
      (void) fprintf( stdout, "\n%s%s%s\n",
                      "-------------------------------- ", "GER1U",
                      " --------------------------------" );
   (void) fprintf( stdout, "%s%s",
                   "TST#     M     N       ALPHA INCX INCY   LDA",
                   "   TIME  MFLOP  SpUp  TEST\n" );
   (void) fprintf( stdout, "%s%s",
                   "==== ===== ===== ===== ===== ==== ==== =====",
                   " ====== ====== ===== =====\n" );
   form = "%4d %5d %5d %5.1f %5.1f %4d %4d %5d %6.2f %6.1f %5.2f %5s\n";
#endif
   for( mm = M0; mm <= MN; mm += MINC )
   {
      for( nn = N0; nn <= NN; nn += NINC )
      {
         n = nn; if( msame ) m = n; else m = mm;
         if( LDA_IS_M ) lda = Mmax( 1, m ); else lda = MN;
 
         for( iy = 0; iy < NINCY; iy++ )
         {
            for( ix = 0; ix < NINCX; ix++ )
            {
               for( al = 0; al < NALPHA; al++ )
               {
#ifdef TREAL
                  ires = gr1case( CACHESIZE, ROUT, TEST, MFLOP, m, n,
				  ALPHAS[al],
                                  INCXS[ix], INCYS[iy], lda, EPSILON, &ttrust,
                                  &ttest, &mftrust, &mftest );
#else
                  ires = gr1case( CACHESIZE, ROUT, TEST, MFLOP, m, n,
				  ALPHAS+2*al,
                                  INCXS[ix], INCYS[iy], lda, EPSILON, &ttrust,
                                  &ttest, &mftrust, &mftest );
#endif
                  if(     !( TEST ) ) pass = "SKIP ";
                  else if( ires < 0 ) pass = "NoMEM";
                  else if( ires     ) pass = "PASS ";
                  else                pass = "FAIL ";

                  if( ires > 0 ) (*NPASSED)++;

                  if( ( mftrust > 0.0 ) && ( mftest > 0.0 ) )
                     t0 = mftest / mftrust;
                  else t0 = 0.0;
#ifdef TREAL
                  (void) fprintf( stdout, form, *NTESTS, m, n, ALPHAS[al],
                                  INCXS[ix], INCYS[iy], lda, ttrust,
                                  mftrust, 1.0, "-----" );
                  (void) fprintf( stdout, form, *NTESTS, m, n, ALPHAS[al],
                                  INCXS[ix], INCYS[iy], lda, ttest,
                                  mftest, t0, pass );
#else
                  (void) fprintf( stdout, form, *NTESTS, m, n, ALPHAS[2*al],
                                  ALPHAS[2*al+1], INCXS[ix], INCYS[iy],
                                  lda, ttrust, mftrust, 1.0, "-----" );
                  (void) fprintf( stdout, form, *NTESTS, m, n, ALPHAS[2*al],
                                  ALPHAS[2*al+1], INCXS[ix], INCYS[iy],
                                  lda, ttest, mftest, t0, pass );
#endif
                  (*NTESTS)++;
               }
            }
         }
      }
   }
}

void Rungr2Case
(  const int                  CACHESIZE,
   const enum LVL2_ROUT       ROUT,
   const int                  TEST,
   const int                  MFLOP,
   const int                  LDA_IS_M,
   int                        M0,
   int                        MN,
   int                        MINC,
   int                        N0,
   int                        NN,
   int                        NINC,
   const int                  NALPHA,
   const TYPE                 * ALPHAS,
   const int                  NBETA,
   const TYPE                 *BETAS,
   const int                  NINCX,
   const int                  * INCXS,
   const int                  NINCY,
   const int                  * INCYS,
   const TYPE                 EPSILON,
   int                        * NPASSED,
   int                        * NTESTS
)
{
   double                     t0, mftrust, mftest, ttrust, ttest;
   char                       * pass, * form;
   int                        al, ires, ix, iy, lda, m, mm, msame=0, n, nn;
   int iw, iz, ib;

   if( M0 == -1 ) { M0 = MN = MINC = NN; msame = 1; }

#ifdef TREAL
   (void) fprintf( stdout, "\n%s%s%s\n",
                   "------------------------------ ", "GER2",
                   " -----------------------------" );
   (void) fprintf( stdout, "%s%s",
                   "TST#     M     N ALPHA INCX INCY  BETA INCW INCX ",
                   "LDA   TIME  MFLOP  SpUp  TEST\n" );
   (void) fprintf( stdout, "%s%s",
                   "==== ===== ===== ===== ==== ==== ===== ==== ==== ",
                   "==== ===== ====== ===== =====\n" );
   form = "%4d %5d %5d %5.1f %4d %4d %5.1f %4d %4d %4d %6.2f %6.1f %5.2f %5s\n";
#else
   if( ROUT == GER2C )
      (void) fprintf( stdout, "\n%s%s%s\n",
                      "-------------------------------- ", "GER2C",
                      " --------------------------------" );
   else
      (void) fprintf( stdout, "\n%s%s%s\n",
                      "-------------------------------- ", "GER2U",
                      " --------------------------------" );
   (void) fprintf( stdout, "%s%s",
                "TST#     M     N       ALPHA INCX INCY BETAr BETAi INCW INCY ",
                   " LDA   TIME  MFLOP  SpUp  TEST\n" );
   (void) fprintf( stdout, "%s%s",
                "==== ===== ===== ===== ===== ==== ==== ===== ===== ==== ==== ",
                   "=====, ====== ====== ===== =====\n" );
   form = "%4d %5d %5d %5.1f %5.1f %4d %4d %5.1f %5.1f %4d %4d %5d %6.2f %6.1f %5.2f %5s\n";
#endif
   for( mm = M0; mm <= MN; mm += MINC )
   {
      for( nn = N0; nn <= NN; nn += NINC )
      {
         n = nn; if( msame ) m = n; else m = mm;
         if( LDA_IS_M ) lda = Mmax( 1, m ); else lda = MN;

         for( iy = 0; iy < NINCY; iy++ )
         {
            for( ix = 0; ix < NINCX; ix++ )
            {
               for( al = 0; al < NALPHA; al++ )
               {
                  for( ib = 0; ib < NBETA; ib++ )
                  {
                     for(iw=0; iw < NINCX; iw++ )
                     {
                        for(iz=0; iz < NINCY; iz++ )
                        {

                           ires = gr2case( CACHESIZE, ROUT, TEST, MFLOP,
                           #ifdef TREAL
                                 m, n, ALPHAS[al], INCXS[ix], INCYS[iy],
                                 BETAS[ib], INCXS[iw], INCYS[iz], lda,
                           #else
                                 m, n, ALPHAS+2*al, INCXS[ix], INCYS[iy],
                                 BETAS+2*ib, INCXS[iw], INCYS[iz], lda,
                           #endif
                                 EPSILON, &ttrust, &ttest, &mftrust, &mftest );
                           if(     !( TEST ) ) pass = "SKIP ";
                           else if( ires < 0 ) pass = "NoMEM";
                           else if( ires     ) pass = "PASS ";
                           else                pass = "FAIL ";

                           if( ires > 0 ) (*NPASSED)++;

                           if( ( mftrust > 0.0 ) && ( mftest > 0.0 ) )
                              t0 = mftest / mftrust;
                           else t0 = 0.0;
                           #ifdef TREAL
                              fprintf(stdout, form, *NTESTS, m, n, ALPHAS[al],
                                      INCXS[ix], INCYS[iy], BETAS[ib],
                                      INCXS[iw], INCYS[iz], lda, ttrust,
                                      mftrust, 1.0, "-----");
                              fprintf(stdout, form, *NTESTS, m, n, ALPHAS[al],
                                      INCXS[ix], INCYS[iy], BETAS[ib],
                                      INCXS[iw], INCYS[iz], lda, ttest,
                                      mftest, t0, pass);
                           #else
                              fprintf(stdout, form, *NTESTS, m, n, ALPHAS[2*al],
                                      ALPHAS[2*al+1], INCXS[ix], INCYS[iy],
                                      BETAS[2*ib], BETAS[2*ib+1], INCXS[iw],
                                      INCYS[iz],
                                      lda, ttrust, mftrust, 1.0, "-----");
                              fprintf(stdout, form, *NTESTS, m, n, ALPHAS[2*al],
                                      ALPHAS[2*al+1], INCXS[ix], INCYS[iy],
                                      BETAS[2*ib], BETAS[2*ib+1], INCXS[iw],
                                      INCYS[iz],
                                      lda, ttest, mftest, t0, pass);
                           #endif
                           (*NTESTS)++;
                        }
                     }
                  }
               }
            }
         }
      }
   }
}

void Runsp1Case
(
   const int                  CACHESIZE,
   const enum LVL2_ROUT       ROUT,
   const int                  TEST,
   const int                  MFLOP,
   const int                  NUPLO,
   const enum ATLAS_UPLO      * UPLOS,
   const int                  N0,
   const int                  NN,
   const int                  NINC,
   const int                  NALPHA,
   const TYPE                 * ALPHAS,
   const int                  NINCX,
   const int                  * INCXS,
   const TYPE                 EPSILON,
   int                        * NPASSED,
   int                        * NTESTS
)
{
   double                     t0, mftrust, mftest, ttrust, ttest;
   char                       * pass, * form;
   int                        al, ires, ix, nn, up;
   char                       cuplo;

#ifdef TREAL
   (void) fprintf( stdout, "\n%s%s%s\n", "----------------------- ", "SPR",
                   " ------------------------" );
#else
   (void) fprintf( stdout, "\n%s%s%s\n", "----------------------- ", "HPR",
                   " ------------------------" );
#endif
   (void) fprintf( stdout, "%s%s", "TST# UPLO     N ALPHA INCX   TIME",
                   "  MFLOP  SpUp  TEST\n" );
   (void) fprintf( stdout, "%s%s", "==== ==== ===== ===== ==== ======",
                   " ====== ===== =====\n" );
   form = "%4d    %c %5d %5.1f %4d %6.2f %6.1f %5.2f %5s\n";

   for( nn = N0; nn <= NN; nn += NINC )
   {
      for( up = 0; up < NUPLO; up++ )
      {
         if( UPLOS[up] == AtlasUpper ) cuplo = 'U';
         else                          cuplo = 'L';
 
         for( ix = 0; ix < NINCX; ix++ )
         {
            for( al = 0; al < NALPHA; al++ )
            {
#ifdef TREAL
               ires = sr1case( CACHESIZE, ROUT, TEST, MFLOP, UPLOS[up],
			       nn, ALPHAS[al],
                               INCXS[ix], 1, EPSILON, &ttrust, &ttest,
                               &mftrust, &mftest );
#else
               ires = sr1case( CACHESIZE, ROUT, TEST, MFLOP, UPLOS[up],
			       nn, ALPHAS[2*al],
                               INCXS[ix], 1, EPSILON, &ttrust, &ttest,
                               &mftrust, &mftest );
#endif
               if(     !( TEST ) ) pass = "SKIP ";
               else if( ires < 0 ) pass = "NoMEM";
               else if( ires     ) pass = "PASS ";
               else                pass = "FAIL ";
 
               if( ires > 0 ) (*NPASSED)++;

               if( ( mftrust > 0.0 ) && ( mftest > 0.0 ) )
                  t0 = mftest / mftrust;
               else t0 = 0.0;
#ifdef TREAL
               (void) fprintf( stdout, form, *NTESTS, cuplo, nn, ALPHAS[al],
                               INCXS[ix], ttrust, mftrust, 1.0, "-----" );
               (void) fprintf( stdout, form, *NTESTS, cuplo, nn, ALPHAS[al],
                               INCXS[ix], ttest,  mftest,  t0,  pass );
#else
               (void) fprintf( stdout, form, *NTESTS, cuplo, nn, ALPHAS[2*al],
                               INCXS[ix], ttrust, mftrust, 1.0, "-----" );
               (void) fprintf( stdout, form, *NTESTS, cuplo, nn, ALPHAS[2*al],
                               INCXS[ix], ttest,  mftest,  t0,  pass );
#endif
               (*NTESTS)++;
            }
         }
      }
   } 
} 

void Runsr1Case
(
   const int                  CACHESIZE,
   const enum LVL2_ROUT       ROUT,
   const int                  TEST,
   const int                  MFLOP,
   const int                  LDA_IS_M,
   const int                  NUPLO,
   const enum ATLAS_UPLO      * UPLOS,
   int                        N0,
   int                        NN,
   int                        NINC,
   const int                  NALPHA,
   const TYPE                 * ALPHAS,
   const int                  NINCX,
   const int                  * INCXS,
   const TYPE                 EPSILON,
   int                        * NPASSED,
   int                        * NTESTS
)
{
   double                     t0, mftrust, mftest, ttrust, ttest;
   char                       * pass, * form;
   int                        al, ires, ix, lda, nn, up;
   char                       cuplo;

#ifdef TREAL
   (void) fprintf( stdout, "\n%s%s%s\n", "--------------------------- ", "SYR",
                   " --------------------------" );
#else
   (void) fprintf( stdout, "\n%s%s%s\n", "--------------------------- ", "HER",
                   " --------------------------" );
#endif
   (void) fprintf( stdout, "%s%s", "TST# UPLO     N ALPHA INCX   LDA   TIME",
                   "  MFLOP  SpUp  TEST\n" );
   (void) fprintf( stdout, "%s%s", "==== ==== ===== ===== ==== ===== ======",
                   " ====== ===== =====\n" );
   form = "%4d    %c %5d %5.1f %4d %5d %6.2f %6.1f %5.2f %5s\n";

   for( nn = N0; nn <= NN; nn += NINC )
   {
      if( LDA_IS_M ) lda = Mmax( 1, nn ); else lda = NN;

      for( up = 0; up < NUPLO; up++ )
      {
         if( UPLOS[up] == AtlasUpper ) cuplo = 'U';
         else                          cuplo = 'L';
 
         for( ix = 0; ix < NINCX; ix++ )
         {
            for( al = 0; al < NALPHA; al++ )
            {
#ifdef TREAL
               ires = sr1case( CACHESIZE, ROUT, TEST, MFLOP, UPLOS[up],
			       nn, ALPHAS[al],
                               INCXS[ix], lda, EPSILON, &ttrust, &ttest,
                               &mftrust, &mftest );
#else
               ires = sr1case( CACHESIZE, ROUT, TEST, MFLOP, UPLOS[up],
			       nn, ALPHAS[2*al],
                               INCXS[ix], lda, EPSILON, &ttrust, &ttest,
                               &mftrust, &mftest );
#endif
               if(     !( TEST ) ) pass = "SKIP ";
               else if( ires < 0 ) pass = "NoMEM";
               else if( ires     ) pass = "PASS ";
               else                pass = "FAIL ";
 
               if( ires > 0 ) (*NPASSED)++;
 
               if( ( mftrust > 0.0 ) && ( mftest > 0.0 ) )
                  t0 = mftest / mftrust;
               else t0 = 0.0;
#ifdef TREAL
               (void) fprintf( stdout, form, *NTESTS, cuplo, nn, ALPHAS[al],
                               INCXS[ix], lda, ttrust, mftrust, 1.0,
                               "-----" );
               (void) fprintf( stdout, form, *NTESTS, cuplo, nn, ALPHAS[al],
                               INCXS[ix], lda, ttest,  mftest,  t0,
                               pass );
#else
               (void) fprintf( stdout, form, *NTESTS, cuplo, nn, ALPHAS[2*al],
                               INCXS[ix], lda, ttrust, mftrust, 1.0,
                               "-----" );
               (void) fprintf( stdout, form, *NTESTS, cuplo, nn, ALPHAS[2*al],
                               INCXS[ix], lda, ttest,  mftest,  t0,
                               pass );
#endif
               (*NTESTS)++;
            }
         }
      }
   }
} 

void Runsp2Case
(
   const int                  CACHESIZE,
   const enum LVL2_ROUT       ROUT,
   const int                  TEST,
   const int                  MFLOP,
   const int                  NUPLO,
   const enum ATLAS_UPLO      * UPLOS,
   const int                  N0,
   const int                  NN,
   const int                  NINC,
   const int                  NALPHA,
   const TYPE                 * ALPHAS,
   const int                  NINCX,
   const int                  * INCXS,
   const int                  NINCY,
   const int                  * INCYS,
   const TYPE                 EPSILON,
   int                        * NPASSED,
   int                        * NTESTS
)
{
   double                     t0, mftrust, mftest, ttrust, ttest;
   char                       * pass, * form;
   int                        al, ires, ix, iy, nn, up;
   char                       cuplo;

#ifdef TREAL
         (void) fprintf( stdout, "\n%s%s%s\n",
                         "-------------------------- ", "SPR2",
                         " -------------------------" );
         (void) fprintf( stdout, "%s%s",
                         "TST# UPLO     N ALPHA INCX INCY   TIME",
                         "  MFLOP  SpUp  TEST\n" );
         (void) fprintf( stdout, "%s%s",
                         "==== ==== ===== ===== ==== ==== ======",
                         " ====== ===== =====\n" );
         form = "%4d    %c %5d %5.1f %4d %4d %6.2f %6.1f %5.2f %5s\n";
#else
         (void) fprintf( stdout, "\n%s%s%s\n",
                         "----------------------------- ", "HPR2",
                         " ----------------------------" );
         (void) fprintf( stdout, "%s%s",
                         "TST# UPLO     N       ALPHA INCX INCY",
                         "   TIME  MFLOP  SpUp  TEST\n");
         (void) fprintf( stdout, "%s%s",
                         "==== ==== ===== ===== ===== ==== ====",
                         " ====== ====== ===== =====\n");
         form = "%4d    %c %5d %5.1f %5.1f %4d %4d %6.2f %6.1f %5.2f %5s\n";
#endif
   for( nn = N0; nn <= NN; nn += NINC )
   {
      for( up = 0; up < NUPLO; up++ )
      {
         if( UPLOS[up] == AtlasUpper ) cuplo = 'U';
         else                          cuplo = 'L';
 
         for( iy = 0; iy < NINCY; iy++ )
         {
            for( ix = 0; ix < NINCX; ix++ )
            {
               for( al = 0; al < NALPHA; al++ )
               {
#ifdef TREAL
                  ires = sr2case( CACHESIZE, ROUT, TEST, MFLOP, UPLOS[up],
				  nn, ALPHAS[al], INCXS[ix], INCYS[iy], 1,
                                  EPSILON, &ttrust, &ttest, &mftrust,
                                  &mftest );
#else
                  ires = sr2case( CACHESIZE, ROUT, TEST, MFLOP, UPLOS[up],
				  nn, ALPHAS+2*al, INCXS[ix], INCYS[iy], 1, 
                                  EPSILON, &ttrust, &ttest, &mftrust,
                                  &mftest );
#endif
                  if(     !( TEST ) ) pass = "SKIP ";
                  else if( ires < 0 ) pass = "NoMEM";
                  else if( ires     ) pass = "PASS ";
                  else                pass = "FAIL ";
 
                  if( ires > 0 ) (*NPASSED)++;
 
                  if( ( mftrust > 0.0 ) && ( mftest > 0.0 ) )
                     t0 = mftest / mftrust;
                  else t0 = 0.0;
#ifdef TREAL
                  (void) fprintf( stdout, form, *NTESTS, cuplo, nn, ALPHAS[al],
                                  INCXS[ix], INCYS[iy], ttrust, mftrust, 1.0,
                                  "-----" );
                  (void) fprintf( stdout, form, *NTESTS, cuplo, nn, ALPHAS[al],
                                  INCXS[ix], INCYS[iy], ttest, mftest, t0,
                                  pass );
#else
                  (void) fprintf( stdout, form, *NTESTS, cuplo, nn,
                                  ALPHAS[2*al], ALPHAS[2*al+1], INCXS[ix],
                                  INCYS[iy], ttrust, mftrust, 1.0, "-----" );
                  (void) fprintf( stdout, form, *NTESTS, cuplo, nn,
                                  ALPHAS[2*al], ALPHAS[2*al+1], INCXS[ix],
                                  INCYS[iy], ttest, mftest, t0, pass );
#endif
                  (*NTESTS)++;
               }
            }
         }
      }
   }
}
 
void Runsr2Case
(
   const int                  CACHESIZE,
   const enum LVL2_ROUT       ROUT,
   const int                  TEST,
   const int                  MFLOP,
   const int                  LDA_IS_M,
   const int                  NUPLO,
   const enum ATLAS_UPLO      * UPLOS,
   int                        N0,
   int                        NN,
   int                        NINC,
   const int                  NALPHA,
   const TYPE                 * ALPHAS,
   const int                  NINCX,
   const int                  * INCXS,
   const int                  NINCY,
   const int                  * INCYS,
   const TYPE                 EPSILON,
   int                        * NPASSED,
   int                        * NTESTS
)
{
   double                     t0, mftrust, mftest, ttrust, ttest;
   char                       * pass, * form; 
   int                        al, ires, ix, iy, lda, nn, up;
   char                       cuplo;

#ifdef TREAL
   (void) fprintf( stdout, "\n%s%s%s\n",
                   "---------------------------- ", "SYR2",
                   " -----------------------------" );
   (void) fprintf( stdout, "%s%s",
                   "TST# UPLO     N ALPHA INCX INCY   LDA   TIME",
                   "  MFLOP  SpUp  TEST\n" );
   (void) fprintf( stdout, "%s%s",
                   "==== ==== ===== ===== ==== ==== ===== ======",
                   " ====== ===== =====\n" );
   form = "%4d    %c %5d %5.1f %4d %4d %5d %6.2f %6.1f %5.2f %5s\n";
#else
   (void) fprintf( stdout, "\n%s%s%s\n",
                   "------------------------------- ", "HER2",
                   " --------------------------------" );
   (void) fprintf( stdout, "%s%s",
                   "TST# UPLO     N       ALPHA INCX INCY   LDA",
                   "   TIME  MFLOP  SpUp  TEST\n");
   (void) fprintf( stdout, "%s%s",
                   "==== ==== ===== ===== ===== ==== ==== =====",
                   " ====== ====== ===== =====\n");
   form = "%4d    %c %5d %5.1f %5.1f %4d %4d %5d %6.2f %6.1f %5.2f %5s\n";
#endif
   for( nn = N0; nn <= NN; nn += NINC )
   {
      if( LDA_IS_M ) lda = Mmax( 1, nn ); else lda = NN;

      for( up = 0; up < NUPLO; up++ )
      {
         if( UPLOS[up] == AtlasUpper ) cuplo = 'U';
         else                          cuplo = 'L';

         for( iy = 0; iy < NINCY; iy++ )
         {
            for( ix = 0; ix < NINCX; ix++ )
            {
               for( al = 0; al < NALPHA; al++ )
               {
#ifdef TREAL
                  ires = sr2case( CACHESIZE, ROUT, TEST, MFLOP, UPLOS[up],
				  nn, ALPHAS[al], INCXS[ix], INCYS[iy], lda,
                                  EPSILON, &ttrust, &ttest, &mftrust, &mftest );
#else
                  ires = sr2case( CACHESIZE, ROUT, TEST, MFLOP, UPLOS[up], nn,
                                  ALPHAS+2*al, INCXS[ix], INCYS[iy], lda,
                                  EPSILON, &ttrust, &ttest, &mftrust, &mftest );
#endif
                  if(     !( TEST ) ) pass = "SKIP ";
                  else if( ires < 0 ) pass = "NoMEM";
                  else if( ires     ) pass = "PASS ";
                  else                pass = "FAIL ";
 
                  if( ires > 0 ) (*NPASSED)++;
 
                  if( ( mftrust > 0.0 ) && ( mftest > 0.0 ) )
                     t0 = mftest / mftrust;
                  else t0 = 0.0;
#ifdef TREAL
                  (void) fprintf( stdout, form, *NTESTS, cuplo, nn,
                                  ALPHAS[al], INCXS[ix], INCYS[iy],
                                  lda, ttrust, mftrust, 1.0, "-----" );
                  (void) fprintf( stdout, form, *NTESTS, cuplo, nn,
                                  ALPHAS[al], INCXS[ix], INCYS[iy],
                                  lda, ttest, mftest, t0, pass );
#else
                  (void) fprintf( stdout, form, *NTESTS, cuplo, nn,
                                  ALPHAS[2*al], ALPHAS[2*al+1], INCXS[ix],
                                  INCYS[iy], lda, ttrust, mftrust, 1.0,
                                  "-----" );
                  (void) fprintf( stdout, form, *NTESTS, cuplo, nn,
                                  ALPHAS[2*al], ALPHAS[2*al+1], INCXS[ix],
                                  INCYS[iy], lda, ttest, mftest, t0, pass );
#endif
                  (*NTESTS)++;
               }
            }
         }
      }
   }
} 

void RunCases
(
   const int                  TEST,
   const int                  CACHESIZE,
   const int                  MFLOP,
   const int                  LDA_IS_M,
   const int                  NUPLO,
   const enum ATLAS_UPLO      * UPLOS,
   const int                  NTRAN,
   const enum ATLAS_TRANS     * TRANS,
   const int                  NDIAG,
   const enum ATLAS_DIAG      * DIAGS,
   const int                  M0,
   const int                  MN,
   const int                  MINC,
   const int                  N0,
   const int                  NN,
   const int                  NINC,
   const int                  KL0,
   const int                  KLN,
   const int                  KLINC,
   const int                  KU0,
   const int                  KUN,
   const int                  KUINC,
   const int                  NALPHA,
   const TYPE                 * ALPHAS,
   const int                  NBETA,
   const TYPE                 * BETAS,
   const int                  NINCX,
   const int                  * INCXS,
   const int                  NINCY,
   const int                  * INCYS,
   const int                  NROUT,
   const enum LVL2_ROUT       * ROUTS
)
{
   TYPE                       eps;
   int                        ro, ntests=0, np=0;

   eps = Mjoin( PATL, epsilon )();

   for( ro = 0; ro < NROUT; ro++ )
   {
      if( ROUTS[ro] == GBMV  )
      {
         RungbmCase( CACHESIZE, ROUTS[ro], TEST, MFLOP, LDA_IS_M, NTRAN,
		     TRANS, M0, MN,
                     MINC, N0, NN, NINC, KL0, KLN, KLINC, KU0, KUN, KUINC,
                     NALPHA, ALPHAS, NBETA, BETAS, NINCX, INCXS, NINCY, INCYS,
                     eps, &np, &ntests );
      }
      else if( ROUTS[ro] == GEMV  )
      {
         RungemCase( CACHESIZE, ROUTS[ro], TEST, MFLOP, LDA_IS_M, NTRAN,
		     TRANS, M0, MN,
                     MINC, N0, NN, NINC, NALPHA, ALPHAS, NBETA, BETAS, NINCX,
                     INCXS, NINCY, INCYS, eps, &np, &ntests );
      }
      else if( ROUTS[ro] == SBMV )
      {
         RunsbCase( CACHESIZE, ROUTS[ro], TEST, MFLOP, LDA_IS_M, NUPLO,
		    UPLOS, N0, NN,
                    NINC, KL0, KLN, KLINC, KU0, KUN, KUINC, NALPHA, ALPHAS,
                    NBETA, BETAS, NINCX, INCXS, NINCY, INCYS, eps, &np,
                    &ntests );
      }
      else if( ROUTS[ro] == SPMV )
      {
         RunspCase( CACHESIZE, ROUTS[ro], TEST, MFLOP, NUPLO, UPLOS, N0,
		    NN, NINC, NALPHA,
                    ALPHAS, NBETA, BETAS, NINCX, INCXS, NINCY, INCYS, eps, &np,
                    &ntests );
      }
      else if( ROUTS[ro] == SYMV )
      {
         RunsyCase( CACHESIZE, ROUTS[ro], TEST, MFLOP, LDA_IS_M, NUPLO,
		    UPLOS, N0, NN,
                    NINC, NALPHA, ALPHAS, NBETA, BETAS, NINCX, INCXS, NINCY,
                    INCYS, eps, &np, &ntests );
      }
      else if( ( ROUTS[ro] == TBMV ) || ( ROUTS[ro] == TBSV ) )
      {
         RuntbCase( CACHESIZE, ROUTS[ro], TEST, MFLOP, LDA_IS_M, NUPLO,
		    UPLOS, NTRAN, 
                    TRANS, NDIAG, DIAGS, N0, NN, NINC, KL0, KLN, KLINC,
                    KU0, KUN, KUINC, NINCX, INCXS, eps, &np, &ntests );
      }
      else if( ( ROUTS[ro] == TPMV ) || ( ROUTS[ro] == TPSV ) )
      {
         RuntpCase( CACHESIZE, ROUTS[ro], TEST, MFLOP, NUPLO, UPLOS,
		    NTRAN, TRANS, NDIAG,
                    DIAGS, N0, NN, NINC, NINCX, INCXS, eps, &np, &ntests );
      }
      else if( ( ROUTS[ro] == TRMV ) || ( ROUTS[ro] == TRSV ) )
      {
         RuntrCase( CACHESIZE, ROUTS[ro], TEST, MFLOP, LDA_IS_M, NUPLO,
		    UPLOS, NTRAN, 
                    TRANS, NDIAG, DIAGS, N0, NN, NINC, NINCX, INCXS, eps,
                    &np, &ntests );
      }
      else if( ( ROUTS[ro] == GERC ) || ( ROUTS[ro] == GERU ) )
      {
         Rungr1Case( CACHESIZE, ROUTS[ro], TEST, MFLOP, LDA_IS_M, M0, MN,
		     MINC, N0, NN,
                     NINC, NALPHA, ALPHAS, NINCX, INCXS, NINCY, INCYS, eps,
                     &np, &ntests ); 
      }
      else if( ( ROUTS[ro] == GER2C ) || ( ROUTS[ro] == GER2U ) )
      {
         Rungr2Case( CACHESIZE, ROUTS[ro], TEST, MFLOP, LDA_IS_M, M0, MN,
		     MINC, N0, NN, NINC, NALPHA, ALPHAS, NBETA, BETAS, 
                     NINCX, INCXS, NINCY, INCYS, eps,
                     &np, &ntests ); 
      }
      else if( ROUTS[ro] == SPR )
      { 
         Runsp1Case( CACHESIZE, ROUTS[ro], TEST, MFLOP, NUPLO, UPLOS,
		     N0, NN, NINC,
                     NALPHA, ALPHAS, NINCX, INCXS, eps, &np, &ntests ); 
      }
      else if( ROUTS[ro] == SYR )
      {
         Runsr1Case( CACHESIZE, ROUTS[ro], TEST, MFLOP, LDA_IS_M, NUPLO,
		     UPLOS, N0, NN,
                     NINC, NALPHA, ALPHAS, NINCX, INCXS, eps, &np, &ntests ); 
      }
      else if( ROUTS[ro] == SPR2 )
      {
         Runsp2Case( CACHESIZE, ROUTS[ro], TEST, MFLOP, NUPLO, UPLOS,
		     N0, NN, NINC,
                     NALPHA, ALPHAS, NINCX, INCXS, NINCY, INCYS, eps, &np,
                     &ntests ); 
      }
      else if( ROUTS[ro] == SYR2 )
      {
         Runsr2Case( CACHESIZE, ROUTS[ro], TEST, MFLOP, LDA_IS_M, NUPLO,
		     UPLOS, N0, NN,
                     NINC, NALPHA, ALPHAS, NINCX, INCXS, NINCY, INCYS, eps,
                     &np, &ntests );
      }
   }

   if( TEST )
      (void) fprintf( stdout, "\n%d tests run, %d passed\n\n", ntests, np );
   else
      (void) fprintf( stdout, "\n%d tests run, all skipped\n\n", ntests );
}
/*
 * =====================================================================
 * Main functions
 * =====================================================================
 */
void PrintUsage( char * nam )
{
   (void) fprintf( stderr, "ATLAS usage:\n" );
   (void) fprintf( stderr, "    %s [-options ...]\n\n", nam );
   (void) fprintf( stderr, "where options include:\n" );

   (void) fprintf( stderr, "   -h                                   " );
   (void) fprintf( stderr, ". print this message                   \n" );

   (void) fprintf( stderr, "   -R <rout>                            " );
   (void) fprintf( stderr, ". select  one  or all routines to test.\n" );
   (void) fprintf( stderr, "                                        " );
#ifdef TREAL
   (void) fprintf( stderr, "  rout must be in {gbmv,gemv,sbmv,spmv,\n" );
   (void) fprintf( stderr, "                                        " );
   (void) fprintf( stderr, "  symv,tbmv,tpmv,trmv,tbsv,tpsv,trsv,  \n" );
   (void) fprintf( stderr, "                                        " );
   (void) fprintf( stderr, "  ger,ger2, spr,syr,spr2,syr2, all}.         \n" );
#else
   (void) fprintf( stderr, "  rout must be in {gbmv,gemv,hbmv,hpmv,\n" );
   (void) fprintf( stderr, "                                        " );
   (void) fprintf( stderr, "  hemv,tbmv,tpmv,trmv,tbsv,tpsv,trsv,  \n" );
   (void) fprintf( stderr, "                                        " );
   (void) fprintf( stderr, "  gerc,geru,ger2c,ger2u,hpr,her,hpr2,her2, all}.   \n" );
#endif
   (void) fprintf( stderr, "                                        " );
   (void) fprintf( stderr, "  Default: -R gemv.  Ex: -R tpmv       \n" );

   (void) fprintf( stderr, "   -R <nrout> <rout1> ... <routN>       " );
   (void) fprintf( stderr, ". same as above for more than one rout-\n" );
   (void) fprintf( stderr, "                                        " );
   (void) fprintf( stderr, "  tine. Ex: -R 3 gemv tpmv tbsv        \n" );

   (void) fprintf( stderr, "   -U <nuplo>  L/U                      " );
   (void) fprintf( stderr, ". select values for the UPLO parameter.\n" );
   (void) fprintf( stderr, "                                        " );
   (void) fprintf( stderr, "  Default: -U 1 L. Ex: -U 2 L U        \n" );

   (void) fprintf( stderr, "   -A <ntrans> n/t/c                    " );
   (void) fprintf( stderr, ". select values of the TRANS parameter.\n" );
   (void) fprintf( stderr, "                                        " );
   (void) fprintf( stderr, "  Default: -A 1 n. Ex: -A 2 n t        \n" );

   (void) fprintf( stderr, "   -D <ndiags> N/U                      " );
   (void) fprintf( stderr, ". select values for the DIAG parameter.\n" );
   (void) fprintf( stderr, "                                        " );
   (void) fprintf( stderr, "  Default: -D 1 N. Ex: -Diag 2 N U     \n" );

   (void) fprintf( stderr, "   -m <m>                               " );
   (void) fprintf( stderr, ". select one value for the parameter M.\n" );
   (void) fprintf( stderr, "                                        " );
   (void) fprintf( stderr, "  Ex: -m 100                           \n" );

   (void) fprintf( stderr, "   -n <n>                               " );
   (void) fprintf( stderr, ". same as above for the parameter N.   \n" );

   (void) fprintf( stderr, "   -p <kl>                              " );
   (void) fprintf( stderr, ". same as above for the parameter KL.  \n" );

   (void) fprintf( stderr, "   -q <ku>                              " );
   (void) fprintf( stderr, ". same as above for the parameter KU.  \n" );

   (void) fprintf( stderr, "   -M <m1>  <mN>  <minc>                " );
   (void) fprintf( stderr, ". select the values of M, from m1 to mN\n" );
   (void) fprintf( stderr, "                                        " );
   (void) fprintf( stderr, "  by increment of minc. m1 > 0.        \n" );
   (void) fprintf( stderr, "                                        " );
   (void) fprintf( stderr, "  Ex: -M 100 1000 100                  \n" );

   (void) fprintf( stderr, "   -N <n1>  <nN>  <ninc>                " );
   (void) fprintf( stderr, ". same as above for the values of N.   \n" );

   (void) fprintf( stderr, "   -P <kl1> <klN> <klinc>               " );
   (void) fprintf( stderr, ". same as above for the values of KL.  \n" );

   (void) fprintf( stderr, "   -Q <ku1> <kuN> <kuinc>               " );
   (void) fprintf( stderr, ". same as above for the values of KU.  \n" );

#ifdef TREAL
   (void) fprintf( stderr, "   -a <nalphas> <a1> ... <aN>           " );
   (void) fprintf( stderr, ". select the values of ALPHA.  Default:\n" );
   (void) fprintf( stderr, "                                        " );
   (void) fprintf( stderr, "  -a 1 1.0. Ex: -a 3 -1.0 0.0 1.0      \n" );
   (void) fprintf( stderr, "   -b <nbetas>  <beta1>  ... <betaN>    " );
   (void) fprintf( stderr, ". same as above for the parameter BETA.\n" );
#else
   (void) fprintf( stderr, "   -a <nalphas> <a1r> <a1i> ... <aNi>  " );
   (void) fprintf( stderr, ". select the values of ALPHA, where a1r\n" );
   (void) fprintf( stderr, "                                        " );
   (void) fprintf( stderr, "  and  a1i  are the  real and imaginary\n" );
   (void) fprintf( stderr, "                                        " );
   (void) fprintf( stderr, "  parts of a1. Default: -a 1 1.0 0.0   \n" );
   (void) fprintf( stderr, "   -b <nbetas>  <b1r> <b1i> ... <bNi>   " );
   (void) fprintf( stderr, ". same as above for the parameter BETA.\n" );
#endif

   (void) fprintf( stderr, "   -X <nincXs>  <incX0>  ... <incX1>    " );
   (void) fprintf( stderr, ". select  the  values  of the increment\n" );
   (void) fprintf( stderr, "                                        " );
   (void) fprintf( stderr, "  INCX. Default: -X 1 1; Ex: -X 2 1 -1 \n" );

   (void) fprintf( stderr, "   -Y <nincYs>  <incY0>  ... <incYN>    " );
   (void) fprintf( stderr, ". same as above for the the values of  \n" );
   (void) fprintf( stderr, "                                        " );
   (void) fprintf( stderr, "  INCY.                                \n" );

   (void) fprintf( stderr, "   -d                                   " );
   (void) fprintf( stderr, ". use smallest possible leading  dimen-\n" );
   (void) fprintf( stderr, "                                        " );
   (void) fprintf( stderr, "  sion for the array A.                \n" );
   (void) fprintf( stderr, "                                        " );
   (void) fprintf( stderr, "  Default: max( mN, nN ).              \n" );

   (void) fprintf( stderr, "   -T <0/1>                             " );
   (void) fprintf( stderr, ". disable/enable computational check.  \n" );
   (void) fprintf( stderr, "                                        " );
   (void) fprintf( stderr, "  Default: -T 1                        \n" );

   (void) fprintf( stderr, "   -F <mflops>                          " );
   (void) fprintf( stderr, ". perform at least mflops per measure. \n" );

   (void) fprintf( stderr, "   -C <CacheSize>                       " );
   (void) fprintf( stderr, ". select how much memory in kilobytes\n" );
   (void) fprintf( stderr, "                                        " );
   (void) fprintf( stderr, "  to flush to clear the caches. Put 1\n" );
   (void) fprintf( stderr, "                                        " );
   (void) fprintf( stderr, "  for no cache flushing. Default is the\n" );
   (void) fprintf( stderr, "                                        " );
   (void) fprintf( stderr, "  size of the biggest cache.\n" );

   (void) fprintf( stderr, "\n" );
   exit( -1 );
}

void GetFlags
(
   int                        NARGS,
   char                       * ARGS[], 
   int                        * NROUT,
   enum LVL2_ROUT             ** ROUTS,
   int                        * TEST,
   int                        * LDA_IS_M,
   int                        * CACHESIZE,
   int                        * MFLOP,
   int                        * NUPLO,
   enum ATLAS_UPLO            ** UPLOS, 
   int                        * NTRAN,
   enum ATLAS_TRANS           ** TRANS, 
   int                        * NDIAG,
   enum ATLAS_DIAG            ** DIAGS, 
   int                        * M0,
   int                        * MN,
   int                        * MINC,
   int                        * N0,
   int                        * NN,
   int                        * NINC, 
   int                        * KL0,
   int                        * KLN,
   int                        * KLINC,
   int                        * KU0,
   int                        * KUN,
   int                        * KUINC,
   int                        * NALPHA,
   TYPE                       ** ALPHAS, 
   int                        * NBETA,
   TYPE                       ** BETAS,
   int                        * NINCX,
   int                        ** INCXS,
   int                        * NINCY,
   int                        ** INCYS
)
{
   char                       ch;
   int                        i = 1, j;
/*
 * Set up defaults
 */
   *NROUT    = -1;                         /* No routine to be tested */
   *TEST     = 1;                               /* Enable the testing */
   *LDA_IS_M = 0;    /* Leading dimension chosen as max testing value */
   *MFLOP    = 0;                /* smallest number of flops possible */
                                            /* Default bandwidth is 1 */
#ifdef L2SIZE
   *CACHESIZE = L2SIZE;               /* Size of largest cache to flush */
#else
   *CACHESIZE = 4*1024*1024;
#endif

   *KL0      = *KU0   = *KLN   = *KUN   = *KLINC = *KUINC = 1;

   *NUPLO    = *NTRAN = *NDIAG = -1;
   *M0       = *N0    = -1;
   *NALPHA   = *NBETA = -1;
   *NINCX    = *NINCY = -1;

   fprintf(stdout, "\n\n");
   for (i=0; i < NARGS; i++) fprintf(stdout, "%s ", ARGS[i]);
   fprintf(stdout, "\n\n");
   for( i = 1; i < NARGS; )
   {
      if( ARGS[i][0] != '-' ) PrintUsage( ARGS[0] );

      switch( ARGS[i++][1] )
      {
         case 'h':
            PrintUsage( ARGS[0] );
            break; 
         case 'T':
            if( ARGS[i] == NULL ) PrintUsage( ARGS[0] );
            *TEST = atoi( ARGS[i++] );
            break;
         case 'd':
            *LDA_IS_M = 1;
            break;
         case 'F':
            if( ARGS[i] == NULL ) PrintUsage( ARGS[0] );
            *MFLOP = atoi( ARGS[i++] );
            if( *MFLOP < 0      ) PrintUsage( ARGS[0] );
            break;
         case 'C':
            if( ARGS[i] == NULL ) PrintUsage( ARGS[0] );
	    *CACHESIZE = 1024*atoi(ARGS[i++]);
            break;
         case 'U':
            if( ARGS[i] == NULL ) PrintUsage( ARGS[0] );
            *NUPLO = atoi( ARGS[i++] );
            if( *NUPLO <= 0     ) PrintUsage( ARGS[0] );
            *UPLOS = (enum ATLAS_UPLO *)malloc( *NUPLO *
                                                sizeof( enum ATLAS_UPLO ) );
            ATL_assert( *UPLOS );
            for( j = 0; j != *NUPLO; j++)
            {
               if( ARGS[i] == NULL ) PrintUsage( ARGS[0] );
               ch = *ARGS[i++];
               if(      ch == 'u' || ch == 'U' ) (*UPLOS)[j] = AtlasUpper;
               else if( ch == 'l' || ch == 'L' ) (*UPLOS)[j] = AtlasLower;
               else PrintUsage( ARGS[0] );
            }
            break;
         case 'D':
            if( ARGS[i] == NULL ) PrintUsage( ARGS[0] );
            *NDIAG = atoi( ARGS[i++] );
            if( *NDIAG <= 0     ) PrintUsage( ARGS[0] );
            *DIAGS = (enum ATLAS_DIAG *)malloc( *NDIAG * 
                                                sizeof( enum ATLAS_DIAG ) );
            ATL_assert( *DIAGS );
            for( j = 0; j != *NDIAG; j++ )
            {
               if( ARGS[i] == NULL ) PrintUsage( ARGS[0] );
               ch = *ARGS[i++];
               if(      ch == 'u' || ch == 'U' ) (*DIAGS)[j] = AtlasUnit;
               else if( ch == 'n' || ch == 'N' ) (*DIAGS)[j] = AtlasNonUnit;
               else PrintUsage( ARGS[0] );
            }
            break;
         case 'A':
            if( ARGS[i] == NULL ) PrintUsage( ARGS[0] );
            *NTRAN = atoi(ARGS[i++]);
            if( *NTRAN <= 0     ) PrintUsage( ARGS[0] );
            *TRANS = (enum ATLAS_TRANS *)malloc( *NTRAN *
                                                 sizeof( enum ATLAS_TRANS ) );
            ATL_assert( *TRANS );
            for( j = 0; j != *NTRAN; j++ )
            {
               if( ARGS[i] == NULL ) PrintUsage( ARGS[0] );
               ch = *ARGS[i++];
               if(      ch == 'n' || ch == 'N' ) (*TRANS)[j] = AtlasNoTrans;
               else if( ch == 't' || ch == 'T' ) (*TRANS)[j] = AtlasTrans;
               else if( ch == 'c' || ch == 'C' ) (*TRANS)[j] = AtlasConjTrans;
               else PrintUsage( ARGS[0] );
            }
            break;

         case 'M':
            if( ARGS[i] == NULL ) PrintUsage( ARGS[0] );
            *M0 = atoi( ARGS[i++] );
            if( *M0 < 0         ) PrintUsage( ARGS[0] );
            if( ARGS[i] == NULL ) PrintUsage( ARGS[0] );
            *MN = atoi( ARGS[i++] );
            if( *MN < 0         ) PrintUsage( ARGS[0] );
            if( ARGS[i] == NULL ) PrintUsage( ARGS[0] );
            *MINC = atoi( ARGS[i++] );
            if( *MINC <= 0      ) PrintUsage( ARGS[0] );
            break;
         case 'm':
            if( ARGS[i] == NULL ) PrintUsage( ARGS[0] );
            *M0 = *MN = atoi( ARGS[i++] ); *MINC = 1;
            if( *M0 <= 0        ) PrintUsage( ARGS[0] );
            break;
         case 'N':
            if( ARGS[i] == NULL ) PrintUsage( ARGS[0] );
            *N0 = atoi( ARGS[i++] );
            if( *N0 < 0         ) PrintUsage( ARGS[0] );
            if( ARGS[i] == NULL ) PrintUsage( ARGS[0] );
            *NN = atoi( ARGS[i++] );
            if( *NN < 0         ) PrintUsage( ARGS[0] );
            if( ARGS[i] == NULL ) PrintUsage( ARGS[0] );
            *NINC = atoi( ARGS[i++] );
            if( *NINC <= 0      ) PrintUsage( ARGS[0] );
            break;
         case 'n':
            if( ARGS[i] == NULL ) PrintUsage( ARGS[0] );
            *N0 = *NN = atoi( ARGS[i++] ); *NINC = 1;
            if( *N0 < 0         ) PrintUsage( ARGS[0] );
            break;
         case 'P':
            if( ARGS[i] == NULL ) PrintUsage( ARGS[0] );
            *KL0 = atoi( ARGS[i++] );
            if( *KL0 < 0        ) PrintUsage( ARGS[0] );
            if( ARGS[i] == NULL ) PrintUsage( ARGS[0] );
            *KLN = atoi( ARGS[i++] );
            if( *KLN < 0        ) PrintUsage( ARGS[0] );
            if( ARGS[i] == NULL ) PrintUsage( ARGS[0] );
            *KLINC = atoi( ARGS[i++] );
            if( *KLINC <= 0     ) PrintUsage( ARGS[0] );
            break;
         case 'p':
            if( ARGS[i] == NULL ) PrintUsage( ARGS[0] );
            *KL0 = *KLN = atoi( ARGS[i++] ); *KLINC = 1;
            if( *KL0 <  0       ) PrintUsage( ARGS[0] );
            break;
         case 'Q':
            if( ARGS[i] == NULL ) PrintUsage( ARGS[0] );
            *KU0 = atoi( ARGS[i++] );
            if( *KU0 < 0        ) PrintUsage( ARGS[0] );
            if( ARGS[i] == NULL ) PrintUsage( ARGS[0] );
            *KUN = atoi( ARGS[i++] );
            if( *KUN < 0        ) PrintUsage( ARGS[0] );
            if( ARGS[i] == NULL ) PrintUsage( ARGS[0] );
            *KUINC = atoi( ARGS[i++] );
            if( *KUINC <= 0     ) PrintUsage( ARGS[0] );
            break;
         case 'q':
            if( ARGS[i] == NULL ) PrintUsage( ARGS[0] );
            *KU0 = *KUN = atoi( ARGS[i++] ); *KUINC = 1;
            if( *KU0 <  0       ) PrintUsage( ARGS[0] );
            break;

         case 'a':
            if( ARGS[i] == NULL ) PrintUsage( ARGS[0] );
            *NALPHA = atoi( ARGS[i++] );
            if( *NALPHA <= 0    ) PrintUsage( ARGS[0] );
            *ALPHAS = (TYPE *)malloc( ATL_MulBySize( *NALPHA ) );
            ATL_assert( *ALPHAS );
            for( j = 0; j < (*NALPHA SHIFT); j++ )
            {
               if( ARGS[i] == NULL ) PrintUsage( ARGS[0] );
               (*ALPHAS)[j] = (TYPE)atof( ARGS[i++] );
            }
            break;
         case 'b':
            if( ARGS[i] == NULL ) PrintUsage( ARGS[0] );
            *NBETA  = atoi( ARGS[i++] );
            if( *NBETA <= 0     ) PrintUsage( ARGS[0] );
            *BETAS  = (TYPE *)malloc( ATL_MulBySize( *NBETA ) );
            ATL_assert( *BETAS );
            for( j = 0; j < (*NBETA SHIFT); j++ )
            {
               if( ARGS[i] == NULL ) PrintUsage( ARGS[0] );
               (*BETAS)[j] = (TYPE)atof( ARGS[i++] );
            }
            break;

         case 'X':
            if( ARGS[i] == NULL ) PrintUsage( ARGS[0] );
            *NINCX = atoi( ARGS[i++] );
            if( *NINCX <= 0     ) PrintUsage( ARGS[0] );
            *INCXS = (int *)malloc( *NINCX * sizeof( int ) );
            ATL_assert( *INCXS );
            for( j = 0; j < *NINCX; j++ )
            {
               if( ARGS[i] == NULL ) PrintUsage( ARGS[0] );
               (*INCXS)[j] = atoi( ARGS[i++] );
            }
            break;
         case 'Y':
            if( ARGS[i] == NULL ) PrintUsage( ARGS[0] );
            *NINCY = atoi( ARGS[i++] );
            if( *NINCY <= 0     ) PrintUsage( ARGS[0] );
            *INCYS = (int *)malloc( *NINCY * sizeof( int ) );
            ATL_assert( *INCYS );
            for( j = 0; j < *NINCY; j++ )
            {
               if( ARGS[i] == NULL ) PrintUsage( ARGS[0] );
               (*INCYS)[j] = atoi( ARGS[i++] );
            }
            break;

         case 'R':
            if( ARGS[i] == NULL ) PrintUsage( ARGS[0] );

            if( ( strcmp( ARGS[i], "ALL"  ) == 0 ) ||
                ( strcmp( ARGS[i], "all"  ) == 0 ) )
            {
#ifdef TREAL
               *NROUT = 16;
#else
               *NROUT = 17;
#endif
               *ROUTS = (enum LVL2_ROUT *)malloc( (*NROUT) * 
                                                  sizeof( enum LVL2_ROUT ) );
               ATL_assert( *ROUTS );

               (*ROUTS)[ 0] = GBMV; (*ROUTS)[ 1] = GEMV; (*ROUTS)[ 2] = SBMV; 
               (*ROUTS)[ 3] = SPMV; (*ROUTS)[ 4] = SYMV; (*ROUTS)[ 5] = TBMV; 
               (*ROUTS)[ 6] = TPMV; (*ROUTS)[ 7] = TRMV; (*ROUTS)[ 8] = TBSV; 
               (*ROUTS)[ 9] = TPSV; (*ROUTS)[10] = TRSV; 
#ifdef TREAL
               (*ROUTS)[11] = GERC; (*ROUTS)[12] = SPR;  (*ROUTS)[13] = SYR;
               (*ROUTS)[14] = SPR2; (*ROUTS)[15] = SYR2; 
#else
               (*ROUTS)[11] = GERC; (*ROUTS)[12] = GERU; (*ROUTS)[13] = SPR; 
               (*ROUTS)[14] = SYR;  (*ROUTS)[15] = SPR2; (*ROUTS)[16] = SYR2; 
#endif
               i++;
            }
            else
            {
               if( isdigit( *ARGS[i] ) ) { *NROUT = atoi( ARGS[i++] ); }
               else                      { *NROUT = 1;                 }
               *ROUTS = (enum LVL2_ROUT *)malloc( (*NROUT) * 
                                                  sizeof( enum LVL2_ROUT ) );
               ATL_assert( *ROUTS );

               for( j = 0; j < *NROUT; j++ )
               {
                  if( ARGS[i] == NULL ) PrintUsage( ARGS[0] );

                  if(      ( strcmp( ARGS[i], "GBMV" ) == 0 ) ||
                           ( strcmp( ARGS[i], "gbmv" ) == 0 ) )
                     (*ROUTS)[j] = GBMV;
                  else if( ( strcmp( ARGS[i], "GEMV" ) == 0 ) ||
                           ( strcmp( ARGS[i], "gemv" ) == 0 ) )
                     (*ROUTS)[j] = GEMV;
#ifdef TREAL
                  else if( ( strcmp( ARGS[i], "SBMV" ) == 0 ) ||
                           ( strcmp( ARGS[i], "sbmv" ) == 0 ) )
                     (*ROUTS)[j] = SBMV;
                  else if( ( strcmp( ARGS[i], "SPMV" ) == 0 ) ||
                           ( strcmp( ARGS[i], "spmv" ) == 0 ) )
                     (*ROUTS)[j] = SPMV;
                  else if( ( strcmp( ARGS[i], "SYMV" ) == 0 ) ||
                           ( strcmp( ARGS[i], "symv" ) == 0 ) )
                     (*ROUTS)[j] = SYMV;
#else
                  else if( ( strcmp( ARGS[i], "HBMV" ) == 0 ) ||
                           ( strcmp( ARGS[i], "hbmv" ) == 0 ) )
                     (*ROUTS)[j] = SBMV;
                  else if( ( strcmp( ARGS[i], "HPMV" ) == 0 ) ||
                           ( strcmp( ARGS[i], "hpmv" ) == 0 ) )
                     (*ROUTS)[j] = SPMV;
                  else if( ( strcmp( ARGS[i], "HEMV" ) == 0 ) ||
                           ( strcmp( ARGS[i], "hemv" ) == 0 ) )
                     (*ROUTS)[j] = SYMV;
#endif
                  else if( ( strcmp( ARGS[i], "TBMV" ) == 0 ) ||
                           ( strcmp( ARGS[i], "tbmv" ) == 0 ) )
                     (*ROUTS)[j] = TBMV;
                  else if( ( strcmp( ARGS[i], "TPMV" ) == 0 ) ||
                           ( strcmp( ARGS[i], "tpmv" ) == 0 ) )
                     (*ROUTS)[j] = TPMV;
                  else if( ( strcmp( ARGS[i], "TRMV" ) == 0 ) ||
                           ( strcmp( ARGS[i], "trmv" ) == 0 ) )
                     (*ROUTS)[j] = TRMV;

                  else if( ( strcmp( ARGS[i], "TBSV" ) == 0 ) ||
                           ( strcmp( ARGS[i], "tbsv" ) == 0 ) )
                     (*ROUTS)[j] = TBSV;
                  else if( ( strcmp( ARGS[i], "TPSV" ) == 0 ) ||
                           ( strcmp( ARGS[i], "tpsv" ) == 0 ) )
                     (*ROUTS)[j] = TPSV;
                  else if( ( strcmp( ARGS[i], "TRSV" ) == 0 ) ||
                           ( strcmp( ARGS[i], "trsv" ) == 0 ) )
                     (*ROUTS)[j] = TRSV;
#ifdef TREAL
                  else if( ( strcmp( ARGS[i], "GER"  ) == 0 ) ||
                           ( strcmp( ARGS[i], "ger"  ) == 0 ) )
                     (*ROUTS)[j] = GERU;
                  else if( ( strcmp( ARGS[i], "GER2"  ) == 0 ) ||
                           ( strcmp( ARGS[i], "ger2"  ) == 0 ) )
                     (*ROUTS)[j] = GER2U;
                  else if( ( strcmp( ARGS[i], "SPR"  ) == 0 ) ||
                           ( strcmp( ARGS[i], "spr"  ) == 0 ) )
                     (*ROUTS)[j] = SPR;
                  else if( ( strcmp( ARGS[i], "SYR"  ) == 0 ) ||
                           ( strcmp( ARGS[i], "syr"  ) == 0 ) )
                     (*ROUTS)[j] = SYR;
                  else if( ( strcmp( ARGS[i], "SPR2" ) == 0 ) ||
                           ( strcmp( ARGS[i], "spr2" ) == 0 ) )
                     (*ROUTS)[j] = SPR2;
                  else if( ( strcmp( ARGS[i], "SYR2" ) == 0 ) ||
                           ( strcmp( ARGS[i], "syr2" ) == 0 ) )
                     (*ROUTS)[j] = SYR2;
#else
                  else if( ( strcmp( ARGS[i], "GERU" ) == 0 ) ||
                           ( strcmp( ARGS[i], "geru" ) == 0 ) )
                     (*ROUTS)[j] = GERU;
                  else if( ( strcmp( ARGS[i], "GERC" ) == 0 ) ||
                           ( strcmp( ARGS[i], "gerc" ) == 0 ) )
                     (*ROUTS)[j] = GERC;
                  else if( ( strcmp( ARGS[i], "GER2U" ) == 0 ) ||
                           ( strcmp( ARGS[i], "ger2u" ) == 0 ) )
                     (*ROUTS)[j] = GER2U;
                  else if( ( strcmp( ARGS[i], "GER2C" ) == 0 ) ||
                           ( strcmp( ARGS[i], "ger2c" ) == 0 ) )
                     (*ROUTS)[j] = GER2C;
                  else if( ( strcmp( ARGS[i], "HPR"  ) == 0 ) ||
                           ( strcmp( ARGS[i], "hpr"  ) == 0 ) )
                     (*ROUTS)[j] = SPR;
                  else if( ( strcmp( ARGS[i], "HER"  ) == 0 ) ||
                           ( strcmp( ARGS[i], "her"  ) == 0 ) )
                     (*ROUTS)[j] = SYR;
                  else if( ( strcmp( ARGS[i], "HPR2" ) == 0 ) ||
                           ( strcmp( ARGS[i], "hpr2" ) == 0 ) )
                     (*ROUTS)[j] = SPR2;
                  else if( ( strcmp( ARGS[i], "HER2" ) == 0 ) ||
                           ( strcmp( ARGS[i], "her2" ) == 0 ) )
                     (*ROUTS)[j] = SYR2;
#endif
                  else PrintUsage( ARGS[0] );
                  i++;
               } 
            } 
            break;
         default:
            PrintUsage( ARGS[0] );
            break;
      }
   }
/*
 * Finish setting up defaults if the user has not selected
 */
   if( *NROUT == -1 )
   {
      *NROUT = 1;
      *ROUTS = (enum LVL2_ROUT *)malloc( sizeof( enum LVL2_ROUT ) );
      ATL_assert( *ROUTS );
      (*ROUTS)[0] = GEMV;
   }

   if( *NUPLO == -1 )
   {
      *NUPLO = 1;
      *UPLOS = (enum ATLAS_UPLO *)malloc( sizeof( enum ATLAS_UPLO ) );
      ATL_assert( *UPLOS );
      (*UPLOS)[0] = AtlasLower;
   }
   if( *NTRAN == -1 )
   {
      *NTRAN = 1;
      *TRANS = (enum ATLAS_TRANS *)malloc( sizeof( enum ATLAS_TRANS ) );
      ATL_assert( *TRANS );
      (*TRANS)[0] = AtlasNoTrans;
   }
   if( *NDIAG == -1 )
   {
      *NDIAG = 1;
      *DIAGS = (enum ATLAS_DIAG *)malloc( sizeof( enum ATLAS_DIAG ) );
      ATL_assert( *DIAGS );
      (*DIAGS)[0] = AtlasNonUnit;
   }

   if( *N0 == -1 ) { *N0 = 100; *NN = 1000; *NINC = 100; }

   if( *NALPHA == -1 )
   {
      *NALPHA = 1;
      *ALPHAS = (TYPE *)malloc( ATL_MulBySize( 1 ) );
      ATL_assert( *ALPHAS );
#ifdef TREAL
      (*ALPHAS)[0] = ATL_rone;
#else
      (*ALPHAS)[0] = ATL_rone;
      (*ALPHAS)[1] = ATL_rzero;
#endif
   }
   if( *NBETA == -1 )
   {
      *NBETA = 1;
      *BETAS = (TYPE *)malloc( ATL_MulBySize( 1 ) );
      ATL_assert( *BETAS );
#ifdef TREAL
      (*BETAS)[0] = ATL_rone;
#else
      (*BETAS)[0] = ATL_rone;
      (*BETAS)[1] = ATL_rzero;
#endif
   }

   if( *NINCX == -1 )
   {
      *NINCX = 1;
      *INCXS = (int *)malloc(sizeof(int));
      ATL_assert( *INCXS );
      (*INCXS)[0] = 1;
   }
   if( *NINCY == -1 )
   {
      *NINCY = 1;
      *INCYS = (int *)malloc( sizeof( int ) );
      ATL_assert( *INCYS );
      (*INCYS)[0] = 1;
   }
}

int main( int NARGS, char **ARGS )
{
   int                        klinc, klstart, klstop, kuinc, kustart,
                              kustop, ldaism, mflopmin, minc, mstart,
                              mstop, ninc, nstart, nstop, nalpha, nbeta,
                              cachesize,
                              ndiag, nincx, nincy, nrout, ntran, nuplo, test;
   int                        * incxs  = NULL, * incys = NULL;
   TYPE                       * alphas = NULL, * betas = NULL;
   enum LVL2_ROUT             * routs  = NULL;
   enum ATLAS_UPLO            * uplos  = NULL;
   enum ATLAS_TRANS           * trans  = NULL;
   enum ATLAS_DIAG            * diags  = NULL;

   GetFlags( NARGS, ARGS, &nrout, &routs, &test, &ldaism, &cachesize,
	     &mflopmin, &nuplo, &uplos, &ntran, &trans, &ndiag, &diags,
	     &mstart, &mstop, &minc, &nstart, &nstop, &ninc, &klstart,
	     &klstop, &klinc, &kustart, &kustop, &kuinc, &nalpha,
	     &alphas, &nbeta, &betas, &nincx, &incxs, &nincy, &incys );

   RunCases( test, cachesize, mflopmin, ldaism, nuplo, uplos, ntran, trans,
	     ndiag, diags, mstart, mstop, minc, nstart, nstop, ninc, klstart,
             klstop, klinc, kustart, kustop, kuinc, nalpha, alphas, nbeta,
             betas, nincx, incxs, nincy, incys, nrout, routs );

   if( uplos  ) free( uplos  );
   if( trans  ) free( trans  );
   if( diags  ) free( diags  );
   if( alphas ) free( alphas );
   if( incxs  ) free( incxs  );
   if( incys  ) free( incys  );
   if( betas  ) free( betas  );
   if( routs  ) free( routs  );

   return( 0 );
}
@ROUT l3time
@extract -b @(topd)/cw.inc lang=C -def author "R. Clint Whaley" -def contrib "Jeff Horner, Antoine Petitet" -def cwdate 2014
@define rname @l3time@
@rout l3blastst
@extract -b @(topd)/gen.inc what=cw -def author "Jeff Horner" -def contrib "Antoine Petitet, R. Clint Whaley" -def cdate 1998
@define rname @l3blastst@
@ROUT l3time l3blastst
/*
 * =====================================================================
 * Include files
 * =====================================================================
 */
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <assert.h>
#ifdef GCCWIN
   ___main(){} __main(){} MAIN__(){} _MAIN_(){}
   #ifndef isdigit
      #define isdigit(ch_) ( ((ch_)=='0')||((ch_)=='1')||((ch_)=='2')|| \
                             ((ch_)=='3')||((ch_)=='4')||((ch_)=='5')|| \
                             ((ch_)=='6')||((ch_)=='7')||((ch_)=='8')|| \
                             ((ch_)=='9') )
   #endif
#else
   #include <ctype.h>
#endif
 
#include "atlas_misc.h"
#include "atlas_tst.h"
/*
 * =====================================================================
 * #define macro constants
 * =====================================================================
 */
#define    MEGA                     1000000.0
#if defined( SREAL ) || defined( SCPLX )
   #define    THRESH                        50.0f
#else
   #define    THRESH                        50.0
#endif
static int NSAMP=1;
 
/* #define    ATLAS_DEBUG */
/*
 * =====================================================================
 * # macro functions
 * =====================================================================
 *
 * The following and mutually exclusive  macros  allow to select various
 * BLAS implementations to test the ATLAS implementation against:
 *
 *    USE_F77_BLAS     : Fortran 77 BLAS interface,
 *    USE_L3_REFERENCE : C ATLAS reference implementation,
 *
 * If none of these macros is defined at compile time, the  ATLAS imple-
 * mentation is to be tested against itself,  after all this is the only
 * version we are sure to have available.
 *
 * By default the mono-threaded  ATLAS  routines are tested. To test the
 * multi-threaded ATLAS routines, define the following macro:
 *    USE_L3_PTHREADS  : multi-threaded ATLAS implementation.
 */
@ROUT l3time
#define USE_F77_BLAS 
@ROUT l3blastst
#ifndef USE_L3_REFERENCE
   #define USE_F77_BLAS
#endif
@ROUT l3blastst l3time
#ifdef ATL_USEPTHREADS
#define USE_L3_PTHREADS
#endif
/*
 * If you define APR, then Antoine's original recursive BLAS will be called
 * for test_blas.  Right now, this affects only herk & syrk.
 */
/* #define APR 1 */

@skip #ifdef USE_L3_PTHREADS
@skip   #define THREADS_AvC   /* tests antoine's original threads against new */
@skip #endif
#ifndef USE_L3_PTHREADS
@skip   #ifdef ATL_TRUST_OMP
@skip      #undef ATL_TRUST_OMP
@skip   #endif
#endif
@skip #ifdef ATL_TRUST_OMP
@skip   #include "atlas_omplvl3.h"
@skip #endif
/*
 * =====================================================================
 */
#if defined(USE_F77_BLAS) || defined(TEST_F77) 
   #define  TP3 Mjoin(PATL,f77)
#elif defined( USE_L3_REFERENCE )
   #include "atlas_reflevel3.h"
   #define  TP3      Mjoin( PATL,   ref )
#else /* defined( USE_L3_ATLAS ) */  /* use ATLAS itself !! (default) */
   #include "atlas_level3.h"
   #define  TP3      PATL
#endif


#define trusted_gemm(TA, TB, M, N, K, al, A, lA, B, lB, be, C, lC) \
   Mjoin(TP3, gemm)(TA, TB, M, N, K, al, A, lA, B, lB, be, C, lC)
#define trusted_trsm( SI, UP, TA, DI, M, N, al, A, lA, B, lB) \
   Mjoin( TP3, trsm  )(  SI, UP, TA, DI, M, N,    al, A, lA, B, lB)
#define trusted_trmm(SI, UP, TA, DI, M, N, al, A, lA, B, lB) \
   Mjoin( TP3, trmm  )(SI, UP, TA, DI, M, N,  al, A, lA, B, lB)
#define trusted_syr2k(UP, TA, N, K, al, A, lA, B, lB, be, C, lC) \
   Mjoin( TP3, syr2k )(UP, TA, N, K, al, A, lA, B, lB, be, C, lC)
#define trusted_symm(SI, UP, M, N, al, A, lA, B, lB, be, C, lC) \
   Mjoin(TP3,symm)(SI, UP, M, N, al, A, lA, B, lB, be, C, lC)
#ifdef APR
   #define trusted_syrk(UP, TA, N, K, al, A, lA, be, C, lC) \
      Mjoin(PATL,syrk_APR)(UP, TA, N, K, al, A, lA, be, C, lC)
#else
   #define trusted_syrk(UP, TA, N, K, al, A, lA, be, C, lC) \
      Mjoin(TP3, syrk)(UP, TA, N, K, al, A, lA, be, C, lC)
#endif
#ifdef TCPLX
   #ifdef APR
      #define trusted_herk(UP, TA, N, K, al, A, lA, be, C, lC) \
         Mjoin(PATL,herk_APR)(UP, TA, N, K, al, A, lA, be, C, lC)
   #else
      #define trusted_herk(UP, TA, N, K, al, A, lA, be, C, lC) \
         Mjoin(TP3, herk)(UP, TA, N, K, al, A, lA, be, C, lC)
   #endif
   #define trusted_her2k(UP, TA, N, K, al, A, lA, B, lB, be, C, lC) \
      Mjoin(TP3,her2k)(UP, TA, N, K, al, A, lA, B, lB, be, C, lC)
   #define trusted_hemm( SI, UP, M, N, al, A, lA, B, lB, be, C, lC) \
      Mjoin(TP3,hemm)(SI, UP, M, N, al, A, lA, B, lB, be, C, lC)
#endif

/*
 * ATLAS version of the BLAS to test.
 */
/* #define PSPRK */
/* #define HPRK */
/* #define AMSYRK 1 */
#ifdef AMSYRK
   #include "atlas_amm.h"
#endif
#if defined(PSPRK) || defined(HPRK)
#include "atlas_pkblas.h"
#endif
#if defined(TEST_F77) 
   #define  AP3 Mjoin(PATL,f77)
   #define  AP4 Mjoin(PATL,f77)
#elif defined(USE_L3_PTHREADS)
   #include "atlas_pthreads.h"
   #include "atlas_ptlvl3.h"
   #include "atlas_tlvl3.h"
   #define  AP3      Mjoin(PATL, t)
   #define  AP4      Mjoin( PATL,   t  )
#else
   #include "atlas_level3.h"
   #define  AP3      PATL
   #define  AP4      PATL
#endif
#include "atlas_bitvec.h"
#include "atlas_amm.h"

#ifdef THREADS_AvC
   #define test_gemm(TA, TB, M, N, K, al, A, lA, B, lB, be, C, lC) \
      Mjoin(PATL,tgemm)(TA, TB, M, N, K, al, A, lA, B, lB, be, C, lC)
   #define test_trsm(SI, UP, TA, DI, M, N, al, A, lA, B, lB) \
      Mjoin(PATL,ttrsm)(SI, UP, TA, DI, M, N, al, A, lA, B, lB)
   #define test_trmm(SI, UP, TA, DI, M, N, al, A, lA, B, lB) \
      Mjoin(PATL,ttrmm)(SI, UP, TA, DI, M, N, al, A, lA, B, lB)
   #define test_syr2k(UP, TA, N, K, al, A, lA, B, lB, be, C, lC) \
      Mjoin(PATL,tsyr2k)(UP, TA, N, K, al, A, lA, B, lB, be, C, lC)
   #define test_symm(SI, UP, M, N, al, A, lA, B, lB, be, C, lC) \
      Mjoin(PATL,tsymm)(SI, UP, M, N, al, A, lA, B, lB, be, C, lC)
   #ifdef SYRK_AMM
      #define test_syrk(UP, TA, N, K, al, A, lA, be, C, lC) \
         Mjoin(PATL,tsyrk_amm)(UP, TA, N, K, al, A, lA, be, C, lC)
   #elif !defined(PSPRK)
      #define test_syrk(UP, TA, N, K, al, A, lA, be, C, lC) \
         Mjoin(PATL,tsyrk)(UP, TA, N, K, al, A, lA, be, C, lC)
   #else
      #define test_syrk(UP, TA, N, K, al, A, lA, be, C, lC) \
         Mjoin(PATL,sprk)(PackGen, TA, UP, 0, N, K, al, A, 0, 0, lA, \
                          be, C, 0, 0, lC)
   #endif
   #ifdef TCPLX
      #define test_her2k(UP, TA, N, K, al, A, lA, B, lB, be, C, lC) \
         Mjoin(PATL, ther2k)(UP, TA, N, K, al, A, lA, B, lB, be, C, lC)
      #define test_hemm(SI, UP, M, N, al, A, lA, B, lB, be, C, lC) \
         Mjoin(PATL,themm)(SI, UP, M, N, al, A, lA, B, lB, be, C, lC)
      #ifndef HPRK
         #define test_herk(UP, TA, N, K, al, A, lA, be, C, lC) \
            Mjoin(PATL,therk)(UP, TA, N, K, al, A, lA, be, C, lC)
      #else
         #define test_herk(UP, TA, N, K, al, A, lA, be, C, lC) \
            Mjoin(PATL,hprk)(PackGen, TA, UP, 0, N, K, al, A, 0, 0, lA, \
                             be, C, 0, 0, lC)
      #endif
   #endif
#else
   #define test_gemm(TA, TB, M, N, K, al, A, lA, B, lB, be, C, lC) \
      Mjoin( AP4, gemm  )(TA, TB, M, N, K, al, A, lA, B, lB, be, C, lC)
   #define test_trsm(SI, UP, TA, DI, M, N, al, A, lA, B, lB) \
      Mjoin(AP4, trsm)(SI, UP, TA, DI, M, N, al, A, lA, B, lB)
   #define test_trmm(SI, UP, TA, DI, M, N, al, A, lA, B, lB) \
      Mjoin( AP4, trmm  )(SI, UP, TA, DI, M, N, al, A, lA, B, lB)
   #define test_syr2k(UP, TA, N, K, al, A, lA, B, lB, be, C, lC) \
      Mjoin( AP4, syr2k )(UP, TA, N, K, al, A, lA, B, lB, be, C, lC)
   #define test_symm(SI, UP, M, N, al, A, lA, B, lB, be, C, lC) \
      Mjoin(AP4,symm)(SI, UP, M, N, al, A, lA, B, lB, be, C, lC)
   #if defined(AMSYRK)
      #define test_syrk(UP, TA, N, K, al, A, lA, be, C, lC) \
         Mjoin(PATL,syrk_IP)(UP, TA, N, K, al, A, lA, be, C, lC)
   #elif defined(SYRK_AMM)
      #ifdef USE_L3_PTHREADS
         #define test_syrk(UP, TA, N, K, al, A, lA, be, C, lC) \
            Mjoin(PATL,tsyrk_amm)(UP, TA, N, K, al, A, lA, be, C, lC)
      #else
         #define test_syrk(UP, TA, N, K, al, A, lA, be, C, lC) \
            Mjoin(PATL,syrk_amm)(UP, TA, N, K, al, A, lA, be, C, lC)
      #endif
   #elif defined(PSPRK)
      #define test_syrk(UP, TA, N, K, al, A, lA, be, C, lC) \
         Mjoin(PATL,sprk)(PackGen, TA, UP, 0, N, K, al, A, 0, 0, lA, \
                          be, C, 0, 0, lC)
   #else
      #define test_syrk(UP, TA, N, K, al, A, lA, be, C, lC) \
         Mjoin(AP4,syrk)(UP, TA, N, K, al, A, lA, be, C, lC)
   #endif
   #ifdef TCPLX
      #define test_her2k(UP, TA, N, K, al, A, lA, B, lB, be, C, lC) \
         Mjoin( AP4, her2k )(UP, TA, N, K, al, A, lA, B, lB, be, C, lC)
      #define test_hemm(SI, UP, M, N, al, A, lA, B, lB, be, C, lC) \
         Mjoin(AP4,hemm)(SI, UP, M, N, al, A, lA, B, lB, be, C, lC)
      #if defined(AMSYRK)
         #define test_herk(UP, TA, N, K, al, A, lA, be, C, lC) \
            Mjoin(PATL,herk_IP)(UP, TA, N, K, al, A, lA, be, C, lC)
      #elif defined(SYRK_AMM)
         #define test_herk(UP, TA, N, K, al, A, lA, be, C, lC) \
            Mjoin(PATL,herk_amm)(UP, TA, N, K, al, A, lA, be, C, lC)
      #elif defined(HPRK)
         #define test_herk(UP, TA, N, K, al, A, lA, be, C, lC) \
            Mjoin(PATL,hprk)(PackGen, TA, UP, 0, N, K, al, A, 0, 0, lA, \
                             be, C, 0, 0, lC)
      #else
         #define test_herk(UP, TA, N, K, al, A, lA, be, C, lC) \
            Mjoin(AP4,herk)(UP, TA, N, K, al, A, lA, be, C, lC)
      #endif
   #endif
#endif

/*
 * =====================================================================
 * macro functions
 * =====================================================================
 */
#ifdef TCPLX
#define Mabs1(X) (Mabs(*X) + Mabs(*(X+1)))
#else
#define Mabs1(X) (Mabs(X))
#endif

#ifdef  ATL_NTHREADS
#define LCSIZE          ATL_NTHREADS * L2SIZE
#else
#define LCSIZE          L2SIZE
#endif
/*
 * =====================================================================
 * typedef definitions
 * =====================================================================
 */
#ifdef TREAL
enum LVL3_ROUT { GEMM=0, SYMM, SYRK, SYR2K, TRMM, TRSM, ALLROUTS }; 
#else
enum LVL3_ROUT
{ GEMM=0, HEMM, HERK, HER2K, SYMM, SYRK, SYR2K, TRMM, TRSM, ALLROUTS }; 
#endif
/*
 * =====================================================================
 * Prototypes for the testing routines
 * =====================================================================
 */
double     opbl3
(  const enum LVL3_ROUT,           const int,      const int,
   const int );
void       trddom
(  const enum ATLAS_UPLO,          const int,      TYPE *,
   const int );

TYPE       gemmtst
(  const int CACHESIZE,
   const enum LVL3_ROUT,           const int,      const enum ATLAS_TRANS,
   const enum ATLAS_TRANS,         const int,      const int,
   const int,      const SCALAR,   const int,      const int,
   const SCALAR,   const int,      const TYPE,     double *,
   double *,       double *,       double * );
TYPE       symmtst
(  const int CACHESIZE,
   const enum LVL3_ROUT,           const int,      const enum ATLAS_SIDE,
   const enum ATLAS_UPLO,          const int,      const int,
   const SCALAR,   const int,      const int,      const SCALAR,
   const int,      const TYPE,     double *,       double *,
   double *,       double * );
TYPE       syr2ktst
(  const int CACHESIZE,
   const enum LVL3_ROUT,           const int,      const enum ATLAS_UPLO,
   const enum ATLAS_TRANS,         const int,      const int,
   const SCALAR,   const int,      const int,      const SCALAR,
   const int,      const TYPE,     double *,       double *,
   double *,       double * );
TYPE       syrktst
(  const int CACHESIZE,
   const enum LVL3_ROUT,           const int,      const enum ATLAS_UPLO,
   const enum ATLAS_TRANS,         const int,      const int,
   const SCALAR,   const int,      const SCALAR,   const int,
   const TYPE,     double *,       double *,       double *,
   double * );
TYPE       trmmtst
(  const int CACHESIZE,
   const enum LVL3_ROUT,           const int,      const enum ATLAS_SIDE,
   const enum ATLAS_UPLO,          const enum ATLAS_TRANS,
   const enum ATLAS_DIAG,          const int,      const int,
   const SCALAR,   const int,      const int,      const TYPE,
   double *,       double *,       double *,       double * );
TYPE       trsmtst
(  const int CACHESIZE,
   const enum LVL3_ROUT,           const int,      const enum ATLAS_SIDE,
   const enum ATLAS_UPLO,          const enum ATLAS_TRANS,
   const enum ATLAS_DIAG,          const int,      const int,
   const SCALAR,   const int,      const int,      const TYPE,
   double *,       double *,       double *,       double * );

int        gemmcase
(  const int CACHESIZE,
   const enum LVL3_ROUT,           const int,      const int,
   const enum ATLAS_TRANS,         const enum ATLAS_TRANS,
   const int,      const int,      const int,      const SCALAR,
   const int,      const int,      const SCALAR,   const int,
   const TYPE,     double *,       double *,       double *,
   double * );
int        symmcase
(  const int CACHESIZE,
   const enum LVL3_ROUT,           const int,      const int,
   const enum ATLAS_SIDE,          const enum ATLAS_UPLO,
   const int,      const int,      const SCALAR,   const int,
   const int,      const SCALAR,   const int,      const TYPE,
   double *,       double *,       double *,       double * );
int        syr2kcase
(  const int CACHESIZE,
   const enum LVL3_ROUT,           const int,      const int,
   const enum ATLAS_UPLO,          const enum ATLAS_TRANS,
   const int,      const int,      const SCALAR,   const int,
   const int,      const SCALAR,   const int,      const TYPE,
   double *,       double *,       double *,       double * );
int        syrkcase
(  const int CACHESIZE,
   const enum LVL3_ROUT,           const int,      const int,
   const enum ATLAS_UPLO,          const enum ATLAS_TRANS,
   const int,      const int,      const SCALAR,   const int,
   const SCALAR,   const int,      const TYPE,     double *,
   double *,       double *,       double * ); 
int        trxmcase
(  const int CACHESIZE,
   const enum LVL3_ROUT,           const int,      const int,
   const enum ATLAS_SIDE,          const enum ATLAS_UPLO,
   const enum ATLAS_TRANS,         const enum ATLAS_DIAG,
   const int,      const int,      const SCALAR,   const int,
   const int,      const TYPE,     double *,       double *,
   double *,       double * );

@ROUT l3blastst
void       RungemmCase
(  const int CACHESIZE,
   const enum LVL3_ROUT,           const int,      const int,
   const int,      const int,      const enum ATLAS_TRANS *,
   const int,      const enum ATLAS_TRANS *,       int,      
   int,            int,            int,            int,      
   int,            int,            int,            int,      
   const int,      const TYPE *,   const int,      const TYPE *,
   const TYPE,     int *,          int * );
void      RunsymmCase
(  const int CACHESIZE,
   const enum LVL3_ROUT,           const int,      const int,
   const int,      const int,      const enum ATLAS_SIDE *,
   const int,      const enum ATLAS_UPLO *,        int,
   int,            int,            int,            int,
   int,            const int,      const TYPE *,   const int,
   const TYPE *,   const TYPE,     int *,          int * );
void      Runsyr2kCase
(  const int CACHESIZE,
   const enum LVL3_ROUT,           const int,      const int,
   const int,      const int,      const enum ATLAS_UPLO *,
   const int,      const enum ATLAS_TRANS *,       int,
   int,            int,            int,            int,
   int,            const int,      const TYPE *,   const int,
   const TYPE *,   const TYPE,     int *,          int * );
void      RunsyrkCase
(  const int CACHESIZE,
   const enum LVL3_ROUT,           const int,      const int,
   const int,      const int,      const enum ATLAS_UPLO *,
   const int,      const enum ATLAS_TRANS *,       int,
   int,            int,            int,            int,
   int,            const int,      const TYPE *,   const int,
   const TYPE *,   const TYPE,     int *,          int * );
void      RuntrxmCase
(  const int CACHESIZE,
   const enum LVL3_ROUT,           const int,      const int,
   const int,      const int,      const enum ATLAS_SIDE *,
   const int,      const enum ATLAS_UPLO *,        const int,
   const enum ATLAS_TRANS *,       const int,      const enum ATLAS_DIAG *,
   int,            int,            int,            int,
   int,            int,            const int,      const TYPE *,
   const TYPE,     int *,          int * );

void       RunCases
(  const int,      const int,      const int,      const int,
   const int,
   const enum ATLAS_SIDE *,        const int,      const enum ATLAS_UPLO *,
   const int,      const enum ATLAS_TRANS *,       const int,
   const enum ATLAS_TRANS *,       const int,      const enum ATLAS_DIAG *,
   const int,      const int,      const int,      const int,
   const int,      const int,      const int,      const int,
   const int,      const int,      const TYPE *,   const int,
   const TYPE *,   const int,      const enum LVL3_ROUT * );
 
void       PrintUsage
(  char * nam );
 
void       GetFlags
(  int,            char **,        int *,          enum LVL3_ROUT **,
   int *,          int *,          int *,          int *,
   int *,          enum ATLAS_SIDE **,             int *,
   enum ATLAS_UPLO **,             int *,          enum ATLAS_TRANS **,
   int *,          enum ATLAS_TRANS **,            int *,
   enum ATLAS_DIAG **,             int *,          int *,
   int *,          int *,          int *,          int *,
   int *,          int *,          int *,          int *,
   TYPE **,        int *,          TYPE ** );
@ROUT l3time l3blastst

int        main
(  int,            char ** );
/*
 * =====================================================================
 */
double opbl3
(
   const enum LVL3_ROUT       ROUT,
   const int                  M,
   const int                  N,
   const int                  K
)
{ 
   double                     adds = 0.0, em, en, ek, muls = 0.0;
/*
 * On entry,  M,  N,  and K contain parameter values used by the Level 3 
 * BLAS.  The output matrix is always M x N or N x N if symmetric, but K
 * has different uses in different contexts. For example, in the matrix-
 * matrix multiply routine,  we  have C = A * B where  C is M x N,  A is
 * M x K, and B is K x N. In xSYMM, xHEMM, xTRMM, and xTRSM, K indicates
 * whether the matrix A is applied on the left or right.  If K <= 0, the
 * matrix is aqpplied on the left, and if K > 0, on  the  right.
 */
   if( M <= 0 ) return( 0.0 );
 
   em = (double)(M); en = (double)(N); ek = (double)(K);

   if(      ROUT == GEMM ) { muls = em * ek * en; adds = em * ek * en; }
#ifdef TREAL
   else if( ROUT == SYMM )
#else
   else if( ( ROUT == SYMM ) || ( ROUT == HEMM ) )
#endif
   {                 /* If K <= 0, assume A multiplies B on the left. */
      if( K <= 0 ) { muls = em * em * en; adds = em * em * en; }
      else         { muls = em * en * en; adds = em * en * en; }
   }
   else if( ROUT == TRMM )
   {                 /* If K <= 0, assume A multiplies B on the left. */
      if( K <= 0 )
      {
         muls = en * em * ( em + 1.0 ) / 2.0;
         adds = en * em * ( em - 1.0 ) / 2.0;
      }
      else
      {
         muls = em * en * ( en + 1.0 ) / 2.0;
         adds = em * en * ( en - 1.0 ) / 2.0;
      }
   }
#ifdef TREAL
   else if( ROUT == SYRK )
#else
   else if( ( ROUT == SYRK ) || ( ROUT == HERK ) )
#endif
   {
      muls = ek * em * ( em + 1.0 ) / 2.0;
      adds = ek * em * ( em + 1.0 ) / 2.0;
   }
#ifdef TREAL
   else if( ROUT == SYR2K )
#else
   else if( ( ROUT == SYR2K ) || ( ROUT == HER2K ) )
#endif
   { muls = ek * em * em; adds = ek * em * em + em; }
   else if( ROUT == TRSM )
   {                 /* If K <= 0, assume A multiplies B on the left. */
      if( K <= 0 )
      {
         muls = en * em * ( em + 1.0 ) / 2.0;
         adds = en * em * ( em - 1.0 ) / 2.0;
      }
      else
      {
         muls = em * en * ( en + 1.0 ) / 2.0;
         adds = em * en * ( en - 1.0 ) / 2.0;
      }
   }
#ifdef TREAL
   return(       muls +       adds );
#else
   return( 6.0 * muls + 2.0 * adds );
#endif
} 

void trddom
(
   const enum ATLAS_UPLO      UPLO,
   const int                  N,
   TYPE                       * A,
   const int                  LDA
)
{
/*
 * Scale strictly lower (resp. upper) part of triangular matrix by 1 / N
 * to make it diagonally dominant.
 */
   int                        i, iaij, j, jaj, lda2 = ( LDA SHIFT ),
                              ldap12 = (( LDA + 1 ) SHIFT);
   TYPE                       alpha;
 
   if( N <= 0 ) return;
 
   alpha = ATL_rone / (TYPE)(N);

   if( UPLO == AtlasUpper )
   {
      for( j = 0, jaj = 0; j < N; j++, jaj += lda2 )
      {
         for( i = 0, iaij = jaj; i < j; i++, iaij += (1 SHIFT) )
         {
            A[iaij  ] *= alpha;
#ifdef TCPLX
            A[iaij+1] *= alpha;
#endif
         }
         if( A[iaij  ] >= ATL_rzero ) A[iaij  ] += ATL_rone;
         else                         A[iaij  ] -= ATL_rone;
#ifdef TCPLX
         if( A[iaij+1] >= ATL_rzero ) A[iaij+1] += ATL_rone;
         else                         A[iaij+1] -= ATL_rone;
#endif
      }
   }
   else
   {
      for( j = N-1, jaj = (N-1)*ldap12; j >= 0; j--, jaj -= ldap12 )
      {
         if( A[jaj  ] >= ATL_rzero ) A[jaj  ] += ATL_rone;
         else                        A[jaj  ] -= ATL_rone;
#ifdef TCPLX
         if( A[jaj+1] >= ATL_rzero ) A[jaj+1] += ATL_rone;
         else                        A[jaj+1] -= ATL_rone;
#endif
         for( i = j+1, iaij = jaj+(1 SHIFT); i < N; i++, iaij += (1 SHIFT) )
         {
            A[iaij  ] *= alpha;
#ifdef TCPLX
            A[iaij+1] *= alpha;
#endif
         }
      }
   }
}
/*
 * =====================================================================
 * tst functions
 * =====================================================================
 */
TYPE gemmtst
(
   const int                  CACHESIZE,
   const enum LVL3_ROUT       ROUT,
   const int                  TEST,
   const enum ATLAS_TRANS     TRANSA,
   const enum ATLAS_TRANS     TRANSB,
   const int                  M,
   const int                  N,
   const int                  K,
   const SCALAR               ALPHA,
   const int                  LDA,
   const int                  LDB,
   const SCALAR               BETA,
   const int                  LDC,
   const TYPE                 EPSILON,
   double                     * TTRUST0,
   double                     * TTEST0,
   double                     * MFTRUST0,
   double                     * MFTEST0
)
{
   double                     l2ret, ops, t0, ttest, ttrust;
   TYPE                       normA, normB, normC, normD, resid;
   TYPE                       * A  = NULL, * B = NULL, * C = NULL, * C0,
                              * a, * b, * c;
   int                        mA, mB, nA, nB, Aseed, Bseed, Cseed;
   const int DOFLUSH=(ATL_MulBySize((size_t)M*N + (size_t)K*(M+N)) < 
                      ((size_t)CACHESIZE)*4);

   *TTRUST0 = *TTEST0 = *MFTEST0 = *MFTRUST0 = 0.0;
   if( ( M == 0 ) || ( N == 0 ) ) { return( ATL_rzero ); }
 
   if( TRANSA == AtlasNoTrans ) { mA = M; nA = K; }
   else                         { mA = K; nA = M; }
   if( TRANSB == AtlasNoTrans ) { mB = K; nB = N; }
   else                         { mB = N; nB = K; }
 
   ops = opbl3( ROUT, M, N, K );
/*
 * Allocate L2 cache space, A, X, Y and Y0
 */
   if (DOFLUSH)
      l2ret = ATL_flushcache( CACHESIZE );
   A  = (TYPE *)malloc( ATL_MulBySize( LDA ) * nA     );
   B  = (TYPE *)malloc( ATL_MulBySize( LDB ) * nB     );
   C  = (TYPE *)malloc( ATL_MulBySize( LDC ) * N  * 2 );

   if( ( A == NULL ) || ( B == NULL ) || ( C == NULL ) )
   {
      if (DOFLUSH)
         l2ret = ATL_flushcache( 0 );
      if( A ) free( A );
      if( B ) free( B );
      if( C ) free( C );
      return( ATL_rnone );
   }
 
   C0 = C + LDC * ( N SHIFT );
/*
 * Generate random operands
 */
   Aseed = mA * nA + 513 *  7 + 90;
   Bseed = mB * nB + 127 * 50 + 77;
   Cseed = M  * N  + 101 *  2 + 53;

   Mjoin( PATL, gegen )( mA, nA, A,  LDA, Aseed );
   Mjoin( PATL, gegen )( mB, nB, B,  LDB, Bseed );
   Mjoin( PATL, gegen )( M,  N,  C,  LDC, Cseed );
   Mjoin( PATL, gegen )( M,  N,  C0, LDC, Cseed );
/*
 * Compute the norm of C for later use in testing
 */
   if( TEST )
   {
      normC = Mjoin( PATL, genrm1 )( M, N, C, LDC );
      if( Mabs1( BETA ) > ATL_rone ) normC *= Mabs1( BETA  );
      if( normC == ATL_rzero ) normC = ATL_rone;
   }
   else { normC = ATL_rone; }
/*
 * Start cold cache timing operations for the trusted routine
 */
   a = A; b = B; c = C0; 
 
   if (DOFLUSH)
      l2ret  = ATL_flushcache( -1 );
   t0     = time00();
   trusted_gemm( TRANSA, TRANSB, M, N, K, ALPHA, a, LDA, b, LDB, BETA, c, LDC );
   ttrust = time00() - t0;
   if( ttrust > 0.0 )
   { *TTRUST0 = ttrust; *MFTRUST0 = ops / ( ttrust * MEGA ); }
@ROUT l3time
   if (DOFLUSH)
      l2ret  = ATL_flushcache( 0 );
   free(A);
   free(B);
   free(C);
   return( ATL_rzero );
}
@ROUT l3blastst
/*
 * Start cold cache timing operations for the tested routine
 */
   a = A; b = B; c = C;
 
   if (DOFLUSH)
      l2ret  = ATL_flushcache( -1 );
   t0     = time00();
   test_gemm(    TRANSA, TRANSB, M, N, K, ALPHA, a, LDA, b, LDB, BETA, c, LDC );
   ttest  = time00() - t0;
   if( ttest  > 0.0 )
   { *TTEST0  = ttest;  *MFTEST0  = ops / ( ttest  * MEGA ); }
/*
 * if timing only, I am done ... so leave.
 */
   if (DOFLUSH)
      l2ret  = ATL_flushcache( 0 );
 
   if( !( TEST ) ) { free( A ); free( B ); free( C ); return( ATL_rzero ); }
/*
 * else perform error check
 */
   normA = Mjoin( PATL, genrm1 )( mA, nA, A, LDA );
   if( Mabs1( ALPHA ) > ATL_rone ) normA *= Mabs1( ALPHA );
   if( normA == ATL_rzero ) normA = ATL_rone;
   free( A  );

   normB = Mjoin( PATL, genrm1 )( mB, nB, B, LDB );
   if( normB == ATL_rzero ) normB = ATL_rone;
   free( B  );
/*
 * Ensure the difference of the output operands is relatively tiny enough
 */
   normD = Mjoin( PATL, gediffnrm1 )( M, N, C, LDC, C0, LDC );
   resid = normD / ( Mmax( normA, ATL_rone ) * Mmax( normB, ATL_rone ) *
                     Mmax( normC, ATL_rone ) * EPSILON *
                     Mmax( Mmax( M, N ), K ) );
 
   if( ( resid > THRESH ) || ( resid != resid ) )
   {
      (void) fprintf( stderr,
      "ERROR:  resid=%f, normD=%f, normA=%f, normB=%f, normC=%f, eps=%e\n",
      resid, normD, normA, normB, normC, EPSILON );
#ifdef ATLAS_DEBUG
      Mjoin( PATL, geprint )( "C_trusted", M, N, C0, LDC );
      Mjoin( PATL, geprint )( "C_test",    M, N, C,  LDC );
#endif
   }
 
   free( C  );

   return( resid );
} 
@ROUT l3blastst l3time

TYPE symmtst
(
   const int                  CACHESIZE,
   const enum LVL3_ROUT       ROUT,
   const int                  TEST, 
   const enum ATLAS_SIDE      SIDE,
   const enum ATLAS_UPLO      UPLO,
   const int                  M, 
   const int                  N,
   const SCALAR               ALPHA,
   const int                  LDA,
   const int                  LDB, 
   const SCALAR               BETA,
   const int                  LDC,
   const TYPE                 EPSILON,
   double                     * TTRUST0,
   double                     * TTEST0,
   double                     * MFTRUST0,
   double                     * MFTEST0
)
{
   double                     l2ret, ops, t0, ttest, ttrust;
   TYPE                       normA, normB, normC, normD, resid;
   TYPE                       * A  = NULL, * B = NULL, * C = NULL, * C0,
                              * a, * b, * c;
   int                        nA, Aseed, Bseed, Cseed;
   const size_t szA = (SIDE == AtlasLeft) ? M : N;
   const int DOFLUSH=(ATL_MulBySize((size_t)M*N*2 + szA)<((size_t)CACHESIZE)*4);

   *TTRUST0 = *TTEST0 = *MFTEST0 = *MFTRUST0 = 0.0;
   if( N == 0 ) { return( ATL_rzero ); }

   if( SIDE == AtlasLeft ) { ops = opbl3( ROUT, M, N, -1 ); nA = M; }
   else                    { ops = opbl3( ROUT, M, N,  1 ); nA = N; }
/*
 * Allocate L2 cache space, A, X, Y and Y0
 */
   if (DOFLUSH)
      l2ret = ATL_flushcache( CACHESIZE );
   A  = (TYPE *)malloc( ATL_MulBySize( LDA ) * nA     );
   B  = (TYPE *)malloc( ATL_MulBySize( LDB ) * N      );
   C  = (TYPE *)malloc( ATL_MulBySize( LDC ) * N  * 2 );

   if( ( A == NULL ) || ( B == NULL ) || ( C == NULL ) )
   {
      if (DOFLUSH)
         l2ret = ATL_flushcache( 0 );
      if( A ) free( A );
      if( B ) free( B );
      if( C ) free( C );
      return( ATL_rnone );
   }
 
   C0 = C + LDC * ( N SHIFT );
/*
 * Generate random operands
 */
   Aseed = nA * nA + 513 *  7 + 90;
   Bseed = M  * N  + 127 * 50 + 77;
   Cseed = M  * N  + 101 *  2 + 53;
 
   Mjoin( PATL, gegen )( nA, nA, A,  LDA, Aseed );
   Mjoin( PATL, gegen )( M,  N,  B,  LDB, Bseed );
   Mjoin( PATL, gegen )( M,  N,  C,  LDC, Cseed );
   Mjoin( PATL, gegen )( M,  N,  C0, LDC, Cseed );
/*
 * Compute the norm of C for later use in testing 
 */
   if( TEST )
   {
      normC = Mjoin( PATL, genrm1 )( M, N, C, LDC );
      if( Mabs1( BETA ) > ATL_rone ) normC *= Mabs1( BETA  );
      if( normC == ATL_rzero ) normC = ATL_rone;
   }
   else { normC = ATL_rone; }
/*
 * Start cold cache timing operations for the trusted routine
 */
   a = A; b = B; c = C0;

#ifdef TREAL 
   if (DOFLUSH)
      l2ret = ATL_flushcache( -1 );
   t0     = time00();
   trusted_symm( SIDE, UPLO, M, N, ALPHA, a, LDA, b, LDB, BETA, c, LDC );
   ttrust = time00() - t0;
   if( ttrust > 0.0 )
   { *TTRUST0 = ttrust; *MFTRUST0 = ops / ( ttrust * MEGA ); }
#else
   if( ROUT == SYMM )
   {
      if (DOFLUSH)
         l2ret = ATL_flushcache( -1 );
      t0     = time00();
      trusted_symm( SIDE, UPLO, M, N, ALPHA, a, LDA, b, LDB, BETA, c, LDC );
      ttrust = time00() - t0;
      if( ttrust > 0.0 )
      { *TTRUST0 = ttrust; *MFTRUST0 = ops / ( ttrust * MEGA ); }
   }
   else /* if( ROUT == HEMM ) */
   {
      if (DOFLUSH)
         l2ret = ATL_flushcache( -1 );
      t0     = time00();
      trusted_hemm( SIDE, UPLO, M, N, ALPHA, a, LDA, b, LDB, BETA, c, LDC );
      ttrust = time00() - t0;
      if( ttrust > 0.0 )
      { *TTRUST0 = ttrust; *MFTRUST0 = ops / ( ttrust * MEGA ); }
   }
#endif
@ROUT l3time
   if (DOFLUSH)
      l2ret  = ATL_flushcache( 0 );
   free(A);
   free(B);
   free(C);
   return( ATL_rzero );
}
@ROUT l3blastst
/*
 * Start cold cache timing operations for the tested routine
 */
   a = A; b = B; c = C;
 
#ifdef TREAL 
   if (DOFLUSH)
      l2ret = ATL_flushcache( -1 );
   t0     = time00();
   test_symm(    SIDE, UPLO, M, N, ALPHA, a, LDA, b, LDB, BETA, c, LDC );
   ttest  = time00() - t0;
   if( ttest  > 0.0 )
   { *TTEST0  = ttest;  *MFTEST0  = ops / ( ttest  * MEGA ); }
#else
   if( ROUT == SYMM )
   {
      if (DOFLUSH)
         l2ret = ATL_flushcache( -1 );
      t0     = time00();
      test_symm( SIDE, UPLO, M, N, ALPHA, a, LDA, b, LDB, BETA, c, LDC );
      ttest  = time00() - t0;
      if( ttest  > 0.0 )
      { *TTEST0  = ttest;  *MFTEST0  = ops / ( ttest  * MEGA ); }
   }
   else /* if( ROUT == HEMM ) */
   {
      if (DOFLUSH)
         l2ret = ATL_flushcache( -1 );
      t0     = time00();
      test_hemm( SIDE, UPLO, M, N, ALPHA, a, LDA, b, LDB, BETA, c, LDC );
      ttest  = time00() - t0;
      if( ttest  > 0.0 )
      { *TTEST0  = ttest;  *MFTEST0  = ops / ( ttest  * MEGA ); }
   }
#endif
/*
 * if timing only, I am done ... so leave.
 */
   if (DOFLUSH)
      l2ret = ATL_flushcache( 0 );
 
   if( !( TEST ) ) { free( A ); free( B ); free( C ); return( ATL_rzero ); }
/*
 * else perform error check
 */
#ifdef TREAL
   normA = Mjoin( PATL, synrm )( UPLO, nA, A, LDA );
#else
   if( ROUT == SYMM ) normA = Mjoin( PATL, synrm )( UPLO, nA, A, LDA );
   else               normA = Mjoin( PATL, henrm )( UPLO, nA, A, LDA );
#endif
   if( Mabs1( ALPHA ) > ATL_rone ) normA *= Mabs1( ALPHA );
   if( normA == ATL_rzero ) normA = ATL_rone;
   free( A  );
 
   normB = Mjoin( PATL, genrm1 )( M, N, B, LDB );
   if( normB == ATL_rzero ) normB = ATL_rone;
   free( B  );
/*
 * Ensure the difference of the output operands is relatively tiny enough
 */
   normD = Mjoin( PATL, gediffnrm1 )( M, N, C, LDC, C0, LDC );
   resid = normD / ( Mmax( normA, ATL_rone ) * Mmax( normB, ATL_rone ) *
                     Mmax( normC, ATL_rone ) * EPSILON * Mmax( M, N ) );
 
   if( ( resid > THRESH ) || ( resid != resid ) )
   {
      (void) fprintf( stderr,
      "ERROR:  resid=%f, normD=%f, normA=%f, normB=%f, normC=%f, eps=%e\n",
      resid, normD, normA, normB, normC, EPSILON );
#ifdef ATLAS_DEBUG
      Mjoin( PATL, geprint )( "C_trusted", M, N, C0, LDC );
      Mjoin( PATL, geprint )( "C_test",    M, N, C,  LDC );
#endif
   }
 
   free( C  );
 
   return( resid );
}
@ROUT l3blastst l3time

TYPE syr2ktst
(
   const int                  CACHESIZE,
   const enum LVL3_ROUT       ROUT,
   const int                  TEST,
   const enum ATLAS_UPLO      UPLO,
   const enum ATLAS_TRANS     TRANS,
   const int                  N,
   const int                  K,
   const SCALAR               ALPHA,
   const int                  LDA,
   const int                  LDB,
   const SCALAR               BETA,
   const int                  LDC,
   const TYPE                 EPSILON,
   double                     * TTRUST0,
   double                     * TTEST0,
   double                     * MFTRUST0,
   double                     * MFTEST0
)
{ 
   double                     l2ret, ops, t0, ttest, ttrust;
   TYPE                       normA, normB, normC, normD, resid;
   TYPE                       * A = NULL, * B = NULL, * C = NULL, * C0,
                              * a, * b, * c; 
   int                        mAB, nAB, Aseed, Bseed, Cseed;
   enum ATLAS_TRANS           ta;
   const int DOFLUSH=(ATL_MulBySize((size_t)N*N + (size_t)N*K*2)
                      < ((size_t)CACHESIZE)*4);

   *TTRUST0 = *TTEST0 = *MFTEST0 = *MFTRUST0 = 0.0;
   if( N == 0 ) { return( ATL_rzero ); }

   if( TRANS == AtlasNoTrans )
   { ta = TRANS; mAB = N; nAB = K; }
   else
   { ta = ( ROUT == SYR2K ? AtlasTrans : AtlasConjTrans ); mAB = K; nAB = N; }

   ops = opbl3( ROUT, N, 0, K ); 
/*
 * Allocate L2 cache space, A, C and C0
 */
   if (DOFLUSH)
      l2ret = ATL_flushcache( CACHESIZE );
   A = (TYPE *)malloc( ATL_MulBySize( LDA ) * nAB    );
   B = (TYPE *)malloc( ATL_MulBySize( LDB ) * nAB    );
   C = (TYPE *)malloc( ATL_MulBySize( LDC ) * N  * 2 );
 
   if( ( A == NULL ) || ( B == NULL ) || ( C == NULL ) )
   {
      if (DOFLUSH)
         l2ret = ATL_flushcache( 0 );
      if( A ) free( A );
      if( B ) free( B );
      if( C ) free( C );
      return( ATL_rnone );
   }
 
   C0 = C + LDC * ( N SHIFT );
/*
 * Generate random operands
 */
   Aseed = mAB * nAB + 513 *  7 + 90;
   Bseed = mAB * nAB + 127 * 50 + 77;
   Cseed = N   * N   + 101 *  2 + 53;
 
   Mjoin( PATL, gegen )( mAB, nAB, A,  LDA, Aseed );
   Mjoin( PATL, gegen )( mAB, nAB, B,  LDB, Bseed );
   Mjoin( PATL, gegen )( N,   N,   C,  LDC, Cseed );
   Mjoin( PATL, gegen )( N,   N,   C0, LDC, Cseed );
/*
 * Compute the norm of C for later use in testing
 */
   if( TEST )
   {
#ifdef TREAL
      normC = Mjoin( PATL, synrm )( UPLO, N, C, LDC );
      if( Mabs1( BETA ) > ATL_rone ) normC *= Mabs1( BETA  );
      if( normC == ATL_rzero ) normC = ATL_rone;
#else
      if( ROUT == SYR2K )
      {
         normC = Mjoin( PATL, synrm )( UPLO, N, C, LDC );
         if( Mabs1( BETA ) > ATL_rone ) normC *= Mabs1( BETA  );
         if( normC == ATL_rzero ) normC = ATL_rone;
      }
      else
      {
         normC = Mjoin( PATL, henrm )( UPLO, N, C, LDC );
         if( Mabs( BETA[0] ) > ATL_rone ) normC *= Mabs( BETA[0] );
         if( normC == ATL_rzero ) normC = ATL_rone;
      }
#endif
   }
   else { normC = ATL_rone; }
/*
 * Start cold cache timing operations for the trusted routine
 */
   a = A; b = B; c = C0;
#ifdef TREAL 
   if (DOFLUSH)
      l2ret = ATL_flushcache( -1 );
   t0     = time00();
   trusted_syr2k( UPLO, ta, N, K, ALPHA, a, LDA, b, LDB, BETA, c, LDC );
   ttrust = time00() - t0;
#else
   if( ROUT == SYR2K )
   {
      if (DOFLUSH)
         l2ret = ATL_flushcache( -1 );
      t0     = time00();
      trusted_syr2k( UPLO, ta, N, K, ALPHA, a, LDA, b, LDB, BETA, c, LDC );
      ttrust = time00() - t0;
   }
   else /* if( ROUT == HER2K ) */
   {
      if (DOFLUSH)
         l2ret = ATL_flushcache( -1 );
      t0     = time00();
      trusted_her2k( UPLO, ta, N, K, ALPHA, a, LDA, b, LDB, (TYPE)(BETA[0]),
                     c, LDC );
      ttrust = time00() - t0;
   }
#endif
   if( ttrust > 0.0 )
   { *TTRUST0 = ttrust; *MFTRUST0 = ops / ( ttrust * MEGA ); }
@ROUT l3time
   if (DOFLUSH)
      l2ret  = ATL_flushcache( 0 );
   free(A);
   free(B);
   free(C);
   return( ATL_rzero );
}
@ROUT l3blastst
/*
 * Start cold cache timing operations for the tested routine
 */
   a = A; b = B; c = C;
#ifdef TREAL 
   if (DOFLUSH)
      l2ret = ATL_flushcache( -1 );
   t0     = time00();
   test_syr2k(    UPLO, TRANS, N, K, ALPHA, a, LDA, b, LDB, BETA, c, LDC );
   ttest  = time00() - t0;
#else
   if( ROUT == SYR2K )
   {
      if (DOFLUSH)
         l2ret = ATL_flushcache( -1 );
      t0     = time00();
      test_syr2k( UPLO, ta, N, K, ALPHA, a, LDA, b, LDB, BETA, c, LDC );
      ttest  = time00() - t0;
   }
   else /* if( ROUT == HERK ) */
   {
      if (DOFLUSH)
         l2ret = ATL_flushcache( -1 );
      t0     = time00();
      test_her2k( UPLO, ta, N, K, ALPHA, a, LDA, b, LDB, (TYPE)(BETA[0]),
                  c, LDC );
      ttest  = time00() - t0;
   }
#endif
   if( ttest  > 0.0 )
   { *TTEST0  = ttest;  *MFTEST0  = ops / ( ttest  * MEGA ); }
/*
 * if timing only, I am done ... so leave.
 */
   if (DOFLUSH)
      l2ret  = ATL_flushcache( 0 );
 
   if( !( TEST ) ) { free( A ); free( C ); return( ATL_rzero ); }
/*
 * else perform error check
 */
   normA = Mjoin( PATL, genrm1 )( mAB, nAB, A, LDA );
   if( Mabs1( ALPHA ) > ATL_rone ) normA *= Mabs1( ALPHA );
   if( normA == ATL_rzero ) normA = ATL_rone;
   free( A  );

   normB = Mjoin( PATL, genrm1 )( mAB, nAB, B, LDB );
   if( normB == ATL_rzero ) normB = ATL_rone;
   free( B  );
/*
 * Ensure the difference of the output operands is relatively tiny enough
 */
   normD = Mjoin( PATL, gediffnrm1 )( N, N, C, LDC, C0, LDC );
   resid = normD / ( Mmax( normC, ATL_rone ) * Mmax( normA, ATL_rone ) *
                     Mmax( normB, ATL_rone ) * EPSILON * Mmax( N, K ) );

   if( ( resid > THRESH ) || ( resid != resid ) )
   {
      (void) fprintf( stderr, 
      "ERROR:    resid=%f, normD=%f, normA=%f, normC=%f, eps=%e\n",
      resid, normD, normA, normC, EPSILON );
#ifdef ATLAS_DEBUG
      Mjoin( PATL, geprint )( "C_trusted", N, N, C0, LDC );
      Mjoin( PATL, geprint )( "C_test",    N, N, C,  LDC );
#endif
   }

   free( C  );

   return( resid );
}
@ROUT l3blastst l3time

TYPE syrktst
(
   const int                  CACHESIZE,
   const enum LVL3_ROUT       ROUT,
   const int                  TEST,
   const enum ATLAS_UPLO      UPLO,
   const enum ATLAS_TRANS     TRANS,
   const int                  N,
   const int                  K,
   const SCALAR               ALPHA,
   const int                  LDA,
   const SCALAR               BETA,
   const int                  LDC,
   const TYPE                 EPSILON,
   double                     * TTRUST0,
   double                     * TTEST0,
   double                     * MFTRUST0,
   double                     * MFTEST0
)
{
   double                     l2ret, ops, t0, ttest, ttrust;
   TYPE                       normA, normC, normD, resid;
   TYPE                       * A = NULL, * C = NULL, * C0, * a, * c; 
   int                        mA, nA, Aseed, Cseed;
@ROUT l3blastst `   ATL_BV_t *errBV=NULL;`
   enum ATLAS_TRANS           ta;
   const int DOFLUSH=(ATL_MulBySize((size_t)N*N + (size_t)N*K)
                      < ((size_t)CACHESIZE)*4);

   *TTRUST0 = *TTEST0 = *MFTEST0 = *MFTRUST0 = 0.0;
   if( N == 0 ) { return( ATL_rzero ); }

   if( TRANS == AtlasNoTrans )
   { ta = TRANS; mA = N; nA = K; }
   else
   { ta = ( ROUT == SYRK ? AtlasTrans : AtlasConjTrans ); mA = K; nA = N; }

   ops = opbl3( ROUT, N, 0, K ); 
/*
 * Allocate L2 cache space, A, C and C0
 */
   if (DOFLUSH)
      l2ret = ATL_flushcache( CACHESIZE );
   A = (TYPE *)malloc( ATL_MulBySize( LDA ) * nA     );
   C = (TYPE *)malloc( ATL_MulBySize( LDC ) * N  * 2 );
 
   if( ( A == NULL ) || ( C == NULL ) )
   {
      if (DOFLUSH)
         l2ret = ATL_flushcache( 0 );
      if( A ) free( A );
      if( C ) free( C );
      return( ATL_rnone );
   }
 
   C0 = C + LDC * ( N SHIFT );
/*
 * Generate random operands
 */
   Aseed = mA * nA + 513 *  7 + 90;
   Cseed = N  * N  + 101 *  2 + 53;
 
   Mjoin( PATL, gegen )( mA, nA, A,  LDA, Aseed );
   Mjoin( PATL, gegen )( N,  N,  C,  LDC, Cseed );
   Mjoin( PATL, gegen )( N,  N,  C0, LDC, Cseed );
/*
 * Compute the norm of C for later use in testing
 */
   if( TEST )
   {
#ifdef TREAL
      normC = Mjoin( PATL, synrm )( UPLO, N, C, LDC );
      if( Mabs1( BETA ) > ATL_rone ) normC *= Mabs1( BETA  );
      if( normC == ATL_rzero ) normC = ATL_rone;
#else
      if( ROUT == SYRK )
      {
         normC = Mjoin( PATL, synrm )( UPLO, N, C, LDC );
         if( Mabs1( BETA ) > ATL_rone ) normC *= Mabs1( BETA  );
         if( normC == ATL_rzero ) normC = ATL_rone;
      }
      else
      {
         normC = Mjoin( PATL, henrm )( UPLO, N, C, LDC );
         if( Mabs( BETA[0] ) > ATL_rone ) normC *= Mabs( BETA[0] );
         if( normC == ATL_rzero ) normC = ATL_rone;
      }
#endif
   }
   else { normC = ATL_rone; } 
/*
 * Start cold cache timing operations for the trusted routine
 */
   a = A; c = C0;
#ifdef TREAL 
   if (DOFLUSH)
      l2ret  = ATL_flushcache( -1 );
   t0     = time00();
   trusted_syrk( UPLO, ta, N, K, ALPHA, a, LDA, BETA, c, LDC );
   ttrust = time00() - t0;
#else
   if( ROUT == SYRK )
   {
      if (DOFLUSH)
         l2ret  = ATL_flushcache( -1 );
      t0     = time00();
      trusted_syrk( UPLO, ta, N, K, ALPHA, a, LDA, BETA, c, LDC );
      ttrust = time00() - t0;
   }
   else /* if( ROUT == HERK ) */
   {
      if (DOFLUSH)
         l2ret  = ATL_flushcache( -1 );
      t0     = time00();
      trusted_herk( UPLO, ta, N, K, (TYPE)(ALPHA[0]), a, LDA, (TYPE)(BETA[0]),
                    c, LDC );
      ttrust = time00() - t0;
   }
#endif
   if( ttrust > 0.0 )
   { *TTRUST0 = ttrust; *MFTRUST0 = ops / ( ttrust * MEGA ); }
@ROUT l3time
   if (DOFLUSH)
      l2ret  = ATL_flushcache( 0 );
   free(A);
   free(C);
   return( ATL_rzero );
}
@ROUT l3blastst
/*
 * Start cold cache timing operations for the tested routine
 */
   a = A; c = C;
#ifdef TREAL 
   if (DOFLUSH)
      l2ret  = ATL_flushcache( -1 );
   t0     = time00();
   test_syrk(    UPLO, TRANS, N, K, ALPHA, a, LDA, BETA, c, LDC );
   ttest  = time00() - t0;
#else
   if( ROUT == SYRK )
   {
      if (DOFLUSH)
         l2ret  = ATL_flushcache( -1 );
      t0     = time00();
      test_syrk( UPLO, ta, N, K, ALPHA, a, LDA, BETA, c, LDC );
      ttest  = time00() - t0;
   }
   else /* if( ROUT == HERK ) */
   {
      if (DOFLUSH)
         l2ret  = ATL_flushcache( -1 );
      t0     = time00();
      test_herk( UPLO, ta, N, K, (TYPE)(ALPHA[0]), a, LDA, (TYPE)(BETA[0]),
                 c, LDC );
      ttest  = time00() - t0;
   }
#endif
   if( ttest  > 0.0 )
   { *TTEST0  = ttest;  *MFTEST0  = ops / ( ttest  * MEGA ); }
/*
 * if timing only, I am done ... so leave.
 */
   if (DOFLUSH)
      l2ret  = ATL_flushcache( 0 );
 
   if( !( TEST ) ) { free( A ); free( C ); return( ATL_rzero ); }
/*
 * else perform error check
 */
   normA = Mjoin( PATL, genrm1 )( mA, nA, A, LDA );
   if (N < 80)
   {
   /* Normally 2*K*eps, but diag dominant matrices have elts as lrg as N! */
      #ifdef TREAL
         double ferr= 2.0 * (Mabs(ALPHA) * 2.0*(K+N)*EPSILON + 
                      Mabs(BETA) * EPSILON) + EPSILON;
      #else
         double ferr = Mabs(*ALPHA) + Mabs(ALPHA[1]);
         ferr = 2.0 * (ferr*8.0*(K+N)*EPSILON + 
                (Mabs(*BETA)+Mabs(BETA[1]))*EPSILON) + EPSILON;
      #endif
      errBV = Mjoin(PATL,cmpmatBV)(0, ferr, N, N, C0, LDC, C, LDC);
   }
#ifdef TREAL
   if( Mabs1( ALPHA ) > ATL_rone ) normA *= Mabs1( ALPHA );
#else
   if( ROUT == SYRK )
   { 
      if( Mabs1( ALPHA ) > ATL_rone ) normA *= Mabs1( ALPHA ); 
   }
   else
   { if( Mabs( ALPHA[0] ) > ATL_rone ) normA *= Mabs( ALPHA[0] ); }
#endif
   if( normA == ATL_rzero ) normA = ATL_rone;
   free( A  );
/*
 * Ensure the difference of the output operands is relatively tiny enough
 */
   normD = Mjoin( PATL, gediffnrm1 )( N, N, C, LDC, C0, LDC );
   resid = normD / ( Mmax( normC, ATL_rone ) * Mmax( normA, ATL_rone ) *
                     EPSILON * Mmax( N, K ) );

   if( ( resid > THRESH ) || ( resid != resid ) )
   {
      (void) fprintf( stderr, 
      "ERROR:    resid=%f, normD=%f, normA=%f, normC=%f, eps=%e\n",
      resid, normD, normA, normC, EPSILON );
#ifdef ATLAS_DEBUG
      Mjoin( PATL, geprint )( "C_trusted", N, N, C0, LDC );
      Mjoin( PATL, geprint )( "C_test",    N, N, C,  LDC );
#endif
   }
   if (errBV)
   {
      if (ATL_FindFirstSetBitBV(errBV, 0) != -1)
         ATL_print2dBV(N, N, errBV);
      ATL_FreeBV(errBV);
   }

   free( C  );

   return( resid );
} 
@ROUT l3blastst l3time

TYPE trmmtst
(
   const int                  CACHESIZE,
   const enum LVL3_ROUT       ROUT,
   const int                  TEST,
   const enum ATLAS_SIDE      SIDE,
   const enum ATLAS_UPLO      UPLO,
   const enum ATLAS_TRANS     TRANS,
   const enum ATLAS_DIAG      DIAG,
   const int                  M,
   const int                  N,
   const SCALAR               ALPHA,
   const int                  LDA,
   const int                  LDB,
   const TYPE                 EPSILON,
   double                     * TTRUST0,
   double                     * TTEST0,
   double                     * MFTRUST0,
   double                     * MFTEST0
)
{
   double                     l2ret, ops, t0, ttest, ttrust;
   TYPE                       normA, normB, normD, resid;
   TYPE                       * A = NULL, * B = NULL, * B0, * a, * b;
   int                        nA, Aseed, Bseed;
   const size_t szA = (SIDE == AtlasLeft) ? M : N;
   const int DOFLUSH=(ATL_MulBySize((size_t)M*N + (size_t)szA*szA)
                      < ((size_t)CACHESIZE)*4);

   *TTRUST0 = *TTEST0 = *MFTEST0 = *MFTRUST0 = 0.0;
   if( ( M == 0 ) || ( N == 0 ) ) { return( ATL_rzero ); }

   if( SIDE == AtlasLeft ) { nA = M; ops = opbl3( ROUT, M, N, -1 ); }
   else                    { nA = N; ops = opbl3( ROUT, M, N,  1 ); }
/*
 * Allocate L2 cache space, A, X and X0
 */
   if (DOFLUSH)
      l2ret = ATL_flushcache( CACHESIZE );
   A = (TYPE *)malloc( ATL_MulBySize( LDA ) * nA    );
   B = (TYPE *)malloc( ATL_MulBySize( LDB ) * N * 2 );
 
   if( ( A == NULL ) || ( B == NULL ) )
   {
      if (DOFLUSH)
         l2ret  = ATL_flushcache( 0 );
      if( A ) free( A );
      if( B ) free( B );
      return( ATL_rnone );
   } 

   B0 = B + LDB * ( N SHIFT );
/*
 * Generate random operands
 */
   Aseed = nA * nA + 513 *  7 + 90;
   Bseed = M  * N  + 127 * 50 + 77;
 
   Mjoin( PATL, gegen )( nA, nA, A,  LDA, Aseed );
   Mjoin( PATL, gegen )( M,  N,  B,  LDB, Bseed );
   Mjoin( PATL, gegen )( M,  N,  B0, LDB, Bseed );
/*
 * Compute the norm of B for later use in testing
 */
   if( TEST )
   {
      normB = Mjoin( PATL, genrm1 )( M, N, B, LDB );
      if( Mabs1( ALPHA ) > ATL_rone ) normB *= Mabs1( ALPHA );
      if( normB == ATL_rzero ) normB = ATL_rone;
   }
   else { normB = ATL_rone; }
/*
 * Start cold cache timing operations for the trusted routine
 */
   a = A; b = B0;
 
   if (DOFLUSH)
      l2ret  = ATL_flushcache( -1 );
   t0     = time00();
   trusted_trmm( SIDE, UPLO, TRANS, DIAG, M, N, ALPHA, a, LDA, b, LDB );
   ttrust = time00() - t0;
   if( ttrust > 0.0 )
   { *TTRUST0 = ttrust; *MFTRUST0 = ops / ( ttrust * MEGA ); }
@ROUT l3time
   if (DOFLUSH)
      l2ret  = ATL_flushcache( 0 );
   free(A);
   free(B);
   return( ATL_rzero );
}
@ROUT l3blastst
/*
 * Start cold cache timing operations for the tested routine
 */
   a = A; b = B;
 
   if (DOFLUSH)
      l2ret = ATL_flushcache( -1 );
   t0    = time00();
   test_trmm(    SIDE, UPLO, TRANS, DIAG, M, N, ALPHA, a, LDA, b, LDB );
   ttest  = time00() - t0;
   if( ttest  > 0.0 )
   { *TTEST0  = ttest;  *MFTEST0  = ops / ( ttest  * MEGA ); }
/*
 * if timing only, I am done ... so leave.
 */
   if (DOFLUSH)
      l2ret  = ATL_flushcache( 0 );
 
   if( !( TEST ) ) { free( A ); free( B ); return( ATL_rzero ); }
/*
 * else perform error check
 */
   normA = Mjoin( PATL, trnrm1 )( UPLO, DIAG, nA, A, LDA );
   if( normA == ATL_rzero ) normA = ATL_rone;
   free( A  );
/*
 * Ensure the difference of the output operands is relatively tiny enough
 */
   normD = Mjoin( PATL, gediffnrm1 )( M, N, B, LDB, B0, LDB );
   resid = normD / ( Mmax( normA, ATL_rone ) * Mmax( normB, ATL_rone ) *
                     EPSILON * Mmax( M, N ) );
 
   if( ( resid > THRESH ) || ( resid != resid ) )
   {
      (void) fprintf( stderr,
      "ERROR:  resid=%f, normD=%f, normA=%f, normB=%f, eps=%e\n",
      resid, normD, normA, normB, EPSILON );
#ifdef ATLAS_DEBUG
      Mjoin( PATL, geprint )( "B_trusted", M, N, B0, LDB );
      Mjoin( PATL, geprint )( "B_test",    M, N, B,  LDB );
#endif
   }
 
   free( B );
 
   return( resid );
} 
@ROUT l3blastst l3time

TYPE trsmtst
(
   const int                  CACHESIZE,
   const enum LVL3_ROUT       ROUT,
   const int                  TEST,
   const enum ATLAS_SIDE      SIDE,
   const enum ATLAS_UPLO      UPLO,
   const enum ATLAS_TRANS     TRANS,
   const enum ATLAS_DIAG      DIAG,
   const int                  M,
   const int                  N,
   const SCALAR               ALPHA,
   const int                  LDA,
   const int                  LDB,
   const TYPE                 EPSILON,
   double                     * TTRUST0,
   double                     * TTEST0,
   double                     * MFTRUST0,
   double                     * MFTEST0
)
{
   double                     l2ret, ops, t0, ttest, ttrust;
   TYPE                       normA, normB, normD, resid;
   TYPE                       * A = NULL, * B = NULL, * B0, * a, * b;
   int                        nA, Aseed, Bseed;
   const size_t szA = (SIDE == AtlasLeft) ? M : N;
   const int DOFLUSH=(ATL_MulBySize((size_t)M*N + (size_t)szA*szA)
                      < ((size_t)CACHESIZE)*4);

   *TTRUST0 = *TTEST0 = *MFTEST0 = *MFTRUST0 = 0.0;
   if( ( M == 0 ) || ( N == 0 ) ) { return( ATL_rzero ); }

   if( SIDE == AtlasLeft ) { nA = M; ops = opbl3( ROUT, M, N, -1 ); }
   else                    { nA = N; ops = opbl3( ROUT, M, N,  1 ); }
/*
 * Allocate L2 cache space, A, X and X0
 */
   if (DOFLUSH)
      l2ret = ATL_flushcache( CACHESIZE );
   A  = (TYPE *)malloc( ATL_MulBySize( LDA ) * nA    );
   B  = (TYPE *)malloc( ATL_MulBySize( LDB ) * N * 2 );
 
   if( ( A == NULL ) || ( B == NULL ) )
   {
      if (DOFLUSH)
         l2ret = ATL_flushcache( 0 );
      if( A ) free( A );
      if( B ) free( B );
      return( ATL_rnone );
   } 

   B0 = B + LDB * ( N SHIFT );
/*
 * Generate random operands
 */
   Aseed = nA * nA + 513 *  7 + 90;
   Bseed = M  * N  + 127 * 50 + 77;
 
   Mjoin( PATL, gegen )( nA, nA, A,  LDA, Aseed ); trddom( UPLO, nA, A, LDA );
   Mjoin( PATL, gegen )( M,  N,  B,  LDB, Bseed );
   Mjoin( PATL, gegen )( M,  N,  B0, LDB, Bseed );
/*
 * Compute the norm of B for later use in testing
 */
   if( TEST )
   {
      normB = Mjoin( PATL, genrm1 )( M, N, B, LDB );
      if( Mabs1( ALPHA ) > ATL_rone ) normB *= Mabs1( ALPHA );
      if( normB == ATL_rzero ) normB = ATL_rone;
   }
   else { normB = ATL_rone; } 
/*
 * Start cold cache timing operations for the trusted routine
 */
   a = A; b = B0;
 
   if (DOFLUSH)
      l2ret  = ATL_flushcache( -1 );
   t0     = time00();
   trusted_trsm( SIDE, UPLO, TRANS, DIAG, M, N, ALPHA, a, LDA, b, LDB );
   ttrust = time00() - t0;
   if( ttrust > 0.0 )
   { *TTRUST0 = ttrust; *MFTRUST0 = ops / ( ttrust * MEGA ); }
@ROUT l3time
   if (DOFLUSH)
      l2ret  = ATL_flushcache( 0 );
   free(A);
   free(B);
   return( ATL_rzero );
}
@ROUT l3blastst
/*
 * Start cold cache timing operations for the tested routine
 */
   a = A; b = B;
 
   if (DOFLUSH)
      l2ret  = ATL_flushcache( -1 );
   t0     = time00();
   test_trsm(    SIDE, UPLO, TRANS, DIAG, M, N, ALPHA, a, LDA, b, LDB );
   ttest  = time00() - t0;
   if( ttest  > 0.0 )
   { *TTEST0  = ttest;  *MFTEST0  = ops / ( ttest  * MEGA ); }
/*
 * if timing only, I am done ... so leave.
 */
   if (DOFLUSH)
      l2ret = ATL_flushcache( 0 );
 
   if( !( TEST ) ) { free( A ); free( B ); return( ATL_rzero ); }
/*
 * else perform error check
 */
   normA = Mjoin( PATL, trnrm1 )( UPLO, DIAG, nA, A, LDA );
   if( normA == ATL_rzero ) normA = ATL_rone;
   free( A  );
/*
 * Ensure the difference of the output operands is relatively tiny enough
 */
   normD = Mjoin( PATL, gediffnrm1 )( M, N, B, LDB, B0, LDB );
   resid = normD / ( Mmax( normA, ATL_rone ) * Mmax( normB, ATL_rone ) *
                     EPSILON * Mmax( M, N ) );
 
   if( ( resid > THRESH ) || ( resid != resid ) )
   {
      (void) fprintf( stderr,
      "ERROR:  resid=%f, normD=%f, normA=%f, normB=%f, eps=%e\n",
      resid, normD, normA, normB, EPSILON );
#ifdef ATLAS_DEBUG
      Mjoin( PATL, geprint )( "B_trusted", M, N, B0, LDB );
      Mjoin( PATL, geprint )( "B_test",    M, N, B,  LDB );
#endif
   }
 
   free( B );
 
   return( resid );
}
@ROUT l3blastst l3time
/*
 * =====================================================================
 * case functions
 * =====================================================================
 */
int gemmcase
(
   const int                  CACHESIZE,
   const enum LVL3_ROUT       ROUT,
   const int                  TEST,
   const int                  MFLOP,
   const enum ATLAS_TRANS     TRANSA,
   const enum ATLAS_TRANS     TRANSB,
   const int                  M,
   const int                  N,
   const int                  K,
   const SCALAR               ALPHA,
   const int                  LDA,
   const int                  LDB, 
   const SCALAR               BETA,
   const int                  LDC,
   const TYPE                 EPSILON,
   double                     * TTRUST0, 
   double                     * TTEST0,
   double                     * MFTRUST0,
   double                     * MFTEST0
)
{
   double                     flops, ttrust, ttest, mftrust, mftest, t0;
   TYPE                       resid = ATL_rzero;
#ifdef TREAL
   TYPE                       bet,  beta,    nbeta;
#else
   TYPE                       *bet, beta[2], nbeta[2];
#endif
   TYPE                       * a, * stA, *b, * stB, * c, * stC, * A,
                              * A0 = NULL, * B, * B0 = NULL, * C, * C0 = NULL;
   unsigned long              ir, reps;
   int                        inca, incb, incc, lA, lB, lC, mA, nA, mB, nB,
                              passed, Aseed, Bseed, Cseed;

   if( ( MEGA * MFLOP <= ( flops = opbl3( ROUT, M, N, K ) ) ) || ( TEST ) )
   {
      resid = gemmtst( CACHESIZE, ROUT, TEST, TRANSA, TRANSB, M, N, K, ALPHA,
		       LDA, LDB, BETA, LDC, EPSILON, TTRUST0, TTEST0,
		       MFTRUST0, MFTEST0 );
      if( resid > THRESH ) (void) fprintf( stderr, "   resid=%f\n", resid );
   }
   if( resid < ATL_rzero ) passed = -1;
   else                    passed = ( resid < THRESH );

   if( MEGA * MFLOP <= flops ) return( passed );

   if( TRANSA == AtlasNoTrans ) { mA = M; nA = K; } else { mA = K; nA = M; }
   if( TRANSB == AtlasNoTrans ) { mB = K; nB = N; } else { mB = N; nB = K; }
 
   inca = LDA  * ( nA SHIFT ); 
   incb = LDB  * ( nB SHIFT ); 
   incc = LDC  * ( N  SHIFT ); 

   lA = inca  * ( ( ATL_DivBySize( LCSIZE ) + mA*nA - 1 ) / ( mA * nA ) );
   lB = incb  * ( ( ATL_DivBySize( LCSIZE ) + mB*nB - 1 ) / ( mB * nB ) );
   lC = incc  * ( ( ATL_DivBySize( LCSIZE ) + M * N - 1 ) / ( M  * N  ) );

   A0 = (TYPE *)malloc( ATL_MulBySize( lA ) );
   B0 = (TYPE *)malloc( ATL_MulBySize( lB ) );
   C0 = (TYPE *)malloc( ATL_MulBySize( lC ) );

   if( ( A0 == NULL ) || ( B0 == NULL ) || ( C0 == NULL ) )
   {
      if( A0 ) free( A0 );
      if( B0 ) free( B0 );
      if( C0 ) free( C0 );
      return( -1 );
   }

   A = A0; stA = A0 + ( lA SHIFT );
   B = B0; stB = B0 + ( lB SHIFT );
   C = C0; stC = C0 + ( lC SHIFT );

#ifdef TREAL
   beta   =  BETA;
   nbeta  = -BETA;
#else
   *beta  =    *BETA; beta [1] =  BETA[1];
   *nbeta = -(*BETA); nbeta[1] = -BETA[1];
#endif

   Aseed = mA * nA + 513 *  7 + 90;
   Bseed = mB * nB + 127 * 50 + 77;
   Cseed = M  * N  + 101 *  2 + 53;

   reps  = ( MEGA * MFLOP ) / flops;
/*
 * Generate the random data and time the trusted routine
 */
   bet = beta; a = A; b = B; c = C;

   Mjoin( PATL, gegen )( lA, 1, A0, lA, Aseed );
   Mjoin( PATL, gegen )( lB, 1, B0, lB, Bseed );
   Mjoin( PATL, gegen )( lC, 1, C0, lC, Cseed );

   t0 = time00();
   for( ir = reps; ir; ir-- )
   {
      trusted_gemm( TRANSA, TRANSB, M, N, K, ALPHA, a, LDA, b, LDB,
                    (SCALAR)(bet), c, LDC );
      a += inca; if( a == stA ) { a = A; }
      b += incb; if( b == stB ) { b = B; }
      c += incc;
      if( c == stC ) { c = C; if( bet == beta ) bet = nbeta; else bet = beta; }
   }
   ttrust = time00() - t0;
   if( ttrust > 0.0 ) mftrust = ( reps * flops ) / ( MEGA * ttrust );
   else               mftrust = 0.0;
   ttrust /= reps; *TTRUST0 = ttrust; *MFTRUST0 = mftrust;
@ROUT l3time
   free(A0);
   free(B0);
   free(C0);
   return(0);
}
@ROUT l3blastst
/*
 * Generate the random data and time the tested routine
 */
   bet = beta; a = A; b = B; c = C;

   Mjoin( PATL, gegen )( lA, 1, A0, lA, Aseed );
   Mjoin( PATL, gegen )( lB, 1, B0, lB, Bseed );
   Mjoin( PATL, gegen )( lC, 1, C0, lC, Cseed );

   t0 = time00();
   for( ir = reps; ir; ir-- )
   {
      test_gemm(    TRANSA, TRANSB, M, N, K, ALPHA, a, LDA, b, LDB,
                    (SCALAR)(bet), c, LDC );
      a += inca; if( a == stA ) { a = A; }
      b += incb; if( b == stB ) { b = B; }
      c += incc;
      if( c == stC ) { c = C; if( bet == beta ) bet = nbeta; else bet = beta; }
   }
   ttest = time00() - t0;
   if( ttest  > 0.0 ) mftest  = ( reps * flops ) / ( MEGA * ttest  );
   else               mftest  = 0.0;
   ttest  /= reps; *TTEST0  = ttest;  *MFTEST0  = mftest;
/*
 * release the memory and exit
 */
   free( C0 );
   free( B0 );
   free( A0 );

   return( passed );
}
@ROUT l3blastst l3time

int symmcase
(
   const int                  CACHESIZE,
   const enum LVL3_ROUT       ROUT,
   const int                  TEST,
   const int                  MFLOP,
   const enum ATLAS_SIDE      SIDE,
   const enum ATLAS_UPLO      UPLO,
   const int                  M,
   const int                  N,
   const SCALAR               ALPHA,
   const int                  LDA,
   const int                  LDB,
   const SCALAR               BETA,
   const int                  LDC,
   const TYPE                 EPSILON,
   double                     * TTRUST0,
   double                     * TTEST0,
   double                     * MFTRUST0,
   double                     * MFTEST0
) 
{
   double                     flops, ttrust, ttest, mftrust, mftest, t0;
   TYPE                       resid = ATL_rzero;
#ifdef TREAL
   TYPE                       bet,  beta,    nbeta;
#else
   TYPE                       *bet, beta[2], nbeta[2];
#endif
   TYPE                       * a, * stA, *b, * stB, * c, * stC, * A,
                              * A0 = NULL, * B, * B0 = NULL, * C, * C0 = NULL;
   unsigned long              ir, reps;
   int                        inca, incb, incc, lA, lB, lC, nA, passed, Aseed,
                              Bseed, Cseed;

   flops = opbl3( ROUT, M, N, ( SIDE == AtlasLeft ? -1 : 1 ) );
 
   if( ( MEGA * MFLOP <= flops ) || ( TEST ) )
   {
      resid = symmtst( CACHESIZE, ROUT, TEST, SIDE, UPLO, M, N, ALPHA,
		       LDA, LDB, BETA, LDC, EPSILON, TTRUST0, TTEST0, 
		       MFTRUST0, MFTEST0 );
      if( resid > THRESH ) (void) fprintf( stderr, "   resid=%f\n", resid );
   }
   if( resid < ATL_rzero ) passed = -1;
   else                    passed = ( resid < THRESH );

   if( MEGA * MFLOP <= flops ) return( passed );
 
   if( SIDE == AtlasLeft ) { nA = M; } else { nA = N; }
 
   inca = LDA  * ( nA SHIFT );
   incb = LDB  * ( N  SHIFT );
   incc = LDC  * ( N  SHIFT );
 
   lA = inca  * ( ( ATL_DivBySize( LCSIZE ) + nA*nA - 1 ) / ( nA * nA ) );
   lB = incb  * ( ( ATL_DivBySize( LCSIZE ) + M * N - 1 ) / ( M  * N  ) );
   lC = incc  * ( ( ATL_DivBySize( LCSIZE ) + M * N - 1 ) / ( M  * N  ) );
 
   A0 = (TYPE *)malloc( ATL_MulBySize( lA ) );
   B0 = (TYPE *)malloc( ATL_MulBySize( lB ) );
   C0 = (TYPE *)malloc( ATL_MulBySize( lC ) );
 
   if( ( A0 == NULL ) || ( B0 == NULL ) || ( C0 == NULL ) )
   {
      if( A0 ) free( A0 );
      if( B0 ) free( B0 );
      if( C0 ) free( C0 );
      return( -1 );
   }
 
   A = A0; stA = A0 + ( lA SHIFT );
   B = B0; stB = B0 + ( lB SHIFT );
   C = C0; stC = C0 + ( lC SHIFT );
 
#ifdef TREAL
   beta   =  BETA;
   nbeta  = -BETA;
#else
   *beta  =    *BETA; beta [1] =  BETA[1];
   *nbeta = -(*BETA); nbeta[1] = -BETA[1];
#endif
 
   Aseed = nA * nA + 513 *  7 + 90;
   Bseed = M  * N  + 127 * 50 + 77;
   Cseed = M  * N  + 101 *  2 + 53;
 
   reps  = ( MEGA * MFLOP ) / flops;
/*
 * Generate the random data and time the trusted routine
 */
   bet = beta; a = A; b = B; c = C;
 
   Mjoin( PATL, gegen )( lA, 1, A0, lA, Aseed );
   Mjoin( PATL, gegen )( lB, 1, B0, lB, Bseed );
   Mjoin( PATL, gegen )( lC, 1, C0, lC, Cseed );
 
#ifdef TREAL
   t0 = time00();
   for( ir = reps; ir; ir-- )
   {
      trusted_symm( SIDE, UPLO, M, N, ALPHA, a, LDA, b, LDB, (SCALAR)(bet),
                    c, LDC );
      a += inca; if( a == stA ) { a = A; }
      b += incb; if( b == stB ) { b = B; }
      c += incc;
      if( c == stC ) { c = C; if( bet == beta ) bet = nbeta; else bet = beta; }
   }
   ttrust = time00() - t0;
#else
   if( ROUT == SYMM )
   {
      t0 = time00();
      for( ir = reps; ir; ir-- )
      {
         trusted_symm( SIDE, UPLO, M, N, ALPHA, a, LDA, b, LDB, (SCALAR)(bet),
                       c, LDC );
         a += inca; if( a == stA ) { a = A; }
         b += incb; if( b == stB ) { b = B; }
         c += incc;
         if( c == stC )
         { c = C; if( bet == beta ) bet = nbeta; else bet = beta; }
      }
      ttrust = time00() - t0;
   }
   else /* if( ROUT == HEMM ) */
   {
      t0 = time00();
      for( ir = reps; ir; ir-- )
      {
         trusted_hemm( SIDE, UPLO, M, N, ALPHA, a, LDA, b, LDB, (SCALAR)(bet),
                       c, LDC );
         a += inca; if( a == stA ) { a = A; }
         b += incb; if( b == stB ) { b = B; }
         c += incc;
         if( c == stC )
         { c = C; if( bet == beta ) bet = nbeta; else bet = beta; }
      }
      ttrust = time00() - t0;
   }
#endif
   if( ttrust > 0.0 ) mftrust = ( reps * flops ) / ( MEGA * ttrust );
   else               mftrust = 0.0;
   ttrust /= reps; *TTRUST0 = ttrust; *MFTRUST0 = mftrust;
@ROUT l3time
   free(A0);
   free(B0);
   free(C0);
   return(0);
}
@ROUT l3blastst
/*
 * Generate the random data and time the tested routine
 */
   bet = beta; a = A; b = B; c = C;
 
   Mjoin( PATL, gegen )( lA, 1, A0, lA, Aseed );
   Mjoin( PATL, gegen )( lB, 1, B0, lB, Bseed );
   Mjoin( PATL, gegen )( lC, 1, C0, lC, Cseed );
 
#ifdef TREAL
   t0 = time00();
   for( ir = reps; ir; ir-- )
   {
      test_symm(    SIDE, UPLO, M, N, ALPHA, a, LDA, b, LDB, (SCALAR)(bet),
                    c, LDC );
      a += inca; if( a == stA ) { a = A; }
      b += incb; if( b == stB ) { b = B; }
      c += incc;
      if( c == stC ) { c = C; if( bet == beta ) bet = nbeta; else bet = beta; }
   }
   ttest = time00() - t0;
#else
   if( ROUT == SYMM )
   {
      t0 = time00();
      for( ir = reps; ir; ir-- )
      {
         test_symm(    SIDE, UPLO, M, N, ALPHA, a, LDA, b, LDB, (SCALAR)(bet),
                       c, LDC );
         a += inca; if( a == stA ) { a = A; }
         b += incb; if( b == stB ) { b = B; }
         c += incc;
         if( c == stC )
         { c = C; if( bet == beta ) bet = nbeta; else bet = beta; }
      }
      ttest = time00() - t0;
   }
   else /* if( ROUT == HEMM ) */
   {
      t0 = time00();
      for( ir = reps; ir; ir-- )
      {
         test_hemm(    SIDE, UPLO, M, N, ALPHA, a, LDA, b, LDB, (SCALAR)(bet),
                       c, LDC );
         a += inca; if( a == stA ) { a = A; }
         b += incb; if( b == stB ) { b = B; }
         c += incc;
         if( c == stC )
         { c = C; if( bet == beta ) bet = nbeta; else bet = beta; }
      }
      ttest = time00() - t0;
   }
#endif
   if( ttest  > 0.0 ) mftest  = ( reps * flops ) / ( MEGA * ttest  );
   else               mftest  = 0.0;
   ttest  /= reps; *TTEST0  = ttest;  *MFTEST0  = mftest;
/*
 * release the memory and exit
 */
   free( C0 );
   free( B0 );
   free( A0 );
 
   return( passed );
}
@ROUT l3blastst l3time

int syr2kcase
(
   const int                  CACHESIZE,
   const enum LVL3_ROUT       ROUT,
   const int                  TEST,
   const int                  MFLOP,
   const enum ATLAS_UPLO      UPLO,
   const enum ATLAS_TRANS     TRANS,
   const int                  N,
   const int                  K,
   const SCALAR               ALPHA,
   const int                  LDA,
   const int                  LDB,
   const SCALAR               BETA,
   const int                  LDC,
   const TYPE                 EPSILON,
   double                     * TTRUST0,
   double                     * TTEST0,
   double                     * MFTRUST0,
   double                     * MFTEST0
)
{
   double                     flops, ttrust, ttest, mftrust, mftest, t0;
   TYPE                       resid = ATL_rzero;
#ifdef TREAL
   TYPE                       bet,  beta,    nbeta;
#else
   TYPE                       *bet, beta[2], nbeta[2];
#endif
   TYPE                       * a, * stA, *b, * stB, * c, * stC, * A,
                              * A0 = NULL, * B, * B0 = NULL, * C, * C0 = NULL;
   unsigned long              ir, reps;
   int                        inca, incb, incc, lA, lB, lC, mAB, nAB, passed,
                              Aseed, Bseed, Cseed;
   enum ATLAS_TRANS           ta;
 
   if( ( MEGA * MFLOP <= ( flops = opbl3( ROUT, N, 0, K ) ) ) || ( TEST ) )
   {
      resid = syr2ktst( CACHESIZE, ROUT, TEST, UPLO, TRANS, N, K, ALPHA,
			LDA, LDB, BETA, LDC, EPSILON, TTRUST0, TTEST0,
			MFTRUST0, MFTEST0 );
      if( resid > THRESH ) (void) fprintf( stderr, "   resid=%f\n", resid );
   }
   if( resid < ATL_rzero ) passed = -1;
   else                    passed = ( resid < THRESH );
 
   if( MEGA * MFLOP <= flops ) return( passed );
 
   if( TRANS == AtlasNoTrans )
   { ta = TRANS; mAB = N; nAB = K; }
   else
   { ta = ( ROUT == SYR2K ? AtlasTrans : AtlasConjTrans ); mAB = K; nAB = N; }

   inca = LDA  * ( nAB SHIFT );
   incb = LDB  * ( nAB SHIFT );
   incc = LDC  * ( N   SHIFT );
 
   lA = inca  * ( ( ATL_DivBySize( LCSIZE ) + mAB*nAB - 1 ) / ( mAB * nAB ) );
   lB = incb  * ( ( ATL_DivBySize( LCSIZE ) + mAB*nAB - 1 ) / ( mAB * nAB ) );
   lC = incc  * ( ( ATL_DivBySize( LCSIZE ) + N * N   - 1 ) / ( N   * N   ) );
 
   A0 = (TYPE *)malloc( ATL_MulBySize( lA ) );
   B0 = (TYPE *)malloc( ATL_MulBySize( lB ) );
   C0 = (TYPE *)malloc( ATL_MulBySize( lC ) );
 
   if( ( A0 == NULL ) || ( B0 == NULL ) || ( C0 == NULL ) )
   {
      if( A0 ) free( A0 );
      if( B0 ) free( B0 );
      if( C0 ) free( C0 );
      return( -1 );
   }
 
   A = A0; stA = A0 + ( lA SHIFT );
   B = B0; stB = B0 + ( lB SHIFT );
   C = C0; stC = C0 + ( lC SHIFT );
 
#ifdef TREAL
   beta   =  BETA;
   nbeta  = -BETA;
#else
   *beta  =    *BETA; beta [1] =  BETA[1];
   *nbeta = -(*BETA); nbeta[1] = -BETA[1];
#endif
 
   Aseed = mAB * nAB + 513 *  7 + 90;
   Bseed = mAB * nAB + 127 * 50 + 77;
   Cseed = N   * N   + 101 *  2 + 53;
 
   reps  = ( MEGA * MFLOP ) / flops;
/*
 * Generate the random data and time the trusted routine
 */
   bet = beta; a = A; b = B; c = C;
 
   Mjoin( PATL, gegen )( lA, 1, A0, lA, Aseed );
   Mjoin( PATL, gegen )( lB, 1, B0, lB, Bseed );
   Mjoin( PATL, gegen )( lC, 1, C0, lC, Cseed );
 
#ifdef TREAL
   t0 = time00();
   for( ir = reps; ir; ir-- )
   {
      trusted_syr2k( UPLO, ta, N, K, ALPHA, a, LDA, b, LDB, (SCALAR)(bet),
                     c, LDC );
      a += inca; if( a == stA ) { a = A; }
      b += incb; if( b == stB ) { b = B; }
      c += incc;
      if( c == stC ) { c = C; if( bet == beta ) bet = nbeta; else bet = beta; }
   }
   ttrust = time00() - t0;
#else
   if( ROUT == SYR2K )
   {
      t0 = time00();
      for( ir = reps; ir; ir-- )
      {
         trusted_syr2k( UPLO, ta, N, K, ALPHA, a, LDA, b, LDB, (SCALAR)(bet),
                        c, LDC );
         a += inca; if( a == stA ) { a = A; }
         b += incb; if( b == stB ) { b = B; }
         c += incc;
         if( c == stC )
         { c = C; if( bet == beta ) bet = nbeta; else bet = beta; }
      }
      ttrust = time00() - t0;
   }
   else /* if( ROUT == HER2K ) */
   {
      t0 = time00();
      for( ir = reps; ir; ir-- )
      {
         trusted_her2k( UPLO, ta, N, K, ALPHA, a, LDA, b, LDB, (TYPE)(bet[0]),
                        c, LDC );
         a += inca; if( a == stA ) { a = A; }
         b += incb; if( b == stB ) { b = B; }
         c += incc;
         if( c == stC )
         { c = C; if( bet == beta ) bet = nbeta; else bet = beta; }
      }
      ttrust = time00() - t0;
   }
#endif
   if( ttrust > 0.0 ) mftrust = ( reps * flops ) / ( MEGA * ttrust );
   else               mftrust = 0.0;
   ttrust /= reps; *TTRUST0 = ttrust; *MFTRUST0 = mftrust;
@ROUT l3time
   free(A0);
   free(B0);
   free(C0);
   return(0);
}
@ROUT l3blastst
/*
 * Generate the random data and time the tested routine
 */
   bet = beta; a = A; b = B; c = C;
 
   Mjoin( PATL, gegen )( lA, 1, A0, lA, Aseed );
   Mjoin( PATL, gegen )( lB, 1, B0, lB, Bseed );
   Mjoin( PATL, gegen )( lC, 1, C0, lC, Cseed );
 
#ifdef TREAL
   t0 = time00();
   for( ir = reps; ir; ir-- )
   {
      test_syr2k(    UPLO, ta, N, K, ALPHA, a, LDA, b, LDB, (SCALAR)(bet),
                     c, LDC );
      a += inca; if( a == stA ) { a = A; }
      b += incb; if( b == stB ) { b = B; }
      c += incc;
      if( c == stC ) { c = C; if( bet == beta ) bet = nbeta; else bet = beta; }
   }
   ttest = time00() - t0;
#else
   if( ROUT == SYR2K )
   {
      t0 = time00();
      for( ir = reps; ir; ir-- )
      {
         test_syr2k(    UPLO, ta, N, K, ALPHA, a, LDA, b, LDB, (SCALAR)(bet),
                        c, LDC );
         a += inca; if( a == stA ) { a = A; }
         b += incb; if( b == stB ) { b = B; }
         c += incc;
         if( c == stC )
         { c = C; if( bet == beta ) bet = nbeta; else bet = beta; }
      }
      ttest = time00() - t0;
   }
   else /* if( ROUT == HER2K ) */
   {
      t0 = time00();
      for( ir = reps; ir; ir-- )
      {
         test_her2k(    UPLO, ta, N, K, ALPHA, a, LDA, b, LDB, (TYPE)(bet[0]),
                        c, LDC );
         a += inca; if( a == stA ) { a = A; }
         b += incb; if( b == stB ) { b = B; }
         c += incc;
         if( c == stC )
         { c = C; if( bet == beta ) bet = nbeta; else bet = beta; }
      }
      ttest = time00() - t0;
   }
#endif
   if( ttest  > 0.0 ) mftest  = ( reps * flops ) / ( MEGA * ttest  );
   else               mftest  = 0.0;
   ttest  /= reps; *TTEST0  = ttest;  *MFTEST0  = mftest;
/*
 * release the memory and exit
 */
   free( C0 );
   free( B0 );
   free( A0 );
 
   return( passed );
}
@ROUT l3blastst l3time

int syrkcase
(
   const int                  CACHESIZE,
   const enum LVL3_ROUT       ROUT,
   const int                  TEST,
   const int                  MFLOP,
   const enum ATLAS_UPLO      UPLO,
   const enum ATLAS_TRANS     TRANS,
   const int                  N,
   const int                  K,
   const SCALAR               ALPHA,
   const int                  LDA,
   const SCALAR               BETA,
   const int                  LDC,
   const TYPE                 EPSILON,
   double                     * TTRUST0,
   double                     * TTEST0,
   double                     * MFTRUST0,
   double                     * MFTEST0
)
{
   double                     flops, ttrust, ttest, mftrust, mftest, t0;
   TYPE                       resid = ATL_rzero;
#ifdef TREAL
   TYPE                       bet,  beta,    nbeta;
#else
   TYPE                       *bet, beta[2], nbeta[2];
#endif
   TYPE                       * a, * stA, * c, * stC, * A, * A0 = NULL,
                              * C, * C0 = NULL;
   unsigned long              ir, reps;
   int                        inca, incc, lA, lC, mA, nA, passed, Aseed, Cseed;
   enum ATLAS_TRANS           ta;

   if( ( MEGA * MFLOP <= ( flops = opbl3( ROUT, N, 0, K ) ) ) || ( TEST ) )
   {
      resid = syrktst( CACHESIZE, ROUT, TEST, UPLO, TRANS, N, K, ALPHA, LDA,
		       BETA, LDC, EPSILON, TTRUST0, TTEST0, MFTRUST0,
		       MFTEST0 );
      if( resid > THRESH ) (void) fprintf( stderr, "   resid=%f\n", resid );
   }
   if( resid < ATL_rzero ) passed = -1;
   else                    passed = ( resid < THRESH );
 
   if( MEGA * MFLOP <= flops ) return( passed );
 
   if( TRANS == AtlasNoTrans )
   { ta = TRANS; mA = N; nA = K; }
   else
   { ta = ( ROUT == SYRK ? AtlasTrans : AtlasConjTrans ); mA = K; nA = N; }

   inca = LDA  * ( nA SHIFT );
   incc = LDC  * ( N  SHIFT );
 
   lA = inca  * ( ( ATL_DivBySize( LCSIZE ) + mA*nA - 1 ) / ( mA * nA ) );
   lC = incc  * ( ( ATL_DivBySize( LCSIZE ) + N * N - 1 ) / ( N   * N ) );
 
   A0 = (TYPE *)malloc( ATL_MulBySize( lA ) );
   C0 = (TYPE *)malloc( ATL_MulBySize( lC ) );
 
   if( ( A0 == NULL ) || ( C0 == NULL ) )
   { if( A0 ) free( A0 ); if( C0 ) free( C0 ); return( -1 ); }
 
   A = A0; stA = A0 + ( lA SHIFT );
   C = C0; stC = C0 + ( lC SHIFT );
 
#ifdef TREAL
   beta   =  BETA;
   nbeta  = -BETA;
#else
   *beta  =    *BETA; beta [1] =  BETA[1];
   *nbeta = -(*BETA); nbeta[1] = -BETA[1];
#endif
 
   Aseed = mA * nA + 513 *  7 + 90;
   Cseed = N  * N  + 101 *  2 + 53;
 
   reps  = ( MEGA * MFLOP ) / flops;
/*
 * Generate the random data and time the trusted routine
 */
   bet = beta; a = A; c = C;
 
   Mjoin( PATL, gegen )( lA, 1, A0, lA, Aseed );
   Mjoin( PATL, gegen )( lC, 1, C0, lC, Cseed );
 
#ifdef TREAL
   t0 = time00();
   for( ir = reps; ir; ir-- )
   {
      trusted_syrk( UPLO, ta, N, K, ALPHA, a, LDA, (SCALAR)(bet), c, LDC );
      a += inca; if( a == stA ) { a = A; }
      c += incc;
      if( c == stC ) { c = C; if( bet == beta ) bet = nbeta; else bet = beta; }
   }
   ttrust = time00() - t0;
#else
   if( ROUT == SYRK )
   {
      t0 = time00();
      for( ir = reps; ir; ir-- )
      {
         trusted_syrk( UPLO, ta, N, K, ALPHA, a, LDA, (SCALAR)(bet), c, LDC );
         a += inca; if( a == stA ) { a = A; }
         c += incc;
         if( c == stC )
         { c = C; if( bet == beta ) bet = nbeta; else bet = beta; }
      }
      ttrust = time00() - t0;
   }
   else /* if( ROUT == HERK ) */
   {
      t0 = time00();
      for( ir = reps; ir; ir-- )
      {
         trusted_herk( UPLO, ta, N, K, (TYPE)(ALPHA[0]), a, LDA,
                       (TYPE)(bet[0]), c, LDC );
         a += inca; if( a == stA ) { a = A; }
         c += incc;
         if( c == stC )
         { c = C; if( bet == beta ) bet = nbeta; else bet = beta; }
      }
      ttrust = time00() - t0;
   }
#endif
   if( ttrust > 0.0 ) mftrust = ( reps * flops ) / ( MEGA * ttrust );
   else               mftrust = 0.0;
   ttrust /= reps; *TTRUST0 = ttrust; *MFTRUST0 = mftrust;
@ROUT l3time
   free(A0);
   free(C0);
   return(0);
}
@ROUT l3blastst
/*
 * Generate the random data and time the tested routine
 */
   bet = beta; a = A; c = C;
 
   Mjoin( PATL, gegen )( lA, 1, A0, lA, Aseed );
   Mjoin( PATL, gegen )( lC, 1, C0, lC, Cseed );
 
#ifdef TREAL
   t0 = time00();
   for( ir = reps; ir; ir-- )
   {
      test_syrk(    UPLO, ta, N, K, ALPHA, a, LDA, (SCALAR)(bet), c, LDC );
      a += inca; if( a == stA ) { a = A; }
      c += incc;
      if( c == stC ) { c = C; if( bet == beta ) bet = nbeta; else bet = beta; }
   }
   ttest = time00() - t0;
#else
   if( ROUT == SYRK )
   {
      t0 = time00();
      for( ir = reps; ir; ir-- )
      {
         test_syrk(    UPLO, ta, N, K, ALPHA, a, LDA, (SCALAR)(bet), c, LDC );
         a += inca; if( a == stA ) { a = A; }
         c += incc;
         if( c == stC )
         { c = C; if( bet == beta ) bet = nbeta; else bet = beta; }
      }
      ttest = time00() - t0;
   }
   else /* if( ROUT == HERK ) */
   {
      t0 = time00();
      for( ir = reps; ir; ir-- )
      {
         test_herk(    UPLO, ta, N, K, (TYPE)(ALPHA[0]), a, LDA,
                       (TYPE)(bet[0]), c, LDC );
         a += inca; if( a == stA ) { a = A; }
         c += incc;
         if( c == stC )
         { c = C; if( bet == beta ) bet = nbeta; else bet = beta; }
      }
      ttest = time00() - t0;
   }
#endif
   if( ttest  > 0.0 ) mftest  = ( reps * flops ) / ( MEGA * ttest  );
   else               mftest  = 0.0;
   ttest  /= reps; *TTEST0  = ttest;  *MFTEST0  = mftest;
/*
 * release the memory and exit
 */
   free( C0 );
   free( A0 );
 
   return( passed );
} 
@ROUT l3blastst l3time

int trxmcase
(
   const int                  CACHESIZE,
   const enum LVL3_ROUT       ROUT,
   const int                  TEST,
   const int                  MFLOP,
   const enum ATLAS_SIDE      SIDE,
   const enum ATLAS_UPLO      UPLO,
   const enum ATLAS_TRANS     TRANS,
   const enum ATLAS_DIAG      DIAG,
   const int                  M,
   const int                  N,
   const SCALAR               ALPHA,
   const int                  LDA,
   const int                  LDB,
   const TYPE                 EPSILON,
   double                     * TTRUST0,
   double                     * TTEST0,
   double                     * MFTRUST0,
   double                     * MFTEST0
)
{
   double                     flops, ttrust, ttest, mftrust, mftest, t0;
   TYPE                       resid = ATL_rzero;
   TYPE                       * a, * stA, * b, * stB, * A, * A0 = NULL,
                              * B, * B0 = NULL;
   unsigned long              ir, reps;
   int                        inca, incb, lA, lB, nA, passed, Aseed, Bseed;

   flops = opbl3( ROUT, M, N, ( SIDE == AtlasLeft ? -1 : 1 ) );
 
   if( ( MEGA * MFLOP <= flops ) || ( TEST ) )
   {
      if( ROUT == TRMM )
      {
         resid = trmmtst( CACHESIZE, ROUT, TEST, SIDE, UPLO, TRANS, DIAG,
			  M, N, ALPHA, LDA, LDB, EPSILON, TTRUST0, TTEST0,
			  MFTRUST0, MFTEST0 );
      }
      else
      {
         resid = trsmtst( CACHESIZE, ROUT, TEST, SIDE, UPLO, TRANS, DIAG,
			  M, N, ALPHA, LDA, LDB, EPSILON, TTRUST0, TTEST0,
			  MFTRUST0, MFTEST0 );
      }
      if( resid > THRESH ) (void) fprintf( stderr, "   resid=%f\n", resid );
   }
   if( resid < ATL_rzero ) passed = -1;
   else                    passed = ( resid < THRESH );
 
   if( MEGA * MFLOP <= flops ) return( passed );
 
   if( SIDE == AtlasLeft ) { nA = M; } else { nA = N; }
 
   inca = LDA * ( nA SHIFT );
   incb = LDB * ( N  SHIFT );
 
   lA = inca * ( ( ATL_DivBySize( LCSIZE ) + nA*nA - 1 ) / ( nA * nA ) );
   lB = incb * ( ( ATL_DivBySize( LCSIZE ) + M * N - 1 ) / ( M   * N ) );
 
   A0 = (TYPE *)malloc( ATL_MulBySize( lA ) );
   B0 = (TYPE *)malloc( ATL_MulBySize( lB ) );

   if( ( A0 == NULL ) || ( B0 == NULL ) )
   { if( A0 ) free( A0 ); if( B0 ) free( B0 ); return( -1 ); }
 
   A = A0; stA = A0 + ( lA SHIFT );
   B = B0; stB = B0 + ( lB SHIFT );
 
   Aseed = nA * nA + 513 *  7 + 90;
   Bseed = M  * N  + 101 *  2 + 53;
 
   reps  = ( MEGA * MFLOP ) / flops;
/*
 * Generate the random data and time the trusted routine
 */
   a = A; b = B;
 
   Mjoin( PATL, gegen )( lA, 1, A0, lA, Aseed );
   Mjoin( PATL, gegen )( lB, 1, B0, lB, Bseed );

   if( ROUT == TRMM )
   {
      t0 = time00();
      for( ir = reps; ir; ir-- )
      {
         trusted_trmm( SIDE, UPLO, TRANS, DIAG, M, N, ALPHA, a, LDA, b, LDB );
         a += inca; if( a == stA ) { a = A; }
         b += incb; if( b == stB ) { b = B; }
      }
      ttrust = time00() - t0;
   }
   else /* if( ROUT == TRSM ) */
   {
      do { trddom( UPLO, nA, a, LDA ); a += inca; } while( a != stA ); a = A;

      t0 = time00();
      for( ir = reps; ir; ir-- )
      {
         trusted_trsm( SIDE, UPLO, TRANS, DIAG, M, N, ALPHA, a, LDA, b, LDB );
         a += inca; if( a == stA ) { a = A; }
         b += incb; if( b == stB ) { b = B; }
      }
      ttrust = time00() - t0;
   }
   if( ttrust > 0.0 ) mftrust = ( reps * flops ) / ( MEGA * ttrust );
   else               mftrust = 0.0;
   ttrust /= reps; *TTRUST0 = ttrust; *MFTRUST0 = mftrust;
@ROUT l3time
   free(A0);
   free(B0);
   return(0);
}
@ROUT l3blastst
/*
 * Generate the random data and time the tested routine
 */
   a = A; b = B;
 
   Mjoin( PATL, gegen )( lA, 1, A0, lA, Aseed );
   Mjoin( PATL, gegen )( lB, 1, B0, lB, Bseed );
 
   if( ROUT == TRMM )
   {
      t0 = time00();
      for( ir = reps; ir; ir-- )
      {
         test_trmm(    SIDE, UPLO, TRANS, DIAG, M, N, ALPHA, a, LDA, b, LDB );
         a += inca; if( a == stA ) { a = A; }
         b += incb; if( b == stB ) { b = B; }
      }
      ttest = time00() - t0;
   }
   else /* if( ROUT == TRSM ) */
   {
      do { trddom( UPLO, nA, a, LDA ); a += inca; } while( a != stA ); a = A;

      t0 = time00();
      for( ir = reps; ir; ir-- )
      {
         test_trsm(    SIDE, UPLO, TRANS, DIAG, M, N, ALPHA, a, LDA, b, LDB );
         a += inca; if( a == stA ) { a = A; }
         b += incb; if( b == stB ) { b = B; }
      }
      ttest = time00() - t0;
   }
   if( ttest  > 0.0 ) mftest  = ( reps * flops ) / ( MEGA * ttest  );
   else               mftest  = 0.0;
   ttest  /= reps; *TTEST0  = ttest;  *MFTEST0  = mftest; 
/*
 * release the memory and exit
 */
   free( B0 );
   free( A0 );
 
   return( passed );
} 
@ROUT l3blastst
/*
 * =====================================================================
 * Run functions
 * =====================================================================
 */
void RungemmCase
(
   const int                  CACHESIZE,
   const enum LVL3_ROUT       ROUT,
   const int                  TEST,
   const int                  MFLOP,
   const int                  LDA_IS_M,
   const int                  NTRANA,
   const enum ATLAS_TRANS     * TRANSA,
   const int                  NTRANB,
   const enum ATLAS_TRANS     * TRANSB,
   int                        M0,
   int                        MN,
   int                        MINC,
   int                        N0,
   int                        NN,
   int                        NINC,
   int                        K0,
   int                        KN,
   int                        KINC,
   const int                  NALPHA,
   const TYPE                 * ALPHAS,
   const int                  NBETA,
   const TYPE                 * BETAS,
   const TYPE                 EPSILON, 
   int                        * NPASSED,
   int                        * NTESTS
)
{
   double                     t0, mftrust, mftest, ttrust, ttest;
   char                       * pass, * form;
   int                        al, be, ires, k, kk, lda, ldb, ldc, m, mm, n,
                              nn, ta, tb, ksame=0, msame=0;
   char                       ctrana, ctranb;

   if( M0 == -1 ) { msame = 1; M0 = MN = MINC = NN; }
   if( K0 == -1 ) { ksame = 1; K0 = KN = KINC = NN; }

#ifdef TREAL
   (void) fprintf( stdout, "\n%s%s%s\n",
                   "--------------------------------- ", "GEMM",
                   " ----------------------------------" );
   (void) fprintf( stdout, "%s%s",
                   "TST# A B    M    N    K ALPHA  LDA  LDB  BETA",
                   "  LDC  TIME MFLOP SpUp  TEST\n" );
   (void) fprintf( stdout, "%s%s",
                   "==== = = ==== ==== ==== ===== ==== ==== =====",
                   " ==== ===== ===== ==== =====\n" );
form = "%4d %c %c %4d %4d %4d %5.1f %4d %4d %5.1f %4d %5.2f %5.1f %4.2f %5s\n";
#else
   (void) fprintf( stdout, "\n%s%s%s\n",
                   "----------------------------------- ", "GEMM",
                   " ---------------------------------------" );
   (void) fprintf( stdout, "%s%s",
                   "TST# A B    M    N    K rALP iALP  LDA  LDB",
                   " rBET iBET  LDC TIME MFLOP SpUp  TEST\n" );
   (void) fprintf( stdout, "%s%s",
                   "==== = = ==== ==== ==== ==== ==== ==== ====",
                   " ==== ==== ==== ==== ===== ==== =====\n" );
   form =
"%4d %c %c %4d %4d %4d %4.1f %4.1f %4d %4d %4.1f %4.1f %4d %4.1f %5.1f %4.2f %5s\n";
#endif 

   for( mm = M0; mm <= MN; mm += MINC )
   {
      for( nn = N0; nn <= NN; nn += NINC )
      {
         n = nn; if( msame ) { m = nn; } else { m = mm; }
         if( LDA_IS_M ) ldc = Mmax( 1, m ); else ldc = MN;

         for( kk = K0; kk <= KN; kk += KINC )
         {
            if( ksame ) { k = nn; } else { k = kk; }
 
            for( ta = 0; ta < NTRANA; ta++ )
            {
               if(      TRANSA[ta] == AtlasNoTrans   ) ctrana = 'N';
               else if( TRANSA[ta] == AtlasTrans     ) ctrana = 'T';
               else                                    ctrana = 'C';

               if(      TRANSA[ta] == AtlasNoTrans   )
               { if( LDA_IS_M ) lda = Mmax( 1, m ); else lda = MN; }
               else
               { if( LDA_IS_M ) lda = Mmax( 1, k ); else lda = KN; }

               for( tb = 0; tb < NTRANB; tb++ )
               {
                  if(      TRANSB[tb] == AtlasNoTrans   ) ctranb = 'N';
                  else if( TRANSB[tb] == AtlasTrans     ) ctranb = 'T';
                  else                                    ctranb = 'C';
 
                  if(      TRANSB[tb] == AtlasNoTrans   )
                  { if( LDA_IS_M ) ldb = Mmax( 1, k ); else ldb = KN; }
                  else
                  { if( LDA_IS_M ) ldb = Mmax( 1, n ); else ldb = NN; }

                  for( al = 0; al < NALPHA; al++ )
                  {
                     for( be = 0; be < NBETA; be++ )
                     {
                        int isam;
                        for (isam=0; isam < NSAMP; isam++)
                        {
#ifdef TREAL
                        ires = gemmcase( CACHESIZE, ROUT, TEST, MFLOP,
					 TRANSA[ta],
                                         TRANSB[tb], m, n, k, ALPHAS[al], lda,
                                         ldb, BETAS[be], ldc, EPSILON, &ttrust,
                                         &ttest, &mftrust, &mftest );
#else
                        ires = gemmcase( CACHESIZE, ROUT, TEST, MFLOP,
					 TRANSA[ta],
                                         TRANSB[tb], m, n, k, ALPHAS+2*al, lda,
                                         ldb, BETAS+2*be, ldc, EPSILON, &ttrust,
                                         &ttest, &mftrust, &mftest );
#endif
                        if(     !( TEST ) ) pass = "SKIP ";
                        else if( ires < 0 ) pass = "NoMEM";
                        else if( ires     ) pass = "PASS ";
                        else                pass = "FAIL ";
 
                        if( ires > 0 ) (*NPASSED)++;
 
                        if( ( mftrust > 0.0 ) && ( mftest > 0.0 ) )
                           t0 = mftest / mftrust;
                        else t0 = 0.0;
#ifdef TREAL
                        (void) fprintf( stdout, form, *NTESTS, ctrana, ctranb,
                                        m, n, k, ALPHAS[al], lda, ldb, 
                                        BETAS[be], ldc, ttrust, mftrust, 1.0,
                                        "-----" );
                        (void) fprintf( stdout, form, *NTESTS, ctrana, ctranb,
                                        m, n, k, ALPHAS[al], lda, ldb,
                                        BETAS[be], ldc, ttest,  mftest,  t0,
                                        pass );
#else
                        (void) fprintf( stdout, form, *NTESTS, ctrana, ctranb,
                                        m, n, k,  ALPHAS[2*al], ALPHAS[2*al+1],
                                        lda, ldb, BETAS [2*be], BETAS [2*be+1],
                                        ldc, ttrust, mftrust, 1.0, "-----" );
                        (void) fprintf( stdout, form, *NTESTS, ctrana, ctranb,
                                        m, n, k,  ALPHAS[2*al], ALPHAS[2*al+1],
                                        lda, ldb, BETAS [2*be], BETAS [2*be+1],
                                        ldc, ttest,  mftest,  t0,  pass );
#endif
                        (*NTESTS)++; 
                        }
                     }
                  }
               }
            }
         }
      }
   }
}

void RunsymmCase
(
   const int                  CACHESIZE,
   const enum LVL3_ROUT       ROUT,
   const int                  TEST,
   const int                  MFLOP,
   const int                  LDA_IS_M,
   const int                  NSIDE,
   const enum ATLAS_SIDE      * SIDES,
   const int                  NUPLO,
   const enum ATLAS_UPLO      * UPLOS,
   int                        M0,
   int                        MN,
   int                        MINC,
   int                        N0,
   int                        NN,
   int                        NINC,
   const int                  NALPHA,
   const TYPE                 * ALPHAS,
   const int                  NBETA,
   const TYPE                 * BETAS,
   const TYPE                 EPSILON,
   int                        * NPASSED,
   int                        * NTESTS
)
{
   double                     t0, mftrust, mftest, ttrust, ttest;
   char                       * pass, * form;
   int                        al, be, ires, lda, ldb, ldc, m, msame=0, mm, n,
                              nn, si, up;
   char                       cside, cuplo;

   if( M0 == -1 ) { msame = 1; M0 = MN = MINC = NN; }

#ifdef TREAL
   (void) fprintf( stdout, "\n%s%s%s\n",
                   "-------------------------------- ", "SYMM",
                   " --------------------------------" );
   (void) fprintf( stdout, "%s%s",
                   "TST# S U    M    N ALPHA  LDA  LDB  BETA  LDC",
                   "   TIME MFLOP  SpUp  TEST\n" );
   (void) fprintf( stdout, "%s%s",
                   "==== = = ==== ==== ===== ==== ==== ===== ====",
                   " ====== ===== ===== =====\n" );
   form = "%4d %c %c %4d %4d %5.1f %4d %4d %5.1f %4d %6.2f %5.1f %5.2f %5s\n";
#else
   if( ROUT == SYMM )
   {
      (void) fprintf( stdout, "\n%s%s%s\n",
                      "------------------------------------ ", "SYMM",
                      " ------------------------------------" );
      (void) fprintf( stdout, "%s%s",
                      "TST# S U    M    N rALP iALP  LDA  LDB rBET iBET",
                      "  LDC   TIME MFLOP  SpUp  TEST\n" );
      (void) fprintf( stdout, "%s%s",
                      "==== = = ==== ==== ==== ==== ==== ==== ==== ====",
                      " ==== ====== ===== ===== =====\n" );
      form =
"%4d %c %c %4d %4d %4.1f %4.1f %4d %4d %4.1f %4.1f %4d %6.2f %5.1f %5.2f %5s\n";
   }
   else
   {
      (void) fprintf( stdout, "\n%s%s%s\n",
                      "------------------------------------ ", "HEMM",
                      " ------------------------------------" );
      (void) fprintf( stdout, "%s%s",
                      "TST# S U    M    N rALP iALP  LDA  LDB iBET rBET",
                      "  LDC   TIME MFLOP  SpUp  TEST\n" );
      (void) fprintf( stdout, "%s%s",
                      "==== = = ==== ==== ==== ==== ==== ==== ==== ====",
                      " ==== ====== ===== ===== =====\n" );
      form =
"%4d %c %c %4d %4d %4.1f %4.1f %4d %4d %4.1f %4.1f %4d %6.2f %5.1f %5.2f %5s\n";
   }
#endif
   for( mm = M0; mm <= MN; mm += MINC )
   {
      for( nn = N0; nn <= NN; nn += NINC )
      {
         n = nn; if( msame ) { m = nn; } else { m = mm; }
         if( LDA_IS_M ) { ldb = ldc = Mmax( 1, m ); } else { ldb = ldc = MN; }

         for( si = 0; si < NSIDE; si++ )
         {
            if( SIDES[si] == AtlasLeft )
            { cside = 'L'; if( LDA_IS_M ) lda = Mmax( 1, m ); else lda = MN; }
            else
            { cside = 'R'; if( LDA_IS_M ) lda = Mmax( 1, n ); else lda = NN; }

            for( up = 0; up < NUPLO; up++ )
            {
               if( UPLOS[up] == AtlasLower ) cuplo = 'L';
               else                          cuplo = 'U';
 
               for( al = 0; al < NALPHA; al++ )
               {
                  for( be = 0; be < NBETA; be++ )
                  {
                     int isam;
                     for (isam=0; isam < NSAMP; isam++)
                     {
#ifdef TREAL
                     ires = symmcase( CACHESIZE, ROUT, TEST, MFLOP,
				      SIDES[si], UPLOS[up],
                                      m, n, ALPHAS[al], lda, ldb, BETAS[be],
                                      ldc, EPSILON, &ttrust, &ttest, &mftrust,
                                      &mftest );
#else
                     ires = symmcase( CACHESIZE, ROUT, TEST, MFLOP,
				      SIDES[si], UPLOS[up],
                                      m, n, ALPHAS+2*al, lda, ldb, BETAS+2*be,
                                      ldc, EPSILON, &ttrust, &ttest, &mftrust,
                                      &mftest );
#endif
                     if(     !( TEST ) ) pass = "SKIP ";
                     else if( ires < 0 ) pass = "NoMEM";
                     else if( ires     ) pass = "PASS ";
                     else                pass = "FAIL ";
 
                     if( ires > 0 ) (*NPASSED)++;
 
                     if( ( mftrust > 0.0 ) && ( mftest > 0.0 ) )
                        t0 = mftest / mftrust;
                     else t0 = 0.0;
#ifdef TREAL
                     (void) fprintf( stdout, form, *NTESTS, cside, cuplo, m, n,
                                     ALPHAS[al], lda, ldb, BETAS[be], ldc,
                                     ttrust, mftrust, 1.0, "-----" );
                     (void) fprintf( stdout, form, *NTESTS, cside, cuplo, m, n,
                                     ALPHAS[al], lda, ldb, BETAS[be], ldc,
                                     ttest,  mftest,  t0,  pass    );
#else
                     (void) fprintf( stdout, form, *NTESTS, cside, cuplo, m, n,
                                     ALPHAS[2*al], ALPHAS[2*al+1], lda, ldb,
                                     BETAS[2*be], BETAS[2*be+1], ldc, ttrust,
                                     mftrust, 1.0, "-----" );
                     (void) fprintf( stdout, form, *NTESTS, cside, cuplo, m, n,
                                     ALPHAS[2*al], ALPHAS[2*al+1], lda, ldb,
                                     BETAS[2*be], BETAS[2*be+1], ldc, ttest,
                                     mftest,  t0,  pass    );
#endif
                     (*NTESTS)++;
                     }
                  }
               }
            }
         }
      }
   }
} 

void Runsyr2kCase
(
   const int                  CACHESIZE,
   const enum LVL3_ROUT       ROUT,
   const int                  TEST,
   const int                  MFLOP,
   const int                  LDA_IS_M,
   const int                  NUPLO,
   const enum ATLAS_UPLO      * UPLOS,
   const int                  NTRAN,
   const enum ATLAS_TRANS     * TRANS,
   int                        N0,
   int                        NN,
   int                        NINC,
   int                        K0,
   int                        KN,
   int                        KINC,
   const int                  NALPHA,
   const TYPE                 * ALPHAS,
   const int                  NBETA,
   const TYPE                 * BETAS,
   const TYPE                 EPSILON,
   int                        * NPASSED,
   int                        * NTESTS
)
{
   double                     t0, mftrust, mftest, ttrust, ttest;
   char                       * pass, * form; 
   int                        al, be, ires, k, kk, ksame=0, lda, ldb, ldc, n,
                              nn, up, ta;
   char                       ctran, cuplo;

   if( K0 == -1 ) { ksame = 1; K0 = KN = KINC = NN; }

#ifdef TREAL
   (void) fprintf( stdout, "\n%s%s%s\n",
                   "-------------------------------- ", "SYR2K",
                   " --------------------------------" );
   (void) fprintf( stdout, "%s%s",
                   "TST# U T    N    K ALPHA  LDA  LDB  BETA  LDC   TIME",
                   "  MFLOP  SpUp  TEST\n" );
   (void) fprintf( stdout, "%s%s",
                   "==== = = ==== ==== ===== ==== ==== ===== ==== ======",
                   " ====== ===== =====\n" );
   form = "%4d %c %c %4d %4d %5.1f %4d %4d %5.1f %4d %6.2f %6.1f %5.2f %5s\n";
#else
   if( ROUT == SYR2K )
   {
      (void) fprintf( stdout, "\n%s%s%s\n",
                      "------------------------------------ ", "SYR2K",
                      " ------------------------------------" );
      (void) fprintf( stdout, "%s%s",
                      "TST# U T    N    K rALP iALP  LDA  LDB rBET iBET",
                      "  LDC   TIME  MFLOP  SpUp  TEST\n" );
      (void) fprintf( stdout, "%s%s",
                      "==== = = ==== ==== ==== ==== ==== ==== ==== ====",
                      " ==== ====== ====== ===== =====\n" );
      form =
"%4d %c %c %4d %4d %4.1f %4.1f %4d %4d %4.1f %4.1f %4d %6.2f %6.1f %5.2f %5s\n";
   }
   else
   {
      (void) fprintf( stdout, "\n%s%s%s\n",
                      "----------------------------------- ", "HER2K",
                      " -----------------------------------" );
      (void) fprintf( stdout, "%s%s",
                      "TST# U T    N    K rALPH iALPH  LDA  LDB  BETA",
                      "  LDC   TIME  MFLOP  SpUp  TEST\n" );
      (void) fprintf( stdout, "%s%s",
                      "==== = = ==== ==== ===== ===== ==== ==== =====",
                      " ==== ====== ====== ===== =====\n" );
      form =
      "%4d %c %c %4d %4d %5.1f %5.1f %4d %4d %5.1f %4d %6.2f %6.1f %5.2f %5s\n";
   }
#endif
   for( nn = N0; nn <= NN; nn += NINC )
   {
      n = nn; if( LDA_IS_M ) ldc = Mmax( 1, n ); else ldc = NN;

      for( kk = K0; kk <= KN; kk += KINC )
      {
         if( ksame ) { k = nn; } else { k = kk; }

         for( up = 0; up < NUPLO; up++ )
         {
            if( UPLOS[up] == AtlasUpper ) cuplo = 'U';
            else                          cuplo = 'L';

            for( ta = 0; ta < NTRAN; ta++ )
            {
#ifdef TREAL
               if( TRANS[ta] == AtlasNoTrans )
               {
                  ctran = 'N';
                  if( LDA_IS_M ) lda = ldb = n; else lda = ldb = NN;
               }
               else
               {
                  ctran = 'T';
                  if( LDA_IS_M ) lda = ldb = k; else lda = ldb = KN;
               }
#else
               if( ROUT == SYR2K )
               {
                  if( TRANS[ta] == AtlasNoTrans )
                  {
                     ctran = 'N';
                     if( LDA_IS_M ) lda = ldb = n; else lda = ldb = NN;
                  }
                  else
                  {
                     ctran = 'T';
                     if( LDA_IS_M ) lda = ldb = k; else lda = ldb = KN;
                  }
               }
               else
               {
                  if( TRANS[ta] == AtlasNoTrans )
                  {
                     ctran = 'N';
                     if( LDA_IS_M ) lda = ldb = n; else lda = ldb = NN;
                  }
                  else
                  {
                     ctran = 'C';
                     if( LDA_IS_M ) lda = ldb = k; else lda = ldb = KN;
                  }
               } 
#endif
               for( al = 0; al < NALPHA; al++ )
               {
                  for( be = 0; be < NBETA; be++ )
                  {
                     int isam;
                     for (isam=0; isam < NSAMP; isam++)
                     {
#ifdef TREAL
                     ires = syr2kcase( CACHESIZE, ROUT, TEST, MFLOP,
				       UPLOS[up], TRANS[ta],
                                       n, k, ALPHAS[al], lda, ldb, BETAS[be],
                                       ldc, EPSILON, &ttrust, &ttest, &mftrust,
                                       &mftest );
#else
                     ires = syr2kcase( CACHESIZE, ROUT, TEST, MFLOP,
				       UPLOS[up], TRANS[ta],
                                       n, k, ALPHAS+2*al, lda, ldb, BETAS+2*be,
                                       ldc, EPSILON, &ttrust, &ttest, &mftrust,
                                       &mftest );
#endif
                     if(     !( TEST ) ) pass = "SKIP ";
                     else if( ires < 0 ) pass = "NoMEM";
                     else if( ires     ) pass = "PASS ";
                     else                pass = "FAIL ";
 
                     if( ires > 0 ) (*NPASSED)++;
 
                     if( ( mftrust > 0.0 ) && ( mftest > 0.0 ) )
                        t0 = mftest / mftrust;
                     else t0 = 0.0;
#ifdef TREAL
                     (void) fprintf( stdout, form, *NTESTS, cuplo, ctran, n, k,
                                     ALPHAS[al], lda, ldb, BETAS[be], ldc,
                                     ttrust, mftrust, 1.0, "-----" );
                     (void) fprintf( stdout, form, *NTESTS, cuplo, ctran, n, k,
                                     ALPHAS[al], lda, ldb, BETAS[be], ldc,
                                     ttest, mftest, t0, pass );
#else
                     if( ROUT == SYR2K )
                     {
                        (void) fprintf( stdout, form, *NTESTS, cuplo, ctran,
                                        n, k, ALPHAS[2*al], ALPHAS[2*al+1],
                                        lda, ldb, BETAS [2*be], BETAS [2*be+1],
                                        ldc, ttrust, mftrust, 1.0, "-----" );
                        (void) fprintf( stdout, form, *NTESTS, cuplo, ctran,
                                        n, k, ALPHAS[2*al], ALPHAS[2*al+1],
                                        lda, ldb, BETAS [2*be], BETAS [2*be+1],
                                        ldc, ttest, mftest, t0, pass );
                     }
                     else
                     {
                        (void) fprintf( stdout, form, *NTESTS, cuplo, ctran,
                                        n, k, ALPHAS[2*al], ALPHAS[2*al+1],
                                        lda, ldb, BETAS [2*be], ldc, ttrust,
                                        mftrust, 1.0, "-----" );
                        (void) fprintf( stdout, form, *NTESTS, cuplo, ctran,
                                        n, k, ALPHAS[2*al], ALPHAS[2*al+1],
                                        lda, ldb, BETAS [2*be], ldc, ttest,
                                        mftest, t0, pass );
                     }
#endif
                     (*NTESTS)++;
                     }
                  }
               }
            }
         }
      }
   }
} 

void RunsyrkCase
(
   const int                  CACHESIZE,
   const enum LVL3_ROUT       ROUT,
   const int                  TEST,
   const int                  MFLOP,
   const int                  LDA_IS_M,
   const int                  NUPLO,
   const enum ATLAS_UPLO      * UPLOS,
   const int                  NTRAN,
   const enum ATLAS_TRANS     * TRANS,
   int                        N0,
   int                        NN,
   int                        NINC,
   int                        K0,
   int                        KN,
   int                        KINC,
   const int                  NALPHA,
   const TYPE                 * ALPHAS,
   const int                  NBETA,
   const TYPE                 * BETAS,
   const TYPE                 EPSILON,
   int                        * NPASSED,
   int                        * NTESTS
)
{
   double                     t0, mftrust, mftest, ttrust, ttest;
   char                       * pass, * form; 
   int                        al, be, ires, k, kk, ksame=0, lda, ldc, n, nn,
                              up, ta;
   char                       ctran, cuplo;

   if( K0 == -1 ) { ksame = 1; K0 = KN = KINC = NN; }

#ifdef TREAL
   (void) fprintf( stdout, "\n%s%s%s\n",
                   "------------------------------ ", "SYRK",
                   " ------------------------------" );
   (void) fprintf( stdout, "%s%s",
                   "TST# U T    N    K ALPHA  LDA  BETA  LDC   TIME",
                   "  MFLOP  SpUp  TEST\n" );
   (void) fprintf( stdout, "%s%s",
                   "==== = = ==== ==== ===== ==== ===== ==== ======",
                   " ====== ===== =====\n" );
   form = "%4d %c %c %4d %4d %5.1f %4d %5.1f %4d %6.2f %6.1f %5.2f %5s\n";
#else
   if( ROUT == SYRK )
   {
      (void) fprintf( stdout, "\n%s%s%s\n",
                      "------------------------------------ ", "SYRK",
                      " ------------------------------------" );
      (void) fprintf( stdout, "%s%s",
                      "TST# U T    N    K rALPH iALPH  LDA rBETA iBETA",
                      "  LDC   TIME  MFLOP  SpUp  TEST\n" );
      (void) fprintf( stdout, "%s%s",
                      "==== = = ==== ==== ===== ===== ==== ===== =====",
                      " ==== ====== ====== ===== =====\n" );
      form =
    "%4d %c %c %4d %4d %5.1f %5.1f %4d %5.1f %5.1f %4d %6.2f %6.1f %5.2f %5s\n";
   }
   else
   {
      (void) fprintf( stdout, "\n%s%s%s\n",
                      "------------------------------ ", "HERK",
                      " ------------------------------" );
      (void) fprintf( stdout, "%s%s",
                      "TST# U T    N    K ALPHA  LDA  BETA",
                      "  LDC   TIME  MFLOP  SpUp  TEST\n" );
      (void) fprintf( stdout, "%s%s",
                      "==== = = ==== ==== ===== ==== =====",
                      " ==== ====== ====== ===== =====\n" );
      form = "%4d %c %c %4d %4d %5.1f %4d %5.1f %4d %6.2f %6.1f %5.2f %5s\n";
   }
#endif
   for( nn = N0; nn <= NN; nn += NINC )
   {
      n = nn; if( LDA_IS_M ) ldc = Mmax( 1, n ); else ldc = NN;

      for( kk = K0; kk <= KN; kk += KINC )
      {
         if( ksame ) { k = nn; } else { k = kk; }

         for( up = 0; up < NUPLO; up++ )
         {
            if( UPLOS[up] == AtlasUpper ) cuplo = 'U';
            else                          cuplo = 'L';

            for( ta = 0; ta < NTRAN; ta++ )
            {
#ifdef TREAL
               if( TRANS[ta] == AtlasNoTrans )
               { ctran = 'N'; if( LDA_IS_M ) lda = n; else lda = NN; }
               else
               { ctran = 'T'; if( LDA_IS_M ) lda = k; else lda = KN; }
#else
               if( ROUT == SYRK )
               {
                  if( TRANS[ta] == AtlasNoTrans )
                  { ctran = 'N'; if( LDA_IS_M ) lda = n; else lda = NN; }
                  else
                  { ctran = 'T'; if( LDA_IS_M ) lda = k; else lda = KN; }
               }
               else
               {
                  if( TRANS[ta] == AtlasNoTrans )
                  { ctran = 'N'; if( LDA_IS_M ) lda = n; else lda = NN; }
                  else
                  { ctran = 'C'; if( LDA_IS_M ) lda = k; else lda = KN; }
               } 
#endif
               for( al = 0; al < NALPHA; al++ )
               {
                  for( be = 0; be < NBETA; be++ )
                  {
                     int isam;
                     for (isam=0; isam < NSAMP; isam++)
                     {
#ifdef TREAL
                     ires = syrkcase( CACHESIZE, ROUT, TEST, MFLOP,
				      UPLOS[up], TRANS[ta],
                                      n, k, ALPHAS[al], lda, BETAS[be], ldc,
                                      EPSILON, &ttrust, &ttest, &mftrust,
                                      &mftest );
#else
                     ires = syrkcase( CACHESIZE, ROUT, TEST, MFLOP,
				      UPLOS[up], TRANS[ta],
                                      n, k, ALPHAS+2*al, lda, BETAS+2*be, ldc,
                                      EPSILON, &ttrust, &ttest, &mftrust,
                                      &mftest );
#endif
                     if(     !( TEST ) ) pass = "SKIP ";
                     else if( ires < 0 ) pass = "NoMEM";
                     else if( ires     ) pass = "PASS ";
                     else                pass = "FAIL ";
 
                     if( ires > 0 ) (*NPASSED)++;
 
                     if( ( mftrust > 0.0 ) && ( mftest > 0.0 ) )
                        t0 = mftest / mftrust;
                     else t0 = 0.0;
#ifdef TREAL
                     (void) fprintf( stdout, form, *NTESTS, cuplo, ctran, n, k,
                                     ALPHAS[al], lda, BETAS[be], ldc, ttrust,
                                     mftrust, 1.0, "-----" );
                     (void) fprintf( stdout, form, *NTESTS, cuplo, ctran, n, k,
                                     ALPHAS[al], lda, BETAS[be], ldc, ttest,
                                     mftest, t0, pass );
#else
                     if( ROUT == SYRK )
                     {
                        (void) fprintf( stdout, form, *NTESTS, cuplo, ctran,
                                        n, k, ALPHAS[2*al], ALPHAS[2*al+1],
                                        lda, BETAS [2*be], BETAS [2*be+1],
                                        ldc, ttrust, mftrust, 1.0, "-----" );
                        (void) fprintf( stdout, form, *NTESTS, cuplo, ctran,
                                        n, k, ALPHAS[2*al], ALPHAS[2*al+1],
                                        lda, BETAS [2*be], BETAS [2*be+1],
                                        ldc, ttest, mftest, t0, pass );
                     }
                     else
                     {
                        (void) fprintf( stdout, form, *NTESTS, cuplo, ctran,
                                        n, k, ALPHAS[2*al], lda, BETAS[2*be],
                                        ldc, ttrust, mftrust, 1.0, "-----" );
                        (void) fprintf( stdout, form, *NTESTS, cuplo, ctran,
                                        n, k, ALPHAS[2*al], lda, BETAS[2*be],
                                        ldc, ttest, mftest, t0, pass );
                     }
#endif
                     (*NTESTS)++;
                     }
                  }
               }
            }
         }
      }
   }
}

void RuntrxmCase
(
   const int                  CACHESIZE,
   const enum LVL3_ROUT       ROUT,
   const int                  TEST,
   const int                  MFLOP,
   const int                  LDA_IS_M,
   const int                  NSIDE,
   const enum ATLAS_SIDE      * SIDES,
   const int                  NUPLO,
   const enum ATLAS_UPLO      * UPLOS,
   const int                  NTRAN,
   const enum ATLAS_TRANS     * TRANS,
   const int                  NDIAG,
   const enum ATLAS_DIAG      * DIAGS,
   int                        M0,
   int                        MN,
   int                        MINC,
   int                        N0,
   int                        NN,
   int                        NINC,
   const int                  NALPHA,
   const TYPE                 * ALPHAS,
   const TYPE                 EPSILON,
   int                        * NPASSED,
   int                        * NTESTS
)
{
   double                     t0, mftrust, mftest, ttrust, ttest;
   char                       * pass, * form;
   int                        al, si, up, ta, di, ires, lda, ldb, m, mm,
                              msame=0, n, nn;
   char                       cside, ctran, cdiag, cuplo;

   if( M0 == -1 ) { msame = 1; M0 = MN = MINC = NN; }

#ifdef TREAL
   if( ROUT == TRMM )
      (void) fprintf( stdout, "\n%s%s%s\n",
                      "---------------------------", " TRMM ",
                      "----------------------------" );
   else 
      (void) fprintf( stdout, "\n%s%s%s\n",
                      "---------------------------", " TRSM ",
                      "----------------------------" );
   (void) fprintf( stdout, "%s%s",
                   "TST# S U T D    M    N ALPHA  LDA  LDB  TIME",
                   " MFLOP SpUp  TEST\n" );
   (void) fprintf( stdout, "%s%s",
                   "==== = = = = ==== ==== ===== ==== ==== =====",
                   " ===== ==== =====\n" );
   form = "%4d %c %c %c %c %4d %4d %5.1f %4d %4d %5.2f %5.1f %4.2f %5s\n";
#else
   if( ROUT == TRMM )
      (void) fprintf( stdout, "\n%s%s%s\n",
                      "------------------------------", " TRMM ",
                      "-------------------------------" );
   else 
      (void) fprintf( stdout, "\n%s%s%s\n",
                      "------------------------------", " TRSM ",
                      "-------------------------------" );
   (void) fprintf( stdout, "%s%s",
                   "TST# S U T D    M    N rALPH iALPH  LDA  LDB  TIME",
                   " MFLOP SpUp  TEST\n" );
   (void) fprintf( stdout, "%s%s",
                   "==== = = = = ==== ==== ===== ===== ==== ==== =====",
                   " ===== ==== =====\n" );
   form = "%4d %c %c %c %c %4d %4d %5.1f %5.1f %4d %4d %5.2f %5.1f %4.2f %5s\n";
#endif
   for( mm = M0; mm <= MN; mm += MINC )
   {
      for( nn = N0; nn <= NN; nn += NINC )
      {
         n = nn; if( msame ) { m = nn; } else { m = mm; }
         if( LDA_IS_M ) { ldb = Mmax( 1, m ); } else { ldb = MN; }

         for( si = 0; si < NSIDE; si++ )
         {
            if( SIDES[si] == AtlasLeft )
            { cside = 'L'; if( LDA_IS_M ) lda = Mmax( 1, m ); else lda = MN; }
            else
            { cside = 'R'; if( LDA_IS_M ) lda = Mmax( 1, n ); else lda = NN; }

            for( up = 0; up < NUPLO; up++ )
            {
               if( UPLOS[up] == AtlasUpper ) cuplo = 'U';
               else                          cuplo = 'L';
 
               for( ta = 0; ta < NTRAN; ta++ )
               {
                  if(      TRANS[ta] == AtlasNoTrans   ) ctran = 'N';
                  else if( TRANS[ta] == AtlasTrans     ) ctran = 'T';
                  else                                   ctran = 'C';
 
                  for( di = 0; di < NDIAG; di++ )
                  {
                     if( DIAGS[di] == AtlasUnit ) cdiag = 'U';
                     else                         cdiag = 'N';

                     for( al = 0; al < NALPHA; al++ )
                     {
                        int isam;
                        for (isam=0; isam < NSAMP; isam++)
                        {
#ifdef TREAL
                        ires = trxmcase( CACHESIZE, ROUT, TEST, MFLOP,
					 SIDES[si],
                                         UPLOS[up], TRANS[ta], DIAGS[di],
                                         m, n, ALPHAS[al], lda, ldb, EPSILON,
                                         &ttrust, &ttest, &mftrust, &mftest );
#else
                        ires = trxmcase( CACHESIZE, ROUT, TEST, MFLOP,
					 SIDES[si],
                                         UPLOS[up], TRANS[ta], DIAGS[di],
                                         m, n, ALPHAS+2*al, lda, ldb, EPSILON,
                                         &ttrust, &ttest, &mftrust, &mftest );
#endif
                        if(     !( TEST ) ) pass = "SKIP ";
                        else if( ires < 0 ) pass = "NoMEM";
                        else if( ires     ) pass = "PASS ";
                        else                pass = "FAIL ";
 
                        if( ires > 0 ) (*NPASSED)++;
 
                        if( ( mftrust > 0.0 ) && ( mftest > 0.0 ) )
                           t0 = mftest / mftrust;
                        else t0 = 0.0;
#ifdef TREAL 
                        (void) fprintf( stdout, form, *NTESTS, cside, cuplo,
                                        ctran, cdiag, m, n, ALPHAS[al], lda,
                                        ldb, ttrust, mftrust, 1.0, "-----" );
                        (void) fprintf( stdout, form, *NTESTS, cside, cuplo,
                                        ctran, cdiag, m, n, ALPHAS[al], lda,
                                        ldb, ttest, mftest,  t0,  pass   );
#else
                        (void) fprintf( stdout, form, *NTESTS, cside, cuplo,
                                        ctran, cdiag, m, n, ALPHAS[2*al],
                                        ALPHAS[2*al+1], lda, ldb, ttrust,
                                        mftrust, 1.0, "-----" );
                        (void) fprintf( stdout, form, *NTESTS, cside, cuplo,
                                        ctran, cdiag, m, n, ALPHAS[2*al],
                                        ALPHAS[2*al+1], lda, ldb, ttest,
                                        mftest,  t0,  pass    );
#endif
                        (*NTESTS)++;
                        }
                     }
                  }
               }
            }
         }
      }
   }
}

void RunCases
(
   const int                  TEST,
   const int                  CACHESIZE,
   const int                  MFLOP,
   const int                  LDA_IS_M,
   const int                  NSIDE,
   const enum ATLAS_SIDE      * SIDES,
   const int                  NUPLO,
   const enum ATLAS_UPLO      * UPLOS,
   const int                  NTRANA,
   const enum ATLAS_TRANS     * TRANSA,
   const int                  NTRANB,
   const enum ATLAS_TRANS     * TRANSB,
   const int                  NDIAG,
   const enum ATLAS_DIAG      * DIAGS,
   const int                  M0,
   const int                  MN,
   const int                  MINC,
   const int                  N0,
   const int                  NN,
   const int                  NINC,
   const int                  K0,
   const int                  KN,
   const int                  KINC,
   const int                  NALPHA,
   const TYPE                 * ALPHAS,
   const int                  NBETA,
   const TYPE                 * BETAS,
   const int                  NROUT,
   const enum LVL3_ROUT       * ROUTS
)
{
   TYPE                       eps;
   int                        ro, ntests=0, np=0;

   eps = Mjoin( PATL, epsilon )();

   for( ro = 0; ro < NROUT; ro++ )
   {
      if(      ROUTS[ro] == GEMM  )
      {
         RungemmCase( CACHESIZE, ROUTS[ro], TEST, MFLOP, LDA_IS_M, NTRANA,
		      TRANSA, NTRANB,
                      TRANSB, M0, MN, MINC, N0, NN, NINC, K0, KN, KINC, NALPHA,
                      ALPHAS, NBETA, BETAS, eps, &np, &ntests );
      }
#ifdef TREAL
      else if(   ROUTS[ro] == SYMM )
#else
      else if( ( ROUTS[ro] == SYMM ) || ( ROUTS[ro] == HEMM ) )
#endif
      {
         RunsymmCase( CACHESIZE, ROUTS[ro], TEST, MFLOP, LDA_IS_M, NSIDE,
		      SIDES, NUPLO,
                      UPLOS, M0, MN, MINC, N0, NN, NINC, NALPHA, ALPHAS, NBETA,
                      BETAS, eps, &np, &ntests );
      }
#ifdef TREAL
      else if(   ROUTS[ro] == SYRK )
#else
      else if( ( ROUTS[ro] == SYRK ) || ( ROUTS[ro] == HERK ) )
#endif
      {
         RunsyrkCase( CACHESIZE, ROUTS[ro], TEST, MFLOP, LDA_IS_M, NUPLO,
		      UPLOS, NTRANA,
                      TRANSA, N0, NN, NINC, K0, KN, KINC, NALPHA, ALPHAS, NBETA,
                      BETAS, eps, &np, &ntests ); 
      }
#ifdef TREAL
      else if(   ROUTS[ro] == SYR2K )
#else
      else if( ( ROUTS[ro] == SYR2K ) || ( ROUTS[ro] == HER2K ) )
#endif
      {
         Runsyr2kCase( CACHESIZE, ROUTS[ro], TEST, MFLOP, LDA_IS_M, NUPLO,
		       UPLOS, NTRANA,
                       TRANSA, N0, NN, NINC, K0, KN, KINC, NALPHA, ALPHAS,
                       NBETA, BETAS, eps, &np, &ntests );
      }
      else if( ( ROUTS[ro] == TRMM ) || ( ROUTS[ro] == TRSM ) )
      {
         RuntrxmCase( CACHESIZE, ROUTS[ro], TEST, MFLOP, LDA_IS_M, NSIDE,
		      SIDES, NUPLO,
                      UPLOS, NTRANA, TRANSA, NDIAG, DIAGS, M0, MN, MINC, N0,
                      NN, NINC, NALPHA, ALPHAS, eps, &np, &ntests );
      }
   }

   if( TEST )
      (void) fprintf( stdout, "\n%d tests run, %d passed\n\n", ntests, np );
   else
      (void) fprintf( stdout, "\n%d tests run, all skipped\n\n", ntests );
}
/*
 * =====================================================================
 * Main functions
 * =====================================================================
 */
void PrintUsage( char * nam )
{
   (void) fprintf( stderr, "ATLAS usage:\n" );
   (void) fprintf( stderr, "    %s [-options ...]\n\n", nam );
   (void) fprintf( stderr, "where options include:\n" );

   (void) fprintf( stderr, "   -h                                  " );
   (void) fprintf( stderr, ". print this message                    \n" );

   (void) fprintf( stderr, "   -R <rout>                           " );
   (void) fprintf( stderr, ". select  one  or all routines to test. \n" );
   (void) fprintf( stderr, "                                       " );
#ifdef TREAL
   (void) fprintf( stderr, "  rout must be in {all, gemm,symm,syrk, \n" );
   (void) fprintf( stderr, "                                       " );
   (void) fprintf( stderr, "  syr2k,trmm,trsm}.                     \n" );
#else
   (void) fprintf( stderr, "  rout must be in {all, gemm,hemm,herk, \n" );
   (void) fprintf( stderr, "                                       " );
   (void) fprintf( stderr, "  her2k,symm,syr2k,syrk,trmm,trsm}.     \n" );
#endif
   (void) fprintf( stderr, "                                       " );
   (void) fprintf( stderr, "  Default: -R gemm.  Ex: -R trmm        \n" );

   (void) fprintf( stderr, "   -R <nrout> <rout1> ... <routN>      " );
   (void) fprintf( stderr, ". same as above for more than one rout- \n" );
   (void) fprintf( stderr, "                                       " );
   (void) fprintf( stderr, "  tine. Ex: -R 3 genn trmm symm         \n" );

   (void) fprintf( stderr, "   -S <nside>  L/R                     " );
   (void) fprintf( stderr, ". select values for the SIDE parameter. \n" );
   (void) fprintf( stderr, "                                       " );
   (void) fprintf( stderr, "  Default: -S 1 L. Ex: -S 2 L R         \n" );

   (void) fprintf( stderr, "   -U <nuplo>  L/U                     " );
   (void) fprintf( stderr, ". select values for the UPLO parameter. \n" );
   (void) fprintf( stderr, "                                       " );
   (void) fprintf( stderr, "  Default: -U 1 L. Ex: -U 2 L U         \n" );

   (void) fprintf( stderr, "   -A <ntrans> N/T/C                   " );
   (void) fprintf( stderr, ". select values of the TRANSA parameter.\n" );
   (void) fprintf( stderr, "                                       " );
   (void) fprintf( stderr, "  Default: -A 1 n. Ex: -A 2 N T         \n" );

   (void) fprintf( stderr, "   -B <ntrans> N/T/C                   " );
   (void) fprintf( stderr, ". select values of the TRANSB parameter.\n" );
   (void) fprintf( stderr, "                                       " );
   (void) fprintf( stderr, "  Default: -B 1 N. Ex: -B 2 N T         \n" );

   (void) fprintf( stderr, "   -D <ndiags> N/U                     " );
   (void) fprintf( stderr, ". select values for the DIAG parameter. \n" );
   (void) fprintf( stderr, "                                       " );
   (void) fprintf( stderr, "  Default: -D 1 N. Ex: -Diag 2 N U      \n" );

   (void) fprintf( stderr, "   -m <m>                              " );
   (void) fprintf( stderr, ". select one value for the parameter M. \n" );
   (void) fprintf( stderr, "                                       " );
   (void) fprintf( stderr, "  Ex: -m 100                            \n" );

   (void) fprintf( stderr, "   -n <n>                              " );
   (void) fprintf( stderr, ". same as above for the parameter N.    \n" );
 
   (void) fprintf( stderr, "   -k <k>                              " );
   (void) fprintf( stderr, ". same as above for the parameter K.    \n" );

   (void) fprintf( stderr, "   -M <m1>  <mN>  <minc>               " );
   (void) fprintf( stderr, ". select the values of M, from m1 to mN \n" );
   (void) fprintf( stderr, "                                       " );
   (void) fprintf( stderr, "  by increment of minc. m1 > 0.         \n" );
   (void) fprintf( stderr, "                                       " );
   (void) fprintf( stderr, "  Ex: -M 100 1000 100                   \n" );

   (void) fprintf( stderr, "   -N <n1>  <nN>  <ninc>               " );
   (void) fprintf( stderr, ". same as above for the values of N.    \n" );

   (void) fprintf( stderr, "   -K <k1>  <kN>  <kinc>               " );
   (void) fprintf( stderr, ". same as above for the values of K.    \n" );

#ifdef TREAL
   (void) fprintf( stderr, "   -a <nalphas> <a1> ... <aN>          " );
   (void) fprintf( stderr, ". select the values of ALPHA.  Default: \n" );
   (void) fprintf( stderr, "                                       " );
   (void) fprintf( stderr, "  -a 1 1.0. Ex: -a 3 -1.0 0.0 1.0       \n" );
   (void) fprintf( stderr, "   -b <nbetas>  <beta1>  ... <betaN>   " );
   (void) fprintf( stderr, ". same as above for the parameter BETA. \n" );
#else
   (void) fprintf( stderr, "   -a <nalphas> <a1r> <a1i> ... <aNi>  " );
   (void) fprintf( stderr, ". select the values of ALPHA, where a1r \n" );
   (void) fprintf( stderr, "                                       " );
   (void) fprintf( stderr, "  and  a1i  are the  real and imaginary \n" );
   (void) fprintf( stderr, "                                       " );
   (void) fprintf( stderr, "  parts of a1. Default: -a 1 1.0 0.0    \n" );
   (void) fprintf( stderr, "   -b <nbetas>  <b1r> <b1i> ... <bNi>  " );
   (void) fprintf( stderr, ". same as above for the parameter BETA. \n" );
#endif

   (void) fprintf( stderr, "   -d                                  " );
   (void) fprintf( stderr, ". use smallest possible leading  dimen- \n" );
   (void) fprintf( stderr, "                                       " );
   (void) fprintf( stderr, "  sion for the array A.                 \n" );
   (void) fprintf( stderr, "                                       " );
   (void) fprintf( stderr, "  Default: max( mN, nN, kN ).           \n" );

   (void) fprintf( stderr, "   -T <0/1>                            " );
   (void) fprintf( stderr, ". disable/enable computational check.   \n" );
   (void) fprintf( stderr, "                                       " );
   (void) fprintf( stderr, "  Default: -T 1                         \n" );

   (void) fprintf( stderr, "   -F <mflops>                         " );
   (void) fprintf( stderr, ". perform at least mflops per measure.  \n" );

   (void) fprintf( stderr, "   -C <CacheSize>                       " );
   (void) fprintf( stderr, ". select how much memory in kilobytes\n" );
   (void) fprintf( stderr, "                                        " );
   (void) fprintf( stderr, "  to flush to clear the caches. Put 1\n" );
   (void) fprintf( stderr, "                                        " );
   (void) fprintf( stderr, "  for no cache flushing. Default is the\n" );
   (void) fprintf( stderr, "                                        " );
   (void) fprintf( stderr, "  size of the biggest cache.\n" );

   (void) fprintf( stderr, "\n" );
   exit( -1 );
}

void GetFlags
(
   int                        NARGS,
   char                       * ARGS[], 
   int                        * NROUT,
   enum LVL3_ROUT             ** ROUTS,
   int                        * TEST,
   int                        * LDA_IS_M,
   int                        * CACHESIZE,
   int                        * MFLOP,
   int                        * NSIDE,
   enum ATLAS_SIDE            ** SIDES, 
   int                        * NUPLO,
   enum ATLAS_UPLO            ** UPLOS, 
   int                        * NTRANA,
   enum ATLAS_TRANS           ** TRANSA, 
   int                        * NTRANB,
   enum ATLAS_TRANS           ** TRANSB, 
   int                        * NDIAG,
   enum ATLAS_DIAG            ** DIAGS, 
   int                        * M0,
   int                        * MN,
   int                        * MINC,
   int                        * N0,
   int                        * NN,
   int                        * NINC, 
   int                        * K0,
   int                        * KN,
   int                        * KINC,
   int                        * NALPHA,
   TYPE                       ** ALPHAS, 
   int                        * NBETA,
   TYPE                       ** BETAS
)
{
   char                       ch;
   int                        i = 1, j;
/*
 * Set up defaults
 */
   *NROUT    = -1;                         /* No routine to be tested */
   *TEST     = 1;                               /* Enable the testing */
   *LDA_IS_M = 0;    /* Leading dimension chosen as max testing value */
   *MFLOP    = 0;                /* smallest number of flops possible */
                                            /* Default bandwidth is 1 */
#ifdef L2SIZE
   *CACHESIZE = L2SIZE;             /* Size of largest cache to flush */
#else
   *CACHESIZE = 4*1024*1024;
#endif

   *NSIDE  = *NUPLO = *NTRANA = *NTRANB = *NDIAG = -1;
   *M0     = *N0    = *K0     = -1;
   *NALPHA = *NBETA = -1;

   fprintf(stdout, "\n\n");
   for (i=0; i < NARGS; i++) fprintf(stdout, "%s ", ARGS[i]);
   fprintf(stdout, "\n\n");
   for( i = 1; i < NARGS; )
   {
      if( ARGS[i][0] != '-' ) PrintUsage( ARGS[0] );

      switch( ARGS[i++][1] )
      {
         case 'h':
            PrintUsage( ARGS[0] );
            break; 
         case 'T':
            if( ARGS[i] == NULL ) PrintUsage( ARGS[0] );
            *TEST = atoi( ARGS[i++] );
            break;
         case 'd':
            *LDA_IS_M = 1;
            break;
         case '#':
            if( ARGS[i] == NULL ) PrintUsage( ARGS[0] );
            NSAMP = atoi( ARGS[i++] );
            if( NSAMP < 0      ) PrintUsage( ARGS[0] );
            break;
         case 'F':
            if( ARGS[i] == NULL ) PrintUsage( ARGS[0] );
            *MFLOP = atoi( ARGS[i++] );
            if( *MFLOP < 0      ) PrintUsage( ARGS[0] );
            break;
         case 'C':
            if( ARGS[i] == NULL ) PrintUsage( ARGS[0] );
	    *CACHESIZE = 1024*atoi(ARGS[i++]);
            break;
         case 'S':
            if( ARGS[i] == NULL ) PrintUsage( ARGS[0] );
            *NSIDE = atoi( ARGS[i++] );
            if( *NSIDE <= 0     ) PrintUsage( ARGS[0] );
            *SIDES = (enum ATLAS_SIDE *)malloc( *NSIDE *
                                                sizeof( enum ATLAS_SIDE ) );
            ATL_assert( *SIDES );
            for( j = 0; j != *NSIDE; j++)
            {
               if( ARGS[i] == NULL ) PrintUsage( ARGS[0] );
               ch = *ARGS[i++];
               if(      ch == 'l' || ch == 'L' ) (*SIDES)[j] = AtlasLeft;
               else if( ch == 'r' || ch == 'R' ) (*SIDES)[j] = AtlasRight;
               else PrintUsage( ARGS[0] );
            }
            break;
         case 'U':
            if( ARGS[i] == NULL ) PrintUsage( ARGS[0] );
            *NUPLO = atoi( ARGS[i++] );
            if( *NUPLO <= 0     ) PrintUsage( ARGS[0] );
            *UPLOS = (enum ATLAS_UPLO *)malloc( *NUPLO *
                                                sizeof( enum ATLAS_UPLO ) );
            ATL_assert( *UPLOS );
            for( j = 0; j != *NUPLO; j++)
            {
               if( ARGS[i] == NULL ) PrintUsage( ARGS[0] );
               ch = *ARGS[i++];
               if(      ch == 'u' || ch == 'U' ) (*UPLOS)[j] = AtlasUpper;
               else if( ch == 'l' || ch == 'L' ) (*UPLOS)[j] = AtlasLower;
               else PrintUsage( ARGS[0] );
            }
            break;
         case 'A':
            if( ARGS[i] == NULL ) PrintUsage( ARGS[0] );
            *NTRANA = atoi(ARGS[i++]);
            if( *NTRANA <= 0    ) PrintUsage( ARGS[0] );
            *TRANSA = (enum ATLAS_TRANS *)malloc( *NTRANA *
                                                  sizeof( enum ATLAS_TRANS ) );
            ATL_assert( *TRANSA );
            for( j = 0; j != *NTRANA; j++ )
            {
               if( ARGS[i] == NULL ) PrintUsage( ARGS[0] );
               ch = *ARGS[i++];
               if(      ch == 'n' || ch == 'N' ) (*TRANSA)[j] = AtlasNoTrans;
               else if( ch == 't' || ch == 'T' ) (*TRANSA)[j] = AtlasTrans;
               else if( ch == 'c' || ch == 'C' ) (*TRANSA)[j] = AtlasConjTrans;
               else PrintUsage( ARGS[0] );
            }
            break;
         case 'B':
            if( ARGS[i] == NULL ) PrintUsage( ARGS[0] );
            *NTRANB = atoi(ARGS[i++]);
            if( *NTRANB <= 0    ) PrintUsage( ARGS[0] );
            *TRANSB = (enum ATLAS_TRANS *)malloc( *NTRANB *
                                                  sizeof( enum ATLAS_TRANS ) );
            ATL_assert( *TRANSB );
            for( j = 0; j != *NTRANB; j++ )
            {
               if( ARGS[i] == NULL ) PrintUsage( ARGS[0] );
               ch = *ARGS[i++];
               if(      ch == 'n' || ch == 'N' ) (*TRANSB)[j] = AtlasNoTrans;
               else if( ch == 't' || ch == 'T' ) (*TRANSB)[j] = AtlasTrans;
               else if( ch == 'c' || ch == 'C' ) (*TRANSB)[j] = AtlasConjTrans;
               else PrintUsage( ARGS[0] );
            }
            break;
         case 'D':
            if( ARGS[i] == NULL ) PrintUsage( ARGS[0] );
            *NDIAG = atoi( ARGS[i++] );
            if( *NDIAG <= 0     ) PrintUsage( ARGS[0] );
            *DIAGS = (enum ATLAS_DIAG *)malloc( *NDIAG * 
                                                sizeof( enum ATLAS_DIAG ) );
            ATL_assert( *DIAGS );
            for( j = 0; j != *NDIAG; j++ )
            {
               if( ARGS[i] == NULL ) PrintUsage( ARGS[0] );
               ch = *ARGS[i++];
               if(      ch == 'u' || ch == 'U' ) (*DIAGS)[j] = AtlasUnit;
               else if( ch == 'n' || ch == 'N' ) (*DIAGS)[j] = AtlasNonUnit;
               else PrintUsage( ARGS[0] );
            }
            break;

         case 'M':
            if( ARGS[i] == NULL ) PrintUsage( ARGS[0] );
            *M0 = atoi( ARGS[i++] );
            if( *M0 < 0         ) PrintUsage( ARGS[0] );
            if( ARGS[i] == NULL ) PrintUsage( ARGS[0] );
            *MN = atoi( ARGS[i++] );
            if( *MN < 0         ) PrintUsage( ARGS[0] );
            if( ARGS[i] == NULL ) PrintUsage( ARGS[0] );
            *MINC = atoi( ARGS[i++] );
            if( *MINC <= 0      ) PrintUsage( ARGS[0] );
            break;
         case 'm':
            if( ARGS[i] == NULL ) PrintUsage( ARGS[0] );
            *M0 = *MN = atoi( ARGS[i++] ); *MINC = 1;
            if( *M0 <= 0        ) PrintUsage( ARGS[0] );
            break;
         case 'N':
            if( ARGS[i] == NULL ) PrintUsage( ARGS[0] );
            *N0 = atoi( ARGS[i++] );
            if( *N0 < 0         ) PrintUsage( ARGS[0] );
            if( ARGS[i] == NULL ) PrintUsage( ARGS[0] );
            *NN = atoi( ARGS[i++] );
            if( *NN < 0         ) PrintUsage( ARGS[0] );
            if( ARGS[i] == NULL ) PrintUsage( ARGS[0] );
            *NINC = atoi( ARGS[i++] );
            if( *NINC <= 0      ) PrintUsage( ARGS[0] );
            break;
         case 'n':
            if( ARGS[i] == NULL ) PrintUsage( ARGS[0] );
            *N0 = *NN = atoi( ARGS[i++] ); *NINC = 1;
            if( *N0 < 0         ) PrintUsage( ARGS[0] );
            break;
         case 'K':
            if( ARGS[i] == NULL ) PrintUsage( ARGS[0] );
            *K0 = atoi( ARGS[i++] );
            if( *K0 < 0         ) PrintUsage( ARGS[0] );
            if( ARGS[i] == NULL ) PrintUsage( ARGS[0] );
            *KN = atoi( ARGS[i++] );
            if( *KN < 0         ) PrintUsage( ARGS[0] );
            if( ARGS[i] == NULL ) PrintUsage( ARGS[0] );
            *KINC = atoi( ARGS[i++] );
            if( *KINC <= 0      ) PrintUsage( ARGS[0] );
            break;
         case 'k':
            if( ARGS[i] == NULL ) PrintUsage( ARGS[0] );
            *K0 = *KN = atoi( ARGS[i++] ); *KINC = 1;
            if( *K0 < 0         ) PrintUsage( ARGS[0] );
            break;

         case 'a':
            if( ARGS[i] == NULL ) PrintUsage( ARGS[0] );
            *NALPHA = atoi( ARGS[i++] );
            if( *NALPHA <= 0    ) PrintUsage( ARGS[0] );
            *ALPHAS = (TYPE *)malloc( ATL_MulBySize( *NALPHA ) );
            ATL_assert( *ALPHAS );
            for( j = 0; j < (*NALPHA SHIFT); j++ )
            {
               if( ARGS[i] == NULL ) PrintUsage( ARGS[0] );
               (*ALPHAS)[j] = (TYPE)atof( ARGS[i++] );
            }
            break;
         case 'b':
            if( ARGS[i] == NULL ) PrintUsage( ARGS[0] );
            *NBETA  = atoi( ARGS[i++] );
            if( *NBETA <= 0     ) PrintUsage( ARGS[0] );
            *BETAS  = (TYPE *)malloc( ATL_MulBySize( *NBETA ) );
            ATL_assert( *BETAS );
            for( j = 0; j < (*NBETA SHIFT); j++ )
            {
               if( ARGS[i] == NULL ) PrintUsage( ARGS[0] );
               (*BETAS)[j] = (TYPE)atof( ARGS[i++] );
            }
            break;

         case 'R':
            if( ARGS[i] == NULL ) PrintUsage( ARGS[0] );

            if( ( strcmp( ARGS[i], "ALL"  ) == 0 ) ||
                ( strcmp( ARGS[i], "all"  ) == 0 ) )
            {
#ifdef TREAL
               *NROUT = 6;
#else
               *NROUT = 9;
#endif
               *ROUTS = (enum LVL3_ROUT *)malloc( (*NROUT) * 
                                                  sizeof( enum LVL3_ROUT ) );
               ATL_assert( *ROUTS );

               (*ROUTS)[ 0] = GEMM; (*ROUTS)[ 1] = SYMM; (*ROUTS)[ 2] = SYR2K; 
               (*ROUTS)[ 3] = SYRK; (*ROUTS)[ 4] = TRMM; (*ROUTS)[ 5] = TRSM; 
#ifdef TCPLX
               (*ROUTS)[ 6] = HEMM; (*ROUTS)[ 7] = HERK; (*ROUTS)[ 8] = HER2K;
#endif
               i++;
            }
            else
            {
               if( isdigit( *ARGS[i] ) ) { *NROUT = atoi( ARGS[i++] ); }
               else                      { *NROUT = 1;                 }
               *ROUTS = (enum LVL3_ROUT *)malloc( (*NROUT) * 
                                                  sizeof( enum LVL3_ROUT ) );
               ATL_assert( *ROUTS );

               for( j = 0; j < *NROUT; j++ )
               {
                  if( ARGS[i] == NULL ) PrintUsage( ARGS[0] );

                  if(      ( strcmp( ARGS[i], "GEMM"  ) == 0 ) ||
                           ( strcmp( ARGS[i], "gemm"  ) == 0 ) )
                     (*ROUTS)[j] = GEMM;
                  else if( ( strcmp( ARGS[i], "SYMM"  ) == 0 ) ||
                           ( strcmp( ARGS[i], "symm"  ) == 0 ) )
                     (*ROUTS)[j] = SYMM;
                  else if( ( strcmp( ARGS[i], "SYR2K" ) == 0 ) ||
                           ( strcmp( ARGS[i], "syr2k" ) == 0 ) )
                     (*ROUTS)[j] = SYR2K;
                  else if( ( strcmp( ARGS[i], "SYRK"  ) == 0 ) ||
                           ( strcmp( ARGS[i], "syrk"  ) == 0 ) )
                     (*ROUTS)[j] = SYRK;
                  else if( ( strcmp( ARGS[i], "TRMM"  ) == 0 ) ||
                           ( strcmp( ARGS[i], "trmm"  ) == 0 ) )
                     (*ROUTS)[j] = TRMM;
                  else if( ( strcmp( ARGS[i], "TRSM"  ) == 0 ) ||
                           ( strcmp( ARGS[i], "trsm"  ) == 0 ) )
                     (*ROUTS)[j] = TRSM;
#ifdef TCPLX
                  else if( ( strcmp( ARGS[i], "HEMM"  ) == 0 ) ||
                           ( strcmp( ARGS[i], "hemm"  ) == 0 ) )
                     (*ROUTS)[j] = HEMM;
                  else if( ( strcmp( ARGS[i], "HER2K" ) == 0 ) ||
                           ( strcmp( ARGS[i], "her2k" ) == 0 ) )
                     (*ROUTS)[j] = HER2K;
                  else if( ( strcmp( ARGS[i], "HERK"  ) == 0 ) ||
                           ( strcmp( ARGS[i], "herk"  ) == 0 ) )
                     (*ROUTS)[j] = HERK;
#endif
                  else PrintUsage( ARGS[0] );
                  i++;
               } 
            } 
            break;
         default:
            PrintUsage( ARGS[0] );
            break;
      }
   }
/*
 * Finish setting up defaults if the user has not selected
 */
   if( *NROUT == -1 )
   {
      *NROUT = 1;
      *ROUTS = (enum LVL3_ROUT *)malloc( sizeof( enum LVL3_ROUT ) );
      ATL_assert( *ROUTS );
      (*ROUTS)[0] = GEMM;
   }

   if( *NSIDE == -1 )
   {
      *NSIDE = 1;
      *SIDES = (enum ATLAS_SIDE *)malloc( sizeof( enum ATLAS_SIDE ) );
      ATL_assert( *SIDES );
      (*SIDES)[0] = AtlasLeft;
   }
   if( *NUPLO == -1 )
   {
      *NUPLO = 1;
      *UPLOS = (enum ATLAS_UPLO *)malloc( sizeof( enum ATLAS_UPLO ) );
      ATL_assert( *UPLOS );
      (*UPLOS)[0] = AtlasLower;
   }
   if( *NTRANA == -1 )
   {
      *NTRANA = 1;
      *TRANSA = (enum ATLAS_TRANS *)malloc( sizeof( enum ATLAS_TRANS ) );
      ATL_assert( *TRANSA );
      (*TRANSA)[0] = AtlasNoTrans;
   }
   if( *NTRANB == -1 )
   {
      *NTRANB = 1;
      *TRANSB = (enum ATLAS_TRANS *)malloc( sizeof( enum ATLAS_TRANS ) );
      ATL_assert( *TRANSB );
      (*TRANSB)[0] = AtlasNoTrans;
   }
   if( *NDIAG == -1 )
   {
      *NDIAG = 1;
      *DIAGS = (enum ATLAS_DIAG *)malloc( sizeof( enum ATLAS_DIAG ) );
      ATL_assert( *DIAGS );
      (*DIAGS)[0] = AtlasNonUnit;
   }

   if( *N0 == -1 ) { *N0 = 100; *NN = 1000; *NINC = 100; }

   if( *NALPHA == -1 )
   {
      *NALPHA = 1;
      *ALPHAS = (TYPE *)malloc( ATL_MulBySize( 1 ) );
      ATL_assert( *ALPHAS );
#ifdef TREAL
      (*ALPHAS)[0] = ATL_rone;
#else
      (*ALPHAS)[0] = ATL_rone;
      (*ALPHAS)[1] = ATL_rzero;
#endif
   }
   if( *NBETA == -1 )
   {
      *NBETA = 1;
      *BETAS = (TYPE *)malloc( ATL_MulBySize( 1 ) );
      ATL_assert( *BETAS );
#ifdef TREAL
      (*BETAS)[0] = ATL_rone;
#else
      (*BETAS)[0] = ATL_rone;
      (*BETAS)[1] = ATL_rzero;
#endif
   }
}

int main( int NARGS, char **ARGS )
{
   int                        kinc, kstart, kstop, ldaism, mflopmin, minc,
                              mstart, mstop, ninc, nstart, nstop, nalpha,
                              nbeta, ndiag, nrout, nside, ntrana, ntranb,
                              nuplo, test, cachesize;

   TYPE                       * alphas = NULL, * betas = NULL;
   enum LVL3_ROUT             * routs  = NULL;
   enum ATLAS_SIDE            * sides  = NULL;
   enum ATLAS_UPLO            * uplos  = NULL;
   enum ATLAS_TRANS           * transa = NULL, * transb = NULL;
   enum ATLAS_DIAG            * diags  = NULL;
 
   GetFlags( NARGS, ARGS, &nrout, &routs, &test, &ldaism, &cachesize,
	     &mflopmin, &nside, &sides, &nuplo, &uplos, &ntrana,
	     &transa, &ntranb, &transb, &ndiag, &diags, &mstart, &mstop,
	     &minc, &nstart, &nstop, &ninc, &kstart, &kstop, &kinc,
	     &nalpha, &alphas, &nbeta, &betas );
   RunCases( test, cachesize, mflopmin, ldaism, nside, sides, nuplo, uplos,
	     ntrana, transa, ntranb, transb, ndiag, diags, mstart,
	     mstop, minc, nstart, nstop, ninc, kstart, kstop, kinc,
	     nalpha, alphas, nbeta, betas, nrout, routs );
 
   if( sides  ) free( sides  );
   if( uplos  ) free( uplos  );
   if( transa ) free( transa );
   if( transb ) free( transb );
   if( diags  ) free( diags  );
   if( alphas ) free( alphas );
   if( betas  ) free( betas  );
   if( routs  ) free( routs  );
 
   return( 0 );
} 
@ROUT l3time
void PrintUsage(char*, int, char*);
#define ATL_GETFLAGS 1
#include "atlas_genparse.h"

#ifdef TCPLX
   #define NBLAS 9
#else
   #define NBLAS 6
#endif
enum eblas {Bgemm, Bsymm, Bsyrk, Bsyr2k, Btrmm, Btrsm, Bhemm, Bherk, Bher2k};
char *nblas[]={"gemm", "symm", "syrk", "syr2k", "trmm", "trsm", "hemm", 
              "herk", "her2k"};

void DoTiming(int nreps, int flszKB, int MFF, int ldaG, int ldbG, int ldcG,
              int ibl, int SD, int UP, int DI, int TA, int TB,
              const SCALAR alpha, const SCALAR beta, int M, int N, int K,
              double *time, double *mflop)
{
   *time = *mflop = 0.0;
   flszKB *= 1024;
   switch(ibl)
   {
      double dtmp;
      int lda, ldb, ldc, ib=0;
   case Bgemm:
      lda = ldaG + (TA == AtlasNoTrans) ? M : K;
      ldb = ldbG + (TB == AtlasNoTrans) ? K : N;
      gemmcase(flszKB, 0, 0, MFF, TA, TB, M, N, K, alpha, lda, ldb, beta,
               M+ldcG, 0.0, time, &dtmp, mflop, &dtmp);
      break;
   case Bhemm:
   case Bsymm:
      ib = (ibl==Bsymm)?SYMM:1;
      lda = ldaG + (SD == AtlasLeft) ? M : N;
      symmcase(flszKB, ib, 0, MFF, SD, UP, M, N, alpha, lda, M+ldbG, beta,
               M+ldcG, 0.0, time, &dtmp, mflop, &dtmp);
      break;
   case Bherk:
   case Bsyrk:
      ib = (ibl==Bsyrk)?SYRK:2;
      lda = ldaG + (TA == AtlasNoTrans) ? N : K;
      syrkcase(flszKB, ib, 0, MFF, UP, TA, N, K, alpha, lda, beta, M+ldcG, 0.0,
               time, &dtmp, mflop, &dtmp);
      break;
   case Bher2k:
   case Bsyr2k:
      ib = (ibl==Bsyr2k)?SYR2K:3;
      lda = ldaG + (TA == AtlasNoTrans) ? N : K;
      ldb = ldbG + (TA == AtlasNoTrans) ? N : K;
      syr2kcase(flszKB, ib, 0, MFF, UP, TA, N, K, alpha, lda, ldb, beta,
                N+ldcG, 0.0, time, &dtmp, mflop, &dtmp);
      break;
   case Btrmm:
   case Btrsm:
      ib = (ibl==Btrsm)?TRSM:TRMM;
      lda = ldaG + (SD == AtlasLeft) ? M : N;
      trxmcase(flszKB, ib, 0, MFF, SD, UP, TA, DI, M, N,
               alpha, lda, M+ldbG, 0.0, time, &dtmp, mflop, &dtmp);
      break;
   }
}

void RunAllTimings(int nreps, int flszKB, int MFF, int ldaG, int ldbG, int ldcG,
                   int *ROUTs, int *SDs, int *UPs, int *DIs, int *TAs, int *TBs,
                   int nalp, TYPE *alps, int nbet, TYPE *bets, 
                   int *Ms, int *Ns, int *Ks)
{
   const int nrt = ROUTs[0];
   const char *frm="%6d  %c  %c  %c  %c  %c  %c  %c %7d %7d %7d  %12e %12.1f\n";
   int ir, it=0;

   for (ir=1; ir <= nrt; ir++)
   {
      const int nm = Ms[0];
      int rt = ROUTs[ir], im;
      const int HAS_SD = (rt==Bsymm || rt==Bhemm || rt==Btrmm || rt==Btrsm);
      const int HAS_UP = (rt==Bsyr2k || rt==Bher2k || rt==Bsyrk || rt==Bherk ||
                          rt==Btrmm || rt==Btrsm);
      const int HAS_DI = (rt==Btrmm || rt==Btrsm);
      const int HAS_TA = (rt != Bsymm && rt != Bhemm);
      const int HAS_TB = (rt == Bgemm);
      char cTA='-', cTB='-', cSD='-', cUP='-', cDI='-';

@skip      printf("\n               ************************************\n");
      printf("\n               ********  TIMING FOR %s%-5s ********\n", 
             Mstr(PRE), nblas[rt]);
@skip      printf("               ************************************\n");
      printf("  TEST SD UP DI TA TB AL BE  "
             "     M       N       K          Time        MFLOP\n");
      printf("====== == == == == == == ==  "
             "======  ======  ======  ============  ===========\n");
      for (im=1; im <= nm; im++)
      {
         const int nn=Ns[0];
         int in;
         for (in=1; in <= nn; in++)
         {
            const int nk = Ks[0];
            const int N = Ns[in], M = (Ms[im]) ? Ms[im] : N;
            int ik;
            for (ik=1; ik <= nk; ik++)
            {
               const int K = (Ks[ik]) ? Ks[ik] : N, ns = SDs[0];
               int is;
               for (is=1; is <= ns; is++)
               {
                  const int SD=SDs[is], nu = UPs[0];
                  int iu;

                  if (HAS_SD)
                     cSD = (SD == AtlasRight) ? 'R' : 'L';
                  for (iu=1; iu <= nu; iu++)
                  {
                     const int UP=UPs[iu];
                     const int nd=DIs[0];
                     int id;

                     if (HAS_UP)
                        cUP = (UP == AtlasLower) ? 'L' : 'U';
                     for (id=1; id <= nd; id++)
                     {
                        const int DI=DIs[id];
                        const int nta=TAs[0];
                        int ita;

                        if (HAS_DI)
                           cDI = (DI == AtlasUnit) ? 'U' : 'N';
                        for (ita=1; ita <= nta; ita++)
                        {
                           const int TA=TAs[ita];
                           const int ntb=TBs[0];
                           int itb;

                           if (HAS_TA)
                           {
                              if (TA == AtlasConjTrans)
                                 cTA = 'C';
                              else
                                 cTA = (TA == AtlasTrans) ? 'T' : 'N';
                           }
                           for (itb=1; itb <= ntb; itb++)
                           {
                              const int TB=TBs[itb];
                              int ia;

                              if (HAS_TB)
                              {
                                 if (TB == AtlasConjTrans)
                                    cTB = 'C';
                                 else
                                    cTB = (TB == AtlasTrans) ? 'T' : 'N';
                              }
                              for (ia=0; ia < nalp; ia++)
                              {
                                 #ifdef TREAL
                                    const TYPE alpha = alps[ia];
                                 #else
                                    const TYPE *alpha = alps+ia+ia;
                                 #endif
                                 int ib;
                                 char cALP;

                                 #ifdef TREAL
                                    if (alpha == 0.0)
                                       cALP = '0';
                                    else if (alpha == 1.0)
                                       cALP = '1';
                                    else if (alpha == -1.0)
                                       cALP = 'N';
                                    else
                                       cALP = 'X';
                                 #else
                                    if (alpha[1] == 0.0)
                                    {
                                       if (*alpha == 0.0)
                                          cALP = '0';
                                       else if (*alpha == 1.0)
                                          cALP = '1';
                                       else if (*alpha == -1.0)
                                          cALP = 'N';
                                       else
                                          cALP = 'R';
                                    }
                                    else
                                       cALP = 'X';
                                 #endif
                                 for (ib=0; ib < nbet; ib++)
                                 {
                                    #ifdef TREAL
                                       const TYPE beta = bets[ia];
                                    #else
                                       const TYPE *beta = bets+ib+ib;
                                    #endif
                                    int r;
                                    char cBET;

                                    #ifdef TREAL
                                       if (beta == 0.0)
                                          cBET = '0';
                                       else if (beta == 1.0)
                                          cBET = '1';
                                       else if (beta == -1.0)
                                          cBET = 'N';
                                       else
                                          cBET = 'X';
                                    #else
                                       if (beta[1] == 0.0)
                                       {
                                          if (*beta == 0.0)
                                             cBET = '0';
                                          else if (*beta == 1.0)
                                             cBET = '1';
                                          else if (*beta == -1.0)
                                             cBET = 'N';
                                          else
                                             cBET = 'R';
                                       }
                                       else
                                          cBET = 'X';
                                    #endif
                                    for (r=0; r < nreps; r++)
                                    {
                                       double time=0.0, mf=0.0;

                                       DoTiming(nreps, flszKB, MFF, ldaG, ldbG,
                                                ldcG, rt, SD, UP, DI, TA, TB,
                                                alpha, beta, M, N, K, 
                                                &time, &mf);
                                       printf(frm, ++it, cSD, cUP, cDI, cTA,cTB,
                                              cALP, cBET, M, N, K, time, mf);
                                       fflush(stdout);
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
   }
}

int *RoutNames2IntList(int nargs, char **args, int i)
{
   int n, *iarr, k;

   if (++i >= nargs)
      PrintUsage(args[0], i, NULL);
   n = atoi(args[i]);
   ATL_assert(n > 0);
   iarr = malloc(sizeof(int)*(n+1));
   ATL_assert(iarr);

   iarr[0] = n;
   for (k=0; k < n; k++)
   {
      int b;
      if (++i >= nargs)
         PrintUsage(args[0], i, NULL);
      for (b=0; b < NBLAS; b++)
      {
         if (!strcmp(args[i], nblas[b]))
         {
            iarr[k+1] = b;
            break;
         }
      }
      if (b == NBLAS)
         PrintUsage(args[0], i, args[i]);
   }
   return(iarr);
}

void PrintUsage(char *name, int ierr, char *flag)
{
   if (ierr > 0)
      fprintf(stderr, "Bad argument #%d: '%s'\n",
              ierr, flag ? flag : "Not enough arguments");
   else if (ierr < 0)
      fprintf(stderr, "ERROR: %s\n", flag);

   fprintf(stderr, "USAGE: %s [flags]:\n", name);
   fprintf(stderr, "   -R <#> <rout1> ... <rout#>\n");
   fprintf(stderr, "   -R <rout1/all>\n");
   fprintf(stderr, 
   "      routs: gemm, symm, syr2k hemm, her2k, syrk, trmm, trsm, herk\n");
   fprintf(stderr, "   -F <mflop> : force <mflops> of timed computation\n");
   fprintf(stderr, "   -# <#> : repeat each timing # times\n");
   fprintf(stderr, "   -n <#> <N1> ... <N#>\n");
   fprintf(stderr, "   -N <Nstart> <Nend> <Ninc>\n");
   fprintf(stderr, "   -m <#> <M1> ... <M#>\n");
   fprintf(stderr, "   -M <Mstart> <Mend> <Minc>\n");
   fprintf(stderr, "   -k <#> <K1> ... <K#>\n");
   fprintf(stderr, "   -K <Kstart> <Kend> <Kinc>\n");
   fprintf(stderr, "   -G[a,bc] <ldxgap> : ldx = N + <ldxgap> foreach N\n");
   fprintf(stderr, "   -f <flushKB> : flush at least this mem in LRU timers\n");
   fprintf(stderr, "   -S <#> <side1> ... <side#>\n");
   fprintf(stderr, "   -U <#> <up1> ... <up#> : Vals: [u,l,q,g]\n");
   fprintf(stderr, "   -D <#> <dia1> ... <dia#> : Vals: [u,n]\n");
   fprintf(stderr, "   -A <#> <ta1> ... <ta#> : Vals: [n,t,c]\n");
   fprintf(stderr, "   -B <#> <tb1> ... <tb#> : Vals: [n,t,c]\n");
   fprintf(stderr, "   -a <#> <alpha1> ... <alphaN> : real/complex floats\n");
   fprintf(stderr, "   -b <#> <beta1> ... <betaN> : real/complex floats\n");
   exit(ierr ? ierr : -1);
}

void GetFlags(int nargs, char **args, int *nreps, int *flsizeKB, int *mflop,
              int *ldaG, int *ldbG, int *ldcG, int **ROUTs, int **Ns, int **Ms,
              int **Ks, int **UPLOs, int **SDs, int **DIs, int **TAs, int **TBs,
              int *nalphas, TYPE **alphas, int *nbetas, TYPE **betas)
{
   int *NBs=NULL, *ns=NULL, *ms=NULL, *ks=NULL, *ups=NULL, *sds=NULL, 
       *dis=NULL, *tas=NULL, *tbs=NULL, *ip;
   int i, j, k, n;

   *ROUTs = NULL;
   *ldbG = *ldcG = *ldaG = 0;
   *flsizeKB = L2SIZE/1024;
   *mflop = 0;
   *nreps = 1;
   *alphas = *betas = NULL;
   for (i=1; i < nargs; i++)
   {
      int WH=0;
      if (args[i][0] != '-')
         PrintUsage(args[0], i, args[i]);
      switch(args[i][1])
      {
      case 'n':         /* -n  or -nb */
         ns = GF_GetIntList(nargs, args, i, 1);
         i += ns[0] + 1;
         break;
      case 'm':         /* -m # <M1> ... <M#> */
         ms = GF_GetIntList(nargs, args, i, 1);
         i += ms[0] + 1;
         break;
      case 'k':         /* -m # <M1> ... <M#> */
         ks = GF_GetIntList(nargs, args, i, 1);
         i += ks[0] + 1;
         break;
      case 'K':         /* -N or -NB */
         WH++;
      case 'N':         /* -N or -NB */
         WH++;
      case 'M':                         /* -M <Mstart> <Mend> <Minc>\n"); */
         if (i+3 >= nargs)
            PrintUsage(args[0], i, NULL);
         ip = GF_IntRange2IntList(atoi(args[i+1]), atoi(args[i+2]),
                                  atoi(args[i+3]));
         if (WH == 2)
            ks = ip;
         else if (WH == 1)
            ns = ip;
         else
            ms = ip;
         i += 3;
         break;
      case 'R':        /* -R # <rout1> ... <routN#>  */
         if (i+1 >= nargs)
            PrintUsage(args[0], i, "out of args to -R");
         if (isdigit(args[i+1][0]))
         {
            *ROUTs = RoutNames2IntList(nargs, args, i);
            i += (*ROUTs)[0] + 1;
         }
         else if (!strcmp(args[++i], "all"))  /* want them all */
            *ROUTs = GF_IntRange2IntList(Bgemm, NBLAS-1, 1);
         else  /* only giving one name */
         {
            for (k=0; k < NBLAS; k++)
               if (!strcmp(args[i], nblas[k]))
                  break;
            if (k == NBLAS)
              PrintUsage(args[0], i, 
                         "Unknown blas name to -R: is it lower case?");
            *ROUTs = GF_GetIntList1(k);
         }
         break;
      case '#':                          /* -# <reps> */
         if (++i >= nargs)
            PrintUsage(args[0], i, NULL);
         *nreps = atoi(args[i]);
         break;
      case 'f':                         /* -f <flushKB> */
         if (++i >= nargs)
            PrintUsage(args[0], i, NULL);
         *flsizeKB = atoi(args[i]);
         break;
      case 'F':                         /* -F <mflop> */
         if (++i >= nargs)
            PrintUsage(args[0], i, NULL);
         *mflop = atoi(args[i]);
         break;
      case 'A':                         /* -A <nta> <ta1> ... <taN> */
         WH = 1;
      case 'B':                         /* -B <ntb> <tb1> ... <tbN> */
         if (++i >= nargs)
            PrintUsage(args[0], i, NULL);
         n = atoi(args[i]);
         ATL_assert(n > 0);
         ip = malloc(sizeof(int)*(n+1));
         ip[0] = n;
         for (k=0; k < n; k++)
         {
            if (++i >= nargs)
               PrintUsage(args[0], i, NULL);
            switch(args[i][0])
            {
            case 'C':
            case 'c':
               ip[k+1] = AtlasConjTrans;
               break;
            case 't':
            case 'T':
               ip[k+1] = AtlasTrans;
               break;
            default:
               ip[k+1] = AtlasNoTrans;
               break;
            }
         }
         if (WH)
            tas = ip;
         else
            tbs = ip;
         break;
      case 'U':                         /* -U <nup> <u1> ... <uN>;[u,l,q,g] */
         if (++i >= nargs)
            PrintUsage(args[0], i, NULL);
         n = atoi(args[i]);
         ATL_assert(n > 0);
         ups = malloc(sizeof(int)*(n+1));
         ups[0] = n;
         for (k=0; k < n; k++)
         {
            if (++i >= nargs)
               PrintUsage(args[0], i, NULL);
            switch(args[i][0])
            {
            case 'U':
            case 'u':
               ups[k+1] = AtlasUpper;
               break;
            case 'l':
            case 'L':
            default:
               ups[k+1] = AtlasLower;
               break;
            }
         }
         break;
      case 'S':                         /* -S <#> <side1> ... <sideN> */
         if (++i >= nargs)
            PrintUsage(args[0], i, NULL);
         n = atoi(args[i]);
         ATL_assert(n > 0);
         sds = malloc(sizeof(int)*(n+1));
         sds[0] = n;
         for (k=0; k < n; k++)
         {
            if (++i >= nargs)
               PrintUsage(args[0], i, NULL);
            switch(args[i][0])
            {
            case 'L':
            case 'l':
               sds[k+1] = AtlasLeft;
               break;
            default:
               sds[k+1] = AtlasRight;
               break;
            }
         }
         break;
      case 'D':                         /* -D <#> <diag1> ... <diagN> */
         if (++i >= nargs)
            PrintUsage(args[0], i, NULL);
         n = atoi(args[i]);
         ATL_assert(n > 0);
         dis = malloc(sizeof(int)*(n+1));
         dis[0] = n;
         for (k=0; k < n; k++)
         {
            if (++i >= nargs)
               PrintUsage(args[0], i, NULL);
            switch(args[i][0])
            {
            case 'U':
            case 'u':
               dis[k+1] = AtlasUnit;
               break;
            default:
               dis[k+1] = AtlasNonUnit;
               break;
            }
         }
         break;
      case 'G':                         /* -a <ldagap> */
         if (++i >= nargs)
            PrintUsage(args[0], i, NULL);
         if (args[i-1][2] == 'b')
            *ldbG = atoi(args[i]);
         else if (args[i-1][2] == 'c')
            *ldcG = atoi(args[i]);
         else
            *ldaG = atoi(args[i]);
         break;
      case 'a':
         if (++i >= nargs)
            PrintUsage(args[0], i, "out of flags in -a");
         *nalphas = atoi(args[i]);
         *alphas = malloc(ATL_MulBySize(*nalphas));
         assert(*alphas);
         for (j=0; j < *nalphas SHIFT; j++) 
         {
            if (++i >= nargs)
               PrintUsage(args[0], i, "out of flags in -a");
            (*alphas)[j] = atof(args[i]);
         }
         break;
      case 'b':
         if (++i >= nargs)
            PrintUsage(args[0], i, "out of flags in -b");
         *nbetas  = atoi(args[i]);
         *betas  = malloc(ATL_MulBySize(*nbetas ));
         assert(*betas );
         for (j=0; j < *nbetas SHIFT; j++)
         {
            if (++i >= nargs)
               PrintUsage(args[0], i, "out of flags in -b");
            (*betas)[j] = atof(args[i]);
         }
         break;
      default:
         PrintUsage(args[0], i, args[i]);
      }
   }
/*
 * Take default values
 */
   if (!(*alphas))
   {
      *nalphas = 1;
      *alphas = malloc(sizeof(double)SHIFT);
      **alphas = 1.0;
      #ifdef TCPLX
         (*alphas)[1] = 0.0;
      #endif
   }
   if (!(*betas))
   {
      *nbetas = 1;
      *betas = malloc(sizeof(double)SHIFT);
      **betas = 1.0;
      #ifdef TCPLX
         (*betas)[1] = 0.0;
      #endif
   }
   if (!(*ROUTs))
      *ROUTs = GF_GetIntList1(Bgemm);
   if (!ns)
      ns = GF_GetIntList1(1000);
   if (!ms)
      ms = GF_GetIntList1(0);
   if (!ks)
      ks = GF_GetIntList1(0);
   if (!ups)
      ups = GF_GetIntList1(AtlasUpper);
   if (!sds)
      sds = GF_GetIntList1(AtlasRight);
   if (!dis)
      dis = GF_GetIntList1(AtlasRight);
   if (!tas)
      tas = GF_GetIntList1(AtlasNoTrans);
   if (!tbs)
      tbs = GF_GetIntList1(AtlasNoTrans);

   *Ns = ns;
   *Ms = ms;
   *Ks = ks;
   *UPLOs = ups;
   *SDs = sds;
   *DIs = dis;
   *TAs = tas;
   *TBs = tbs;
}

int main(int nargs, char **args)
{
   int nreps, flszKB, MF, ldaG, ldbG, ldcG, nalp, nbet; 
   int *ROUTs, *Ns, *Ms, *Ks, *UPs, *SDs, *DIs, *TAs, *TBs;
   TYPE *alps, *bets;
   GetFlags(nargs, args, &nreps, &flszKB, &MF, &ldaG, &ldbG, &ldcG, 
            &ROUTs, &Ns, &Ms, &Ks, &UPs, &SDs, &DIs, &TAs, &TBs,
            &nalp, &alps, &nbet, &bets);
   RunAllTimings(nreps, flszKB, MF, ldaG, ldbG, ldcG, ROUTs, SDs, UPs, DIs, 
                 TAs, TBs, nalp, alps, nbet, bets, Ms, Ns, Ks);
   free(ROUTs);
   free(Ms);
   free(Ns);
   free(Ks);
   free(UPs);
   free(SDs);
   free(DIs);
   free(TAs);
   free(TBs);
   free(alps);
   free(bets);
   return(0);
}
@rout l3blastst_old
@extract -b @(topd)/gen.inc what=cw -def author "Jeff Horner" -def contrib "R. Clint Whaley" -def cdate 1998
@define rname @l3blastst@
/*
 * =====================================================================
 * Include files
 * =====================================================================
 */
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <assert.h>
 
#include "atlas_misc.h"
#include "atlas_tst.h"
/*
 * =====================================================================
 * #define macro constants
 * =====================================================================
 */
#define    MEGA                     1000000.0
#if defined( SREAL ) || defined( SCPLX )
#define    THRESH                        50.0f
#else
#define    THRESH                        50.0
#endif
 
/* #define    ATLAS_DEBUG */
/*
 * =====================================================================
 * # macro functions
 * =====================================================================
 *
 * The following and mutually exclusive  macros  allow to select various
 * BLAS implementations to test the ATLAS implementation against:
 *
 *    USE_F77_BLAS     : Fortran 77 BLAS interface,
 *    USE_L3_REFERENCE : C ATLAS reference implementation,
 *
 * If none of these macros is defined at compile time, the  ATLAS imple-
 * mentation is to be tested against itself,  after all this is the only
 * version we are sure to have available.
 *
 * By default the mono-threaded  ATLAS  routines are tested. To test the
 * multi-threaded ATLAS routines, define the following macro:
 *    USE_L3_PTHREADS  : multi-threaded ATLAS implementation.
 */
#define USE_F77_BLAS

/*
 * =====================================================================
 */
#if   defined( USE_F77_BLAS ) /* Trusted BLAS version to test against */
#define  TP3      Mjoin( PATL,   f77 )
#elif defined( USE_L3_REFERENCE )
#include "atlas_reflevel3.h"
#define  TP3      Mjoin( PATL,   ref )
#else /* defined( USE_L3_ATLAS ) */  /* use ATLAS itself !! (default) */
#include "atlas_level3.h"
#define  TP3      PATL
#endif

#define trusted_gemm(         TA, TB, M, N, K, al, A, lA, B, lB, be, C, lC) \
Mjoin( TP3, gemm  )(          TA, TB, M, N, K, al, A, lA, B, lB, be, C, lC)
#define trusted_hemm( SI, UP,         M, N,    al, A, lA, B, lB, be, C, lC) \
Mjoin( TP3, hemm  )(  SI, UP,         M, N,    al, A, lA, B, lB, be, C, lC)
#define trusted_herk(     UP, TA,        N, K, al, A, lA,        be, C, lC) \
Mjoin( TP3, herk  )(      UP, TA,        N, K, al, A, lA,        be, C, lC)
#define trusted_her2k(    UP, TA,        N, K, al, A, lA, B, lB, be, C, lC) \
Mjoin( TP3, her2k )(      UP, TA,        N, K, al, A, lA, B, lB, be, C, lC)
#define trusted_symm( SI, UP,         M, N,    al, A, lA, B, lB, be, C, lC) \
Mjoin( TP3, symm  )(  SI, UP,         M, N,    al, A, lA, B, lB, be, C, lC)
#define trusted_syrk(     UP, TA,        N, K, al, A, lA,        be, C, lC) \
Mjoin( TP3, syrk  )(      UP, TA,        N, K, al, A, lA,        be, C, lC)
#define trusted_syr2k(    UP, TA,        N, K, al, A, lA, B, lB, be, C, lC) \
Mjoin( TP3, syr2k )(      UP, TA,        N, K, al, A, lA, B, lB, be, C, lC)
#define trusted_trmm( SI, UP, TA, DI, M, N,    al, A, lA,            B, lB) \
Mjoin( TP3, trmm  )(  SI, UP, TA, DI, M, N,    al, A, lA,            B, lB)
#define trusted_trsm( SI, UP, TA, DI, M, N,    al, A, lA,            B, lB) \
Mjoin( TP3, trsm  )(  SI, UP, TA, DI, M, N,    al, A, lA,            B, lB)
 
/*
 * ATLAS version of the BLAS to test.
 */
#if   defined( USE_L3_PTHREADS )
#include "atlas_ptlvl3.h"
#define  AP3      Mjoin( PATL,   pt  )
#else
#include "atlas_level3.h"
#define  AP3      PATL
#endif

#define test_gemm(            TA, TB, M, N, K, al, A, lA, B, lB, be, C, lC) \
Mjoin( TP3, gemm  )(          TA, TB, M, N, K, al, A, lA, B, lB, be, C, lC)
#define test_hemm(    SI, UP,         M, N,    al, A, lA, B, lB, be, C, lC) \
Mjoin( TP3, hemm  )(  SI, UP,         M, N,    al, A, lA, B, lB, be, C, lC)
#define test_herk(        UP, TA,        N, K, al, A, lA,        be, C, lC) \
Mjoin( TP3, herk  )(      UP, TA,        N, K, al, A, lA,        be, C, lC)
#define test_her2k(       UP, TA,        N, K, al, A, lA, B, lB, be, C, lC) \
Mjoin( TP3, her2k )(      UP, TA,        N, K, al, A, lA, B, lB, be, C, lC)
#define test_symm(    SI, UP,         M, N,    al, A, lA, B, lB, be, C, lC) \
Mjoin( TP3, symm  )(  SI, UP,         M, N,    al, A, lA, B, lB, be, C, lC)
#define test_syrk(        UP, TA,        N, K, al, A, lA,        be, C, lC) \
Mjoin( TP3, syrk  )(      UP, TA,        N, K, al, A, lA,        be, C, lC)
#define test_syr2k(       UP, TA,        N, K, al, A, lA, B, lB, be, C, lC) \
Mjoin( TP3, syr2k )(      UP, TA,        N, K, al, A, lA, B, lB, be, C, lC)
#define test_trmm(    SI, UP, TA, DI, M, N,    al, A, lA,            B, lB) \
Mjoin( TP3, trmm  )(  SI, UP, TA, DI, M, N,    al, A, lA,            B, lB)
#define test_trsm(    SI, UP, TA, DI, M, N,    al, A, lA,            B, lB) \
Mjoin( TP3, trsm  )(  SI, UP, TA, DI, M, N,    al, A, lA,            B, lB)


#ifdef TCPLX
   #define SCALAR_ABS(X) (Mabs(*X) + Mabs(*(X+1)))
#else
   #define SCALAR_ABS(X) (Mabs(X))
#endif

void Mjoin(PRE,symd)(enum ATLAS_UPLO UL, int M, TYPE *A, int lda, TYPE *B, int ldb, TYPE *C, int ldc)
{
   int i,j;
   if (UL == AtlasLower)
   {
      for (i=0; i<M; i++)
      {
         for (j=0; j<i; j++)
         {
#ifdef TCPLX
            C[(i+j*ldc)*2] = A[(i+j*lda)*2] - B[(i+j*ldb)*2];
            C[(i+j*ldc)*2+1] = A[(i+j*lda)*2+1] - B[(i+j*ldb)*2+1];
#else
            C[i+j*ldc] = A[i+j*lda] - B[i+j*ldb];
#endif
         }
         for (j=0; j<M-i; j++)
         {
#ifdef TCPLX
            C[(j+i+i*ldc)*2] = A[(j+i+i*lda)*2] - B[(j+i+i*ldb)*2];
            C[(j+i+i*ldc)*2+1] = A[(j+i+i*lda)*2+1] - B[(j+i+i*ldb)*2+1];
#else
            C[j+i+i*ldc] = A[j+i+i*lda] - B[j+i+i*ldb];
#endif
         }
      }
   } 
   else 
   {
      for (i=0; i<M; i++)
      {
         for (j=0; j<i; j++)
         {
#ifdef TCPLX
            C[(j+i*lda)*2] = A[(j+i*lda)*2] - B[(j+i*ldb)*2];
            C[(j+i*lda)*2+1] = A[(j+i*lda)*2+1] - B[(j+i*ldb)*2+1];
#else
            C[j+i*lda] = A[j+i*lda] - B[j+i*ldb];
#endif
         }
         for (j=0; j<M-i; j++)
         {
#ifdef TCPLX
            C[(i+(i+j)*lda)*2] = A[(i+(i+j)*lda)*2] - B[(i+(i+j)*ldb)*2];
            C[(i+(i+j)*lda)*2+1] = A[(i+(i+j)*lda)*2+1] - B[(i+(i+j)*ldb)*2+1];
#else
            C[i+(i+j)*lda] = A[i+(i+j)*lda] - B[i+(i+j)*ldb];
#endif
         }
      }
   }
}
      
TYPE  Mjoin(PRE,genorm)(int M, int N, TYPE *A, int lda)
{
   int i,j;
   TYPE *v, maxval=0.0;
   
   v = malloc(sizeof(TYPE) * N);
   ATL_assert(v);

   for (j=0; j<N; j++)
   {
      v[j] = 0.0;
      for (i=0; i< (M SHIFT); i++)
         v[j] += Mabs(A[i]);
      A += lda SHIFT;
   }
   
   for (i=0; i<N; i++){
      if (maxval < v[i]) maxval = v[i];
   }
   free(v);
   return maxval;
}

TYPE Mjoin(PRE,synorm)(enum ATLAS_UPLO UL, int M, TYPE *A, int lda)
{
   int i,j;
   TYPE *v, maxval=0.0;
#ifdef TCPLX
   TYPE *tmp;
#endif
   
   v = malloc(sizeof(TYPE) * M);
   ATL_assert(v);
   
   if (UL == AtlasLower){
      for (i=0; i<M; i++){
         v[i] = 0.0;
         for (j=0; j<i; j++){
#ifdef TCPLX
            tmp = A+(i+j*lda)*2;
            v[i] += SCALAR_ABS(tmp);
#else
            v[i] += Mabs(A[i+j*lda]);
#endif
         }
         for (j=0; j<M-i; j++){
#ifdef TCPLX
            tmp = A+(j+i+i*lda)*2;
            v[i] += SCALAR_ABS(tmp);
#else
            v[i] += Mabs(A[j+i+i*lda]);
#endif
         }
      }
   } else {
      for (i=0; i<M; i++){
         v[i] = 0.0;
         for (j=0; j<i; j++){
#ifdef TCPLX
            tmp = A+(j+i*lda)*2;
            v[i] += SCALAR_ABS(tmp);
#else
            v[i] += Mabs(A[j+i*lda]);
#endif
         }
         for (j=0; j<M-i; j++){
#ifdef TCPLX
            tmp = A+(i+(i+j)*lda)*2;
            v[i] += SCALAR_ABS(tmp);
#else
            v[i] += Mabs(A[i+(i+j)*lda]);
#endif
         }
      }
   }

   for (i=0; i<M; i++){
      if (maxval < v[i]) maxval = v[i];
   }
   free(v);
   return maxval;
}
#ifdef TCPLX
TYPE Mjoin(PRE,henorm)(enum ATLAS_UPLO UL, int M, TYPE *A, int lda)
{
   int i,j;
   TYPE *v, maxval=0.0;
   TYPE *tmp;
   
   v = malloc(sizeof(TYPE) * M);
   ATL_assert(v);
   
   if (UL == AtlasLower){
      for (i=0; i<M; i++){
         v[i] = 0.0;
         for (j=0; j<i; j++){
            tmp = A+(i+j*lda)*2;
            v[i] += SCALAR_ABS(tmp);
         }
         v[i] += Mabs(A[(i+i*lda)*2]);
         for (j=1; j<M-i; j++){
            tmp = A+(j+i+i*lda)*2;
            v[i] += SCALAR_ABS(tmp);
         }
      }
   } else {
      for (i=0; i<M; i++){
         v[i] = 0.0;
         for (j=0; j<i; j++){
            tmp = A+(j+i*lda)*2;
            v[i] += SCALAR_ABS(tmp);
         }
         v[i] += Mabs(A[(i+i*lda)*2]);
         for (j=1; j<M-i; j++){
            tmp = A+(i+(i+j)*lda)*2;
            v[i] += SCALAR_ABS(tmp);
         }
      }
   }

   for (i=0; i<M; i++){
      if (maxval < v[i]) maxval = v[i];
   }
   free(v);
   return maxval;
}
#endif

TYPE Mjoin(PRE,trnorm)(enum ATLAS_UPLO UL, enum ATLAS_DIAG DI, int M, TYPE *A, int lda)
{
   int i,j;
   TYPE *v, maxval=0.0;
#ifdef TCPLX
   TYPE *tmp;
#endif
   
   v = malloc(ATL_sizeof * M);
   ATL_assert(v);
   
   if (UL == AtlasLower){
      for (i=0; i<M; i++){
         if (DI == AtlasUnit) 
            v[i] = 1.0;
         else
         {
#ifdef TCPLX
            tmp = A+(i+i*lda)*2;
            v[i] = SCALAR_ABS(tmp);
#else
            v[i] = Mabs(A[i+i*lda]);
#endif
         }
         for (j=i+1; j<M; j++)
         {
#ifdef TCPLX
            tmp = A+(j+(i*lda))*2;
            v[i] += SCALAR_ABS(tmp);
#else
            v[i] += Mabs(A[j+(i*lda)]);
#endif
         }
      }
   } else {
      for (i=0; i<M; i++){
         v[i] = 0.0;
         for (j=0; j<i; j++)
         {
#ifdef TCPLX
            tmp = A+(j+i*lda)*2;
            v[i] += SCALAR_ABS(tmp);
#else
            v[i] += Mabs(A[j+i*lda]);
#endif
         }
         if (DI == AtlasUnit) 
            v[i] += 1.0;
         else
         {
#ifdef TCPLX
            tmp = A+(i+i*lda)*2;
            v[i] += SCALAR_ABS(tmp);
#else
            v[i] += Mabs(A[i+i*lda]);
#endif
         }
      }
   }

   for (i=0; i<M; i++){
      if (maxval < v[i]) maxval = v[i];
   }
   free(v);
   return maxval;
}

void Mjoin(PRE,gemscal)(int M, int N, TYPE *A, int lda, SCALAR alpha)
{
   int i,j;
#ifdef TCPLX
   TYPE tmp, *Ar, *Ai;
#endif
   
   for (i=0; i<N; i++)
      for (j=0; j<M; j++){
#ifdef TCPLX
         Ar = A+(j+i*lda)*2;
         Ai = Ar+1;
         tmp = *alpha * *Ar - *(alpha+1) * *Ai;
         *Ai = *alpha * *Ai + *(alpha+1) * *Ar;
         *Ar = tmp;
#else
         A[j+i*lda] *= alpha;
#endif
      }
}


int Maxval3(int M, int N, int K)
{
   int maxval=0;
   if (maxval < M) maxval = M;
   if (maxval < N) maxval = N;
   if (maxval < K) maxval = K;
   return maxval;
}

int Maxval2(int M, int N)
{
   int maxval=0;
   if (maxval < M) maxval = M;
   if (maxval < N) maxval = N;
   return maxval;
}
#ifdef TCPLX
#define L3_nrouts 9
#define L3_GEMM 0
#define L3_SYMM 1
#define L3_HEMM 2
#define L3_SYRK 3
#define L3_HERK 4
#define L3_SYR2K 5
#define L3_HER2K 6
#define L3_TRMM 7
#define L3_TRSM 8
static char *blas[L3_nrouts] = { "gemm" , "symm"  , "hemm" , "syrk" ,
                            "herk" , "syr2k" , "her2k", "trmm" , "trsm" }; 

#define L3_copyrouts(X) (X)[0] = blas[0]; (X)[1] = blas[1]; \
                        (X)[2] = blas[2]; (X)[3] = blas[3]; \
                        (X)[4] = blas[4]; (X)[5] = blas[5]; \
                        (X)[6] = blas[6]; (X)[7] = blas[7]; \
                        (X)[8] = blas[8];
                  
#else
#define L3_nrouts 6
#define L3_GEMM 0
#define L3_SYMM 1
#define L3_SYRK 2
#define L3_SYR2K 3
#define L3_TRMM 4
#define L3_TRSM 5
static char *blas[L3_nrouts] = { "gemm" , "symm"  , "syrk" , "syr2k" , 
                            "trmm" , "trsm" }; 
#define L3_copyrouts(X) (X)[0] = blas[0]; (X)[1] = blas[1]; \
                        (X)[2] = blas[2]; (X)[3] = blas[3]; \
                        (X)[4] = blas[4]; (X)[5] = blas[5];
#endif
                  
/* 
 * GLOBAL VARIABLES
 */
TYPE eps=0.0;
char *pre=Mstr(PRE);

/*
 * FUNCTION PROTOTYPES FOR TESTING ROUTINES
 */
double time00(void);
void Mjoin(PRE,symd)(enum ATLAS_UPLO, int, TYPE *, int, TYPE *, int, TYPE *, int);
TYPE  Mjoin(PRE,genorm)(int, int, TYPE *, int);
TYPE  Mjoin(PRE,synorm)(enum ATLAS_UPLO, int, TYPE *, int);
TYPE  Mjoin(PRE,henorm)(enum ATLAS_UPLO, int, TYPE *, int);
TYPE  Mjoin(PRE,trnorm)(enum ATLAS_UPLO, enum ATLAS_DIAG, int, TYPE *, int);
int Maxval3(int, int, int);
int Maxval2(int, int);

#ifndef L2SIZE
   #define L2SIZE 4194304
#endif

#ifdef DEBUG
void printmat(char *mat, int M, int N, TYPE *A, int lda)
{
   int i, j;

#ifdef TCPLX
   lda *= 2;
#endif
   printf("\n%s = \n",mat);
   for (i=0; i != M; i++)
   {
#ifdef TREAL
#ifdef DEBUG
      for (j=0; j != N; j++) printf("%.1f  ",A[i+j*lda]);
#else
      for (j=0; j != N; j++) printf("%f  ",A[i+j*lda]);
#endif
#else
#ifdef DEBUG
      for (j=0; j != N; j++) printf("(%.1f,%.1f)  ",A[2*i+j*lda], A[1+2*i+j*lda]);
#else
      for (j=0; j != N; j++) printf("(%f,%f)  ",A[2*i+j*lda], A[1+2*i+j*lda]);
#endif
#endif
      printf("\n");
   }
}
#endif

void matgen(int M, int N, TYPE *A, int lda, int seed)
{
   int i, j;
#ifdef DEBUG
   int k = 1;
#endif

#ifdef TCPLX
   M *= 2;
   lda *= 2;
#endif
   dumb_seed(seed);
   for (j=N; j; j--)
   {
#ifdef DEBUG
      for (i=0; i != M; i++) A[i] = k++;
#else
      for (i=0; i != M; i++) A[i] = dumb_rand();
#endif
      A += lda;
   }
}

int gemmcase
(
   char TA,
   char TB, 
   int M,
   int N,
   int K, 
   SCALAR alpha,
   TYPE * A,
   int lda,
   TYPE * B,
   int ldb,
   SCALAR beta, 
   TYPE * C,
   int ldc,
   TYPE *D,
   int ldd, 
   int TEST
)
{
   char *pc = "---";
#ifdef TREAL
   char *form="%4d   %c   %c %4d %4d %4d  %5.1f  %5.1f  %6.2f  %5.1f %5.2f   %3s\n";
   #define MALPH alpha
   #define MBETA beta
#else
   #define MALPH *alpha, alpha[1]
   #define MBETA *beta, beta[1]
   char *form="%4d  %c  %c %4d %4d %4d  %5.1f %5.1f  %5.1f %5.1f  %6.2f %6.1f %4.2f  %3s\n";
#endif
   int i, j=0, passed=0;
   double t0, t1, t2, t3, mflop;
   TYPE ferr;
   extern TYPE eps;
   static int itst=1;
   int *L2=NULL, nL2=(1.3*L2SIZE)/sizeof(int);
   enum ATLAS_TRANS TAc, TBc;
   TYPE normA, normB, normC;
   extern unsigned int _mcount;

   if (nL2) L2 = malloc(nL2*sizeof(int));
   if (TA == 'n' || TA == 'N') 
   {
      matgen(M, K, A, lda, K*1112);
      TAc = AtlasNoTrans;
   }
   else
   {
      matgen(K, M, A, lda, K*1112);
      if (TA == 'c' || TA == 'C') TAc = AtlasConjTrans;
      else TAc = AtlasTrans;
   }
   if (TB == 'n' || TB == 'N')
   {
      matgen(K, N, B, ldb, N*2238);
      TBc = AtlasNoTrans;
   }
   else
   {
      matgen(N, K, B, ldb, N*2238);
      if (TB == 'c' || TB == 'C') TBc = AtlasConjTrans;
      else TBc = AtlasTrans;
   }
   matgen(M, N, C, ldc, M*N);
   matgen(M, N, D, ldd, M*N);

#ifdef DEBUG
   printmat("A0", M, K, A, lda);
   printmat("B0", K, N, B, ldb);
   printmat("C0", M, N, C, ldc);
#endif

   if (L2) /* invalidate L2 cache */
   {
      for (i=0; i != nL2; i++) L2[i] = 0.0; 
      for (i=0; i != nL2; i++) j += L2[i];
   }

   t0 = time00();
   trusted_gemm(TAc, TBc, M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
   t1 = time00() - t0;
   if (t1 <= 0.0) mflop = t1 = 0.0;
   else   /* flop rate's actually 8MNK+12MN & 2MNK + 2MN, resp */
      #ifdef TCPLX
         mflop = ( ((8.0*M)*N)*K ) / (t1*MEGA);
      #else
         mflop = ( ((2.0*M)*N)*K ) / (t1*MEGA);
      #endif
   printf(form, itst, TA, TB, M, N, K, MALPH, MBETA, t1, mflop, 1.0, "---");

#ifdef DEBUG
   printmat("C", M, N, C, ldc);
#endif

#ifndef TIMEONLY

   if (L2)
   {
      for (i=0; i != nL2; i++) L2[i] = 0.0;  /* invalidate L2 cache */
      for (i=0; i != nL2; i++) j += L2[i];  /* invalidate L2 cache */
   }

   t0 = time00();
   test_gemm(TAc, TBc, M, N, K, alpha, A, lda, B, ldb, beta, D, ldd);
   t2 = time00() - t0;
   if (t2 <= 0.0) t2 = mflop = 0.0;
   else 
      #ifdef TCPLX
         mflop = ( ((8.0*M)*N)*K ) / (t2*MEGA);
      #else
         mflop = ( ((2.0*M)*N)*K ) / (t2*MEGA);
      #endif
#ifdef DEBUG
   printmat("D", M, N, D, ldd);
#endif
   if (TEST)
   {
      Mjoin(PATL,gediff)(M,N,C,ldc,D,ldd,C,ldc);
      normC = Mjoin(PRE,genorm)(M,N,C,ldc);
      normA = Mjoin(PRE,genorm)(M,K,A,lda);
      normB = Mjoin(PRE,genorm)(K,N,B,ldb);
      if (normA > 0.0 && normB > 0.0 && SCALAR_ABS(alpha) > 0.0 )
         ferr = normC / ( normA * normB * eps * Maxval3(M,N,K) * SCALAR_ABS(alpha) );
      else
         ferr = 0.0;
      if (ferr > 1.0 ){
         passed = 0;
         pc = "NO";
         printf("ERROR: ferr is %f\n",ferr);
      } 
      else 
      {
         passed = 1;
         pc = "YES";
      }
   }
   if (t1 == t2) t3 = 1.0;
   else if (t2 != 0.0) t3 = t1/t2;
   else t3 = 0.0;
   printf(form, itst++, TA, TB, M, N, K, MALPH, MBETA, t2, mflop, t3, pc);
#else
   itst++;
   passed = 1;
#endif
   if (L2) free(L2);
   return(passed);
}

void gemmloop(int nTA, enum ATLAS_TRANS *TransA,
              int nTB, enum ATLAS_TRANS *TransB,
              int M0, int MN, int incM, 
              int N0, int NN, int incN, 
              int K0, int KN, int incK, 
              int nalph, TYPE *alph, 
              int nbeta, TYPE *beta, 
              int TEST, int LDA_IS_M, int *gtst, int *gpass)
{
   int lda, ldb, ldc, k, m, n, im, ik, ita, itb, ia, ib; 
   int itst=0, ipass=0, MSAME=0, KSAME=0;
   TYPE *A, *B, *C, *D;
   char TA, TB; 
   extern char *pre;

   if (M0 == -1)
   {
      MSAME = 1;
      M0 = MN = incM = NN;
   }
   if (K0 == -1)
   {
      KSAME = 1;
      K0 = KN = incK = NN;
   }

   A = malloc(MN*KN*ATL_sizeof);
   B = malloc(NN*KN*ATL_sizeof);
   C = malloc(MN*NN*ATL_sizeof);
   D = malloc(MN*NN*ATL_sizeof);
   if (!A || !B || !C || !D)
   {
      fprintf(stderr, "Not enough memory to run tests!!\n");
      exit(-1);
   }

   printf("\n%cGEMM\n",Mupcase(pre[0]));
#ifdef TREAL
   printf("TEST  TA  TB    M    N    K  alpha   beta    Time  Mflop  SpUp  PASS\n");
   printf("====  ==  == ==== ====  ===  =====  =====  ======  =====  ====  ====\n\n");
#else
printf("\nTEST TA TB    M    N    K        alpha         beta    Time  Mflop SpUp PASS\n");
  printf("==== == == ==== ==== ====  ===== =====  ===== =====  ====== ====== ==== ====\n\n");
#endif
   for (im=M0; im <= MN; im += incM)
   {
      for (n=N0; n <= NN; n += incN)
      {
         if (MSAME) m = n;
         else m = im;
         for (ik=K0; ik <= KN; ik += incK)
         {
            if (KSAME) k = n;
            else k = ik;
            for (ita=0; ita != nTA; ita++)
            {
               if (TransA[ita] == AtlasNoTrans) TA = 'N';
               else if (TransA[ita] == AtlasTrans) TA = 'T';
               else if (TransA[ita] == AtlasConjTrans) TA = 'C';

               for (itb=0; itb != nTB; itb++)
               {
                  if (TransB[itb] == AtlasNoTrans) TB = 'N';
                  else if (TransB[itb] == AtlasTrans) TB = 'T';
                  else if (TransB[itb] == AtlasConjTrans) TB = 'C';
                  for (ia=0; ia != nalph; ia++)
                  {
                     for (ib=0; ib != nbeta; ib++)
                     {
                        itst++;
                        if (LDA_IS_M)
                        {
                           if (TransA[ita] == AtlasNoTrans) lda = m;
                           else lda = k;
                           if (TransB[itb] == AtlasNoTrans) ldb = k;
                           else ldb = n;
                           ldc = m;
                        }
                        else
                        {
                           if (TransA[ita] == AtlasNoTrans) lda = MN;
                           else lda = KN;
                           if (TransB[itb] == AtlasNoTrans) ldb = KN;
                           else ldb = NN;
                           ldc = MN;
                        }

#ifdef TREAL
                        ipass += gemmcase(TA, TB, m, n, k, 
                                          alph[ia], A, lda, 
                                          B, ldb, beta[ib], 
                                          C, ldc, D, ldc, 
                                          TEST);
#else
                        ipass += gemmcase(TA, TB, m, n, k, 
                                          &alph[2*ia], A, lda, 
                                          B, ldb, &beta[2*ib],
                                          C, ldc, D, ldc, 
                                          TEST);
#endif
                     }
                  }
               }
            }
         }
      }
   }
   if (TEST) printf("\nNTEST=%d, NUMBER passed=%d, NUMBER FAILURES=%d\n",
                    itst, ipass, itst-ipass);
   else printf("\nDone with %d timing runs\n",itst);
   *gtst += itst; *gpass += ipass;
   free(A);
   free(B);
   free(C);
   if (D) free(D);
}

int syhemmcase(char *rout, char SI, char UL, 
             int M, int N,
             SCALAR alpha, TYPE *A, int lda,
             TYPE *B, int ldb,  SCALAR beta, 
             TYPE *C, int ldc,
             TYPE *D, int ldd, 
             int TEST)
{
   char *pc = "---";
#ifdef TREAL
   char *form="%4d   %c   %c %4d %4d       %5.1f  %5.1f  %6.2f  %5.1f  %4.2f   %3s\n";
   #define MALPH alpha
   #define MBETA beta
#else
   #define MALPH *alpha, alpha[1]
   #define MBETA *beta, beta[1]
   char *form="%4d  %c  %c %4d %4d       %5.1f %5.1f  %5.1f %5.1f  %6.2f %6.1f %4.2f  %3s\n";
   static int hetst=1;
#endif
   int i, j=0, passed=0;
   double t0, t1, t2, t3, mflop;
   TYPE ferr;
   extern TYPE eps;
   static int sytst=1;
   int *itst = NULL;
   int *pL2 = NULL, *L2 = NULL, nL2=(1.3*L2SIZE)/sizeof(int);
   enum ATLAS_SIDE SIc;
   enum ATLAS_UPLO ULc;
   TYPE normA, normB, normC;

   if (nL2) {
      pL2 = malloc(nL2*sizeof(int));
      L2 = pL2;
   }
   if (SI == 'l' || SI == 'L'){ 
      matgen(M, M, A, lda, M*M);
      SIc = AtlasLeft;
   } else {
      matgen(N, N, A, lda, N*N);
      SIc = AtlasRight;
   }
   if (UL == 'U' || UL == 'u') ULc = AtlasUpper;
   else ULc = AtlasLower;

   matgen(M, N, B, ldb, M*N);
   matgen(M, N, C, ldc, M*N);
   matgen(M, N, D, ldd, M*N);

#ifdef DEBUG
   if (SI == 'l' || SI == 'L') printmat("A0", M, M, A, lda);
   else printmat("A0", N, N, A, lda);
   printmat("B0", M, N, B, ldb);
   printmat("C0", M, N, C, ldc);
#endif

   if (L2) /* invalidate L2 cache */
   {
      for (i=0; i != nL2; i++) L2[i] = 0.0; 
      for (i=0; i != nL2; i++) j += L2[i];
   }

#ifdef TCPLX
   if (strcasecmp(rout,blas[L3_SYMM]) == 0)
   {
#endif
      itst = &sytst;
      t0 = time00();
      trusted_symm(SIc, ULc, M, N, alpha, A, lda, B, ldb, beta, C, ldc);
      t1 = time00() - t0;
#ifdef TCPLX
   }
   else
   {
      itst = &hetst;
      t0 = time00();
      trusted_hemm(SIc, ULc, M, N, alpha, A, lda, B, ldb, beta, C, ldc);
      t1 = time00() - t0;
   }
#endif
   if (t1 <= 0.0) mflop = t1 = 0.0;
   else if (SI == 'L')
#ifdef TCPLX
      mflop = ( ((8.0*M)*M)*N ) / (t1*MEGA);
#else
      mflop = ( ((2.0*M)*M)*N ) / (t1*MEGA);
#endif 
   else 
#ifdef TCPLX
      mflop = ( ((8.0*M)*N)*N ) / (t1*MEGA);
#else
      mflop = ( ((2.0*M)*N)*N ) / (t1*MEGA);
#endif 
   printf(form, *itst, SI, UL, M, N, MALPH, MBETA, t1, mflop, 1.0, "---");

#ifdef DEBUG
   printmat("C", M, N, C, ldc);
#endif

#ifndef TIMEONLY

      if (L2)
      {
         for (i=0; i != nL2; i++) L2[i] = 0.0;  /* invalidate L2 cache */
         for (i=0; i != nL2; i++) j += L2[i];  /* invalidate L2 cache */
      }

#ifdef TCPLX
   if (strcasecmp(rout,blas[L3_SYMM]) == 0)
   {
#endif
      t0 = time00();
      test_symm(SIc, ULc, M, N, alpha, A, lda, B, ldb, beta, D, ldc);
      t2 = time00() - t0;
#ifdef TCPLX
   }
   else
   {
      t0 = time00();
      test_hemm(SIc, ULc, M, N, alpha, A, lda, B, ldb, beta, D, ldc);
      t2 = time00() - t0;
   }
#endif
      if (t2 <= 0.0) t2 = mflop = 0.0;
      else if (SI == 'L')
#ifdef TCPLX
         mflop = ( ((8.0*M)*M)*N ) / (t2*MEGA);
#else
         mflop = ( ((2.0*M)*M)*N ) / (t2*MEGA);
#endif 
      else
#ifdef TCPLX
         mflop = ( ((8.0*M)*N)*N ) / (t2*MEGA);
#else
         mflop = ( ((2.0*M)*N)*N ) / (t2*MEGA);
#endif 
#ifdef DEBUG
      printmat("D", M, N, D, ldd);
#endif
   if (TEST)
   {

      Mjoin(PATL,gediff)(M,N,C,ldc,D,ldd,C,ldc);
      normC = Mjoin(PRE,genorm)(M,N,C,ldc);
      normB = Mjoin(PRE,genorm)(M,N,B,ldb);
#ifdef TCPLX
      if (strcasecmp(rout,blas[L3_SYMM]) == 0)
      {
#endif
         if (ULc == AtlasLower)
            normA = Mjoin(PRE,synorm)(ULc, M,A,lda);
         else
            normA = Mjoin(PRE,synorm)(ULc, N,A,lda);
#ifdef TCPLX
      }
      else
      {
         if (ULc == AtlasLower)
            normA = Mjoin(PRE,henorm)(ULc, M,A,lda);
         else
            normA = Mjoin(PRE,henorm)(ULc, N,A,lda);
      }
#endif
      if (normA > 0.0 && normB > 0.0 && SCALAR_ABS(alpha) > 0.0 )
         ferr = normC / ( normA * normB * eps * Maxval2(M,N) * SCALAR_ABS(alpha) );
      else 
         ferr = 0.0;
      if (ferr > 1.0 ){
         passed = 0;
         pc = "NO";
         printf("ERROR: ferr is %f\n",ferr);
      } 
      else 
      {
         passed = 1;
         pc = "YES";
      }
   }
   if (t1 == t2) t3 = 1.0;
   else if (t2 != 0.0) t3 = t1/t2;
   else t3 = 0.0;
   printf(form, (*itst)++, SI, UL, M, N, MALPH, MBETA, t2, mflop, t3, pc);
#else
   (*itst)++;
   passed = 1;
#endif
   if (pL2) free(pL2);
   return(passed);
}

void syhemmloop(char *rout, int nside, enum ATLAS_SIDE *Side, 
              int nuplo, enum ATLAS_UPLO *Uplo,
              int M0, int MN, int incM, 
              int N0, int NN, int incN, 
              int nalph, TYPE *alph, 
              int nbeta, TYPE *beta, 
              int TEST, int LDA_IS_M, int *gtst, int *gpass)
{
   int m, n, is, iu, ia, ib, lda, ldb, ldc;
   int itst=0, ipass=0, SAME=0;
   TYPE *A, *B, *C, *D;
   char SI, UL; 
   extern char *pre;
   
   if (M0 == -1)
   {
      SAME = 1;
      M0 = MN = incM = NN;
   }

   if (MN >= NN)
   {
      A = malloc(MN*MN*ATL_sizeof);
      B = malloc(MN*MN*ATL_sizeof);
   }
   else 
   {
      A = malloc(NN*NN*ATL_sizeof);
      B = malloc(NN*NN*ATL_sizeof);
   }
   C = malloc(MN*NN*ATL_sizeof);
   D = malloc(MN*NN*ATL_sizeof);
   if (!A || !B || !C || !D)
   {
      fprintf(stderr, "Not enough memory to run tests!!\n");
      exit(-1);
   }

   if (strcasecmp(rout,blas[L3_SYMM]) == 0)
      printf("\n%cSYMM\n",Mupcase(pre[0]));
   else 
      printf("\n%cHEMM\n",Mupcase(pre[0]));
#ifdef TREAL
   printf("TEST  SI  UL    M    N       alpha   beta    Time  Mflop  SpUp  PASS\n");
   printf("====  ==  == ==== ====       =====  =====  ======  =====  ====  ====\n\n");
#else
printf("\nTEST SI UP    M    N             alpha         beta    Time  Mflop SpUp PASS\n");
  printf("==== == == ==== ====       ===== =====  ===== =====  ====== ====== ==== ====\n\n");
#endif
   for (m=M0; m <= MN; m += incM) 
   {
      for (n=N0; n <= NN; n += incN) 
      {
         if (SAME) m = n;
         for (is=0; is != nside; is++) 
         {
            if (Side[is] == AtlasRight) SI = 'R';
            else SI = 'L';
            for (iu=0; iu != nuplo; iu++) 
            {
               if (Uplo[iu] == AtlasUpper) UL = 'U';
               else UL = 'L';
               for (ia=0; ia != nalph; ia++) 
               {
                  for (ib=0; ib != nbeta; ib++) 
                  {
                     itst++;
                     if (LDA_IS_M)
                     {
                        if (Side[is] == AtlasLeft) lda = m;
                        else lda = n;
                        ldb = m;
                        ldc = m;
                     }
                     else
                     {
                        if (Side[is] == AtlasLeft) lda = MN;
                        else lda = NN;
                        ldb = MN;
                        ldc = MN;
                     }
#ifdef TREAL
                     ipass += syhemmcase(rout, SI, UL, m, n,
                                       alph[ia], A, lda, 
                                       B, ldb, beta[ib],
                                       C, ldc, D, ldc, 
                                       TEST);
#else
                     ipass += syhemmcase(rout, SI, UL, m, n,
                                       &alph[2*ia], A, lda, 
                                       B, ldb, &beta[2*ib],
                                       C, ldc, D, ldc, 
                                       TEST);
#endif
                  }
               }
            }
         }
      }
   }
   if (TEST) printf("\nNTEST=%d, NUMBER passed=%d, NUMBER FAILURES=%d\n",
         itst, ipass, itst-ipass);
   else printf("\nDone with %d timing runs\n",itst);
   *gtst += itst; *gpass += ipass;
   free(A);
   free(B);
   free(C);
   if (D) free(D);
}

int syherkcase( char *rout, char UL, char TR,
              int N, int K,
              SCALAR alpha, TYPE *A, int lda,
              SCALAR beta,  TYPE *C, int ldc,
              TYPE *D, int ldd,
              int TEST)
{
   char *pc = "---";
#ifdef TREAL
   char *form="%4d   %c   %c      %4d %4d  %5.1f  %5.1f  %6.2f  %5.1f  %4.2f   %3s\n";
   #define MALPH alpha
   #define MBETA beta
#else
   #define MALPH *alpha, alpha[1]
   #define MBETA *beta, beta[1]
   char *form="%4d  %c  %c      %4d %4d  %5.1f %5.1f  %5.1f %5.1f  %6.2f %6.1f %4.2f  %3s\n";
   static int hetst=1;
#endif
   int i, j=0, passed=0;
   double t0, t1, t2, t3, mflop;
   extern TYPE eps;
   TYPE ferr;
   static int sytst=1;
   int *itst=NULL;
   int *L2=NULL, nL2=(1.3*L2SIZE)/sizeof(int);
   enum ATLAS_UPLO ULc;
   enum ATLAS_TRANS TRc;
   TYPE *mdiff, normA, normC;

   if (nL2) L2 = malloc(nL2*sizeof(int));
   if (TR == 'N') 
   {
      matgen(N, K, A, lda, K*1112);
      TRc = AtlasNoTrans;
   }
   else
   {
      matgen(K, N, A, lda, K*1112);
      if (TR == 'c' || TR == 'C') TRc = AtlasConjTrans;
      else TRc = AtlasTrans;
   }
   if (UL == 'U' || UL == 'u') ULc = AtlasUpper;
   else ULc = AtlasLower;

   matgen(N, N, C, ldc, N*N);
   matgen(N, N, D, ldc, N*N);
#ifdef DEBUG
   if (TR == 'N') printmat("A0", N, K, A, lda);
   else printmat("A0", K, N, A, lda);
   printmat("B0", N, N, C, ldc);
#endif

   if (L2) /* invalidate L2 cache */
   {
      for (i=0; i != nL2; i++) L2[i] = 0.0; 
      for (i=0; i != nL2; i++) j += L2[i];
   }

#ifdef TCPLX
   if (strcasecmp(rout,blas[L3_SYRK]) == 0)
   {
#endif
      itst = &sytst;
      t0 = time00();
      trusted_syrk(ULc, TRc, N, K, alpha, A, lda, beta, C, ldc);
      t1 = time00() - t0;
#ifdef TCPLX
   }
   else
   {
      itst = &hetst;
      t0 = time00();
      trusted_herk(ULc, TRc, N, K, *alpha, A, lda, *beta, C, ldc);
      t1 = time00() - t0;
   }
#endif
   if (t1 <= 0.0) mflop = t1 = 0.0;
   else
      #ifdef TCPLX
         mflop = ( ((4.0*N)*N)*K ) / (t1*MEGA);
      #else
         mflop = ( ((1.0*N)*N)*K ) / (t1*MEGA);
      #endif
   printf(form, *itst, UL, TR, N, K, MALPH, MBETA, t1, mflop, 1.0, "---");
   
#ifdef DEBUG
   printmat("C",N,N,C,ldc);
#endif

#ifndef TIMEONLY

   if (L2)
   {
      for (i=0; i != nL2; i++) L2[i] = 0.0;  /* invalidate L2 cache */
      for (i=0; i != nL2; i++) j += L2[i];  /* invalidate L2 cache */
   }

#ifdef TCPLX
   if (strcasecmp(rout,blas[L3_SYRK]) == 0)
   {
#endif
      t0 = time00();
      test_syrk(ULc, TRc, N, K, alpha, A, lda, beta, D, ldd);
      t2 = time00() - t0;
#ifdef TCPLX
   }
   else
   {
      t0 = time00();
      test_herk(ULc, TRc, N, K, *alpha, A, lda, *beta, D, ldd);
      t2 = time00() - t0;
   }
#endif

   if (t2 <= 0.0) t2 = mflop = 0.0;
   else 
      #ifdef TCPLX
         mflop = ( ((4.0*N)*N)*K ) / (t2*MEGA);
      #else
         mflop = ( ((1.0*N)*N)*K ) / (t2*MEGA);
      #endif
#ifdef DEBUG
   printmat("D", N, N, D, ldd);
#endif
   if (TEST)
   {

      mdiff = malloc(ATL_sizeof * N * ldc);
      assert(mdiff);
      Mjoin(PRE,symd)(ULc,N,C,ldc,D,ldd,mdiff,ldc);
      normC = Mjoin(PRE,synorm)(ULc,N,mdiff,ldc);
      free(mdiff);
      if ( TRc == AtlasNoTrans)
         normA = Mjoin(PRE,genorm)(N,K,A,lda);
      else
         normA = Mjoin(PRE,genorm)(K,N,A,lda);

      #ifdef TCPLX
         if (strcasecmp(rout,blas[L3_SYRK]) == 0)
         {
            if (normA > 0.0 && SCALAR_ABS(alpha) > 0.0 )
               ferr = normC/(normA*normA*eps*Maxval2(N,K)*SCALAR_ABS(alpha));
            else ferr = 0.0;
         }
         else
         {
            if (normA > 0.0 && Mabs(*alpha) > 0.0 )
               ferr = normC/(normA * normA * eps * Maxval2(N,K) * Mabs(*alpha));
            else ferr = 0.0;
         }
      #else
         if (normA > 0.0 && Mabs(alpha) > 0.0 )
            ferr = normC/(normA * normA * eps * Maxval2(N,K) * Mabs(alpha));
         else ferr = 0.0;
      #endif
      if (ferr > 1.0 ){
         passed = 0;
         pc = "NO";
         printf("ERROR: ferr is %f\n",ferr);
      } 
      else 
      {
         passed = 1;
         pc = "YES";
      }
   }
   if (t1 == t2) t3 = 1.0;
   else if (t2 != 0.0) t3 = t1/t2;
   else t3 = 0.0;
   printf(form, (*itst)++, UL, TR, N, K, MALPH, MBETA, t2, mflop, t3, pc);
#else
   (*itst)++;
   passed = 1;
#endif
   if (L2) free(L2);
   return(passed);
}

void syherkloop(char *rout, int nuplo, enum ATLAS_UPLO *Uplo,
              int ntrans, enum ATLAS_TRANS *Trans,
              int N0, int NN, int incN, 
              int K0, int KN, int incK, 
              int nalph, TYPE *alph, 
              int nbeta, TYPE *beta, 
              int TEST, int LDA_IS_M, int *gtst, int *gpass)
{
   int n, k, ik, iu, it, ia, ib, lda, ldc;
   int itst=0, ipass=0, SAME=0;
   TYPE *A, *C, *D;
   char UL, TR; 
   extern char *pre;
   
   if (K0 == -1)
   {
      SAME = 1;
      K0 = KN = incK = NN;
   }
   if (NN >=KN)
      A = malloc(NN*NN*ATL_sizeof);
   else
      A = malloc(KN*KN*ATL_sizeof);
   C = malloc(NN*NN*ATL_sizeof);
   D = malloc(NN*NN*ATL_sizeof);
   if (!A || !C || !D)
   {
      fprintf(stderr, "Not enough memory to run tests!!\n");
      exit(-1);
   }
   if (strcasecmp(rout,blas[L3_SYRK]) == 0)
      printf("\n%cSYRK\n",Mupcase(pre[0]));
   else
      printf("\n%cHERK\n",Mupcase(pre[0]));
#ifdef TREAL
   printf("TEST  UL  TR         N    K  alpha   beta    Time  Mflop  SpUp  PASS\n");
   printf("====  ==  ==      ==== ====  =====  =====  ======  =====  ====  ====\n\n");
#else
printf("\nTEST UL TR         N    K        alpha         beta    Time  Mflop SpUp PASS\n");
  printf("==== == ==      ==== ====  ===== =====  ===== =====  ====== ====== ==== ====\n\n");
#endif
   for (n=N0; n <= NN; n += incN) 
   {
      for (ik=K0; ik <= KN; ik += incK) 
      {
         if (SAME) k = n;
         else k = ik;
         for (iu=0; iu != nuplo; iu++) 
         {
            if (Uplo[iu] == AtlasUpper) UL = 'U';
            else UL = 'L';
            for (it=0; it != ntrans; it++) 
            {
               if (Trans[it] == AtlasNoTrans) TR = 'N';
               else if (Trans[it] == AtlasTrans) 
               {
                  if (strcasecmp(rout,blas[L3_SYRK]) == 0) TR = 'T';
                  else continue;
               }
#ifdef TCPLX
               else if (Trans[it] == AtlasConjTrans)
               { 
                  if (strcasecmp(rout,blas[L3_HERK]) == 0) TR = 'C';
                  else continue;
               }
#else
               else continue;
#endif
               for (ia=0; ia != nalph; ia++) 
               {
                  for (ib=0; ib != nbeta; ib++) 
                  {
                     itst++;
                     if (LDA_IS_M)
                     {
                        if ( Trans[it] == AtlasNoTrans) lda = n;
                        else lda = k;
                        ldc = n;
                     }
                     else
                     {
                        if ( Trans[it] == AtlasNoTrans) lda = NN;
                        else lda = KN;
                        ldc = NN;
                     }
#ifdef TREAL
                     ipass += syherkcase(rout, UL, TR, n, k, alph[ia], 
                                       A, lda, beta[ib], C, ldc, D, ldc, 
                                       TEST);
#else
                     ipass += syherkcase(rout, UL, TR, n, k, &alph[2*ia], 
                                       A, lda, &beta[2*ib], C, ldc, D, ldc, 
                                       TEST);
#endif
                  }
               }
            }
         }
      }
   }
   if (TEST) printf("\nNTEST=%d, NUMBER passed=%d, NUMBER FAILURES=%d\n",
         itst, ipass, itst-ipass);
   else printf("\nDone with %d timing runs\n",itst);
   *gtst += itst; *gpass += ipass;
   free(A);
   free(C);
   if (D) free(D);
}
int syher2kcase( char *rout, char UL, char TR,
              int N, int K,
              SCALAR alpha, TYPE *A, int lda,
              TYPE *B, int ldb, SCALAR beta,  
              TYPE *C, int ldc,
              TYPE *D, int ldd,
              int TEST)
{
   char *pc = "---";
#ifdef TREAL
   char *form="%4d   %c   %c      %4d %4d  %5.1f  %5.1f  %6.2f  %5.1f  %4.2f   %3s\n";
   #define MALPH alpha
   #define MBETA beta
#else
   #define MALPH *alpha, alpha[1]
   #define MBETA *beta, beta[1]
   char *form="%4d  %c  %c      %4d %4d  %5.1f %5.1f  %5.1f %5.1f  %6.2f %6.1f %4.2f  %3s\n";
   static int hetst=1;
#endif
   int i, j=0, passed=0;
   double t0, t1, t2, t3, mflop;
   extern TYPE eps;
   TYPE ferr;
   static int sytst=1;
   int *itst;
   int *L2=NULL, nL2=(1.3*L2SIZE)/sizeof(int);
   enum ATLAS_TRANS TRc;
   enum ATLAS_UPLO ULc;
   TYPE normA, normB, normC, *mdiff;

   if (nL2) L2 = malloc(nL2*sizeof(int));
   if (TR == 'N') 
   {
      matgen(N, K, A, lda, K*1112);
      matgen(N, K, B, ldb, K*1112);
      TRc = AtlasNoTrans;
   }
   else
   {
      matgen(K, N, A, lda, K*1112);
      matgen(K, N, B, ldb, K*1112);
      if (TR == 'c' || TR == 'C') TRc = AtlasConjTrans;
      else TRc = AtlasTrans;
   }
   if (UL == 'U' || UL == 'u') ULc = AtlasUpper;
   else ULc = AtlasLower;
   matgen(N, N, C, ldc, N*N);
   matgen(N, N, D, ldd, N*N);

#ifdef DEBUG
   if (TR == 'N'){ printmat("A0", N, K, A, lda); printmat("B0",N,K,B,ldb); }
   else { printmat("A0", K, N, A, lda); printmat("B0",K,N,B,ldb); }
   printmat("C0", N, N, C, ldc);
#endif

   if (L2) /* invalidate L2 cache */
   {
      for (i=0; i != nL2; i++) L2[i] = 0.0; 
      for (i=0; i != nL2; i++) j += L2[i];
   }

#ifdef TCPLX
   if (strcasecmp(rout,blas[L3_SYR2K]) == 0)
   {
#endif
      itst = &sytst;
      t0 = time00();
      trusted_syr2k(ULc, TRc, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
      t1 = time00() - t0;
#ifdef TCPLX
   }
   else
   {
      itst = &hetst;
      t0 = time00();
      trusted_her2k(ULc, TRc, N, K, alpha, A, lda, B, ldb, *beta, C, ldc);
      t1 = time00() - t0;
   }
#endif
   if (t1 <= 0.0) mflop = t1 = 0.0;
   else
      #ifdef TCPLX
         mflop = ( ((8.0*N)*N)*K ) / (t1*MEGA);
      #else
         mflop = ( ((2.0*N)*N)*K ) / (t1*MEGA);
      #endif
   printf(form, *itst, UL, TR, N, K, MALPH, MBETA, t1, mflop, 1.0, "---");
#ifdef DEBUG
   printmat("C",N,N,C,ldc);
#endif

#ifndef TIMEONLY

   if (L2)
   {
      for (i=0; i != nL2; i++) L2[i] = 0.0;  /* invalidate L2 cache */
      for (i=0; i != nL2; i++) j += L2[i];  /* invalidate L2 cache */
   }

#ifdef TCPLX
   if (strcasecmp(rout,blas[L3_SYR2K]) == 0)
   {
#endif
      t0 = time00();
      test_syr2k(ULc, TRc, N, K, alpha, A, lda, B, ldb, beta, D, ldd);
      t2 = time00() - t0;
#ifdef TCPLX
   }
   else
   {
      t0 = time00();
      test_her2k(ULc, TRc, N, K, alpha, A, lda, B, ldb, *beta, D, ldd);
      t2 = time00() - t0;
   }
#endif

   if (t2 <= 0.0) t2 = mflop = 0.0;
   else 
      #ifdef TCPLX
         mflop = ( ((8.0*N)*N)*K ) / (t2*MEGA);
      #else
         mflop = ( ((2.0*N)*N)*K ) / (t2*MEGA);
      #endif
#ifdef DEBUG
   printmat("D", N, N, D, ldd);
#endif
   if (TEST)
   {
      mdiff = malloc(ATL_sizeof * N * ldc);
      assert(mdiff);
      Mjoin(PRE,symd)(ULc,N,C,ldc,D,ldd,mdiff,ldc);
      normC = Mjoin(PRE,synorm)(ULc,N,mdiff,ldc);
      free(mdiff);
      if ( TRc == AtlasNoTrans){
         normA = Mjoin(PRE,genorm)(N,K,A,lda);
         normB = Mjoin(PRE,genorm)(N,K,B,ldb);
      }
      else
      {
         normA = Mjoin(PRE,genorm)(K,N,A,lda);
         normB = Mjoin(PRE,genorm)(K,N,B,ldb);
      }

      if (normA > 0.0 && normB > 0.0 && SCALAR_ABS(alpha) > 0.0 )
         ferr = normC / ( normA * normB * eps * Maxval2(N,K) * SCALAR_ABS(alpha) );
      else
         ferr = 0.0;
      if (ferr > 1.0 ){
         passed = 0;
         pc = "NO";
         printf("ERROR: ferr is %f\n",ferr);
      } 
      else 
      {
         passed = 1;
         pc = "YES";
      }
   }
   if (t1 == t2) t3 = 1.0;
   else if (t2 != 0.0) t3 = t1/t2;
   else t3 = 0.0;
   printf(form, (*itst)++, UL, TR, N, K, MALPH, MBETA, t2, mflop, t3, pc);
#else
   (*itst)++;
   passed = 1;
#endif
   if (L2) free(L2);
   return(passed);
}
void syher2kloop(char *rout, int nuplo, enum ATLAS_UPLO *Uplo,
              int ntrans, enum ATLAS_TRANS *Trans,
              int N0, int NN, int incN, 
              int K0, int KN, int incK, 
              int nalph, TYPE *alph, 
              int nbeta, TYPE *beta, 
              int TEST, int LDA_IS_M, int *gtst, int *gpass)
{
   int n, k, ik, iu, it, ia, ib, lda, ldb, ldc;
   int itst=0, ipass=0, SAME=0;
   TYPE *A, *B, *C, *D;
   char UL, TR; 
   extern char *pre;
   
   if (K0 == -1)
   {
      SAME = 1;
      K0 = KN = incK = NN;
   }
   if (NN >= KN)
   {
      A = malloc(NN*NN*ATL_sizeof);
      B = malloc(NN*NN*ATL_sizeof);
   }
   else
   {
      A = malloc(KN*KN*ATL_sizeof);
      B = malloc(KN*KN*ATL_sizeof);
   }
   C = malloc(NN*NN*ATL_sizeof);
   D = malloc(NN*NN*ATL_sizeof);
   if (!A || !B || !C || !D)
   {
      fprintf(stderr, "Not enough memory to run tests!!\n");
      exit(-1);
   }
   #ifdef TCPLX
      if (strcasecmp(rout,blas[L3_SYR2K]) == 0) printf("\n%cSYR2K\n",Mupcase(pre[0]));
      else printf("\n%cHER2K\n",Mupcase(pre[0]));
   #else
      printf("\n%cSYR2K\n",Mupcase(pre[0]));
   #endif
#ifdef TREAL
   printf("TEST  UL  TR         N    K  alpha   beta    Time  Mflop  SpUp  PASS\n");
   printf("====  ==  ==      ==== ====  =====  =====  ======  =====  ====  ====\n\n");
#else
printf("\nTEST UL TR         N    K        alpha         beta    Time  Mflop SpUp PASS\n");
  printf("==== == ==      ==== ====  ===== =====  ===== =====  ====== ====== ==== ====\n\n");
#endif
   for (n=N0; n <= NN; n += incN) 
   {
      for (ik=K0; ik <= KN; ik += incK) 
      {
         if (SAME) k = n;
         else k = ik;
         for (iu=0; iu != nuplo; iu++) 
         {
            if (Uplo[iu] == AtlasUpper) UL = 'U';
            else UL = 'L';
            for (it=0; it != ntrans; it++) 
            {
               if (Trans[it] == AtlasNoTrans) TR = 'N';
               else if (Trans[it] == AtlasTrans) 
               {
                  if (strcasecmp(rout,blas[L3_SYR2K]) == 0) TR = 'T';
                  else continue;
               }
#ifdef TCPLX
               else if (Trans[it] == AtlasConjTrans)
               { 
                  if (strcasecmp(rout,blas[L3_HER2K]) == 0) TR = 'C';
                  else continue;
               }
#else
               else continue;
#endif
               for (ia=0; ia != nalph; ia++) 
               {
                  for (ib=0; ib != nbeta; ib++) 
                  {
                     itst++;
                     if (LDA_IS_M)
                     {
                        if ( Trans[it] == AtlasNoTrans) 
                        {
                           lda = n;
                           ldb = n;
                        }
                        else 
                        {
                           lda = k;
                           ldb = k;
                        }
                        ldc = n;
                     }
                     else
                     {
                        if ( Trans[it] == AtlasNoTrans) 
                        {
                           lda = NN;
                           ldb = NN;
                        }
                        else 
                        {
                           lda = KN;
                           ldb = KN;
                        }
                        ldc = NN;
                     }
#ifdef TREAL
                     ipass += syher2kcase(rout, UL, TR, n, k, alph[ia], 
                                       A, lda, B,ldb, beta[ib],
                                       C, ldc, D, ldc, 
                                       TEST);
#else
                     ipass += syher2kcase(rout, UL, TR, n, k, &alph[2*ia], 
                                       A, lda, B, ldb, &beta[2*ib],
                                       C, ldc, D, ldc, 
                                       TEST);
#endif
                  }
               }
            }
         }
      }
   }
   if (TEST) printf("\nNTEST=%d, NUMBER passed=%d, NUMBER FAILURES=%d\n",
         itst, ipass, itst-ipass);
   else printf("\nDone with %d timing runs\n",itst);
   *gtst += itst; *gpass += ipass;
   free(A);
   free(B);
   free(C);
   if (D) free(D);
}
int trcase(char *rout, 
             char SI, char UL, char TR, char DI,
             int M, int N,
             SCALAR alpha, TYPE *A, int lda,
             TYPE *B, int ldb,
             TYPE *C, int ldc,
             int TEST)
{
   char *pc = "---";
#ifdef TREAL
   char *form="%4d   %c  %c  %c  %c %4d %4d  %5.1f         %6.2f %6.1f  %4.2f   %3s\n";
   #define MALPH alpha
   #define MBETA beta
#else
   #define MALPH *alpha, alpha[1]
   #define MBETA *beta, beta[1]
   char *form="%4d  %c  %c  %c  %c %4d %4d  %5.1f %5.1f               %6.2f %6.1f %4.2f  %3s\n";
#endif
   int i, j=0, passed=0;
   double t0, t1, t2, t3, mflop;
   TYPE ferr;
   extern TYPE eps;
   static int mmtst=1;
   static int smtst=1;
   int *itst;
   int *pL2 = NULL, *L2=NULL, nL2=(1.3*L2SIZE)/sizeof(int);
   enum ATLAS_SIDE SIc;
   enum ATLAS_UPLO ULc;
   enum ATLAS_TRANS TRc;
   enum ATLAS_DIAG DIc;
   TYPE normA, normB, normC, *cB;
#ifdef TREAL
   SCALAR alpha1 = 1.0;
#else
   TYPE alpha1[2] = {1.0,0.0};
#endif

   cB = malloc(ATL_sizeof * N * ldb);
   assert(cB);

   if (nL2) {
      pL2 = malloc(nL2*sizeof(int));
      L2 = pL2;
   }
   if (SI == 'l' || SI == 'L'){ 
      matgen(M, M, A, lda, M*M);
      if (strcasecmp(rout,blas[L3_TRSM]) == 0)
         for (i=0; i != M; i++) 
            #ifdef TREAL
               A[i*(lda+1)] += M;
            #else
               {  A[2*i*(lda+1)] += M; A[2*i*(lda+1)+1] += M; }
            #endif
      SIc = AtlasLeft;
   } else {
      matgen(N, N, A, lda, N*N);
      if (strcasecmp(rout,blas[L3_TRSM]) == 0)
         for (i=0; i != N; i++) 
            #ifdef TREAL
               A[i*(lda+1)] += N;
            #else
               {  A[2*i*(lda+1)] += N; A[2*i*(lda+1)+1] += N; }
            #endif
      SIc = AtlasRight;
   }

   if (UL == 'U' || UL == 'u') ULc = AtlasUpper;
   else ULc = AtlasLower;

   if (TR == 'N' || TR == 'n') TRc = AtlasNoTrans;
   else if (TR == 'T' || TR == 't') TRc = AtlasTrans;
   else TRc = AtlasConjTrans;
   
   if (DI == 'U' || DI == 'u') DIc = AtlasUnit;
   else DIc = AtlasNonUnit;

   matgen(M, N, B, ldb, M*N);
   bcopy(B,C,ATL_sizeof*N*ldb);
   bcopy(B,cB,ATL_sizeof*N*ldb);

#ifdef DEBUG
   if (SI == 'l' || SI == 'L') printmat("A0", M, M, A, lda);
   else printmat("A0", N, N, A, lda);
   printmat("B0", M, N, B, ldb);
#endif

   if (L2) /* invalidate L2 cache */
   {
      for (i=0; i != nL2; i++) L2[i] = 0.0; 
      for (i=0; i != nL2; i++) j += L2[i];
   }

   if (strcasecmp(rout,blas[L3_TRMM]) == 0)
   {
      itst = &mmtst;
      t0 = time00();
      trusted_trmm(SIc, ULc, TRc, DIc, M, N, alpha, A, lda, B, ldb);
      t1 = time00() - t0;
   }
   else
   {
      itst = &smtst;
      t0 = time00();
      trusted_trsm(SIc, ULc, TRc, DIc, M, N, alpha, A, lda, B, ldb);
      t1 = time00() - t0;
   }

   if (t1 <= 0.0) mflop = t1 = 0.0;
   else if (SI == 'L')
   {
      #ifdef TCPLX
         mflop = ( ((4.0*M)*M)*N ) / (t1*MEGA);
      #else
         mflop = ( ((1.0*M)*M)*N ) / (t1*MEGA);
      #endif
   }
   else
   {
      #ifdef TCPLX
         mflop = ( ((4.0*M)*N)*N ) / (t1*MEGA);
      #else
         mflop = ( ((1.0*M)*N)*N ) / (t1*MEGA);
      #endif
   }
   printf(form, *itst, SI, UL, TR, DI, M, N, MALPH, t1, mflop, 1.0, "---");

#ifdef DEBUG
   printmat("B", M, N, B, ldb);
#endif

#ifndef TIMEONLY
   if (L2)
   {
      for (i=0; i != nL2; i++) L2[i] = 0.0;  /* invalidate L2 cache */
      for (i=0; i != nL2; i++) j += L2[i];  /* invalidate L2 cache */
   }

   if (strcasecmp(rout,blas[L3_TRMM]) == 0)
   {
      t0 = time00();
      test_trmm(SIc, ULc, TRc, DIc, M, N, alpha, A, lda, C, ldc);
      t2 = time00() - t0;
   }
   else
   {
      t0 = time00();
      test_trsm(SIc, ULc, TRc, DIc, M, N, alpha, A, lda, C, ldc);
      t2 = time00() - t0;
   }

   if (t2 <= 0.0) t2 = mflop = 0.0;
   else if (SI == 'L')
   {
      #ifdef TCPLX
         mflop = ( ((4.0*M)*M)*N ) / (t2*MEGA);
      #else
         mflop = ( ((1.0*M)*M)*N ) / (t2*MEGA);
      #endif
   }
   else 
   {
      #ifdef TCPLX
         mflop = ( ((4.0*M)*N)*N ) / (t2*MEGA);
      #else
         mflop = ( ((1.0*M)*N)*N ) / (t2*MEGA);
      #endif
   }
#ifdef DEBUG
   printmat("C", M, N, C, ldc);
#endif
   if (TEST)
   {
      if (strcasecmp(rout,blas[L3_TRMM]) == 0)
      {
         Mjoin(PATL,gediff)(M,N,B,ldb,C,ldc,B,ldb);
         normC = Mjoin(PRE,genorm)(M,N,B,ldb);
         if (SIc == AtlasLeft)
            normA = Mjoin(PRE,trnorm)(ULc, DIc, M,A,lda);
         else
            normA = Mjoin(PRE,trnorm)(ULc, DIc, N,A,lda);
         normB = Mjoin(PRE,genorm)(M,N,cB,ldb);
      }
      else
      {
         normB = Mjoin(PRE,genorm)(M,N,B,ldb);
         trusted_trmm(SIc, ULc, TRc, DIc, M, N, alpha1, A, lda, C, ldc);
         if (SIc == AtlasLeft)
            normA = Mjoin(PRE,trnorm)(ULc,DIc,M,A,lda);
         else
            normA = Mjoin(PRE,trnorm)(ULc,DIc,N,A,lda);
         Mjoin(PRE,gemscal)(M,N,cB,ldb,alpha);
         Mjoin(PATL,gediff)(M,N,cB,ldb,C,ldc,cB,ldb);
         normC = Mjoin(PRE,genorm)(M,N,cB,ldb);
      }
      if (normA > 0.0 && normB > 0.0 && SCALAR_ABS(alpha) > 0.0 )
         ferr = normC / ( normA * normB * eps * Maxval2(M,N) * SCALAR_ABS(alpha) );
      else 
         ferr = 0.0;
      if (ferr > 1.0 ){
         passed = 0;
         pc = "NO";
         printf("ERROR: ferr is %f\n",ferr);
      } 
      else 
      {
         passed = 1;
         pc = "YES";
      }
   }
   if (t1 == t2) t3 = 1.0;
   else if (t2 != 0.0) t3 = t1/t2;
   else t3 = 0.0;
   printf(form, (*itst)++, SI, UL, TR, DI, M, N, MALPH, t2, mflop, t3, pc);
#else
   (*itst)++;
   passed = 1;
#endif
   free(cB);
   if (pL2) free(pL2);
   return(passed);
}
void trloop(char *rout,
            int nside, enum ATLAS_SIDE *Side, 
            int nuplo, enum ATLAS_UPLO *Uplo,
            int ntrans, enum ATLAS_TRANS *Trans,
            int ndiag, enum ATLAS_DIAG *Diag,
            int M0, int MN, int incM, 
            int N0, int NN, int incN, 
            int nalph, TYPE *alph, 
            int TEST, int LDA_IS_M, int *gtst, int *gpass)
{
   int m, n, is, iu, it, id, ia, lda, ldb;
   int itst=0, ipass=0, SAME=0;
   TYPE *A, *B, *C;
   char SI, UL, TR, DI; 
   extern char *pre;
   
   if (M0 == -1)
   {
      SAME = 1;
      M0 = MN = incM = NN;
   }

   if (MN >= NN)
   {
      A = malloc(MN*MN*ATL_sizeof);
      B = malloc(MN*MN*ATL_sizeof);
      C = malloc(MN*MN*ATL_sizeof);
   }
   else 
   {
      A = malloc(NN*NN*ATL_sizeof);
      B = malloc(NN*NN*ATL_sizeof);
      C = malloc(NN*MN*ATL_sizeof);
   }
   if (!A || !B || !C)
   {
      fprintf(stderr, "Not enough memory to run tests!!\n");
      exit(-1);
   }

   if (strcasecmp(rout,blas[L3_TRMM]) == 0)
      printf("\n%cTRMM\n",Mupcase(pre[0]));
   else
      printf("\n%cTRSM\n",Mupcase(pre[0]));
#ifdef TREAL
   printf("TEST  SI UL TA DI    M    N  alpha           Time  Mflop  SpUp  PASS\n");
   printf("====  == == == == ==== ====  =====         ======  =====  ====  ====\n\n");
#else
printf("\nTEST SI UL TA DI    M    N        alpha                 Time  Mflop SpUp PASS\n");
  printf("==== == == == == ==== ====  ===== =====               ====== ====== ==== ====\n\n");
#endif
   for (m=M0; m <= MN; m += incM) 
   {
      for (n=N0; n <= NN; n += incN) 
      {
         if (SAME) m = n;
         for (is=0; is != nside; is++) 
         {
            if (Side[is] == AtlasRight) SI = 'R';
            else SI = 'L';
            for (iu=0; iu != nuplo; iu++) 
            {
               if (Uplo[iu] == AtlasUpper) UL = 'U';
               else UL = 'L';
               for (it=0; it != ntrans; it++)
               {
                  if (Trans[it] == AtlasNoTrans) TR = 'N';
                  else if (Trans[it] == AtlasTrans) TR = 'T';
                  else if (Trans[it] == AtlasConjTrans) TR = 'C';
                  for (id=0; id != ndiag; id++)
                  {
                     if (Diag[id] == AtlasNonUnit) DI = 'N';
                     else DI = 'U';
                     for (ia=0; ia != nalph; ia++) 
                     {
                        itst++;
                        if (LDA_IS_M)
                        {
                           if (Side[is] == AtlasLeft) lda = m;
                           else lda = n;
                           ldb = m;
                        }
                        else
                        {
                           if (Side[is] == AtlasLeft) lda = MN;
                           else lda = NN;
                           ldb = MN;
                        }
#ifdef TREAL
                        ipass += trcase(rout, SI, UL, TR, DI,
                              m, n, alph[ia], A, lda, 
                              B, ldb, C, ldb, 
                              TEST);
#else
                        ipass += trcase(rout, SI, UL, TR, DI,
                              m, n, &alph[2*ia], A, lda, 
                              B, ldb, C, ldb, 
                              TEST);
#endif
                     }
                  }
               }
            }
         }
      }
   }
   if (TEST) printf("\nNTEST=%d, NUMBER passed=%d, NUMBER FAILURES=%d\n",
         itst, ipass, itst-ipass);
   else printf("\nDone with %d timing runs\n",itst);
   *gtst += itst; *gpass += ipass;
   free(A);
   free(B);
   free(C);
}

void PrintUsage(char *nam)
{
   fprintf(stderr, "USAGE: %s -R <rout> -Side <nsides> L/R -Uplo <nuplo> L/U -Atrans <ntrans> n/t/c -Btrans <ntrans> n/t/c -Diag <ndiags> N/U -M <m1> <mN> <minc> -N <n1> <nN> <ninc> -K <k1> <kN> <kinc> -n <n> -m <m> -k <k> -a <nalphas> <alpha1> ... <alphaN> -b <nbetas> <beta1> ... <betaN> -Test <0/1>\n", nam);
   exit(-1);
}

void GetFlags(int nargs, char *args[], int *TEST, int *nside,
              enum ATLAS_SIDE **Side, int *nuplo, enum ATLAS_UPLO **Uplo, 
              int *nta, enum ATLAS_TRANS **TransA, 
              int *ntb, enum ATLAS_TRANS **TransB, int *ndiag,
              enum ATLAS_DIAG **Diag, int *M0, int *MN, int *Minc, 
              int *N0, int *NN, int *Ninc, int *K0, int *KN, int *Kinc,
              int *nalphas, TYPE **alphas, int *nbetas, TYPE **betas,
              int *nrouts, char ***routs, int *LDA_IS_M)

{
   char ch;
   int i=1, j, k,l=0;
/*
 * Set up defaults
 */
   *TEST = 1;
   *M0 = *N0 = *K0 = -1;
   *nrouts = *nuplo = *nta = *ntb = *nside = *ndiag = *nalphas = *nbetas = -1;
   *LDA_IS_M = 0;

   fprintf(stdout, "\n\n");
   for (i=0; i < NARGS; i++) fprintf(stdout, "%s ", ARGS[i]);
   fprintf(stdout, "\n\n");
   for (i=1; i < nargs ; )
   {
      if ( args[i][0] != '-' ) PrintUsage(args[0]);
      switch(args[i++][1])
      {
      case 'S':
         if (args[i] == NULL) PrintUsage(args[0]);
         *nside = atoi(args[i++]);
         if (*nside <= 0) PrintUsage(args[0]);
         *Side = malloc(*nside * sizeof(int));
         assert(*Side);
         for (j=0; j != *nside; j++)
         {
            if (args[i] == NULL) PrintUsage(args[0]);
            ch = *args[i++];
            if (ch == 'r' || ch == 'R') (*Side)[j] = AtlasRight;
            else if (ch == 'l' || ch == 'L') (*Side)[j] = AtlasLeft;
            else PrintUsage(args[0]);
         }
         break;
      case 'U':
         if (args[i] == NULL) PrintUsage(args[0]);
         *nuplo = atoi(args[i++]);
         if (*nuplo <= 0) PrintUsage(args[0]);
         *Uplo = malloc(*nuplo * sizeof(int));
         assert(*Uplo);
         for (j=0; j != *nuplo; j++)
         {
            if (args[i] == NULL) PrintUsage(args[0]);
            ch = *args[i++];
            if (ch == 'u' || ch == 'U') (*Uplo)[j] = AtlasUpper;
            else if (ch == 'l' || ch == 'L') (*Uplo)[j] = AtlasLower;
            else PrintUsage(args[0]);
         }
         break;
      case 'D':
         if (args[i] == NULL) PrintUsage(args[0]);
         *ndiag = atoi(args[i++]);
         if (*ndiag <= 0) PrintUsage(args[0]);
         *Diag = malloc(*ndiag * sizeof(int));
         assert(*Diag);
         for (j=0; j != *ndiag; j++)
         {
            if (args[i] == NULL) PrintUsage(args[0]);
            ch = *args[i++];
            if (ch == 'u' || ch == 'U') (*Diag)[j] = AtlasUnit;
            else if (ch == 'n' || ch == 'N') (*Diag)[j] = AtlasNonUnit;
            else PrintUsage(args[0]);
         }
         break;
      case 'A':
         if (args[i] == NULL) PrintUsage(args[0]);
         *nta   = atoi(args[i++]);
         if (*nta <= 0) PrintUsage(args[0]);
         *TransA = malloc(*nta * sizeof(int));
         assert(*TransA);
         for (j=0; j != *nta; j++)
         {
            if (args[i] == NULL) PrintUsage(args[0]);
            ch = *args[i++];
            if (ch == 'n' || ch == 'N') (*TransA)[j] = AtlasNoTrans;
            else if (ch == 't' || ch == 'T') (*TransA)[j] = AtlasTrans;
            else if (ch == 'c' || ch == 'C') (*TransA)[j] = AtlasConjTrans;
            else PrintUsage(args[0]);
         }
         break;
      case 'B':
         if (args[i] == NULL) PrintUsage(args[0]);
         *ntb   = atoi(args[i++]);
         if (*ntb <= 0) PrintUsage(args[0]);
         *TransB = malloc(*ntb * sizeof(int));
         assert(*TransB);
         for (j=0; j != *ntb; j++)
         {
            if (args[i] == NULL) PrintUsage(args[0]);
            ch = *args[i++];
            if (ch == 'n' || ch == 'N') (*TransB)[j] = AtlasNoTrans;
            else if (ch == 't' || ch == 'T') (*TransB)[j] = AtlasTrans;
            else if (ch == 'c' || ch == 'C') (*TransB)[j] = AtlasConjTrans;
            else PrintUsage(args[0]);
         }
         break;
       case 'C':
	 if( args[i] == NULL ) PrintUsage( args[0] );
	 *CACHESIZE = 1024*atoi(args[++i]);
	 break;
      case 'M':
         if (args[i] == NULL) PrintUsage(args[0]);
         *M0 = atoi(args[i++]);
         if (*M0 < 0) PrintUsage(args[0]);
         if (args[i] == NULL) PrintUsage(args[0]);
         *MN = atoi(args[i++]);
         if (*MN < 0) PrintUsage(args[0]);
         if (args[i] == NULL) PrintUsage(args[0]);
         *Minc = atoi(args[i++]);
         if (*Minc <= 0) PrintUsage(args[0]);
         break;
      case 'N':
         if (args[i] == NULL) PrintUsage(args[0]);
         *N0 = atoi(args[i++]);
         if (*N0 < 0) PrintUsage(args[0]);
         if (args[i] == NULL) PrintUsage(args[0]);
         *NN = atoi(args[i++]);
         if (*NN < 0) PrintUsage(args[0]);
         if (args[i] == NULL) PrintUsage(args[0]);
         *Ninc = atoi(args[i++]);
         if (*Ninc <= 0) PrintUsage(args[0]);
         break;
      case 'K':
         if (args[i] == NULL) PrintUsage(args[0]);
         *K0 = atoi(args[i++]);
         if (*K0 < 0) PrintUsage(args[0]);
         if (args[i] == NULL) PrintUsage(args[0]);
         *KN = atoi(args[i++]);
         if (*KN < 0) PrintUsage(args[0]);
         if (args[i] == NULL) PrintUsage(args[0]);
         *Kinc = atoi(args[i++]);
         if (*Kinc <= 0) PrintUsage(args[0]);
         break;
      case 'T':
         if (args[i] == NULL) PrintUsage(args[0]);
         *TEST = atoi(args[i++]);
         break;
      case 'R':
         if (args[i] == NULL) PrintUsage(args[0]);
         if (isdigit(*args[i]))
         {
            *nrouts = atoi(args[i++]);
            *routs = malloc( (*nrouts) * sizeof(char *) );
            assert(*routs);
         }
         else
         {
            *nrouts = 1;
            *routs = malloc( sizeof(char *) );
            assert(*routs);
         }
         for (j=0; j < *nrouts; j++)
         {
            if (args[i] == NULL) PrintUsage(args[0]);
            for (k=0; k < L3_nrouts; k++)
            {
               if (strcasecmp(args[i],blas[k]) == 0)
               {
                  l = 1;
                  (*routs)[j] = blas[k];
                  break;
               }
            }
            if (!l) 
            {
               if (strcasecmp(args[i],"all") == 0 && *nrouts == 1)
               {
                  free(*routs);
                  *nrouts = L3_nrouts;
                  *routs = malloc( (*nrouts) * sizeof(char *) );
                  L3_copyrouts(*routs);
                  i++;
                  break;
               }
               else PrintUsage(args[0]);
            }
            l = 0;
            i++;
         } 
         break;
      case 'm':
         if (args[i] == NULL) PrintUsage(args[0]);
         *M0 = *MN = atoi(args[i++]);
         *Minc = 1;
         if (*M0 <= 0) PrintUsage(args[0]);
         break;
      case 'n':
         if (args[i] == NULL) PrintUsage(args[0]);
         *N0 = *NN = atoi(args[i++]);
         *Ninc = 1;
         if (*N0 < 0) PrintUsage(args[0]);
         break;
      case 'k':
         if (args[i] == NULL) PrintUsage(args[0]);
         *K0 = *KN = atoi(args[i++]);
         *Kinc = 1;
         if (*K0 <= 0) PrintUsage(args[0]);
         break;
      case 'a':
         if (args[i] == NULL) PrintUsage(args[0]);
         *nalphas = atoi(args[i++]);
         if (*nalphas <= 0)  PrintUsage(args[0]);
         *alphas = malloc(ATL_MulBySize(*nalphas ));
         assert(*alphas);
         for (j=0; j < *nalphas SHIFT; j++)
         {
            if (args[i] == NULL) PrintUsage(args[0]);
            (*alphas)[j] = atof(args[i++]);
         }
         break;
      case 'b':
         if (args[i] == NULL) PrintUsage(args[0]);
         *nbetas  = atoi(args[i++]);
         if (*nbetas <= 0)  PrintUsage(args[0]);
         *betas  = malloc(ATL_MulBySize(*nbetas ));
         assert(*betas );
         for (j=0; j < *nbetas SHIFT; j++)
         {
            if (args[i] == NULL) PrintUsage(args[0]);
            (*betas)[j] = atof(args[i++]);
         }
         break;
      case 'd':
         *LDA_IS_M  = atoi(args[i++]);
         break;
      default:
         PrintUsage(args[0]);
         break;
      }
   }
/*
 * Finish setting up defaults if the user has not selected
 */
   if (*N0 == -1)
   {
      *N0 = 100;
      *NN = 1000;
      *Ninc = 100;
   }
   if (*nside == -1)
   {
      *nside = 1;
      *Side = malloc(sizeof(int));
      assert(*Side);
      **Side = AtlasLeft;
   }
   if (*nuplo == -1)
   {
      *nuplo = 1;
      *Uplo = malloc(sizeof(int));
      assert(*Uplo);
      **Uplo = AtlasLower;
   }
   if (*nta == -1)
   {
      *nta = 1;
      *TransA = malloc(sizeof(int));
      assert(*TransA);
      **TransA = AtlasNoTrans;
   }
   if (*ntb == -1)
   {
      *ntb = 1;
      *TransB = malloc(sizeof(int));
      assert(*TransB);
      **TransB = AtlasNoTrans;
   }
   if (*ndiag == -1)
   {
      *ndiag = 1;
      *Diag = malloc(sizeof(int));
      assert(*Diag);
      **Diag = AtlasNonUnit;
   }
   if (*nalphas == -1)
   {
      *nalphas = 1;
      *alphas = malloc(ATL_MulBySize(1));
      assert(*alphas);
      #ifdef TREAL
         **alphas = 1.0;
      #else
         **alphas = 1.0;
         (*alphas)[1] = 0.0;
      #endif
   }
   if (*nbetas  == -1)
   {
      *nbetas  = 1;
      *betas  = malloc(ATL_MulBySize(1));
      assert(*betas );
      #ifdef TREAL
         **betas  = 1.0;
      #else
         **betas  = 1.0;
         (*betas)[1] = 0.0;
      #endif
   }
   if (*nrouts == -1)
   {
     *nrouts = 1;
     *routs = malloc( sizeof(char *) );
     assert(*routs);
     (*routs)[0] = blas[L3_GEMM];
   }
}

int main(int nargs, char *args[])
/*
 *  tst <tst> <# TA> <TA's> <# TB's> <TB's> <M0> <MN> <incM> <N0> <NN> <incN>
 *      <K0> <KN> <incK> <# alphas> <alphas> <# betas> <betas>
 *          
 */
{
   int i=0, M0=-1, MN=-1, incM=-1, N0=-1, NN=-1, incN=-1, K0=-1, KN=-1;
   int incK=-1, gtst=0, gpass=0, nalph=-1, nbeta=-1, ndiag=-1, nuplo=-1;
   int nside=-1, nrouts=-1, nTA=-1, nTB=-1, TEST=1, LDA_IS_M=1;
   TYPE *alph, *beta;
   char **rout;
   enum ATLAS_SIDE *Side; 
   enum ATLAS_UPLO *Uplo;
   enum ATLAS_TRANS *TransA, *TransB;
   enum ATLAS_DIAG *Diag;
   extern TYPE eps;
#if 1
   eps = Mjoin(PATL,epsilon)();
#else
   eps = EPS;
#endif
#ifdef DEBUG
   printf("epsilon=%e\n",eps);
#endif

   GetFlags(nargs, args, &TEST, &nside, &Side, &nuplo, &Uplo, 
            &nTA, &TransA, &nTB, &TransB, &ndiag, &Diag, 
            &M0, &MN, &incM, &N0, &NN, &incN, &K0, &KN, &incK,
            &nalph, &alph, &nbeta, &beta, &nrouts, &rout, &LDA_IS_M);

   for (i=0; i < nrouts; i++)
   {
      if (strcasecmp(rout[i],blas[L3_GEMM]) == 0)      /* GEMM */
         gemmloop(nTA,TransA, nTB,TransB,
                  M0,MN,incM, N0,NN,incN, K0,KN,incK,
                  nalph,alph, nbeta,beta,
                  TEST,LDA_IS_M,&gtst,&gpass);
      else if (strcasecmp(rout[i],blas[L3_SYMM]) == 0) /* SYMM */
         syhemmloop(blas[L3_SYMM],nside,Side, nuplo,Uplo,
                  M0,MN,incM, N0,NN,incN,
                  nalph,alph, nbeta,beta,
                  TEST,LDA_IS_M,&gtst,&gpass);
     #ifdef TCPLX
      else if (strcasecmp(rout[i],blas[L3_HEMM]) == 0) /* HEMM */
         syhemmloop(blas[L3_HEMM],nside,Side, nuplo,Uplo,
                  M0,MN,incM, N0,NN,incN,
                  nalph,alph, nbeta,beta,
                  TEST,LDA_IS_M,&gtst,&gpass);
     #endif
      else if (strcasecmp(rout[i],blas[L3_SYRK]) == 0) /* SYRK */
         syherkloop(blas[L3_SYRK],nuplo,Uplo, nTA,TransA,
                  N0,NN,incN, K0,KN,incK,
                  nalph,alph, nbeta,beta,
                  TEST,LDA_IS_M,&gtst,&gpass);
     #ifdef TCPLX
      else if (strcasecmp(rout[i],blas[L3_HERK]) == 0) /* HERK */
         syherkloop(blas[L3_HERK],nuplo,Uplo, nTA,TransA,
                  N0,NN,incN, K0,KN,incK,
                  nalph,alph, nbeta,beta,
                  TEST,LDA_IS_M,&gtst,&gpass);
     #endif
      else if (strcasecmp(rout[i],blas[L3_SYR2K]) == 0) /* SYR2K */
         syher2kloop(blas[L3_SYR2K],nuplo,Uplo, nTA,TransA,
                  N0,NN,incN, K0,KN,incK,
                  nalph,alph, nbeta,beta,
                  TEST,LDA_IS_M,&gtst,&gpass);
     #ifdef TCPLX
      else if (strcasecmp(rout[i],blas[L3_HER2K]) == 0) /* HER2K */
         syher2kloop(blas[L3_HER2K],nuplo,Uplo, nTA,TransA,
                  N0,NN,incN, K0,KN,incK,
                  nalph,alph, nbeta,beta,
                  TEST,LDA_IS_M,&gtst,&gpass);
     #endif
      else if (strcasecmp(rout[i],blas[L3_TRMM]) == 0) /* TRMM */
         trloop(blas[L3_TRMM],
                  nside,Side, nuplo,Uplo, nTA,TransA, ndiag,Diag,
                  M0,MN,incM, N0,NN,incN,
                  nalph,alph,
                  TEST,LDA_IS_M,&gtst,&gpass);
      else if (strcasecmp(rout[i],blas[L3_TRSM]) == 0) /* TRSM */
         trloop(blas[L3_TRSM],
                  nside,Side, nuplo,Uplo, nTA,TransA, ndiag,Diag,
                  M0,MN,incM, N0,NN,incN,
                  nalph,alph,
                  TEST,LDA_IS_M,&gtst,&gpass);
   }

   if (nrouts > 1)
   {
   if (TEST)
      printf("\nGRAND TOTAL: NTEST=%d, NUMBER passed=%d, NUMBER FAILURES=%d\n",
             gtst, gpass,gtst-gpass);
   else 
      printf("\nGRAND TOTAL: NTEST=%d\n",gtst);
   }

   free( Side   );
   free( Uplo   );
   free( TransA );
   free( TransB );
   free( Diag   );
   free( alph   );
   free( beta   );
   free( rout   );

   return 0;
}
@rout !
