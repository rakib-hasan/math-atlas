@ROUT ATL_geqr2
@extract -b @(topd)/cw.inc lang=C -def cwdate 2009 -def cwauth "Siju Samuel" -def contrib "Anthony M. Castaldo, R. Clint Whaley"

/*
 * This is the C translation of the standard LAPACK Fortran routine:
 *      SUBROUTINE DGEQR2( M, N, A, LDA, TAU, WORK, INFO )
 *
 * ATL_geqr2.c :
 * int ATL_geqr2( const int M, const int N, TYPE *A, int LDA,
 *                                                      TYPE  *TAU, TYPE *WORK)
 *     NOTE :a)   ATL_geqr2.c will get compiled to four precisions
 *               single precision real,      double precision real
 *               single precision complex,   double precision complex
 *
 *           b) This routine will not validate the input parameters.
 *  Purpose
 *  =======
 *
 *  ATL_geqr2  computes a QR factorization of a real/complex  m by n matrix A:
 *  A = Q * R.
 *
 *  Arguments
 *  =========
 *
 *  M       (input) INTEGER
 *          The number of rows of the matrix A.  M >= 0.
 *
 *  N       (input) INTEGER
 *          The number of columns of the matrix A.  N >= 0.
 *
 *  A       (input/output) array, dimension (LDA,N)
 *          On entry, the m by n matrix A.
 *          On exit, the elements on and above the diagonal of the array
 *          contain the min(m,n) by n upper trapezoidal matrix R (R is
 *          upper triangular if m >= n); the elements below the diagonal,
 *          with the array TAU, represent the orthogonal matrix Q
 *          (unitary matrix incase of complex precision )  as a
 *          product of elementary reflectors (see Further Details).
 *
 *  LDA     (input) INTEGER
 *          The leading dimension of the array A.  LDA >= max(1,M).
 *
 *  TAU     (output) array, dimension (min(M,N))
 *          The scalar factors of the elementary reflectors (see Further
 *          Details).
 *
 *  WORK    (workspace)  array, dimension (N)
 *
 *  INFO    (output) INTEGER
 *          = 0: successful exit
 *          < 0: if INFO = -i, the i-th argument had an illegal value
 *
 *  Further Details
 *  ===============
 *
 *  The matrix Q is represented as a product of elementary reflectors
 *
 *     Q = H(1) H(2) . . . H(k), where k = min(m,n).
 *                                             (for Real/Complex Precision)
 *  Each H(i) has the form
 *
 *     H(i) = I - tau * v * v'                 (for Real Precision)
 *     H(i) = I - tau * v * conjugate(v)'      (for Complex  Precision)        
 *
 *  where tau is a real/complex  scalar, and v is a real/complex vector with
 *  v(1:i-1) = 0 and v(i) = 1; v(i+1:m) is stored on exit in A(i+1:m,i),
 *  and tau in TAU(i).
 */

#include "atlas_misc.h"
#include "cblas.h"
#include "atlas_lapack.h"
#define NOARRS 1
/* #include Mstr(Mjoin(ATLAS_PRE,oprk_perf.h)) */
#undef NOARRS


int ATL_geqr2(ATL_CINT M, ATL_CINT N, TYPE *A, ATL_CINT LDA, TYPE  *TAU,
              TYPE *WORK)
{
   int lda2 = LDA  SHIFT;                   

   #ifdef TREAL
      const TYPE ONE = ATL_rone;
      TYPE AII ;
      TYPE TAUVAL ;
   #else
      const TYPE ONE[2] = {ATL_rone, ATL_rzero};
      TYPE AII[2];
      TYPE TAUVAL[2] ;
   #endif

   int i, k;

   k = (M < N)?M:N;                         

   for (i=0; i<k; i++)
   {
/*
 *    Generate elementary reflector H(i) to annihilate A(i+1:m,i)
 */
      int t=((i+1)<(M-1))?(i+1):(M-1);      
      ATL_larfg((M-i), (A+(i SHIFT)+i*lda2),
                (A+(t SHIFT)+i*lda2), 1, (TAU+(i SHIFT)) );

/*    If not last column                   */
      if (i < (N-1))                        /* If not last column,            */
      {
/*
 *       Apply H(i) to A(i:m,i+1:n) from the left
 */
         #ifdef TREAL
            AII = A[i+i*lda2];
            A[i+i*lda2] = ONE;
            TAUVAL = TAU[i];
         #else
            AII[0] = A[(i SHIFT)+i*lda2];
            AII[1] = A[(i SHIFT)+i*lda2 + 1];

            A[(i SHIFT)+i*lda2] = ONE[0];
            A[(i SHIFT)+i*lda2 + 1] = ONE[1];

            TAUVAL[0] = TAU[i SHIFT];
/*          Conjugate                 */
            TAUVAL[1] = 0.0 -TAU[(i SHIFT) + 1]; 
         #endif

         ATL_larf(CblasLeft, M-i, N-i-1, (A+(i SHIFT)+i*lda2), 1, TAUVAL ,
                  (A+(i SHIFT)+(i+1)*lda2) , LDA, WORK);

         /*  Reassign the values of A[i] */
         #ifdef TREAL
            A[(i SHIFT)+i*lda2] = AII;
         #else
            A[(i SHIFT) +i*lda2] = AII[0];
            A[(i SHIFT) +i*lda2 + 1] = AII[1];
         #endif
      }
   } /* END for each column. */
   return(0);
} /* END ATL_geqr2 */
@ROUT ATL_gerq2
@extract -b @(topd)/cw.inc lang=C -def cwdate 2009 -def cwauth "Siju Samuel" -def contrib "Anthony M. Castaldo, R. Clint Whaley"

/*
 * This is the C translation of the standard LAPACK Fortran routine:
 *     SUBROUTINE DGERQ2( M, N, A, LDA, TAU, WORK, INFO )
 *
 * ATL_gerq2.c :
 * int ATL_gerq2( const int M, const int N, TYPE *A, int LDA,
 *                                                      TYPE  *TAU, TYPE *WORK)
 *     NOTE :a)   ATL_gerq2.c will get compiled to four precisions
 *               single precision real,      double precision real
 *               single precision complex,   double precision complex
 *
 *           b) This routine will not validate the input parameters.
 *  Purpose
 *  =======
 *
 *  ATL_gerq2  computes a QR factorization of a real/complex  m by n matrix A:
 *  A = Q * R.
 *
 *  Arguments
 *  =========
 *
 *  M       (input) INTEGER
 *          The number of rows of the matrix A.  M >= 0.
 *
 *  N       (input) INTEGER
 *          The number of columns of the matrix A.  N >= 0.
 *
 *  A       (input/output)  array, dimension (LDA,N)
 *          On entry, the m by n matrix A.
 *          On exit, if m <= n, the upper triangle of the subarray
 *          A(1:m,n-m+1:n) contains the m by m upper triangular matrix R;
 *          if m >= n, the elements on and above the (m-n)-th subdiagonal
 *          contain the m by n upper trapezoidal matrix R; the remaining
 *          elements, with the array TAU, represent the orthogonal matrix
 *          (unitary matrix incase of complex precision )  as a
 *          as a product of elementary reflectors (see Further
 *          Details).
 *
 *  LDA     (input) INTEGER
 *          The leading dimension of the array A.  LDA >= max(1,M).
 *
 *  TAU     (output) DOUBLE PRECISION array, dimension (min(M,N))
 *          The scalar factors of the elementary reflectors (see Further
 *          Details).
 *
 *  WORK    (workspace) DOUBLE PRECISION array, dimension (M)
 *
 *  INFO    (output) INTEGER
 *          = 0: successful exit
 *          < 0: if INFO = -i, the i-th argument had an illegal value
 *
 *  Further Details
 *  ===============
 *
 *  The matrix Q is represented as a product of elementary reflectors
 *
 *     Q = H(1) H(2) . . . H(k), where k = min(m,n).    (for Real precison)
 *     Q = H(1)' H(2)' . . . H(k)', where k = min(m,n). (for Complex Precison)
 *         (Note : Conjugate Transpose of H is taken above)
 *
 *  Each H(i) has the form
 *
 *     H(i) = I - tau * v * v'                 (for Real Precision)
 *     H(i) = I - tau * v * conjugate(v)'      (for Complex  Precision)
 *
 *  where tau is a real scalar, and v is a real vector with
 *  v(n-k+i+1:n) = 0 and v(n-k+i) = 1; v(1:n-k+i-1) is stored on exit in
 *  A(m-k+i,1:n-k+i-1), and tau in TAU(i).
 */

#include "atlas_misc.h"
#include "cblas.h"
#include "atlas_lapack.h"
#define NOARRS 1
/* #include Mstr(Mjoin(ATLAS_PRE,oprk_perf.h)) */
#undef NOARRS

int ATL_gerq2(ATL_CINT M, ATL_CINT N, TYPE *A, ATL_CINT LDA, 
              TYPE *TAU, TYPE *WORK)
{
   int lda2 = LDA  SHIFT;                   /* for complex LDA*2              */

   #ifdef TREAL
      const TYPE ONE = ATL_rone;
      TYPE AII ;
      TYPE TAUVAL ;
   #else
      const TYPE ONE[2] = {ATL_rone, ATL_rzero};
      TYPE AII[2];
      TYPE TAUVAL[2] ;
   #endif

   int i, K;
   K = (M < N)?M:N;                         /* k is min(M,N)                  */

   for (i=K-1; i>=0 ; i--)
   {
/*
 *    Generate elementary reflector H(i) to annihilate
 *    A(m-k+i,1:n-k+i-1)
 */
      #ifdef TCPLX
/*       Applicable only to Complex Numbers                                   */
         ATL_lacgv(N-K+i+1, (A + ((M-K+i) SHIFT)), LDA);
      #endif

      ATL_larfg((N-K+i+1), (A +((M-K+i) SHIFT) + (N-K+i)*lda2 ),
                (A + ((M-K+i) SHIFT)), LDA, (TAU+(i SHIFT)) );

/*
 *    Apply H(i) to A(1:m-k+i-1,1:n-k+i) from the right
 */

      #ifdef TREAL
         AII = *(A + ((M-K+i) SHIFT)  + (N-K+i)*lda2 );
         *(A + ((M-K+i) SHIFT)  + (N-K+i)*lda2 ) = ONE;
         TAUVAL = TAU[i];
      #else
         AII[0] = *(A + ((M-K+i) SHIFT)  + (N-K+i)*lda2 );
         AII[1] = *(A + ((M-K+i) SHIFT)  + (N-K+i)*lda2 + 1 );

         *(A + ((M-K+i) SHIFT)  + (N-K+i)*lda2 ) = ONE[0];
         *(A + ((M-K+i) SHIFT)  + (N-K+i)*lda2 + 1 ) = ONE[1];

         TAUVAL[0] = TAU[i SHIFT];
         TAUVAL[1] = TAU[(i SHIFT) + 1];
      #endif

      ATL_larf(CblasRight, M-K+i, N-K+i+1, (A+((M-K+i) SHIFT)), LDA, TAUVAL,
               (A), LDA, WORK);

/*    Reassign the values of A[i]                                             */
      #ifdef TREAL
         *(A + ((M-K+i) SHIFT)  + (N-K+i)*lda2 ) = AII;
      #else
         *(A + ((M-K+i) SHIFT)  + (N-K+i)*lda2 ) = AII[0];
         *(A + ((M-K+i) SHIFT)  + (N-K+i)*lda2 + 1 ) = AII[1];
      #endif

      #ifdef TCPLX
         ATL_lacgv(N-K+i, (A + ((M-K+i) SHIFT)), LDA);
      #endif

   }                                        /* end of for                     */

   return(0);
}                                           /* END AL_gerq2                   */
@ROUT ATL_geql2
@extract -b @(topd)/cw.inc lang=C -def cwdate 2009 -def cwauth "Siju Samuel" -def contrib "Anthony M. Castaldo, R. Clint Whaley"

/*
 * This is the C translation of the standard LAPACK Fortran routine:
 *      SUBROUTINE DGEQL2( M, N, A, LDA, TAU, WORK, INFO )
 *
 * ATL_geql2.c :
 *
 * int ATL_geql2( const int M, const int N, TYPE *A, int LDA,
 *                                                      TYPE  *TAU, TYPE *WORK)
 *     NOTE :a)  ATL_geql2.c will get compiled to four precisions
 *               single precision real,      double precision real
 *               single precision complex,   double precision complex
 *
 *           b) This routine will not validate the input parameters.
 *
 *
 *  Purpose
 *  =======
 *
 *  ATL_geql2 computes a QL factorization of a real/complex m by n matrix A:
 *  A = Q * L.
 *
 *  Arguments
 *  =========
 *
 *  M       (input) INTEGER
 *          The number of rows of the matrix A.  M >= 0.
 *
 *  N       (input) INTEGER
 *          The number of columns of the matrix A.  N >= 0.
 *
 *  A       (input/output) array, dimension (LDA,N)
 *          On entry, the m by n matrix A.
 *          On exit, if m >= n, the lower triangle of the subarray
 *          A(m-n+1:m,1:n) contains the n by n lower triangular matrix L;
 *          if m <= n, the elements on and below the (n-m)-th
 *          superdiagonal contain the m by n lower trapezoidal matrix L;
 *          the remaining elements, with the array TAU, represent the
 *          orthogonal matrix Q ((unitary matrix incase of complex precision )
 *          as a product of elementary reflectors (see Further Details).
 *
 *  LDA     (input) INTEGER
 *          The leading dimension of the array A.  LDA >= max(1,M).
 *
 *  TAU     (output) array, dimension (min(M,N))
 *          The scalar factors of the elementary reflectors (see Further
 *          Details).
 *
 *  WORK    (workspace) array, dimension (N)
 *
 *  INFO    (output) INTEGER
 *          = 0: successful exit
 *          < 0: if INFO = -i, the i-th argument had an illegal value
 *
 *  Further Details
 *  ===============
 *
 *  The matrix Q is represented as a product of elementary reflectors
 *
 *     Q = H(k) . . . H(2) H(1), where k = min(m,n).
 *                                             (for Real/Complex Precisions)
 *
 *  Each H(i) has the form
 *
 *     H(i) = I - tau * v * v'                 (for Real Precision)
 *     H(i) = I - tau * v * conjugate(v)'      (for Complex  Precision)
 *
 *
 *  where tau is a real scalar, and v is a real vector with
 *  v(m-k+i+1:m) = 0 and v(m-k+i) = 1; v(1:m-k+i-1) is stored on exit in
 *  A(1:m-k+i-1,n-k+i), and tau in TAU(i).
 */

#include "atlas_misc.h"
#include "cblas.h"
#include "atlas_lapack.h"
#define NOARRS 1
/* #include Mstr(Mjoin(ATLAS_PRE,oprk_perf.h)) */
#undef NOARRS

int ATL_geql2(ATL_CINT M, ATL_CINT N, TYPE *A, ATL_CINT LDA, 
              TYPE *TAU, TYPE *WORK)
{
   const int lda2 = LDA  SHIFT;             /* for complex LDA*2              */

   #ifdef TREAL
      const TYPE ONE = ATL_rone;
      TYPE AII ;
      TYPE TAUVAL ;
   #else
      const TYPE ONE[2] = {ATL_rone, ATL_rzero};
      TYPE AII[2];
      TYPE TAUVAL[2] ;
   #endif

   int i, K;

   K = (M < N)?M:N;                         /* k is min(M,N)                  */

   for (i=K-1; i>=0; i--)
   {
/*    Generate elementary reflector H(i) to annihilate
 *    A(1:m-k+i-1,n-k+i)
 */
      ATL_larfg((M-K+i+1), (A +((M-K+i) SHIFT) + (N-K+i)*lda2),
                (A + ((N-K+i)*lda2 )), 1, (TAU+(i SHIFT)) );

/*
 *    Apply H(i) to A(1:m-k+i,1:n-k+i-1) from the left
 */

      #ifdef TREAL
         AII = *(A + ((M-K+i) SHIFT)  + (N-K+i)*lda2 );
          *(A + ((M-K+i) SHIFT)  + (N-K+i)*lda2 ) = ONE;
         TAUVAL = TAU[i];
      #else
         AII[0] = *(A + ((M-K+i) SHIFT)  + (N-K+i)*lda2 );
         AII[1] = *(A + ((M-K+i) SHIFT)  + (N-K+i)*lda2 + 1 );

         *(A + ((M-K+i) SHIFT)  + (N-K+i)*lda2 ) = ONE[0];
         *(A + ((M-K+i) SHIFT)  + (N-K+i)*lda2 + 1 ) = ONE[1];

         TAUVAL[0] = TAU[i SHIFT];
         TAUVAL[1] = 0.0 - TAU[(i SHIFT) + 1];   /* Conjugate for complex     */
      #endif

      ATL_larf(CblasLeft, M-K+i+1, N-K+i, (A + ((N-K+i)*lda2 )), 1, TAUVAL ,
               (A) , LDA, WORK);    

/*    Reassign the values of A[i]                                             */
      #ifdef TREAL
         *(A + ((M-K+i) SHIFT)  + (N-K+i)*lda2 ) = AII;
      #else
         *(A + ((M-K+i) SHIFT)  + (N-K+i)*lda2 ) = AII[0];
         *(A + ((M-K+i) SHIFT)  + (N-K+i)*lda2 + 1 ) = AII[1];
      #endif

   }                                        /* end of for                     */

   return(0);
}                                           /* END AL_geql2                   */


@ROUT ATL_gelq2
@extract -b @(topd)/cw.inc lang=C -def cwdate 2009 -def cwauth "Siju Samuel" -def contrib "Anthony M. Castaldo, R. Clint Whaley"

/*
 * This is the C translation of the standard LAPACK Fortran routine:
 *      SUBROUTINE DGELQ2( M, N, A, LDA, TAU, WORK, INFO )
 *
 * ATL_gelq2.c :
 * int ATL_gelq2( const int M, const int N, TYPE *A, int LDA,
 *                                                      TYPE  *TAU, TYPE *WORK)
 *     NOTE :a)   ATL_gelq2.c will get compiled to four precisions
 *               single precision real,      double precision real
 *               single precision complex,   double precision complex
 *
 *           b) This routine will not validate the input parameters.
 *  Purpose
 *  =======
 *
 *  ATL_gelq2  computes an LQ factorization of a real m by n matrix A:
 *  A = L * Q.
 *
 *  Arguments
 *  =========
 *
 *          (unitary matrix incase of complex precision )  as a
 *
 *  Arguments
 *  =========
 *
 *  M       (input) INTEGER
 *          The number of rows of the matrix A.  M >= 0.
 *
 *  N       (input) INTEGER
 *          The number of columns of the matrix A.  N >= 0.
 *
 *  A       (input/output) array, dimension (LDA,N)
 *          On entry, the m by n matrix A.
 *          On exit, the elements on and below the diagonal of the array
 *          contain the m by min(m,n) lower trapezoidal matrix L (L is
 *          lower triangular if m <= n); the elements above the diagonal,
 *          with the array TAU, represent the orthogonal matrix Q
 *          (unitary matrix incase of complex precision )  as a
 *          product of elementary reflectors (see Further Details).
 *
 *  LDA     (input) INTEGER
 *          The leading dimension of the array A.  LDA >= max(1,M).
 *
 *  TAU     (output) DOUBLE PRECISION array, dimension (min(M,N))
 *          The scalar factors of the elementary reflectors (see Further
 *          Details).
 *
 *  WORK    (workspace) DOUBLE PRECISION array, dimension (M)
 *
 *  INFO    (output) INTEGER
 *          = 0: successful exit
 *          < 0: if INFO = -i, the i-th argument had an illegal value
 *
 *  Further Details
 *  ===============
 *
 *  The matrix Q is represented as a product of elementary reflectors
 *
 *     Q = H(k) . . . H(2) H(1), where k = min(m,n).    ( for Real precision)
 *     Q = H(1)' H(2)' . . . H(k)', where k = min(m,n). ( for Complex Precison)
 *         (Note : Conjugate Transpose of H is taken above)
 *
 *
 *  Each H(i) has the form
 *
 *     H(i) = I - tau * v * v'
 *
 *  where tau is a real/complex scalar, and v is a real/complex vector with
 *  v(1:i-1) = 0 and v(i) = 1; v(i+1:n) is stored on exit in A(i,i+1:n),
 *  and tau in TAU(i).
 */
#include "atlas_misc.h"
#include "cblas.h"
#include "atlas_lapack.h"
#define NOARRS 1
/* #include Mstr(Mjoin(ATLAS_PRE,oprk_perf.h)) */
#undef NOARRS

int ATL_gelq2(ATL_CINT M, ATL_CINT N, TYPE *A, ATL_CINT LDA, 
              TYPE  *TAU, TYPE *WORK)
{
   const int lda2 = LDA  SHIFT;             /* for complex LDA*2              */

   #ifdef TREAL
      const TYPE ONE = ATL_rone;
      TYPE AII ;
      TYPE TAUVAL ;
   #else
      const TYPE ONE[2] = {ATL_rone, ATL_rzero};
      TYPE AII[2];
      TYPE TAUVAL[2] ;
   #endif

   int i, K;

   K = (M < N)?M:N;                         /* k is min(M,N)                  */

   for (i=0; i<K; i++)
   {
/*
 *    Generate elementary reflector H(i) to annihilate A(i,i+1:n)
 */
      #ifdef TCPLX
/*       Applicable only to Complex Numbers : Make Conjugate                  */
         ATL_lacgv(N-i, (A+(i SHIFT)+i*lda2), LDA);   /* V vextor             */
      #endif
      int t=((i+1)<(N-1))?(i+1):(N-1);      /* t = min(i+1, N-1)              */

      ATL_larfg( (N-i), (A+(i SHIFT) + i*lda2), (A+ (i SHIFT) + (t*lda2) ),
                 LDA, (TAU+(i SHIFT)) );

      if (i < (M-1))                        /* If not last column,            */
      {
/*
 *      Apply H(i) to A(i+1:m,i:n) from the right
 *
 */
         #ifdef TREAL
            AII = A[i+i*lda2];
            A[i+i*lda2] = ONE;
            TAUVAL = TAU[i];
         #else
            AII[0] = A[(i SHIFT)+i*lda2];
            AII[1] = A[(i SHIFT)+i*lda2 + 1];

            A[(i SHIFT)+i*lda2] = ONE[0];
            A[(i SHIFT)+i*lda2 + 1] = ONE[1];

            TAUVAL[0] = TAU[i SHIFT];
            TAUVAL[1] = TAU[(i SHIFT) + 1];
         #endif

         ATL_larf(CblasRight, M-i-1, N-i, (A+(i SHIFT)+i*lda2), LDA,
                  TAUVAL, ( A+ ((i+1) SHIFT) + i*lda2 ) , LDA, WORK);

/*       Reassign the values of A[i]                                          */
         #ifdef TREAL
            A[(i SHIFT)+i*lda2] = AII;
         #else
            A[(i SHIFT) +i*lda2] = AII[0];
            A[(i SHIFT) +i*lda2 + 1] = AII[1];
         #endif
      }
      #ifdef TCPLX
/*       Applicable only to Complex Numbers : Make Conjugate                  */
         ATL_lacgv(N-i, (A+(i SHIFT)+i*lda2), LDA);  
      #endif
   }                                        /* end of for                     */

   return(0);
}                                           /* END ATL_gelq2                  */


@ROUT ATL_geqrf
@define rtn @geqrf@
@define rec @geqrr@
@define wks @ws_QR2@
@define btm @geqr2@
@ROUT ATL_geqlf
@define rtn @geqlf@
@define rec @geqlr@
@define wks @ws_QL2@
@define btm @geql2@
@ROUT ATL_gerqf
@define rtn @gerqf@
@define rec @gerqr@
@define wks @ws_RQ2@
@define btm @gerq2@
@ROUT ATL_gelqf
@define rtn @gelqf@ 
@define rec @gelqr@ 
@define wks @ws_LQ2@
@define btm @gelq2@

@ROUT ATL_geqrf ATL_geqlf ATL_gerqf ATL_gelqf

@extract -b @(topd)/cw.inc lang=C -def cwdate 2009 -def cwauth "Siju Samuel" -def contrib "Anthony M. Castaldo, R. Clint Whaley"

#include "atlas_misc.h"
#include "cblas.h"
#include "atlas_ptalias_lapack.h"
#include "atlas_lapack.h"
#define NOARRS 1
/* #include Mstr(Mjoin(ATLAS_PRE,oprk_perf.h)) */
#undef NOARRS

@beginskip
#if defined(ATL_TUNING)
/*-------------------------------------------------------*/
/* If PanelTune is non-zero, we use it as both NB *and*  */
/* a flag to stop after the first trailing update.       */
/*-------------------------------------------------------*/
   extern int ATL_PanelTune;
   #if defined(ATL_USEPTHREADS)
   #define ATL_@(rtn)_Tune Mjoin(Mjoin(PATL,t@(rtn)),_Tune)   /* Add tag */
   #define ATL_@(rec)_Tune Mjoin(Mjoin(PATL,t@(rec)),_Tune)   /* Add tag */
   #else
   #define ATL_@(rtn)_Tune Mjoin(Mjoin(PATL,@(rtn)),_Tune)    /* Add tag */
   #define ATL_@(rec)_Tune Mjoin(Mjoin(PATL,@(rec)),_Tune)    /* Add tag */
   #endif /* ATL_USEPTHREADS */
#else
   #if defined(ATL_USEPTHREADS)
   #define ATL_@(rtn)_Tune Mjoin(PATL,t@(rtn)) /* standard method. */
   #define ATL_@(rec)_Tune Mjoin(PATL,t@(rec)) /* standard method. */
   #else
   #define ATL_@(rtn)_Tune Mjoin(PATL,@(rtn))  /* standard method. */
   #define ATL_@(rec)_Tune Mjoin(PATL,@(rec))  /* standard method. */
   #endif /* ATL_USEPTHREADS */
#endif /* ATL_TUNING */

@endskip
@ROUT ATL_geqrf ATL_geqlf ATL_gerqf ATL_gelqf
@beginskip
int ATL_@(rec)_Tune(int M, int N, TYPE *A, int LDA, TYPE *TAU,
              TYPE *@(wks), TYPE *ws_T, int LDT,
              TYPE *WORKM, int buildT);
@endskip
#ifdef  SREAL
   #define MYOPT LASreal
#endif
#ifdef  DREAL
   #define MYOPT  LADreal
#endif
#ifdef  SCPLX
   #define MYOPT  LAScplx
#endif
#ifdef  DCPLX
   #define MYOPT  LADcplx
#endif

int ATL_@(rtn)(ATL_CINT M, ATL_CINT N, TYPE  *A, ATL_CINT lda, TYPE *TAU,
               TYPE *WORK, ATL_CINT LWORK)
/*
 * This is the C translation of the standard LAPACK Fortran routine:
 *      SUBROUTINE @(rtn)( M, N, A, LDA, TAU, WORK, LWORK, INFO )
 *
 * ATL_@(rtn).c :
 * int ATL_@(rtn)(int M, int N, TYPE  *A, int LDA, TYPE  *TAU,
 *              TYPE *WORK, int LWORK)
 *
 *  Purpose
 *  =======
 *
@ROUT ATL_geqrf
 *  ATL_geqrf  computes a QR factorization of a real/complex M-by-N matrix A:
 *  A = Q * R.
@ROUT ATL_geqlf
 *  ATL_geqlf  computes a QL factorization of a real/complex M-by-N matrix A:
 *  A = Q * L.
@ROUT ATL_gerqf
 *  ATL_gerqf  computes an RQ factorization of a real/complex M-by-N matrix A:
 *  A = R * Q.
@ROUT ATL_gelqf
 *  ATL_gelqf  computes an LQ factorization of a real/complex M-by-N matrix A:
 *  A = L * Q.
@ROUT ATL_geqrf ATL_geqlf ATL_gerqf ATL_gelqf
 *
 *  Compared to LAPACK, here, a recursive panel factorization is implemented.
 *  Refer to ATL_@(rec).c andd ATL_larft.c for details.
 *
 *  Arguments
 *  =========
 *
 *  M       (input) INTEGER
 *          The number of rows of the matrix A.  M >= 0.
 *
 *  N       (input) INTEGER
 *          The number of columns of the matrix A.  N >= 0.
 *
 *  A       (input/output) array, dimension (LDA,N)
 *          On entry, the M-by-N matrix A.
 *          On exit, the elements on and above the diagonal of the array
 *          contain the min(M,N)-by-N upper trapezoidal matrix R (R is
 *          upper triangular if m >= n); the elements below the diagonal,
 *          with the array TAU, represent the orthogonal matrix Q as a
 *          product of min(m,n) elementary reflectors (see Further
 *          Details).
 *
 *  LDA     (input) INTEGER
 *          The leading dimension of the array A.  LDA >= max(1,M).
 *
 *  TAU     (output) array, dimension (min(M,N))
 *          The scalar factors of the elementary reflectors (see Further
 *          Details).
 *
 *  WORK    (workspace/output) array, dimension (MAX(1,LWORK))
 *          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
 *
 *  LWORK   (input) INTEGER
 *          The dimension of the array WORK.  LWORK >= max(1,N).
 *          For optimum performance LWORK >= N*NB, where NB is
 *          the optimal blocksize.
 *
 *          If LWORK = -1, then a workspace query is assumed; the routine
 *          only calculates the optimal size of the WORK array, returns
 *          this value as the first entry of the WORK array, and no error
 *          message related to LWORK is issued .
 *
 *  INFO    (output) INTEGER
 *          = 0:  successful exit
 *          < 0:  if INFO = -i, the i-th argument had an illegal value
 *
 *  Further Details
 *  ===============
 *
 *  The matrix Q is represented as a product of elementary reflectors
 *
 *     Q = H(1) H(2) . . . H(k), where k = min(m,n).
 *
 *  Each H(i) has the form
 *
 *     H(i) = I - tau * v * v'                  (For Real precision)
 *     H(i) = I - tau * v * conjugate(v)'       (For Complex precision)
 *
 *  where tau is a real/complex scalar, and v is a real/complex vector with
 *  v(1:i-1) = 0 and v(i) = 1; v(i+1:m) is stored on exit in A(i+1:m,i),
 *  and tau in TAU(i).
 *
 */
{
   ATL_CINT minMN = Mmin(M, N), maxMN = Mmax(M, N);
   ATL_INT n, nb, j;
   TYPE  *@(wks),  *ws_T, *ws_larfb;        /* Workspace level 2, T, larfb.   */
   void *vp=NULL;

@ROUT ATL_gerqf ATL_gelqf
   /* For transpose function, may need type-appropriate 'ONE' for alpha. */
   #ifdef TREAL
      const TYPE ONE = ATL_rone;
   #else
      const TYPE ONE[2] = {ATL_rone, ATL_rzero};
   #endif
   TYPE *ws_CP=NULL, *ws_CPRaw=NULL;
   ATL_INT ldCP;

@ROUT ATL_geqrf ATL_geqlf ATL_gerqf ATL_gelqf
   #if defined(ATL_TUNING)
   /*-------------------------------------------------------------------------*/
   /* For tuning recursion crossover points, the blocking factor is set by    */
   /* la2xover, the tuning program for that purpose.                          */
   /*-------------------------------------------------------------------------*/
   if (ATL_PanelTune) nb=ATL_PanelTune; else
   #endif /* ATL_TUNING */

@ROUT ATL_geqrf
   nb = clapack_ilaenv(LAIS_OPT_NB, LAgeqrf, MYOPT+LARight+LAUpper, M, N,-1,-1);

/*
 * If it is a workspace query, return the size of work required.
 *    wrksz = wrksz of ATL_larfb + ATL_larft + ATL_geqr2
 */
   if (LWORK < 0)
   {
      *WORK = ( N*nb + nb*nb + maxMN )  ;
      return(0);
   }
   else if (M < 1 || N < 1)                 /* quick return if no work to do  */
      return(0);
/*
 * If the user gives us too little space, see if we can allocate it ourselves
 */
   else if (LWORK < (N*nb + nb*nb + maxMN))
   {
      vp = malloc(ATL_MulBySize(N*nb + nb*nb + maxMN) + ATL_Cachelen);
      if (!vp)
         return(-7);
      WORK = ATL_AlignPtr(vp);
   }

/*
 * Assign workspace areas for ATL_larft, ATL_geqr2, ATL_larfb
 * RCW Q: Why can't LARFB & GEQR2 workspaces be overlapped?
 */
   ws_T = WORK;                             /* T at begining of work          */
   ws_QR2 = WORK +(nb SHIFT)*nb;            /* After T Work space             */
   ws_larfb = ws_QR2 + (maxMN SHIFT);       /* After workspace for T and QR2  */

/*
 * Leave one iteration to be done outside loop, so we don't build T
 * Any loop iterations are therefore known to be of size nb (no partial blocks)
 */
   n = (minMN / nb) * nb;
   if (n == minMN)
      n -= Mmin(nb, minMN);

   for (j=0; j < n; j += nb)
   {
      ATL_assert(!ATL_geqrr(M-j, nb, A+(j SHIFT)*(lda+1), lda,
                            TAU+(j SHIFT), ws_QR2, ws_T, nb, ws_larfb, 1));

      if (j+nb < N)     /* if there are more cols left to right, update them  */
      {
/*
 *       Form the triangular factor of the block reflector
 *          H = H(i) H(i+1) . . . H(i+ib-1)
 *       After geqrr, ws_T contains 'T', the nb x nb triangular factor 'T'
 *       of the block reflector. It is an output used in the next call, dlarfb.
 *          H = Id - Y*T*Y', with Id=(M-j)x(M-j), Y=(M-j)xNB.
 *
 *       Apply H' to A(j:m,j+nb:N) from the left
 *
 *       The ws_T array used above is an input to dlarfb; it is 'T' in
 *       that routine, and LDT x K (translates here to LDWORK x NB).
 *       WORK is an LDWORK x NB workspace (not input or output).
 */
         ATL_larfb(CblasLeft, CblasTrans, LAForward, LAColumnStore,
                   M-j, N-j-nb, nb, A+(j SHIFT)*(lda+1), lda, ws_T, nb,
                   A+(j SHIFT)+((j+nb)SHIFT)*lda, lda, ws_larfb, N);
      }
   }
/*
 * Build Last panel.  buildT is passed as (0).
 */
   nb = minMN - n;                              /* remaining columns.         */
   ATL_assert(!ATL_geqrr(M-n, N-n, A+(n SHIFT)*(lda+1), lda, TAU+(n SHIFT), 
                         ws_QR2, ws_T, nb, ws_larfb, 0));

   if (vp)
      free(vp);
   return(0);
} /* END ATL_dgeqrf */

@ROUT ATL_geqlf
   nb = clapack_ilaenv(LAIS_OPT_NB, LAgeqrf, MYOPT+LARight+LALower, M, N,-1,-1);

/*
 * If it is a workspace query, return the size of work required.
 *    wrksz = wrksz of ATL_larfb + ATL_larft + ATL_geql2
 */
   if (LWORK < 0)
   {
      *WORK = ( N*nb + nb*nb + maxMN )  ;
      return(0);
   }
   else if (M < 1 || N < 1)                 /* quick return if no work to do  */
      return(0);
/*
 * If the user gives us too little space, see if we can allocate it ourselves
 */
   else if (LWORK < (N*nb + nb*nb + maxMN))
   {
      vp = malloc(ATL_MulBySize(N*nb + nb*nb + maxMN) + ATL_Cachelen);
      if (!vp)
         return(-7);
      WORK = ATL_AlignPtr(vp);
   }

/*
 * Assign workspace areas for ATL_larft, ATL_geql2, ATL_larfb
 */
   ws_T = WORK;                             /* T at begining of work          */
   ws_QL2 = WORK +(nb SHIFT)*nb;            /* After T Work space             */
   ws_larfb = ws_QL2 + (maxMN SHIFT);       /* After workspace for T and QL2  */

/*
 * Leave one iteration to be done outside loop, so we don't build T
 * Any loop iterations are therefore known to be of size nb (no partial blocks)
 */
   n = (minMN / nb) * nb;
   if (n == minMN)
      n -= Mmin(nb, minMN);

   for (j=0; j < n; j += nb)
   {
      ATL_assert(!ATL_geqlr(M-j, nb, A+(N SHIFT)*lda-((j + nb) SHIFT)*lda, lda,
                            TAU+( (minMN -(j +nb)) SHIFT), ws_QL2, ws_T, nb, 
                            ws_larfb, 1));
      if (j+nb < N)     /* if there are more cols left to right, update them  */
      {
/*
 *       Form the triangular factor of the block reflector
 *          H = H(i) H(i+1) . . . H(i+ib-1)
 *       After geqlr, ws_T contains 'T', the nb x nb triangular factor 'T'
 *       of the block reflector. It is an output used in the next call, dlarfb.
 *          H = Id - Y*T*Y', with Id=(M-j)x(M-j), Y=(M-j)xNB.
 *
 *       Apply H' to A(j:m,j+nb:N) from the left
 *
 *       The ws_T array used above is an input to dlarfb; it is 'T' in
 *       that routine, and LDT x K (translates here to LDWORK x NB).
 *       WORK is an LDWORK x NB workspace (not input or output).
 */
         ATL_larfb(CblasLeft, CblasTrans, LABackward, LAColumnStore,
                   M-j, N-j-nb, nb, A+(N SHIFT)*lda-((j + nb) SHIFT)*lda, lda,
                   ws_T, nb, A, lda, ws_larfb, N);
      }
   }

/*
 * Build Last panel. buildT is passed as 0
 */
   nb = minMN - n;                              /* remaining columns.         */
   ATL_assert(!ATL_geqlr(M-n, N-n, A, lda, TAU, ws_QL2, ws_T, nb, ws_larfb, 0));

   if (vp)
      free(vp);
   return(0);
} /* END ATL_dgeqlf */

@ROUT ATL_gelqf
   nb = clapack_ilaenv(LAIS_OPT_NB, LAgeqrf, MYOPT+LALeft+LALower, M, N,-1,-1);

/*
 * If it is a workspace query, return the size of work required.
 *    wrksz = wrksz of ATL_larfb + ATL_larft + ATL_gelq2
 */
   if (LWORK < 0)
   {
      *WORK = ( maxMN*nb + nb*nb + maxMN )  ;
      return(0);
   }
   else if (M < 1 || N < 1)  /* quick return if no work to do */
      return(0);

/*
 * LQ is the transpose of QR: We use this to go from row-major LQ to
 * col-major QR, typically faster. Here, if we are square and large,
 * we transpose the whole matrix in-place and then transpose it back.
 * This should be a tunable parameter; perhaps if the matrix fits in
 * L1 or L2? (Note by Tony C, short on time to conduct tuning).
 */
   if (M == N && N >= 128)
   {
      Mjoin(PATL,sqtrans)(N, A, lda);
      n = ATL_geqrf(M, N, A, lda, TAU, WORK, LWORK);
      Mjoin(PATL,sqtrans)(N, A, lda);

      /* Take the conjugate for Complex TAU. */
      #ifdef TCPLX
      ATL_INT i;
      for (i=1; i<(minMN<<1); i+=2)
         *(TAU+i) = 0.-*(TAU+i);          /* Negate imaginary part. */
      #endif
      return(n);
   }
/*
 * If the user gives us too little space, see if we can allocate it ourselves
 */
   else if (LWORK < (maxMN*nb + nb*nb + maxMN))
   {
      vp = malloc(ATL_MulBySize(maxMN*nb + nb*nb + maxMN) + ATL_Cachelen);
      if (!vp)
         return(-7);
       WORK = ATL_AlignPtr(vp);
   }

/*
 * Assign workspace areas for ATL_larft, ATL_gelq2, ATL_larfb
 */
   ws_T = WORK;                         /* T at begining of work */
   ws_LQ2 = WORK +(nb SHIFT)*nb;        /* After T Work space             */
   ws_larfb = ws_LQ2 + (maxMN SHIFT);   /* After workspace for T and LQ2  */

/*
 * Leave one iteration to be done outside loop, so we don't build T
 * Any loop iterations are therefore known to be of size nb (no partial blocks)
 */
   n = (minMN / nb) * nb;
   if (n == minMN)
      n -= Mmin(nb, minMN);       /* when n is a multiple of nb, reduce by nb */
   #if !defined(ATL_USEPTHREADS)        /* If no PCA, try to copy up front. */
      j = M - n;
      j = Mmax(nb, j);
      ldCP = (N&7) ? (((N+7)>>3)<<3) : N;
      ws_CPRaw = malloc(ATL_MulBySize(ldCP)*j + ATL_Cachelen);
      if (ws_CPRaw) ws_CP=ATL_AlignPtr(ws_CPRaw);  /* Align if malloced. */
   #endif /* Serial Mode */
 

   for (j=0; j < n; j += nb)
   {
      #if !defined(ATL_USEPTHREADS) /* If no PCA it won't copy. Try it here. */
      /* If we got our copy workspace, transpose panel before recursion. */
      if (ws_CP)                             /* If workspace exists. */
      {
         int ci, cj;                         /* for conjugation.     */
         ldCP = N-j;
         if (ldCP&7)
            ldCP = ((ldCP+7)>>3)<<3;
         Mjoin(PATL,gemoveT)(N-j, nb, ONE, A+(j SHIFT)*(lda+1), 
                             lda, ws_CP, ldCP);

         ATL_assert(!ATL_geqrr(N-j, nb, ws_CP, ldCP, TAU+(j SHIFT),
                               ws_LQ2, ws_T, nb, ws_larfb, 1));
      
         Mjoin(PATL,gemoveT)(nb, N-j, ONE, ws_CP, ldCP, 
                             A+(j SHIFT)*(lda+1), lda);

         #if defined(TCPLX)               /* conj upTri T, TAU. */
         for (cj=0; cj<nb; cj++)          /* column loop... */
         {
            TAU[((j+cj) SHIFT)+1] = 0.-TAU[((j+cj) SHIFT)+1];
            for (ci=0; ci<=cj; ci++)      /* row loop... */
               ws_T[((ci+cj*nb) SHIFT)+1] = 0.-ws_T[((ci+cj*nb) SHIFT)+1];
         }
         #endif /* defined(TCPLX) */
      } else /* copy workspace was not allocated, use native. */
      #endif /* Serial Mode (No PCA) */
      {
         ATL_assert(!ATL_gelqr(nb, N-j,  A+(j SHIFT)*(lda+1), lda, 
                               TAU+(j SHIFT), ws_LQ2, ws_T, nb, ws_larfb, 1));
      }

      if (j+nb < M)  /* if there are more cols left to bottom, update them */
      {
/*
 *       ======================================================================
 *       Form the triangular factor of the block reflector
 *       After gelqr, ws_T contains 'T', the nb x nb triangular factor 'T'
 *       of the block reflector. It is an output used in the next call, dlarfb.
 *          H = Id - Y'*T*Y, with Id=(N-j)x(N-j), Y=(N-j)xNB.
 *
 *       The ws_T array used above is an input to dlarfb; it is 'T' in
 *       that routine, and LDT x K (translates here to LDWORK x NB).
 *       WORK is an LDWORK x NB workspace (not input or output).
 *       ======================================================================
 */
         ATL_larfb(CblasRight, CblasNoTrans, LAForward, LARowStore,
                   M-j-nb, N-j, nb, A+(j SHIFT)*(lda+1), lda, ws_T, nb,
                   A+((j SHIFT)*(lda+1))+(nb SHIFT), lda, ws_larfb, M);
      }
   }

/*
 *  Build Last panel.  build T is set to 0
 *  RCW: changed nb = minMN-n to nb = M-n, since it is used as the # of rows!
 */
   nb = minMN - n;                            /* remaining factorization. */
   if (nb)                                    /* If we have any cleanup, */
   {
      ATL_CINT mr = M-n;
      #if !defined(ATL_USEPTHREADS)          /* If no PCA try up front copy. */
      if (ws_CP)                             /* If workspace exists. */
      {
         ATL_INT cj;                         /* for conjugation.     */
         ldCP = N-n;
         if (ldCP&7)
            ldCP = ((ldCP+7)>>3)<<3;
         Mjoin(PATL,gemoveT)(N-j, mr, ONE, A+(j SHIFT)*(lda+1), 
                             lda, ws_CP, ldCP);

         /* Final parm is whether to build T. No need for T on final panel. */
         ATL_assert(!ATL_geqrr(N-j, mr,  ws_CP, ldCP, TAU+(j SHIFT),
                               ws_LQ2, ws_T, nb, ws_larfb, 0));
      
         Mjoin(PATL,gemoveT)(mr, N-j, ONE, ws_CP, ldCP, 
                             A+(j SHIFT)*(lda+1), lda);

         /* We only need to conjugate final chunk of TAU. */ 
         #if defined(TCPLX)
         for (cj=0; cj<nb; cj++)
         {
            TAU[((j+cj) SHIFT)+1] = 0.-TAU[((j+cj) SHIFT)+1];
         }
         #endif /* defined(TCPLX) */
      } else /* copy workspace was not allocated, use native. */
      #endif /* Serial Mode (No PCA) */
      {
         /* Final parm is whether to build T. No need for T on final panel. */
         ATL_assert(!ATL_gelqr(M-n, N-n, A+(n SHIFT)*(lda+1), lda,
                               TAU+(n SHIFT), ws_LQ2, ws_T, nb, ws_larfb, 0));
      }
   } /* if we had any cleanup rows to do... */

   if (vp)
      free(vp);

   #if !defined(ATL_USEPTHREADS)             /* If copy workspace possible, */
   if (ws_CPRaw) free(ws_CPRaw);             /* Free any space allocated.   */
   #endif /* Serial Mode */

   return(0);
} /* END ATL_gelqf */

@ROUT ATL_gerqf
   nb = clapack_ilaenv(LAIS_OPT_NB, LAgeqrf, MYOPT+LALeft+LAUpper, M, N,-1,-1);

/*
 * If it is a workspace query, return the size of work required.
 *    wrksz = wrksz of ATL_larfb + ATL_larft + ATL_gerq2
 * RCW Q: Why can't LARFB & GERQ2 workspaces be overlapped?
 */
   if (LWORK < 0)
   {
      *WORK = ( maxMN*nb + nb*nb + maxMN )  ;
      return(0);
   }
   else if (M < 1 || N < 1)  /* quick return if no work to do */
      return(0);
/*
 * RQ is the transpose of QL: We use this to go from row-major RQ to
 * col-major QL, typically faster. Here, if we are square and large,
 * we transpose the whole matrix in-place and then transpose it back.
 * This should be a tunable parameter; perhaps if the matrix fits in
 * L1 or L2? (Note by Tony C, short on time to conduct tuning).
 */
   if (M == N && N >= 128)
   {
      Mjoin(PATL,sqtrans)(N, A, lda);
      n = ATL_geqlf(M, N, A, lda, TAU, WORK, LWORK);
      Mjoin(PATL,sqtrans)(N, A, lda);

      /* Take the conjugate for Complex TAU. */
      #ifdef TCPLX
      ATL_INT i;
      for (i=1; i<(minMN<<1); i+=2)
         *(TAU+i) = 0.-*(TAU+i);          /* Negate imaginary part. */
      #endif
      return(n);
   }
/*
 * If the user gives us too little space, see if we can allocate it ourselves
 */
   else if (LWORK < (maxMN*nb + nb*nb + maxMN))
   {
      vp = malloc(ATL_MulBySize(maxMN*nb + nb*nb + maxMN) + ATL_Cachelen);
      if (!vp)
         return(-7);
       WORK = ATL_AlignPtr(vp);
   }

/*
 * Assign workspace areas for ATL_larft, ATL_gerq2, ATL_larfb
 */
   ws_T = WORK;                         /* T at begining of work */
   ws_RQ2 = WORK +(nb SHIFT)*nb;        /* After T Work space             */
   ws_larfb = ws_RQ2 + (maxMN SHIFT);   /* After workspace for T and RQ2  */


/*
 * Leave one iteration to be done outside loop, so we don't build T
 * Any loop iterations are therefore known to be of size nb (no partial blocks)
 */
   n = (minMN / nb) * nb;
   if (n == minMN)
      n -= Mmin(nb, minMN);  

   #if !defined(ATL_USEPTHREADS)        /* If no PCA, try to copy up front. */
      j = M - n;
      j = Mmax(j, nb);
      ldCP = (N&7) ? (((N+7)>>3)<<3) : N;
      ws_CPRaw = malloc(ATL_MulBySize(ldCP)*j + ATL_Cachelen);
      if (ws_CPRaw) ws_CP=ATL_AlignPtr(ws_CPRaw);  /* Align if malloced. */
   #endif /* Serial Mode */

   for (j=0; j < n; j += nb)
   {
/*
 *    Starts Factorization from the bottom row
 */
      #if !defined(ATL_USEPTHREADS) /* If no PCA it won't copy. Try it here. */
      /* If we got our copy workspace, transpose panel before recursion. */
      if (ws_CP)                             /* If workspace exists. */
      {
         int ci, cj;                         /* for conjugation.     */
         TYPE *myTAU=TAU+((minMN-(j+nb)) SHIFT);
         TYPE *myA=A+((M -j -nb) SHIFT);

         ldCP = N-j;
         if (ldCP&7)
            ldCP = ((ldCP+7)>>3)<<3;

         Mjoin(PATL,gemoveT)(N-j, nb, ONE, myA, lda, ws_CP, ldCP);

         ATL_assert(!ATL_geqlr(N-j, nb, ws_CP, ldCP, myTAU, 
                               ws_RQ2, ws_T, nb, ws_larfb, 1));
      
         Mjoin(PATL,gemoveT)(nb, N-j, ONE, ws_CP, ldCP, myA, lda);

         #if defined(TCPLX)               /* conj LowTri T, TAU. */
         for (cj=0; cj<nb; cj++)          /* column loop... */
         {
            myTAU[(cj SHIFT)+1] = 0.-myTAU[(cj SHIFT)+1];
            for (ci=cj; ci< nb; ci++)     /* row loop... */
               ws_T[((ci+cj*nb) SHIFT)+1] = 0.-ws_T[((ci+cj*nb) SHIFT)+1];
         }
         #endif /* defined(TCPLX) */
      } else /* copy workspace was not allocated, use native. */
      #endif /* Serial Mode (No PCA) */
      {
         ATL_assert(!ATL_gerqr(nb, N-j, A+((M -j -nb) SHIFT), lda, 
                               TAU+((minMN -(j+nb)) SHIFT), ws_RQ2, ws_T, nb, 
                               ws_larfb, 1));
      }

      if (j+nb < M)  /* if there are more cols left on top to update them */
      {
/*
 *       ======================================================================
 *       Form the triangular factor of the block reflector
 *          H = H(i+ib-1) . . . H(i+1) H(i)
 *       After gerqr, ws_T contains 'T', the nb x nb triangular factor 'T'
 *       of the block reflector. It is an output used in the next call, dlarfb.
 *
 *       The ws_T array used above is an input to ATL_larfb; it is 'T' in
 *       that routine, and LDT x K (translates here to NB  x NB).
 *       WORK is an LDWORK x NB workspace in ATL_larfb(maxMN X NB).
 *       ======================================================================
 */

         ATL_larfb(CblasRight, CblasNoTrans, LABackward, LARowStore,
                   M-j-nb, N-j, nb, A+((M - j -nb ) SHIFT), lda, ws_T, nb,
                   A, lda, ws_larfb, M);
      }
   }

/*
 *  Build Last panel.  buildT  is passed as 0, as there is no need to build T
 *  RCW: changed nb = minMN-n to nb = M-n, since it is used as the # of rows!
 */
   nb = minMN - n;                              /* remaining steps in factor */
   if (nb)                                      /* If we have any to do...    */
   {
      ATL_CINT mr = M-n;
      #if !defined(ATL_USEPTHREADS) /* If no PCA it won't copy. Try it here. */
      /* If we got our copy workspace, transpose panel before recursion. */
      if (ws_CP)                             /* If workspace exists. */
      {
         int cj;                             /* for conjugation.     */
         ldCP = N-n;
         if (ldCP&7)
            ldCP = ((ldCP+7)>>3)<<3;
         Mjoin(PATL,gemoveT)(N-j, mr, ONE, A, lda, ws_CP, ldCP);

         ATL_assert(!ATL_geqlr(N-j, mr, ws_CP, ldCP, TAU, 
                               ws_RQ2, ws_T, nb, ws_larfb, 0));
      
         Mjoin(PATL,gemoveT)(mr, N-j, ONE, ws_CP, ldCP, A, lda);

         #if defined(TCPLX)               /* conj TAU. */
         for (cj=0; cj<nb; cj++)          /* column loop... */
         {
            TAU[(cj SHIFT)+1] = 0.-TAU[(cj SHIFT)+1];
         }
         #endif /* defined(TCPLX) */
      } else /* copy workspace was not allocated, use native. */
      #endif /* Serial Mode (No PCA) */
      {
         ATL_assert(!ATL_gerqr(M-n, N-n, A, lda, TAU, ws_RQ2, 
                               ws_T, nb, ws_larfb, 0));
      }
   }

   if (vp)
      free(vp);

   #if !defined(ATL_USEPTHREADS)             /* If copy workspace possible, */
   if (ws_CPRaw) free(ws_CPRaw);             /* Free any space allocated.   */
   #endif /* Serial Mode */

   return(0);
} /* END ATL_gerqf */

@ROUT ATL_geqrr
@define rtn @geqrf@
@define rec @geqrr@
@define wks @ws_QR2@
@define btm @geqr2@
@ROUT ATL_geqlr
@define rtn @geqlf@
@define rec @geqlr@
@define wks @ws_QL2@
@define btm @geql2@
@ROUT ATL_gerqr
@define rtn @gerqf@
@define rec @gerqr@
@define wks @ws_RQ2@
@define btm @gerq2@
@ROUT ATL_gelqr
@define rtn @gelqf@ 
@define rec @gelqr@ 
@define wks @ws_LQ2@
@define btm @gelq2@

@ROUT ATL_geqrr ATL_gelqr ATL_geqlr ATL_gerqr
@extract -b @(topd)/cw.inc lang=C -def cwdate 2009 -def cwauth "Siju Samuel" -def contrib "Anthony M. Castaldo, R. Clint Whaley"

#include "atlas_misc.h"
#include "cblas.h"
#include "atlas_ptalias_lapack.h"
#include "atlas_lapack.h"
#include "atlas_lvl3.h"
#include "atlas_qrrmeth.h"
/* #include Mstr(Mjoin(ATLAS_PRE,oprk_perf.h)) */
#include Mstr(Mjoin(ATLAS_PRE,opgen_view.h))
#if ATL_VWopgen_MAX_KB <= 88
   #define ATL_QRKB ATL_VWopgen_100KB
   #define ATL_QRLCM ATL_VWopgen_100LCMMN
#elif ATL_VWopgen_99KB <= 88
   #define ATL_QRKB ATL_VWopgen_99KB
   #define ATL_QRLCM ATL_VWopgen_99LCMMN
#else
   #define ATL_QRKB ATL_VWopgen_98KB
   #define ATL_QRLCM ATL_VWopgen_98LCMMN
#endif

#ifdef ATL_USEPTHREADS
   #include "atlas_threads.h"
   #include "atlas_taffinity.h"
   #include "atlas_tcacheedge.h"
#else
   #include "atlas_cacheedge.h"
#endif

@beginskip
#if defined(ATL_TUNING)
extern   int   ForceMethod;   /* Method used if >=0. */
extern   int   ATL_Ns;
extern   int   ATL_N[];
extern   int   ATL_Serial[];
extern   int   ATL_CpNoCpLo[];
extern   int   ATL_CpNoCpHi[];
extern   int   ATL_Recurse[];

#if defined(ATL_USEPTHREADS)
#define ATL_@(rec)_Tune Mjoin(Mjoin(PATL,t@(rec)),_Tune)    /* Add tag */
#else
#define ATL_@(rec)_Tune Mjoin(Mjoin(PATL,@(rec)),_Tune)     /* Add tag */
#define ATL_NTHREADS (1)                                  /* Must define... */
#endif /* ATL_USEPTHREADS */

/* Must find the index with the tables. ATL_N is {NB,2NB, ..., 5NB,4,8,...,}  */
/* i.e. first five entries are multiples of NB, then powers of 2, starting at */
/* 4, up to NB without including NB. So, we find which N_ is closest to.      */

#define NIDX(IDX_, N_) \
if (N_ >= ((ATL_N[ATL_Ns-1]+NB)>>1))                     \
   IDX_ = Mmin(5, (N_+(NB>>1))/NB)-1;                    \
else {                                                   \
   for(IDX_ = 5; IDX_ < ATL_Ns-1; IDX_ ++)               \
      if (N_ < ((ATL_N[IDX_]+ATL_N[IDX_+1])>>1)) break;  \
}

/* We do not check if the problem will fit in cache in any way here, we are   */
/* tuning. So the only question is IF we can recurse, and if  the tuner wants */
/* us to recurse based on M.                                                  */

#define METHOD(METH_, M_, N_, LDA_) /* 0,1,2,3=Recur,Serial,Cp,NoC*/\
{ NIDX(METH_, N_);                  /* Get index for N into METH_.*/\
  if (ForceMethod >= 0) METH_ = ForceMethod; else /* Honor force. */\
  if (Mmin(M_,N_) > 1 &&            /* If possible to recurse,    */\
      M_ >= ATL_Recurse[METH_])     /* Recurse if M is large.     */\
     METH_ = 0;                     /* Set recursion as method.   */\
  else if (ATL_NTHREADS == 1 ||     /* Use serial if we must, or  */\
           M_ < ATL_Serial[METH_])  /* if we are beneath thresh.  */\
     METH_ = 1;                     /* Set Serial as method.      */\
  else if (LDA_ & (LDA_-1) == 0)    /* PCA. If LDA power of 2,    */\
     METH_ = 2;                     /* Make sure we copy.         */\
  else if (M_ >= ATL_CpNoCpHi[METH_] ||   /* If above lower limit,*/\
           M_ <  ATL_CpNoCpLo[METH_])     /* or below lower limit,*/\
     METH_ = 3;                     /* NoCopy will be faster,     */\
  else METH_ = 2;                   /* Copy will be faster.       */\
} /* END METHOD MACRO */


#else /* We aren't tuning, use the tuned values and include files. */
#define ForceMethod (-1)                    /* Never force if not tuning. */

   #if defined(ATL_USEPTHREADS)
   #define ATL_@(rec)_Tune Mjoin(PATL,t@(rec)) /* No tuning tag. */
   #else
   #define ATL_@(rec)_Tune Mjoin(PATL,@(rec))  /* No tuning tag. */
   #endif /* ATL_USEPTHREADS */

@ROUT ATL_geqrr `@define L2 @qr@`
@ROUT ATL_geqlr `@define L2 @ql@`
@ROUT ATL_gerqr `@define L2 @rq@`
@ROUT ATL_gelqr `@define L2 @lq@`

#if defined(ATL_USEPTHREADS)  /* Include threaded versions of headers.  */
#if defined(SREAL)
#include "atlas_stxover_ge@(L2)r.h"
#elif defined(DREAL)
#include "atlas_dtxover_ge@(L2)r.h"
#elif defined(SCPLX)
#include "atlas_ctxover_ge@(L2)r.h"
#elif defined(DCPLX)
#include "atlas_ztxover_ge@(L2)r.h"
#endif /* (include on Type)  */
#else                         /* Include Serial versions of headers.    */
#if defined(SREAL)
#include "atlas_sxover_ge@(L2)r.h"
#elif defined(DREAL)
#include "atlas_dxover_ge@(L2)r.h"
#elif defined(SCPLX)
#include "atlas_cxover_ge@(L2)r.h"
#elif defined(DCPLX)
#include "atlas_zxover_ge@(L2)r.h"
#endif /* (include on Type)  */
#endif /* Handled Parallel or Serial Includes. */

#if !defined(METHOD)
#if !defined(ATL_NTHREADS)
#define MyCacheEdge ((3*CacheEdge)>>2) /* 3/4 single-core cache edge.   */
#else 
#define MyCacheEdge ((ATL_NTHREADS*3*CacheEdge)>>2) /* 3/4 collective.  */
#endif 

#define METHOD(METH_, M_, N_, LDA_) /* 0,1,2,3=Recur,Serial,Cp,NoC      */ \
{                                                                          \
   if (Mmin(M_,N_) < 2) METH_ = 1;  /* Force serial if just one column. */ \
   else {                                                                  \
      if (ATL_MulBySize(M_) * N_ <= /* If memory size of whole problem  */ \
         MyCacheEdge)               /* ..fits in 3/4 total cache size,  */ \
         METH_ = 2;                 /* ..Try PCA COPY.                  */ \
      else METH_ = 0;               /* Otherwise, recurse.              */ \
   }                                                                       \
} /* END METHOD MACRO */
#endif  /* Method macro not defined.  */
#endif /* handled ATL_TUNING */
@endskip

int ATL_@(rec)(ATL_CINT M, ATL_CINT N, TYPE *A, ATL_CINT LDA, TYPE  *TAU,
               TYPE *@(wks), TYPE *ws_T, ATL_CINT LDT,
               TYPE *WORKM, const int buildT)
{
@ROUT ATL_geqrr ATL_geqlr
/*
 * This is a recursive implementation of ATL_@(rtn).c; it performs a QR
 * factorization of a panel (M > N) with a bottom level of ATL_@(btm). The
 * recursion is on columns only; it divides by 2 until it reaches a
 * stopping point; at which time it calls ATL_@(btm) to complete a sub-panel,
 * ATL_larft and ATL_larfb to propagate the results, etc.
 *
 * ATL_@(rec).c :
 * int ATL_@(rec)(int M, int N, TYPE *A, int LDA, TYPE  *TAU,
 *               TYPE *@(wks), TYPE *ws_T, int LDT,
 *               TYPE *WORKM, int buildT)
 *      NOTE :   ATL_@(btm).c will get compiled to four precisions
 *               single precision real,      double precision real
 *               single precision complex,   double precision complex
 *  Purpose
 *  =======
 *
 *  ATL_@(rec) computes a QR factorization of a real M-by-N matrix A:
@ROUT ATL_geqrr ` *  A = Q * R.`
@ROUT ATL_geqlr ` *  A = Q * L.`
 *
 *  Arguments
 *  =========
 *
 *  M       (input) INTEGER
 *          The number of rows of the matrix A.  M >= 0.
 *
 *  N       (input) INTEGER
 *          The number of columns of the matrix A.  N >= 0.
 *
 *  A       (input/output)  array, dimension (LDA,N)
 *          On entry, the M-by-N matrix A.
 *          On exit, the elements on and above the diagonal of the array
 *          contain the min(M,N)-by-N upper trapezoidal matrix R (R is
 *          upper triangular if m >= n); the elements below the diagonal,
 *          with the array TAU, represent the orthogonal matrix Q as a
 *          product of min(m,n) elementary reflectors (see Further
 *          Details).
 *
 *  LDA     (input) INTEGER
 *          The leading dimension of the array A.  LDA >= max(1,M).
 *
 *
 *  TAU     (output) DOUBLE PRECISION array, dimension (min(M,N))
 *          The scalar factors of the elementary reflectors (see Further
 *          Details).
 *
 *  @(wks)  (workspace) workspace for @(btm) factorization. To be allocated
 *          with space of max(M,N)
 *
 *  ws_T    (input/output).  Is the size of T matrix. To be allocated
 *          with a space of min(M,N) X min(M,N). If buildT flag is true,
 *          T is computed and populated as output. If buildT is false,
 *          T must not be used as output
 *
 *  LDT     (input) INTEGER
 *          The leading dimension of the array T.  LDT >= max(1,min(M,N)).
 *
 *  WORKM   (workspace) Work space matrix, N rows by
 *          minMN columns; the amount used by larfb.
 *
 *  buildT  If non-zero, dgeqrr will build in ws_T the complete T necessary
 *          for the original panel it is passed;
 *          such that Q= I - transpose(Y) * T * Y.
 *          If zero, ws_T will contain only those elements of T necessary to
 *          complete the panel.
 */

@ROUT ATL_gelqr ATL_gerqr `   int top, bottom, buildT_temp;`
@ROUT ATL_geqrr ATL_geqlr `   int left, right;`
@ROUT ATL_geqlr `   int leftMN;`
@ROUT ATL_gerqr `   int topMN;`
@ROUT ATL_gelqr `   int bottomMN;`
@ROUT ATL_geqrr ATL_geqlr ATL_gelqr ATL_gerqr
   int I, INFO, IINFO, lbuilt, rbuilt, method;
   int LDA2 = LDA SHIFT;                    /* for complex LDA *2             */
   int LDT2 = LDT SHIFT;                    /* for complex LDT *2             */
   ATL_CINT minMN = Mmin(M, N);

@ROUT ATL_gelqr ATL_gerqr
   #ifdef TCPLX
      TYPE ONE[2] = {ATL_rone, ATL_rzero};
   #else
      #define ONE ATL_rone
   #endif

@ROUT ATL_geqrr ATL_geqlr ATL_gelqr ATL_gerqr
   if (M < 1 || N < 1) return(0);           /* Nothing to do.                 */
@ROUT ATL_geqrr ATL_geqlr `   METHOD(method, M, N, LDA);                   /* Find the method.           */`
@ROUT ATL_gerqr ATL_gelqr `   METHOD(method, N, M, LDA);                   /* Find the method.           */`
   #if !defined(ATL_USEPTHREADS) 
   if (method == 2 || method == 3) method=1;    /* Don't PCA if no affinity.  */
   #endif

   switch(method)                               /* Based on method;           */
   {
      case 0:  /* RECURSION. */
@BEGINSKIP 
/******************************************************************************/
/* That ends the common portion. These four routines share a lot of structure,*/
/* but the details are different on almost every line, so being generic with  */
/* extract for the structure really just makes it more confusing than helpful.*/
/* So we don't try, the next commonality will just finish the routine.        */
/******************************************************************************/
@ENDSKIP

@ROUT ATL_geqrr

      /*
       * Choose a smart recursive column partitioning based on N:
       * The mapping from this routs dim:GEMM is : right:M, left:N, K:M-left
       * For big probs, max M & K by making left small & a mult of NB.
       * For small problems, make M a mult of MU (many x86 have NU=1 anyway!).
       */

         if (minMN >= 2*ATL_QRKB) /* big prob, put rmnder right */
         {
            left = ((minMN>>1) / ATL_QRKB)*ATL_QRKB;
            right = N - left;                   /* for QR, right as N - left  */
         }
         else /* small prob, keep M mult of MU (MU more critical than NU)     */
         {
            right = ((minMN>>1)/ATL_QRLCM)*ATL_QRLCM;
            left = minMN - right;
            right = N - left;                   /* for QR, right as N - left  */
         }

         if (left==0 || right==0)               /* If too small for that,     */
         {
            left=(minMN>>1);                    /* get half for left.         */
            right = N-left;                     /* half for right.            */
         }

      /*
       * Factor left half, using same workspaces as we eventually use for right.
       * We always build T so we can multiply by Q for the right side update
       */
         ATL_geqrr(M, left, A, LDA, TAU, ws_QR2, ws_T, LDT, WORKM, 1);

      /*
       * Adjust right according to T:  apply H' to A[0:(M-1), left:(N-1)].
       */
         ATL_larfb(CblasLeft, CblasTrans, LAForward, LAColumnStore,     
                   M, right, left, A, LDA, ws_T, LDT,A+(left*LDA2), LDA,          
                   WORKM, N);                   

      /*
       * Now factor updated right
       */
         ATL_geqrr(M-left, right, A+(left SHIFT)*(LDA+1), LDA,
                   TAU+(left SHIFT), ws_QR2, ws_T+(left SHIFT)*(LDT+1), LDT,
                   WORKM, buildT);

      /*
       * If we are building T, the left side was completely built above, and the
       * right-hand side is partially built by the recursion. We need to fill in
       * the upper right quarter of T, which is left x right in size, using the
       * formula -T1 * (Y1^T * Y2) * T2.
       * right :   minMN - left
       */
         if (buildT)
            ATL_larft_block(LAForward, LAColumnStore, M, minMN, left, 
                            minMN-left, A, LDA, ws_T, LDT);
         return(0); /* END CASE RECURSION */


      case 1:  /* SERIAL. */

         ATL_geqr2(M, minMN, A, LDA, TAU, ws_QR2);
         if (buildT ||  (N > minMN) )
         {
            ATL_larft(LAForward, LAColumnStore,
                      M, minMN, A, LDA, TAU, ws_T, LDT);
         }
         break; /* END CASE (Update T is after switch). */

      #if defined(ATL_USEPTHREADS)  /* Cases 2 & 3 only for parallel. */
      case 2: /* PCA COPY (last two parameters: BuildT, Copy) */
         ATL_tgeqr2(M, minMN, A, LDA, TAU, ws_QR2, ws_T, LDT, WORKM, 1, 1);
         break; /* END CASE (Update T is after switch). */

      case 3: /* PCA NOCOPY (last two parameters: BuildT, Copy) */
         ATL_tgeqr2(M, minMN, A, LDA, TAU, ws_QR2, ws_T, LDT, WORKM, 1, 0);
         break; /* END CASE (Update T is after switch). */
      #endif /* defined(ATL_USEPTHREADS) */
   } /* END SWITCH on method. */

   /*
    *   For cases Serial, PCA_Copy, PCA NoCopy, we must update T.
    *   Adjust remainder matrix according to T:  apply H' , if N > minMN
    */
   if ( N > minMN )
   {
      ATL_larfb(CblasLeft, CblasTrans,
                LAForward, LAColumnStore, M, N-minMN, minMN, A, LDA,      
                ws_T, LDT, A+(minMN*LDA2), LDA, WORKM, N);               
   }

@ROUT ATL_geqlr 

      /*
       * Choose a smart recursive column partitioning based on N:
       * The mapping from this routs dim:GEMM is : right:M, left:N, K:M-left
       * For big probs, max M & K by making left small & a mult of NB.
       * For small problems, make M a mult of MU (many x86 have NU=1 anyway!).
       */

         if (minMN >= 2*ATL_QRKB) /* big prob, put remainder on right. */
         {
            leftMN = ((minMN>>1)/ATL_QRKB)*ATL_QRKB;
            right = minMN - leftMN;
            left  = N -right;
         }
         else /* small prob, keep M mult of MU (MU more critical than NU)     */
         {
            right = ((minMN>>1)/ATL_QRLCM)*ATL_QRLCM;
            leftMN = minMN - right;
            left = N - right;
         }

         if (left==0 || right==0)               /* Stop trying to be fancy.   */
         {
            right = (minMN>>1);
            leftMN = minMN - right;
            left = N - right;
         }

      /*----------------------------------------------------------------------*/
      /* On the right half, we use the same workspaces.                       */
      /* Because we know we have a left hand side we must always              */
      /* build T, so we can multiply by Q before doing the left side.         */
      /* Build T @ T[left,left].                                              */   
      /*----------------------------------------------------------------------*/
         ATL_geqlr(M, right, (A+(left*LDA2)), LDA, (TAU+(leftMN SHIFT)), ws_QL2,
                   (ws_T+(leftMN SHIFT)+leftMN*LDT2), LDT, WORKM, 1);

      /*----------------------------------------------------------------------*/
      /* Now we must adjust the left hand side according to our T.            */
      /* We must apply H'                                                     */
      /*----------------------------------------------------------------------*/

         ATL_larfb(CblasLeft, CblasTrans,        
                   LABackward, LAColumnStore,   
                   M, left, right, (A +(left*LDA2))  , LDA,     
                   (ws_T+(leftMN SHIFT)+leftMN*LDT2), 
                   LDT, A, LDA, WORKM, N);                    

      /*----------------------------------------------------------------------*/
      /* On the left  half, we must adjust all pointers.                      */
      /*----------------------------------------------------------------------*/
         ATL_geqlr(M-right, left, (A), LDA, (TAU), ws_QL2, ( ws_T),
                   LDT, WORKM, buildT);               

      /*----------------------------------------------------------------------*/
      /* If we build T, the right side must be completely built, and          */
      /* the left side should be partially built. We need to fill in          */
      /* the lower  left  hand block, 'right' rows by 'left' columns.         */
      /* The formula is -T2 * (Y2^T * Y1) * T1.                               */
      /* The routine is in ATL_larft.c.                                       */
      /*----------------------------------------------------------------------*/

         if (buildT)
         {
            ATL_larft_block(LABackward, LAColumnStore,
                            M, minMN, minMN-right, right,
                            (A+((N-minMN)*LDA2)) , LDA,
                            ws_T, LDT);
         }

         return(0); /* END CASE RECURSION */


      case 1:  /* SERIAL. */

         ATL_geql2(M, minMN, A+((N-minMN)*LDA2), LDA, TAU, ws_QL2);

         if (buildT || (N > minMN) )
         {
            ATL_larft(LABackward, LAColumnStore, M, minMN, A+((N-minMN)*LDA2),
                      LDA, TAU, ws_T, LDT);     
         }
         break; /* END CASE (Update T is after switch). */

      #if defined(ATL_USEPTHREADS)  /* Cases 2 & 3 only for parallel. */
      case 2: /* PCA COPY (last two parameters: BuildT, Copy) */
         ATL_tgeql2(M, minMN, A+((N-minMN)*LDA2), LDA, TAU, ws_QL2,
                    ws_T, LDT, WORKM, 1, 1);
         break; /* END CASE (Update T is after switch). */

      case 3: /* PCA NOCOPY (last two parameters: BuildT, Copy) */
         ATL_tgeql2(M, minMN, A+((N-minMN)*LDA2), LDA, TAU, ws_QL2,
                    ws_T, LDT, WORKM, 1, 0);
         break; /* END CASE (Update T is after switch). */
      #endif /* defined(ATL_USEPTHREADS) */
   } /* END SWITCH on method. */

   /*
    *   For cases Serial, PCA_Copy, PCA NoCopy, we must update T.
    *   Adjust remainder matrix according to T:  apply H' , if N > minMN
    */
   if (N > minMN )
   {
      ATL_larfb(CblasLeft, CblasTrans, LABackward, LAColumnStore,          
                M, N-minMN, minMN, (A+((N-minMN)*LDA2))  , LDA, (ws_T),
                LDT, A, LDA, WORKM, N);                          
   }

@ROUT ATL_gelqr
      /*
       * Choose a smart recursive column partitioning based on M:
       */
         if (minMN >= 2*ATL_QRKB)    /* big prob, put rmndr on bottom. */
         {
            bottomMN = ((minMN>>1)/ATL_QRKB)*ATL_QRKB;
            top  = minMN - bottomMN;
            bottom  = M -top;
         }
         else                          /* small prob, keep M mult of MU.      */
         {
            top  = ((minMN>>1)/ATL_QRLCM)*ATL_QRLCM;
            bottomMN = minMN - top;
            bottom = M - top;
         }

         if (top==0 || bottom==0)      /* If too small for that,              */
         {
            top=(minMN>>1);            /* Get half for top.                   */
            bottomMN = minMN - top;
            bottom = M - top;          /* Rest for bottom.                    */
         }
         
         /*-------------------------------------------------------------------*/
         /* On the top half, we use the same workspaces.                      */
         /* Because we know we have a bottom hand side we must always         */
         /* build T, so we can multiply by Q before doing the bottom side.    */
         /*-------------------------------------------------------------------*/
            ATL_gelqr(top, N, A, LDA, TAU, @(wks), ws_T, LDT, WORKM, 1);

         /*-------------------------------------------------------------------*/
         /* Now we must adjust the bottom hand side according to our T.       */
         /* We must apply H' to A[0:(M-1), top:(N-1)].                        */
         /*-------------------------------------------------------------------*/

            ATL_larfb(CblasRight, CblasNoTrans, LAForward, LARowStore, 
                       bottom, N, top, A, LDA, ws_T, LDT, A+(top SHIFT),
                       LDA, WORKM, M);                   

         /*-------------------------------------------------------------------*/
         /* On the bottom half, we must adjust all pointers.                  */
         /*-------------------------------------------------------------------*/
            ATL_gelqr(bottom, N-top, (A+(top SHIFT)+top*LDA2), LDA,
                      (TAU+(top SHIFT)), @(wks),                       
                      (ws_T+(top SHIFT)+top*LDT2), LDT, WORKM, buildT);

         /*-------------------------------------------------------------------*/
         /* If we build T, the left/top side must be completely built, and    */
         /* the right/bottom side should be partially built. We need to fill  */
         /* in the upper left hand block, 'top' rows by 'bottom' columns.     */
         /* The formula is -T1 * (Y1 * Y2^T) * T2.                            */
         /* The routine is in ATL_larft.c.                                    */
         /*-------------------------------------------------------------------*/

            if (buildT)
            {
               ATL_larft_block(LAForward, LARowStore, N, minMN, top, bottomMN,
                               A, LDA, ws_T, LDT);  
            }
            return(0);
            break;

      case 1: /* SERIAL */ 
         /*
          *       ATL_gelq2(minMN, N, A, LDA, TAU, ws_LQ2);
          *       Transpose the input and sent to QR2 serial.
          */
         if (minMN >= 4)
         {
            Mjoin(PATL,gemoveT)(N, minMN, ONE, A, LDA, WORKM, N);
            ATL_geqr2(N, minMN, WORKM, N, TAU, ws_LQ2);
            Mjoin(PATL,gemoveT)(minMN, N, ONE, WORKM, N, A, LDA);
            #ifdef TCPLX
               Mjoin(PATLU,scal)(minMN, ATL_rnone, TAU+1, 2);
            #endif
         }
         else
         {
               ATL_gelq2(minMN, N, A, LDA, TAU, ws_LQ2);
         }

         if (buildT || (M > minMN) )
         {
/*          Build the T matrix.                                               */
            ATL_larft(LAForward, LARowStore, N, minMN, A, LDA,
                    TAU, ws_T, LDT);
         }
         break; /* END CASE */

      #if defined(ATL_USEPTHREADS)  /* Cases 2 & 3 only for parallel. */
      case 2:  /* PCA COPY */
      case 3:  /* PCA NOCOPY (does not exist for LQ) */

         if (buildT || (M > minMN) )
         {
            buildT_temp = 1;
         } 
         else 
         {
            buildT_temp = buildT;
         }
/*       call lq2 with '1' for copy.          */
         ATL_tgelq2(N, minMN, A, LDA, TAU, @(wks), ws_T, LDT, WORKM, 
                    buildT_temp, 1); 

         break; /* END CASE */
      #endif /* defined(ATL_USEPTHREADS) */
   } /* END SWITCH on method */

   /* Common code for cases Serial, PCA COPY, PCA NOCOPY */
   /*
    *   Adjust bottom according to T:  apply H' , if M > minMN
    */
   if ( M > minMN )
   {
      ATL_larfb(CblasRight, CblasNoTrans, 
                LAForward, LARowStore, M-minMN, N, minMN, A, LDA, ws_T, LDT,    
                A+( minMN SHIFT), LDA, WORKM, M);                
   }

@ROUT ATL_gerqr 
      /*
       * Choose a smart recursive column partitioning based on M:
       */
         if (minMN >= 2*ATL_QRKB) /* big prob, put remainder on right */
         {
            topMN = ((minMN>>1)/ATL_QRKB)*ATL_QRKB;
            bottom = minMN - topMN;
            top  = M - bottom;
         }
         else /* small prob, keep M mult of MU (MU more critical than NU)     */
         {
            bottom = ((minMN>>1)/ATL_QRLCM)*ATL_QRLCM;
            topMN = minMN - bottom;
            top = M - bottom;
         }

         if (top==0 || bottom==0)      /* If too small for that,              */
         {
            bottom = (minMN>>1);       /* Stop trying to be clever.           */
            topMN = minMN - bottom;
            top = M - bottom;
         }

      /*----------------------------------------------------------------------*/
      /* On the bottom half, we use the same workspaces.                      */
      /* Because we know we have a top hand side we must always               */
      /* build T, so we can multiply by Q before doing the top side.          */
      /*----------------------------------------------------------------------*/
         ATL_gerqr(bottom,N, (A+(top SHIFT)), LDA, (TAU+(topMN SHIFT)), @(wks),
                   ( ws_T+(topMN SHIFT)+topMN*LDT2), LDT, WORKM, 1);

      /*----------------------------------------------------------------------*/
      /* Now we must adjust the top hand side according to our T.             */
      /* We must apply H'                                                     */
      /*----------------------------------------------------------------------*/

         ATL_larfb(CblasRight, CblasNoTrans, LABackward, LARowStore,     
                   top, N, bottom, (A +(top SHIFT))  , LDA,    
                   (ws_T+(topMN SHIFT)+topMN*LDT2), LDT, A, LDA, WORKM, M);                  

      /*----------------------------------------------------------------------*/
      /* On the top  half,                                                    */
      /*----------------------------------------------------------------------*/
         ATL_gerqr(top, N-bottom,(A), LDA, (TAU),                          
                   @(wks),                         
                   ( ws_T), LDT, WORKM, buildT);                 

      /*----------------------------------------------------------------------*/
      /* If we build T, the bottom side must be completely built, and         */
      /* the top side should be partially built. We need to fill in           */
      /* the lower  left  hand block, 'bottom' rows by 'top' columns.         */
      /* The formula is -T2 * (Y2 * Y1^T) * T1.                               */
      /* The routine is in ATL_larft.c.                                       */
      /*----------------------------------------------------------------------*/

         if (buildT )
         {
            ATL_larft_block(LABackward, LARowStore,
                            N, minMN, minMN-bottom, bottom,
                            A+((M -minMN) SHIFT), LDA, ws_T, LDT);
         }

         return(0);

      case 1: /* SERIAL (single core mode) */
         if (minMN >= 4)
         {
            Mjoin(PATL,gemoveT)(N, minMN, ONE, A+((M-minMN) SHIFT),LDA,WORKM,N);
            ATL_geql2(N, minMN, WORKM, N, TAU, ws_RQ2);
            Mjoin(PATL,gemoveT)(minMN,N,ONE,WORKM, N, A+((M-minMN) SHIFT), LDA);
            // make conjugate  of TAU
            #ifdef TCPLX
               Mjoin(PATLU,scal)(minMN, ATL_rnone, TAU+1, 2);
            #endif
         }
         else
         {
            ATL_gerq2(minMN, N, A+((M -minMN) SHIFT) , LDA, TAU, ws_RQ2);
         }

         if (buildT  || M > minMN)
         {
            ATL_larft(LABackward, LARowStore, N, minMN,
                      A+((M -minMN) SHIFT), LDA, TAU, ws_T, LDT);        
         }
         break; /* END CASE */

      #if defined(ATL_USEPTHREADS)  /* Cases 2 & 3 only for parallel. */
      case 2: /* PCA COPY */
      case 3: /* PCA NOCOPY (but does not exist for RQ) */
         if (buildT || (M > minMN) )
         {
            buildT_temp = 1;
         }
         else
         {
            buildT_temp = buildT;
         }

         /* Here minMN, N are reversed */ 
         ATL_tgerq2(N, minMN,  A+((M-minMN) SHIFT), LDA, TAU, @(wks),
                    ws_T, LDT, WORKM, buildT_temp, 1);
         break; /* END CASE */
      #endif /* defined(ATL_USEPTHREADS) */
   } /* END SWITCH on method */
 
   /* Common code for cases Serial, PCA COPY, PCA NOCOPY */
   if (M > minMN)
   {
      ATL_larfb(CblasRight, CblasNoTrans,       
                LABackward, LARowStore, M-minMN, N, minMN, A+((M -minMN) SHIFT),
                LDA, (ws_T), LDT, A, LDA, WORKM, M);                          
   }

@ROUT ATL_geqrr ATL_geqlr ATL_gerqr ATL_gelqr
   return(0);
} /* END ATL_@(rec) */


@ROUT ATL_lapy2
@extract -b @(topd)/cw.inc lang=C -def cwdate 2009 -def cwdate 2012 -def cwauth "Siju Samuel" -def contrib "Anthony M. Castaldo, R. Clint Whaley"

/*
 * This is the C translation of the standard LAPACK Fortran routine:
 *      DOUBLE PRECISION FUNCTION DLAPY2( X, Y )
 *
 *      It is important to use the appropriate sqrt function for the
 *      precision given in order to test against the LAPACK fortran 
 *      reference library; in particular due to high serial data 
 *      dependence the SGEHRD routine can drift far enough on larger
 *      problems to appear to be in error; about 0.0004 in a single
 *      result element. (Modification by Tony Castaldo, 12/29/2011).
 *
 *  Purpose
 *  =======
 *
 *  DLAPY2 returns sqrt(x**2+y**2), taking care not to cause unnecessary
 *  overflow.
 *
 *  Arguments
 *  =========
 *
 *  X       (input) single/double precision
 *  Y       (input) single/double precision
 *          X and Y specify the values x and y.
 *
 */
#include "atlas_misc.h"
#include "cblas.h"
#include "atlas_lapack.h"
#include "math.h"

TYPE  ATL_lapy2(TYPE X, TYPE Y)
{
   TYPE  ONE=1.0, ZERO=0.0, W, Z, XABS, YABS, TEMP;

/* Find absolute values                                                       */
   XABS = Mabs(X);
   YABS = Mabs(Y);
   W = (XABS<YABS)?YABS:XABS;
   Z = (XABS<YABS)?XABS:YABS;

   if (Z == ZERO) return(W);
/* NOTE: If Z != 0, then W != 0                                               */
   TEMP = Z/W;

   TEMP = ONE + TEMP*TEMP;
   #if defined(SREAL) || defined(SCPLX)
   return(W * sqrtf(TEMP));                     /* Use single precision sqrt. */
   #else
   return(W * sqrt(TEMP));                      /* Use double precision sqrt. */
   #endif 
}                                               /* END ATL_?lapy2             */


@ROUT ATL_larfb
@extract -b @(topd)/cw.inc lang=C -def cwdate 2009 -def cwauth "Siju Samuel" -def contrib "Anthony M. Castaldo, R. Clint Whaley"
/*
 * This is the C translation of the standard LAPACK Fortran routine:
 *     SUBROUTINE DLARFB( SIDE, TRANS, DIRECT, STOREV, M, N, K, V, LDV,
 *     $                   T, LDT, C, LDC, WORK, LDWORK )
 *
 * ATL_larfb.c :
 *
 * void ATL_larfb(const enum CBLAS_SIDE SIDE, const enum CBLAS_TRANSPOSE TRANS,
 *     const enum ATL_LADIRECT  DIRECT, const enum ATL_LASTOREV STOREV,
 *                int M, int N, int K, TYPE *V, int LDV, TYPE *T, int LDT,
 *               TYPE *C, int LDC, TYPE *WORK, int LDWORK)
 *
 *
 *     NOTE :   ATL_larfb.c will get compiled to four precisions
 *                    single precision real,      double precision real
 *                    single precision complex,   double precision complex
 *  Purpose
 *  =======
 *
 *  ATL_larf  applies a real block reflector H or its transpose H' to a
 *  real/complex m by n matrix C, from either the left or the right.
 *
 *  Arguments
 *  =========
 *
 *  SIDE    (input) CHARACTER*1
 *          = 'L': apply H or H' from the Left
 *          = 'R': apply H or H' from the Right
 *
 *  TRANS   (input) CHARACTER*1
 *          = 'N': apply H (No transpose)
 *          = 'T': apply H' (Transpose for real)
 *          = 'C': apply H' (Conjugate Transpose for
 *                   complex)
 *
 *  DIRECT  (input) CHARACTER*1
 *          Indicates how H is formed from a product of elementary
 *          reflectors
 *          = 'F': H = H(1) H(2) . . . H(k) (Forward)
 *          = 'B': H = H(k) . . . H(2) H(1) (Backward)
 *
 *  STOREV  (input) CHARACTER*1
 *          Indicates how the vectors which define the elementary
 *          reflectors are stored:
 *          = 'C': Columnwise
 *          = 'R': Rowwise
 *
 *  M       (input) INTEGER
 *          The number of rows of the matrix C.
 *
 *  N       (input) INTEGER
 *          The number of columns of the matrix C.
 *
 *  K       (input) INTEGER
 *          The order of the matrix T (= the number of elementary
 *          reflectors whose product defines the block reflector).
 *
 *  V       (input)  array, dimension
 *                                (LDV,K) if STOREV = 'C'
 *                                (LDV,M) if STOREV = 'R' and SIDE = 'L'
 *                                (LDV,N) if STOREV = 'R' and SIDE = 'R'
 *          The matrix V. See further details.
 *
 *  LDV     (input) INTEGER
 *          The leading dimension of the array V.
 *          If STOREV = 'C' and SIDE = 'L', LDV >= max(1,M);
 *          if STOREV = 'C' and SIDE = 'R', LDV >= max(1,N);
 *          if STOREV = 'R', LDV >= K.
 *
 *  T       (input)  array, dimension (LDT,K)
 *          The triangular k by k matrix T in the representation of the
 *          block reflector.
 *
 *  LDT     (input) INTEGER
 *          The leading dimension of the array T. LDT >= K.
 *
 *  C       (input/output)  array, dimension (LDC,N)
 *          On entry, the m by n matrix C.
 *          On exit, C is overwritten by H*C or H'*C or C*H or C*H'.
 *
 *  LDC     (input) INTEGER
 *          The leading dimension of the array C. LDA >= max(1,M).
 *
 *  WORK    (workspace) array, dimension (LDWORK,K)
 *
 *  LDWORK  (input) INTEGER
 *          The leading dimension of the array WORK.
 *          If SIDE = 'L', LDWORK >= max(1,N);
 *          if SIDE = 'R', LDWORK >= max(1,M).
 *
 *  =====================================================================
 *  TonyC: When called by dgeqrf, V=&A(I,I), LDV=LDA. T=WORK, LDT=LDWORK.
 *  C=&A(I,I+IB), LDC=LDA. WORK=&WORK(IB+1), LDWORK=LDWORK. K=IB.
 */
#include "atlas_misc.h"
#include "cblas.h"
#include "atlas_lapack.h"

#ifdef TREAL
    #define MY_TRANS CblasTrans
#else
    #define MY_TRANS CblasConjTrans
#endif

void ATL_larfb(const enum CBLAS_SIDE SIDE, const enum CBLAS_TRANSPOSE TRANS,
               const enum ATL_LADIRECT  DIRECT, const enum ATL_LASTOREV STOREV,
               ATL_CINT M, ATL_CINT N, ATL_CINT K, const TYPE *V, ATL_CINT LDV,
               const TYPE *T, ATL_CINT LDT, TYPE *C, ATL_CINT LDC, 
               TYPE *WORK, ATL_CINT LDWORK)

{
   enum CBLAS_TRANSPOSE CTRANS, CTRANST;
   int    i, j;
   int  LDV2,LDC2, LDWORK2;
   LDV2 = LDV SHIFT;                        /* For complex, LDV*2             */
   LDC2 = LDC SHIFT;                        /* For complex, LDC*2             */
   LDWORK2 = LDWORK SHIFT;                  /* For complex, LDWORK * 2        */

   #ifdef TREAL
      const TYPE ONE = ATL_rone;
      const TYPE ZEROVAL = ATL_rzero;
      const TYPE NONE = ATL_rnone;
   #else
      const TYPE ONE[2] = {ATL_rone, ATL_rzero};
      const TYPE NONE[2] = {ATL_rnone, ATL_rzero};
      const TYPE ZEROVAL[2] = {ATL_rzero, ATL_rzero};
   #endif

/* Quick return if possible                                                   */
   if (M <= 0 || N <= 0) return;            /* Early exit                     */

/*    Translate the Transpose and Transpose-Transpose settings                */
   if (TRANS == CblasNoTrans )
   {
      CTRANS = CblasNoTrans;
      #ifdef TREAL
         CTRANST = CblasTrans;
      #else
         CTRANST = CblasConjTrans;
      #endif
   } else
   {
      #ifdef TREAL
         CTRANS = CblasTrans;
      #else
         CTRANS = CblasConjTrans;
      #endif
      CTRANST = CblasNoTrans;
   }

   if (STOREV == LAColumnStore)
   {
      if (DIRECT == LAForward )
      {
/*
 *           Let  V =  ( V1 )    (first K rows)
 *                     ( V2 )
 *           where  V1  is unit lower triangular.
 */
            if (SIDE == CblasLeft)
            {
/*
 *             Form  H * C  or  H' * C  where  C = ( C1 )
 *                                                 ( C2 )
 *
 *             W := C' * V  =  (C1'*V1 + C2'*V2)  (stored in WORK)
 *
 *             W := C1'
 */
               for (j=0; j<K; j++)
               {
                  cblas_copy(N, C+(j SHIFT), LDC, WORK+j*LDWORK2, 1);
/*                For complex, make it conjugate                              */
                  #ifdef TCPLX
                     ATL_lacgv(N,  WORK+j*LDWORK2, 1);
                  #endif
               }

/*
 *             W := W * V1
 */
               cblas_trmm(CblasColMajor, CblasRight, CblasLower, CblasNoTrans,
                          CblasUnit, N, K, ONE, V, LDV, WORK, LDWORK);

               if (M > K)
               {
/*
 *                 W := W + C2'*V2
 */
                 
                  cblas_gemm(CblasColMajor, MY_TRANS, CblasNoTrans,
                             N, K, M-K, ONE, C+(K SHIFT), LDC, V+(K SHIFT),
                             LDV, ONE, WORK, LDWORK);
               }
/*
 *             W := W * T'  or  W * T
 *
 *             'T' is the non-unit upper triangular array, on the right.
 *             alpha is one.
 */
               cblas_trmm(CblasColMajor,
                          CblasRight, CblasUpper, CTRANST, CblasNonUnit,
                          N, K, ONE, T, LDT, WORK, LDWORK);
/*
 *             C := C - V * W'
 */
               if (M > K)
               {
/*
 *                 C2 := C2 - V2 * W'
 */
                  cblas_gemm(CblasColMajor,
                             CblasNoTrans, MY_TRANS, M-K, N, K, NONE,
                             V+(K SHIFT), LDV, WORK, LDWORK, ONE,
                             C+(K SHIFT), LDC);
               }
/*
 *             W := W * V1'
 */
               cblas_trmm(CblasColMajor, CblasRight, CblasLower,
                          MY_TRANS, CblasUnit, N, K, ONE, V, LDV, WORK, LDWORK);
/*
 *             C1 := C1 - W'
 */
               for (j=0; j< (K ) ; j++)
               {
                  for (i=0; i<N; i++)
                  {
                     #ifdef TREAL
                        C[j+i*LDC2] -= WORK[i+j*LDWORK2];
                     #else
                        C[(j SHIFT) +i*LDC2] -= WORK[(i SHIFT) +j*LDWORK2];
/*                      Conjugate is taken, hence the addition                */
                        C[(j SHIFT)+i*LDC2+1] += WORK[(i SHIFT)+j*LDWORK2+1];
                     #endif
                  }
               }                            /* for                            */
            } else if (SIDE == CblasRight)
            {
/*
 *             Form  C * H  or  C * H'  where  C = ( C1  C2 )
 *
 *             W := C * V  =  (C1*V1 + C2*V2)  (stored in WORK)
 *
 *             W := C1
 */
               for (j=0; j<K; j++)
               {
                  cblas_copy(M, C+(j*LDC2), 1, WORK+j*LDWORK2, 1);
               }

/*
 *              W := W * V1
 *
 */
               cblas_trmm(CblasColMajor, CblasRight, CblasLower,
                          CblasNoTrans, CblasUnit, M, K, ONE, V, LDV,
                          WORK, LDWORK);
               if (N > K)
               {
/*
 *                 W := W + C2 * V2
 *
 */
                  cblas_gemm(CblasColMajor, CblasNoTrans, CblasNoTrans,
                             M, K, N-K, ONE, C+K*LDC2, LDC,
                             V+(K SHIFT), LDV,ONE,WORK,LDWORK);
               }
/*
 *              W := W * T  or  W * T'
 *
 */
               cblas_trmm(CblasColMajor, CblasRight, CblasUpper, CTRANS,
                          CblasNonUnit, M, K, ONE, T, LDT, WORK, LDWORK);
/*
 *              C := C - W * V'
 */
               if (N > K)
               {
/*
 *                 C2 := C2 - W * V2'
 *
 */
                  cblas_gemm(CblasColMajor, CblasNoTrans, MY_TRANS, M, N-K, K,
                             NONE, WORK, LDWORK, V+(K SHIFT), LDV, ONE,
                             C+K*LDC2, LDC);
               }
/*
 *              W := W * V1'
 *
 */
               cblas_trmm(CblasColMajor, CblasRight, CblasLower, MY_TRANS,
                          CblasUnit, M, K, ONE, V, LDV, WORK, LDWORK);

/*
 *              C1 := C1 - W
 *
 */
               for (j=0; j<K; j++)
               {
                  for (i=0; i<M; i++)
                  {
                     #ifdef TREAL 
                        C[i+j*LDC] -= WORK[i+j*LDWORK];
                     #else
                        C[(i SHIFT)+j*LDC2] -= WORK[(i SHIFT)+j*LDWORK2];
                        C[(i SHIFT)+j*LDC2+1] -= WORK[(i SHIFT)+j*LDWORK2+1];
                     #endif
                  }
               }
            }                               /* SIDE == CblasRight             */
         } else                             /* DIRECT != LAForward            */
         {
/*
 *           Let  V =  ( V1 )
 *                     ( V2 )    (last K rows)
 *           where  V2  is unit upper triangular.
 */
            if (SIDE == CblasLeft)
            {
/*             Form  H * C  or  H' * C  where  C = ( C1 )
 *                                                  ( C2 )
 *
 *              W := C' * V  =  (C1'*V1 + C2'*V2)  (stored in WORK)
 *
 *              W := C2'
 *
 */
               for (j=0; j<K; j++)
               {
                  cblas_copy(N, C +((M-K+j) SHIFT) , LDC, WORK+j*LDWORK2, 1);
/*                For complex, make it conjugate                              */
                  #ifdef TCPLX
                     ATL_lacgv(N,  WORK+j*LDWORK2, 1);
                  #endif
               }

/*
 *              W := W * V2
 *
 */
               cblas_trmm(CblasColMajor, CblasRight, CblasUpper, CblasNoTrans,
                          CblasUnit, N, K, ONE, V+((M-K) SHIFT), LDV, WORK,
                          LDWORK);

               if (M > K)
               {

/*
 *                 W := W + C1'*V1
 *
 */
                  cblas_gemm(CblasColMajor, MY_TRANS, CblasNoTrans, N, K, M-K,
                             ONE, C, LDC, V, LDV, ONE, WORK, LDWORK);
               }

/*
 *              W := W * T'  or  W * T
 *
 */
               cblas_trmm(CblasColMajor, CblasRight, CblasLower, CTRANST,
                          CblasNonUnit, N, K, ONE, T, LDT, WORK, LDWORK);

/*
 *             C := C - V * W'
 */
               if (M > K)
               {

/*
 *                 C1 := C1 - V1 * W'
 */
                  cblas_gemm(CblasColMajor, CblasNoTrans, MY_TRANS, M-K,
                             N, K, NONE, V, LDV, WORK, LDWORK, ONE, C, LDC);
               }

/*
 *              W := W * V2'
 *
 */
               cblas_trmm(CblasColMajor, CblasRight, CblasUpper, MY_TRANS,
                          CblasUnit, N, K, ONE, V+((M-K) SHIFT), LDV,
                          WORK, LDWORK);
/*
 *              C2 := C2 - W'
 */
               for (j=0; j<K; j++)
               {
                  for (i=0; i<N; i++)
                  {
                     #ifdef TREAL
                        C[M-K+j+i*LDC] -= WORK[i+j*LDWORK];
                     #else
                        C[((M-K+j) SHIFT)+i*LDC2] -= WORK[(i SHIFT)+j*LDWORK2];
/*                      Conjugate is taken, hence the addition                */
                        C[((M-K+j) SHIFT)+1+i*LDC2] += 
                                                   WORK[(i SHIFT)+1+j*LDWORK2];
                    #endif
                  }
               }
            } else if (SIDE == CblasRight)
            {
/*
 *              Form  C * H  or  C * H'  where  C = ( C1  C2 )
 *
 *              W := C * V  =  (C1*V1 + C2*V2)  (stored in WORK)
 *
 *              W := C2
 *
 */
               for (j=0; j<K; j++)
               {
                  cblas_copy(M, C+(N-K+j)*LDC2, 1, WORK+(j*LDWORK2), 1);
               }

/*
 *              W := W * V2
 */
               cblas_trmm(CblasColMajor, CblasRight, CblasUpper, CblasNoTrans,
                          CblasUnit, M, K, ONE, V+((N-K) SHIFT), LDV, WORK,
                          LDWORK);
               if (N > K)
               {
/*
 *                 W := W + C1 * V1
 */
                  cblas_gemm(CblasColMajor, CblasNoTrans, CblasNoTrans, M,
                             K, N-K, ONE, C, LDC, V, LDV, ONE, WORK, LDWORK);
               }

/*
 *              W := W * T  or  W * T'
 */
               cblas_trmm(CblasColMajor, CblasRight, CblasLower, CTRANS,
                          CblasNonUnit, M, K, ONE, T, LDT, WORK, LDWORK);

/*
 *              C := C - W * V'
 */

               if (N > K)
               {
/*
 *                 C1 := C1 - W * V1'
 */
                  cblas_gemm(CblasColMajor, CblasNoTrans, MY_TRANS, M, N-K,
                             K, NONE, WORK, LDWORK, V, LDV, ONE, C, LDC);
               }

/*
 *              W := W * V2'
 */
               cblas_trmm(CblasColMajor, CblasRight, CblasUpper, MY_TRANS,
                          CblasUnit, M, K, ONE, V+((N-K) SHIFT),
                          LDV, WORK, LDWORK);

/*
 *              C2 := C2 - W
 */
               for (j=0; j<K; j++)
               {
                  for (i=0; i<M; i++)
                  {
                     #ifdef TREAL 
                        C[i+(N-K+j)*LDC] -= WORK[i+j*LDWORK];
                     #else
                        C[(i SHIFT)+(N-K+j)*LDC2] -= WORK[(i SHIFT)+j*LDWORK2];
                        C[(i SHIFT)+(N-K+j)*LDC2+1] -= 
                                                   WORK[(i SHIFT)+j*LDWORK2+1];
                     #endif
                  }
               }
            }                               /* END IF SIDE == CblasRight      */
         }
      } else if (STOREV == LARowStore)
      {
         if (DIRECT == LAForward)
         {

/*           Let  V =  ( V1  V2 )    (V1: first K columns)
 *           where  V1  is unit upper triangular.
 */
            if (SIDE == CblasLeft)
            {
/*
 *              Form  H * C  or  H' * C  where  C = ( C1 )
 *
 *              W := C' * V'  =  (C1'*V1' + C2'*V2') (stored in WORK)
 *
 *              W := C1'
 */
               for (j=0; j<K; j++)
               {
                  cblas_copy(N, C+(j SHIFT), LDC, WORK+j*LDWORK2, 1);
                  #ifdef TCPLX
                     ATL_lacgv(N,  WORK+j*LDWORK2, 1);
                  #endif 
               }
/*
 *              W := W * V1'
 *
 */
               cblas_trmm(CblasColMajor, CblasRight, CblasUpper, MY_TRANS,
                          CblasUnit, N, K, ONE, V, LDV, WORK, LDWORK);

               if (M > K)
               {
/*
 *                 W := W + C2'*V2'
 */
                  cblas_gemm(CblasColMajor, MY_TRANS, MY_TRANS, N, K, M-K,
                             ONE, C+(K SHIFT), LDC, V+(K*LDV2), LDV, ONE, WORK,
                             LDWORK);
               }

/*
 *              W := W * T'  or  W * T
 *
 */
               cblas_trmm(CblasColMajor, CblasRight, CblasUpper, CTRANST,
                          CblasNonUnit, N, K, ONE, T, LDT, WORK, LDWORK);

/*
 *              C := C - V' * W'
 */
               if (M > K)
               {
/*
 *                 C2 := C2 - V2' * W'
 */
                  cblas_gemm(CblasColMajor, MY_TRANS, MY_TRANS, M-K, N, K,
                             NONE, V+(K*LDV2), LDV, WORK, LDWORK,
                             ONE, C+(K SHIFT), LDC);
               }

/*
 *              W := W * V1
 */
               cblas_trmm(CblasColMajor, CblasRight, CblasUpper, CblasNoTrans,
                          CblasUnit, N, K, ONE, V, LDV, WORK, LDWORK);

/*
 *              C1 := C1 - W'
 */
               for (j=0; j<K; j++)
               {
                  for (i=0; i<N; i++)
                  {
                     #ifdef TREAL
                        C[j+i*LDC] -= WORK[i+j*LDWORK];
                     #else
                        C[(j SHIFT) +i*LDC2] -= WORK[(i SHIFT)+j*LDWORK2];
/*                      Conjugate is taken, hence the addition                */
                        C[(j SHIFT)+i*LDC2+1] += WORK[(i SHIFT)+j*LDWORK2+1];
                     #endif
                  }
               }
            } else if (SIDE == CblasRight)
            {

/*              Form  C * H  or  C * H'  where  C = ( C1  C2 )
 *
 *              W := C * V'  =  (C1*V1' + C2*V2')  (stored in WORK)
 *
 *              W := C1
 */

               for (j=0; j<K; j++)
               {
                  cblas_copy(M, C+j*LDC2, 1, WORK+j*LDWORK2, 1);
               }

/*
 *              W := W * V1'
 *
 */
               cblas_trmm(CblasColMajor, CblasRight, CblasUpper, MY_TRANS,
                          CblasUnit, M, K, ONE, V, LDV, WORK, LDWORK);

               if (N > K)
               {
/*
 *                 W := W + C2 * V2'
 */
                  cblas_gemm(CblasColMajor, CblasNoTrans, MY_TRANS,
                             M, K, N-K, ONE, C+(K*LDC2), LDC, V+(K*LDV2),
                             LDV, ONE, WORK, LDWORK);

               }
/*
 *              W := W * T  or  W * T'
 */
               cblas_trmm(CblasColMajor, CblasRight, CblasUpper, CTRANS,
                          CblasNonUnit, M, K, ONE, T, LDT, WORK, LDWORK);
/*
 *              C := C - W * V
 */
               if (N > K)
               {
/*
 *                 C2 := C2 - W * V2
 */
                  cblas_gemm(CblasColMajor, CblasNoTrans, CblasNoTrans,
                             M, N-K, K, NONE, WORK, LDWORK, V+(K*LDV2),
                             LDV, ONE, C+(K*LDC2), LDC);
               }
/*
 *              W := W * V1
 */
               cblas_trmm(CblasColMajor, CblasRight, CblasUpper, 
                          CblasNoTrans, CblasUnit, M, K, ONE, V, LDV,
                          WORK, LDWORK);
/*
 *              C1 := C1 - W
 *
 */
               for (j=0; j<K; j++)
               {
                  for (i=0; i<M; i++)
                  {
                     #ifdef TREAL
                        C[i+j*LDC] -= WORK[i+j*LDWORK];
                     #else
                        C[(i SHIFT)+j*LDC2] -= WORK[(i SHIFT)+j*LDWORK2];
                        C[(i SHIFT)+1+j*LDC2] -= WORK[(i SHIFT)+1+j*LDWORK2];
                     #endif
                  }
               }
            }                               /* END if SIDE == CblasRight      */
         } else                             /* DIRECT != LAForward            */
         {
/*          Let  V =  ( V1  V2 )    (V2: last K columns)
 *           where  V2  is unit lower triangular.
 */
            if (SIDE == CblasLeft)
            {

/*              Form  H * C  or  H' * C  where  C = ( C1 )
 *                                                  ( C2 )
 *
 *              W := C' * V'  =  (C1'*V1' + C2'*V2') (stored in WORK)
 *
 *              W := C2'
 *
 */
               for (j=0; j<K; j++)
               {
                  cblas_copy(N, C+((M-K+j) SHIFT), LDC, WORK+j*LDWORK2, 1);
/*                For complex, make it conjugate                              */
                  #ifdef TCPLX
                     ATL_lacgv(N,  WORK+j*LDWORK2, 1);
                  #endif 
               }

/*
 *              W := W * V2'
 */
               cblas_trmm(CblasColMajor, CblasRight, CblasLower, MY_TRANS,
                          CblasUnit, N, K, ONE, V+(M-K)*LDV2, LDV,
                          WORK, LDWORK);

               if (M > K)
               {
/*
 *                 W := W + C1'*V1'
 */
                  cblas_gemm(CblasColMajor, MY_TRANS, MY_TRANS, N, K, M-K,
                             ONE, C, LDC, V, LDV, ONE, WORK, LDWORK);
               }

/*
 *              W := W * T'  or  W * T
 *
 */
               cblas_trmm(CblasColMajor, CblasRight, CblasLower, CTRANST,
                          CblasNonUnit, N, K, ONE, T, LDT, WORK, LDWORK);

/*
 *              C := C - V' * W'
 */
               if (M > K)
               {
/*
 *                 C1 := C1 - V1' * W'
 *
 */
                  cblas_gemm(CblasColMajor, MY_TRANS, MY_TRANS, M-K, N, K,
                             NONE, V, LDV, WORK, LDWORK, ONE, C, LDC);
               }

/*
 *              W := W * V2
 *
 */
               cblas_trmm(CblasColMajor, CblasRight, CblasLower, 
                          CblasNoTrans, CblasUnit, N, K, ONE, V+(M-K)*LDV2,
                          LDV, WORK, LDWORK);
/*
 *              C2 := C2 - W'
 *
 */
               for (j=0; j<K; j++)
               {
                  for (i=0; i<N; i++)
                  {
                     #ifdef TREAL 
                        C[M-K+j+i*LDC] -= WORK[i+j*LDWORK];
                     #else 
                        C[((M-K+j) SHIFT) +i*LDC2] -= WORK[(i SHIFT)+j*LDWORK2];
/*                      Conjugate is taken, hence the addition                */
                        C[((M-K+j) SHIFT)+i*LDC2+1] += 
                                                   WORK[(i SHIFT)+j*LDWORK2+1];
                     #endif 
                  }
               }
            } else if (SIDE == CblasRight)
            {

/*             Form  C * H  or  C * H'  where  C = ( C1  C2 )
 *
 *              W := C * V'  =  (C1*V1' + C2*V2')  (stored in WORK)
 *
 *              W := C2
 */
               for (j=0; j<K; j++)
               {
                  cblas_copy(M, C+(N-K+j)*LDC2, 1, WORK+j*LDWORK2, 1);
               }

/*
 *              W := W * V2'
 */
               cblas_trmm(CblasColMajor, CblasRight, CblasLower, MY_TRANS,
                          CblasUnit, M, K, ONE, V+(N-K)*LDV2, LDV,
                          WORK, LDWORK);

               if (N > K)
               {
/*
 *                 W := W + C1 * V1'
 */
                  cblas_gemm(CblasColMajor, CblasNoTrans, MY_TRANS, M, K,
                             N-K, ONE, C, LDC, V, LDV, ONE, WORK, LDWORK);
               }
/*
 *              W := W * T  or  W * T'
 */
               cblas_trmm(CblasColMajor, CblasRight, CblasLower, CTRANS,
                          CblasNonUnit, M, K, ONE, T, LDT, WORK, LDWORK);
/*
 *              C := C - W * V
 */
               if (N > K)
               {
/*
 *                 C1 := C1 - W * V1
 */
                  cblas_gemm(CblasColMajor, CblasNoTrans, CblasNoTrans, M, N-K,
                             K, NONE, WORK, LDWORK, V, LDV, ONE, C, LDC);
               }

/*
 *              W := W * V2
 */
               cblas_trmm(CblasColMajor, CblasRight, CblasLower, CblasNoTrans,
                          CblasUnit, M, K, ONE, V+(N-K)*LDV2, LDV,
                          WORK, LDWORK);

/*
 *              C1 := C1 - W   TODO: check this  C2 : = C2 - W
 */
               for (j=0; j<K; j++)
               {
                  for (i=0; i<M; i++)
                  {
                     #ifdef TREAL
                        C[i+(N-K+j)*LDC] -= WORK[i+j*LDWORK];
                     #else
                        C[(i SHIFT)+(N-K+j)*LDC2] -= WORK[(i SHIFT)+j*LDWORK2];
                        C[(i SHIFT)+1+(N-K+j)*LDC2] -= 
                                                   WORK[(i SHIFT)+1+j*LDWORK2];
                     #endif
                  }
               }
            }                               /* END IF SIDE == CblasRight      */
         }                                  /* END else DIRECT != LAForward   */
      }                                     /* END if STOREV == LARowwise     */
      return;
}                                           /* END ATL_larfb                  */

@ROUT ATL_larf
@extract -b @(topd)/cw.inc lang=C -def cwdate 2009 -def cwauth "Siju Samuel" -def contrib "Anthony M. Castaldo, R. Clint Whaley"

/*
 * This is the C translation of the standard LAPACK Fortran routine:
 *      SUBROUTINE DLARF( SIDE, M, N, V, INCV, TAU, C, LDC, WORK )
 *
 * ATL_larf.c
 * void ATL_larf(const enum  CBLAS_SIDE SIDE, const int M, const int N,TYPE *V,
 *              int INCV, SCALAR TAU, TYPE *C, int LDC, TYPE *WORK)
 *
 *     NOTE :   ATL_larf.c will get compiled to four precisions
 *                   single precision real,      double precision real
 *                   single precision complex,   double precision complex
 *
 *  Purpose
 *  =======
 *
 *  ATL_larf  applies a real/complex elementary reflector H to a real/complex
 *  m by n matrix  C, from either the left or the right. H is represented in
 *  the form
 *
 *        H = I - tau * v * v'                      ( For Real precision)
 *        H = I - tau * v * conjugate(v)'           ( For Real precision)
 *
 *  where tau is a real/complex  scalar and v is a real/complex  vector.
 *
 *  If tau = 0, then H is taken to be the unit matrix.
 *
 *  Arguments
 *  =========
 *
 *  SIDE    (input) CHARACTER*1
 *          = 'L': form  H * C
 *          = 'R': form  C * H
 *
 *  M       (input) INTEGER
 *          The number of rows of the matrix C.
 *
 *  N       (input) INTEGER
 *          The number of columns of the matrix C.
 *
 *  V       (input) array, dimension
 *                     (1 + (M-1)*abs(INCV)) if SIDE = 'L'
 *                  or (1 + (N-1)*abs(INCV)) if SIDE = 'R'
 *          The vector v in the representation of H. V is not used if
 *          TAU = 0.
 *
 *  INCV    (input) INTEGER
 *          The increment between elements of v. INCV <> 0.
 *
 *  TAU     (input)
 *          The value tau in the representation of H.
 *          For complex  precison, it is a pointer  to  array
 *
 *  C       (input/output) array, dimension (LDC,N)
 *          On entry, the m by n matrix C.
 *          On exit, C is overwritten by the matrix H * C if SIDE = 'L',
 *          or C * H if SIDE = 'R'.
 *
 *  LDC     (input) INTEGER
 *          The leading dimension of the array C. LDC >= max(1,M).
 *
 *  WORK    (workspace) array, dimension
 *                         (N) if SIDE = 'L'
 *                      or (M) if SIDE = 'R'
 *
 */
#include "atlas_misc.h"
#include <math.h>
#include "cblas.h"
#include "atlas_lapack.h"

#ifdef TREAL
    #define MY_TRANS CblasTrans
#else
    #define MY_TRANS CblasConjTrans
#endif

void ATL_larf(const enum CBLAS_SIDE SIDE, ATL_CINT M, ATL_CINT N,
              const TYPE *V, ATL_CINT INCV, const SCALAR TAU, 
              TYPE *C, int LDC, TYPE *WORK)
{
   #ifdef TREAL
      const TYPE ONE     = ATL_rone;
      const TYPE ZEROVAL = ATL_rzero;
      TYPE NEGTAUVAL ;
   #else
      const TYPE ONE[2]     = {ATL_rone, ATL_rzero};
      const TYPE ZEROVAL[2] = {ATL_rzero, ATL_rzero};
      TYPE NEGTAUVAL[2] ;
   #endif

   if (SIDE == CblasLeft)
   {
/*
 *        Form  H * C
 */
      if (! SCALAR_IS_ZERO(TAU) )
      {
         #ifdef TREAL
            NEGTAUVAL = 0.-TAU;
         #else
            NEGTAUVAL[0]=0.-TAU[0];
            NEGTAUVAL[1]=0.-TAU[1];
         #endif
/*
 *           w := C' * v
 */
         cblas_gemv(CblasColMajor, MY_TRANS, M, N, ONE, C, LDC,
                    V, INCV, ZEROVAL, WORK, 1);
/*
 *           C := C - v * w'
 */
         #ifdef TREAL
            cblas_ger(CblasColMajor, M, N, NEGTAUVAL, V, INCV, WORK, 1,
                      C, LDC);
         #else
            cblas_gerc(CblasColMajor, M, N, NEGTAUVAL, V, INCV, WORK, 1,
                       C, LDC);
         #endif

      }
   }
   else                                     /* SIDE != CblasLeft              */
   {
/*
 *        Form  C * H
 */
      if (! SCALAR_IS_ZERO(TAU) )
      {
         #ifdef TREAL
            NEGTAUVAL = 0.-TAU;
         #else
            NEGTAUVAL[0]=0.-TAU[0];
            NEGTAUVAL[1]=0.-TAU[1];
         #endif
/*
 *           w := C * v
 */
         cblas_gemv(CblasColMajor, CblasNoTrans, M, N, ONE,
                    C, LDC, V, INCV, ZEROVAL, WORK, 1);
/*
 *           C := C - w * v'
 */
         #ifdef TREAL
            cblas_ger(CblasColMajor, M, N, NEGTAUVAL, WORK, 1,
                      V, INCV, C, LDC);
         #else
            cblas_gerc(CblasColMajor, M, N, NEGTAUVAL, WORK, 1,
                       V, INCV, C, LDC);
         #endif
      }
   }
      return;
}                                           /* END ATL_larf                   */
@ROUT ATL_larfg
@extract -b @(topd)/cw.inc lang=C -def cwdate 2009 -def cwauth "Siju Samuel" -def contrib "Anthony M. Castaldo, R. Clint Whaley"

/*
 * This is the C translation of the standard LAPACK Fortran routine:
 *     SUBROUTINE DLARFG( N, ALPHA, X, INCX, TAU )
 *
 * ATL_larfg.c :
 * void ATL_larfg( const int N, TYPE *ALPHA, TYPE *X, int INCX, TYPE *TAU)
 *        NOTE : ATL_larfg.c  will get compiled to 4 precisions
 *               single precision real,      double precision real
 *               single precision complex,   double precision complex
 *  Purpose
 *  =======
 *
 *  Real Precision
 *  --------------
 *
 *  ATL_larfg generates a real/complex  elementary reflector H of order n, such
 *  that
 *
 *        H * ( alpha ) = ( beta ),   H' * H = I.
 *            (   x   )   (   0  )
 *
 *  where alpha and beta are scalars, and x is an (n-1)-element real
 *  vector. H is represented in the form
 *
 *        H = I - tau * ( 1 ) * ( 1 v' ) ,                 (Real Precisions)
 *                      ( v )
 *
 *        H = I - tau * ( 1 ) * ( 1 conjugate(v)' ) ,     (Complex Precisions)
 *                      ( v )
 *
 *  where tau is a real/complex scalar and v is a real/complex (n-1)-element
 *  vector.
 *
 *  If the elements of x are all zero, then tau = 0 and H is taken to be
 *  the unit matrix.
 *
 *  Otherwise  1 <= tau <= 2.
 *
 *
 *  Arguments
 *  =========
 *
 *  N       (input) INTEGER
 *          The order of the elementary reflector.
 *
 *  ALPHA   (input/output)
 *          On entry, the value alpha.
 *          On exit, it is overwritten with the value beta.
 *
 *  X       (input/output)   array pointer, dimension
 *                         (1+(N-2)*abs(INCX))
 *          On entry, the vector x.
 *          On exit, it is overwritten with the vector v.
 *
 *  INCX    (input) INTEGER
 *          The increment between elements of X. INCX > 0.
 *
 *  TAU     (output)
 *          value of tau.
 */
#include "atlas_misc.h"
#include <math.h>
#include "cblas.h"
#include "atlas_lapack.h"
#include "atlas_lamch.h"

/*----------------------------------------------------------------------------*/
/* HighLevel Logic : * Real Precision                                         */
/* ---------------------------------------------------------------------------*/
/* On entry from ATL_geqr2(or any other variant lq, ql, rq) ,                 */
/* *Alpha points at A[i,i] and *X points  at A[i+1, i].                       */
/* If N==1, cblas_nrm2 returns zero. The norm is actually                     */
/* found in two parts; XNORM is all of the column except for A[i,i], and if   */
/* that is zero, we return TAU of zero (so H = I).                            */
/* Otherwise, we combine XNORM and A[i,i] into BETAp using lapy2. So BETAp    */
/* is the actual norm2 of A[i:m, i].                                          */
/* We set BETA to BETAp but with the opposite sign as A[i,i]. This is done    */
/* to ensure that TAU is in [1,2].                                            */
/* We set TAU to (BETA-A[i,i])/BETA, and scale A[i+1:m,i] by 1/(A[i,i]-BETA). */
/* Finally, we replace A[i,i] with BETA.                                      */
/* Note that |A[i,i]-BETA| > |A[i,i]|. Treat the column as X=[x1, x2, x3],    */
/* and assume x1 > 0. Then we return X' (prime, not transpose) as:            */
/* x1' = -||X||  (The element actually on the diagonal, and part of R.)       */
/* x2' = x2/(x1+||X||)                                                        */
/* x3' = x3/(x1+||X||)                                                        */
/* TAU = (-||X||-x1)/-||X|| = (x1+||X||)/||X||                                */
/*                                                                            */
/* This is NOT a textbook Householder reflection, because [1 v]^T does not    */
/* have a norm of 1. The purpose seems to be to save the first storage        */
/* location; the '1' is not stored anywhere. The choice of whether to make    */
/* A[i,i] either +/- ||X|| is strictly to control the range of TAU, but has   */
/* the added value of making the Householder matrix unique for any given A.   */
/* Note that |x1| < | (x1+||X||) |, i.e. the magnitude is always increased,   */
/* so the magnitude of xi/(x1+||X||) is always decreased. I'm not sure if     */
/* that is intended to reduce error or not.                                   */
/*                                                                            */
/*----------------------------------------------------------------------------*/
/* Complex Precisions                                                         */
/*----------------------------------------------------------------------------*/
/* The  highlevel logic for Complex precision remains same as that of Real    */
/* precisions. The difference are                                             */
/*    BETAp is calculated using real part of A[i,i], imaginary part of A[i,i] */
/*    and XNORM using lapy3.                                                  */
/*                                                                            */
/*    ATL_ladiv is called to apply complex number devision before             */
/*    performing  the scaling operation for A[i+1:m,i] by 1/(A[i,i]-BETA).    */
/*                                                                            */
/*   NOTE :                                                                   */
/*    For Real precision and Complex precision, the codes are kept seperately */
/*    for clarity. ( Many code might be similar)                              */
/*----------------------------------------------------------------------------*/


void ATL_larfg(ATL_CINT N, TYPE *ALPHA, TYPE *X, ATL_CINT INCX, TYPE *TAU)
{

#ifdef TREAL
      TYPE ONE=1.0, ZERO=0.0, BETA, BETAp, RSAFMN, SAFMAX, XNORM;
      int    j, KNT;

      if (N < 1)
      {
         *TAU = ZERO;
         return;
      }

      XNORM = cblas_nrm2(N-1, X, INCX);     /* Get the norm2 .                */

      if (XNORM == ZERO)
      {
/*
 *        H  =  I
 */
         *TAU = ZERO;
      } else
      {
         BETAp = ATL_lapy2((*ALPHA), XNORM);/* Get sqrt(a^2+b^2)              */
         BETA = BETAp;                      /* Assume ALPHA < 0               */
         if ((*ALPHA) > 0) BETA = 0.-BETAp; /* Change if assumed wrong.       */

         if (BETAp < ATL_laSAFMIN)
         {
/*
 *           XNORM, BETA may be inaccurate; scale X and recompute them
 */
            RSAFMN = ONE / ATL_laSAFMIN;    /* Set a maximum                  */
            KNT = 0;

            while (BETAp < ATL_laSAFMIN)
            {
               KNT++;
               cblas_scal(N-1, RSAFMN, X, INCX);
               BETA *= RSAFMN;
               BETAp *= RSAFMN;
               *ALPHA *= RSAFMN;
            }
/*
 *          New BETA is at most 1, at least SAFMIN
 */
            XNORM = cblas_nrm2(N-1, X, INCX);
            BETA = ATL_lapy2((*ALPHA), XNORM);   /* Will always be positive   */
            if ((*ALPHA) > 0) BETA = -BETA; /* -SIGN(BETA, ALPHA)             */
            *TAU = (BETA-(*ALPHA)) / BETA;
            cblas_scal(N-1, ONE/((*ALPHA)-BETA), X, INCX);

/*
 *          If ALPHA is subnormal, it may lose relative accuracy
 */
            *ALPHA = BETA;
            for (j=0; j<KNT; j++)
            {
               (*ALPHA) *= ATL_laSAFMIN;
            }
         } else                             /* General case                   */
         {
            *TAU = (BETA-(*ALPHA)) / BETA;
            cblas_scal(N-1, ONE / ((*ALPHA)-BETA), X, INCX);
            *ALPHA = BETA;
         }
      }
      return;
/*
 *     End of  Real Precision ATL_larfg
 */
#else
/*
 *     Beginning of  Complex  Precision ATL_larfg
 */
      TYPE ONE=1.0, ZERO=0.0, BETA, BETAp, RSAFMN, SAFMAX, XNORM, ALPHI, ALPHR;
      TYPE ONEVAL[2] =  {ATL_rone, ATL_rzero};
      int j, KNT;

      if ( N < 0)
      {
/*
 *        H  =  I
 */
         *(TAU)  = 0.0;
         *(TAU + 1) = 0.0;
         return;
      }

      XNORM = cblas_nrm2(N-1, X, INCX);     /* Get the nrm2                   */

      ALPHR = *( ALPHA) ;
      ALPHI = *( ALPHA + 1) ;

      if ( (XNORM == ZERO) &&  (ALPHI == ZERO)  )
      {
/*
 *        H  =  I
 */
        *(TAU)  = 0.0;
        *(TAU + 1) = 0.0;
      }
      else
      {

         BETAp = ATL_lapy3(ALPHR, ALPHI, XNORM); /* Get sqrt(a^2 + b^2 + c^2) */
         BETA = BETAp;                      /* Assume ALPHA < 0               */
         if ( (*ALPHA) > 0) BETA = 0. - BETAp;   /* Change if assumed wrong   */

         RSAFMN = ONE / ATL_laSAFMIN ;

         if ( BETAp  <  ATL_laSAFMIN )
         {
/*
 *           XNORM, BETA may be inaccurate; scale X and recompute them
 */
            KNT = 0;
            while ( BETAp < ATL_laSAFMIN )
            {
               KNT++;
               #ifdef DCPLX
                  cblas_zdscal(N-1, RSAFMN, X, INCX);
               #else
                  cblas_csscal(N-1, RSAFMN, X, INCX);
               #endif
               BETA *= RSAFMN;
               BETAp *= RSAFMN;
               ALPHI = ALPHI*RSAFMN;
               ALPHR = ALPHR*RSAFMN;
            }

/*
 *           New BETA is at most 1, at least SAFMIN
 */
            XNORM = cblas_nrm2(N-1, X, INCX);
            *(ALPHA) = ALPHR;
            *(ALPHA + 1) = ALPHI;

            BETA = ATL_lapy3(ALPHR, ALPHI,
                                          XNORM);/* Will always be positive   */
            if (ALPHR > 0) BETA = -BETA;    /* -SIGN(BETA, ALPHR)             */
            *(TAU) = ( BETA-ALPHR ) / BETA ;
            *(TAU + 1) =  (-1.0 * ALPHI) / BETA ;
/*          Modify alpha   to alpha - beta,  which is equal to alphar -beta   */
            *(ALPHA) = *(ALPHA) - BETA;
/*          Perform complex division before scaling the X vector              */
            ATL_ladiv( ONEVAL,  ALPHA, ALPHA);   /* ALPHA will have the result*/
            cblas_scal(N-1, ALPHA, X, INCX);
/*
 *           If ALPHA is subnormal, it may lose relative accuracy
 */
            *(ALPHA) = BETA;                /* Real Part of alpha             */
            for (j=0; j<KNT; j++)
            {
               (*ALPHA) *= ATL_laSAFMIN;
            }
            *(ALPHA + 1) = 0.0;             /* Set Imaginary part to Zero     */
        }
        else                                /* BETA > SAFMIN                  */
        {

            *(TAU) = ( BETA-ALPHR ) / BETA ;
            *(TAU + 1) =  (-1.0 * ALPHI) / BETA ;

/*          Modify alpha   to alpha - beta, which is equal to alphar -beta    */
            *(ALPHA) = *(ALPHA) - BETA ;
/*          Perform complex division before scaling the X vector              */
            ATL_ladiv( ONEVAL,  ALPHA, ALPHA); 
            cblas_scal(N-1, ALPHA, X, INCX);
            *(ALPHA) = BETA;                /* Real Part of alpha             */
            *(ALPHA + 1) = 0.0;             /* Set Imaginary part to Zero     */
           }
      }
      return;
#endif
}                                           /* END ATL_larfg                  */

@ROUT ATL_larfgp
@extract -b @(topd)/cw.inc lang=C -def cwdate 2012 -def cwauth "Anthony M. Castaldo" -def contrib "Siju Samuel, R. Clint Whaley"
/*----------------------------------------------------------------------------*/
/* *** WARNING *** WARNING *** WARNING *** WARNING *** WARNING *** WARNING ****/
/* WARNING: THIS CODE IS ONLY LIGHTLY TESTED, AT BEST. I believe I made a     */
/* faithful translation of the LAPACK Fortran code. Tony Castaldo Jan 2012.   */
/*----------------------------------------------------------------------------*/
/*
 * This is the C translation of the standard LAPACK Fortran routine:
 *     SUBROUTINE DLARFGP( N, ALPHA, X, INCX, TAU )
 *
 * ATL_larfgp.c :
 * void ATL_larfgp( const int N, TYPE *ALPHA, TYPE *X, int INCX, TYPE *TAU)
 *
 *  Purpose
 *  =======
 *
 *  Real Precision
 *  --------------
 *
 *  ATL_larfgp generates a real/complex elementary reflector H of order n,
 *  such that:
 *
 *        H * ( alpha ) = ( beta ),   H' * H = I.
 *            (   x   )   (   0  )
 *
 *  where alpha and beta are scalars, beta is POSITIVE, 
 *  and x is an (n-1)-element real vector. H is represented in the form
 *
 *        H = I - tau * ( 1 ) * ( 1 v' ) ,                     (Real Precisions)
 *                      ( v )
 *
 *        H = I - tau * ( 1 ) * ( 1 conjugate(v)' ) ,       (Complex Precisions)
 *                      ( v )
 *
 *  where tau is a real/complex scalar and v is a real/complex (n-1)-element
 *  vector.
 *
 *  If the elements of x are all zero, then tau = 0 and H is taken to be
 *  the unit matrix.
 *
 *  Otherwise  1 <= tau <= 2.
 *
 *  The difference between this routine and larfg is that beta is guaranteed to
 *  be non-negative; this also ensures a unique H, and for a QR factorization,
 *  a unique Q for any given matrix A, along with additional mathematical 
 *  properties for R that do not necessarily exist with negative numbers on the
 *  diagonal. However, empirical analysis indicates these features come at the 
 *  price of some minor losses in precision.
 *
 *
 *  Arguments
 *  =========
 *
 *  N       (input) INTEGER
 *          The order of the elementary reflector.
 *
 *  ALPHA   (input/output)
 *          On entry, the value alpha.
 *          On exit, it is overwritten with the value beta.
 *
 *  X       (input/output)   array pointer, dimension
 *                         (1+(N-2)*abs(INCX))
 *          On entry, the vector x.
 *          On exit, it is overwritten with the vector v.
 *
 *  INCX    (input) INTEGER
 *          The increment between elements of X. INCX > 0.
 *
 *  TAU     (output)
 *          value of tau.
 */
#include "atlas_misc.h"
#include <math.h>
#include "cblas.h"
#include "atlas_lapack.h"
#include "atlas_lamch.h"

/*----------------------------------------------------------------------------*/
/* This is NOT a textbook Householder reflection, because [1 v]^T does not    */
/* have a norm of 1. The purpose seems to be to save the first storage        */
/* location; the '1' is not stored anywhere.                                  */
/*                                                                            */
/* Real and Complex do share some structure, but they are complicated enough  */
/* as it is, so for clarity we just have two codes separated by an IFDEF.     */
/*----------------------------------------------------------------------------*/

void ATL_larfgp(ATL_CINT N, TYPE *ALPHA, TYPE *X, ATL_CINT INCX, TYPE *TAU)
{
   #ifdef TREAL

   TYPE TWO=2.0, ONE=1.0, ZERO=0.0, ALPHR, BETA, BETAp, BIGNUM, SMLNUM, XNORM;
   TYPE TEMP, SAVEALPHA;
   int    j, KNT;

   if (N < 0)
   {
      *TAU = ZERO;
      return;
   }

   XNORM = cblas_nrm2(N-1, X, INCX);      /* Norm2 of X. */
   ALPHR = *ALPHA;                        /* Use ALPHR throughout... */

   if (XNORM == ZERO)
   {
      /* Set H = [+/-1, 0; I], sign is chosen so ALPHA >= 0. */
      if (ALPHR >= ZERO )
      {
         /* When TAU.eq.ZERO, the vector is special-cased to be     */
         /* all zeros in the application routines.  We do not need  */
         /* to clear it. Also, *ALPHA remains as is.                */
         *TAU = ZERO;
      }
      else
      {
         /* However, the application routines rely on explicit zero */
         /* checks when TAU.ne.ZERO, so we must clear X.            */
         *TAU = TWO;
         for (j=0; j<(N-1); j++)
         {
            X[j*INCX] = ZERO;
         }
         *ALPHA = -ALPHR;                 /* Must negate alpha in data. */
      }
   }
   else                                   /* XNORM NE ZERO. */
   {
      BETAp = ATL_lapy2(ALPHR, XNORM);    /* Full norm2=sqrt(a^2+b^2) */
      BETA = BETAp;                       /* Assume ALPHA < 0 */
      if (ALPHR < 0) BETA= -BETAp;        /* Change sign if alpha negative.*/
      SMLNUM = ATL_laSAFMIN;              /* Get smallest safe invertible. */
      KNT = 0;
      if (BETAp < SMLNUM)
      {
         /* XNORM, BETA may be inaccurate; scale X and recompute them. */
         BIGNUM = ONE / SMLNUM;           /* Get large number. */             

         while (BETAp < SMLNUM)
         {
            KNT++;
            cblas_scal(N-1, BIGNUM, X, INCX);
            BETA *= BIGNUM;
            BETAp *= BIGNUM;
            ALPHR *= BIGNUM;
         }
         /* New BETA is at most 1, at least SMLNUM. */

         XNORM = cblas_nrm2(N-1, X, INCX);
         BETAp = ATL_lapy2(ALPHR, XNORM);   /* Will always be positive */
         BETA = BETAp;                      /* Assume ALPHA < 0        */
         if (ALPHR > 0) BETA=-BETAp;        /* -SIGN(BETA, ALPHA)      */
      } /* BETAp < SAFMIN */

      SAVEALPHA = ALPHR;
      ALPHR = ALPHR + BETA;
      if (BETA < ZERO)
      {
         BETA = -BETA;
         *TAU = -(ALPHR/BETA);
      }
      else
      {
         ALPHR = XNORM * (XNORM/ALPHR);
         *TAU   = ALPHR/BETA;
         ALPHR = -ALPHR;
      }

      #if defined(SREAL)
      TEMP = fabsf(*TAU);
      #else 
      TEMP = fabs(*TAU);
      #endif 

      if (TEMP <= SMLNUM)
      {
         /* In the case where the computed TAU ends up being a denormalized  */
         /* number, it loses relative accuracy. This is a BIG problem.       */
         /* Solution: flush TAU to ZERO. This explains the next IF statement.*/
         /*                                                                  */
         /*(Bug report provided by Pat Quillen from MathWorks Jul 29, 2009.) */
         /*(Thanks Pat. Thanks MathWorks.)                                   */
         if (SAVEALPHA >= ZERO)
         {
            *TAU = ZERO;
         } else {
            *TAU = TWO;
            for (j=0; j<(N-1); j++)
            {
               X[j*INCX] = ZERO;
            }

            BETA = -SAVEALPHA;
         }
      } else {
         /* This is the general case. */
         cblas_scal(N-1, ONE / ALPHR, X, INCX);
      }

      for (j=0; j<KNT; j++)
      {
         BETA *= SMLNUM;
      }

      *ALPHA = BETA;

   } /* end XNORM !=0 */
   return; /* END of REAL Precision ATL_larfgp. */

#else /* COMPLEX CASE  of ATL_larfgp. */
   TYPE TWO=2.0, ONE=1.0, ZERO=0.0, BETA, BETAp, BIGNUM, SMLNUM, XNORM, 
        ALPHI, ALPHR, TEMP;
   TYPE ONEVAL[2] =  {ATL_rone, ATL_rzero};
   TYPE SAVEALPHA[2] =  {ATL_rzero, ATL_rzero};
   int j, KNT;

   if ( N < 0)
   {
/*
 *    H  =  I
 */
      *(TAU)  = 0.0;
      *(TAU + 1) = 0.0;
      return;
   }

   XNORM = cblas_nrm2(N-1, X, INCX);
   ALPHR = *(ALPHA);          /* Real component. */
   ALPHI = *(ALPHA+1);        /* Imag component. */

   if (XNORM == ZERO )
   {
      /* Set H=[1-alpha/abs(alpha) 0; 0 I], sign chosen so ALPHA >= 0. */
      if ( ALPHI == ZERO )
      {
         if(ALPHR > ZERO)
         {
/*          When TAU.eq.ZERO, the vector is special-cased to be
 *          all zeros in the application routines.  We do not need
 *          to clear it.
 */
            *(TAU)  = 0.0;
            *(TAU + 1) = 0.0;
         }
         else
         {
/*          However, the application routines rely on explicit
 *          zero checks when TAU.ne.ZERO, and we must clear X.
 */
            *(TAU)  = 2.0;
            *(TAU+1)= 0.0;
            
            for (j=0; j<(N-1); j++)                /* For all entries,        */
            {
               X[((j*INCX) SHIFT)]   = ZERO;       /* .. Clear real part.     */
               X[((j*INCX) SHIFT)+1] = ZERO;       /* .. Clear imaginary part.*/
            }
               
            *(ALPHA)  = -ALPHR;              /* Negate Alpha. */
            *(ALPHA+1)= -ALPHI;
         }
      }                                     /* ALPHI != ZERO                  */
      else
      {
/*       Only "reflecting" the diagonal entry to be real and non-negative.    */

         XNORM = ATL_lapy2(ALPHR,ALPHI);     /* Get abs value of Alpha. */
         *(TAU)   = ONE-(ALPHR/XNORM);
         *(TAU+1) = -(ALPHI/XNORM);

         for (j=0; j<(N-1); j++)                   /* For all entries,        */
         {                                         
            X[((j*INCX) SHIFT)]   = ZERO;          /* .. Clear real part.     */
            X[((j*INCX) SHIFT)+1] = ZERO;          /* .. Clear imaginary part.*/
         }                                         

         *(ALPHA)   = XNORM;              /* Real Part of alpha */
         *(ALPHA+1) = 0.0;                /* Set Imaginary part to Zero */
      }                                   /* ALPHI = 0 ends */
   }
   else  /* general case, XNORM != zero. */
   {
      BETAp = ATL_lapy3(ALPHR, ALPHI, XNORM);  /* Full norm 2. */
      BETA = BETAp;                 /* Assume ALPHR < 0 */
      if (ALPHR < 0)                /* If AlphR negative, */
         BETA = -BETAp;             /* Make beta match sign of ALPHR  */

      SMLNUM = ATL_laSAFMIN;        /* Get safe inversion number. */
      BIGNUM = ONE / SMLNUM;        
      KNT = 0;

      if (BETAp < SMLNUM)           /* If norm2 is too small, */
      {
         /* XNORM, BETA may be inaccurate; scale X and recompute them. */
         while (BETAp < SMLNUM)           
         {
            KNT++;
            #ifdef DCPLX
                cblas_zdscal(N-1, BIGNUM, X, INCX);
            #else
                cblas_csscal(N-1, BIGNUM, X, INCX);
            #endif
            BETA *= BIGNUM;
            BETAp *= BIGNUM;
            ALPHI = ALPHI*BIGNUM;
            ALPHR = ALPHR*BIGNUM;
         }

         /* New BETA is at most 1, at least SMLNUM */
         XNORM = cblas_nrm2(N-1, X, INCX);
         *(ALPHA)  = ALPHR;
         *(ALPHA+1)= ALPHI;

         BETAp = ATL_lapy3(ALPHR, ALPHI, XNORM); /* always positive. */
         BETA = BETAp;
         if (ALPHR < 0) BETA= -BETAp;  /* SIGN(BETA, ALPHR) */
      } /* END if BETAp < SMLNUM */

      SAVEALPHA[0] = *(ALPHA);
      SAVEALPHA[1] = *(ALPHA+1);
      *ALPHA = *ALPHA + BETA;

      if (BETA < ZERO)
      {
         BETA = -BETA;

         /* TAU = -ALPHA/BETA (Note TAU is complex but Beta is REAL) */
         *TAU     = -(*ALPHA)/BETA;
         *(TAU+1) = -(*(ALPHA+1))/BETA;
      }
      else
      {
         ALPHR = ALPHI * (ALPHI/ (*ALPHA));
         ALPHR = ALPHR + XNORM * (XNORM/(*ALPHA));
         *TAU     = ALPHR/BETA;
         *(TAU+1) = - (ALPHI/BETA);
         *ALPHA     = -ALPHR;
         *(ALPHA+1) = ALPHI;
      }

      /* Perform complex division before scaling the X vector */
      ATL_ladiv(ONEVAL, ALPHA, ALPHA);  /* ALPHA will have the result */

      TEMP = ATL_lapy2( TAU[0], TAU[1]); /* Get abs(TAU). */
      if (TEMP <= SMLNUM) 
      {
         /* In the case where the computed TAU ends up being a             */
         /* denormalized number, it loses relative accuracy. This is a     */
         /* BIG problem. Solution: flush TAU to ZERO (or TWO or whatever   */
         /* makes a nonnegative real number for BETA).                     */

         /* (Bug report provided by Pat Quillen from MathWorks on Jul      */
         /* 29, 2009.) (Thanks Pat. Thanks MathWorks.)                     */

         ALPHR = SAVEALPHA[0];
         ALPHI = SAVEALPHA[1];
         if (ALPHI == ZERO)
         {
            if (ALPHR >= ZERO)
            {
               *(TAU) = ZERO;
               *(TAU+1) = ZERO;
            } else {
               *(TAU) = TWO;
               *(TAU+1) = ZERO;
               for (j=0; j<(N-1); j++)
               {
                  X[((j*INCX) SHIFT)] = ZERO;
                  X[((j*INCX) SHIFT)+1] = ZERO;
               }
               
               BETA = -ALPHR;             /* Note ALPHI == zero, here. */
            }
         } else {
            XNORM = ATL_lapy2(ALPHR, ALPHI);
            *(TAU) = ONE - (ALPHR/XNORM);
            *(TAU+1) = -(ALPHI/XNORM);
            for (j=0; j<(N-1); j++)
            {
               X[((j*INCX) SHIFT)] = ZERO;
               X[((j*INCX) SHIFT)+1] = ZERO;
            }

            BETA = XNORM;
         }
      } else /* TAU large enough, handle general case */
      {
         cblas_scal(N-1, ALPHA, X, INCX);
      }

      /* If BETA is subnormal, it may lose relative accuracy. */
      for (j=0; j<KNT; j++)
      {
         BETA *= SMLNUM;       
      }

     *(ALPHA)   = BETA;          /* Note BETA is just REAL, not complex. */
     *(ALPHA+1) = ZERO;          /* ...                                  */
   }  /* XNORM != 0 ends  */
   return;
#endif /* COMPLEX CASE */
} /* END ATL_larfgp */
@ROUT ATL_larft
@extract -b @(topd)/cw.inc lang=C -def cwdate 2009 -def cwauth "Siju Samuel" -def contrib "Anthony M. Castaldo, R. Clint Whaley"

/*
 * This is a recursive C implementation of the standard LAPACK Fortran routine:
 *      SUBROUTINE DLARFT( DIRECT, STOREV, N, K, V, LDV, TAU, T, LDT )
 *
 * ATL_larft.c :
 * void ATL_larft(const enum ATL_LADIRECT DIRECT,
 *                const enum ATL_LASTOREV STOREV, int N, int K, TYPE *V,
 *                int LDV, TYPE  *TAU, TYPE *T, int LDT )
 *
 *     NOTE :   ATL_larft.c will get compiled to four precisions
 *               single precision real,      double precision real
 *               single precision complex,   double precision complex
 *
 *  Purpose
 *  =======
 *
 *  ATL_larft forms the triangular factor T of a real/complex block reflector H
 *  of order n, which is defined as a product of k elementary reflectors.
 *  We only handle DIRECT='F' (forward) and STOREV='C' (columnwise).
 *
 *  N       (input) INTEGER
 *          The order of the block reflector H. N >= 0.
 *
 *  K       (input) INTEGER
 *          The order of the triangular factor T (= the number of
 *          elementary reflectors). K >= 1.
 *
 *  V       (input/output) DOUBLE PRECISION array, dimension (LDV, K)
 *
 *  LDV     (input) INTEGER
 *          The leading dimension of the array V.
 *          LDV >= max(1,N).
 *
 *  TAU     (input)  array, dimension (K)
 *          TAU(i) must contain the scalar factor of the elementary
 *          reflector H(i).
 *
 *  T       (output) array, dimension (LDT,K)
 *          The k by k upper triangular factor T of the block reflector.
 *
 *  LDT     (input) INTEGER
 *          The leading dimension of the array T. LDT >= K.
 *
 *  Further Details
 *  ===============
 *
 *  The shape of the matrix V and the storage of the vectors which define
 *  the H(i) is best illustrated by the following example with n = 5 and
 *  k = 3. The elements equal to 1 are not stored.
 *
 *  DIRECT = 'F' and STOREV = 'C':
 *
 *               V = (  1       )
 *                   ( v1  1    )
 *                   ( v1 v2  1 )
 *                   ( v1 v2 v3 )
 *                   ( v1 v2 v3 )
 *
 *  =====================================================================
 *  We are using the recursive formulation outlined in the paper
 *  "Applying recursion to serial and parallel QR factorization leads to
 *   better performance", by E. Elmroth and F.G. Gustavson, 2000 (IBM).
 *
 *  The YT(Y^T) formulation is by Schreiber and Van Loan, 1989; but is
 *  modified in two ways. LAPACK uses Q=(I-YT(Y^T)) instead of Q=(I+YT(Y^T)),
 *  and also does not use unit vectors: As you can see above, our V vectors
 *  begin with '1' and thus cannot have unit norm, and working out the
 *  necessary T and TAU produces TAU[i] on the diagonal of T. If we stop our
 *  recursion at 1, TAU[0] is the result. If we stop at 2, we have a 2x2
 *  upper triangular matrix; with TAU[0] and TAU[1] on the diagonal, and
 *  -TAU[0]*TAU[1]* dotproduct(V[0], V[1]) in the upper right hand corner.
 *
 *  The Elmroth+Gustavson algorithm permits updates with different sizes,
 *  we make our split to try and keep the update area a multiple of 4 when
 *  possible, we presume this will aid SSE usage in multiplication.
 *
 */
#include "atlas_misc.h"
#include "cblas.h"
#include "atlas_lapack.h"

#define ATL_larftFC           Mjoin(PATL,larftFC)
#define ATL_larftBC           Mjoin(PATL,larftBC)
#define ATL_larftFR           Mjoin(PATL,larftFR)
#define ATL_larftBR           Mjoin(PATL,larftBR)
#define ATL_larft_blockFC     Mjoin(PATL,larft_blockFC)
#define ATL_larft_blockBC     Mjoin(PATL,larft_blockBC)
#define ATL_larft_blockFR     Mjoin(PATL,larft_blockFR)
#define ATL_larft_blockBR     Mjoin(PATL,larft_blockBR)

@whiledef tt FC BC FR BR
void ATL_larft@(tt)(const enum ATL_LADIRECT DIRECT, const enum ATL_LASTOREV STOREV,
                 ATL_CINT N, ATL_CINT K, TYPE *V, ATL_CINT LDV,
                 const TYPE *TAU, TYPE *T, ATL_CINT LDT);
@endwhile

void ATL_larft_blockFC(int N, int K, int left, int right,
                      TYPE *V, int LDV, TYPE *T, int LDT );
void ATL_larft_blockBC(int N, int K, int left, int right,
                      TYPE *V, int LDV, TYPE *T, int LDT );
void ATL_larft_blockFR(int N, int K, int left, int right,
                      TYPE *V, int LDV, TYPE *T, int LDT );
void ATL_larft_blockBR(int N, int K, int left, int right,
                      TYPE *V, int LDV, TYPE *T, int LDT );

/* Use CBLAS routines.                                                        */

   #ifdef TREAL
      #define MY_DOT  cblas_dot
   #else
      #define MY_DOT  cblas_dotc_sub
      #define MY_DOTU cblas_dotu_sub
   #endif

   #define MY_LEFT  CblasLeft
   #define MY_RIGHT CblasRight
   #define MY_LOWER CblasLower
   #define MY_UPPER CblasUpper
   #ifdef TREAL
      #define MY_TRANS CblasTrans
   #else
      #define MY_TRANS CblasConjTrans
   #endif

   #define MY_NOTRANS CblasNoTrans
   #define MY_UNIT    CblasUnit
   #define MY_NONUNIT CblasNonUnit

void ATL_larft_block
   (const enum ATL_LADIRECT DIRECT, const enum ATL_LASTOREV STOREV, 
    ATL_CINT N, ATL_CINT K, ATL_CINT left, ATL_CINT right,
    TYPE *V, ATL_CINT LDV, TYPE *T, ATL_CINT LDT)
{
   if ( DIRECT == LAForward)
   {
      if ( STOREV == LAColumnStore )
      {
         ATL_larft_blockFC(N, K, left, right, V, LDV, T,  LDT );
      }
      else if (STOREV == LARowStore)
      {
         ATL_larft_blockFR(N, K, left, right, V, LDV, T,  LDT );
      }

   }
   else if (DIRECT == LABackward)
   {
      if ( STOREV == LAColumnStore)
      {
         ATL_larft_blockBC(N, K, left, right, V, LDV, T, LDT );
      }
      else if (STOREV == LARowStore)
      {
         ATL_larft_blockBR(N, K, left, right, V, LDV, T, LDT );
      }
   }
}

/*
 * This function produce the block portion of the T matrix in recursive
 * algorithm.
 */

void ATL_larft_blockFC(ATL_CINT N, ATL_CINT K, ATL_CINT left, ATL_CINT right,
                       TYPE *V, int LDV, TYPE *T, ATL_CINT LDT)
{
   TYPE *Tw, *Y2, *T2;
   int    row, col;
   int LDV2, LDT2;
   LDV2 = LDV SHIFT;                        /* For complex LDV * 2            */
   LDT2 = LDT SHIFT;                        /* For complex LDT * 2            */

    #ifdef TREAL
      const TYPE ONE = ATL_rone;
      const TYPE ZEROVAL = ATL_rzero;
      const TYPE NONE = ATL_rnone;
    #else
      const TYPE ONE[2] = {ATL_rone, ATL_rzero};
      const TYPE ZEROVAL[2] = {ATL_rzero, ATL_rzero};
      const TYPE NONE[2] = {ATL_rnone, ATL_rzero};
    #endif

   Tw = T+left*LDT2;                        /* Work at T[0, left].            */
   Y2 = V+(left SHIFT)+LDV2*left;           /* Y2 at V[left, left].           */
   T2 = T+(left SHIFT) +LDT2*left;          /* Address of new T2.             */

/*----------------------------------------------------------------------------*/
/* Fill in the upper right hand block, which is                               */
/* 'left' rows and 'right' columns.                                           */
/*                                                                            */
/* -T1 * (Y1^T * Y2) * T2                                                     */
/* Block upper right hand element is T+(LDT*left).                            */
/*----------------------------------------------------------------------------*/
/* Step 1: Y1^T * Y2, Y2 upper unit triangular.                               */
/* We do this in two steps to use DTRMM.                                      */
/* We transpose by hand the first 'left' columns                              */
/* of Y1 into the workspace; then use DTRMM to                                */
/* multiply that on the right by the triangular                               */
/* part of Y2. Then we use DGEMM to compute                                   */
/* Workspace += Y1rest^T * Y2rest.                                            */
/*                                                                            */
/* Note Y1rest[0,0] is at V+K, and                                            */
/* Y2rest[0,0] is at Y2+right.                                                */
/*                                                                            */
/*----------------------------------------------------------------------------*/
   for (row=0; row<left; row++)             /* Each row of Tw                 */
   {
      for (col=0; col<right; col++)         /* Each column of Tw              */
      {
         #ifdef TREAL
            *(Tw + row + col*LDT) =         /* Work[row, col]                 */
            *((V+left)+col+row*LDV);        /* Y1[col, row].                  */
         #else
/*          Copy the  ConjTranspose for complex                               */
            *(Tw + (row SHIFT) + col*LDT2) =/* Work[row, col]                 */
            *((V+ (left SHIFT))+(col SHIFT)
                              +row*LDV2);   /* Y1[col, row].                  */
/*          copy the imaginary part.                                          */
            *(Tw + (row SHIFT) + 1 + col*LDT2) = /* Work[row, col]            */
            0.0 - ( *((V+ (left SHIFT))+(col SHIFT) +1 +
                              row*LDV2) );  /* Y1[col, row].                  */
         #endif
      }
   }

/*----------------------------------------------------------------------------*/
/* Copy complete, Tw is 'left' rows, 'right' cols.                            */
/* Tw = 1.0 * Tw * Y2.                                                        */
/* DTRMM: (right): B := alpha * B * triangular A.                             */
/*----------------------------------------------------------------------------*/
   cblas_trmm(CblasColMajor,                /* Y2 is on right, lwr tri.       */
             MY_RIGHT, MY_LOWER,            /* Y2 is on right, lwr tri.       */
             MY_NOTRANS, MY_UNIT,           /* As-is, with unit diag.         */
             left, right, ONE,              /* B rows, cols, alpha=1.         */
             Y2, LDV, Tw, LDT);             /* A and B.                       */
/*----------------------------------------------------------------------------*/
/* Dgemm can finish the multiply, if any is left.                             */
/* Tw += (Y1^T) * Y2, if N-K is > 0.                                          */
/* DGEMM: C = alpha * A * B + Beta * C.                                       */
/*----------------------------------------------------------------------------*/
   if (N > K)                               /* If any left below...           */
   {
     cblas_gemm(CblasColMajor,
                MY_TRANS,                   /* Y1 is transposed.              */
                MY_NOTRANS,                 /* Y2 is not.                     */
                left, right,                /* Dimensions of C.               */
                N-K,                        /* Height of columns.             */
                ONE,                        /* No special multiplier.         */
                (V+(K SHIFT)), LDV,         /* Y1[0,0], dist to Y1[0,1]       */
                (Y2+(right SHIFT) ), LDV,   /* Y2[0,0], dist to Y2[0,1]       */
                ONE,                        /* Add to existing data.          */
                Tw, LDT);                   /* Wk[0,0], dist to Wk[0,1]       */
   }

/*----------------------------------------------------------------------------*/
/* Y1^T * Y2 complete; now two triangular mults.                              */
/* Tw = -1.0 * T1 * Tw.                                                       */
/* DTRMM: (left): B:= alpha * triangular A * B                                */
/*----------------------------------------------------------------------------*/
   cblas_trmm(CblasColMajor,
            MY_LEFT, MY_UPPER,              /* T1 on left, upr tri.           */
            MY_NOTRANS, MY_NONUNIT,         /* As-is, non-unit diag.          */
             left, right, NONE,             /* B rows, cols, alpha=-1.        */
             T, LDT, Tw, LDT);              /* A and B.                       */

/*----------------------------------------------------------------------------*/
/* -T1 * (Y1^T * Y2) complete. Final tri T2 Mult.                             */
/* Tw = 1.0 * Tw * T2.                                                        */
/* DTRMM: (right): B:= alpha * B * triangular A                               */
/*----------------------------------------------------------------------------*/
   cblas_trmm(CblasColMajor,
           MY_RIGHT, MY_UPPER,              /* T2 on right, upr tri.          */
            MY_NOTRANS, MY_NONUNIT,         /* As-is, non-unit diag.          */
             left, right, ONE,              /* B rows, cols, alpha=1.         */
             T2, LDT, Tw, LDT);             /* A and B.                       */

   return;                                  /* All done.                      */
}                                           /* END ATL_dlarft_block           */

/*
 * This function produce the block portion of the T matrix in recursive
 * algorithm.
 */
void ATL_larft_blockFR(ATL_CINT N, ATL_CINT K, ATL_CINT top, ATL_CINT bottom,
                       TYPE *V, ATL_CINT LDV, TYPE *T, ATL_CINT LDT)
{
   TYPE *Tw, *Y2, *T2;
   int    row, col;
   int LDV2, LDT2;
   LDV2 = LDV SHIFT;                        /* For complex LDV * 2            */
   LDT2 = LDT SHIFT;                        /* For complex LDT * 2            */

   #ifdef TREAL
      const TYPE ONE = ATL_rone;
      const TYPE ZEROVAL = ATL_rzero;
      const TYPE NONE = ATL_rnone;
   #else
      const TYPE ONE[2] = {ATL_rone, ATL_rzero};
      const TYPE ZEROVAL[2] = {ATL_rzero, ATL_rzero};
      const TYPE NONE[2] = {ATL_rnone, ATL_rzero};
   #endif
   Tw = T+top*LDT2;                         /* Work at T[0, top].             */
   Y2 = V+(top SHIFT)+LDV2*top;             /* Y2 at V[top, top].             */
   T2 = T+(top SHIFT) +LDT2*top;            /* Address of new T2.             */

/*----------------------------------------------------------------------------*/
/* Fill in the upper left hand block, which is                                */
/* 'top' rows and 'bottom' columns.                                           */
/*                                                                            */
/* -T1 * (Y1 * Y2^T) * T2                                                     */
/* Block upper left hand element is T+(LDT*top).                              */
/*----------------------------------------------------------------------------*/
/* Step 1: Y1 * Y2^T, Y2 upper unit triangular.                               */
/* We do this in two steps to use DTRMM.                                      */
/* We copy by hand the 'top' columns                                          */
/* of Y1 into the workspace; then use DTRMM to                                */
/* multiply that on the bottom by the triangular                              */
/* part of Y2. Then we use DGEMM to compute                                   */
/* Workspace += Y1rest* Y2^Trest.                                             */
/*                                                                            */
/* Note Y1rest[0,0] is at V+K, and                                            */
/* Y2rest[0,0] is at Y2+bottom.                                               */
/*----------------------------------------------------------------------------*/
   for (row=0; row<top; row++)              /* Each row of Tw                 */
   {
      for (col=0; col<bottom; col++)        /* Each column of Tw              */
      {
         #ifdef TREAL
            *(Tw + row + col*LDT) =         /* Work[row, col]                 */
            *((V+top*LDV)+row+col*LDV);     /* Y1[col, row].                  */
         #else

            *(Tw +( row SHIFT) + col*LDT2) =/* Work[row, col]                 */
            *((V+top*LDV2)+(row SHIFT)+col*LDV2);/* Y1[col, row].             */

/*          copy the imaginary part.                                          */
            *(Tw +( row SHIFT)+1 + col*LDT2) =   /* Work[row, col]            */
            *((V+top*LDV2)+(row SHIFT)+ 1+col*LDV2);  /* Y1[col, row].        */
         #endif
      }
   }
/*----------------------------------------------------------------------------*/
/* Copy complete, Tw is 'top' rows, 'bottom' cols.                            */
/* Tw = 1.0 * Tw * Y2^T.                                                      */
/* DTRMM: (right): B := alpha * B * triangular A^T.                           */
/*----------------------------------------------------------------------------*/
   cblas_trmm(CblasColMajor,                /* Y2 is on right, upr tri.       */
            MY_RIGHT, MY_UPPER,             /* Y2 is on right, upr tri.       */
            MY_TRANS, MY_UNIT,              /* As-is, with unit diag.         */
            top, bottom, ONE,               /* B rows, cols, alpha=1.         */
            Y2, LDV, Tw, LDT);              /* A and B.                       */
/*----------------------------------------------------------------------------*/
/* Dgemm can finish the multiply, if any is left.                             */
/* Tw += Y1 * (Y2^T), if N-K is > 0.                                          */
/* DGEMM: C = alpha * A * B + Beta * C.                                       */
/*----------------------------------------------------------------------------*/
   if (N > K)                               /* If any top below...            */
   {
     cblas_gemm(CblasColMajor,
               MY_NOTRANS,                  /* Y1 is not transposed.          */
               MY_TRANS,                    /* Y2 is                          */
               top, bottom,                 /* Dimensions of C.               */
               N-K,                         /* Height of columns.             */
               ONE,                         /* No special multiplier.         */
               (V+(K*LDV2)), LDV,           /* Y1[0,0], dist to Y1[0,1]       */
               (Y2+(bottom*LDV2)), LDV,     /* Y2[0,0], dist to Y2[0,1]       */
               ONE,                         /* Add to existing data.          */
               Tw, LDT);                    /* Wk[0,0], dist to Wk[0,1]       */
   }

/*----------------------------------------------------------------------------*/
/* Y1 * Y2^T complete; now two triangular mults.                              */
/* Tw = -1.0 * T1 * Tw.                                                       */
/* DTRMM: (left): B:= alpha * triangular A * B                                */
/*----------------------------------------------------------------------------*/
   cblas_trmm(CblasColMajor,
            MY_LEFT, MY_UPPER,              /* T1 on top, upr tri.            */
            MY_NOTRANS, MY_NONUNIT,         /* As-is, non-unit diag.          */
            top, bottom, NONE,              /* B rows, cols, alpha=-1.        */
            T, LDT, Tw, LDT);               /* A and B.                       */

/*----------------------------------------------------------------------------*/
/* -T1 * (Y * Y2^T) complete. Final tri T2 Mult.                              */
/* Tw = 1.0 * Tw * T2.                                                        */
/* DTRMM: (right): B:= alpha * B * triangular A                               */
/*----------------------------------------------------------------------------*/
   cblas_trmm(CblasColMajor,
           MY_RIGHT, MY_UPPER,              /* T2 on bottom, upr tri.         */
            MY_NOTRANS, MY_NONUNIT,         /* As-is, non-unit diag.          */
             top, bottom, ONE,              /* B rows, cols, alpha=1.         */
             T2, LDT, Tw, LDT);             /* A and B.                       */
   return;                                  /* All done.                      */
}                                           /* END ATL_dlarft_block           */

/*
 * This function produce the block portion of the T matrix in recursive
 * algorithm.
 */
void ATL_larft_blockBC(ATL_CINT N, ATL_CINT K, ATL_CINT left, ATL_CINT right,
                       TYPE *V, ATL_CINT LDV, TYPE *T, ATL_CINT LDT)
{
   TYPE *Tw, *Y2, *T2;
   int    row, col;
   int LDV2, LDT2;
   LDV2 = LDV SHIFT;                        /* For complex LDV * 2            */
   LDT2 = LDT SHIFT;                        /* For complex LDT * 2            */

   #ifdef TREAL
      const TYPE ONE = ATL_rone;
      const TYPE ZEROVAL = ATL_rzero;
      const TYPE NONE = ATL_rnone;
   #else
      const TYPE ONE[2] = {ATL_rone, ATL_rzero};
      const TYPE ZEROVAL[2] = {ATL_rzero, ATL_rzero};
      const TYPE NONE[2] = {ATL_rnone, ATL_rzero};
   #endif

   Tw = T+(left SHIFT);                     /* Work at T[0 + left].           */
   Y2 = V+LDV2*left;                        /* Y2 at V[0,left].               */
   T2 = T+(left SHIFT) +LDT2*left;          /* Address of new T2.             */

/*----------------------------------------------------------------------------*/
/* Fill in the lower  left hand block, which is                               */
/* 'right' rows and 'left' columns.                                           */
/*                                                                            */
/* -T2 * (Y2^T * Y1) * T1                                                     */
/* Block upper right hand element is T+(LDT*left).                            */
/*----------------------------------------------------------------------------*/
/* TODO : check all thsis comments                                            */
/* Step 1: Y2^T * Y1, Y1 lower unit triangular.                               */
/* We do this in two steps to use DTRMM.                                      */
/* We transpose by hand the 'last' 'right' columns                            */
/* of Y2 into the workspace; then use DTRMM to                                */
/* multiply that on the right by the triangular                               */
/* part of Y1. Then we use DGEMM to compute                                   */
/* Workspace += Y2rest^T * Y1rest.                                            */
/*                                                                            */
/* Note Y1rest[0,0] is at V, and                                              */
/* Y2rest[0,0] is at Y2.                                                      */
/*                                                                            */
/*----------------------------------------------------------------------------*/
   for (row=0; row<right; row++)            /* Each row of Tw                 */
   {
      for (col=0; col<left; col++)          /* Each column of Tw              */
      {
         #ifdef TREAL
/*          Copy the  Transpose                                               */
            *(Tw + row + col*LDT) =         /* Work[row, col]                 */
            *((Y2+N-K) +row*LDV2 + col);    /* Y[col, row].                   */
         #else
/*          Copy the  ConjTranspose for complex                               */
            *(Tw + (row SHIFT) + col*LDT2) =/* Work[row, col]                 */
            *(Y2+ ((N-K) SHIFT) +row*LDV2 + (col SHIFT) ); /* Y[col, row].    */

/*          copy the imaginary part.                                          */
            *(Tw + (row SHIFT) + 1 + col*LDT2) = /* Work[row, col]            */
            0.0 - *(Y2+((N-K) SHIFT)+row*LDV2 + (col SHIFT)+1); /* Y[col,row].*/
         #endif
      }
   }

/*----------------------------------------------------------------------------*/
/* Copy complete, Tw is 'right' rows, 'left' cols.                            */
/* Tw = 1.0 * Tw * Y1.                                                        */
/* DTRMM: (right): B := alpha * B * triangular A.                             */
/*----------------------------------------------------------------------------*/
   cblas_trmm(CblasColMajor,                /* Y1 is on right, upr tri.       */
             MY_RIGHT, MY_UPPER,            /* Y1 is on right, upr tri.       */
             MY_NOTRANS, MY_UNIT,           /* As-is, with unit diag.         */
             right, left, ONE,              /* B rows, cols, alpha=1.         */
             (V + ((N -K) SHIFT)), LDV, Tw, LDT);/* A and B.                  */
/*----------------------------------------------------------------------------*/
/* Dgemm can finish the multiply, if any is left.                             */
/* Tw += (Y2^T) * Y1, if N-K is > 0.                                          */
/* DGEMM: C = alpha * A * B + Beta * C.                                       */
/*----------------------------------------------------------------------------*/
   if (N > K)                               /* If any left below...           */
   {
     cblas_gemm(CblasColMajor,
                MY_TRANS,                   /* Y2 is transposed.              */
                MY_NOTRANS,                 /* Y1 is not.                     */
                right, left,                /* Dimensions of C.               */
                N-K,                        /* Height of columns.             */
                ONE,                        /* No special multiplier.         */
                (Y2), LDV,                  /* Y2[0,0], dist to Y2[0,1]       */
                (V ), LDV,                  /* Y1[0,0], dist to Y1[0,1]       */
                ONE,                        /* Add to existing data.          */
                Tw, LDT);                   /* Wk[0,0], dist to Wk[0,1]       */
   }

/*----------------------------------------------------------------------------*/
/* Y2^T * Y1 complete; now two triangular mults.                              */
/* Tw = -1.0 * T2 * Tw.                                                       */
/* DTRMM: (left): B:= alpha * triangular A * B                                */
/*----------------------------------------------------------------------------*/
   cblas_trmm(CblasColMajor,
            MY_LEFT, MY_LOWER,              /* T2 on left, lwr tri.           */
            MY_NOTRANS, MY_NONUNIT,         /* As-is, non-unit diag.          */
            right, left, NONE,              /* B rows, cols, alpha=-1.        */
            T2, LDT, Tw, LDT);              /* A and B.                       */

/*----------------------------------------------------------------------------*/
/* -T2 * (Y2^T * Y1) complete. Final tri T1 Mult.                             */
/* Tw = 1.0 * Tw * T1.                                                        */
/* DTRMM: (right): B:= alpha * B * triangular A                               */
/*----------------------------------------------------------------------------*/
   cblas_trmm(CblasColMajor,
           MY_RIGHT, MY_LOWER,              /* T1 on right, lower tri.        */
           MY_NOTRANS, MY_NONUNIT,          /* As-is, non-unit diag.          */
           right, left, ONE,                /* B rows, cols, alpha=1.         */
           T, LDT, Tw, LDT);                /* A and B.                       */


   return;                                  /* All done.                      */
}                                           /* END ATL_dlarft_block_BC        */

void ATL_larft_blockBR(ATL_CINT N, ATL_CINT K, ATL_CINT top, ATL_CINT bottom,
                       TYPE *V, ATL_CINT LDV, TYPE *T, ATL_CINT LDT)
{
   TYPE *Tw, *Y2, *T2;
   int    row, col;
   int LDV2, LDT2;
   LDV2 = LDV SHIFT;                        /* For complex LDV * 2            */
   LDT2 = LDT SHIFT;                        /* For complex LDT * 2            */

   #ifdef TREAL
      const TYPE ONE = ATL_rone;
      const TYPE ZEROVAL = ATL_rzero;
      const TYPE NONE = ATL_rnone;
   #else
      const TYPE ONE[2] = {ATL_rone, ATL_rzero};
      const TYPE ZEROVAL[2] = {ATL_rzero, ATL_rzero};
      const TYPE NONE[2] = {ATL_rnone, ATL_rzero};
   #endif

   Tw = T+(top SHIFT);                      /* Work at T[top,0].              */
   Y2 = V+(top SHIFT);                      /* Y2 at V[top, 0].               */
   T2 = T+(top SHIFT) +LDT2*top;            /* Address of new T2.             */

/*----------------------------------------------------------------------------*/
/* Fill in the lower  left hand block, which is                               */
/* 'bottom' rows and 'top' columns.                                           */
/*                                                                            */
/* -T2 * (Y2 * Y1^T) * T1                                                     */
/* Block  lower left hand elements                                            */
/*----------------------------------------------------------------------------*/
/* Step 1: Y2 * Y1^T, Y1 lower unit triangular.                               */
/* We do this in two steps to use DTRMM.                                      */
/* We copy by hand the 'last-bottom' 'top' columns                            */
/* of Y2 into the workspace; then use DTRMM to                                */
/* multiply that on the bottom by the triangular                              */
/* part of Y1. Then we use DGEMM to compute                                   */
/* Workspace += Y2rest * Y1rest^T.                                            */
/*                                                                            */
/* Note Y1rest[0,0] is at V, and                                              */
/* Y2rest[0,0] is at Y2.                                                      */
/*                                                                            */
/*----------------------------------------------------------------------------*/
   for (row=0; row<bottom; row++)           /* Each row of Tw                 */
   {
      for (col=0; col<top; col++)           /* Each column of Tw              */
      {
         #ifdef TREAL
            *(Tw + row + col*LDT) =         /* Work[row, col]                 */
            *((Y2+ (N-K)*LDV) +row + (col*LDV)); /* Y[col, row].              */
         #else
            *(Tw + (row SHIFT) + col*LDT2) =/* Work[row, col]                 */
            *((Y2+ (N-K)*LDV2) +(row SHIFT) + (col*LDV2)); /* Y[col, row].    */


/*          copy the imaginary part.                                          */
            *(Tw + (row SHIFT) +1  + col*LDT2) = /* Work[row, col]            */
            *((Y2+ (N-K)*LDV2) +(row SHIFT) +1 + (col*LDV2)); /* Y[col, row]. */

         #endif
      }
   }

/*----------------------------------------------------------------------------*/
/* Copy complete, Tw is 'bottom' rows, 'top' cols.                            */
/* Tw = 1.0 * Tw * Y1^T.                                                      */
/* DTRMM: (bottom): B := alpha*B * (op)triangular A.                          */
/*----------------------------------------------------------------------------*/
   cblas_trmm(CblasColMajor,                /* Y1 is on bottom, lower tri.    */
             MY_RIGHT, MY_LOWER,            /* Y1 is on bottom, lower tri.    */
             MY_TRANS, MY_UNIT,             /* As-is, with unit diag.         */
             bottom, top, ONE,              /* B rows, cols, alpha=1.         */
             (V + ((N -K)*LDV2)), LDV, Tw, LDT); /* A and B.                  */
/*----------------------------------------------------------------------------*/
/* Dgemm can finish the multiply, if any is top.                              */
/* Tw += Y2 * (Y1^T), if N-K is > 0.                                          */
/* DGEMM: C = alpha * A * B + Beta * C.                                       */
/*----------------------------------------------------------------------------*/
   if (N > K)                               /* If any top below...            */
   {
     cblas_gemm(CblasColMajor,
                MY_NOTRANS,                 /* Y2 is not transposed.          */
                MY_TRANS,                   /* Y1 is transposed.              */
                bottom, top,                /* Dimensions of C.               */
                N-K,                        /* Height of columns.             */
                ONE,                        /* No special multiplier.         */
                (Y2), LDV,                  /* Y2[0,0], dist to Y2[0,1]       */
                (V ), LDV,                  /* Y1[0,0], dist to Y1[0,1]       */
                ONE,                        /* Add to existing data.          */
                Tw, LDT);                   /* Wk[0,0], dist to Wk[0,1]       */
   }

/*----------------------------------------------------------------------------*/
/* Y2 * Y1^T complete; now two triangular mults.                              */
/* Tw = -1.0 * T2 * Tw.                                                       */
/* DTRMM: (top): B:= alpha * triangular A * B                                 */
/*----------------------------------------------------------------------------*/
   cblas_trmm(CblasColMajor,
            MY_LEFT, MY_LOWER,              /* T2 on left, lwr tri.           */
            MY_NOTRANS, MY_NONUNIT,         /* As-is, non-unit diag.          */
            bottom, top, NONE,              /* B rows, cols, alpha=-1.        */
            T2, LDT, Tw, LDT);              /* A and B.                       */

/*----------------------------------------------------------------------------*/
/* -T2 * (Y2 * Y1^T) complete. Final tri T1 Mult.                             */
/* Tw = 1.0 * Tw * T1.                                                        */
/* DTRMM: (right): B:= alpha * B * triangular A                               */
/*----------------------------------------------------------------------------*/
   cblas_trmm(CblasColMajor,
           MY_RIGHT, MY_LOWER,              /* T1 on bottom, lower tri.       */
           MY_NOTRANS, MY_NONUNIT,          /* As-is, non-unit diag.          */
           bottom, top, ONE,                /* B rows, cols, alpha=1.         */
           T, LDT, Tw, LDT);                /* A and B.                       */

   return;                                  /* All done.                      */
}                                           /* END ATL_dlarft_block_BR        */

void ATL_larft(const enum ATL_LADIRECT DIRECT, const enum ATL_LASTOREV STOREV, 
               ATL_CINT N, ATL_CINT K, TYPE *V, ATL_CINT LDV,
               const TYPE *TAU, TYPE *T, ATL_CINT LDT)
{

   if ( DIRECT == LAForward)
   {
      if ( STOREV == LAColumnStore)
      {
         ATL_larftFC(DIRECT, STOREV, N, K, V, LDV, TAU, T, LDT );
      }
      else if (STOREV == LARowStore)
      {
         ATL_larftFR(DIRECT, STOREV, N, K, V, LDV, TAU, T, LDT );
      }

   }
   else if (DIRECT == LABackward)
   {
      if ( STOREV == LAColumnStore)
      {
         ATL_larftBC(DIRECT, STOREV, N, K, V, LDV, TAU, T, LDT );
      }
      else if (STOREV == LARowStore)
      {
         ATL_larftBR(DIRECT, STOREV, N, K, V, LDV, TAU, T, LDT );
      }
   }
}                                           /* END ATL_dlarft                 */

void ATL_larftFC(const enum ATL_LADIRECT DIRECT, const enum ATL_LASTOREV STOREV,
                 ATL_CINT N, ATL_CINT K, TYPE *V, ATL_CINT LDV,
                 const TYPE *TAU, TYPE *T, ATL_CINT LDT)
{
   TYPE   *Y2, *T2;
   TYPE   dt;
   int    row, col;
   int LDV2, LDT2;
   LDV2 = LDV SHIFT;                        /* for complex LDV *2             */
   LDT2 = LDT SHIFT;                        /* for comlex LDT *2              */
   int right, left;

   #ifdef TREAL
      const TYPE ONE = ATL_rone;
      const TYPE ZEROVAL = ATL_rzero;
      TYPE VII;
      TYPE  d01, d02, d12;
   #else
      const TYPE ONE[2] = {ATL_rone, ATL_rzero};
      const TYPE ZEROVAL[2] = {ATL_rzero, ATL_rzero};
      TYPE VII[2];
      TYPE  d01[2], d02[2], d12[2];
   #endif

   if (K == 0) return;                      /* Nothing to do.                 */
   if (N == 0) return;                      /* Nothing to do.                 */
   if (DIRECT != LAForward || STOREV != LAColumnStore) /* If not my specialty */
   {
      fprintf(stderr, "ATL_dlarft called with DIRECT=%d, STOREV=%d.\n"
                     "Aborting.\n", DIRECT, STOREV);
      exit(1);
   }

   if (K == 1)                              /* Down to a scalar               */
   {
      #ifdef TREAL
         *T = *TAU;                         /* Y. Just copy it.               */
      #else
         *T = *TAU;                         /* Y. Just copy it.               */
         *(T+1) = *(TAU+1);                 /* Y. Just copy it.               */
      #endif
      return;                               /* ...All done!                   */
   }

/*----------------------------------------------------------------------------*/
/* K=2: We only need T[0,1], computed as: (zero-relative):                    */
/*                                                                            */
/* T[0, 1] = -tau[0] * d01 * tau[1].                                          */
/*----------------------------------------------------------------------------*/
   if (K == 2)
   {
      #ifdef TREAL
         *T = *TAU;                         /* Copy the diagonal...           */
         *(T+LDT+1) = *(TAU+1);             /* ...                            */
         d01 = MY_DOT( N-2, V+2, 1, V+2+LDV, 1); /* Main dot product.         */
         d01 += *(V+1);                     /* Part mult by assumed 1.0       */
         *(T+LDT) = -(*TAU) * (*(TAU+1)) * d01;  /* Fill in T[0,1].           */
      #else
         *T = *TAU;                         /* Copy the diagonal -real        */
         *(T+1) = *(TAU+1);                 /* Copy the diagonal. -real       */
         *(T+LDT2+(1 SHIFT) ) = *(TAU+(1 SHIFT));/* ... -imag                 */
         *(T+LDT2+(1 SHIFT)+1) = *(TAU+(1 SHIFT) +1 );/* ... -imag            */

         MY_DOT( N-2, V+(2 SHIFT), 1,
                  (V+(2 SHIFT )+LDV2), 1, d01);  /* Main dot product.         */

         *(d01)+=*(V+(1 SHIFT));            /* Part mult by assumed 1.0       */
         *(d01+1)-=*(V+(1 SHIFT) + 1) ;     /* taken conj                     */

/*       T[0,1] = -tau1*tau2*d01                                              */
/*       Perform                                                              */
/*       tau1( -a -ib) * tau2(c+id) = (-ac+bd)  -i(bc+ad)-> res               */
         *(T+LDT2)  = -1.0* (*TAU) * (*(TAU + 2))  +
                     (*(TAU + 1) ) * (*(TAU + 3));
         *(T+LDT2 + 1)  = -1.0* (  (*(TAU + 1) ) * (*(TAU + 2))  +
                     (*TAU) * (*(TAU + 3))   ) ;

/*       res = res* d01                                                       */
         MY_DOTU( 1, (T+LDT2), 1, (d01), 1, (T+LDT2) ); /* T[0,1]             */
      #endif

      return;
   }

   right = (K>>3)<<2;
   left = K -right;
   if (right == 0)                          /* If not enough,                 */
   {
      left  = K>>1;                         /* Take smaller half.             */
      right = K-left;                       /* right is the rest.             */
   }

   Y2 = V+(left SHIFT) +LDV2*left;          /* Y2 at V[left, left].           */
   T2 = T+(left SHIFT)+LDT2*left;           /* Address of new T2.             */

/*----------------------------------------------------------------------------*/
/* Recurse on the left, no change to T or V.                                  */
/*----------------------------------------------------------------------------*/
   ATL_larftFC(DIRECT, STOREV, N, left,     /* K changes for left.            */
               V, LDV, TAU, T, LDT);        /* Left uses same V,Tau,T.        */


/*----------------------------------------------------------------------------*/
/* Recurse on the right, T2 is always below and to                            */
/* The right of T1 (adjacent with no overlap).                                */
/*----------------------------------------------------------------------------*/
   ATL_larftFC(DIRECT, STOREV, N-left, right,    /* N and K change on right.  */
            Y2, LDV, TAU+(left SHIFT), T2, LDT); /* Right new V, Tau, T.      */

   ATL_larft_blockFC(N, K, left, right,
                     V, LDV, T, LDT);       /* Fill in urh block.             */

}                                           /* END ATL_dlarft                 */

void ATL_larftBC(const enum ATL_LADIRECT DIRECT, const enum ATL_LASTOREV STOREV,
                 ATL_CINT N, ATL_CINT K, TYPE *V, ATL_CINT LDV,
                 const TYPE *TAU, TYPE *T, ATL_CINT LDT)
{
   TYPE   *Y2, *T2;
   TYPE   dt;
   int    row, col;
   int LDV2, LDT2;
   LDV2 = LDV SHIFT;                        /* for complex LDV *2             */
   LDT2 = LDT SHIFT;                        /* for comlex LDT *2              */
   int left, right;

   #ifdef TREAL
      const TYPE ONE = ATL_rone;
      const TYPE ZEROVAL = ATL_rzero;
      TYPE VII;
      TYPE  d10, d20, d21;
   #else
      const TYPE ONE[2] = {ATL_rone, ATL_rzero};
      const TYPE ZEROVAL[2] = {ATL_rzero, ATL_rzero};
      TYPE VII[2];
      TYPE  d10[2], d02[2], d12[2];
   #endif

   if (K == 0) return;                      /* Nothing to do.                 */
   if (N == 0) return;                      /* Nothing to do.                 */
   if (DIRECT != LABackward || STOREV != LAColumnStore) /* If not my specialty*/
   {
      fprintf(stderr, "ATL_dlarft called with DIRECT=%d, STOREV=%d.\n"
                     "Aborting.\n", DIRECT, STOREV);
      exit(1);
   }

   if (K == 1)                              /* Down to a scalar?              */
   {
     #ifdef TREAL
        *T = *TAU;                          /* Y. Just copy it.               */
     #else
        *T = *TAU;                          /* Y. Just copy it.               */
        *(T+1) = *(TAU+1);                  /* Y. Just copy it.               */
     #endif
      return;                               /* ...All done!                   */
   }

/*----------------------------------------------------------------------------*/
/* K=2: We only need T[1,0], computed as: (zero-relative):                    */
/*                                                                            */
/* T[0, 1] = -tau[0] * d10 * tau[1].        d10 : v0^T V1                     */
/*----------------------------------------------------------------------------*/
   if (K == 2)
   {
      #ifdef TREAL
         *T = *TAU;                         /* Copy the diagonal...           */
         *(T+LDT+1) = *(TAU+1);             /* ...                            */
         d10 = MY_DOT( N-2, V+LDV, 1, V, 1);/* Main dot product.              */
         d10 += *(V+LDV+N-2);               /* Part mult by assumed 1.0       */
         *(T+1) = -(*(TAU+1)) * (*TAU)* d10;/* Fill in T[0,1].                */
      #else
         *T = *TAU;                         /* Copy the diagonal -real        */
         *(T+1) = *(TAU+1);                 /* Copy the diagonal. -real       */
         *(T+LDT2+(1 SHIFT) ) = *(TAU+(1 SHIFT));/* ... -imag                 */
         *(T+LDT2+(1 SHIFT)+1) = *(TAU+(1 SHIFT) +1 );/* ... -imag            */

/*       Y is  conjugate transposed                                           */
         MY_DOT( N-2, (V+LDV2), 1, (V), 1, d10); /* Main dot product.         */

         *(d10)+=*(V+LDV2+((N-2) SHIFT));   /* Part mult by assumed 1.0       */
         *(d10+1)-=*(V+LDV2+((N-2) SHIFT) + 1) ; /* taken conj                */

/*       T[1,0] = -tau1*tau2*d10                                              */
/*       Perform                                                              */
/*       tau1( -a -ib) * tau2(c+id) = (-ac+bd)  -i(bc+ad)-> res               */
         *(T+ (1 SHIFT) )  = -1.0* (*TAU) * (*(TAU + 2))  +
                     (*(TAU + 1) ) * (*(TAU + 3));
         *(T+(1 SHIFT) + 1)  = -1.0* (  (*(TAU + 1) ) * (*(TAU + 2))  +
                     (*TAU) * (*(TAU + 3))   ) ;

/*  res = res* d01                                                            */
         MY_DOTU( 1, (T+ ( 1 SHIFT) ), 1,
                  (d10), 1, (T + (1 SHIFT)) );   /* T[0,1]                    */

      #endif

      return;
   }

   left = (K>>3)<<2;
   right = K -left;
   if (left == 0)                           /* If not enough,                 */
   {
      right  = K>>1;                        /* Take smaller half.             */
      left = K-right;                       /* right is the rest.             */
   }

   Y2 = V+LDV2*left;                        /* Y2 at V[0, left].              */
   T2 = T+(left SHIFT)+LDT2*left;           /* Address of new T2.             */

/*----------------------------------------------------------------------------*/
/* Recurse on the right, no change to T or V.                                 */
/*----------------------------------------------------------------------------*/
   ATL_larftBC(DIRECT, STOREV, N, right,    /* K changes for left.            */
     Y2, LDV, (TAU+(left SHIFT)) , T2, LDT);/* Left uses same V,Tau,T.        */

/*----------------------------------------------------------------------------*/
/* Recurse on the left, T1 is always above and to                             */
/* The left of T1 (adjacent with no overlap).                                 */
/*----------------------------------------------------------------------------*/
   ATL_larftBC(DIRECT, STOREV, N-right, left,    /* N and K change on right.  */
            V, LDV, TAU, T, LDT);           /* Left same V, Tau, T.           */

   ATL_larft_blockBC(N, K, left, right,
                    V, LDV, T, LDT);        /* Fill in urh block.             */

}                                           /* END ATL_dlarft                 */


void ATL_larftFR(const enum ATL_LADIRECT DIRECT, const enum ATL_LASTOREV STOREV,
                 ATL_CINT N, ATL_CINT K, TYPE *V, ATL_CINT LDV,
                 const TYPE *TAU, TYPE *T, ATL_CINT LDT)
{
   TYPE   *Y2, *T2;
   TYPE   dt;
   int    row, col;
   int LDV2, LDT2;
   LDV2 = LDV SHIFT;                        /* for complex LDV *2             */
   LDT2 = LDT SHIFT;                        /* for comlex LDT *2              */
   int bottom, top;

   #ifdef TREAL
      const TYPE ONE = ATL_rone;
      const TYPE ZEROVAL = ATL_rzero;
      TYPE VII;
      TYPE  d01, d02, d12;
   #else
      const TYPE ONE[2] = {ATL_rone, ATL_rzero};
      const TYPE ZEROVAL[2] = {ATL_rzero, ATL_rzero};
      TYPE VII[2];
      TYPE  d01[2], d02[2], d12[2];
   #endif

   if (K == 0) return;                      /* Nothing to do.                 */
   if (N == 0) return;                      /* Nothing to do.                 */
   if (DIRECT != LAForward || STOREV != LARowStore)   /* If not my specialty, */
   {
      fprintf(stderr, "ATL_dlarft called with DIRECT=%d, STOREV=%d.\n"
                     "Aborting.\n", DIRECT, STOREV);
      exit(1);
   }

   if (K == 1)                              /* Down to a scalar?              */
   {
     #ifdef TREAL
        *T = *TAU;                          /* Y. Just copy it.               */
     #else
        *T = *TAU;                          /* Y. Just copy it.               */
        *(T+1) = *(TAU+1);                  /* Y. Just copy it.               */
     #endif
      return;                               /* ...All done!                   */
   }

/*----------------------------------------------------------------------------*/
/* K=2: We only need T[0,1], computed as: (zero-relative):                    */
/*                                                                            */
/* T[0, 1] = -tau[0] * d01 * tau[1].   ( z = -tau.T.Y.v')                     */
/*----------------------------------------------------------------------------*/
   if (K == 2)
   {
      #ifdef TREAL
         *T = *TAU;                         /* Copy the diagonal...           */
         *(T+LDT+1) = *(TAU+1);             /* ...                            */
         d01 = MY_DOT( N-2, (V+2*LDV), LDV,
               V+2*LDV+1, LDV);             /* Main dot product.              */
         d01 += *(V+LDV);                   /* Part mult by assumed 1.0       */
         *(T+LDT) = -(*TAU) * (*(TAU+1)) * d01;  /* Fill in T[0,1].           */
      #else
         *T = *TAU;                         /* Copy the diagonal -real        */
         *(T+1) = *(TAU+1);                 /* Copy the diagonal. -real       */
         *(T+LDT2+(1 SHIFT) ) = *(TAU+(1 SHIFT));/* ... -imag                 */
         *(T+LDT2+(1 SHIFT)+1) = *(TAU+(1 SHIFT) +1 );/* ... -imag            */

/*       conjugate of V is taken                                              */
         MY_DOT( N-2, (V+2*LDV2 +(1 SHIFT)), LDV,
               (V+2*LDV2), LDV, d01);       /* Main dot product.              */


        *( d01)  += *(V+LDV2);              /* Part mult by assumed 1.0       */
        *(d01+1) += *(V+LDV2 + 1);          /* Part mult by assumed 1.0       */

/*      T[0,1] = -tau1*tau2*d0                                                */
/*      Perform                                                               */
/*       tau1( -a -ib) * tau2(c+id) = (-ac+bd)  -i(bc+ad)-> res               */
         *(T+ LDT2 )  = -1.0* (*TAU) * (*(TAU + 2))  +
                     (*(TAU + 1) ) * (*(TAU + 3));
         *(T+ LDT2 + 1)  = -1.0* (  (*(TAU + 1) ) * (*(TAU + 2))  +
                     (*TAU) * (*(TAU + 3))   ) ;

/*       res = res* d01                                                       */
         MY_DOTU( 1, (T+LDT2), 1,
                  (d01), 1, (T+ LDT2) );    /* T[1,0]                         */
      #endif

      return;
   }

   bottom = (K>>3)<<2;
   top = K -bottom;
   if (bottom == 0)                         /* If not enough,                 */
   {
      top  = K>>1;                          /* Take smaller half.             */
      bottom = K-top;                       /* bottom is the rest.            */
   }

   Y2 = V+(top SHIFT) +LDV2*top;            /* Y2 at V[top, top].             */
   T2 = T+(top SHIFT)+LDT2*top;             /* Address of new T2.             */

/*----------------------------------------------------------------------------*/
/* Recurse on the top, no change to T or V.                                   */
/*----------------------------------------------------------------------------*/
   ATL_larftFR(DIRECT, STOREV, N, top,      /* K changes for top.             */
               V, LDV, TAU, T, LDT);        /* Left uses same V,Tau,T.        */


/*----------------------------------------------------------------------------*/
/* Recurse on the bottom, T2 is always below and to                           */
/* The bottom of T1 (adjacent with no overlap).                               */
/*----------------------------------------------------------------------------*/
   ATL_larftFR(DIRECT, STOREV, N-top, bottom,    /* N and K change on bottom. */
            Y2, LDV, TAU+(top SHIFT), T2, LDT);  /* Right new V, Tau, T.      */

   ATL_larft_blockFR(N, K, top, bottom,
                     V, LDV, T, LDT);       /* Fill in urh block.             */

}                                           /* END ATL_dlarft                 */

void ATL_larftBR(const enum ATL_LADIRECT DIRECT, const enum ATL_LASTOREV STOREV,
                 ATL_CINT N, ATL_CINT K, TYPE *V, ATL_CINT LDV,
                 const TYPE *TAU, TYPE *T, ATL_CINT LDT)
{
   TYPE   *Y2, *T2;
   TYPE   dt;
   int    row, col;
   int LDV2, LDT2;
   LDV2 = LDV SHIFT;                        /* for complex LDV *2             */
   LDT2 = LDT SHIFT;                        /* for comlex LDT *2              */
   int top, bottom;

   #ifdef TREAL
      const TYPE ONE = ATL_rone;
      const TYPE ZEROVAL = ATL_rzero;
      TYPE VII;
      TYPE  d10, d20, d21;
   #else
      const TYPE ONE[2] = {ATL_rone, ATL_rzero};
      const TYPE ZEROVAL[2] = {ATL_rzero, ATL_rzero};
      TYPE VII[2];
      TYPE  d10[2], d02[2], d12[2];
   #endif

   if (K == 0) return;                      /* Nothing to do.                 */
   if (N == 0) return;                      /* Nothing to do.                 */
   if (DIRECT != LABackward || STOREV != LARowStore)  /* If not my specialty, */
   {
      fprintf(stderr, "ATL_dlarft called with DIRECT=%d, STOREV=%d.\n"
                     "Aborting.\n", DIRECT, STOREV);
      exit(1);
   }

   if (K == 1)                              /* Down to a scalar               */
   {
     #ifdef TREAL
        *T = *TAU;                          /* Y. Just copy it.               */
     #else
        *T = *TAU;                          /* Y. Just copy it.               */
        *(T+1) = *(TAU+1);                  /* Y. Just copy it.               */
     #endif
      return;                               /* ...All done!                   */
   }

/*----------------------------------------------------------------------------*/
/* K=2: We only need T[1,0], computed as: (zero-relative):                    */
/*                                                                            */
/* T[0, 1] = -tau[0] *  tau[1] * d10        d10 : V1*v0^T                     */
/*                                   => -tau*T*Y*v^T                          */
/* T is a lower triangular matrix                                             */
/*----------------------------------------------------------------------------*/
   if (K == 2)
   {
      #ifdef TREAL
         *T = *TAU;                         /* Copy the diagonal...           */
         *(T+LDT+1) = *(TAU+1);             /* ...                            */
         d10 = MY_DOT( N-2, V, LDV,(V+1), LDV);  /* Main dot product.         */
         d10 += *(V+1+(N-2)*LDV);           /* Part mult by assumed 1.0       */
         *(T+1) = -(*(TAU)) * (*(TAU+1))* d10;   /* Fill in T[1,0].           */
      #else
         *T = *TAU;                         /* Copy the diagonal -real        */
         *(T+1) = *(TAU+1);                 /* Copy the diagonal. -real       */
         *(T+LDT2+(1 SHIFT) ) = *(TAU+(1 SHIFT));/* ... -imag                 */
         *(T+LDT2+(1 SHIFT)+1) = *(TAU+(1 SHIFT) +1 );/* ... -imag            */

/*       conjugate of V is taken                                              */
         MY_DOT( N-2, V, LDV, (V+( 1 SHIFT) ), LDV, d10); /* Main dot product.*/

         *(d10)+=*(V+(1 SHIFT) + (N-2)*LDV2);    /* Part mult by assumed 1.0  */
         *(d10+1)+=*(V+(1 SHIFT)+1 + (N-2)*LDV2 ); /* Part mult by assumed 1.0*/

/*       T[1,0] = -tau1*tau2*d10                                              */
/*       Perform                                                              */
/*       tau1( -a -ib) * tau2(c+id) = (-ac+bd)  -i(bc+ad)-> res               */
         *(T+ ( 1 SHIFT) )  = -1.0* (*TAU) * (*(TAU + 2))  +
                     (*(TAU + 1) ) * (*(TAU + 3));
         *(T+ ( 1 SHIFT) + 1)  = -1.0* (  (*(TAU + 1) ) * (*(TAU + 2))  +
                     (*TAU) * (*(TAU + 3))   ) ;

/*       res = res* d10                                                       */
         MY_DOTU( 1, (T+(1 SHIFT)), 1,
                  (d10), 1, (T+ ( 1 SHIFT) ) );  /* T[1,0]                    */

      #endif

      return;
   }

   top = (K>>3)<<2;
   bottom = K -top;
   if (top == 0)                            /* If not enough,                 */
   {
      bottom  = K>>1;                       /* Take smaller half.             */
      top = K-bottom;                       /* bottom is the rest.            */
   }

   Y2 = V+(top SHIFT) ;                     /* Y2 at V[top,0].                */
   T2 = T+(top SHIFT)+LDT2*top;             /* Address of new T2.             */

/*----------------------------------------------------------------------------*/
/* Recurse on the bottom, no change to T or V.                                */
/*----------------------------------------------------------------------------*/
   ATL_larftBR(DIRECT, STOREV, N, bottom,   /* K changes for top.             */
     Y2, LDV, (TAU+(top SHIFT)) , T2, LDT); /* Left uses same V,Tau,T.        */

/*----------------------------------------------------------------------------*/
/* Recurse on the top, T1 is always above and to                              */
/* The top of T1 (adjacent with no overlap).                                  */
/*----------------------------------------------------------------------------*/
   ATL_larftBR(DIRECT, STOREV, N-bottom, top,    /* N and K change on bottom. */
               V, LDV, TAU, T, LDT);             /* Left same V, Tau, T.      */

   ATL_larft_blockBR(N, K, top, bottom,
                    V, LDV, T, LDT);        /* Fill in urh block.             */

}                                           /* END ATL_dlarft                 */

@ROUT ATL_ladiv
@extract -b @(topd)/cw.inc lang=C -def cwdate 2009 -def cwauth "Siju Samuel" -def contrib "Anthony M. Castaldo, R. Clint Whaley"

/*
 * This is the C translation of the standard LAPACK Fortran routine:
 *      void      FUNCTION ZLADIV( X, Y, Z)
 *
 * ATL_ladiv.c :
 *             void ATL_cmladiv( TYPE *X, TYPE *Y, TYPE  *Z)
 *     NOTE :  a) ATL_ladiv.c will get compiled to two  precisions
 *                single precision complex,   double precision complex
 *
 *             b) This should be called only for real numbers
 *
 * Purpose
 * =======
 *
 * Z := X / Y, where X and Y are complex.  The computation of X / Y
 * will not overflow on an intermediary step unless the results
 * overflows.
 *
 *        This performs complex division in  real arithmetic
 *
 *                               a + i*b
 *                    p + i*q = ---------
 *                               c + i*d
 *
 *        The algorithm is due to Robert L. Smith and can be found
 *         in D. Knuth, The art of Computer Programming, Vol.2, p.195
 *
 * Arguments
 * =========
 *
 *         X       (input)
 *         Y       (input)
 *                 The complex scalars X and Y ( pointer to X and Y).
 *         Z       (input/output) is the output  ( pointer  to Z)
 *
 */
#include "atlas_misc.h"
#include "cblas.h"
#include "atlas_lapack.h"


void ATL_ladiv(const TYPE *X, const TYPE *Y, TYPE  *Z)
{
   TYPE   E, F;

/* If           X[0], X[1], Y[0], Y[1], &Z[0], &Z[1]  is mapped to            */
/* real numbers  A,    B,    C,    D,    *P,   *Q                             */
/* the computation is as below                                                */
/*                                                                            */
/*   if ( fabs(D) < fabs( C) ) {                                              */
/*         E = D / C ;                                                        */
/*         F = C + D*E ;                                                      */
/*         *P = ( A+B*E ) / F ;                                               */
/*         *Q = ( B-A*E ) / F ;                                               */
/*                                                                            */
/*   } else{                                                                  */
/*         E = C / D ;                                                        */
/*         F = D + C*E ;                                                      */
/*         *P = ( B+A*E ) / F ;                                               */
/*         *Q = ( -A+B*E ) / F ;                                              */
/*   }                                                                        */

   if ( Mabs(Y[1])  < Mabs(Y[0]) )
   {
      E = Y[1]/Y[0];
      F = Y[0] + Y[1]*E;
      *(Z)   = ( X[0] + X[1]*E ) / F ;
      *(Z+1) = ( X[1] - X[0]*E ) / F ;
   }
   else
   {
      E = Y[0]/Y[1];
      F = Y[1] + Y[0]*E;
      *(Z)   = (X[1]+ X[0]*E ) / F ;
      *(Z+1) = (-X[0] + X[1]*E ) / F ;
   }
}                                           /* END AL_ladiv                   */
@ROUT ATL_lacgv
@extract -b @(topd)/cw.inc lang=C -def cwdate 2009 -def cwauth "Siju Samuel" -def contrib "Anthony M. Castaldo, R. Clint Whaley"

/*
 * This is the C translation of the standard LAPACK Fortran routine:
 *      SUBROUTINE C/Z LACGV( N, X, INCX )
 *
 *  Purpose
 *  =======
 *
 *  ATL_lacgv.c conjugates a complex vector of length N.
 *
 *  Arguments
 *  =========
 *
 *  N       (input) INTEGER
 *          The length of the vector X.  N >= 0.
 *
 *  X       (input/output) complex array, dimension
 *                         (1+(N-1)*abs(INCX))
 *          On entry, the vector of length N to be conjugated.
 *          On exit, X is overwritten with conjg(X).
 *
 *          NOTE : complex numbers are stored as,
 *          real(single/complex), imaginary(single/complex)
 *          in concequtive memory locations.
 *
 *  INCX    (input) INTEGER
 *          The spacing between successive elements of X.
 *
 *  NOTE : rewritten by RCW to just call SCAL of underlying type.
 *
 */
#include "atlas_misc.h"
#include "cblas.h"
#include "atlas_lapack.h"

/* Compiled only to precisions single complex and double complex.             */
void ATL_lacgv(ATL_CINT N, TYPE *X, ATL_CINT INCX)
{
@beginskip
   int i, ioff;

   if ( INCX == 1)
   {
/*    imaginary part = Negetive of imaginary(X[i])                            */
      for ( i = 0; i < N; i++)
      {
          *(X + (i SHIFT) + 1 ) = 0.0 - *(X + (i SHIFT) + 1 ) ;
      }
   }
   else
   {
/*    TODO : Test this section on i off                                       */
      ioff =0;
      if ( INCX < 0 ){
         ioff = 0 - ( N-1)*INCX;
      }

      for ( i =0; i < N; i=i++)
      {
/*       Negetaive of imaginary number is taken                               */
         *(X+ ( ioff SHIFT ) + 1  ) = 0.0 - *(X+ (ioff SHIFT) + 1 );
         ioff = ioff + INCX;                /* increment the offset           */
      }
   } //else on INCX

   return;
@endskip
   ATL_CINT incX = (INCX >= 0) ? (INCX+INCX) : ((-INCX)<<1);
   Mjoin(PATLU,scal)(N, ATL_rnone, X+1, incX); /* conj imag elts */
}
@ROUT ATL_lapy3
@extract -b @(topd)/cw.inc lang=C -def cwdate 2009 -def cwdate 2012 -def cwauth "Siju Samuel" -def contrib "Anthony M. Castaldo, R. Clint Whaley"

/*-----------------------------------------------------------------------------
 *  This is the C translation of the standard LAPACK Fortran routine:
 *      DOUBLE PRECISION FUNCTION DLAPY3( X, Y, Z )
 *      NOTE : ATL_lapy3.c  will get compiled to
 *             single precision complex (ATL_clapy3.o)  and
 *              double precision complex (ATL_zlapt3.o)
 *
 *   Purpose
 *   =======
 *   ATL_lapy3 returns sqrt(x**2+y**2+z**2), taking care not to cause
 *         unnecessary overflow.
 *
 *   Arguments
 *   =========
 *
 *   X       (input) single/double precision
 *   Y       (input) single/double precision
 *   Z       (input) single/double precision
 *                 X, Y and Z specify the values x, y and z.
-----------------------------------------------------------------------------*/
#include "cblas.h"
#include "atlas_lapack.h"
#include "math.h"

TYPE  ATL_lapy3(const TYPE X, const TYPE Y, const TYPE Z)
{
   TYPE  ONE=1.0, ZERO=0.0, W, Wtemp,  XABS, YABS, ZABS, TEMP;

   XABS = Mabs(X);
   YABS = Mabs(Y);
   ZABS = Mabs(Z);

/* W : get the maximum absolute value from x,y,z                              */
   Wtemp = (XABS<YABS)?YABS:XABS;
   W = (Wtemp<ZABS)?ZABS:Wtemp;

   if (W == ZERO)
   {
/*    W can be zero for max(0,nan,0). Adding all three entries                */
/*    together will make sure  NaN will not disappear.                        */

      return( XABS + YABS + ZABS);
   }
   else
   {
      TEMP =( XABS / W )*( XABS / W ) +
            ( YABS / W )*( YABS / W ) +
            ( ZABS / W )*( ZABS / W ) ;

      #if defined(SREAL) || defined(SCPLX)
         return (W * sqrtf(TEMP));           /* Use single precision sqrt.    */
      #else                         
         return (W * sqrt(TEMP));            /* Use double precision sqrt.    */
      #endif 
   }
}                                            /* END ATL_?lapy3                */
@ROUT ATL_lamch
/*
 *  ATL_lamch.c :
 *                TYPE  ATL_lamch(char  CMACH )
 *                Will get compiled to single precision and double precesion
 *
 *  Purpose
 *  =======
 *
 *  ATL_lamch determines single/double precision machine parameters.
 *
 *  Arguments
 *  =========
 *
 *  CMACH   (input) CHARACTER*1
 *          Specifies the value to be returned by DLAMCH:
 *          = 'E' or 'e',   DLAMCH := eps
 *          = 'S' or 's ,   DLAMCH := sfmin
 *          = 'B' or 'b',   DLAMCH := base
 *          = 'P' or 'p',   DLAMCH := eps*base
 *          = 'N' or 'n',   DLAMCH := t
 *          = 'R' or 'r',   DLAMCH := rnd
 *          = 'M' or 'm',   DLAMCH := emin
 *          = 'U' or 'u',   DLAMCH := rmin
 *          = 'L' or 'l',   DLAMCH := emax
 *          = 'O' or 'o',   DLAMCH := rmax
 *
 *          where
 *
 *          eps   = relative machine precision
 *          sfmin = safe minimum, such that 1/sfmin does not overflow
 *          base  = base of the machine
 *          prec  = eps*base
 *          t     = number of (base) digits in the mantissa
 *          rnd   = 1.0 when rounding occurs in addition, 0.0 otherwise
 *          emin  = minimum exponent before (gradual) underflow
 *          rmin  = underflow threshold - base**(emin-1)
 *          emax  = largest exponent before overflow
 *          rmax  = overflow threshold  - (base**emax)*(1-eps)
 *
 */
#include "atlas_misc.h"
#include "atlas_lapack.h"
#include "cblas.h"
#define TRUE 1
#define FLASE 0
#define ATL_rmin       Mjoin(PATL,rmin)
#define ATL_emin       Mjoin(PATL,emin)
#define ATL_mantissa   Mjoin(PATL,mantissa)
#define ATL_rmax       Mjoin(PATL,rmax)
#define ATL_epsilon1   Mjoin(PATL,epsilon1)

TYPE ATL_rmin();
int ATL_emin();
int ATL_mantissa();
TYPE ATL_rmax(int P);
TYPE  ATL_epsilon1();

TYPE  ATL_lamch(char CMACH )
{
   const TYPE ONE = ATL_rone;
   const TYPE ZERO = ATL_rzero;
   const TYPE  BASE = 2.0;
   static int FIRST = TRUE;

   int   IT;
/* double volatile  EMAX, EMIN, EPS, PREC, RMACH, RMAX, RMIN,
 *                        RND, SFMIN, SMALL, T;
 */

   TYPE static EPS1,  RMACH, RMAX, RMIN, SFMIN, SMALL, T;

   if(FIRST)
   {
      T     = ATL_mantissa();               /* int to Double                  */
      EPS1   = ATL_epsilon1();
/*    PREC = BASE*EPS;         Just for reference                             */

      RMIN   = ATL_rmin();
      SFMIN  = RMIN;

      RMAX   = ATL_rmax(T);

      SMALL  = ONE /RMAX;

      if ( SMALL > SFMIN )
      {
/* Use SMALL plus a bit, to avoid the possibility of rounding                 */
/*           causing overflow when computing  1/sfmin.                        */
         SFMIN = SMALL*( ONE+EPS1 );

      }
   }                                        /* if first                       */

   switch(CMACH)
   {
      case 'E':
         RMACH = EPS1;
         break;
      case 'S':
         RMACH = SFMIN;
         break;
      case 'B':
         RMACH = BASE;
         break;
/*      case 'P':
 *        RMACH = PREC;
 */       break;
case 'N':
RMACH = T;
break;
/*      case 'M':
 *        RMACH = EMIN;
 */        break;
case 'U':
RMACH = RMIN;
break;
/*      case 'L':
 *        RMACH = EMAX;
 */        break;
case 'O':
RMACH = RMAX;
break;
}

FIRST  = FLASE;
return RMACH;
}                                           /* End of ATL_lamch               */


TYPE ATL_rmin()
{

   int EMIN, T, i;
   TYPE volatile LRMIN = 1.0;
   TYPE const RBASE = 1/2.0;

/*  Now find  EMIN.  Let A = + or - 1, and + or - (1 + BASE**(-3)).           */
/*  Keep dividing  A by BETA until (gradual) underflow occurs. This           */
/*  is detected when we cannot recover the previous A.                        */

   EMIN = ATL_emin();

/*  Special LOGIC :                                                           */
/*  ( Non twos-complement machines, with gradual underflow;                   */
/*    e.g., IEEE standard followers )                                         */

   T = ATL_mantissa();
   EMIN = EMIN - 1 + T;

/* Compute  RMIN by successive division by  BETA. We could compute            */
/* RMIN as BASE**( EMIN - 1 ),  but some machines underflow during            */
/* this computation.                                                          */

   for ( i = 0; i <  (1 - EMIN); i++)
   {
      LRMIN = LRMIN*RBASE;
   }

   return LRMIN;

}


int ATL_emin()
{
/*  The minimum exponent before (gradual) underflow, computed by              */
/*  setting A = START value (1.00  and dividing by BASE until the             */
/*  previous  A  can not be recovered.                                        */

   int            I, EMIN;
   TYPE const    ONE = 1.0,  ZERO =0.0;
   TYPE volatile   A, B1, B2, C1, C2, D1, D2, RBASE;
   TYPE BASE = 2.0;
   int BASEINT = 2;

   A = 1.0;
   RBASE = ONE / BASE;
   EMIN = 1;
   B1 = A*RBASE;
   C1 = A;
   C2 = A;
   D1 = A;
   D2 = A;

   while ( ( C1 == A ) && ( C2 == A )  &&
      ( D1  == A ) && ( D2 == A )      )
   {

      EMIN = EMIN - 1;
      A = B1;
      B1 =  A / BASE;
      C1 = B1*BASE;
      D1 = ZERO;
      for(I=0; I< BASE ; I++) D1 = D1 + B1;

      B2 = A*RBASE;
      C2 =  B2 / RBASE;
      D2 = ZERO;

      for(I=0; I< BASE ; I++) D2 = D2 + B2;
   }
   return EMIN;
}


int ATL_mantissa()
{

/*  Now find  the  mantissa, t.  It should  be the  integer part of           */
/*  log to the base beta of a,  however it is safer to determine  t           */
/*  by powering.  So we find t as the smallest positive integer for           */
/*  which                                                                     */
/*         fl( beta**t + 1.0 ) = 1.0.                                         */

   int LT;
   TYPE  volatile A,C;
   TYPE ONE = 1.0;
   TYPE BETA = 2.0;

   LT = 0;
   A = 1.0;
   C = 1.0;

   while(C == ONE )
   {
      LT = LT + 1;
      A = A*BETA;
      C = A+ ONE;
      C =  C -A ;
   }
   return LT;
}



TYPE ATL_rmax(int P)
{
/* attempts to compute RMAX, the largest machine floating-point               */
/*  number, without overflow.  It assumes that EMAX + abs(EMIN) sum           */
/*  approximately to a power of 2                                             */

   TYPE volatile A =1.0;
   TYPE volatile B =1.0;
   TYPE volatile C =2.0;
   TYPE volatile   Z, Y, OLDY,  RECBAS ;
   TYPE const BETA = 2.0, ONE = 1.0, ZERO = 0.0;
   int I ;

   int IMAX = 0;          //Starting with 0,


   while ( C == 2.00)
   {
      IMAX = IMAX + 1;
      A = B;
      B = A* 2.0;
      C = B/A;
   }

/*     Now create RMAX, the largest machine number, which should              */
/*     be equal to (1.0 - BETA**(-P)) * BETA**EMAX .                          */
/*                                                                            */
/*     First compute 1.0 - BETA**(-P), being careful that the                 */
/*     result is less than 1.0 .                                              */

   RECBAS = ONE / BETA;
   Z = BETA - ONE;
   Y = ZERO;

   for (  I=0; I < P; I++)
   {
      Z = Z*RECBAS;
      if ( Y < ONE ) OLDY = Y;
      Y = Y +  Z ;
   }
   if ( Y > ONE )  Y = OLDY;

   for( I = 0; I < IMAX ; I++)
   {
         Y = Y*BETA;
   }

   return Y;
}


TYPE  ATL_epsilon1()
{
   static TYPE eps;
   const TYPE  half=0.5;
   volatile TYPE  maxval, f1=0.5;

   do
   {
      eps = f1;
      f1 *= half;
      maxval = 1.0 + f1;
   }
   while (maxval != 1.0);
   return(eps);
}


@ROUT qrtst
@extract -b @(topd)/cw.inc lang=C -def cwdate 2009 -def cwauth "Siju Samuel" -def contrib "R. Clint Whaley, Anthony M. Castaldo"
/*
 *  This program is a tester for QR, RQ, LQ and QL factorization routines.
 */

#include <string.h>
#include "atlas_misc.h"
#include "atlas_lapack.h"
#include "cblas.h"
#include "atlas_cblastypealias.h"
#include "atlas_tst.h"
#ifndef TimeF77
   #include "clapack.h"
#endif

#ifdef ATL_FULL_LAPACK
   #include "atlas_C2Flapack.h"

   @whiledef rt qr ql rq lq
   #ifdef TREAL
      #define LA_@up@(rt)2Q Mjoin(Mjoin(ATL_C2F,PRE),orm@(rt))
   #else
      #define LA_@up@(rt)2Q Mjoin(Mjoin(ATL_C2F,PRE),unm@(rt))
   #endif
   @endwhile
#endif

#ifdef GCCWIN
   ___main(){} __main(){} MAIN__(){} _MAIN_(){}
#endif
#define PRINT_1    0
#define TESTCORRECT  1

#ifdef TREAL
   static const TYPE ONE = ATL_rone;
   static const TYPE ZEROVAL = ATL_rzero;
   #define MY_TRANS CblasTrans
#else
   static const TYPE ONE[2] = {ATL_rone, ATL_rzero};
   static const TYPE ZEROVAL[2] = {ATL_rzero, ATL_rzero};
   #define MY_TRANS CblasConjTrans
#endif

@whiledef rt qr ql rq lq
#ifdef TimeF77
   #define test_ge@(rt)f(Major_, M_, N_, A_, lda_, tau_, wrk_, lw_) \
      ATL_assert(!Mjoin(PATL,f77ge@(rt)f) \
         (Major_, M_, N_, A_, lda_, tau_, wrk_, lw_))
#elif defined(TimeC)
   #define test_ge@(rt)f(Major_, M_, N_, A_, lda_, tau_, wrk_, lw_) \
   { \
      if ((lw_) != -1) \
      { \
         ATL_assert(!Mjoin(Mjoin(clapack_,PRE),ge@(rt)f) \
            (CblasColMajor, M_, N_, A_, lda_, tau_)) \
      } \
      else (wrk_)[0] = 0; \
   }
#elif defined(ATL_USEPTHREADS)
   #define test_ge@(rt)f(Major_, M_, N_, A_, lda_, tau_, wrk_, lw_) \
      ATL_assert(!Mjoin(PATL,tge@(rt)f) \
         (M_, N_, A_, lda_, tau_, wrk_, lw_))
#else
   #define test_ge@(rt)f(Major_, M_, N_, A_, lda_, tau_, wrk_, lw_) \
      ATL_assert(!Mjoin(PATL,ge@(rt)f) \
         (M_, N_, A_, lda_, tau_, wrk_, lw_))
#endif
@endwhile
/*
 * Print a Matrix
 */
void printMatrix(char *msg, TYPE *A, int M, int N, int lda)
{
   if(PRINT_1)
      Mjoin(PATL,geprint)(msg, M, N, A, lda);
}

/*
 * Print a Vector
 */
void printVector( char * msg, TYPE *X, int N)
{
   if(PRINT_1)
      Mjoin(PATL,geprint)(msg, N, 1, X, N);
}

/*
 * Copy Vector X1[1:n] to  -1.0*X1[1:n]
 */
void   makeVectorToNegVal( TYPE *X1, int size)
{
   int  i, size2;
   size2 = size SHIFT;                // 2*size, for  complex  numbers

   for ( i= 0; i < size2; i++)
   {
      X1[i] = -1.0*X1[i];
   }
}


int AllocationErr( char * msg)
{
   printf("Error while allocating %s\n", msg);
   exit(-1);
}

/*
 * Returns a duplicate of the A matrix, with new leading dimension
 * lda   : leading dimension of A
 * ldc   : leading dimension of Duplicate Matrix
 */
static TYPE *DupMat(enum ATLAS_ORDER Order, int M, int N, TYPE *A, int lda,
                     int ldc)
{
   int i, j, M2;
   const int ldc2 = (ldc SHIFT), lda2 = (lda SHIFT);
   TYPE *C;
   if (Order == CblasRowMajor)
   {
      i = M;
      M = N;
      N = i;
   }
   M2 = M SHIFT;
   ATL_assert(ldc >= M);
   C = malloc(ATL_MulBySize(ldc)*N);
   ATL_assert(C);
   for (j=0; j != N; j++)
   {
      for (i=0; i != M2; i++) C[i] = A[i];
      C += ldc2;
      A += lda2;
   }
   return(C-N*ldc2);
}

/*
 * Make input square matrix A[NxN] as Identity Matrix.
 */
void  makeIdenty(TYPE *A, int N, int lda)
{
   int i, j, lda2;

   lda2 = lda SHIFT;                  // 2*lda for complex

   for(i=0; i<N; i++)
   {
      for(j=0; j<N; j++)
      {
         #ifdef TREAL
            if(i==j){
               *(A+j*lda2+i) = 1.0;
            }
            else {
               *(A+j*lda2+i) = 0.0;
            }
         #else
            if(i==j){
               *(A+j*lda2 + (i SHIFT ) ) = 1.0;
               *(A+j*lda2+ (i SHIFT ) + 1) = 0.0;
            }
            else {
               *(A+j*lda2+ (i SHIFT ) ) = 0.0;
               *(A+j*lda2+ (i SHIFT ) + 1) = 0.0;
            }
          #endif
      }
   }
}

/*
 * Allocate a space for ldmxN for 'real'.
 * For Complex allocate space for (2*ldm)xN.
 * It also takes care of the precision.
 * Then generate matrix for MxN, real/complex values based on the precision.
 */
TYPE *GetGE(int M, int N, int lda)
{
   TYPE *A;
   A = malloc(ATL_MulBySize(lda)*N);
   if (A) Mjoin(PATL,gegen)(M, N, A, lda, M*N+lda);
   return(A);
}

/*
 * Populate Vi vector  from the given ROW of A Matrix.  A has the pointer
 * to the first element  in the row. N represent the size of row.
 * 'numberOfVielement' denotes  (N - number of zero elements in Vi)
 *
 *   if       ROW-> v v v v R R R (example)
 *   then     VI->  v v v v 1 (example)
 *
 *   NOTE : For Complex conjugate of v(i) is taken
 *
 */
void populateViForRQ (TYPE *Vi, TYPE * A, int lda,
                        int numberOfVielement)
{
   int j =0;
   int i =0;
   int lda2 = lda SHIFT;

   #ifdef TREAL
      for ( j = 0; j < (numberOfVielement -1 ); j++)
      {
         Vi[j]= *(A+j*lda);
      }
      Vi[numberOfVielement -1 ] = 1.0;
   #else
      for ( j = 0; j < ( (numberOfVielement -1)); j++)
      {
         Vi[(j SHIFT) ]= *(A+j*lda2);

/*       Conjugate is taken                                                   */
         Vi[(j SHIFT) +1 ]= 0.0 - *(A+j*lda2 + 1);
      }
      Vi[ ( (numberOfVielement -1) SHIFT)  ] = 1.0;
      Vi[ ( (numberOfVielement -1) SHIFT) + 1  ] = 0.0;
   #endif
}

/*
 * Populate Vi vector  from the given ROW of A Matrix.  A has the pointer
 * to the first element  in the row. N represent the size of row.
 * 'numberOfVielement' denotes  (N - number of zero elements in Vi)
 *
 *    vi -> L L v v v v v  (example)
 *           To
 *    vi -> 1 v v v v v  (example)
 *
 *     NOTE : Conjugate is taken for complex
 *
 */
void populateViForLQ (TYPE *Vi, TYPE * A, int N, int lda,
                                    int numberOfVielement )
{
   int j =0;
   int i =0;
   int lda2 = lda SHIFT;

   #ifdef TREAL
      Vi[0] = 1.0;
      for (j=1; j < numberOfVielement; j++)
      {
         Vi[j]= *(A+ (( N - numberOfVielement + j)*lda) );
      }
   #else
      Vi[0] = 1.0;
      Vi[1] = 0.0;
      for (j=1; j < numberOfVielement; j++)
      {
         Vi[(j SHIFT) ]= *(A+ (( N - numberOfVielement + j)*lda2) );
         Vi[(j SHIFT) + 1]= 0.0 - *(A+ (( N - numberOfVielement + j)*lda2)+1);
      }
   #endif
}
 
void populateViForQR(TYPE *Vi, TYPE * A, int M,  int numberOfVielement)
{
   int j = 0;

   #ifdef TREAL
      Vi[0] = 1.0;
   #else
      Vi[0] = 1.0;
      Vi[1] = 0.0;
   #endif
   for (j=1; j<numberOfVielement;  j++)
   {
      #ifdef TREAL
         Vi[j] = A[j+ M-numberOfVielement];
      #else
         Vi[(j SHIFT)] = A[((j+ M-numberOfVielement) SHIFT) ];
         Vi[(j SHIFT)+1] = A[((j+ M-numberOfVielement) SHIFT) + 1 ];
      #endif
   }
}

/*
 * Populate Vi vector  from the given COLUMN of A Matrix.  A has the pointer
 * to the top of the column.
 * 'numberOfVielement' denotes  (M - number of zero elements in Vi)
 *
 *                      v                        v
 *                      v                        v
 *                      v            TO          v
 *                      R                        1
 *                      R
 *                      R
 */
void populateViForQL(TYPE *Vi, TYPE * A,  int numberOfVielement)
{
   int j =0;

   #ifdef TREAL
      for (j=0; j< (numberOfVielement-1);  j++)
      {
         Vi[j] = A[j];
      }
      Vi[numberOfVielement -1 ] = 1.0;
   #else
      for (j=0; j< ( (numberOfVielement-1) SHIFT );  j++)
      {
         Vi[j ] = A[j];
      } 
      Vi[(numberOfVielement -1) SHIFT ] = 1.0;
      Vi[ ((numberOfVielement -1) SHIFT ) + 1 ] = 0.0;
   #endif
}

/*  Make Matrix A to Upper Triangular or Upper Trapezoidal to make R matrix
 *  as per QR factorization. (Refer lapack for how the values are stored in A)
 */
void makeToUTForQR(TYPE *A , int lda, int M, int N)
{
   int i, j;
   int lda2 = lda SHIFT;              // 2*lda for complex

   for(i=0; i<M; i++)
   {
      for(j=0; (j<i && j < N) ; j++)
      {
         #ifdef TREAL
            *(A+j*lda2+i SHIFT) =  0.0;
         #else
            *(A+j*lda2+(i SHIFT)) =  0.0;
            *(A+j*lda2+(i SHIFT) + 1) =  0.0;
         #endif
      }
   }
}

/*
 * Make  the lower portion of the matrix to zero w.r.t to the
 * diagonal from bottom left (Note: change to standard naming)
 */
void makeToUTForRQ(TYPE *A , int lda, int M, int N )
{
   int i, j , lda2;
   int k =0;

   lda2 = lda SHIFT;

   int mn = Mmin(M,N) ;

   for(i=(M-1); i >= (M -mn) ; i--)
   {
      k++;

      for(j=(N-1-k ); j>=0  ; j--)
      {
         #ifdef TREAL
            *(A+j*lda2+i) =  0.0;
         #else
            *(A+j*lda2+ (i SHIFT) ) =  0.0;
            *(A+j*lda2+ (i SHIFT) + 1) =  0.0;
         #endif
      }
   }
}

/*
 * Make  the upper portion of the matrix to zero w.r.t to the
 * diagonal from upper right  (Note: change to standard naming)
 */
void makeToLTForLQ(TYPE *A , int lda, int M, int N )
{
   int i, j, lda2 ;
   int k =0;

   lda2 = lda SHIFT;
   int mn = Mmin(M,N) ;

   for(i=0;  i< mn  ; i++)
   {
      for(j= (i+1); j < N ; j++)
      {
         #ifdef TREAL
             *(A+j*lda2+(i SHIFT) ) =  0.0;
         #else
             *(A+j*lda2+(i SHIFT)) =  0.0;
             *(A+j*lda2+(i SHIFT) + 1) =  0.0;
         #endif
      }
   }
}

/*
 * Make  the upper portion of the matrix to zero w.r.t to the
 * diagonal from bottom left (Note: change to standard naming)
 */
void makeToLTForQL(TYPE *A , int lda, int M, int N )
{
   int i, j , lda2;
   int k =0;

   lda2 = lda SHIFT;

   int mn = Mmin(M,N) ;

   for(j=(N-1); j >= (N -mn) ; j--)
   {
      k++;

      for(i=(M-1-k ); i>=0  ; i--)
      {
         #ifdef TREAL
            *(A+j*lda2+i) =  0.0;
         #else
            *(A+j*lda2+ (i SHIFT) ) =  0.0;
            *(A+j*lda2+ (i SHIFT) + 1) =  0.0;
         #endif
      }
   }
}

static TYPE lqtest(int M, int N, int lda, int flushKB, double *time)
{
   TYPE *A, *TAU, *TAUNEG,  *WORK, *WORKF,  *L, *W ;
   TYPE *Q, *VI;
   TYPE *AORIG;
   int viCounter =0;
   TYPE dtmp, dtmp1;
   double t0;

   int ITER ;

   #ifdef TREAL
      TYPE NEGTAUVAL = ATL_rzero;
   #else
      TYPE NEGTAUVAL[2] = {ATL_rzero, ATL_rzero};
   #endif

   int LWORK;
   TYPE normA, eps, resid;
   int i, j, k, ldn, ldm, ldmn;

   ldm = M;
   ldn = N;
   const int MNmin = Mmin(M,N);
   const int Maxmn = Mmax(M,N);
   ldmn = MNmin;

   eps = Mjoin(PATL,epsilon)();

/* Allocate A and initialize                                                  */
   A = GetGE(M, N, lda);
   if (A == NULL) AllocationErr("A");

if(TESTCORRECT)
{
/* Allocate A Original and copy from A                                        */
   AORIG = DupMat(CblasColMajor, M, N, A, lda, lda);
}

/* Call to get the  size of workspace required                                */
   test_gelqf(CblasColMajor, M, N, &dtmp1, lda, &dtmp1, &dtmp, -1);

/* Get Work and LWORK                                                         */
   LWORK = dtmp;
   WORK = malloc(ATL_MulBySize(LWORK));
   if (WORK == NULL) return(-1);

   TAU = malloc(ATL_MulBySize(MNmin));
   if (TAU == NULL) AllocationErr("TAU");
   if (flushKB > 0)
   {
      t0 = ATL_flushcache(flushKB*1024);
      t0 += ATL_flushcache(-1);
   }
   t0 = time00();
   test_gelqf(CblasColMajor, M, N, (TYPE*)(A), lda,
              (TYPE*)(TAU), (TYPE*)(WORK), LWORK);
   *time = time00() - t0;
   if (flushKB)
      t0 += ATL_flushcache(0);
if(TESTCORRECT)
{
/* Allocate and Copy TAU to TAUNEG                                            */
   TAUNEG = DupMat(CblasColMajor, MNmin, 1, TAU, ldmn, ldmn);

   makeVectorToNegVal(TAUNEG, MNmin);

/* Allocate Vi, based on Size of N                                            */
   VI = malloc(ATL_MulBySize(N));
   if (VI == NULL) AllocationErr("VI");

/* Allocate Q and Q-temp,   lda equals N                                      */
   Q = malloc(ATL_MulBySize(ldn)*N);
   if (Q == NULL) AllocationErr("Q");

   W = malloc(ATL_MulBySize(ldn));
   if (W == NULL) AllocationErr("W");

   makeIdenty(Q, N, ldn);              //Q: Size of Q mat  and lda is N

/* Copy A[M, N] to L and then Modify the upper part of DIAG w.r.t top left    */
   L= DupMat(CblasColMajor, M, N, A, lda, ldm);
   makeToLTForLQ(L , ldm, M, N );

   printMatrix("AORIG",AORIG, M, N, lda);
   printMatrix("A",A, M, N, lda);
   printMatrix("Q MARTIX ", Q, N, N, ldn);
   printMatrix("L matrix", L, M, N, ldm);
   printVector("TAU", TAU, MNmin);
   printVector("TAUNEG", TAUNEG, MNmin);

   #ifdef ATL_FULL_LAPACK
      ATL_assert(!LA_LQ2Q(CblasRight, CblasNoTrans, N, N, MNmin, A, lda, TAU,
                           Q, ldn));
   #else
/*
 *    Form Q Matrix
 *    Q = H(K).H(K-1)..........H(2).H(1).
 *        where H(i) = I -tau(i).v(i).v(i)^T.
 *
 *        Forming H Matrix from v and propogating the results, has resulted in
 *        taking a lot of CPU. So the following logic for forming Q is
 *        implemented
 *
 *          Q(Current) =   Q(Previous) * H (Current)
 *          Equivalent to,
 *              Q(K-1) =   Q(k) * H(K-1)
 *                        Note : Q matrix will get replaced in  each iterations
 *        In each Q(k) will hold the  previous Q values as below
 *                    1 0
 *                    0 Q
 *
 *          =>   Q(k) * (I - tau(k-1) v(k-1) v(k-1)^T)
 *          =>  Q(k) - tau(k-1)  w v(k-1)^T  where
 *                                w => Q(k) v(k-1)
 *
 *       NOTE : For complex
 *    Q = H(k)^T.H(k-1)^T..........H(2)^T.H(1)^T.
 *        Transpose is applied by taking the conjugate transpose of
 *        tau.
 */
      ITER = 1;
      for (i =  MNmin-1; i >= 0 ;  i-- )
      {
/*
 *       Make Vi And take its conjugate for Complex numbers. For complex, 
 *       the conjugate value is stored in the output.
 *       In the first iteration, gets V(k)
 */

         populateViForLQ(VI, (A+((MNmin-ITER) SHIFT)), N, lda, (N-MNmin+ITER));
         printVector("VI",VI, M);

         #ifdef TREAL
               NEGTAUVAL=TAUNEG[i];
         #else
            NEGTAUVAL[0] = TAUNEG[( i SHIFT) ];
/*          Conjugate Transpose                                               */
            NEGTAUVAL[1] = 0.0 - TAUNEG[ (i SHIFT) + 1 ];
         #endif

/*
 * Q will be MxM matrix, intially populated as I matrix.
 * In each iteration Q will hold the  previous Q values as below
 *   Q 0
 *   0 1
 * Step 1
 * Q(k)*v
 */
         cblas_gemv(CblasColMajor, CblasNoTrans, (N - MNmin + ITER ), 
                    (N - MNmin + ITER ) , ONE, (Q + ((MNmin -ITER)*(ldn SHIFT))
                     + ((MNmin - ITER) SHIFT)) , ldn, VI, 1, ZEROVAL, W, 1);

/* Perform Q(k) - tau W v^T                                                   */
         #ifdef TREAL
            cblas_ger(CblasColMajor, (N - MNmin + ITER ), (N - MNmin + ITER ),
                      NEGTAUVAL, W, 1, VI, 1, (Q + ((MNmin -ITER)*(ldn SHIFT))
                      + ((MNmin - ITER) SHIFT)) , ldn );
          #else
            cblas_gerc(CblasColMajor, (N - MNmin + ITER ), (N - MNmin + ITER ),
                      NEGTAUVAL, W, 1, VI, 1, (Q + ((MNmin -ITER)*(ldn SHIFT))
                      + ((MNmin - ITER) SHIFT)), ldn );
         #endif

         printMatrix("Q", Q, N, N, ldn);
         ITER++;
      }
   #endif

/*
 * Calculate LQ  and Compare with AORIG
 * L*Q -> A
 */
   cblas_gemm(CblasColMajor, CblasNoTrans, CblasNoTrans, M  , N,
              N , ONE, L, ldm, Q, ldn, ZEROVAL, A , lda);

   printMatrix("LQ Matrix ", A, M, N, lda);


/* Get the  Norm of RQ      s A has the result                                */
   normA = Mjoin(PATL,genrm1)(M, N, AORIG, lda);

/* Find residue || A - Q*L ||  /   || A ||                                    */
   resid = Mjoin(PATL,gediffnrm1)(M, N, AORIG, lda, A, lda);
   resid /= (normA * eps * Mmin(M,N));

}//(TESTCORRECT)
   if(A) free(A);
   if(TAU) free(TAU);
   if(TAUNEG) free(TAUNEG);
   if(WORK) free(WORK);
   if(L) free(L);
   if(Q) free(Q);
   if(VI) free (VI);
   if(AORIG) free(AORIG);

   return(resid);
}

static TYPE qltest(int M, int N, int lda, int flushKB, double *time)
{
   TYPE *A, *TAU, *TAUNEG,  *WORK, *L, *W ;
   TYPE *Q, *VI;
   TYPE *AORIG;
   TYPE dtmp, dtmp1;
   double t0;

   int ITER;

   #ifdef TREAL
      TYPE NEGTAUVAL = ATL_rzero;
   #else
      TYPE NEGTAUVAL[2] = {ATL_rzero, ATL_rzero};
   #endif

   int LWORK;
   TYPE normA, eps, resid;
   int i, j, k, ldm, ldmn;
   int lda2 = lda SHIFT;

   ldm = M;
   const int MNmin = Mmin(M,N);
   ldmn = MNmin;

   eps = Mjoin(PATL,epsilon)();

/* Allocate A and initialize                                                  */
   A = GetGE(M, N, lda);
   if (A == NULL) AllocationErr("A");

if(TESTCORRECT)
{
/* Allocate A Original and copy from A                                        */
   AORIG = DupMat(CblasColMajor, M, N, A, lda, lda);
}

/* Call to get the  size of workspace required                                */
   test_geqlf(CblasColMajor, M, N, &dtmp1, lda, &dtmp1, &dtmp, -1);

/* Get Work and LWORK                                                         */
   LWORK = dtmp;
   WORK = malloc(ATL_MulBySize(LWORK));
   if (WORK == NULL) return(-1);

   TAU = malloc(ATL_MulBySize(MNmin));
   if (TAU == NULL) AllocationErr("TAU");

   if (flushKB)
   {
      t0 = ATL_flushcache(flushKB*1024);
      t0 += ATL_flushcache(-1);
   }
   t0 = time00();
   test_geqlf(CblasColMajor, M, N, (TYPE*)(A), lda, (TYPE*)(TAU),
              (TYPE*)(WORK), LWORK);
   *time = time00() - t0;
   if (flushKB)
      t0 += ATL_flushcache(0);
if(TESTCORRECT)
{
/* Allocate and Copy TAU to TAUNEG                                            */
   TAUNEG = DupMat(CblasColMajor, MNmin, 1, TAU, ldmn, ldmn);

   makeVectorToNegVal(TAUNEG, MNmin);

/* Allocate Vi, based on Size of M                                            */
   VI = malloc(ATL_MulBySize(M));
   if (VI == NULL) AllocationErr("VI");

/* Allocate Q and Q-temp,   lda equals M                                      */
   Q = malloc(ATL_MulBySize(ldm)*M);
   if (Q == NULL) AllocationErr("Q");

   W = malloc(ATL_MulBySize(ldm));
   if (W == NULL) AllocationErr("W");

   makeIdenty(Q, M, ldm);                   /* Q: Size of Q mat and lda is M  */


/* Make L Matrix  from A  and lda as M                                        */
   L = malloc(ATL_MulBySize(ldm)*N);        /* Has size [M, N]                */
   if (L == NULL) return(-1);

/*
 * Copy A[M, N] to L and then Modify the Tringular part
 * above the diagonal w.r.t bottom right diagonal
 */
   L = DupMat(CblasColMajor, M, N, A, lda, ldm);

   makeToLTForQL(L , ldm, M, N );

   printMatrix("AORIG",AORIG, M, N, lda);
   printMatrix("A",A, M, N, lda);
   printMatrix("Q ", Q, M, M, ldm);
   printMatrix("L matrix", L, M, N, ldm);
   printVector("TAU", TAU, MNmin);
   printVector("TAUNEG", TAUNEG, MNmin);

   #ifdef ATL_FULL_LAPACK
      ATL_assert(!LA_QL2Q(CblasLeft, CblasNoTrans, M, M, MNmin,
                  A+(N-MNmin)*lda2, lda, TAU, Q, ldm));
   #else
/*
 *    Form Q Matrix
 *    Q = H(K).H(K-1)..........H(2).H(1).
 *        where H(i) = I -tau(i).v(i).v(i)^T.
 *
 *        Forming H Matrix from v and propogating the results, has resulted in
 *        taking a lot of CPU. So the following logic for forming Q is
 *        implemented
 *
 *          Q(Current) =  (I - tau v v^T) * Q(Previous)
 *          Equivalent to,
 *              Q(K+1) =   H(K+1) * Q(k)
 *                        Note : Q matrix will get replaced in  each iterations
 *        In each Q(k) will hold the  previous Q values as below
 *                    Q 0
 *                    0 1
 *
 *          =>   (I - tau(k+1) v(k+1) v(k-1)^T) * Q(k)
 *          =>  Q(k) - tau(k+1)  v(k+1) w^T  where
 *                                w => Q(k)^T v(k+1)
 */
      ITER = 1;
      for (i = 0; i <  MNmin; i++)
      {
/*       Make Vi                                                              */
         populateViForQL(VI, (A+((N-MNmin+ITER-1)*lda2)), (M-MNmin+ITER));

         printVector("VI",VI, M);

         #ifdef TREAL
            NEGTAUVAL=TAUNEG[i];
         #else
            NEGTAUVAL[0] = TAUNEG[( i SHIFT) ];
            NEGTAUVAL[1] = TAUNEG[ (i SHIFT) + 1 ];
         #endif
/*
 *       Q will be MxM matrix, intially populated as I matrix.
 *       In each iteration Q will hold the  previous Q values as below
 *         Q 0
 *          0 1
 *       Step 1
 *       Q(k)^T*v
 */
         cblas_gemv(CblasColMajor, MY_TRANS, (M - MNmin + ITER ), (M - MNmin + ITER ),    
                              ONE, (Q), ldm, VI, 1, ZEROVAL, W, 1);

/* Perform Q(k) - tau W v^T                                                   */
         #ifdef TREAL
            cblas_ger(CblasColMajor, (M - MNmin + ITER ), (M - MNmin + ITER ),
                      NEGTAUVAL, VI, 1, W, 1, (Q) ,ldm);
         #else
            cblas_gerc(CblasColMajor, (M - MNmin + ITER ), (M - MNmin + ITER ),
                       NEGTAUVAL, VI, 1, W, 1, (Q),ldm);
         #endif

         printMatrix("Q", Q, M, M, ldm);
         ITER++;

      }
   #endif

/*
 * Calculate Q*R  and Compare with AORIG
 * Q*L -> A
 */
   cblas_gemm(CblasColMajor, CblasNoTrans, CblasNoTrans, M  , N,
              M , ONE, Q, ldm, L, ldm, ZEROVAL, A , lda);

   printMatrix("QL Matrix ", A, M, N, lda);

/* Get the  Norm of QL      s A has the result                                */
   normA = Mjoin(PATL,genrm1)(M, N, AORIG, lda);

/* Find residue || A - Q*L ||  /   || A ||                                    */
   resid = Mjoin(PATL,gediffnrm1)(M, N, AORIG, lda, A, lda);
   resid /= (normA * eps * Mmin(M,N));

} /*(TESTCORRECT) */
   if(A) free(A);
   if(TAU) free(TAU);
   if(TAUNEG) free(TAUNEG);
   if(WORK) free(WORK);
   if(L) free(L);
   if(Q) free(Q);
   if(VI) free (VI);
   if(AORIG) free(AORIG);


   return(resid);
}


/*
 * Calls gerq ( single, double, single complex and double complex ).
 * From A[MxN] Matrix returned from geqr routines, compute Q and R matrix.
 * Find the residual for ( A_original - RQ  ) operation.
 *
 *   Also, make H(k) = i-tau*vv'
 *   and compute Q = H(1)*H(2)...H(k)  where k = Min(M,N)
 *
 *   VI has size of N
 *
 */
static TYPE rqtest(int M, int N, int lda, int flushKB, double *time)
{
   TYPE *A, *TAU, *TAUNEG,  *WORK, *WORKF, *R, *W ;
   TYPE *Q, *VI;
   TYPE *AORIG;
   TYPE dtmp, dtmp1;
   double t0;

   int ITER;

   #ifdef TREAL
      TYPE NEGTAUVAL = ATL_rzero;
   #else
      TYPE NEGTAUVAL[2] = {ATL_rzero, ATL_rzero};
   #endif

   int LWORK;
   TYPE normA, eps, resid;
   int i, j, k, ldn, ldm, ldmn;
   int lda2 = lda SHIFT;

   ldm = M;
   ldn = N;
   const int MNmin = Mmin(M,N);
   ldmn = MNmin;

/* Epsilon                                                                    */
   eps = Mjoin(PATL,epsilon)();

/* Allocate A and initialize                                                  */
   A = GetGE(M, N, lda);
   if (A == NULL) AllocationErr("A");
if(TESTCORRECT)
{
/* Allocate A Original and copy from A                                        */
   AORIG = DupMat(CblasColMajor, M, N, A, lda, lda);
}

/* Call to get the  size of workspace required                                */
   test_gerqf(CblasColMajor, M, N, &dtmp1, lda, &dtmp1, &dtmp, -1);

/* Get Work and LWORK                                                         */
   LWORK = dtmp;
   WORK = malloc(ATL_MulBySize(LWORK));
   if (WORK == NULL) return(-1);

   TAU = malloc(ATL_MulBySize(MNmin));
   if (TAU == NULL) AllocationErr("TAU");

   if (flushKB)
   {
      t0 = ATL_flushcache(flushKB*1024);
      t0 += ATL_flushcache(-1);
   }
   t0 = time00();
   test_gerqf(CblasColMajor, M, N, (TYPE*)(A), lda, (TYPE*)(TAU),
              (TYPE*)(WORK), LWORK);
   *time = time00() - t0;
   if (flushKB)
      t0 += ATL_flushcache(0);
if(TESTCORRECT)
{
/* Allocate and Copy TAU to TAUNEG                                            */
   TAUNEG = DupMat(CblasColMajor, MNmin, 1, TAU, ldmn, ldmn);

   makeVectorToNegVal(TAUNEG, MNmin);

/* Allocate Vi, based on Size of N                                            */
   VI = malloc(ATL_MulBySize(N));
   if (VI == NULL) AllocationErr("VI");

/* Allocate Q and Q-temp,   lda equals N                                      */
   Q = malloc(ATL_MulBySize(ldn)*N);
   if (Q == NULL) AllocationErr("Q");

   W = malloc(ATL_MulBySize(N));
   if (Q == NULL) AllocationErr("W");

   makeIdenty(Q, N, ldn);                   /* Q: Size of Q mat and lda is N  */

/* Copy A[M, N] to R and then Modify the Lower part of DIAG                   */
   R = DupMat(CblasColMajor, M, N, A, lda, ldm);
   makeToUTForRQ(R , ldm, M, N );

   printMatrix("AORIG",AORIG, M, N, lda);
   printMatrix("A",A, M, N, lda);
   printMatrix("Q MARTIX ", Q, N, N, ldn);
   printMatrix("R matrix", R, M, N, ldm);
   printVector("TAU", TAU, MNmin);
   printVector("TAUNEG", TAUNEG, MNmin);

   #ifdef ATL_FULL_LAPACK
      ATL_assert(!LA_RQ2Q(CblasRight, CblasNoTrans, N, N, MNmin,
                          A+((M-MNmin)SHIFT), lda, TAU, Q, ldn));
   #else
/*     Form Q Matrix
 *     Q = H(1).H(2)..........H(k-1).H(k).
 *         where H(i) = I -tau(i).v(i).v(i)^T.
 *
 *         Forming H Matrix from v and propogating the results, has resulted in
 *         taking a lot of CPU. So the following logic for forming Q is
 *         implemented
 *
 *           Q(Current) = (Q(previous)* I - tau v v^T)
 *           Equivalent to,
 *               Q(K+1) =   Q(k) * H(K+1)
 *                         Note : Q matrix will get replaced in  each iterations
 *         In each Q(k) will hold the  previous Q values as below
 *                     Q 0
 *                     0 1
 *
 *           =>  Q(k) * (I - tau(k+1) v(k+1) v(k-1)^T)
 *           =>  Q(k) - tau(k+1)  w   v(k+1)^T  where
 *                                 w => Q(k) v(k+1)
 *
 *
 *        NOTE : For complex
 *         Q = H(1)^T.H(2)^T..........H(k-1)^T.H(k)^T.
 *         Transpose is applied by taking the conjugate transpose of
 *         tau.
 */

      ITER = 1;

      for (i = 0  ; i < MNmin ; i++)
      {
/*
 *       Make Vi And take its conjugate for Complex numbers. For complex, 
 *       the conjugate value is stored in the output.
 */
         populateViForRQ(VI,(A+((M-MNmin+ITER-1) SHIFT)), lda, (N-MNmin+ITER));
         printVector("VI______________ ",VI, N);

         #ifdef TREAL
            NEGTAUVAL=TAUNEG[i];
         #else
            NEGTAUVAL[0] = TAUNEG[(i SHIFT) ];
/*          Conjugate Transpose                                               */
            NEGTAUVAL[1] = 0.0 - TAUNEG[(i SHIFT) + 1 ];
         #endif
/*
 * Q will be MxM matrix, intially populated as I matrix.
 * In each iteration Q will hold the  previous Q values as below
 *   Q 0
 *   0 1
 *
 * Step 1
 * Q(k)*v
 */
         cblas_gemv(CblasColMajor, CblasNoTrans, (N - MNmin + ITER ) , 
                    (N - MNmin + ITER ), ONE, (Q), ldn, VI, 1,
                    ZEROVAL, W, 1);

/*       Perform Q(k) - tau W v^T                                             */
         #ifdef TREAL
            cblas_ger(CblasColMajor, (N - MNmin + ITER ), (N - MNmin + ITER ),
                      NEGTAUVAL, W, 1, VI, 1, (Q) ,ldn);
         #else
            cblas_gerc(CblasColMajor, (N - MNmin + ITER ), (N - MNmin + ITER ),
                       NEGTAUVAL, W, 1, VI, 1, (Q),ldn);
         #endif

         printMatrix("Q ", Q, N, N, ldn);
         ITER++;
      }
   #endif
/*
 * Calculate Q*R  and Compare with AORIG
 * R*Q -> A
 */
   cblas_gemm(CblasColMajor, CblasNoTrans, CblasNoTrans, M  , N,
              N, ONE, R, ldm, Q, ldn, ZEROVAL, A , lda);

   printMatrix("RQ Matrix ", A, M, N, lda);

/* Get the  Norm of RQ      s A has the result                                */
   normA = Mjoin(PATL,genrm1)(M, N, AORIG, lda);

/* Find residue || A - R*Q ||  /   || A ||                                    */
   resid = Mjoin(PATL,gediffnrm1)(M, N, AORIG, lda, A, lda);
   resid /= (normA * eps * Mmin(M,N));

}/*(TESTCORRECT) */
   if(A) free(A);
   if(TAU) free(TAU);
   if(TAUNEG) free(TAUNEG);
   if(WORK) free(WORK);
   if(R) free(R);
   if(Q) free(Q);
   if(VI)  free (VI);
   if(AORIG) free(AORIG);

   return(resid);
}

/*
 * Calls geqr ( single, double, single complex and double complex ).
 * From A[MxN] Matrix returned from geqr routines, compute Q and R matrix.
 * Find the residual for ( A_original - QR  ) operation.
 *
 *   Also, make H(k) = i-tau*vv'
 *   and compute Q = H(1)*H(2)...H(k)  where k = Min(M,N)
 *
 */
TYPE qrtest(int M, int N, int lda, int flushKB, double *time)
{
   TYPE *A, *TAU, *TAUNEG,  *WORK, *WORKF,  *R , *W ;
   TYPE *Q, *VI;
   TYPE *AORIG ;
   TYPE  dtmp, dtmp1;
   double t0;

   int ITER;

   #ifdef TREAL
      TYPE NEGTAUVAL = ATL_rzero;
      TYPE AII ;
   #else
      TYPE NEGTAUVAL[2] = {ATL_rzero, ATL_rzero};
      TYPE AII[2] ;
   #endif


   int LWORK;
   TYPE normA, eps, resid;
   int i, j, k, ldm, ldmn ;
   int lda2 = lda SHIFT;

   ldm = M;
   const int MNmin = Mmin(M,N);
   ldmn = MNmin;

/* Epsilon                                                                    */
   eps = Mjoin(PATL,epsilon)();

/* Allocate A and initialize                                                  */
   A = GetGE(M, N, lda);
   if (A == NULL) AllocationErr("A");

   printMatrix("AORIG from A ", A, M, N, lda);
if(TESTCORRECT)
{
/* Allocate A Original and copy from A                                        */
   AORIG = DupMat(CblasColMajor, M, N, A, lda, lda);
}
   test_geqrf(CblasColMajor, M, N, &dtmp1, lda, &dtmp1, &dtmp, -1);
   LWORK = dtmp;

   WORK = malloc(ATL_MulBySize(LWORK));
   if (WORK == NULL) return(-1);

   TAU = malloc(ATL_MulBySize(MNmin));
   if (TAU == NULL) AllocationErr("TAU");

   if (flushKB)
   {
      t0 = ATL_flushcache(flushKB*1024);
      t0 += ATL_flushcache(-1);
   }
   t0 = time00();
   test_geqrf(CblasColMajor, M, N, (TYPE*)(A), lda,
               (TYPE*)(TAU), (TYPE*)(WORK), LWORK);
   *time = time00() - t0;
   if (flushKB)
      t0 += ATL_flushcache(0);
if(TESTCORRECT)
{
/* Allocate and Copy TAU to TAUNEG                                            */
   TAUNEG = DupMat(CblasColMajor, MNmin, 1, TAU, ldmn, ldmn);

   makeVectorToNegVal(TAUNEG, MNmin);

/* Allocate Q and Q-Temp,   lda equals M(ldm)                                 */
   Q = malloc(ATL_MulBySize(ldm)*M);
   if (Q == NULL) AllocationErr("Q");

   W = malloc(ATL_MulBySize(M));
   if (W == NULL) AllocationErr("W");

   makeIdenty(Q, M, ldm);         

/*
 * Copy A[M, N of lda] to R[M, N od ldm] and then make the elements
 * below diagonals as zero
 */
   R = DupMat(CblasColMajor, M, N, A, lda, ldm);
   makeToUTForQR(R , ldm, M,N);

   printMatrix("AORIG", AORIG, M, N, lda);
   printMatrix("A", A, M, N, lda);
   printMatrix("Q", Q, M, M, ldm);
   printMatrix("R", R, M, N, ldm);
   printVector("TAU", TAU, MNmin);
   printVector("TAUNEG", TAUNEG, MNmin);

   #ifdef ATL_FULL_LAPACK
      ATL_assert(!LA_QR2Q(CblasLeft, CblasNoTrans, M, M, MNmin, A, lda, TAU,
                          Q, ldm));
   #else
/*    Form Q Matrix
 *    Q = H(1).H(2)..........H(k-1).H(k).
 *        where H(i) = I -tau(i).v(i).v(i)^T.
 *
 *        Forming H Matrix from v and propogating the results, has resulted in
 *        taking a lot of CPU. So the following logic for forming Q is
 *        implemented
 *
 *          Q(Current) = (I - tau v v^T)*Q(previous)
 *          Equivalent to,
 *              Q(K-1) =  ( H(k-1))* Q(k)
 *                        Note : Q matrix will get replaced in  each iterations
 *          =>  (I - tau(k-1) v(k-1) v(k-1)^T) Q(k)
 *          =>  Q(k) - tau(k-1) w v(k+1)^T where
 *                                w => Q(k)^T v(k-1)
 */

/*    Make diagonal element of A, which  holds VI to 1.0                      */
      for (i = 0; i < MNmin; i++)
      {
         #ifdef TREAL
            *(A  + i*lda + i ) = 1.0;
         #else
            *(A  + (i * ( lda SHIFT)) + ( i SHIFT))   = 1.0;
            *(A  + (i * ( lda SHIFT)) + ( i SHIFT ) + 1) = 0.0;
         #endif
      }

      ITER = 1;
      for (i =( MNmin - 1); i >= 0; i--)

      {

/*       Point Vi to  A(diagonal element )                                    */
         VI = (A + (i*(lda SHIFT)) + ( i SHIFT)); 

         #ifdef TREAL
            NEGTAUVAL=TAUNEG[i];
         #else
            NEGTAUVAL[0] = TAUNEG[(i SHIFT) ];
            NEGTAUVAL[1] = TAUNEG[ (i SHIFT) + 1 ];
         #endif

/*
 * Q will be MxM matrix, intially populated as I matrix.
 * In each Q will hold the  previous Q values as below
 *  1 0
 *  0 Q
 */

/*
 * Step 1.
 * Q(k)^T*v
 */
         cblas_gemv(CblasColMajor, MY_TRANS, (M - MNmin + ITER ) ,
                    (M - MNmin + ITER ), ONE, (Q + ((MNmin - ITER)*(ldm SHIFT))
                    +( (MNmin - ITER) SHIFT )), ldm, VI, 1, ZEROVAL, W, 1);

/*       Perform Q(k) - tau v W^T                                             */
         #ifdef TREAL
            cblas_ger(CblasColMajor, (M - MNmin + ITER ), (M - MNmin + ITER ),
                      NEGTAUVAL, VI, 1, W, 1, (Q + ((MNmin - ITER)*(ldm SHIFT))
                                 +( (MNmin - ITER) SHIFT )) ,ldm);
         #else
            cblas_gerc(CblasColMajor, (M - MNmin + ITER ), (M - MNmin + ITER ),
                      NEGTAUVAL, VI, 1, W, 1, (Q + ((MNmin - ITER)*(ldm SHIFT))
                                 +( (MNmin - ITER) SHIFT )) ,ldm);
         #endif

         printMatrix("Q", Q, M, M, ldm);
         ITER++;
      }
   #endif

/*
 * Calculate Q*R  and Compare with AORIG
 * Q*R -> A       Reuse A space
 */

   cblas_gemm(CblasColMajor, CblasNoTrans, CblasNoTrans, M  , N,
              M , ONE, Q, ldm, R, ldm, ZEROVAL, A , lda);

   printMatrix("QR  A matrix", A, M, N, lda);

/* Get the  Norm of QR      as A has the result                               */
   normA = Mjoin(PATL,genrm1)(M, N, AORIG, lda);

/* Find residue || A - Q*R ||  /   || A ||                                    */
   resid = Mjoin(PATL,gediffnrm1)(M, N, AORIG, lda, A, lda);
   resid /= (normA * eps * Mmin(M,N));

} /*(TESTCORRECT) */
   if (A)   free(A);
   if (TAU) free(TAU);
   if (TAUNEG)   free(TAUNEG);
   if (WORK)  free(WORK);
   if (R)   free(R);
   if (Q)   free(Q);
   if (W)   free(W);
   if (AORIG)  free(AORIG);

   return(resid);
}

@beginskip
char *RoutInt2Str2(int rout)
/*
 * returns 2-char abbreviation for LAPACK householder routine rout
 */
{
   char *sp = "QR";
   if (rout == LAgeqlf)
      sp = "QL";
   else if (rout == LAgerqf)
      sp = "RQ";
   else if (rout == LAgelqf)
      sp = "LQ";
   return(sp);
}
@endskip

int GetMyReps(int N, int *nreps)
/*
 * Finds the correct nreps for this N
 */
{
   int n, i;

   n = *nreps++;
   for (i=n+n-2; i>=0; i -= 2)
   {
      if (N >= nreps[i])
         return(nreps[i+1]);
   }
   return(nreps[1]);
}

int RunCase(TYPE thresh, int flushKB, int side, int uplo, int M, int N, int lda)
/*
 * RETURNS: 0 if residual is <= thresh, otherwise 1
 */
{
   TYPE resid;
   TYPE (*qtest)(int, int, int, int, double*);
   double time;
   double Time2Flops(int rout, int UPLO, int M, int N, double time);
   char qs[4];

   qs[2] = '\0';
   if (side == LARight)
   {
      qs[0] = 'Q';
      if (uplo == LALower) { qtest = qltest; qs[1] = 'L'; }
      else { qtest = qrtest; qs[1] = 'R'; }
   }
   else
   {
      qs[1] = 'Q';
      if (uplo == LALower) { qtest = lqtest; qs[0] = 'L'; }
      else { qtest = rqtest; qs[0] = 'R'; }
   }
   resid = qtest(M, N, lda, flushKB, &time);
   printf("%2s  %3s %6d %6d %6d  %10.4e %11.2f  %9.2e\n", qs, "Col", M, N, lda,
         time, Time2Flops(LAgeqrf, uplo+side, M, N, time), resid);
   /* A temporary fix */
   if(resid == 0. && M > 10 && N > 10)  resid = 99999999; // Setting to a big num 
   return(resid <= thresh ? 1 : 0);
}

int RunCases(TYPE thresh, int flushKB, int ldagap, int *NREPS,
            int *sides, int *uplos, int *Ms, int *Ns)
/*
 * RETURNS: number of failed cases
 */
{
   int u, s, o, m, n, M, lda, npass=0, ntest=0, nreps, k;
   printf("Rt  Maj      M      N    lda        TIME       MFLOP   RESIDUAL\n");
   printf("==  ===  =====  =====  =====  ==========  ==========  =========\n");

   for (s=1; s <= sides[0]; s++)            /* loop over sides                */
   {
      for (u=1; u <= uplos[0]; u++)         /* loop over uplos                */
      {
         for (o=0; o < 1; o++)              /* useless order loop, add later  */
         {
            for (n=1; n <= Ns[0]; n++)
            {
               for (m=1; m <= Ms[0]; m++)
               {
                  M = (Ms[m]) ? Ms[m]:Ns[n];
                  nreps = GetMyReps(Mmin(M, Ns[n]), NREPS);
                  for (k=0; k < nreps; k++)
                  {
                     npass += RunCase(thresh, flushKB, sides[s], uplos[u],
                                       M, Ns[n], M+ldagap);
                     ntest++;
                  }
               }
            }
         }
      }
   }
   if (ntest == npass)
      printf("\n%d cases ran, %d cases passed\n\n", ntest, npass);
   else
      printf("\n%d cases ran, %d cases failed, %d cases passed\n\n", ntest,
             ntest-npass, npass);
             
   return(ntest-npass);
}

#define CAN_NB 0
@extract -b @(topd)/Clint/atlas-tlp.base rout=qrtstGF

int main(int nargs, char **args)
{
   int *Ns, *Ms, *nreps, *UPLOs, *SDs; 
   int flushKB, ldagap;
   TYPE thresh;

   GetFlags(nargs, args, &flushKB, &thresh, &nreps, &ldagap, &Ms, &Ns, 
            &UPLOs, &SDs);
   return(RunCases(thresh, flushKB, ldagap, nreps, SDs, UPLOs, Ms, Ns));
}



@ROUT ATL_ormqr
@extract -b @(topd)/cw.inc lang=C -def cwdate 2009 -def cwauth "Siju Samuel" -def contrib "Anthony M. Castaldo, R. Clint Whaley"

#include "stdio.h"
#include "cblas.h"
#include "atlas_lapack.h"

#ifdef  SREAL
     #define MYOPT LASreal
#endif
#ifdef  DREAL
    #define MYOPT  LADreal
#endif
#ifdef  SCPLX
    #define MYOPT  LAScplx
#endif
#ifdef  DCPLX
    #define MYOPT  LADcplx
#endif

int ATL_ormqr
   (const enum CBLAS_SIDE SIDE, const enum CBLAS_TRANSPOSE TRANS, 
    ATL_CINT M, ATL_CINT N, ATL_CINT K, TYPE *A, ATL_CINT lda, 
    const TYPE *TAU, TYPE *C, ATL_CINT ldc, TYPE *WORK, ATL_CINT LWORK) 
/*
 * This is the C translation of the standard LAPACK Fortran routine:
 *      SUBROUTINE ATL_ormqr( SIDE, TRANS, M, N, K, A, LDA, TAU, C, LDC,
 *                        WORK, LWORK, INFO )
 *
 * ATL_ormqr.c :
 * int ATL_ormqr(const enum CBLAS_SIDE SIDE SIDE,
 *        const enum CBLAS_TRANSPOSE TRANS, ATL_CINT M, ATL_CINT N,
 *        ATL_CINT K, TYPE * A, ATL_CINT lda,TYPE * TAU, TYPE * C, ATL_CINT ldc,
 *                       TYPE * WORK, ATL_CINT LWORK)
 *
 *      NOTE :   ATL_ormqr.c will get compiled to four precisions
 *               single precision real,      double precision real
 *               single precision complex,   double precision complex
 *
 *
 *
 *  Purpose
 *  =======
 *
 *  ATL_ormqr overwrites the general real M-by-N matrix C with
 *
 *                  SIDE = 'L'     SIDE = 'R'
 *  TRANS = 'N':      Q * C          C * Q
 *  TRANS = 'T':      Q**T * C       C * Q**T
 *
 *  where Q is,
 *        a real orthogonal matrix defined as the product of k
 *        elementary reflectors
 *
 *        Q = H(1) H(2) . . . H(k)
 *
 *   OR
 *        a complex unitary matrix defined as a product of k
 *        elementary reflectors
 *
 *        Q = H(1) H(2) . . . H(k)
 *
 *  as returned by ATLL_geqrf.c. Q is of order M if SIDE = 'L' and of order N
 *  if SIDE = 'R'.
 *
 *  Arguments
 *  =========
 *
 *  SIDE    (input) CHARACTER*1
 *          = 'L': apply Q or Q**T from the Left;
 *          = 'R': apply Q or Q**T from the Right.
 *
 *  TRANS   (input) CHARACTER*1
 *          = 'N':  No transpose, apply Q;
 *          = 'T':  Transpose, apply Q**T.
 *
 *  M       (input) INTEGER
 *          The number of rows of the matrix C. M >= 0.
 *
 *  N       (input) INTEGER
 *          The number of columns of the matrix C. N >= 0.
 *
 *  K       (input) INTEGER
 *          The number of elementary reflectors whose product defines
 *          the matrix Q.
 *          If SIDE = 'L', M >= K >= 0;
 *          if SIDE = 'R', N >= K >= 0.
 *
 *  A       (input) array, dimension (LDA,K)
 *          The i-th column must contain the vector which defines the
 *          elementary reflector H(i), for i = 1,2,...,k, as returned by
 *          DGEQRF in the first k columns of its array argument A.
 *          A is modified by the routine but restored on exit.
 *
 *  lda     (input) INTEGER
 *          The leading dimension of the array A.
 *          If SIDE = 'L', LDA >= max(1,M);
 *          if SIDE = 'R', LDA >= max(1,N).
 *
 *  TAU     (input)  array, dimension (K)
 *          TAU(i) must contain the scalar factor of the elementary
 *          reflector H(i), as returned by ATL_geqrf.c.
 *
 *  C       (input/output)  array, dimension (LDC,N)
 *          On entry, the M-by-N matrix C.
 *          On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.
 *
 *  ldc     (input) INTEGER
 *          The leading dimension of the array C. LDC >= max(1,M).
 *
 *  WORK    (workspace/output) array, dimension (MAX(1,LWORK))
 *          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
 *
 *  LWORK   (input) INTEGER
 *          The dimension of the array WORK.
 *          If SIDE = 'L', LWORK >= max(1,N);
 *          if SIDE = 'R', LWORK >= max(1,M).
 *          For optimum performance LWORK >= N*NB if SIDE = 'L', and
 *          LWORK >= M*NB if SIDE = 'R', where NB is the optimal
 *          blocksize.
 *
 *          If LWORK = -1, then a workspace query is assumed; the routine
 *          only calculates the optimal size of the WORK array, returns
 *          this value as the first entry of the WORK array, and no error
 *          message related to LWORK is issued by XERBLA.
 *
 *  INFO    (output) INTEGER
 *          = 0:  successful exit
 *          < 0:  if INFO = -i, the i-th argument had an illegal value
 */
{
   ATL_CINT minMN = Mmin(M, N), maxMN = Mmax(M, N);
   ATL_INT n, nb, j, ib, mi, ni, ic, jc ;
   TYPE  *ws_QR2,  *ws_T, *ws_larfb;        /* Workspace for QR2,T, larfb     */
   void *vp=NULL;

   nb = clapack_ilaenv(LAIS_OPT_NB, LAormqr, MYOPT+LARight+LAUpper, M, N, K,-1);

/*
 * If it is a workspace query, return the size of work required.
 *    wrksz = wrksz of ATL_larfb + ATL_larft + ATL_geqr2
 */
   if (LWORK < 0)
   {
      if(SIDE == CblasLeft)
      {
         *WORK = ( N*nb + nb*nb + maxMN )  ;
      }
      else
      {
         *WORK = ( M*nb + nb*nb + maxMN )  ;
      }
      return(0);
   }
   else if (M < 1 || N < 1)                 /* quick return if no work to do  */
      return(0);
/*
 * If the user gives us too little space, see if we can allocate it ourselves
 */
   else 
   {
      if(SIDE == CblasLeft)
      {
         if (LWORK < (N*nb + nb*nb + maxMN))
         {
            vp = malloc(ATL_MulBySize(N*nb + nb*nb + maxMN) + ATL_Cachelen);
            if (!vp)
               return(-7);
            WORK = ATL_AlignPtr(vp);
         }
      }
      else 
      {
         if (LWORK < (M*nb + nb*nb + maxMN))
         {
            vp = malloc(ATL_MulBySize(M*nb + nb*nb + maxMN) + ATL_Cachelen);
            if (!vp)
               return(-7);
            WORK = ATL_AlignPtr(vp);
         }
      } /* if CblasRight */
   }

/*
 * Assign workspace areas for ATL_larft, ATL_geqr2, ATL_larfb
 */
  
   ws_T = WORK;                             /* T at begining of work          */
   ws_QR2 = WORK +(nb SHIFT)*nb;            /* After T Work space             */
   ws_larfb = ws_QR2 + (maxMN SHIFT);       /* After workspace for T and QR2  */


   if (SIDE == CblasLeft)
   {
      if ( TRANS == CblasNoTrans )
      {
         j = (K/nb)*nb;
         if (j == K)
         {
            j=K -nb;
         }         
 	 for (j; j >= 0; j = j - nb)
         {  
            ib = nb;
            if ((j+nb) > K)
            {
               ib = K - j;          
            }
/*
 *          Form the triangular factor of the block reflector
 *          H = H(i) H(i+1) . . . H(i+ib-1)
 */
            ATL_larft(LAForward, LAColumnStore, M-j, ib, A+(j SHIFT)*(lda+1),
                      lda, TAU+(j SHIFT), ws_T, ib);
/*
 *          H or H' is applied to C(i:m,1:n)
 */
            ATL_larfb(SIDE, TRANS, LAForward, LAColumnStore,
                      (M-j), N, ib, A+(j SHIFT)*(lda+1), lda, ws_T, ib,
                      C+(j SHIFT), ldc, ws_larfb, N);
          }                                 /* for                            */
      }                                     /* CblasNoTrans                   */
      else 
      {
         for (j = 0 ; j < K; j = j + nb)
         {  
            ib = Mmin(K-j, nb);
/*
 *          Form the triangular factor of the block reflector
 *          H = H(i) H(i+1) . . . H(i+ib-1)
 */
            ATL_larft(LAForward, LAColumnStore, M-j, ib, A+(j SHIFT)*(lda+1),
                      lda, TAU+(j SHIFT), ws_T, ib);
/*
 *          H or H' is applied to C(i:m,1:n)
 */
            ATL_larfb(SIDE, TRANS, LAForward, LAColumnStore,
                      (M-j), N, ib, A+(j SHIFT)*(lda+1), lda, ws_T, ib,
                      C+(j SHIFT), ldc, ws_larfb, N);
         }                                  /* for                            */
      }                                     /* CblasNoTran                    */
   }                                        /* cblasLeft                      */
   else 
   {
      if ( TRANS == CblasNoTrans )
      {
 	 for (j = 0 ; j < K; j = j + nb)
         {  
            ib = Mmin(K-j, nb);
/*
 *          Form the triangular factor of the block reflector
 *          H = H(i) H(i+1) . . . H(i+ib-1)
 */
            ATL_larft(LAForward, LAColumnStore, N-j, ib, A+(j SHIFT)*(lda+1), 
                      lda, TAU+(j SHIFT), ws_T, ib);
/*
 *              H or H' is applied to C(1:m,i:n)
 */
            ATL_larfb(SIDE, TRANS, LAForward, LAColumnStore,
                      M, N-j, ib, A+(j SHIFT)*(lda+1), lda, ws_T, ib,
                      C+((j SHIFT)*ldc), ldc, ws_larfb, M);
          }                                 /* for                            */
      }
      else 
      {
         j = (K/nb)*nb;
         if (j == K)
         {
            j=K -nb;
         }         
 	 for (j; j >= 0; j = j - nb)
         {  
 
            ib = nb;
            if ((j+nb) > K)
            {
               ib = K - j;          
            }
/*
 *          Form the triangular factor of the block reflector
 *          H = H(i) H(i+1) . . . H(i+ib-1)
 */
            ATL_larft(LAForward, LAColumnStore, N-j, ib, A+(j SHIFT)*(lda+1), 
                      lda, TAU+(j SHIFT), ws_T, ib);
/*
 *              H or H' is applied to C(1:m,i:n)
 */
 
            ATL_larfb(SIDE, TRANS, LAForward, LAColumnStore,
                      M, N-j , ib, A+(j SHIFT)*(lda+1), lda, ws_T, ib,
                      C+((j SHIFT)*ldc) , ldc, ws_larfb, M);
         }                                  /* for                            */
               
      }                                     /* Cblas Tran on Right            */
   }
   
   if (vp)
      free(vp);
   return(0);
}                                           /* END ATL_ormqr                  */


@ROUT ATL_ormrq
#include "stdio.h"
#include "cblas.h"
#include "atlas_lapack.h"

#ifdef  SREAL
   #define MYOPT LASreal
#endif
#ifdef  DREAL
   #define MYOPT  LADreal
#endif
#ifdef  SCPLX
   #define MYOPT  LAScplx
#endif
#ifdef  DCPLX
   #define MYOPT  LADcplx
#endif

int ATL_ormrq
   (const enum CBLAS_SIDE SIDE, const enum CBLAS_TRANSPOSE TRANS, 
    ATL_CINT M, ATL_CINT N, ATL_CINT K, TYPE *A, ATL_CINT lda, const TYPE *TAU,
    TYPE *C, ATL_CINT ldc, TYPE *WORK, ATL_CINT LWORK) 
/*-----------------------------------------------------------------------------
 * This is the C translation of the standard LAPACK Fortran routine:
 *      SUBROUTINE DORMRQ( SIDE, TRANS, M, N, K, A, LDA, TAU, C, LDC,
 *                        WORK, LWORK, INFO )
 *
 * ATL_ormrq.c :
 * int ATL_ormrq(const enum CBLAS_SIDE SIDE SIDE,
 *        const enum CBLAS_TRANSPOSE TRANS, ATL_CINT M, ATL_CINT N,
 *        ATL_CINT K, TYPE * A, ATL_CINT lda,TYPE * TAU, TYPE * C, ATL_CINT ldc,
 *                       TYPE * WORK, ATL_CINT LWORK)
 *
 *      NOTE :   ATL_ormrq.c will get compiled to four precisions
 *               single precision real,      double precision real
 *               single precision complex,   double precision complex
 *
 *
 *  Purpose
 *  =======
 *
 *  ATL_ormrq overwrites the general real M-by-N matrix C with
 *
 *                  SIDE = 'L'     SIDE = 'R'
 *  TRANS = 'N':      Q * C          C * Q
 *  TRANS = 'T':      Q**T * C       C * Q**T
 *
 *  where Q is,
 *        a real orthogonal matrix defined as the product of k
 *        elementary reflectors
 *
 *        Q =  Q = H(1) H(2) . . . H(k)
 *
 *   OR
 *        a complex unitary matrix defined as a product of k
 *        elementary reflectors
 *
 *        Q =  Q = H(1) H(2) . . . H(k)
 *
 *  as returned by ATL_gerqf.c. Q is of order M if SIDE = 'L' and of order N
 *  if SIDE = 'R'.
 *
 *  Arguments
 *  =========
 *
 *  SIDE    (input) CHARACTER*1
 *          = 'L': apply Q or Q**T from the Left;
 *          = 'R': apply Q or Q**T from the Right.
 *
 *  TRANS   (input) CHARACTER*1
 *          = 'N':  No transpose, apply Q;
 *          = 'T':  Transpose, apply Q**T.
 *
 *  M       (input) INTEGER
 *          The number of rows of the matrix C. M >= 0.
 *
 *  N       (input) INTEGER
 *          The number of columns of the matrix C. N >= 0.
 *
 *  K       (input) INTEGER
 *          The number of elementary reflectors whose product defines
 *          the matrix Q.
 *          If SIDE = 'L', M >= K >= 0;
 *          if SIDE = 'R', N >= K >= 0.
 *
 *  A       (input) array, dimension
 *                               (LDA,M) if SIDE = 'L',
 *                               (LDA,N) if SIDE = 'R'
 *          The i-th row must contain the vector which defines the
 *          elementary reflector H(i), for i = 1,2,...,k, as returned by
 *          ATL_gerqf in the last k rows of its array argument A.
 *          A is modified by the routine but restored on exit.
 *
 *  LDA     (input) INTEGER
 *          The leading dimension of the array A. LDA >= max(1,K).
 *
 *  TAU     (input) array, dimension (K)
 *          TAU(i) must contain the scalar factor of the elementary
 *          reflector H(i), as returned by ATL_gerqf.
 *
 *  C       (input/output) array, dimension (LDC,N)
 *          On entry, the M-by-N matrix C.
 *          On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.
 *
 *  LDC     (input) INTEGER
 *          The leading dimension of the array C. LDC >= max(1,M).
 *
 *  WORK    (workspace/output) array, dimension (MAX(1,LWORK))
 *          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
 *
 *  LWORK   (input) INTEGER
 *          The dimension of the array WORK.
 *          If SIDE = 'L', LWORK >= max(1,N);
 *          if SIDE = 'R', LWORK >= max(1,M).
 *          For optimum performance LWORK >= N*NB if SIDE = 'L', and
 *          LWORK >= M*NB if SIDE = 'R', where NB is the optimal
 *          blocksize.
 *
 *          If LWORK = -1, then a workspace query is assumed; the routine
 *          only calculates the optimal size of the WORK array, returns
 *          this value as the first entry of the WORK array, and no error
 *          message related to LWORK is issued by XERBLA.
 *
 *  INFO    (output) INTEGER
 *          = 0:  successful exit
 *          < 0:  if INFO = -i, the i-th argument had an illegal value
 *----------------------------------------------------------------------------*/
{
   ATL_CINT minMN = Mmin(M, N), maxMN = Mmax(M, N);
   ATL_INT n, nb, j, ib, mi, ni, ic, jc, compK ;
   TYPE  *ws_RQ2,  *ws_T, *ws_larfb;        /* Workspace for QR2,T, larfb     */
   void *vp=NULL;
   
   enum CBLAS_TRANSPOSE  TRANST;

   nb = clapack_ilaenv(LAIS_OPT_NB, LAormqr, MYOPT+LALeft+LAUpper, M, N,K,-1);

/*
 *  If it is a workspace query, return the size of work required.
 *    wrksz = wrksz of ATL_larfb + ATL_larft + ATL_geqr2
 */
   if (LWORK < 0)
   {
      if(SIDE == CblasLeft)
      {
         *WORK = ( maxMN*nb + nb*nb + maxMN )  ;
      }
      else
      {
         *WORK = ( maxMN*nb + nb*nb + maxMN )  ;
      }
      return(0);
   }
   else if (M < 1 || N < 1)                 /* quick return if no work to do  */
      return(0);
/*
 * If the user gives us too little space, see if we can allocate it ourselves
 */
   else 
   {
      if(SIDE == CblasLeft)
      {
         if (LWORK < (maxMN*nb + nb*nb + maxMN))
         {
            vp = malloc(ATL_MulBySize(maxMN*nb + nb*nb + maxMN) + ATL_Cachelen);
            if (!vp)
               return(-7);
            WORK = ATL_AlignPtr(vp);
         }
      }
      else 
      {
         if (LWORK < (maxMN*nb + nb*nb + maxMN))
         {
            vp = malloc(ATL_MulBySize(maxMN*nb + nb*nb + maxMN) + ATL_Cachelen);
            if (!vp)
               return(-7);
            WORK = ATL_AlignPtr(vp);
        }
      }                                     /* if CblasRight                  */
   }                                        /* if else                        */

/*
 * Assign workspace areas for ATL_larft, ATL_geql2, ATL_larfb
 */
  
   ws_T = WORK;                             /* T at begining of work          */
   ws_RQ2 = WORK +(nb SHIFT)*nb;            /* After T Work space             */
   ws_larfb = ws_RQ2 + (maxMN SHIFT);       /* After workspace for T and QR2  */

   if (TRANS == CblasNoTrans)
   {
      TRANST = CblasTrans;    
   } else
   {
      TRANST = CblasNoTrans;
   }

   if (SIDE == CblasRight)
   {
      if (TRANS == CblasNoTrans)
      {
         for (j=0 ; j < K ; j = j + nb) 
         {
            ib = Mmin(K-j,nb);
/*
 *           Form the triangular factor of the block reflector
 *           H = H(i+ib-1) . . . H(i+1) H(i)
 */
            ATL_larft(LABackward, LARowStore, N-K+j+ib, ib,
                      A+(j SHIFT) , lda, TAU+(j SHIFT), ws_T, ib);

            ni = N - K + j +ib;

/*              H or H' is applied to C(1:m,1:n-k+i+ib-1)                     */

            ATL_larfb(SIDE, TRANST, LABackward, LARowStore,
                      M, ni, ib, A+(j SHIFT), lda, ws_T, ib,      
                      C, ldc, ws_larfb, M);
         }
      }                                     /* CblasNoTrans on Right          */
      else 
      {
         j = (K/nb)*nb;
         if (j == K)
         {
            j=K -nb;
         }
         for (j; j >= 0; j = j - nb)
         {
            ib = nb;
            if ((j+nb) > K)
            {
               ib = K - j;
            }

/*
 *           Form the triangular factor of the block reflector
 *           H = H(i+ib-1) . . . H(i+1) H(i)
 */
            ATL_larft(LABackward, LARowStore, N-K+j+ib, ib,
                      A+(j SHIFT) , lda, TAU+(j SHIFT),      
                                   ws_T, ib);
            ni = N - K + j +ib;
            
/*              H or H' is applied to C(1:m,1:n-k+i+ib-1)                     */

            ATL_larfb(SIDE, TRANST, LABackward, LARowStore,
                      M, ni, ib, A+(j SHIFT), lda, ws_T, ib,      
                      C, ldc, ws_larfb, M);
         }                                  /* for                            */
      }
   }                                        /* cblasRight                     */
   else
   {
      if (TRANS == CblasNoTrans)
      {
         j = (K/nb)*nb;
         if (j == K)
         {
            j=K -nb;
         }
         for (j; j >= 0; j = j - nb)
         {
            ib = nb;
            if ((j+nb) > K)
            {
               ib = K - j;
            }
/*
 *           Form the triangular factor of the block reflector
 *           H = H(i+ib-1) . . . H(i+1) H(i)
 */
            ATL_larft(LABackward, LARowStore, M-K+j+ib, ib,
                      A+(j SHIFT) , lda, TAU+(j SHIFT),      
                                   ws_T, ib);

            mi = M -K + j +ib ;

/*           H or H' is applied to C(1:m-k+i+ib-1,1:n)                        */

            ATL_larfb(SIDE, TRANST, LABackward, LARowStore,
                      mi, N, ib, A+(j SHIFT), lda, ws_T, ib,      
                      C, ldc, ws_larfb, N);
         }                                  /* for                            */
          
      }
      else 
      {
         for (j=0 ; j < K ; j = j + nb) 
         {
            ib = Mmin(K-j,nb);
/*
 *           Form the triangular factor of the block reflector
 *           H = H(i+ib-1) . . . H(i+1) H(i)
 */
            ATL_larft(LABackward, LARowStore, M-K+j+ib, ib,
                      A+(j SHIFT) , lda, TAU+(j SHIFT), ws_T, ib);

            mi = M -K + j +ib ;

/*           H or H' is applied to C(1:m-k+i+ib-1,1:n)                        */

            ATL_larfb(SIDE, TRANST, LABackward, LARowStore,
                      mi, N, ib, A+(j SHIFT), lda, ws_T, ib,      
                      C, ldc, ws_larfb, N);
         }                                  /* for                            */
      }
   }                                        /* cblasLeft                      */

   if (vp)
      free(vp);
   return(0);
}                                           /* END ATL_ormrq                  */

@ROUT ATL_ormql

#include "stdio.h"
#include "cblas.h"
#include "atlas_lapack.h"

#ifdef  SREAL
   #define MYOPT LASreal
#endif
#ifdef  DREAL
   #define MYOPT  LADreal
#endif
#ifdef  SCPLX
   #define MYOPT  LAScplx
#endif
#ifdef  DCPLX
   #define MYOPT  LADcplx
#endif

int ATL_ormql
   (const enum CBLAS_SIDE SIDE, const enum CBLAS_TRANSPOSE TRANS, 
    ATL_CINT M, ATL_CINT N, ATL_CINT K, TYPE *A, ATL_CINT lda, 
    const TYPE * TAU, TYPE *C, ATL_CINT ldc, TYPE *WORK, ATL_CINT LWORK) 
/*
 * This is the C translation of the standard LAPACK Fortran routine:
 *      SUBROUTINE ATL_ormql( SIDE, TRANS, M, N, K, A, LDA, TAU, C, LDC,
 *                        WORK, LWORK, INFO )
 *
 * ATL_ormql.c :
 * int ATL_ormql(const enum CBLAS_SIDE SIDE SIDE,
 *        const enum CBLAS_TRANSPOSE TRANS, ATL_CINT M, ATL_CINT N,
 *        ATL_CINT K, TYPE * A, ATL_CINT lda,TYPE * TAU, TYPE * C, ATL_CINT ldc,
 *                       TYPE * WORK, ATL_CINT LWORK)
 *
 *      NOTE :   ATL_ormql.c will get compiled to four precisions
 *               single precision real,      double precision real
 *               single precision complex,   double precision complex
 *
 *
 *  Purpose
 *  =======
 *
 *  ATL_ormql overwrites the general real M-by-N matrix C with
 *
 *                  SIDE = 'L'     SIDE = 'R'
 *  TRANS = 'N':      Q * C          C * Q
 *  TRANS = 'T':      Q**T * C       C * Q**T
 *
 *  where Q is,
 *        a real orthogonal matrix defined as the product of k
 *        elementary reflectors
 *
 *        Q = H(k) . . . H(2) H(1)
 *
 *   OR
 *        a complex unitary matrix defined as a product of k
 *        elementary reflectors
 *
 *        Q = H(k) . . . H(2) H(1)
 *
 *  as returned by ATLL_geqrf.c. Q is of order M if SIDE = 'L' and of order N
 *  if SIDE = 'R'.
 *
 *  Arguments
 *  =========
 *
 *  SIDE    (input) CHARACTER*1
 *          = 'L': apply Q or Q**T from the Left;
 *          = 'R': apply Q or Q**T from the Right.
 *
 *  TRANS   (input) CHARACTER*1
 *          = 'N':  No transpose, apply Q;
 *          = 'T':  Transpose, apply Q**T.
 *
 *  M       (input) INTEGER
 *          The number of rows of the matrix C. M >= 0.
 *
 *  N       (input) INTEGER
 *          The number of columns of the matrix C. N >= 0.
 *
 *  K       (input) INTEGER
 *          The number of elementary reflectors whose product defines
 *          the matrix Q.
 *          If SIDE = 'L', M >= K >= 0;
 *          if SIDE = 'R', N >= K >= 0.
 *
 *  A       (input) array, dimension (LDA,K)
 *          The i-th column must contain the vector which defines the
 *          elementary reflector H(i), for i = 1,2,...,k, as returned by
 *          DGEQRF in the first k columns of its array argument A.
 *          A is modified by the routine but restored on exit.
 *
 *  lda     (input) INTEGER
 *          The leading dimension of the array A.
 *          If SIDE = 'L', LDA >= max(1,M);
 *          if SIDE = 'R', LDA >= max(1,N).
 *
 *  TAU     (input)  array, dimension (K)
 *          TAU(i) must contain the scalar factor of the elementary
 *          reflector H(i), as returned by ATL_geqrf.c.
 *
 *  C       (input/output)  array, dimension (LDC,N)
 *          On entry, the M-by-N matrix C.
 *          On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.
 *
 *  ldc     (input) INTEGER
 *          The leading dimension of the array C. LDC >= max(1,M).
 *
 *  WORK    (workspace/output) array, dimension (MAX(1,LWORK))
 *          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
 *
 *  LWORK   (input) INTEGER
 *          The dimension of the array WORK.
 *          If SIDE = 'L', LWORK >= max(1,N);
 *          if SIDE = 'R', LWORK >= max(1,M).
 *          For optimum performance LWORK >= N*NB if SIDE = 'L', and
 *          LWORK >= M*NB if SIDE = 'R', where NB is the optimal
 *          blocksize.
 *
 *          If LWORK = -1, then a workspace query is assumed; the routine
 *          only calculates the optimal size of the WORK array, returns
 *          this value as the first entry of the WORK array, and no error
 *          message related to LWORK is issued by XERBLA.
 *
 *  INFO    (output) INTEGER
 *          = 0:  successful exit
 *          < 0:  if INFO = -i, the i-th argument had an illegal value
 *
 */
{
   ATL_CINT minMN = Mmin(M, N), maxMN = Mmax(M, N);
   ATL_INT n, nb, j, ib, mi, ni, ic, jc ;
   TYPE  *ws_QL2,  *ws_T, *ws_larfb;        /* Workspace for QR2,T, larfb     */
   void *vp=NULL;

   nb = clapack_ilaenv(LAIS_OPT_NB, LAormqr, MYOPT+LARight+LALower, M, N,K,-1);

/*
 * If it is a workspace query, return the size of work required.
 *    wrksz = wrksz of ATL_larfb + ATL_larft + ATL_geqr2
 */
   if (LWORK < 0)
   {
      if(SIDE == CblasLeft)
      {
         *WORK = ( N*nb + nb*nb + maxMN )  ;
      }
      else
      {
         *WORK = ( M*nb + nb*nb + maxMN )  ;
      }
      return(0);
   }
   else if (M < 1 || N < 1)                 /* quick return if no work to do  */
      return(0);
/*
 * If the user gives us too little space, see if we can allocate it ourselves
 */
   else 
   {
      if(SIDE == CblasLeft)
      {
         if (LWORK < (N*nb + nb*nb + maxMN))
         {
            vp = malloc(ATL_MulBySize(N*nb + nb*nb + maxMN) + ATL_Cachelen);
            if (!vp)
               return(-7);
            WORK = ATL_AlignPtr(vp);
         }
      }
      else 
      {
         if (LWORK < (M*nb + nb*nb + maxMN))
         {
            vp = malloc(ATL_MulBySize(M*nb + nb*nb + maxMN) + ATL_Cachelen);
            if (!vp)
               return(-7);
            WORK = ATL_AlignPtr(vp);
         }
      }                                     /* if CblasRight                  */
   }                                        /* if else                        */

/*
 * Assign workspace areas for ATL_larft, ATL_geql2, ATL_larfb
 */
  
   ws_T = WORK;                             /* T at begining of work          */
   ws_QL2 = WORK +(nb SHIFT)*nb;            /* After T Work space             */
   ws_larfb = ws_QL2 + (maxMN SHIFT);       /* After workspace for T and QR2  */


   if (SIDE == CblasLeft)
   {
      if (TRANS == CblasNoTrans)
      {
         for (j=0 ; j < K ; j = j + nb) 
         {
            ib = Mmin(K-j, nb);
/*
 *          Form the triangular factor of the block reflector
 *          H = H(i+ib-1) . . . H(i+1) H(i)
 */
            ATL_larft(LABackward, LAColumnStore, M-K+j+ib, ib,
                      A+(j SHIFT)*lda , lda, TAU+(j SHIFT),     
                                   ws_T, ib);
/*
 *          H or H' is applied to C(1:m-k+i+ib-1,1:n)
 */
            mi = M -K + j +ib ;

            ATL_larfb(SIDE, TRANS, LABackward, LAColumnStore,
                      mi, N, ib, A+(j SHIFT)*lda, lda, ws_T, ib,        
                      C, ldc, ws_larfb, N);
         }
      }                                     /* CblasNoTrans                   */
      else 
      {
         j = (K/nb)*nb;
         if (j == K)
         {
            j=K -nb;
         }

         for (j; j >= 0; j = j - nb)
         {
            ib = nb;
            if ((j+nb) > K)
            {
               ib = K - j;
            }
/*
 *          Form the triangular factor of the block reflector
 *          H = H(i+ib-1) . . . H(i+1) H(i)
 */
            ATL_larft(LABackward, LAColumnStore, M-K+j+ib, ib,
                      A+(j SHIFT)*(lda), lda, TAU+(j SHIFT), ws_T, ib);
/*
 *          H or H' is applied to C(1:m-k+i+ib-1,1:n)
 */
            mi = M -K + j +ib ;

            ATL_larfb(SIDE, TRANS, LABackward, LAColumnStore,
                      mi, N, ib, A+(j SHIFT)*(lda), lda, ws_T, ib,
                      C, ldc, ws_larfb, N);
         }                                  /* for                            */
      }
   }                                        /* cblasLeft main logic           */
   else 
   {
      if ( TRANS == CblasNoTrans )
      {
         j = (K/nb)*nb;
         if (j == K)
         {
            j=K -nb;
         }
         for (j; j >= 0; j = j - nb)
         {

            ib = nb;
            if ((j+nb) > K)
            {
               ib = K - j;
            }
/*
 *          Form the triangular factor of the block reflector
 *          H = H(i+ib-1) . . . H(i+1) H(i)
 */
            ATL_larft(LABackward, LAColumnStore, N-K+j+ib, ib,
                      A+(j SHIFT)*(lda), lda, TAU+(j SHIFT), ws_T, ib);
/*
 *          H or H' is applied to C(1:m-k+i+ib-1,1:n)
 */
            ni = N - K + j +ib;

            ATL_larfb(SIDE, TRANS, LABackward, LAColumnStore,
                      M, ni, ib, A+(j SHIFT)*(lda), lda, ws_T, ib,
                      C, ldc, ws_larfb, M);
         }                                  /* for                            */

      }                                     /* Cblas Tran on Right            */
      else 
      {
         for (j = 0 ; j < K; j = j + nb)
         {
            ib = Mmin(K-j, nb);
/*
 *          Form the triangular factor of the block reflector
 *          H = H(i+ib-1) . . . H(i+1) H(i)
 */
            ATL_larft(LABackward, LAColumnStore, N-K+j+ib, ib,
                      A+(j SHIFT)*lda , lda, TAU+(j SHIFT),     
                                   ws_T, ib);
/*
 *          H or H' is applied to C(1:m-k+i+ib-1,1:n)
 */
            ni = N - K + j +ib;
            ATL_larfb(SIDE, TRANS, LABackward, LAColumnStore,
                      M, ni, ib, A+(j SHIFT)*lda, lda, ws_T, ib,        
                      C, ldc, ws_larfb, M);
         }                                  /* for                            */
      }                                     /* Cblastrans                     */
   }                                        /* CblasRight                     */

   if (vp)
      free(vp);
   return(0);
}                                           /* END ATL_ormql                  */

@ROUT ATL_ormlq

#include "stdio.h"
#include "cblas.h"
#include "atlas_lapack.h"

#ifdef  SREAL
     #define MYOPT LASreal
#endif
#ifdef  DREAL
    #define MYOPT  LADreal
#endif
#ifdef  SCPLX
    #define MYOPT  LAScplx
#endif
#ifdef  DCPLX
    #define MYOPT  LADcplx
#endif

int ATL_ormlq
   (const enum CBLAS_SIDE SIDE, const enum CBLAS_TRANSPOSE TRANS, 
    ATL_CINT M, ATL_CINT N, ATL_CINT K, TYPE *A, ATL_CINT lda,
    const TYPE *TAU, TYPE *C, ATL_CINT ldc, TYPE *WORK, ATL_CINT LWORK) 
/*
 * This is the C translation of the standard LAPACK Fortran routine:
 *      SUBROUTINE DORMLQ( SIDE, TRANS, M, N, K, A, LDA, TAU, C, LDC,
 *                        WORK, LWORK, INFO )
 *
 * ATL_ormlq.c :
 * int ATL_ormlq(const enum CBLAS_SIDE SIDE SIDE,
 *        const enum CBLAS_TRANSPOSE TRANS, ATL_CINT M, ATL_CINT N,
 *        ATL_CINT K, TYPE * A, ATL_CINT lda,TYPE * TAU, TYPE * C, ATL_CINT ldc,
 *                       TYPE * WORK, ATL_CINT LWORK)
 *
 *      NOTE :   ATL_ormlq.c will get compiled to four precisions
 *               single precision real,      double precision real
 *               single precision complex,   double precision complex
 *
 *
 *  Purpose
 *  =======
 *
 *  ATL_ormlq overwrites the general real M-by-N matrix C with
 *
 *                  SIDE = 'L'     SIDE = 'R'
 *  TRANS = 'N':      Q * C          C * Q
 *  TRANS = 'T':      Q**T * C       C * Q**T
 *
 *  where Q is,
 *        a real orthogonal matrix defined as the product of k
 *        elementary reflectors
 *
 *        Q = H(k) . . . H(2) H(1)
 *
 *   OR
 *        a complex unitary matrix defined as a product of k
 *        elementary reflectors
 *
 *        Q = H(k) . . . H(2) H(1)
 *
 *  as returned by ATL_gerqf.c. Q is of order M if SIDE = 'L' and of order N
 *  if SIDE = 'R'.
 *
 *  Arguments
 *  =========
 *
 *  SIDE    (input) CHARACTER*1
 *          = 'L': apply Q or Q**T from the Left;
 *          = 'R': apply Q or Q**T from the Right.
 *
 *  TRANS   (input) CHARACTER*1
 *          = 'N':  No transpose, apply Q;
 *          = 'T':  Transpose, apply Q**T.
 *
 *  M       (input) INTEGER
 *          The number of rows of the matrix C. M >= 0.
 *
 *  N       (input) INTEGER
 *          The number of columns of the matrix C. N >= 0.
 *
 *  K       (input) INTEGER
 *          The number of elementary reflectors whose product defines
 *          the matrix Q.
 *          If SIDE = 'L', M >= K >= 0;
 *          if SIDE = 'R', N >= K >= 0.
 *
 *  A       (input) array, dimension
 *                               (LDA,M) if SIDE = 'L',
 *                               (LDA,N) if SIDE = 'R'
 *          The i-th row must contain the vector which defines the
 *          elementary reflector H(i), for i = 1,2,...,k, as returned by
 *          DGELQF in the first k rows of its array argument A.
 *          A is modified by the routine but restored on exit.
 *
 *  lda     (input) INTEGER
 *          The leading dimension of the array A. LDA >= max(1,K).
 *
 *  TAU     (input) array, dimension (K)
 *          TAU(i) must contain the scalar factor of the elementary
 *          reflector H(i), as returned by DGELQF.
 *
 *  C       (input/output) array, dimension (LDC,N)
 *          On entry, the M-by-N matrix C.
 *          On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.
 *
 *  ldc     (input) INTEGER
 *          The leading dimension of the array C. LDC >= max(1,M).
 *
 *  WORK    (workspace/output) array, dimension (MAX(1,LWORK))
 *          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
 *
 *  LWORK   (input) INTEGER
 *          The dimension of the array WORK.
 *          If SIDE = 'L', LWORK >= max(1,N);
 *          if SIDE = 'R', LWORK >= max(1,M).
 *          For optimum performance LWORK >= N*NB if SIDE = 'L', and
 *          LWORK >= M*NB if SIDE = 'R', where NB is the optimal
 *          blocksize.
 *
 *          If LWORK = -1, then a workspace query is assumed; the routine
 *          only calculates the optimal size of the WORK array, returns
 *          this value as the first entry of the WORK array, and no error
 *          message related to LWORK is issued by XERBLA.
 *
 *  INFO    (output) INTEGER
 *          = 0:  successful exit
 *          < 0:  if INFO = -i, the i-th argument had an illegal value
 *
 */
{
   ATL_CINT minMN = Mmin(M, N), maxMN = Mmax(M, N);
   ATL_INT n, nb, j, ib, mi, ni ;
   TYPE  *ws_LQ2,  *ws_T, *ws_larfb;        /* Workspace for QR2,T, larfb     */
   void *vp=NULL;
   
   enum CBLAS_TRANSPOSE  TRANST;

   nb = clapack_ilaenv(LAIS_OPT_NB, LAormqr, MYOPT+LALeft+LAUpper, M, N, K,-1);

/*
 * If it is a workspace query, return the size of work required.
 *    wrksz = wrksz of ATL_larfb + ATL_larft + ATL_geqr2
 */
   if (LWORK < 0)
   {
      if(SIDE == CblasLeft)
      {
         *WORK = ( N*nb + nb*nb + maxMN )  ;
      }
      else
      {
         *WORK = ( M*nb + nb*nb + maxMN )  ;
      }
      return(0);
   }
   else if (M < 1 || N < 1)                 /* quick return if no work to do  */
      return(0);
/*
 * If the user gives us too little space, see if we can allocate it ourselves
 */
   else 
   {
      if(SIDE == CblasLeft)
      {
         if (LWORK < (N*nb + nb*nb + maxMN))
         {
            vp = malloc(ATL_MulBySize(N*nb + nb*nb + maxMN) + ATL_Cachelen);
            if (!vp)
               return(-7);
            WORK = ATL_AlignPtr(vp);
         }
      }
      else 
      {
         if (LWORK < (M*nb + nb*nb + maxMN))
         {
            vp = malloc(ATL_MulBySize(M*nb + nb*nb + maxMN) + ATL_Cachelen);
            if (!vp)
               return(-7);
            WORK = ATL_AlignPtr(vp);
         }
      }                                     /* if CblasRight                  */
   }                                        /* if else                        */

/*
 * Assign workspace areas for ATL_larft, ATL_geql2, ATL_larfb
 */
  
   ws_T = WORK;                             /* T at begining of work          */
   ws_LQ2 = WORK +(nb SHIFT)*nb;            /* After T Work space             */
   ws_larfb = ws_LQ2 + (maxMN SHIFT);       /* After workspace for T and QR2  */

   if (TRANS == CblasNoTrans)
   {
      TRANST = CblasTrans;    
   } else
   {
      TRANST = CblasNoTrans;
   }

   if (SIDE == CblasRight)
   {
      if (TRANS == CblasNoTrans)
      {
         j  = (K/nb)*nb;  
         if (j == K)
         {
            j = K -nb;
         }        

         for (j ; j >=0; j = j - nb) 
         {
            ib = nb;
            if ((j+nb)  > K)
            {
               ib = K -j;          
            }
            
/*
 *           Form the triangular factor of the block reflector
 *           H = H(i) H(i+1) . . . H(i+ib-1)
 */
            ATL_larft(LAForward, LARowStore, N-j, ib,
                      A+(j SHIFT)*(lda+1) , lda, TAU+(j SHIFT),  ws_T, ib);

/*              H or H' is applied to C(1:m,i:n)                              */

            ATL_larfb(SIDE, TRANST, LAForward, LARowStore,
                      M, N-j, ib, A+(j SHIFT)*(lda+1), lda, ws_T, ib,   
                      C + (j SHIFT)*ldc, ldc, ws_larfb, M);
         }
      } //else on Trans 
      else 
      {
         for (j=0 ; j < K ; j = j + nb)
         {
            ib = Mmin(K-j,nb);
/*
 *           Form the triangular factor of the block reflector
 *           H = H(i) H(i+1) . . . H(i+ib-1)
 */
            ATL_larft(LAForward, LARowStore, N-j, ib,
                      A+(j SHIFT)*(lda+1) , lda, TAU+(j SHIFT), ws_T, ib);

/*              H or H' is applied to C(1:m,i:n)                              */

            ATL_larfb(SIDE, TRANST, LAForward, LARowStore,
                      M, N-j, ib, A+(j SHIFT)*(lda+1), lda, ws_T, ib,   
                      C + (j SHIFT)*ldc, ldc, ws_larfb, M);
         }
      }
   }                                        /* cblasLeft main logic           */
   else 
   {
      if (TRANS == CblasNoTrans)
      {
//         fprintf(stderr, "code Left and with No trans....\n");
         for (j=0 ; j < K ; j = j + nb)
         {
            ib = Mmin(K-j,nb);
/*
 *           Form the triangular factor of the block reflector
 *           H = H(i) H(i+1) . . . H(i+ib-1)
 */
            ATL_larft(LAForward, LARowStore, M-j, ib,
                      A+(j SHIFT)*(lda+1) , lda, TAU+(j SHIFT), ws_T, ib);

/*              H or H' is applied to C(i:m,1:n)                              */

            ATL_larfb(SIDE, TRANST, LAForward, LARowStore,
                      M-j, N, ib, A+(j SHIFT)*(lda+1), lda, ws_T, ib,   
                      C + (j SHIFT), ldc, ws_larfb, N);
         }

      }
      else  //Trans 
      {
         j = (K/nb)*nb;
         if (j == K)
         {
            j=K -nb;
         }
         for (j; j >= 0; j = j - nb)
         {
            ib = nb;
            if ((j+nb) > K)
            {
               ib = K - j;
            }
/*
 *           Form the triangular factor of the block reflector
 *           H = H(i) H(i+1) . . . H(i+ib-1)
 */
            ATL_larft(LAForward, LARowStore, M-j, ib,
                      A+(j SHIFT)*(lda+1) , lda, TAU+(j SHIFT), 
                                   ws_T, ib);

/*              H or H' is applied to C(i:m,1:n)                              */

            ATL_larfb(SIDE, TRANST, LAForward, LARowStore,
                      M-j, N, ib, A+(j SHIFT)*(lda+1), lda, ws_T, ib,   
                      C + (j SHIFT), ldc, ws_larfb, N);
         }
      } //else Trans
   } // Else Right

   if (vp)
      free(vp);
   return(0);
}                                           /* END ATL_ormlq                  */


@ROUT ormtst
@extract -b @(topd)/cw.inc lang=C -def cwdate 2009 -def cwauth "Siju Samuel" -def contrib "Anthony M. Castaldo, R. Clint Whaley"


/*
 *  This program is a tester for ORM routines.
 *  Logic:
 *       a) Based on the Input dimensions m and n, create a matrix A and perform
 *          QR(LQ,RQ,QL) factorization. 
 *       b) Create the input matrix C for ORM routines
 *       c) Identify input dimension for call to ORM routines based on SIDE, TRANS
 *          and factorization variant.  
 *       d) Call LAPACK Fortran version of ORM routine   with modified A & C
 *       d) Call ATLAS C version of ORM routine   with modified A & C
 *       e) Compare the results  
 */

/************************   Some Sample Input :***********************
QR
./xsormtst_pt  -m 1 800   -n 1 128 -a 200 -S 1 R  -U 1 u -# 1   -x L -y N  -z 100
./xsormtst_pt  -m 1 800   -n 1 128 -a 200 -S 1 R  -U 1 u -# 1   -x L -y T  -z 100
./xsormtst_pt  -m 1 800   -n 1 128 -a 200 -S 1 R  -U 1 u -# 1   -x R -y N  -z 100
./xsormtst_pt  -m 1 800   -n 1 128 -a 200 -S 1 R  -U 1 u -# 1   -x R -y T  -z 100
RQ
./xsormtst_pt  -m 1 800   -n 1 128 -a 200 -S 1 L  -U 1 u -# 1   -x L -y N  -z 100

QL
./xsormtst_pt  -m 1 800   -n 1 128 -a 200 -S 1 R  -U 1 l -# 1   -x L -y N  -z 100

LQ
./xsormtst_pt  -m 1 800   -n 1 128 -a 200 -S 1 L  -U 1 l -# 1   -x L -y T  -z 100
 ***********************************************************************/


#include "atlas_misc.h"
#include "atlas_lapack.h"
#include "cblas.h"
#include "atlas_cblastypealias.h"
#include "atlas_tst.h"
#ifndef TimeF77
   #include "clapack.h"
#endif
//#define ormCtime 1
#define ormFtime 1

#ifdef ATL_FULL_LAPACK
   #include "atlas_C2Flapack.h"
   #ifdef TREAL
      #define LA_LQ2Q Mjoin(Mjoin(ATL_C2F,PRE),ormlq)
   #else
      #define LA_LQ2Q Mjoin(Mjoin(ATL_C2F,PRE),unmlq)
   #endif
   #ifdef TREAL
      #define LA_RQ2Q Mjoin(Mjoin(ATL_C2F,PRE),ormrq)
   #else
      #define LA_RQ2Q Mjoin(Mjoin(ATL_C2F,PRE),unmrq)
   #endif
   #ifdef TREAL
      #define LA_QL2Q Mjoin(Mjoin(ATL_C2F,PRE),ormql)
   #else
      #define LA_QL2Q Mjoin(Mjoin(ATL_C2F,PRE),unmql)
   #endif
   #ifdef TREAL
      #define LA_QR2Q Mjoin(Mjoin(ATL_C2F,PRE),ormqr)
   #else
      #define LA_QR2Q Mjoin(Mjoin(ATL_C2F,PRE),unmqr)
   #endif
#endif

#ifdef GCCWIN
   ___main(){} __main(){} MAIN__(){} _MAIN_(){}
#endif
#define PRINT_1    0
#define PRINT_2    1

#ifdef TREAL
   static const TYPE ONE = ATL_rone;
   static const TYPE ZEROVAL = ATL_rzero;
   #define MY_TRANS CblasTrans
#else
   static const TYPE ONE[2] = {ATL_rone, ATL_rzero};
   static const TYPE ZEROVAL[2] = {ATL_rzero, ATL_rzero};
   #define MY_TRANS CblasConjTrans
#endif



#ifdef TimeF77
   #define test_gelqf(Major_, M_, N_, A_, lda_, tau_, wrk_, lw_) \
      ATL_assert(!Mjoin(PATL,f77gelqf) \
         (Major_, M_, N_, A_, lda_, tau_, wrk_, lw_))
#elif defined(TimeC)
   #define test_gelqf(Major_, M_, N_, A_, lda_, tau_, wrk_, lw_) \
   { \
      if ((lw_) != -1) \
      { \
         ATL_assert(!Mjoin(Mjoin(clapack_,PRE),gelqf) \
            (CblasColMajor, M_, N_, A_, lda_, tau_)) \
      } \
      else (wrk_)[0] = 0; \
   }
#else
   #define test_gelqf(Major_, M_, N_, A_, lda_, tau_, wrk_, lw_) \
      ATL_assert(!Mjoin(PATL,gelqf) \
         (M_, N_, A_, lda_, tau_, wrk_, lw_))
#endif
#ifdef TimeF77
   #define test_gerqf(Major_, M_, N_, A_, lda_, tau_, wrk_, lw_) \
      ATL_assert(!Mjoin(PATL,f77gerqf) \
         (Major_, M_, N_, A_, lda_, tau_, wrk_, lw_))
#elif defined(TimeC)
   #define test_gerqf(Major_, M_, N_, A_, lda_, tau_, wrk_, lw_) \
   { \
      if ((lw_) != -1) \
      { \
         ATL_assert(!Mjoin(Mjoin(clapack_,PRE),gerqf) \
            (CblasColMajor, M_, N_, A_, lda_, tau_)) \
      } \
      else (wrk_)[0] = 0; \
   }
#else
   #define test_gerqf(Major_, M_, N_, A_, lda_, tau_, wrk_, lw_) \
      ATL_assert(!Mjoin(PATL,gerqf) \
         (M_, N_, A_, lda_, tau_, wrk_, lw_))
#endif
#ifdef TimeF77
   #define test_geqlf(Major_, M_, N_, A_, lda_, tau_, wrk_, lw_) \
      ATL_assert(!Mjoin(PATL,f77geqlf) \
         (Major_, M_, N_, A_, lda_, tau_, wrk_, lw_))
#elif defined(TimeC)
   #define test_geqlf(Major_, M_, N_, A_, lda_, tau_, wrk_, lw_) \
   { \
      if ((lw_) != -1) \
      { \
         ATL_assert(!Mjoin(Mjoin(clapack_,PRE),geqlf) \
            (CblasColMajor, M_, N_, A_, lda_, tau_)) \
      } \
      else (wrk_)[0] = 0; \
   }
#else
   #define test_geqlf(Major_, M_, N_, A_, lda_, tau_, wrk_, lw_) \
      ATL_assert(!Mjoin(PATL,geqlf) \
         (M_, N_, A_, lda_, tau_, wrk_, lw_))
#endif
#ifdef TimeF77
   #define test_geqrf(Major_, M_, N_, A_, lda_, tau_, wrk_, lw_) \
      ATL_assert(!Mjoin(PATL,f77geqrf) \
         (Major_, M_, N_, A_, lda_, tau_, wrk_, lw_))
#elif defined(TimeC)
   #define test_geqrf(Major_, M_, N_, A_, lda_, tau_, wrk_, lw_) \
   { \
      if ((lw_) != -1) \
      { \
         ATL_assert(!Mjoin(Mjoin(clapack_,PRE),geqrf) \
            (CblasColMajor, M_, N_, A_, lda_, tau_)) \
      } \
      else (wrk_)[0] = 0; \
   }
#else
   #define test_geqrf(Major_, M_, N_, A_, lda_, tau_, wrk_, lw_) \
      ATL_assert(!Mjoin(PATL,geqrf) \
         (M_, N_, A_, lda_, tau_, wrk_, lw_))
#endif


/*
 * Print a Matrix
 */
void printMatrix(char *msg, TYPE *A, int M, int N, int lda)
{
   if(PRINT_1)
      Mjoin(PATL,geprint)(msg, M, N, A, lda);
}

/*
 * Print a Vector
 */
void printVector( char * msg, TYPE *X, int N)
{
   if(PRINT_1)
      Mjoin(PATL,geprint)(msg, N, 1, X, N);
}


int AllocationErr( char * msg)
{
   printf("Error while allocating %s\n", msg);
   exit(-1);
}

/*
 * Returns a duplicate of the A matrix, with new leading dimension
 * lda   : leading dimension of A
 * ldc   : leading dimension of Duplicate Matrix
 */
static TYPE *DupMat(enum ATLAS_ORDER Order, int M, int N, TYPE *A, int lda,
                     int ldc)
{
   int i, j, M2;
   const int ldc2 = (ldc SHIFT), lda2 = (lda SHIFT);
   TYPE *C;
   if (Order == CblasRowMajor)
   {
      i = M;
      M = N;
      N = i;
   }
   M2 = M SHIFT;
   ATL_assert(ldc >= M);
   C = malloc(ATL_MulBySize(ldc)*N);
   ATL_assert(C);
   for (j=0; j != N; j++)
   {
      for (i=0; i != M2; i++) C[i] = A[i];
      C += ldc2;
      A += lda2;
   }
   return(C-N*ldc2);
}


/*
 * Allocate a space for ldmxN for 'real'.
 * For Complex allocate space for (2*ldm)xN.
 * It also takes care of the precision.
 * Then generate matrix for MxN, real/complex values based on the precision.
 */
TYPE *GetGE(int M, int N, int lda)
{
   TYPE *A;
   A = malloc(ATL_MulBySize(lda)*N);
   if (A) Mjoin(PATL,gegen)(M, N, A, lda, M*N+lda);
   return(A);
}


static TYPE ORlqtest(int M, int N, int lda, int flushKB, double *time, char Cside, char Ctrans, int CsideSz)
{

   TYPE *A, *TAU,  *WORK, *WORKC ;
   TYPE *C, *CF;

   TYPE *AORIG ;
   TYPE  dtmp, dtmp1;
   double t0;

   int LWORK, LWORKC;
   TYPE normC, eps, resid;

   int  ldm, ldmn, ldn, cM, cN, ldc ;

   enum CBLAS_SIDE SIDE; enum CBLAS_TRANSPOSE TRANS ;

   ldm = M;
   ldn = N;
   const int MNmin = Mmin(M,N);
   ldmn = MNmin;

/* Epsilon */
   eps = Mjoin(PATL,epsilon)();

/* Allocate A and initialize */
   A = GetGE(M, N, lda);
   if (A == NULL) AllocationErr("A");

/* Allocate C  and CF  as the matrix to be multiplied with A                  */
/* and will get the same matrix                                               */
/* Note that ALWAYS Q will have size M since we are caling  ATL_ormqrf        */

   if( Cside == 'L')
   {
      if(Ctrans  ==  'N')
      {
         cM = N;
         cN = CsideSz;
         ldc = ldn;
         SIDE = CblasLeft;
         TRANS = CblasNoTrans;
      }
      else
      {
         cM = N;
         cN = CsideSz;
         ldc = ldn;
         SIDE = CblasLeft;
         #ifdef TREAL
            TRANS = CblasTrans;                  
         #else
            TRANS = CblasConjTrans;
         #endif
      }
   }
   else
   {
      if(Ctrans  ==  'N')
      {
         cM = CsideSz;
         cN = N;
         ldc = CsideSz;
         SIDE = CblasRight;
         TRANS = CblasNoTrans;                  
      }
      else
      {
         cM = CsideSz;
         cN = N;
         ldc = CsideSz;
         SIDE = CblasRight;
         #ifdef TREAL
            TRANS = CblasTrans;                  
         #else
            TRANS = CblasConjTrans;
         #endif
      }
   }
/* Allocate C and CF  for ormqr inp - will get modified */
   C  =  GetGE(cM,cN, ldc);                 /* Q will have side M             */
   CF =  GetGE(cM,cN, ldc);       /* Both C an CF are having the same values  */

/* Allocate A Original and copy from A */
   AORIG = DupMat(CblasColMajor, M, N, A, lda, lda);

/* Call to get the  size of workspace required */
   test_gelqf(CblasColMajor, M, N, &dtmp1, lda, &dtmp1, &dtmp, -1);

   LWORK = dtmp;

   WORK = malloc(ATL_MulBySize(LWORK));
   if (WORK == NULL) return(-1);

   TAU = malloc(ATL_MulBySize(MNmin));
   if (TAU == NULL) AllocationErr("TAU");

   if (flushKB)
   {
      t0 = ATL_flushcache(flushKB*1024);
      t0 += ATL_flushcache(-1);
   }
   t0 = time00();

   test_gelqf(CblasColMajor, M, N, (TYPE*)(A), lda, (TYPE*)(TAU),
              (TYPE*)(WORK), LWORK);

   *time = time00() - t0;
   if (flushKB)
      t0 += ATL_flushcache(0);


   printMatrix("AORIG", AORIG, M, N, lda);
   printMatrix("A", A, M, N, lda);
   printVector("TAU", TAU, MNmin);


//   LWORKC = 1000000;            // TODO : Temporary Code  Modify  later
   LWORKC = Mjoin(PATL,ormlq)(SIDE, TRANS, cM, cN, MNmin, &dtmp1, lda, TAU, &dtmp1, ldc,
                     &dtmp,  -1);
   LWORKC = dtmp;
   WORKC = malloc(ATL_MulBySize(LWORKC));


   ATL_assert(!LA_LQ2Q(SIDE, TRANS, cM, cN, MNmin, A, lda, TAU,
                       CF, ldc));

   Mjoin(PATL,ormlq)(SIDE, TRANS, cM, cN, MNmin, A, lda, TAU, C, ldc,
                     WORKC,  LWORKC);


   normC = Mjoin(PATL,genrm1)(cM, cN, C, ldc);
   resid  = Mjoin(PATL,gediffnrm1)(cM, cN, C, ldc, CF, ldc);

   resid /= (normC * eps * Mmin(cM, cN));

   return(resid);
}

static TYPE ORqltest(int M, int N, int lda, int flushKB, double *time, char Cside, char Ctrans, int CsideSz)
{
   TYPE *A, *TAU,  *WORK, *WORKC ;
   TYPE *C, *CF;

   TYPE *AORIG ;
   TYPE  dtmp, dtmp1;
   double t0;


   int LWORK, LWORKC;
   TYPE normC, eps, resid;
   int  ldm, ldmn, ldn, cM, cN, ldc ;
   const int lda2 = (lda SHIFT);

   enum CBLAS_SIDE SIDE; enum CBLAS_TRANSPOSE TRANS ;


   ldm = M;
   ldn = N;
   const int MNmin = Mmin(M,N);
   ldmn = MNmin;

   eps = Mjoin(PATL,epsilon)();

/* Allocate A and initialize */
   A = GetGE(M, N, lda);
   if (A == NULL) AllocationErr("A");

/* Allocate C  and CF  as the matrix to be multiplied with A
 * and will get the same matrix
 * Note that ALWAYS Q will have size M since we are caling  ATL_ormqrf
 */

   if( Cside == 'L')
   {
      if(Ctrans  ==  'N')
      {
         cM = M;
         cN = CsideSz;
         ldc = ldm;
         SIDE = CblasLeft;
         TRANS = CblasNoTrans;
      }
      else
      {
         cM = M;
         cN = CsideSz;
         ldc = ldm;
         SIDE = CblasLeft;
         #ifdef TREAL
            TRANS = CblasTrans;                 //or MY_TRAN?
         #else
            TRANS = CblasConjTrans;
         #endif
      }
   }
   else
   {
      if(Ctrans  ==  'N')
      {
         cM = CsideSz;
         cN = M;
         ldc = CsideSz;
         SIDE = CblasRight;
         TRANS = CblasNoTrans;                 //or MY_TRAN?
      }
      else
      {
         cM = CsideSz;
         cN = M;
         ldc = CsideSz;
         SIDE = CblasRight;
         #ifdef TREAL
            TRANS = CblasTrans;                 //or MY_TRAN?
         #else
            TRANS = CblasConjTrans;
         #endif
      }
   }
/* Allocate C and CF  for ormqr inp - will get modified */
   C  =  GetGE(cM,cN, ldc);                 /* Q will have side M             */
   CF =  GetGE(cM,cN, ldc);       /* Both C an CF are having the same values  */

/* Allocate A Original and copy from A */
   AORIG = DupMat(CblasColMajor, M, N, A, lda, lda);

/* Call to get the  size of workspace required */
   test_geqlf(CblasColMajor, M, N, &dtmp1, lda,
               &dtmp1,
               &dtmp, -1);

   LWORK = dtmp;

/* Get Work and LWORK   */
   WORK = malloc(ATL_MulBySize(LWORK));
   if (WORK == NULL) return(-1);

   TAU = malloc(ATL_MulBySize(MNmin));
   if (TAU == NULL) AllocationErr("TAU");

   if (flushKB)
   {
      t0 = ATL_flushcache(flushKB*1024);
      t0 += ATL_flushcache(-1);
   }
   t0 = time00();
   test_geqlf(CblasColMajor, M, N, (TYPE*)(A), lda,
               (TYPE*)(TAU),
               (TYPE*)(WORK), LWORK);
   *time = time00() - t0;
   if (flushKB)
      t0 += ATL_flushcache(0);

   printMatrix("AORIG", AORIG, M, N, lda);
   printMatrix("A", A, M, N, lda);
   printVector("TAU", TAU, MNmin);


//   LWORKC = 1000000;
   LWORKC = Mjoin(PATL,ormql)(SIDE, TRANS, cM, cN, MNmin, &dtmp1, lda, TAU, &dtmp1, ldc,
                     &dtmp,  -1);
   LWORKC = dtmp;

   WORKC = malloc(ATL_MulBySize(LWORKC));

   ATL_assert(!LA_QL2Q(SIDE, TRANS, cM, cN, MNmin, A+(N-MNmin)*lda2, lda, TAU,
                                 CF, ldc));

   ATL_ormql(SIDE, TRANS, cM, cN, MNmin, A+(N-MNmin)*lda2, lda,
                                 TAU, C, ldc, WORKC,  LWORKC);

   normC = Mjoin(PATL,genrm1)(cM, cN, C, ldc);
   resid  = Mjoin(PATL,gediffnrm1)(cM, cN, C, ldc, CF, ldc);

   resid /= (normC * eps * Mmin(cM, cN));
   return(resid);
}


/*
 * Calls gerq ( single, double, single complex and double complex ).
 * From A[MxN] Matrix returned from geqr routines, compute Q and R matrix.
 * Find the residual for ( A_original - RQ  ) operation.
 *
 *   Also, make H(k) = i-tau*vv'
 *   and compute Q = H(1)*H(2)...H(k)  where k = Min(M,N)
 *
 *   VI has size of N
 *
 */
static TYPE ORrqtest(int M, int N, int lda, int flushKB, double *time, char Cside, char Ctrans, int CsideSz )
{
   TYPE *A, *TAU,  *WORK, *WORKC ;
   TYPE *C, *CF;

   TYPE *AORIG ;
   TYPE  dtmp, dtmp1;
   double t0;


   int LWORK, LWORKC;
   TYPE normC, eps, resid;
   int  ldm, ldmn, ldn, cM, cN, ldc ;

   enum CBLAS_SIDE SIDE; enum CBLAS_TRANSPOSE TRANS ;


   ldm = M;
   ldn = N;
   const int MNmin = Mmin(M,N);
   ldmn = MNmin;

   eps = Mjoin(PATL,epsilon)();

/* Allocate A and initialize */
   A = GetGE(M, N, lda);
   if (A == NULL) AllocationErr("A");

/* Allocate C  and CF  as the matrix to be multiplied with A
 * and will get the same matrix
 * Note that ALWAYS Q will have size M since we are caling  ATL_ormqrf
 *
 * fprintf(stderr, " inside rqtest  \n");
 * fprintf(stderr, " CSide %c  Ctrans %c \n", Cside, Ctrans);
 */

   if( Cside == 'L')
   {
      if(Ctrans  ==  'N')
      {
         cM = N;
         cN = CsideSz;
         ldc = ldn;
         SIDE = CblasLeft;
         TRANS = CblasNoTrans;
      }
      else
      {
         cM = N;
         cN = CsideSz;
         ldc = ldn;
         SIDE = CblasLeft;
         #ifdef TREAL
            TRANS = CblasTrans;                 //or MY_TRAN?
         #else
            TRANS = CblasConjTrans;
         #endif
      }
   }
   else
   {
      if(Ctrans  ==  'N')
      {
         cM = CsideSz;
         cN = N;
         ldc = CsideSz;
         SIDE = CblasRight;
         TRANS = CblasNoTrans;                 //or MY_TRAN?
      }
      else
      {
         cM = CsideSz;
         cN = N;
         ldc = CsideSz;
         SIDE = CblasRight;
         #ifdef TREAL
            TRANS = CblasTrans;                 //or MY_TRAN?
         #else
            TRANS = CblasConjTrans;
         #endif
      }
   }
/* Allocate C and CF  for ormqr inp - will get modified */
   C  =  GetGE(cM,cN, ldc);                 /* Q will have side M             */
   CF =  GetGE(cM,cN, ldc);       /* Both C an CF are having the same values  */

/* Allocate A Original and copy from A */
   AORIG = DupMat(CblasColMajor, M, N, A, lda, lda);

/* Call to get the  size of workspace required */
   test_gerqf(CblasColMajor, M, N, &dtmp1, lda,
               &dtmp1,
               &dtmp, -1);

   LWORK = dtmp;

/* Get Work and LWORK */
   WORK = malloc(ATL_MulBySize(LWORK));
   if (WORK == NULL) return(-1);

   TAU = malloc(ATL_MulBySize(MNmin));
   if (TAU == NULL) AllocationErr("TAU");

   if (flushKB)
   {
      t0 = ATL_flushcache(flushKB*1024);
      t0 += ATL_flushcache(-1);
   }
   t0 = time00();

   test_gerqf(CblasColMajor, M, N, (TYPE*)(A), lda,
               (TYPE*)(TAU),
               (TYPE*)(WORK), LWORK);

   *time = time00() - t0;
   if (flushKB)
      t0 += ATL_flushcache(0);


   printMatrix("AORIG", AORIG, M, N, lda);
   printMatrix("A", A, M, N, lda);
   printVector("TAU", TAU, MNmin);


//   LWORKC = 10000000;            // TODO : Temporary Code  Modify  later
   LWORKC = Mjoin(PATL,ormrq)(SIDE, TRANS, cM, cN, MNmin, &dtmp1, lda, TAU, &dtmp1, ldc,
                     &dtmp,  -1);
   LWORKC = dtmp;
   WORKC = malloc(ATL_MulBySize(LWORKC));

   ATL_assert(!LA_RQ2Q(SIDE, TRANS, cM, cN, MNmin,
                       A+((M-MNmin)SHIFT), lda, TAU, CF, ldc));

   Mjoin(PATL,ormrq)(SIDE, TRANS,
                     cM, cN, MNmin, A+((M-MNmin) SHIFT) , lda, TAU, C, ldc,
                     WORKC,  LWORKC);

   normC = Mjoin(PATL,genrm1)(cM, cN, C, ldc);
   resid  = Mjoin(PATL,gediffnrm1)(cM, cN, C, ldc, CF, ldc);

   resid /= (normC * eps * Mmin(cM, cN));   /* Scale                          */

   return(resid);
}


/*
 * Calls geqr ( single, double, single complex and double complex ).
 * From A[MxN] Matrix returned from geqr routines, compute Q and R matrix.
 * Find the residual for ( A_original - QR  ) operation.
 *
 *   Also, make H(k) = i-tau*vv'
 *   and compute Q = H(1)*H(2)...H(k)  where k = Min(M,N)
 *    Cside is the column
 */
TYPE ORqrtest(int M, int N, int lda, int flushKB, double *time, char Cside, char Ctrans, int CsideSz )
{
   TYPE *A, *TAU,  *WORK, *WORKC ;
   TYPE *C, *CF;

   TYPE *AORIG ;
   TYPE  dtmp, dtmp1;
   double t0;


   int LWORK, LWORKC;
   TYPE normC, eps, resid;
   int  ldm, ldmn, ldn, cM, cN, ldc ;

   enum CBLAS_SIDE SIDE; enum CBLAS_TRANSPOSE TRANS ;

   ldm = M;
   ldn = N;
   const int MNmin = Mmin(M,N);
   ldmn = MNmin;

/* Epsilon                                                                    */
   eps = Mjoin(PATL,epsilon)();

/* Allocate A and initialize                                                  */
   A = GetGE(M, N, lda);
   if (A == NULL) AllocationErr("A");
/*
 * Allocate C  and CF  as the matrix to be multiplied with A
 * and will get the same matrix
 * Note that ALWAYS Q will have size M since we are caling  ATL_ormqrf
 */

   if( Cside == 'L')
   {
      if(Ctrans  ==  'N')
      {
         cM = M;
         cN = CsideSz;
         ldc = ldm;
         SIDE = CblasLeft;
         TRANS = CblasNoTrans;
      }
      else
      {
         cM = M;
         cN = CsideSz;
         ldc = ldm;
         SIDE = CblasLeft;
         #ifdef TREAL
            TRANS = CblasTrans;                 //or MY_TRAN?
         #else
            TRANS = CblasConjTrans;
         #endif
      }
   }
   else
   {
      if(Ctrans  ==  'N')
      {
         cM = CsideSz;
         cN = M;
         ldc = CsideSz;
         SIDE = CblasRight;
         TRANS = CblasNoTrans;                 //or MY_TRAN?
      }
      else
      {
         cM = CsideSz;
         cN = M;
         ldc = CsideSz;
         SIDE = CblasRight;
         #ifdef TREAL
            TRANS = CblasTrans;                 //or MY_TRAN?
         #else
            TRANS = CblasConjTrans;
         #endif
      }
   }
/* Allocate C and CF  for ormqr inp - will get modified */
   C  =  GetGE(cM,cN, ldc);                 /* Q will have side M             */
   CF =  GetGE(cM,cN, ldc);       /* Both C an CF are having the same values  */

/* Allocate A Original and copy from A */
   AORIG = DupMat(CblasColMajor, M, N, A, lda, lda);

/* Call to get the  size of workspace required */
   test_geqrf(CblasColMajor, M, N, &dtmp1, lda,
               &dtmp1,
               &dtmp, -1);

   LWORK = dtmp;

   WORK = malloc(ATL_MulBySize(LWORK));
   if (WORK == NULL) return(-1);

   TAU = malloc(ATL_MulBySize(MNmin));
   if (TAU == NULL) AllocationErr("TAU");

   if (flushKB)
   {
      t0 = ATL_flushcache(flushKB*1024);
      t0 += ATL_flushcache(-1);
   }
   t0 = time00();
   test_geqrf(CblasColMajor, M, N, (TYPE*)(A), lda,
               (TYPE*)(TAU),
               (TYPE*)(WORK), LWORK);
   *time = time00() - t0;
   if (flushKB)
      t0 += ATL_flushcache(0);


   printMatrix("AORIG", AORIG, M, N, lda);
   printMatrix("A", A, M, N, lda);
   printVector("TAU", TAU, MNmin);

//   LWORKC = 100000;            // TODO : Temporary Code  Modify  later
   LWORKC = Mjoin(PATL,ormqr)(SIDE, TRANS, cM, cN, MNmin, &dtmp1, lda, TAU, &dtmp1, ldc,
                     &dtmp,  -1);
   LWORKC = dtmp;
   WORKC = malloc(ATL_MulBySize(LWORKC));

   if(PRINT_2) printf("Input to ORM routine cM=%d cN=%d K=%d\n",
                                     cM, cN, MNmin);
   #ifdef ormFtime
   t0 = time00();
   #endif
   ATL_assert(!LA_QR2Q(SIDE, TRANS, cM, cN, MNmin, A, lda, TAU,
                                 CF, ldc));
   #ifdef ormFtime
   *time = time00() - t0;
   #endif

   #ifdef ormCtime
   t0 = time00();
   #endif
   ATL_ormqr(SIDE, TRANS, cM, cN, MNmin, A, lda,
                                 TAU, C, ldc, WORKC,  LWORKC);
   #ifdef ormCtime
   *time = time00() - t0;
   #endif

   normC = Mjoin(PATL,genrm1)(cM, cN, C, ldc);
   resid  = Mjoin(PATL,gediffnrm1)(cM, cN, C, ldc, CF, ldc);

   resid /= (normC * eps * Mmin(cM, cN));

/* free */
   if (A)   free(A);
   if (C)   free(C);
   if (CF) free(CF);
   if (WORK)  free(WORK);
   if (WORKC)  free(WORKC);
   if (AORIG)  free(AORIG);

   return(resid);
}


int GetMyReps(int N, int *nreps)
/*
 * Finds the correct nreps for this N
 */
{
   int n, i;

   n = *nreps++;
   for (i=n+n-2; i>=0; i -= 2)
   {
      if (N >= nreps[i])
         return(nreps[i+1]);
   }
   return(nreps[1]);
}

int RunCase(TYPE thresh, int flushKB, int side, int uplo, int M, int N, int lda, char Cside, char Ctrans, int CsideSz)
/*
 * RETURNS: 0 if residual is <= thresh, otherwise 1
 */
{
   TYPE resid;
   TYPE (*qtest)(int, int, int, int, double*, char, char, int);
   double time;
   double Time2FlopsNew(int rout, int UPLO, int M, int N, double time, char  QSIDE, int CsideSize);
   char qs[4];

   qs[2] = '\0';
   if (side == LARight)
   {
      qs[0] = 'Q';
      if (uplo == LALower) { qtest = ORqltest; qs[1] = 'L'; }
      else { qtest = ORqrtest; qs[1] = 'R'; }
   }
   else
   {
      qs[1] = 'Q';
      if (uplo == LALower) { qtest = ORlqtest; qs[0] = 'L'; }
      else { qtest = ORrqtest; qs[0] = 'R'; }
   }
   resid = qtest(M, N, lda, flushKB, &time, Cside, Ctrans, CsideSz);
   printf("%2s  %3s %6d %6d %6d  %10.4e %11.2f  %9.2e\n", qs, "Col", M, N, lda,
          time, Time2FlopsNew(LAgeqrf, uplo+side, M, N, time, Cside, CsideSz), resid);
   return(resid <= thresh ? 1 : 0);
}

int RunCases(TYPE thresh, int flushKB, int ldagap, int *NREPS,
              int *sides, int *uplos, int *Ms, int *Ns, 
              char Cside, char Ctrans, int CsideSz)
/*
 * RETURNS: number of failed cases
 */
{
   int u, s, o, m, n, M, lda, npass=0, ntest=0, nreps, k;
   printf("Rt  Maj      M      N    lda        TIME       MFLOP   RESIDUAL\n");
   printf("==  ===  =====  =====  =====  ==========  ==========  =========\n");

   for (s=1; s <= sides[0]; s++)            /* loop over sides                */
   {
      for (u=1; u <= uplos[0]; u++)         /* loop over uplos                */
      {
         for (o=0; o < 1; o++)              /* useless order loop, add later  */
         {
            for (n=1; n <= Ns[0]; n++)
            {
               for (m=1; m <= Ms[0]; m++)
               {
                  M = (Ms[m]) ? Ms[m]:Ns[n];
                  nreps = GetMyReps(Mmin(M, Ns[n]), NREPS);
                  for (k=0; k < nreps; k++)
                  {

                     npass += RunCase(thresh, flushKB, sides[s], uplos[u],

//orig QR -QL
//                                      M, Ns[n], M+ldagap,  'L', 'N', 100);
//                                      M, Ns[n], M+ldagap,  'L', 'T', 100);
//orig RQ -LQ
//                                      M, Ns[n], M+ldagap,  'R', 'N', 100);
//                                      M, Ns[n], M+ldagap,  'R', 'T', 100);
                                      M, Ns[n], M+ldagap,  Cside, Ctrans, CsideSz);

                     ntest++;
                  }
               }
            }
         }
      }
   }
   printf("\n%d cases ran, %d cases passed\n\n", ntest, npass);
   return(ntest-npass);
}

#define CAN_NB 0
void PrintUsage(char *name, int ierr, char *flag)
{
   if (ierr > 0)
      fprintf(stderr, "Bad argument #%d: '%s'\n",
         ierr, flag ? flag : "Not enough arguments");
   else if (ierr < 0)
      fprintf(stderr, "ERROR: %s\n", flag);

   fprintf(stderr, "USAGE: %s [flags]:\n", name);
   fprintf(stderr, "      routs: geqrf, geqlf, gerqf, gelqf\n");
   fprintf(stderr, "   -T <thresh> : set residual error threshold\n");
   fprintf(stderr, "   -# <#> : repeat each timing # times\n");
   fprintf(stderr, "   -n <#> <N1> ... <N#>\n");
   fprintf(stderr, "   -N <Nstart> <Nend> <Ninc>\n");
   fprintf(stderr, "   -m <#> <M1> ... <M#>\n");
   fprintf(stderr, "   -M <Mstart> <Mend> <Minc>\n");
   fprintf(stderr, "   -a <ldagap> : lda = M + <ldagap> foreach M\n");
   fprintf(stderr, "   -f <flushKB> : flush at least this mem in LRU timers\n");
   fprintf(stderr, "   -S <#> <side1> ... <side#>\n");
   fprintf(stderr, "   -U <nuplo> <up1> ... <upN> : Vals: [u,l,q,g]\n");
   exit(ierr ? ierr : -1);
}

int *GetIntList1(int ival)
/*
 * returns integer array with iarr[0] = 1, iarr[1] = ival
 */
{
   int *iarr;
   iarr = malloc(2*sizeof(int));
   ATL_assert(iarr);
   iarr[0] = 1;
   iarr[1] = ival;
   return(iarr);
}

int *GetIntList2(int ival1, int ival2)
/*
 * returns integer array with iarr[0] = 1, iarr[1] = ival1, ival[2] = ival2
 */
{
   int *iarr;
   iarr = malloc(3*sizeof(int));
   ATL_assert(iarr);
   iarr[0] = 1;
   iarr[1] = ival1;
   iarr[2] = ival2;
   return(iarr);
}

int *GetIntList(int nargs, char **args, int i, int nmul)
/*
 * Gets a list of integers, whose length is given by atoi(args[i])*nmul
 * list is this length+1, since 0'th location gets atoi(args[i])
 */
{
   int n, *iarr, k;

   if (++i >= nargs)
      PrintUsage(args[0], i, NULL);
   n = atoi(args[i]) * nmul;
   ATL_assert(n > 0);
   iarr = malloc(sizeof(int)*(n+1));
   ATL_assert(iarr);

   iarr[0] = n / nmul;
   for (k=0; k < n; k++)
   {
      if (++i >= nargs)
         PrintUsage(args[0], i, NULL);
      iarr[k+1] = atoi(args[i]);
   }
   return(iarr);
}

int *RoutNames2IntList(int nargs, char **args, int i)
{
   int n, *iarr, k;

   if (++i >= nargs)
      PrintUsage(args[0], i, NULL);
   n = atoi(args[i]);
   ATL_assert(n > 0);
   iarr = malloc(sizeof(int)*(n+1));
   ATL_assert(iarr);

   iarr[0] = n;
   for (k=0; k < n; k++)
   {
      if (++i >= nargs)
         PrintUsage(args[0], i, NULL);
      if (!strcmp(args[i], "getrf") || !strcmp(args[i], "GETRF"))
         iarr[k+1] = LAgetrf;
      else if (!strcmp(args[i], "potrf") || !strcmp(args[i], "POTRF"))
         iarr[k+1] = LApotrf;
      else if (!strcmp(args[i], "geqrf") || !strcmp(args[i], "GEQRF"))
         iarr[k+1] = LAgeqrf;
      else if (!strcmp(args[i], "geqlf") || !strcmp(args[i], "GEQLF"))
         iarr[k+1] = LAgeqrf;
      else if (!strcmp(args[i], "gerqf") || !strcmp(args[i], "GERQF"))
         iarr[k+1] = LAgeqrf;
      else if (!strcmp(args[i], "gelqf") || !strcmp(args[i], "GELQF"))
         iarr[k+1] = LAgeqrf;
      else
         PrintUsage(args[0], i, args[i]);
   }
   return(iarr);
}

int *IntRange2IntList(int N0, int NN, int incN)
{
   int i, n;
   int *iarr;

   for (i=N0, n=0; i <= NN; i += incN) n++;
   iarr = malloc(sizeof(int)*(n+1));
   ATL_assert(iarr);
   iarr[0] = n;
   for (i=N0, n=1 ; i <= NN; i += incN, n++)
      iarr[n] = i;
   return(iarr);
}

void GetFlags(int nargs, char **args, int *flsizeKB, TYPE *thresh,
              int **nreps, int *ldagap, int **Ms, int **Ns,
              int **UPLOs, int **SDs,
              char  *cside,
              char *ctrans, 
              int *csideSz)
{
   int *NBs=NULL, *ns=NULL, *ms=NULL, *ups=NULL, *sds=NULL, *ip;
   int i, k, n;

   *ldagap = 0;
   *flsizeKB = L2SIZE/1024;
   *nreps = NULL;
    *thresh = 100.0;
   /* Temporary Setting For ormm Matrix  C */
   *cside  = 'L';
   *ctrans = 'N';
   *csideSz = 100;
   for (i=1; i < nargs; i++)
   {
      if (args[i][0] != '-')
         PrintUsage(args[0], i, args[i]);
      switch(args[i][1])
      {
      case 'T':
         if (++i >= nargs)
            PrintUsage(args[0], i, NULL);
         *thresh = atof(args[i]);
         break;
      case 'n':                             /* -n or -nb                      */
         ns = GetIntList(nargs, args, i, 1);
         i += ns[0] + 1;
         break;
      case 'm':                             /* -m # <M1> ... <M#>             */
         ms = GetIntList(nargs, args, i, 1);
         i += ms[0] + 1;
         break;
      case 'N':                             /* -N or -NB                      */
      case 'M':                   /* -M <Mstart> <Mend> <Minc>\n");           */
         if (i+3 >= nargs)
            PrintUsage(args[0], i, NULL);
         ip = IntRange2IntList(atoi(args[i+1]),atoi(args[i+2]),atoi(args[i+3]));
         if (args[i][0] == 'M')
            ms = ip;
         else if (args[i][2] == 'B')        /* -NB <NBstart> <NBend> <NBinc>  */
            NBs = ip;
         else                     /* -N <Nstart> <Nend> <Ninc>\n");           */
            ns = ip;
         i += 3;
         break;
      case '#':                             /* set nreps                      */
         if (args[i][2] == 't')             /* -#t N1 reps1 ... Nt repst      */
         {
            *nreps = GetIntList(nargs, args, i, 2);
            i += ((*nreps)[0] << 1) + 1;
         }
         else                               /* -# <reps>                      */
         {
            if (++i >= nargs)
               PrintUsage(args[0], i, NULL);
            *nreps = GetIntList2(0, atoi(args[i]));
         }
         break;
      case 'f':                             /* -f <flushKB>                   */
         if (++i >= nargs)
            PrintUsage(args[0], i, NULL);
         *flsizeKB = atoi(args[i]);
         break;
      case 'U':                   /* -U <nup> <u1> ... <uN>;[u,l,q,g]         */
         if (++i >= nargs)
            PrintUsage(args[0], i, NULL);
         n = atoi(args[i]);
         ATL_assert(n > 0);
         ups = malloc(sizeof(int)*(n+1));
         ups[0] = n;
         for (k=0; k < n; k++)
         {
            if (++i >= nargs)
               PrintUsage(args[0], i, NULL);
            switch(args[i][0])
            {
            case 'U':
            case 'u':
               ups[k+1] = LAUpper;
               break;
            case 'l':
            case 'L':
            default:
               ups[k+1] = LALower;
               break;
            }
         }
         break;
      case 'S':                             /* -S <#> <side1> ... <sideN>     */
         if (++i >= nargs)
            PrintUsage(args[0], i, NULL);
         n = atoi(args[i]);
         ATL_assert(n > 0);
         sds = malloc(sizeof(int)*(n+1));
         sds[0] = n;
         for (k=0; k < n; k++)
         {
            if (++i >= nargs)
               PrintUsage(args[0], i, NULL);
            switch(args[i][0])
            {
            case 'L':
            case 'l':
               sds[k+1] = LALeft;
               break;
            default:
               sds[k+1] = LARight;
               break;
            }
         }
         break;
      case 'a':                             /* -a <ldagap>                    */
         if (++i >= nargs)
            PrintUsage(args[0], i, NULL);
         *ldagap = atoi(args[i]);
         break;
      case 'x':                         /* -x L      -x R      side for Q */
         if (++i >= nargs)
            PrintUsage(args[0], i, NULL);
         *cside = args[i][0];
         break;
      case 'y':                         /* -y T      -y T      trans  Q */
         if (++i >= nargs)
            PrintUsage(args[0], i, NULL);
         *ctrans = args[i][0];
         break;
      case 'z':                         /* -z <size> */
         if (++i >= nargs)
            PrintUsage(args[0], i, NULL);
         *csideSz =  atoi(args[i]);
         break;
      default:
         PrintUsage(args[0], i, args[i]);
      }
   }
/*
 * Take default values
 */
   if (!(*nreps))
      *nreps = GetIntList2(0, 1);
   if (!ns)
      ns = GetIntList1(1000);
   if (!ms)
      ms = GetIntList1(0);
   if (!ups)
      ups = GetIntList1(LAUpper);
   if (!sds)
      sds = GetIntList1(LARight);

   *Ns = ns;
   *Ms = ms;
   *UPLOs = ups;
   *SDs = sds;
}

double GetFlopCount(enum ATL_LAROUT rout, enum ATL_LAFLG flags,
                     int M, int N, int KL, int KU, int nb)
/*
 * These numbers copied from LAPACK timer routines TIMING/[EIG,LIN]/dopla[2].f
 */
{
   double m=(M?M:N), n=N, kl=KL, ku=ku, mn;
   double adds=0.0, muls=0.0;

   if (rout & LAgetrf)
   {
      mn = (m >= n) ? n : m;                /* mn = MIN(M,N)                  */
      adds = mn * ( m*n-(m+n)*(mn+1.0)/2.0 + (mn+1.0)*(2.0*mn+1.0)/6.0 );
      muls = adds + mn * ( m-(mn+1.0)/2.0 );
   }
   else if (rout & LAgeqrf)
   {
      if (flags & LARight)                  /* LAgeqrf || LAgeqlf             */
      {
         if (M >= N)
         {
            muls = n*( ((23.0/6.0)+m+(n/2.0)) + n*(m-(n/3.0)) );
            adds = n*( (5.0/6.0) + n*((1.0/2.0) + (m-(n/3.0))) );
         }
         else
         {
            muls = m*( ((23.0/6.0) + 2.0*n - (m/2.0)) + m*(n-(m/3.0)) );
            adds = m*( (5.0/6.0) + n - (m/2.0) + m*(n-(m/3.0)) );
         }
      }
      else                                  /* LAgerqf || LAgelqf             */
      {
         if (M >= N)
         {
            muls = n*( ((29.0/6.0) + m + n/2.0) + n*(m-n/3.0) );
            adds = n*( (5.0/6.0) + m + n*(-0.5 + (m - n/3.0)) );
         }
         else
         {
            muls = m*( ((29.0/6.0) + 2.0*n - 0.5*m) +m*(n - m/3.0) );
            adds = m*( (5.0/6.0) + 0.5*m + m*(n - m/3.0) );
         }
      }
   }
    else if (rout & LAormqr)
    {
    }
   else if (rout & LApotrf)
   {
      muls = m*( (1.0/3.0) + m*((1.0/2.0) + (m/6.0)) );
      adds = (1.0/6.0)*m*(-1.0+m*m);
   }
   #if defined (SCPLX) || defined(DCPLX)
      return(2.0*adds + 6.0*muls);
   #else
      return(adds+muls);
    #endif
}


double Time2FlopsNew(int rout, int UPLO, int M, int N, double time, char QSIDE, int csideSz )
{
   double mflop;
   int cM, cN; 

   
//ORlqtest
//   if( Cside == 'L')
//   {
//         cM = N;
//         cN = CsideSz;
//   }
//   else
//   {
//         cM = CsideSz;
//         cN = N;
//   }
//
//ORqltest
//   if( Cside == 'L')
//   {
//         cM = M;
//         cN = CsideSz;
//   }
//   else
//   {
//         cM = CsideSz;
//         cN = M;
//   }
//
//ORrqtest
//   if( Cside == 'L')
//   {
//         cM = N;
//         cN = CsideSz;
//   }
//   else
//   {
//         cM = CsideSz;
//         cN = N;
//   }
//
//ORqrtest
//   if( Cside == 'L')
//   {
//         cM = M;
//         cN = CsideSz;
//   }
//   else
//   {
//         cM = CsideSz;
//         cN = M;
//   }
   mflop = GetFlopCount(rout, UPLO, M, N, 0, 0, CAN_NB);
   if (mflop > 0)
      mflop /= time*1e6;          /* translate flops & time to MFLOPS         */
   return(mflop);
}

int main(int nargs, char **args)
{
   int *Ns, *Ms, *nreps, *UPLOs, *SDs;
   int flushKB, ldagap;
   TYPE thresh;

   char cside, ctrans;
   int  csideSz ;
   GetFlags(nargs, args, &flushKB, &thresh, &nreps, &ldagap, &Ms, &Ns,
            &UPLOs, &SDs, &cside, &ctrans, &csideSz);

  printf ("cside   = %c   ctrans = %c  csidesz = %d \n", cside, ctrans, csideSz); 
   return(RunCases(thresh, flushKB, ldagap, nreps, SDs, UPLOs, Ms, Ns, cside, ctrans, csideSz));
}

@ROUT ATL_tgeqr2
@extract -b @(topd)/cw.inc lang=C -def cwdate 2009 -def cwauth "Siju Samuel" -def contrib "Anthony M. Castaldo, R. Clint Whaley"
/*
 * This is the C translation of the standard LAPACK Fortran routine:
 *      SUBROUTINE DGEQR2( M, N, A, LDA, TAU, WORK, INFO )
 *
 * Reference :
 *      Scaling LAPACK Panel Operations Using Parallel Cache Assignment
 *          Principles and Practice of Parallel Programming (PPoPP)' 10
 *          Jan 9-14, 2010, Bangalore, India
 *            by   Anthony M. Castaldo,  R.Clint Whaley
 *
 * ATL_tgeqr2.c :
 *
 * int ATL_geql2_t( const int M, const int N, TYPE *A, int LDA,
 *                             TYPE  *TAU, TYPE *WORK)
 *     NOTE :a)  ATL_tgeqr2.c will get compiled to four precisions
 *               single precision real,      double precision real
 *               single precision complex,   double precision complex
 *
 *           b) This routine will not validate the input parameters.
 *
 *
 *  Purpose
 *  =======
 *
 *  A = Q * R.
 *
 *  Arguments
 *  =========
 *
 *  M       (input) INTEGER
 *          The number of rows of the matrix A.  M >= 0.
 *
 *  N       (input) INTEGER
 *          The number of columns of the matrix A.  N >= 0.
 *
 *  A       (input/output) array, dimension (LDA,N)
 *          On entry, the m by n matrix A.
 *          On exit, the elements on and above the diagonal of the array
 *          contain the min(m,n) by n upper trapezoidal matrix R (R is
 *          upper triangular if m >= n); the elements below the diagonal,
 *          with the array TAU, represent the orthogonal matrix Q
 *          (unitary matrix incase of complex precision )  as a
 *          product of elementary reflectors (see Further Details).
 *
 *  LDA     (input) INTEGER
 *          The leading dimension of the array A.  LDA >= max(1,M).
 *
 *  TAU     (output) array, dimension (min(M,N))
 *          The scalar factors of the elementary reflectors (see Further
 *          Details).
 *
 *  WORK    (workspace)  array, dimension (N)
 *
 *  INFO    (output) INTEGER
 *          = 0: successful exit
 *          < 0: if INFO = -i, the i-th argument had an illegal value
 *
 *  Further Details
 *  ===============
 *
 *  The matrix Q is represented as a product of elementary reflectors
 *
 *     Q = H(1) H(2) . . . H(k), where k = min(m,n).
 *                                             (for Real/Complex Precision)
 *  Each H(i) has the form
 *
 *     H(i) = I - tau * v * v'                 (for Real Precision)
 *     H(i) = I - tau * v * conjugate(v)'      (for Complex  Precision)
 *
 *  where tau is a real/complex  scalar, and v is a real/complex vector with
 *  v(1:i-1) = 0 and v(i) = 1; v(i+1:m) is stored on exit in A(i+1:m,i),
 *  and tau in TAU(i).
 *
 *
 * Threads are managed as below.  Instead of having
 * thread zero manage the computation by specifying tasks to workers, we
 * have workers proceed automatically to their next task; looping through
 * each of the columns on their own and only synchronizing when necessary.
 *
 * We launch and join as below. For example:
 *
 * Core To Thread Mapping
 *
 * Core  Binary  Reversed  Decimal   Busy Map
 *  0     000      000      0        X.......
 *  1     001      100      4        X...X...
 *  2     010      010      2        X.X.X...
 *  3     011      110      6        X.X.X.X.
 *  4     100      001      1        XXX.X.X.
 *  5     101      101      5        XXX.XXX.
 *  6     110      011      3        XXXXXXX.
 *  7     111      111      7        XXXXXXXX
 *
 * Worker Thread assigned  as below : (siju check it is thread or core ? TODO)
 *
 * Thread Binary  #ofTrailing  ReplaceTrailing      Waits for
 *                zeroes       bits by 1            (+ core)
 *
 *  0     000      3          +1 +2 +4             1  2 4
 *  1     001      0              _                   _
 *  2     010      1          +1                   3
 *  3     011      0              _                   _
 *  4     100      2          +1 +2                5  6
 *  5     101      0              _                   _
 *  6     110      1          +1                   7
 *  7     111      0              _                   _
 *
 *  There is no trivial non-looping method of reversing the binary digits,
 *  so we use an integer array for the indices, and another array to keep
 *  track of working cores. The join operation for a node just skips the
 *  core if it is inactive.
 *
 *  For example, core 0 must join 1, 2, 4, but if only three threads were
 *  engaged, it skips the join on thread 1, joins 2, and then joins 4.
 *  Thread 2 would normally need to combine 3, but since 3 is inactive, it
 *  (Thread 2) will just post itself done immediately.
 *
 *  This approach balances the binary tree and lets us use our existing
 *  join method.
 */


#include "stdio.h"
#include "cblas.h"
#include "atlas_tlapack.h"
#include "atlas_lapack.h"
#include "atlas_threads.h"
#include "atlas_tlvl3.h"
#include "atlas_level2.h"
#include "atlas_lamch.h"
#include "math.h"
#include "errno.h"

#ifdef TREAL
   static const TYPE ONE = ATL_rone;
#else
   static const TYPE ONE[2] = {ATL_rone, ATL_rzero};
#endif

#define  MY_align 64                        /* ONLY powers of 2 work.         */

#ifdef  SREAL
   #define  MY_gemv ATL_sgemv               /* L2 tuned dgemv                 */
   #define  MY_trmv ATL_strmv               /* L2 tuned dgemv                 */
   #define  MY_gemvT  ATL_sgemvT_L2         /* L2 tuned dgemv                 */
   #define  MY_gemvN  ATL_sgemvN            /* L2 tuned dgemv                 */
   #define  ATL_axpy ATL_saxpy
   #define  MY_ger  ATL_sger_L2             /* L2 tuned dger                  */
   #define MY_gecopy ATL_sgecopy            /* Copy routine to use.           */
#endif
#ifdef  DREAL
   #define  MY_gemv_Tony  ATL_dgemv_L2      /* L2 tuned dgemv */
   #define  MY_trmv ATL_dtrmv               /* L2 tuned dgemv                 */
   #define  MY_gemvT  ATL_dgemvT_L2         /* L2 tuned dgemv                 */
   #define  MY_gemvN  ATL_dgemvN            /* L2 tuned dgemv                 */
   #define  ATL_axpy ATL_daxpy
   #define  MY_ger  ATL_dger_L2             /* L2 tuned dger                  */
   #define MY_gecopy ATL_dgecopy            /* Copy routine to use.           */
#endif
#ifdef  SCPLX
   #define  MY_trmv ATL_ctrmv               /* L2 tuned dgemv                 */
   #define  MY_gemvT  ATL_cgemvCT_L2        /* L2 tuned dgemv                 */
   #define  MY_gemvN  ATL_cgemvN            /* L2 tuned dgemv                 */
   #define  ATL_axpy ATL_caxpy
   #define  MY_gemv ATL_cgemv               /* L2 tuned dgemv                 */
   #define  MY_ger  ATL_cgerc_L2            /* L2 tuned dger                  */
   #define MY_gecopy ATL_cgecopy            /* Copy routine to use.           */
#endif
#ifdef  DCPLX
   #define  MY_trmv ATL_dtrmv               /* L2 tuned dgemv                 */
   #define  MY_gemvT  ATL_zgemvCT_L2        /* L2 tuned dgemv                 */
   #define  MY_gemvN  ATL_zgemvN            /* L2 tuned dgemv                 */
   #define  ATL_axpy ATL_zaxpy
   #define  MY_gemv ATL_zgemv               /* L2 tuned dgemv                 */
   #define  MY_ger  ATL_zgerc_L2            /* L2 tuned dger                  */
   #define MY_gecopy ATL_zgecopy            /* Copy routine to use.           */
#endif

#ifdef TREAL
    #define MY_TRANS CblasTrans
#else
    #define MY_TRANS CblasConjTrans
#endif


#define ATL_ger_L2 Mjoin(PATL,ger_L2)
#define ATL_geqr2_dnrm2 Mjoin(PATL,geqr2_dnrm2)
#define ATL_geqr2_LC_Setup Mjoin(PATL,geqr2_LC_Setup)
#define ATL_geqr2_DoCopy Mjoin(PATL,geqr2_DoCopy)
#define ATL_geqr2_UnCopy Mjoin(PATL,geqr2_UnCopy)
#define ATL_geqr2_Cache Mjoin(PATL,geqr2_Cache)
#define ATL_geqr2Worker Mjoin(PATL,geqr2Worker)
#define ATL_geqr2Worker_Zero Mjoin(PATL,geqr2Worker_Zero)
#define ATL_tgeqr2 Mjoin(PATL,tgeqr2)
#define ATL_geqr2_Order Mjoin(PATL,geqr2_Order)

double time00(void);                        /* prototype external rtn.        */
/*----------------------------------------------------------------------------*/
/* rdtsc reads the time stamp counter into %rax, which will be aliased as a   */
/* temp for the memory location 'time' which MUST be a long long location!!!  */
/* This takes about 30 cycles to complete.                                    */
/*----------------------------------------------------------------------------*/
#define rdtsc(time)                 \
   __asm__ __volatile__ (           \
      "rdtsc;\n\t"                  \
      "shlq $32, %%rdx;\n\t"        \
      "addq %%rdx, %%rax;\n\t"      \
      : "=a"(time) : : "%rdx" );


/*----------------------------------------------------------------------------*/
/* Align the code.                                                            */
/*----------------------------------------------------------------------------*/
#define asmalign                    \
   __asm__ __volatile__ (           \
      ".align 4096;\n\t"            \
      : : : "%eax" )

//int ATL_geqr2_Order[ATL_NTHREADS]={0,4,2,6,1,5,3,7};
//int ATL_geqr2_Order[ATL_NTHREADS]={0,2,1,3};

typedef struct                              /* Threading structure.           */
{
   ATL_INT  fullM;
   ATL_INT  fullN;
   ATL_INT  myM;
   ATL_INT  myN;
   ATL_INT  myK;
   ATL_INT  lda;
   ATL_INT  rank;
   volatile ATL_INT  dnrm2;
   volatile ATL_INT  dgemv;
   ATL_INT  active;
   TYPE     *A;
#ifdef TREAL
   volatile TYPE     zDiag;
#else
   volatile TYPE  zDiag[2];
#endif
   TYPE     *TAU;
   TYPE     *oldA;
   ATL_INT  oldLDA;
   TYPE     *WORK;
   volatile TYPE     Scale;
   volatile TYPE     SSQ;
   TYPE     *T;
   ATL_INT  LDT;
   ATL_INT  buildT;
   volatile ATL_INT  dgemvt;
   ATL_INT  copy;
} ATL_DGEQR2_t;

/* This code is used three times below, macro to prevent bug propagation.     */
#define dnrm2_combine \
   if (myTS->Scale > ptnr->Scale)   /* If my scale is bigger,  */ \
   {                                                              \
      w = (ptnr->Scale)/(myTS->Scale); /* Must scale his SSQ.  */ \
      myTS->SSQ += (ptnr->SSQ)*w*w; /* Add scaled version.     */ \
   } else                           /* His scale is bigger.    */ \
   {                                                              \
      w = (myTS->Scale)/(ptnr->Scale); /* Must scale my SSQ.   */ \
      myTS->SSQ *= (w*w);           /* Scale my SSQ first.     */ \
      myTS->SSQ += ptnr->SSQ;       /* Add his to mine.        */ \
      myTS->Scale = ptnr->Scale;    /* Replace my SSQ with his.*/ \
   }                                        /* END #define dnrm2_combine      */


//double dgeqr2_SAFMIN=-1.;

/*-----------------------------------------------------------------------------
 * ATL_dgeqr2_dnrm2: Compute a dnrm2, but retain scale and value.
 *---------------------------------------------------------------------------*/

static void ATL_geqr2_dnrm2(ATL_DGEQR2_t *ts)
{
   int i,  N=ts->myM, N2;
   #ifdef TREAL
      N2 = N ;
   #else
      N2 = N << 1;
   #endif
   TYPE  aX, sX, SSQ=0., Scale=1.0;
   TYPE *X=ts->A+(((ts->lda) SHIFT)*(ts->myK));

   if (ts->rank != 0)                       /* If a standard compute,         */
   {
      for (i=0; i<N2; i++)                  /* Do the full column.            */
      {
         if (X[i] != 0.)
         {
            aX = fabs(X[i]);
            if (Scale < aX)
            {
               SSQ = 1.+SSQ*(Scale/aX)*(Scale/aX);
               Scale = aX;
            } else
            {
               SSQ += (aX/Scale)*(aX/Scale);
            }
         } //for
      }
   } else                                   /* This is the Rank 0 Operation   */
   {
      i = ((ts->myK) SHIFT) +(1 SHIFT);     /* Might as well shortcut.        */
      for (; i<N2; i++)                     /* 'i' already initialized.       */
      {
         if (X[i] != 0.)
         {
            aX = fabs(X[i]);
            if (Scale < aX)
            {
               sX = Scale/aX;               /* Do scale only once.            */
               SSQ = 1.+SSQ*sX*sX;          /* Scale SSQ.                     */
               Scale = aX;                  /* Use the new Scale.             */
            } else
            {
               sX = aX/Scale;               /* Scale the value.               */
               SSQ += sX*sX;                /* Square and add to SSQ.         */
            }
         }
      }//for
   }

   ts->Scale = Scale;
   ts->SSQ   = SSQ;
//    fprintf(stderr, "scale %f ssq %f \n", Scale, SSQ );
}                                           /* END ATL_dgeqr2_dnrm2           */


/*
 * LC_Setup sets up copy.
 */
static size_t ATL_geqr2_LC_Setup(ATL_DGEQR2_t *myTS)
{
   int N = myTS->fullN;                     /* width of array.                */
   int M = myTS->myM;                       /* height of array.               */
   myTS->oldLDA = myTS->lda;                /* Remember the old one.          */
   myTS->oldA   = myTS->A;                  /* ...                            */
   int LDA = (M+1)&(-2);                    /* My new LDA, multiple 2.        */
   myTS->lda = LDA;                         /* Store new LDA.                 */
   size_t memSize = ((LDA SHIFT)*N*sizeof(TYPE));/* Room I need.              */
   memSize = (memSize+MY_align-1)&(-MY_align);   /* As multiple of MY_align.  */
   return(memSize);                         /* Exit with amt needed.          */
}                                           /* ** END ATL_geqr2_LC_Setup **   */


/*
 * DoCopy works from LC_Setup.
 */
static void ATL_geqr2_DoCopy(ATL_DGEQR2_t *myTS)
{
   int N = myTS->fullN;                         /* width of array.            */
   int M = myTS->myM;                           /* height of array.           */

   #ifdef BUILD_LQ2    
   Mjoin(PATL,gemoveT)(M, N, ONE, myTS->oldA,   /* First arg is source,       */
         myTS->oldLDA, myTS->A, myTS->lda);     /* This is destination.       */
   #else
   MY_gecopy(M, N, myTS->oldA, myTS->oldLDA,    /* First arg is source,       */
   myTS->A, myTS->lda);                         /* This is destination.       */
   #endif
}  /* END ATL_geqr2_DoCopy. */


/*
 * UnCopy is just a copy back, no free.
 */
static void ATL_geqr2_UnCopy(ATL_DGEQR2_t *myTS)
{
   int N = myTS->fullN;                         /* width of array.            */
   int M = myTS->myM;                           /* height of array.           */
   #ifdef BUILD_LQ2                                
   Mjoin(PATL,gemoveT)(N, M , ONE,myTS->A,      
                       myTS->lda, myTS->oldA, myTS->oldLDA);  
   #else                                           
   MY_gecopy(M, N, myTS->A, myTS->lda,          
   myTS->oldA, myTS->oldLDA);                   
   #endif                                          
   myTS->lda = myTS->oldLDA;                    /* Restore the old one.       */
   myTS->A = myTS->oldA;                        /* ...                        */
}  /* END ATL_geqr2_UnCopy. */


/*
 * Cache will force a read every 64th byte (eighth double) in an array,
 * following LDA.
 */
static void ATL_geqr2_Cache(ATL_DGEQR2_t *myTS)
{
   int r, c;
   int N = myTS->fullN;                     /* width of array.                */
   int M = myTS->myM;                       /* height of array.               */
   int LDA = myTS->lda;
   TYPE *A = myTS->A;
   volatile TYPE x;

   for (c=N-1; c>=0; c--)                   /* Every column, backwards.       */
   {
      for (r=((M-1) SHIFT); r>=0; r-=8)     /* every eighth double.           */
      {
         x = *(A+(LDA SHIFT)*c+r);          /* read the variable.             */
      }
   }
}                                           /* ** END ATL_dgeqr2_Cache **     */


/*
 * Callback for thread launcher
 */
static int Mjoin(PATL,StructIsInitGEQR2)(void *vp)
{
   //return 1;
   return(((ATL_DGEQR2_t*)vp)->active);
}


/*
 * ATL_geqr2Worker: Persistent for the duration of the DGEQR2 operation.
 * Argument is pointer to a structure which contains our data section.
 */
//void* ATL_geqr2Worker(void *myArg)
static void* ATL_geqr2Worker(ATL_LAUNCHSTRUCT_t *lp, void *vp)
{
   ATL_thread_t *tp = vp;
   ATL_DGEQR2_t *myTS = ((ATL_DGEQR2_t*) lp->opstruct)+tp->rank;
   ATL_DGEQR2_t *zTS = myTS - (myTS->rank);     /* Point at zero ts.         */
   int   zees, pair, myRank;                    /* Log2 looping variables.   */
   int   i,j,M,N,LDA,mScale,mUpdate,newN,KNT,LDT;
   int i_loop; 
   int   myCopy = myTS->copy;
   volatile ATL_DGEQR2_t *ptnr;                 /* partner log2 combine.     */
   TYPE  *A, *scaleA,  *T;                      /* Work variables.           */
   TYPE XNORM, BETA, BETAp;           
   TYPE *TAU = myTS->TAU;                       /* Short cut.                */
   TYPE ALPHA;
   TYPE w;                                      /* Used in dnrm2_combine mac.*/
   #ifdef TREAL
      const TYPE ONE = ATL_rone;
      TYPE AII ;
      TYPE TAUVAL ;
      TYPE myTAUi;
      TYPE sc;
      TYPE RSAFMN;
      const TYPE ZERO = ATL_rzero;
   #else
      const TYPE ONE[2] = {ATL_rone, ATL_rzero};
      TYPE AII[2];
      TYPE TAUVAL[2] ;
      TYPE myTAUi[2] ;
      TYPE negTAUi[2] ;

      TYPE ALPHAI, ALPHAR;
      TYPE ALPHADIV[2] ;
      TYPE sc[2];
      TYPE RSAFMN[2]; 
      const TYPE ZERO[2] = {ATL_rzero, ATL_rzero};
   #endif

   myRank = myTS->rank;                     /* Get my rank.                   */

   T = zTS->T;
   LDT = zTS->LDT;

/*----------------------------------------------------------------------------*/
/* Now we begin the real dgeqr2.                                              */
/*----------------------------------------------------------------------------*/
   N = myTS->fullN;                         /* panel width.                   */

   if (myCopy)
   {
      ATL_geqr2_DoCopy(myTS);                  /* Execute it.                 */
   }

   LDA = myTS->lda;                         /* Load AFTER local copy.         */
   M = myTS->myM;                           /* Shortcut to M.                 */

   for (i=0; i<N; i++)                      /* Now, for each column,          */
   {
      if (myRank == 0)                      /* Zero follows diagonal.         */
      {
         mScale = M-i-1;                    /* Special scaling value.         */
         mUpdate = M-i;                     /* Special gemv/ger size.         */
         A = myTS->A + (i SHIFT)+ (i* (LDA SHIFT));  /* Special pointer to A. */
         #ifdef TREAL
            myTS->zDiag = (*A);             /* Get the diagonal.              */
	         *A = 1.;
         #else
            myTS->zDiag[0] = (*A);
            myTS->zDiag[1] = *(A+1);
/*          Replace with one now.                                             */
            *(A) = 1.0;
            *(A+1) = 0.0;
         #endif
         scaleA = A+(1 SHIFT);              /* What to scale.                 */
      } else                                /* Others keep square.            */
      {
         mScale = M;                        /* Always scale full col.         */
         mUpdate = M;                       /* Always gemv/ger full co.       */
         A = myTS->A + (i*(LDA SHIFT));     /* Point at column.               */
         scaleA = A;                        /* What to scale.                 */
      }

      myTS->myK = i;                        /* Set my K value.                */

      ATL_geqr2_dnrm2(myTS);

      zees = myRank;                        /* Init the test flags.           */
      pair = 1;                             /* Starting pair.                 */
      while ( (zees & 1) == 0 &&            /* If I must wait on pair,        */
         (myRank)+pair < ATL_NTHREADS)      /* ..and pair exists,             */
      {
         ptnr = myTS+pair;                  /* Point at my partner.           */

         if (ptnr->active == 1)             /* If ptnr was used,              */
         {
            while (ptnr->dnrm2 <= myTS->dnrm2);  /* Wait for it.              */
               dnrm2_combine;
         }

         zees >>= 1;                        /* Shift a zero out.              */
         pair <<= 1;                        /* Double the pair idx.           */
      }

      myTS->dnrm2++;                        /* Signal I am done.              */

      /*************************************/
      /******  S Y N C   P O I N T  ********/
      /******  S Y N C   P O I N T  ********/
      /******  S Y N C   P O I N T  ********/
      /*************************************/
  
      /*-----------------------------------------------------------------*/
      /* Note: We can avoid syncing immediately after the DGER, but DGER */
      /* does use zTS->WORK as its vector. So here is the point where we */
      /* have to make sure everybody's DGER is done, and they have done  */
      /* their norm2 work. All threads converge here for the next column */
      /* and so will be done with their DGER, and zTS->WORK is free.     */
      /*-----------------------------------------------------------------*/
      while (zTS->dnrm2 < myTS->dnrm2);     /* Wait for zero to finish.       */

      /*-------------------------------------------------------------*/
      /* At this point, zTS->SSQ is computed. If it is zero, then no */
      /* rotation is needed, and TAU should be set to zero, and we   */
      /* just skip to the next column.                               */
      /* HOWEVER, core zero may be fast on the next compare, and     */
      /* change zTS->SSQ before some other core gets a chance to see */
      /* it was zero. So we must have a barrier here before we go on.*/
      /*                                                             */
      /* In Complex we require both SSQ == 0 and IMAG(A[i,i]) == 0.  */
      /*-------------------------------------------------------------*/
      /* If H should be Identity, set TAU to zero and go to next column. */
      #ifdef TREAL 
      if (zTS->SSQ == 0.)
      #else /* COMPLEX */
      if (zTS->SSQ == 0. && zTS->zDiag[1] == 0.)
      #endif /* REAL or CPLX */
      {
         zees = myRank;                     /* Init the test flags.           */
         pair = 1;                          /* Starting pair.                 */
         while ( (zees & 1) == 0 &&         /* If I must wait on pair,        */
            (myRank)+pair < ATL_NTHREADS)   /* ..and pair exists,             */
         {
            ptnr = myTS+pair;               /* Point at my partner.           */

            if (ptnr->active == 1)          /* If ptnr was used,              */
            {
               while (ptnr->dnrm2 <= myTS->dnrm2);  /* Wait for it.           */
            }

            zees >>= 1;                     /* Shift a zero out.              */
            pair <<= 1;                     /* Double the pair idx.           */
         }

         if (myRank == 0)                   /* Restore A[i,i] we replaced w 1.*/
         {
            #ifdef TREAL
            *(A) =  zTS->zDiag;
            TAU[i] = 0.;                    /* clear TAU so H[i]=Identity.    */
            #else
            *(A )  = zTS->zDiag[0];
            *(A+1) = zTS->zDiag[1];
            TAU[(i SHIFT)] = 0.;            /* clear TAU so H[i]=Identity.    */
            TAU[(i SHIFT)+1] = 0.;
            #endif
         }

         myTS->dnrm2++;                     /* Signal I am done.              */
         while (zTS->dnrm2 < myTS->dnrm2);  /* Wait for zero to finish.       */
         continue;                          /* ..Proceed to next column.      */
      } /* END if H=Identity no need to process column. */

/*----------------------------------------------------------------------------*/
/* Here, H is not identity, we 'continued' the loop if it was.                */
/*----------------------------------------------------------------------------*/
      XNORM = (zTS->Scale)*sqrt(zTS->SSQ);  /* Compute the norm.              */

      #ifdef TREAL
/*----------------------------------------------------------------------------*/
/*    The following code is inlined from ATL_larfg; the main difference is    */
/*    that we use zTS->zDiag instead of ALPHA, and recompute is parallel.     */
/*----------------------------------------------------------------------------*/
      BETAp = ATL_lapy2((zTS->zDiag), XNORM);    /* Get sqrt(a^2+b^2)         */
      BETA = BETAp;                              /* Assume diagonal < 0 ...   */
      if ((zTS->zDiag) >= 0.) BETA = -BETAp;     /* .. If >= 0, change sign.  */

      KNT = 0;                                   /* Init power to zero. */
      if (BETAp < ATL_laSAFMIN)
      {
         RSAFMN = ATL_rone / ATL_laSAFMIN;       /* Set a maximum. */

         /*---------------------------------------------------------------*/
         /* BETAp is the same for all cores, so this loop can be executed */
         /* independently. However, XNORM must be computed in concert.    */
         /* The new BETAp will be at most 1, at least SAFMIN.             */
         /*---------------------------------------------------------------*/
         while (BETAp < ATL_laSAFMIN)
         {
            KNT++;                              /* increment power. */
            if ( myTS->active == 1)             /* If I am active, */
            {
               cblas_scal(mScale, RSAFMN,  
                                    scaleA, 1); /* Scale my share. */
            }

            BETA *= RSAFMN;
            BETAp *= RSAFMN;
            if (myRank==0) zTS->zDiag *= RSAFMN;   /* Only done by core 0! */
         }

         ATL_geqr2_dnrm2(myTS);                /* Do my share of new norm2. */

         zees = myRank;                        /* Init the test flags.    */
         pair = 1;                             /* Starting pair.          */
         while ( (zees & 1) == 0 &&            /* If I must wait on pair, */
            (myRank)+pair < ATL_NTHREADS)      /* ..and pair exists,      */
         {
            ptnr = myTS+pair;                  /* Point at my partner.    */

            if (ptnr->active == 1)             /* If ptnr was used,       */
            {
               while (ptnr->dnrm2 <= myTS->dnrm2);  /* Wait for it.       */
                  dnrm2_combine;
            }

            zees >>= 1;                        /* Shift a zero out.       */
            pair <<= 1;                        /* Double the pair idx.    */
         }

         myTS->dnrm2++;                        /* Signal I am done.       */

         /*************************************/
         /******  S Y N C   P O I N T  ********/
         /******  S Y N C   P O I N T  ********/
         /******  S Y N C   P O I N T  ********/
         /*************************************/
         while (zTS->dnrm2 < myTS->dnrm2);         /* Wait on zero to finish. */
  
         XNORM = (zTS->Scale)*sqrt(zTS->SSQ);      /* Compute the norm. */
         BETAp = ATL_lapy2((zTS->zDiag), XNORM);   /* Get sqrt(a^2+b^2) */
         BETA = BETAp;                             /* Assume diagonal < 0 ... */
         if ((zTS->zDiag) >= 0.) BETA = 0.-BETAp;  /* ..If >= 0, change sign. */
      }

      myTAUi = (BETA-(zTS->zDiag)) / BETA;         /* Compute TAU[i]. */
      if (myRank == 0) TAU[i] = myTAUi;            /* Set if I own TAU. */

      sc = ATL_rone/((zTS->zDiag)-BETA);           /* Find scaling factor. */
      if ( myTS->active == 1)
      {
         cblas_scal(mScale, sc, scaleA, 1);        /* Scale the vector. */
      }

      if (myRank == 0)                             /* If I own diagonal, */
      {
         AII = BETA;                               /* Set new A[i,i] element. */
         for (j=0; j<KNT; j++)                     /* Rescaling loop...       */
            AII *= ATL_laSAFMIN;                   /* ...Adjust it.           */
      }

   #else /* COMPLEX VERSION of LARFG, modeled on clarfg.f. */
      ALPHAR =  zTS->zDiag[0];                     /* Real portion. */
      ALPHAI =  zTS->zDiag[1];                     /* Imaginary portion. */

      BETAp = ATL_lapy3(ALPHAR, ALPHAI, XNORM);    /* sqrt(a^2+b^2,c^2) */
      BETA = BETAp;                                /* Assume ALPHAR < 0.*/
      if (ALPHAR >= 0.) BETA = -BETAp;             /* If >=0, Change sign. */

      KNT = 0;                                     /* Init power to zero. */
      if (BETAp < ATL_laSAFMIN)
      {
         RSAFMN[0] = ATL_rone/ATL_laSAFMIN;        /* Set a maximum. */
         RSAFMN[1] = ATL_rzero;                    /* ..for scaling. */

         /*---------------------------------------------------------------*/
         /* BETAp is the same for all cores, so this loop can be executed */
         /* independently. However, XNORM must be computed in concert.    */
         /* The new BETAp will be at most 1, at least SAFMIN.             */
         /*---------------------------------------------------------------*/
         while (BETAp < ATL_laSAFMIN)
         {
            KNT++;                                 /* increment power. */
            if ( myTS->active == 1)                /* If I am active, */
            {
               cblas_scal(mScale, RSAFMN,  
                                    scaleA, 1);    /* Scale my share. */
            }

            BETA *= RSAFMN[0];
            BETAp *= RSAFMN[0];
            ALPHAR *= RSAFMN[0];
            ALPHAI *= RSAFMN[0];
         }

         ATL_geqr2_dnrm2(myTS);                /* Do my share of new norm2. */

         zees = myRank;                        /* Init the test flags.      */
         pair = 1;                             /* Starting pair.            */
         while ( (zees & 1) == 0 &&            /* If I must wait on pair,   */
            (myRank)+pair < ATL_NTHREADS)      /* ..and pair exists,        */
         {
            ptnr = myTS+pair;                  /* Point at my partner.      */

            if (ptnr->active == 1)             /* If ptnr was used,         */
            {
               while (ptnr->dnrm2 <= myTS->dnrm2);  /* Wait for it.         */
                  dnrm2_combine;
            }

            zees >>= 1;                        /* Shift a zero out.         */
            pair <<= 1;                        /* Double the pair idx.      */
         }

         myTS->dnrm2++;                        /* Signal I am done.         */

         /*************************************/
         /******  S Y N C   P O I N T  ********/
         /******  S Y N C   P O I N T  ********/
         /******  S Y N C   P O I N T  ********/
         /*************************************/
         while (zTS->dnrm2 < myTS->dnrm2);         /* Wait on zero to finish.*/
      
         XNORM = (zTS->Scale)*sqrt(zTS->SSQ);      /* Compute the norm. */
         BETAp = ATL_lapy3(ALPHAR, ALPHAI, XNORM); /* sqrt(a^2+b^2,c^2) */
         BETA = BETAp;                             /* Assume ALPHAR < 0.*/
         if (ALPHAR >= 0.) BETA = 0.-BETAp;        /* If >=0, Change sign. */
      }

      myTAUi[0] = (BETA-ALPHAR) / BETA;      /* Compute real part. */
      myTAUi[1] = (0.-ALPHAI) / BETA;        /* Compute imag part. */

      ALPHADIV[0] = ALPHAR - BETA;           /* prepare for 1/(alpha-beta) */
      ALPHADIV[1] = ALPHAI;                  /* ...                        */
      ATL_ladiv(ONE, ALPHADIV, sc);          /* compute scaling factor.    */
      if (myTS->active == 1)                 /* If I have some of vector,  */
      {
         cblas_scal(mScale, sc, scaleA, 1);  /* ..scale it. */
      }

      if (myRank == 0)                       /* If I own TAU, */
      {
         TAU[(i SHIFT)] = myTAUi[0];
         #ifdef BUILD_LQ2
            TAU[(i SHIFT) +1] = -myTAUi[1];  /* LQ2 needs conjugate. */
         #else
            TAU[(i SHIFT) +1] = myTAUi[1];   /* otherwise use normal. */
         #endif
      }

      if (myRank == 0)                       /* If I own diagonal, */
      {
         for (j=0; j<KNT; j++) BETA *= ATL_laSAFMIN;  /* Rescale BETA. */         
         AII[0] = BETA;                               /* save for later. */
         AII[1] = 0.0;
      }
   #endif /* COMPLEX version of larfg. */

/*----------------------------------------------------------------------------*/
/*   Now we apply dlarf, if we are not on the last column. This is            */
/*   a dgemv, followed by a dger, all presuming TAU is non-zero.              */
/*   The DGEMV: Column major, transpose A.                                    */
/*                                                                            */
/*   We must compute H(i)*C, where C is the trailing part of our panel        */
/*   at A[i..M-1, (i+1)..N-1]. So, C is (M-i) x (N-i-1).                      */
/*   H(i) = (I-TAU[i]* u * (transpose u)), by definition.                     */
/*   Where 'u' = A[i..M-1, i]. So, u is (M-i) x 1. We compute H(i)*C          */
/*   as C - TAU[i] * u * (transpose w), where w = (transpose C) * u           */
/*   (so that (transpose w) = (transpose u) * C.)                             */
/*   Thus, w is (N-i-1) x 1.                                                  */
/*                                                                            */
/*   Now, (transpose C) * u is just a GEMV. It produces a vector of           */
/*   (N-i-1) elements. Every core will produce its own copy, and they         */
/*   must be added together. Pictorially, the pieces look like this:          */
/*                                                                            */
/*   B R R R R R R R R      Q = finished part of column                       */
/*   Q B R R R R R R R      R = upper triangular part for column              */
/*   Q Q B R R R R R R      B = Betas (norm 2) stored on diagonal,            */
/*   Q Q Q 1 C C C C C      1 = forced unit (normally assumed)                */
/*   Q Q Q u C C C C C      u = vector that H(i) is computed by,              */
/*   Q Q Q u C C C C C      C = portion of panel to be updated.               */
/*   .     .     .                                                            */
/*   .     .     .          The '1' will later be replaced by BETA for        */
/*   .     .     .          the column 'u'.                                   */
/*   Q Q Q u C C C C C                                                        */
/*                                                                            */
/*   The second part, C += -TAU[i] * u * (transpose w), is just a GER.        */
/*   Each core can do its part independently. We are essentially              */
/*   dividing on M, not N, so every core needs (transpose w).                 */
/*                                                                            */
/*----------------------------------------------------------------------------*/

   #ifdef TREAL
      if (i < (N-1) && myTAUi != 0.)        /* If dlarf necessary,            */
   #else
      if (i < (N-1) )                       /* If dlarf necessary,            */
   #endif
      {
         newN = N-i-1;                      /* Width of update array & vect w.*/
         MY_gemvT(mUpdate, newN,
                  ONE, A+(LDA SHIFT), LDA, A, 1, ZERO, myTS->WORK, 1);      

/*----------------------------------------------------------------------------*/
/*       Now combine with other threads.                                      */
/*----------------------------------------------------------------------------*/
         zees = myRank;                     /* Init the test flags.           */
         pair = 1;                          /* Starting pair.                 */
         while ( (zees & 1) == 0 &&         /* If I must wait on pair,        */
                  (myRank)+pair <
                  ATL_NTHREADS)             /* ..and pair exists,             */
         {
            ptnr = myTS+pair;               /* Point at my partner.           */
            if (ptnr->active == 1)          /* If partner was used,           */
            {
               while (ptnr->dgemv < i);     /* Wait for it.                   */
               ATL_axpy(newN, ONE, ptnr->WORK, 1, myTS->WORK, 1); 
            }

            zees >>= 1;                     /* Shift a zero out.              */
            pair <<= 1;                     /* Double the pair idx.           */
         }

         myTS->dgemv = i;                   /* Say I finished dgemv.          */

         /***********************************/
         /******  S Y N C   P O I N T  ******/
         /******  S Y N C   P O I N T  ******/
         /******  S Y N C   P O I N T  ******/
         /***********************************/
         /*---------------------------------*/
         /* We can't start GER until all of */
         /* 'w' is finished. Wait for zero. */
         /*---------------------------------*/
         while (zTS->dgemv < i);            /* Wait for zero to build 'w'.    */

         /*---------------------------------*/
         /* 'w' now in WORK. Use for GER.   */
         /*---------------------------------*/
         #ifdef TREAL
         MY_ger(mUpdate, newN, 0.-myTAUi, A, 1, zTS->WORK, 1,                
                A+(LDA SHIFT), LDA);                
         #else
         negTAUi[0]= 0.0 - myTAUi[0];
         negTAUi[1]= 0.0 + myTAUi[1];       /* conjugate for complex          */

         MY_ger(mUpdate, newN, negTAUi, A, 1, zTS->WORK, 1,           
                A+(LDA SHIFT), LDA);           
         #endif

         /*-----------------------------------------------*/
         /* Once we finish it is safe for us to start our */
         /* next column and dnrm2 on our share. We  will  */
         /* sync up with other threads to complete that.  */
         /*-----------------------------------------------*/
      } /* END IF we needed to apply dlarf. */
      
      #ifdef TREAL
         if (myRank == 0) *A = AII;      /* Core 0, restore diag now.      */
      #else
         if (myRank == 0)
         {
            *(A ) = AII[0];              /* Core 0, restore diag now.      */
            *(A + 1) = AII[1];           /* Core 0, restore diag now.      */
         }
      #endif

      /*
       * for computing T,  for LQ replace myTAUi with correct TAU for the 
       * complex part. 
       */

      #ifdef TCPLX 
          #ifdef BUILD_LQ2 
                myTAUi[1] = 0.0 -  myTAUi[1];
          #endif
      #endif

      #ifdef TREAL                          /* TODO change later              */
      if (myTS->buildT && i == 0)           /* Simple store will work.        */
         *T = myTAUi;                       /* Just store it.                 */
      #else
      if(myTS->buildT && i == 0)            /* Simple store will work.        */
      {
         *(T) = myTAUi[0];
         *(T+1) = myTAUi[1];
      }
      #endif

      if (myTS->buildT && i > 0)            /* If I must work for T,          */
      {
/*----------------------------------------------------------------------------*/
/*       Building T is very similar to DLARF, except we use the other         */
/*       side of A. Here is the picture:                                      */
/*                                                                            */
/*       B R R R R R R R R      Q = finished part of column                   */
/*       Q B R R R R R R R      R = upper triangular part for column          */
/*       Q Q B R R R R R R      B = Betas (norm 2) stored on diagonal,        */
/*       Q Q Q 1 C C C C C      1 = forced unit (normally assumed)            */
/*       Q Q Q u C C C C C      u = vector that H(i) is computed by,          */
/*       Q Q Q u C C C C C      C = portion of panel to be updated.           */
/*       .     .     .                                                        */
/*       .     .     .                                                        */
/*       .     .     .                                                        */
/*       Q Q Q u C C C C C                                                    */
/*                                                                            */
/*       We must compute Q^T times u, so each thread does its part, and       */
/*       then we add them together. We don't know at this point if all        */
/*       threads have completed their dger, so we can't use WORK. But         */
/*       we can use WORK+N-i, because it is not in use at this time. So       */
/*       we build the vector in zTS->WORK+N-i, it is 'i' elements long,       */
/*       and then zero will copy that into the column T[0,i].                 */
/*                                                                            */
/*       From there, we let thread 0 (alone) do a DTRMV to update that        */
/*       vector with the previous T, and then store TAU[i] at T[i,i].         */
/*                                                                            */
/*       This presumes that the DTRMV is too small to parallelize; but        */
/*       if that assumption is wrong the DTRMV could be parallelized as       */
/*       well, in future work.                                                */
/*                                                                            */
/*       We must sync to add up the DGEMV for T, not after that.              */
/*                                                                            */
/*       Rank 0: A points at A[i,i] mUpdate=M-i  A-i*LDA=A[i,0]               */
/*       Rank X: A points at A[0,i] mUpdate=M    A-i*LDA=A[0,0]               */
/*----------------------------------------------------------------------------*/

         if (myRank == 0)                   /* Special case...                */
         {
            #ifdef TREAL
            AII = *A;                       /* Save diagonal element.         */
            *A = 1.0;                       /* Force to 1.                    */
            #else
            AII[0] = *(A) ;
            AII[1] = *(A+1);
            *(A ) = 1.0;                    /* Force to 1.                    */
            *(A + 1) = 0.0;                 /* Force to 1.                    */
            #endif
         }

         int os=(N+3)&(-4);                 /* Find even offset into work.    */

         #ifdef TREAL
         MY_gemvT(mUpdate, i, 0.-myTAUi, 
                  A-i*LDA, LDA, A, 1, 0.0, myTS->WORK+os, 1); 
         #else
              #ifdef BUILD_LQ2
                 negTAUi[0]= 0.0 + myTAUi[0];
                 negTAUi[1]= 0.0 - myTAUi[1]; /* conj for cplx Not required */
              #else
                 negTAUi[0]= 0.0 - myTAUi[0];
                 negTAUi[1]= 0.0 - myTAUi[1]; /* conj for cplx Not required */
              #endif
              MY_gemvT(mUpdate,  i, negTAUi, A-(i*(LDA SHIFT)), LDA,          
                       A, 1, ZERO, myTS->WORK+(os SHIFT), 1);       
            
          #ifdef BUILD_LQ2
		          for (i_loop = 0; i_loop < i; i_loop++)
		          {
		              (myTS->WORK+(os SHIFT))[(i_loop SHIFT) + 0] =
		                   0.0 - (myTS->WORK+(os SHIFT))[(i_loop SHIFT) + 0];
		          }
			  #endif
         #endif

/*----------------------------------------------------------------------------*/
/*       Now combine with other threads.                                      */
/*----------------------------------------------------------------------------*/
         zees = myRank;                     /* Init the test flags.           */
         pair = 1;                          /* Starting pair.                 */
         while ( (zees & 1) == 0 &&         /* If I must wait on pair,        */
                  (myRank)+pair <
                  ATL_NTHREADS)             /* ..and pair exists,             */
         {
            ptnr = myTS+pair;               /* Point at my partner.           */
            if (ptnr->active == 1)          /* If partner was used,           */
            {
               while (ptnr->dgemvt < i);    /* Wait for it.                   */
               ATL_axpy(i, ONE, ptnr->WORK+(os SHIFT), 1,    
                        myTS->WORK+(os SHIFT), 1);   
            }

            zees >>= 1;                     /* Shift a zero out.              */
            pair <<= 1;                     /* Double the pair idx.           */
         }

         myTS->dgemvt = i;                  /* Post my completion.            */

/*----------------------------------------------------------------------------*/
/*       Done with dgemv part, rest is                                        */
/*       all for thread 0 to get done.                                        */
/*----------------------------------------------------------------------------*/
         if (myRank == 0)
         {
            TYPE *src=zTS->WORK+(os SHIFT); /* Source vector.                 */
            TYPE *dst=T+(i*(LDT SHIFT));    /* Destination vector.            */
            #ifdef TREAL
            *A = AII;                       /* Restore saved value.           */
            #else
            *(A) = AII[0];                  /* Restore saved value.           */
            *(A +1) = AII[1];               /* Restore saved value.           */
            #endif
            for (j=0; j<(i SHIFT); j++)
            {
               *dst++ = *src++;             /* Copy value.                    */
            }

            cblas_trmv(CblasColMajor, CblasUpper, CblasNoTrans, CblasNonUnit,        
                        i, T, LDT, T+(i*(LDT SHIFT)), 1);                  

            /* Force TAU[i] on diagonal. */
            #ifdef TREAL
	         *(T+i+i*LDT)=myTAUi;
            #else
            *(T+(i SHIFT)+(i*(LDT SHIFT))    ) = myTAUi[0];
            *(T+(i SHIFT)+(i*(LDT SHIFT)) + 1) = myTAUi[1];
            #endif

         } /* END IF zero must update T. */
      } /* END IF building T. */
   } /* END FOR each column. */


/*----------------------------------------------------------------------------*/
/* If we copied, this will copy back.                                         */
/*----------------------------------------------------------------------------*/
   if (myCopy)
   {
      ATL_geqr2_UnCopy(myTS);               /* Do my copy back.               */
   }

   return(NULL);                            /* Implicit thread exit.          */
} /* END ATL_geqr2Worker() */


/**************************************************************************** */
/********************** M A S T E R   C O N T R O L L E R ******************* */
/**************************************************************************** */

/*----------------------------------------------------------------------------*/
/* The break-up: We divide on M, simply enough, in multiples of 4. If there   */
/* are less than 32*ATL_NTHREADS elements, we will not divide at all.         */
/*                                                                            */
/* Processor 0 is our master combiner. The jobs are to compute the norm,      */
/* and then apply the reflector to the array.                                 */
/*                                                                            */
/* To compute the norm, threads need SAFMIN. We compute it before any thread  */
/* launches if it is not already computed.                                    */
/*                                                                            */
/*----------------------------------------------------------------------------*/
#ifdef BUILD_LQ2    
#define ATL_tgexx2 Mjoin(PATL,tgelq2)
#else 
#define ATL_tgexx2 Mjoin(PATL,tgeqr2)
#endif 

int ATL_tgexx2(int M, int N, TYPE *A, int LDA, TYPE *TAU, TYPE *WORK,
                 TYPE *ws_T, int LDT, TYPE *WORKM, int buildT, int myCopy)
{

   ATL_DGEQR2_t ts[ATL_NTHREADS];
   long long t0, t1;

// fprintf (stderr,"______in %s M=%d  N=%d \n", Mstr(ATL_tgexx2), M,N);  
   if (M < 0)
   {
      fprintf(stderr, "%s: M<0 (%i)\n", Mstr(ATL_tgexx2), M);
      return(-1);
   }

   if (N < 0)
   {
      fprintf(stderr, "%s: N<0 (%i)\n", Mstr(ATL_tgexx2), N);
      return(-2);
   }

   #ifdef BUILD_LQ2   
   if (LDA < N) /*  N is the original M */
   {
      fprintf(stderr, "%s: LDA<M (%i, %i)\n", Mstr(ATL_tgexx2), LDA, M);
      return(-4);
   }
   #else
   if (LDA < M)
   {
      fprintf(stderr, "%s: LDA<M (%i, %i)\n", Mstr(ATL_tgexx2), LDA, M);
      return(-4);
   }
   #endif 


/*----------------------------------------------------------------------------*/
/* Preliminaries are done; now split up the problem.                          */
/* We use a data-owner split, each thread gets 1/p of the data,               */
/* and does all computation related to it.                                    */
/*----------------------------------------------------------------------------*/
   TYPE *myA = A, *myOldA = A, *allMem=NULL, *workMem;
   int i, j, k, b0, b, th;
   long unsigned int CPU;
   size_t mem[ATL_NTHREADS], totmem, workSize;

   th = ((M+N-1)/N);                        /* Max number of threads.         */
   if (th==0) th=1;                         /* Avoid divide by zero.          */
   if (th > ATL_NTHREADS) th=ATL_NTHREADS;  /* Limit on top.                  */

   b0 = (M/th);                             /* Find part for th zero.         */
   if (b0 < N) b0 = N;                      /* Take at least N.               */
   b = 0;
   if (th !=1)                              /* If multiple threads,           */
      b = ((M-b0) / (th-1) ) & (-4);        /* Split up the rest.             */
   b0 = M - (th-1)*b;                       /* Leftovers go to b0.            */
   if (b0 > b && b0 >= (N+(th-1)*4)) /* If b0 is biggest and can be smaller,  */
   {
      b += 4;                     /* Make the others slightly bigger.         */
      b0 -= (th-1)*4;             /* Core 0 has more overhead, do less.       */
   }

   if (b == 0) th = 1;
   if (th == 1 || (N> M))         /* If impossible to split, use serial. */
   {

      #ifdef BUILD_LQ2
      ATL_gelq2(N, M, A, LDA, TAU, WORK);   /* Use serial version.            */
      if (buildT)                           
      {
         ATL_larft(LAForward, LARowStore, M, N, A, LDA,  TAU, ws_T, LDT);
      }
      #else
      ATL_geqr2(M, N, A, LDA, TAU, WORK);    
      if (buildT)                            
      {
         ATL_larft(LAForward, LAColumnStore, M, N, A, LDA, TAU, ws_T, LDT);
      }
      #endif

      return(0);                            /* Exit after panel.              */
   }

/*----------------------------------------------------------------------------*/
/* Fill out the thread work areas.                                            */
/*----------------------------------------------------------------------------*/
   for (i=0; i<ATL_NTHREADS; i++)
   {
      ts[i].active=0;                       /* Nobody is active yet.          */
      mem[i] = 0;                           /* Nobody needs memory.           */
   }

   ts[0].fullM = M;                         /* Need full size M.              */
   ts[0].fullN = N;                         /* Need full size N.              */
   ts[0].myM = b0;                          /* Core 0 is special.             */
   ts[0].myN = N;                           /* Width is same for all.         */
   ts[0].myK = 0;                           /* First k for dnrm2.             */
   ts[0].lda = LDA;                         /* LDA is same for all.           */
   ts[0].rank = 0;                          /* Rank used by core 0.           */
   ts[0].A = myA;                           /* Core 0 gets top of A.          */
   ts[0].TAU = TAU;                         /* TAU is same for all.           */
   ts[0].dnrm2 = -1;                        /* Not done yet.                  */
   ts[0].dgemv = -1;                        /* Not done yet.                  */
   ts[0].active = 1;                        /* We are active.                 */
   ts[0].buildT = buildT;                   /* Pass in decision var.          */
   ts[0].T = ws_T;                          /* Pass in matrix addr.           */
   ts[0].LDT = LDT;                         /* And leading dimension.         */
   ts[0].dgemvt = -1;                       /* Not done yet.                  */
   ts[0].copy   = myCopy;                   /* Whether PCA should copy.       */
   #ifdef BUILD_LQ2   
   myA += (b0 SHIFT)*LDA;                   /* Point at next A, LQ.           */
   #else 
   myA += (b0 SHIFT);                       /* Point at next A, QR.           */
   #endif 

   for (i=1; i < th; i++)
   {
@skip      t =ATL_launchorder[i];
      ts[i].fullM = b;                      /* Remember whole M.              */
      ts[i].fullN = N;                      /* Need full size N.              */
      ts[i].myM = b;                        /* 'b' entries for all.           */
      ts[i].myN = N;                        /* Width is same for all.         */
      ts[i].myK = 0;                        /* First k for dnrm2.             */
      ts[i].lda = LDA;                      /* LDA is same for all.           */
      ts[i].rank = i;                       /* Rank of process.               */
      ts[i].A = myA;                        /* Point at share of A.           */
      ts[i].TAU = TAU;                      /* TAU is same for all.           */
      ts[i].dnrm2 = -1;                     /* Not done yet.                  */
      ts[i].dgemv = -1;                     /* Not done yet.                  */
      ts[i].active = 1;                     /* Indicate active.               */
      ts[i].buildT = buildT;                /* Pass in decision var.          */
      ts[i].dgemvt = -1;                    /* Not done yet.                  */
      ts[i].copy   = myCopy;                /* Whether PCA should copy.       */
      #ifdef BUILD_LQ2   
      myA += (b SHIFT)*LDA;                 /* Point at next share, LQ.       */
      #else 
      myA += (b SHIFT);                     /* Point at next share, QR.       */
      #endif
   }

/*----------------------------------------------------------------------------*/
/* Deal with memory.                                                          */
/*----------------------------------------------------------------------------*/
   if (myCopy)
   {
      totmem=MY_align;                         /* Needed for alignment.       */
      for (i=0; i<th; i++)
      {
         mem[i] = ATL_geqr2_LC_Setup(ts+i);    /* Find necessary memory.      */
         totmem += mem[i];                     /* Add to total.               */
      }

      allMem = malloc(totmem);                 /* Allocate the memory.        */

      ts[0].A = (TYPE*) (((size_t) allMem+MY_align)&(-MY_align));
      for (i=1; i<th; i++)                     /* Each thread takes..         */
      {
         ts[i].A = (TYPE*) ((size_t) ts[i-1].A + mem[i-1]);  /* ..next block. */
      }
   }

   workSize = ((2 SHIFT)*(N+4)*sizeof(TYPE) +
                     MY_align-1)&(-MY_align);    /* aligned.                  */
   totmem = MY_align + workSize*ATL_NTHREADS;    /* Find mem to alloc.        */
   workMem = malloc(totmem);
   ts[0].WORK = (TYPE*) (((size_t) workMem + MY_align-1)&(-MY_align));
   for (i=1; i<th; i++)
      ts[i].WORK = (TYPE*) ((size_t) ts[i-1].WORK + workSize);

/*----------------------------------------------------------------------------*/
/* Call ATL_launcher to launch thread which runs in different CPUs   cores    */
/*----------------------------------------------------------------------------*/

   ATL_goparallel(th, ATL_geqr2Worker, ts, NULL);
@beginskip
   ls.opstruct = (char*) ts;
   ls.opstructstride = (int) ( ((char*)(ts+1)) - (char*)(ts) );
   ls.CombineOpStructs = NULL;
   ls.OpStructIsInit = Mjoin(PATL, StructIsInitGEQR2);

   ls.DoWork = ATL_geqr2Worker;
   ls.rank2thr = tp;
   for (i=0; i < ATL_NTHREADS; i++)
   {
      tp[i].vp = &ls;
      tp[i].rank = i;
   }
   ATL_thread_start(tp, 0, ATL_tlaunch, tp);
   ATL_thread_join(tp);
@endskip


   if (allMem)
      free(allMem);                         /* release copied area.           */
   free(workMem);                           /* release work area.             */
   return(0);                               /* Done with dgeqr2.              */
}  /* END ATL_t_dgeqr2. */

@ROUT ATL_tgeql2
@extract -b @(topd)/cw.inc lang=C -def cwdate 2009 -def cwauth "Siju Samuel" -def contrib "Anthony M. Castaldo, R. Clint Whaley"
/*-----------------------------------------------------------------------------
 * This is the C translation of the standard LAPACK Fortran routine:
 *      SUBROUTINE DGEQL2( M, N, A, LDA, TAU, WORK, INFO )
 *
 * Reference :
 *      Scaling LAPACK Panel Operations Using Parallel Cache Assignment
 *          Principles and Practice of Parallel Programming (PPoPP)' 10
 *          Jan 9-14, 2010, Bangalore, India
 *            by   Anthony M. Castaldo,  R.Clint Whaley
 *
 * ATL_tgeql2.c :
 *
 * int ATL_geql2( const int M, const int N, TYPE *A, int LDA,
 *                             TYPE  *TAU, TYPE *WORK)
 *     NOTE :a)  ATL_geql2_t.c will get compiled to four precisions
 *               single precision real,      double precision real
 *               single precision complex,   double precision complex
 *
 *           b) This routine will not validate the input parameters.
 *
 *  Purpose
 *  =======
 *
 *  A = Q * L.
 *
 *  Arguments
 *  =========
 *
 *  M       (input) INTEGER
 *          The number of rows of the matrix A.  M >= 0.
 *
 *  N       (input) INTEGER
 *          The number of columns of the matrix A.  N >= 0.
 *
 *  A       (input/output) array, dimension (LDA,N)
 *          On entry, the m by n matrix A.
 *          On exit, if m >= n, the lower triangle of the subarray
 *          A(m-n+1:m,1:n) contains the n by n lower triangular matrix L;
 *          if m <= n, the elements on and below the (n-m)-th
 *          superdiagonal contain the m by n lower trapezoidal matrix L;
 *          the remaining elements, with the array TAU, represent the
 *          orthogonal matrix Q ((unitary matrix incase of complex precision )
 *          as a product of elementary reflectors (see Further Details).
 *
 *  LDA     (input) INTEGER
 *          The leading dimension of the array A.  LDA >= max(1,M).
 *
 *  TAU     (output) array, dimension (min(M,N))
 *          The scalar factors of the elementary reflectors (see Further
 *          Details).
 *
 *  WORK    (workspace) array, dimension (N)
 *
 *  INFO    (output) INTEGER
 *          = 0: successful exit
 *          < 0: if INFO = -i, the i-th argument had an illegal value
 *
 *  Further Details
 *  ===============
 *
 *  The matrix Q is represented as a product of elementary reflectors
 *
 *     Q = H(k) . . . H(2) H(1), where k = min(m,n).
 *                                             (for Real/Complex Precisions)
 *
 *  Each H(i) has the form
 *
 *     H(i) = I - tau * v * v'                 (for Real Precision)
 *     H(i) = I - tau * v * conjugate(v)'      (for Complex  Precision)
 *
 *
 *  where tau is a real scalar, and v is a real vector with
 *  v(m-k+i+1:m) = 0 and v(m-k+i) = 1; v(1:m-k+i-1) is stored on exit in
 *  A(1:m-k+i-1,n-k+i), and tau in TAU(i).
 *
 *
 *-------------------------------------------------------------------------
 * Threads are managed as below.  Instead of having
 * thread zero manage the computation by specifying tasks to workers, we
 * have workers proceed automatically to their next task; looping through
 * each of the columns on their own and only synchronizing when necessary.
 *
 * We launch and join as below. For example:
 *
 * Core To Thread Mapping
 *
 * Core  Binary  Reversed  Decimal   Busy Map
 *  0     000      000      0        X.......
 *  1     001      100      4        X...X...
 *  2     010      010      2        X.X.X...
 *  3     011      110      6        X.X.X.X.
 *  4     100      001      1        XXX.X.X.
 *  5     101      101      5        XXX.XXX.
 *  6     110      011      3        XXXXXXX.
 *  7     111      111      7        XXXXXXXX
 *
 * Worker Thread assigned  as below : 
 *
 * Thread Binary  #ofTrailing  ReplaceTrailing      Waits for
 *                zeroes       bits by 1            (+ core)
 *
 *  0     000      3          +1 +2 +4             1  2 4
 *  1     001      0              _                   _
 *  2     010      1          +1                   3
 *  3     011      0              _                   _
 *  4     100      2          +1 +2                5  6
 *  5     101      0              _                   _
 *  6     110      1          +1                   7
 *  7     111      0              _                   _
 *
 *  There is no trivial non-looping method of reversing the binary digits,
 *  so we use an integer array for the indices, and another array to keep
 *  track of working cores. The join operation for a node just skips the
 *  core if it is inactive.
 *
 *  For example, core 0 must join 1, 2, 4, but if only three threads were
 *  engaged, it skips the join on thread 1, joins 2, and then joins 4.
 *  Thread 2 would normally need to combine 3, but since 3 is inactive, it
 *  (Thread 2) will just post itself done immediately.
 *
 *  This approach balances the binary tree and lets us use our existing
 *  join method.
 *
 *----------------------------------------------------------------------------*/

#include "stdio.h"
#include "cblas.h"
#include "atlas_tlapack.h"
#include "atlas_lapack.h"
#include "atlas_threads.h"
#include "atlas_tlvl3.h"
#include "atlas_level2.h"
#include "atlas_lamch.h"
#include "math.h"
#include "errno.h"

#ifdef TREAL
   static const TYPE ONE = ATL_rone;
#else
   static const TYPE ONE[2] = {ATL_rone, ATL_rzero};
#endif

#define  MY_align 64                        /* ONLY powers of 2 work.         */

#ifdef  SREAL
   #define  MY_gemv ATL_sgemv               /* L2 tuned dgemv                 */
   #define  MY_gemvT ATL_sgemvT_L2          /* L2 tuned dgemv                 */
   #define  ATL_axpy ATL_saxpy
   #define  MY_ger  ATL_sger_L2             /* L2 tuned dger                  */
   #define MY_gecopy ATL_sgecopy            /* Copy routine to use.           */
#endif
#ifdef  DREAL
   #define  MY_gemv ATL_dgemv               /* L2 tuned dgemv                 */
   #define  MY_gemvT ATL_dgemvT_L2          /* L2 tuned dgemv                 */
   #define  ATL_axpy ATL_daxpy
   #define  MY_ger  ATL_dger_L2             /* L2 tuned dger                  */
   #define MY_gecopy ATL_dgecopy            /* Copy routine to use.           */
#endif
#ifdef  SCPLX
   #define  ATL_axpy ATL_caxpy
   #define  MY_gemvT ATL_cgemvCT_L2         /* L2 tuned dgemv                 */
   #define  MY_gemv ATL_cgemv               /* L2 tuned dgemv                 */
   #define  MY_ger  ATL_cgerc_L2            /* L2 tuned dger                  */
   #define MY_gecopy ATL_cgecopy            /* Copy routine to use.           */
#endif
#ifdef  DCPLX
   #define  ATL_axpy ATL_zaxpy
   #define  MY_gemvT ATL_zgemvCT_L2         /* L2 tuned dgemv                 */
   #define  MY_gemv ATL_zgemv               /* L2 tuned dgemv                 */
   #define  MY_ger  ATL_zgerc_L2            /* L2 tuned dger                  */
   #define MY_gecopy ATL_zgecopy            /* Copy routine to use.           */
#endif

#ifdef TREAL
    #define MY_TRANS CblasTrans
#else
    #define MY_TRANS CblasConjTrans
#endif

#define ATL_ger_L2 Mjoin(PATL,ger_L2)
#define ATL_geql2_dnrm2 Mjoin(PATL,geql2_dnrm2)
#define ATL_geql2_dnrm2_ql Mjoin(PATL,geql2_dnrm2_ql)
#define ATL_geql2_LC_Setup Mjoin(PATL,geql2_LC_Setup)
#define ATL_geql2_DoCopy Mjoin(PATL,geql2_DoCopy)
#define ATL_geql2_UnCopy Mjoin(PATL,geql2_UnCopy)
#define ATL_geql2_Cache Mjoin(PATL,geql2_Cache)
#define ATL_geql2Worker Mjoin(PATL,geql2Worker)
#define ATL_geql2Worker_Zero Mjoin(PATL,geql2Worker_Zero)
#define ATL_tgeql2 Mjoin(PATL,tgeql2)
#define ATL_geql2_Order Mjoin(PATL,geql2_Order)


double time00(void);                        /* prototype external rtn.        */
/*----------------------------------------------------------------------------*/
/* rdtsc reads the time stamp counter into %rax, which will be aliased as a   */
/* temp for the memory location 'time' which MUST be a long long location!!!  */
/* This takes about 30 cycles to complete.                                    */
/*----------------------------------------------------------------------------*/
#define rdtsc(time)                 \
   __asm__ __volatile__ (           \
      "rdtsc;\n\t"                  \
      "shlq $32, %%rdx;\n\t"        \
      "addq %%rdx, %%rax;\n\t"      \
      : "=a"(time) : : "%rdx" );


typedef struct                              /* Threading structure.           */
{
   ATL_INT  fullM;
   ATL_INT  fullN;
   ATL_INT  myM;
   ATL_INT  myN;
   ATL_INT  myK;
   ATL_INT  lda;
   ATL_INT  rank;
   volatile ATL_INT  dnrm2;
   volatile ATL_INT  dgemv;
   ATL_INT  active;
   TYPE     *A;
#ifdef TREAL
   volatile TYPE     zDiag;
#else
   volatile TYPE  zDiag[2];
#endif
   TYPE     *TAU;
   TYPE     *oldA;
   ATL_INT  oldLDA;
   TYPE     *WORK;
   volatile TYPE     Scale;
   volatile TYPE     SSQ;
   TYPE     *T;
   ATL_INT  LDT;
   ATL_INT  buildT;
   volatile ATL_INT  dgemvt;
   ATL_INT  copy;
} ATL_DGEQL2_t;


/* This code is used three times below, macro to prevent bug propagation.     */
#define dnrm2_combine_ql \
   if (myTS->Scale > ptnr->Scale)   /* If my scale is bigger,  */ \
   {                                                              \
      w = (ptnr->Scale)/(myTS->Scale); /* Must scale his SSQ.  */ \
      myTS->SSQ += (ptnr->SSQ)*w*w; /* Add scaled version.     */ \
   } else                           /* His scale is bigger.    */ \
   {                                                              \
      w = (myTS->Scale)/(ptnr->Scale); /* Must scale my SSQ.   */ \
      myTS->SSQ *= (w*w);           /* Scale my SSQ first.     */ \
      myTS->SSQ += ptnr->SSQ;       /* Add his to mine.        */ \
      myTS->Scale = ptnr->Scale;    /* Replace my SSQ with his.*/ \
   } /* END #define dnrm2_combine */


//-----------------------------------------------------------------------------
//  ATL_dgeqr2_dnrm2: Compute a dnrm2, but retain scale and value.
// ---------------------------------------------------------------------------

static void ATL_geql2_dnrm2_ql(ATL_DGEQL2_t *ts)
{
   int i,  N=ts->myM, N2;
   #ifdef TREAL
      N2 = N ;
   #else
      N2 = N << 1;
   #endif
   TYPE  aX, sX, SSQ=0., Scale=1.0;
   TYPE *X=ts->A+(((ts->lda) SHIFT)*(ts->myN -1 -ts->myK )); 
                                             /* Point at proper column. */

   if (ts->rank != 0)                       /* If a standard compute,         */
   {
      for (i=0; i<N2; i++)                  /* Do the full column.            */
      {
         if (X[i] != 0.)
         {
            aX = fabs(X[i]);
            if (Scale < aX)
            {
               SSQ = 1.+SSQ*(Scale/aX)*(Scale/aX);
               Scale = aX;
            } else
            {
               SSQ += (aX/Scale)*(aX/Scale);
            }
         } //for
      }
   } else                                   /* This is the Rank 0 Operation   */
   {

      N2 = ((N-ts->myK -1) SHIFT);          /* Not all the N is taken         */
      for (i=0; i<N2; i++)                  /* QL starts from zero.           */
      {
         if (X[i] != 0.)
         {
            aX = fabs(X[i]);
            if (Scale < aX)
            {
               sX = Scale/aX;               /* Do scale only once.            */
               SSQ = 1.+SSQ*sX*sX;          /* Scale SSQ.                     */
               Scale = aX;                  /* Use the new Scale.             */
            } else
            {
               sX = aX/Scale;               /* Scale the value.               */
               SSQ += sX*sX;                /* Square and add to SSQ.         */
            }
         }
      }//for
   }

   ts->Scale = Scale;
   ts->SSQ   = SSQ;
}                                           /* END ATL_dgeqr2_dnrm2           */


/*
 * LC_Setup sets up copy.
 */
static size_t ATL_geql2_LC_Setup(ATL_DGEQL2_t *myTS)
{
   int N = myTS->fullN;                     /* width of array.                */
   int M = myTS->myM;                       /* height of array.               */
   myTS->oldLDA = myTS->lda;                /* Remember the old one.          */
   myTS->oldA   = myTS->A;                  /* ...                            */
   int LDA = (M+1)&(-2);                    /* My new LDA, multiple 2.        */
   myTS->lda = LDA;                         /* Store new LDA.                 */
   size_t memSize = ((LDA SHIFT)*N*sizeof(TYPE));/* Room I need.              */
   memSize = (memSize+MY_align-1)&(-MY_align);   /* As multiple of MY_align.  */
   return(memSize);                         /* Exit with amt needed.          */
}                                           /* ** END ATL_geql2_LC_Setup **   */

/*
 * DoCopy works from LC_Setup.
 */
static void ATL_geql2_DoCopy(ATL_DGEQL2_t *myTS)
{
   int N = myTS->fullN;                     /* width of array.                */
   int M = myTS->myM;                       /* height of array.               */

   #ifdef BUILD_RQ2
   Mjoin(PATL,gemoveT)(M, N, ONE,  myTS->oldA,
         myTS->oldLDA, myTS->A, myTS->lda);
   #else
   MY_gecopy(M, N, myTS->oldA, myTS->oldLDA,
             myTS->A, myTS->lda);                     
   #endif
} /* END ATL_geql2_DoCopy. */

/*
 * UnCopy is just a copy back, no free.
 */
static void ATL_geql2_UnCopy(ATL_DGEQL2_t *myTS)
{
   int N = myTS->fullN;                     /* width of array.                */
   int M = myTS->myM;                       /* height of array.               */

   #ifdef BUILD_RQ2
   Mjoin(PATL,gemoveT)(N, M , ONE, myTS->A, 
                       myTS->lda, myTS->oldA, myTS->oldLDA); 
   #else
   MY_gecopy(M, N, myTS->A, myTS->lda,      
             myTS->oldA, myTS->oldLDA);               
   #endif

   myTS->lda = myTS->oldLDA;                /* Restore the old one.           */
   myTS->A = myTS->oldA;                    /* ...                            */
}                                           /* ** END ATL_geql2_UnCopy **     */

/*
 * Cache will force a read every 64th byte (eighth double) in an array,
 * following LDA.
 */
static void ATL_geql2_Cache(ATL_DGEQL2_t *myTS)
{
   int r, c;
   int N = myTS->fullN;                     /* width of array.                */
   int M = myTS->myM;                       /* height of array.               */
   int LDA = myTS->lda;
   TYPE *A = myTS->A;
   volatile TYPE x;

   for (c=N-1; c>=0; c--)                   /* Every column, backwards.       */
   {
      for (r=((M-1) SHIFT); r>=0; r-=8)     /* every eighth double.           */
      {
         x = *(A+(LDA SHIFT)*c+r);          /* read the variable.             */
      }
   }
}                                           /* ** END ATL_dgeql2_Cache **     */

/*
 * Callback for thread launcher
 */
static int Mjoin(PATL,StructIsInitGEQL2)(void *vp)
{
   //return 1;
   return(((ATL_DGEQL2_t*)vp)->active);
}


/*
 * ATL_geql2Worker: Persistent for the duration of the DGEQL2 operation.
 * Argument is pointer to a structure which contains our data section.
 */
//void* ATL_geql2Worker(void *myArg)
static void* ATL_geql2Worker(ATL_LAUNCHSTRUCT_t *lp, void *vp)
{
   ATL_thread_t *tp=vp;
   ATL_DGEQL2_t *myTS = ((ATL_DGEQL2_t*) lp->opstruct)+tp->rank;
   ATL_DGEQL2_t *zTS = myTS - (myTS->rank); /* Point at zero ts.              */
   int   zees, pair, myRank;                /* Log2 looping variables.        */
   int   i_loop;
   int   i,j,M,N,LDA,mScale,mUpdate,newN,KNT,LDT;
   int   idup;
   int   myCopy=myTS->copy;   
   volatile ATL_DGEQL2_t *ptnr;             /* partner log2 combine.          */
   TYPE  *A, *scaleA, *T;                   /* Work variables.                */
   TYPE XNORM, BETA, BETAp;
   TYPE *TAU = myTS->TAU;                   /* Short cut.              */
   TYPE ALPHA;
   TYPE w;

   #ifdef TREAL
      const TYPE ONE = ATL_rone;
      TYPE AII ;
      TYPE TAUVAL ;
      TYPE myTAUi;
      TYPE sc;
      TYPE RSAFMN;
      const TYPE ZERO = ATL_rzero;
   #else
      const TYPE ONE[2] = {ATL_rone, ATL_rzero};
      TYPE AII[2];
      TYPE TAUVAL[2] ;
      TYPE myTAUi[2] ;
      TYPE negTAUi[2] ;

      TYPE ALPHAI, ALPHAR;
      TYPE ALPHADIV[2] ;
      TYPE sc[2];
      TYPE RSAFMN[2];
      const TYPE ZERO[2] = {ATL_rzero, ATL_rzero};
   #endif

   myRank = myTS->rank;                     /* Get my rank.                   */
   T = zTS->T;
   LDT = zTS->LDT;

/*----------------------------------------------------------------------------*/
/* Now we begin the real dgeql2.                                              */
/*----------------------------------------------------------------------------*/
   N = myTS->fullN;                         /* panel width.                   */

   if (myCopy)
   {
      ATL_geql2_DoCopy(myTS);                  /* Copy my data.               */
   }

   LDA = myTS->lda;                         /* Load AFTER local copy.         */
   M = myTS->myM;                           /* Shortcut to M.                 */

/* Here the computation should start from left to right.               */

   for (i=N-1; i >= 0; i--)                 /* Now, for each column,          */
   {
/*    i starts from N -1                                                      */
      myTS->myK =  N - i -1;                /* 0, 1, ... N-1  Set my K value. */
      idup =  N - i -1;                     /* 0, 1, ... N-1  Set my K value. */

      if (myRank == 0)                      /* Zero follows diagonal.         */
      {
         mScale = M-idup-1;                 /* Special scaling value.         */
         mUpdate = M-idup;                  /* Special gemv/ger size.         */
         A = myTS->A + (i* (LDA SHIFT));    /* Special pointer to A.          */

         /* Save diagonal entry, replace with 1.0. */
         #ifdef TREAL
            myTS->zDiag = *(A + ((M -1 - myTS->myK) SHIFT));
            *(A + M -1 - myTS->myK ) = 1.0;
         #else
            myTS->zDiag[0] = *(A + ( (M -1 - myTS->myK) SHIFT));
            myTS->zDiag[1] = *(A + ( (M -1 - myTS->myK) SHIFT) + 1);
            *(A + ((M -1 - myTS->myK) SHIFT) ) = 1.0;
            *(A + ((M -1 - myTS->myK) SHIFT) + 1 ) = 0.0;
         #endif

         scaleA = A;                        /* What to scale.                 */
      } else                                /* Others keep square.            */
      {
         mScale = M;                        /* Always scale full col.         */
         mUpdate = M;                       /* Always gemv/ger full co.       */
         A = myTS->A + (i* (LDA SHIFT));    /* Point at column.               */
         scaleA = A;                        /* What to scale.                 */
      }

      /* i starts from N -1. */

      ATL_geql2_dnrm2_ql(myTS);

      zees = myRank;                        /* Init the test flags.           */
      pair = 1;                             /* Starting pair.                 */
      while ( (zees & 1) == 0 &&            /* If I must wait on pair,        */
         (myRank)+pair < ATL_NTHREADS)      /* ..and pair exists,             */
      {
         ptnr = myTS+pair;                  /* Point at my partner.           */

         if (ptnr->active == 1)             /* If ptnr was used,              */
         {
            while (ptnr->dnrm2 <= myTS->dnrm2);  /* Wait for it.              */
            dnrm2_combine_ql;
         }

         zees >>= 1;                        /* Shift a zero out.              */
         pair <<= 1;                        /* Double the pair idx.           */
      }

      myTS->dnrm2++;                        /* Signal I am done.              */


      /****************************************/
      /********  S Y N C   P O I N T  *********/
      /********  S Y N C   P O I N T  *********/
      /********  S Y N C   P O I N T  *********/
      /****************************************/

      /*-----------------------------------------------------------------*/
      /* Note: We can avoid syncing immediately after the DGER, but DGER */
      /* does use zTS->WORK as its vector. So here is the point where we */
      /* have to make sure everybody's DGER is done, and they have done  */
      /* their norm2 work. All threads converge here for the next column */
      /* and so will be done with their DGER, and zTS->WORK is free.     */
      /*-----------------------------------------------------------------*/
      while (zTS->dnrm2 < myTS->dnrm2);     /* Wait for zero to finish.       */

      /*-------------------------------------------------------------*/
      /* At this point, zTS->SSQ is computed. If it is zero, then no */
      /* rotation is needed, and TAU should be set to zero, and we   */
      /* just skip to the next column.                               */
      /* HOWEVER, core zero may be fast on the next compare, and     */
      /* change zTS->SSQ before some other core gets a chance to see */
      /* it was zero. So we must have a barrier here before we go on.*/
      /*                                                             */
      /* In Complex we require both SSQ == 0 and IMAG(A[i,i]) == 0.  */
      /*-------------------------------------------------------------*/
      /* If H should be Identity, set TAU to zero and go to next column. */
      #ifdef TREAL
      if (zTS->SSQ == 0.)
      #else /* COMPLEX */
      if (zTS->SSQ == 0. && zTS->zDiag[1] == 0.)
      #endif /* REAL or CPLX */
      {
         zees = myRank;                     /* Init the test flags.           */
         pair = 1;                          /* Starting pair.                 */
         while ( (zees & 1) == 0 &&         /* If I must wait on pair,        */
            (myRank)+pair < ATL_NTHREADS)   /* ..and pair exists,             */
         {
            ptnr = myTS+pair;               /* Point at my partner.           */

            if (ptnr->active == 1)          /* If ptnr was used,              */
            {
               while (ptnr->dnrm2 <= myTS->dnrm2);  /* Wait for it.           */
            }

            zees >>= 1;                     /* Shift a zero out.              */
            pair <<= 1;                     /* Double the pair idx.           */
         }

         if (myRank == 0)                   /* Replace A[i,i] we repl with 1. */
         {
            #ifdef TREAL
            *(A + M -1 - idup) =  myTS->zDiag;
            TAU[i] = 0.;                    /* clear TAU so H[i]=Identity.    */
            #else
            *(A + ((M -1 - idup) SHIFT)) =  myTS->zDiag[0];
            *(A + ((M -1 - idup) SHIFT) +1) =  myTS->zDiag[1];
            TAU[(i SHIFT)] = 0.;            /* clear TAU so H[i]=Identity.    */
            TAU[(i SHIFT)+1] = 0.;
            #endif
         }

         myTS->dnrm2++;                     /* Signal I am done.              */
         while (zTS->dnrm2 < myTS->dnrm2);  /* Wait for zero to finish.       */
         continue;                          /* ..Proceed to next column.      */
      } /* END if H=Identity no need to process column. */

/*----------------------------------------------------------------------------*/
/* Here, H is not identity, we 'continued' the loop if it was.                */
/*----------------------------------------------------------------------------*/
      XNORM = (zTS->Scale)*sqrt(zTS->SSQ);  /* Compute the norm.              */

/*----------------------------------------------------------------------------*/
/* The following code is inlined from ATL_larfg.                              */
/* Here, SSQ is non-zero, we exited the loop above if that occurred.          */
/*----------------------------------------------------------------------------*/

   #ifdef TREAL
/*----------------------------------------------------------------------------*/
/*    The following code is inlined from ATL_larfg; the main difference is    */
/*    that we use zTS->zDiag instead of ALPHA, and recompute is parallel.     */
/*----------------------------------------------------------------------------*/
      BETAp = ATL_lapy2((zTS->zDiag), XNORM);    /* Get sqrt(a^2+b^2)         */
      BETA = BETAp;                              /* Assume diagonal < 0 ...   */
      if ((zTS->zDiag) >= 0.) BETA = -BETAp;     /* .. If >= 0, change sign.  */

      KNT = 0;                                   /* Init power to zero. */
      if (BETAp < ATL_laSAFMIN)
      {
         RSAFMN = ATL_rone / ATL_laSAFMIN;       /* Set a maximum. */

         /*---------------------------------------------------------------*/
         /* BETAp is the same for all cores, so this loop can be executed */
         /* independently. However, XNORM must be computed in concert.    */
         /* The new BETAp will be at most 1, at least SAFMIN.             */
         /*---------------------------------------------------------------*/
         while (BETAp < ATL_laSAFMIN)
         {
            KNT++;                              /* increment power. */
            if ( myTS->active == 1)             /* If I am active, */
            {
               cblas_scal(mScale, RSAFMN,
                                    scaleA, 1); /* Scale my share. */
            }

            BETA *= RSAFMN;
            BETAp *= RSAFMN;
            if (myRank==0) zTS->zDiag *= RSAFMN;   /* Only done by core 0! */
         }

         /* i starts from N -1. */
         ATL_geql2_dnrm2_ql(myTS);             /* Do my share of new norm2. */

         zees = myRank;                        /* Init the test flags.    */
         pair = 1;                             /* Starting pair.          */
         while ( (zees & 1) == 0 &&            /* If I must wait on pair, */
            (myRank)+pair < ATL_NTHREADS)      /* ..and pair exists,      */
         {
            ptnr = myTS+pair;                  /* Point at my partner.    */

            if (ptnr->active == 1)             /* If ptnr was used,       */
            {
               while (ptnr->dnrm2 <= myTS->dnrm2);  /* Wait for it.       */
                  dnrm2_combine_ql;
            }

            zees >>= 1;                        /* Shift a zero out.       */
            pair <<= 1;                        /* Double the pair idx.    */
         }

         myTS->dnrm2++;                        /* Signal I am done.       */

         /*************************************/
         /******  S Y N C   P O I N T  ********/
         /******  S Y N C   P O I N T  ********/
         /******  S Y N C   P O I N T  ********/
         /*************************************/
         while (zTS->dnrm2 < myTS->dnrm2);         /* Wait on zero to finish. */

         XNORM = (zTS->Scale)*sqrt(zTS->SSQ);      /* Compute the norm. */
         BETAp = ATL_lapy2((zTS->zDiag), XNORM);   /* Get sqrt(a^2+b^2) */
         BETA = BETAp;                             /* Assume diagonal < 0 ... */
         if ((zTS->zDiag) >= 0.) BETA = 0.-BETAp;  /* ..If >= 0, change sign. */
      }

      myTAUi = (BETA-(zTS->zDiag)) / BETA;         /* Compute TAU[i]. */
      if (myRank == 0) TAU[i] = myTAUi;            /* Set if I own TAU. */

      sc = ATL_rone/((zTS->zDiag)-BETA);           /* Find scaling factor. */
      if ( myTS->active == 1)
      {
         cblas_scal(mScale, sc, scaleA, 1);        /* Scale the vector. */
      }

      if (myRank == 0)                             /* If I own diagonal, */
      {
         AII = BETA;                               /* Set new A[i,i] element. */
         for (j=0; j<KNT; j++)                     /* Rescaling loop...       */
            AII *= ATL_laSAFMIN;                   /* ...Adjust it.           */
      }

   #else /* COMPLEX VERSION of LARFG, modeled on clarfg.f. */
      ALPHAR =  zTS->zDiag[0];                     /* Real portion. */
      ALPHAI =  zTS->zDiag[1];                     /* Imaginary portion. */

      BETAp = ATL_lapy3(ALPHAR, ALPHAI, XNORM);    /* sqrt(a^2+b^2,c^2) */
      BETA = BETAp;                                /* Assume ALPHAR < 0.*/
      if (ALPHAR >= 0.) BETA = -BETAp;             /* If >=0, Change sign. */

      KNT = 0;                                     /* Init power to zero. */
      if (BETAp < ATL_laSAFMIN)
      {
         RSAFMN[0] = ATL_rone/ATL_laSAFMIN;        /* Set a maximum. */
         RSAFMN[1] = ATL_rzero;                    /* ..for scaling. */

         /*---------------------------------------------------------------*/
         /* BETAp is the same for all cores, so this loop can be executed */
         /* independently. However, XNORM must be computed in concert.    */
         /* The new BETAp will be at most 1, at least SAFMIN.             */
         /*---------------------------------------------------------------*/
         while (BETAp < ATL_laSAFMIN)
         {
            KNT++;                                 /* increment power. */
            if ( myTS->active == 1)                /* If I am active, */
            {
               cblas_scal(mScale, RSAFMN,
                                    scaleA, 1);    /* Scale my share. */
            }

            BETA *= RSAFMN[0];
            BETAp *= RSAFMN[0];
            ALPHAR *= RSAFMN[0];
            ALPHAI *= RSAFMN[0];
         }

         /* i starts from N -1. */
         ATL_geql2_dnrm2_ql(myTS);             /* Do my share of new norm2. */

         zees = myRank;                        /* Init the test flags.      */
         pair = 1;                             /* Starting pair.            */
         while ( (zees & 1) == 0 &&            /* If I must wait on pair,   */
            (myRank)+pair < ATL_NTHREADS)      /* ..and pair exists,        */
         {
            ptnr = myTS+pair;                  /* Point at my partner.      */

            if (ptnr->active == 1)             /* If ptnr was used,         */
            {
               while (ptnr->dnrm2 <= myTS->dnrm2);  /* Wait for it.         */
                  dnrm2_combine_ql;
            }

            zees >>= 1;                        /* Shift a zero out.         */
            pair <<= 1;                        /* Double the pair idx.      */
         }

         myTS->dnrm2++;                        /* Signal I am done.         */

         /*************************************/
         /******  S Y N C   P O I N T  ********/
         /******  S Y N C   P O I N T  ********/
         /******  S Y N C   P O I N T  ********/
         /*************************************/
         while (zTS->dnrm2 < myTS->dnrm2);         /* Wait on zero to finish.*/

         XNORM = (zTS->Scale)*sqrt(zTS->SSQ);      /* Compute the norm. */
         BETAp = ATL_lapy3(ALPHAR, ALPHAI, XNORM); /* sqrt(a^2+b^2,c^2) */
         BETA = BETAp;                             /* Assume ALPHAR < 0.*/
         if (ALPHAR >= 0.) BETA = 0.-BETAp;        /* If >=0, Change sign. */
      }

      myTAUi[0] = (BETA-ALPHAR) / BETA;      /* Compute real part. */
      myTAUi[1] = (0.-ALPHAI) / BETA;        /* Compute imag part. */

      ALPHADIV[0] = ALPHAR - BETA;           /* prepare for 1/(alpha-beta) */
      ALPHADIV[1] = ALPHAI;                  /* ...                        */
      ATL_ladiv(ONE, ALPHADIV, sc);          /* compute scaling factor.    */
      if (myTS->active == 1)                 /* If I have some of vector,  */
      {
         cblas_scal(mScale, sc, scaleA, 1);  /* ..scale it. */
      }

      if (myRank == 0)                       /* If I own TAU, */
      {
         TAU[(i SHIFT)] = myTAUi[0];
         #ifdef BUILD_RQ2
            TAU[(i SHIFT) +1] = -myTAUi[1];  /* RQ2 needs conjugate. */
         #else
            TAU[(i SHIFT) +1] = myTAUi[1];   /* otherwise use normal. */
         #endif
      }

      if (myRank == 0)                       /* If I own diagonal, */
      {
         for (j=0; j<KNT; j++) BETA *= ATL_laSAFMIN;  /* Rescale BETA. */
         AII[0] = BETA;                               /* save for later. */
         AII[1] = 0.0;
      }
   #endif /* COMPLEX version of larfg. */

/*----------------------------------------------------------------------------*/
/* Now we apply dlarf, if we are not on the last column. This is              */
/* a dgemv, followed by a dger, all presuming TAU is non-zero.                */
/* The DGEMV: Column major, transpose A.                                      */
/*                                                                            */
/* We must compute H(i)*C, where C is the trailing part of our panel          */
/* at A[i..M-1, (i+1)..N-1]. So, C is (M-i) x (N-i-1).                        */
/* H(i) = (I-TAU[i]* u * (transpose u)), by definition.                       */
/* Where 'u' = A[i..M-1, i]. So, u is (M-i) x 1. We compute H(i)*C            */
/* as C - TAU[i] * u * (transpose w), where w = (transpose C) * u             */
/* (so that (transpose w) = (transpose u) * C.)                               */
/* Thus, w is (N-i-1) x 1.                                                    */
/*                                                                            */
/* Now, (transpose C) * u is just a GEMV. It produces a vector of             */
/* (N-i-1) elements. Every core will produce its own copy, and they           */
/* must be added together.                                                    */
/*                                                                            */
/* The second part, C += -TAU[i] * u * (transpose w), is just a GER.          */
/* Each core can do its part independently. We are essentially                */
/* dividing on M, not N, so every core needs (transpose w).                   */
/*----------------------------------------------------------------------------*/

   #ifdef TREAL
      if (myTS->myK < (N-1) && myTAUi != 0.)/* If dlarf necessary,            */
   #else
      if (myTS->myK < (N-1) )               /* If dlarf necessary,            */
   #endif
      {
         newN = N- myTS->myK  -1;           /* Width of update array & w.     */

         MY_gemvT ( mUpdate, newN, ONE, myTS->A, LDA,
                     A, 1, ZERO, myTS->WORK, 1);

/*----------------------------------------------------------------------------*/
/*       Now combine with other threads.                                      */
/*----------------------------------------------------------------------------*/

         zees = myRank;                     /* Init the test flags.           */
         pair = 1;                          /* Starting pair.                 */
         while ( (zees & 1) == 0 &&         /* If I must wait on pair,        */
                  (myRank)+pair <
                  ATL_NTHREADS)             /* ..and pair exists,             */
         {
            ptnr = myTS+pair;               /* Point at my partner.           */
            if (ptnr->active == 1)          /* If partner was used,           */
            {
               while (ptnr->dgemv < idup);  /* Wait for it.                   */
               ATL_axpy(newN, ONE, ptnr->WORK, 1, myTS->WORK, 1);
            }

            zees >>= 1;                     /* Shift a zero out.              */
            pair <<= 1;                     /* Double the pair idx.           */
         }

         myTS->dgemv = idup;                /* Say I finished dgemv.          */

/**********************************                                           */
/******  S Y N C   P O I N T  *****                                           */
/******  S Y N C   P O I N T  *****                                           */
/******  S Y N C   P O I N T  *****                                           */
/**********************************                                           */
/*----------------------------------------------------------------------------*/
/*       We can't start GER until all of                                      */
/*       'w' is finished. Wait for zero.                                      */
/*----------------------------------------------------------------------------*/
         while (zTS->dgemv < idup);         /* Wait for zero to build 'w'.    */

/*----------------------------------------------------------------------------*/
/*       'w' now in WORK. Use for GER.                                        */
/*----------------------------------------------------------------------------*/
         #ifdef TREAL
            MY_ger(
            mUpdate, newN, 0.-myTAUi,       
            A, 1, zTS->WORK, 1,             
            myTS->A, LDA);                  
         #else
            negTAUi[0]= 0.0 - myTAUi[0];
            negTAUi[1]= 0.0 + myTAUi[1];    /* conjugate for complex          */

            MY_ger(
            mUpdate, newN, negTAUi,         
            A, 1, zTS->WORK, 1,             
            myTS->A, LDA);                  
         #endif

         #ifdef TREAL
            if (myRank == 0) *(A + M -1 - idup) = AII; 
                                            /* Core 0, restore diag now. */
         #else
            if (myRank == 0)
            {
               *(A + ((M -1 - idup) SHIFT) ) = AII[0]; 
                                            /* Core 0, restore diag now. */
               *(A + ((M -1 - idup) SHIFT)  + 1) = AII[1]; 
                                            /* Core 0, restore diag now. */
            }
         #endif
/*----------------------------------------------------------------------------*/
/*       Once we finish it is safe for us to start our                        */
/*       next column and dnrm2 on our share. We  will                         */
/*       sync up with other threads to complete that.                         */
/*----------------------------------------------------------------------------*/
      }
      else                        /* END IF we need to apply dlarf.           */
      {
         #ifdef TREAL
            if (myRank == 0) *(A + M -1 - idup) = AII; 
                                                 /* Don't forget to set diag. */
         #else
            if (myRank == 0)
            {
               *(A + ((M -1 - idup) SHIFT) ) = AII[0]; 
                                                 /* Core 0, restore diag now. */
               *(A + ((M -1 - idup) SHIFT) +1  ) = AII[1]; 
                                                 /* Core 0, restore diag now. */
            }
         #endif
      }

      /*
       * for computing T,  for RQF replace myTAUi with correct TAU for the 
       * complex part. 
       */  

      #ifdef TCPLX 
          #ifdef BUILD_RQ2
                myTAUi[1] = 0.0 -  myTAUi[1];
          #endif
      #endif

      #ifdef TREAL
      if (myTS->buildT && idup == 0)        /* Simple store will work.        */
         *(T +i*LDT + i)  = myTAUi;         /* Just store it. NOte later      */
      #else
      if (myTS->buildT && idup == 0)        /* Simple store will work.        */
      {
         *(T +(i*(LDT SHIFT))+ (i SHIFT))  = myTAUi[0]; 
                                            /* Just store it. NOte later      */
         *(T +(i*(LDT SHIFT)) + (i SHIFT) + 1)  = myTAUi[1];
      }
      #endif
/*    change to min m, n                                                      */
      if (myTS->buildT && idup > 0)         /* If I must work for T,          */
      {

/*----------------------------------------------------------------------------*/
/*       Building T is very similar to DLARF, except we use the other         */
/*       side of A. Here is the picture:                                      */
/*                                                                            */
/*       B R R R R R R R R      Q = finished part of column                   */
/*       Q B R R R R R R R      R = upper triangular part for column          */
/*       Q Q B R R R R R R      B = Betas (norm 2) stored on diagonal,        */
/*       Q Q Q 1 C C C C C      1 = forced unit (normally assumed)            */
/*       Q Q Q u C C C C C      u = vector that H(i) is computed by,          */
/*       Q Q Q u C C C C C      C = portion of panel to be updated.           */
/*       .     .     .                                                        */
/*       .     .     .                                                        */
/*       .     .     .                                                        */
/*       Q Q Q u C C C C C                                                    */
/*                                                                            */
/*       We must compute Q^T times u, so each thread does its part, and       */
/*       then we add them together. We don't know at this point if all        */
/*       threads have completed their dger, so we can't use WORK. But         */
/*       we can use WORK+N-i, because it is not in use at this time. So       */
/*       we build the vector in zTS->WORK+N-i, it is 'i' elements long,       */
/*       and then zero will copy that into the column T[0,i].                 */
/*                                                                            */
/*       From there, we let thread 0 (alone) do a DTRMV to update that        */
/*       vector with the previous T, and then store TAU[i] at T[i,i].         */
/*                                                                            */
/*       This presumes that the DTRMV is too small to parallelize; but        */
/*       if that assumption is wrong the DTRMV could be parallelized as       */
/*       well, in future work.                                                */
/*                                                                            */
/*       We must sync to add up the DGEMV for T, not after that.              */
/*                                                                            */
/*       Rank 0: A points at A[i,i] mUpdate=M-i  A-i*LDA=A[i,0]               */
/*       Rank X: A points at A[0,i] mUpdate=M    A-i*LDA=A[0,0]               */
/*                                                                            */
/*----------------------------------------------------------------------------*/

         if (myRank == 0)                   /* Special case...                */
         {
            #ifdef TREAL
            AII = *(A + M -1 - idup );      /* Save diagonal element.         */
            *(A + M -1 - idup )  = 1.0;     /* Force to 1.                    */
            #else
            AII[0] = *(A + ((M -1 - idup) SHIFT) );  /* Save diagonal element.*/
            AII[1] = *(A + ((M -1 - idup ) SHIFT) +1);/* Save diagonal element*/
            *(A + ((M -1 - idup) SHIFT)) = 1.0;  /* Force to 1.               */
            *(A + ((M -1 - idup) SHIFT) + 1) = 0.0;   /* Force to 1.          */
            #endif
         }

         int os=(N+3)&(-4);                 /* Find even offset into work.    */


         #ifdef TREAL
         MY_gemvT(mUpdate, idup, 0.-myTAUi, A+LDA, LDA,
                  A, 1, 0.0, myTS->WORK+os, 1);
         #else
            #ifdef BUILD_RQ2
               negTAUi[0]= 0.0 + myTAUi[0];
               negTAUi[1]= 0.0 - myTAUi[1]; 
            #else
               negTAUi[0]= 0.0 - myTAUi[0];
               negTAUi[1]= 0.0 - myTAUi[1]; 
            #endif
            MY_gemvT(mUpdate, idup, negTAUi, A+(LDA SHIFT), LDA,
                     A, 1, ZERO, myTS->WORK+(os SHIFT), 1);
            #ifdef BUILD_RQ2
                for (i_loop = 0; i_loop < idup; i_loop++)
                {
                     (myTS->WORK+(os SHIFT))[(i_loop SHIFT)    ] = 
                         -(myTS->WORK+(os SHIFT))[(i_loop SHIFT)    ];
                }
            #endif
         #endif

/*----------------------------------------------------------------------------*/
/* Now combine with other threads.                                            */
/*----------------------------------------------------------------------------*/
         zees = myRank;                     /* Init the test flags.           */
         pair = 1;                          /* Starting pair.                 */
         while ( (zees & 1) == 0 &&         /* If I must wait on pair,        */
                  (myRank)+pair <
                  ATL_NTHREADS)             /* ..and pair exists,             */
         {
            ptnr = myTS+pair;               /* Point at my partner.           */
            if (ptnr->active == 1)          /* If partner was used,           */
            {
               while (ptnr->dgemvt < idup); /* Wait for it.                   */
               ATL_axpy(idup, ONE, ptnr->WORK+(os SHIFT), 1,    
                        myTS->WORK+(os SHIFT), 1);   
            }

            zees >>= 1;                     /* Shift a zero out.              */
            pair <<= 1;                     /* Double the pair idx.           */
         }

         myTS->dgemvt = idup;               /* Post my completion.            */

/*----------------------------------------------------------------------------*/
/*       Done with dgemv part, rest is all for thread 0 to get done.          */
/*----------------------------------------------------------------------------*/
         if (myRank == 0)
         {
            TYPE *src=zTS->WORK+(os SHIFT); /* Source vector.                 */
            TYPE *dst= (T + (i*(LDT SHIFT)) +(i SHIFT) +(1 SHIFT)); 
                                                       /* Destination vector. */

            #ifdef TREAL
            *(A + M -1 - idup )  = AII;     /* Restore saved value.           */
            #else
            *(A + ((M -1 - idup) SHIFT) )  = AII[0];  /* Restore saved value. */
            *(A + ((M -1 - idup) SHIFT) +1 )  = AII[1]; /* Restore svd value. */
            #endif
            for (j=0; j<(idup SHIFT); j++)
            {
               *dst++ = *src++;             /* Copy value.                    */
            }

            cblas_trmv(CblasColMajor, CblasLower, CblasNoTrans, CblasNonUnit,       
                        idup, (T + (i+1)*(LDT SHIFT)  + ((i+1) SHIFT) ), 
                        LDT, T+i*(LDT SHIFT)+ ((i+1) SHIFT), 1);                 

            #ifdef TREAL
            *(T+i*LDT+i)=myTAUi;            /* Force TAU[i] on diagonal.      */
            #else
            *(T+i*(LDT SHIFT) +(i SHIFT))=myTAUi[0]; 
                                            /* Force TAU[i] on diagonal.      */
            *(T+i*(LDT SHIFT) +(i SHIFT) + 1)=myTAUi[1]; 
                                            /* Force TAU[i] on diagonal.      */
            #endif

         }                        /* ** END IF zero must update T. **         */

      }                                     /* ** END if building T **        */
   }                                        /* END FOR each column.           */

/*----------------------------------------------------------------------------*/
/* If we copied, this will copy back.                                         */
/*----------------------------------------------------------------------------*/
   if (myCopy)
   {
      ATL_geql2_UnCopy(myTS);               /* Do my copy back.               */
   }

   return(NULL);                            /* Implicit thread exit.          */
}                                           /* end *** ATL_geql2Worker **     */


/**************************************************************************** */
/********************** M A S T E R   C O N T R O L L E R ******************* */
/**************************************************************************** */

/*----------------------------------------------------------------------------*/
/* The break-up: We divide on M, simply enough, in multiples of 4. If there   */
/* are less than 32*ATL_NTHREADS elements, we will not divide at all.         */
/*                                                                            */
/* Processor 0 is our master combiner. The jobs are to compute the norm,      */
/* and then apply the reflector to the array.                                 */
/*                                                                            */
/* To compute the norm, threads need SAFMIN. We compute it before any thread  */
/* launches if it is not already computed.                                    */
/*                                                                            */
/*----------------------------------------------------------------------------*/
#ifdef BUILD_RQ2    
#define ATL_tgexx2 Mjoin(PATL,tgerq2)
#else 
#define ATL_tgexx2 Mjoin(PATL,tgeql2)
#endif 

int ATL_tgexx2(int M, int N, TYPE *A, int LDA, TYPE *TAU, TYPE *WORK,
                 TYPE *ws_T, int LDT, TYPE *WORKM, int buildT, int myCopy)
{

   ATL_DGEQL2_t ts[ATL_NTHREADS];

   long long t0, t1;

   if (M < 0)
   {
      fprintf(stderr, "%s: M<0 (%i)\n", Mstr(ATL_tgexx2), M);
      return(-1);
   }

   if (N < 0)
   {
      fprintf(stderr, "%s: N<0 (%i)\n", Mstr(ATL_tgexx2), N);
      return(-2);
   }

   #ifdef BUILD_RQ2
   if (LDA < N)
   {
      fprintf(stderr, "%s: LDA<N (%i, %i)\n", Mstr(ATL_tgexx2), LDA, N);
      return(-4);
   }
   #else
   if (LDA < M)
   {
      fprintf(stderr, "%s: LDA<M (%i, %i)\n", Mstr(ATL_tgexx2), LDA, M);
      return(-4);
   }
   #endif

/*----------------------------------------------------------------------------*/
/* Preliminaries are done; now split up the problem.                          */
/* We use a data-owner split, each thread gets 1/p of the data,               */
/* and does all computation related to it.                                    */
/*----------------------------------------------------------------------------*/
   TYPE *myA = A, *allMem=NULL, *workMem;
   int i, j, k, b0, b, th;
   long unsigned int CPU;
   size_t mem[ATL_NTHREADS], totmem, workSize;

   th = ((M+N-1)/N);                        /* Max number of threads.         */
   if (th==0) th=1;                         /* Avoid divide by zero.          */
   if (th > ATL_NTHREADS) th=ATL_NTHREADS;  /* Limit on top.                  */

   b0 = (M/th);                             /* Find part for th zero.         */
   if (b0 < N) b0 = N;                      /* Take at least N.               */
   b = 0;
   if (th !=1)                              /* If multiple threads,           */
      b = ((M-b0) / (th-1) ) & (-4);        /* Split up the rest.             */
   b0 = M - (th-1)*b;                       /* Leftovers go to b0.            */
   if (b0 > b && b0 >= (N+(th-1)*4)) /* If b0 is biggest and can be smaller,  */
   {
      b += 4;                     /* Make the others slightly bigger.         */
      b0 -= (th-1)*4;             /* Core 0 has more overhead, do less.       */
   }

   if (b == 0) th = 1;
   if (th == 1 || (M < N) )       /* If impossible to split, use serial. */
   {

      #ifdef BUILD_RQ2
      ATL_gerq2(N, M, A, LDA, TAU, WORK);   /* Use serial version.            */
      if (buildT)                           
      {
         ATL_larft(LABackward, LARowStore, M, N, A, LDA, TAU, ws_T, LDT);
      }
      #else
      ATL_geql2(M, N, A, LDA, TAU, WORK);   
      if (buildT)                           
      {
         ATL_larft(LABackward, LAColumnStore, M, N, A, LDA, TAU, ws_T, LDT);
      }
      #endif
      return(0);                            /* Exit after panel.              */
   }

/*----------------------------------------------------------------------------*/
/* Fill out the thread work areas.                                            */
/*----------------------------------------------------------------------------*/
   for (i=0; i<ATL_NTHREADS; i++)
   {
      ts[i].active=0;                       /* Nobody is active yet.          */
      mem[i] = 0;                           /* Nobody needs memory.           */
   }
/*
 * Note :
 *    For QL, the '0' denote the rows at the bottom. From bottom
 *    each row buld is allocated
 */

/* Modify myA  as   A + M - b0                                                */
   #ifdef BUILD_RQ2
   myA = A + ((M -b0) * (LDA SHIFT));
   #else
   myA = A + ((M -b0) SHIFT);
   #endif 

   ts[0].fullM = M;                         /* Need full size M.              */
   ts[0].fullN = N;                         /* Need full size N.              */
   ts[0].myM = b0;                          /* Core 0 is special.             */
   ts[0].myN = N;                           /* Width is same for all.         */
   ts[0].myK = 0;                           /* First k for dnrm2.             */
   ts[0].lda = LDA;                         /* LDA is same for all.           */
   ts[0].rank = 0;                          /* Rank used by core 0.           */
   ts[0].A = myA;                           /* Core 0 gets bottom of A.       */
   ts[0].TAU = TAU;                         /* TAU is same for all.           */
   ts[0].dnrm2 = -1;                        /* Not done yet.                  */
   ts[0].dgemv = -1;                        /* Not done yet.                  */
   ts[0].active = 1;                        /* We are active.                 */
   ts[0].buildT = buildT;                   /* Pass in decision var.          */
   ts[0].T = ws_T;                          /* Pass in matrix addr.           */
   ts[0].LDT = LDT;                         /* And leading dimension.         */
   ts[0].dgemvt = -1;                       /* Not done yet.                  */
   ts[0].copy = myCopy;                     /* Whether worker should copy.    */
   #ifdef BUILD_RQ2
   myA -= (b SHIFT)*LDA;                    /* Point at next A, RQ.           */
   #else 
   myA -= (b SHIFT);                        /* Point at next A, QL.           */
   #endif 

   for (i=1; i < th; i++)
   {
@skip    t = ATL_launchorder[i];               /* Get thread to use.             */
      ts[i].fullM = b;                      /* Remember whole M.              */
      ts[i].fullN = N;                      /* Need full size N.              */
      ts[i].myM = b;                        /* 'b' entries for all.           */
      ts[i].myN = N;                        /* Width is same for all.         */
      ts[i].myK = 0;                        /* First k for dnrm2.             */
      ts[i].lda = LDA;                      /* LDA is same for all.           */
      ts[i].rank = i;                       /* Rank of process.               */
      ts[i].A = myA;                        /* Point at share of A.           */
      ts[i].TAU = TAU;                      /* TAU is same for all.           */
      ts[i].dnrm2 = -1;                     /* Not done yet.                  */
      ts[i].dgemv = -1;                     /* Not done yet.                  */
      ts[i].active = 1;                     /* Indicate active.               */
      ts[i].buildT = buildT;                /* Pass in decision var.          */
      ts[i].dgemvt = -1;                    /* Not done yet.                  */
      ts[i].copy = myCopy;                  /* Whether worker should copy.    */
      #ifdef BUILD_RQ2
      myA -= (b SHIFT)*LDA;                 /* Point at next A, RQ.           */
      #else 
      myA -= (b SHIFT);                     /* Point at next A, QL.           */
      #endif 
   }

/*----------------------------------------------------------------------------*/
/* Deal with memory.                                                          */
/*----------------------------------------------------------------------------*/
   if (myCopy)
   {
      totmem=MY_align;                          /* Needed for alignment.      */
      for (i=0; i<th; i++)                      
      {                                         
         mem[i] = ATL_geql2_LC_Setup(ts+i);     /* Find necessary memory.     */
         totmem += mem[i];                      /* Add to total.              */
      }                                         
                                                
      allMem = malloc(totmem);                  /* Allocate the memory.       */

      ts[0].A = (TYPE*) (((size_t) allMem+MY_align)&(-MY_align));
      for (i=1; i<th; i++)                      /* Each thread takes..        */
      {
         ts[i].A = (TYPE*) ((size_t) ts[i-1].A + mem[i-1]);/* ..next block.   */
      }
   }

   workSize = ((2 SHIFT)*(N+4)*sizeof(TYPE) + 
                     MY_align-1)&(-MY_align);   /* aligned. */
   totmem = MY_align + workSize*ATL_NTHREADS;   /* Find mem to alloc.        */
   workMem = malloc(totmem);
   ts[0].WORK = (TYPE*) (((size_t) workMem + MY_align-1)&(-MY_align));

   for (i=1; i<th; i++)
      ts[i].WORK = (TYPE*) ((size_t) ts[i-1].WORK + workSize);

/*----------------------------------------------------------------------------*/
/* Call ATL_launcher to launch thread which runs in different CPUs   cores    */
/*----------------------------------------------------------------------------*/

   ATL_goparallel(th, ATL_geql2Worker, ts, NULL);
@beginskip
   ls.opstruct = (char*) ts;
   ls.opstructstride = (int) ( ((char*)(ts+1)) - (char*)(ts) );
   ls.CombineOpStructs = NULL;
   ls.OpStructIsInit = Mjoin(PATL, StructIsInitGEQL2);

   ls.DoWork = ATL_geql2Worker;
   ls.rank2thr = tp;
   for (i=0; i < ATL_NTHREADS; i++)
   {
      tp[i].vp = &ls;
      tp[i].rank = i;
   }
   ATL_thread_start(tp, 0, ATL_tlaunch, tp);
   ATL_thread_join(tp);
@endskip


   if (allMem) 
      free(allMem);                         /* release copied area.           */
   free(workMem);                           /* release work area.             */
   return(0);                               /* Done with dgeql2.              */
} /* END ATL_t_dgeql2 */
@ROUT RUN_qrtest_pt.sh
cd ../bin ; make xsqrtst_pt xdqrtst_pt xcqrtst_pt xzqrtst_pt ; cd ../EXtest
#QR
../bin/xsqrtst_pt  -m 1 800   -n 1 128 -a 200 -S 1 R  -U 1 u -# 1
../bin/xsqrtst_pt  -m 1 2800   -n 1 1282 -a 200 -S 1 R  -U 1 u -# 1
../bin/xsqrtst_pt  -m 1 500   -n 1 500 -a 200 -S 1 R  -U 1 u -# 1
../bin/xsqrtst_pt  -m 1 600   -n 1 501 -a 200 -S 1 R  -U 1 u -# 1
../bin/xsqrtst_pt  -m 1 502   -n 1 600 -a 200 -S 1 R  -U 1 u -# 1
../bin/xsqrtst_pt  -m 1 60   -n 1 128 -a 200 -S 1 R  -U 1 u -# 1
../bin/xsqrtst_pt  -m 1 550   -n 1 550 -a 200 -S 1 R  -U 1 u -# 1
../bin/xsqrtst_pt  -m 1 800   -n 1 800 -a 200 -S 1 R  -U 1 u -# 1




../bin/xdqrtst_pt  -m 1 800   -n 1 128 -a 200 -S 1 R  -U 1 u -# 1
../bin/xdqrtst_pt  -m 1 2800   -n 1 1128 -a 200 -S 1 R  -U 1 u -# 1
../bin/xdqrtst_pt  -m 1 500   -n 1 500 -a 200 -S 1 R  -U 1 u -# 1
../bin/xdqrtst_pt  -m 1 600   -n 1 501 -a 200 -S 1 R  -U 1 u -# 1
../bin/xdqrtst_pt  -m 1 502   -n 1 600 -a 200 -S 1 R  -U 1 u -# 1
../bin/xdqrtst_pt  -m 1 60   -n 1 128 -a 200 -S 1 R  -U 1 u -# 1
../bin/xdqrtst_pt  -m 1 550   -n 1 550 -a 200 -S 1 R  -U 1 u -# 1
../bin/xdqrtst_pt  -m 1 800   -n 1 800 -a 200 -S 1 R  -U 1 u -# 1


../bin/xcqrtst_pt  -m 1 800   -n 1 128 -a 200 -S 1 R  -U 1 u -# 1
../bin/xcqrtst_pt  -m 1 800   -n 1 1280 -a 200 -S 1 R  -U 1 u -# 1
../bin/xcqrtst_pt  -m 1 500   -n 1 500 -a 200 -S 1 R  -U 1 u -# 1
../bin/xcqrtst_pt  -m 1 600   -n 1 501 -a 200 -S 1 R  -U 1 u -# 1
../bin/xcqrtst_pt  -m 1 502   -n 1 600 -a 200 -S 1 R  -U 1 u -# 1
../bin/xcqrtst_pt  -m 1 60   -n 1 128 -a 200 -S 1 R  -U 1 u -# 1
../bin/xcqrtst_pt  -m 1 550   -n 1 550 -a 200 -S 1 R  -U 1 u -# 1
../bin/xcqrtst_pt  -m 1 800   -n 1 800 -a 200 -S 1 R  -U 1 u -# 1


../bin/xzqrtst_pt  -m 1 800   -n 1 128 -a 200 -S 1 R  -U 1 u -# 1
../bin/xzqrtst_pt  -m 1 500   -n 1 500 -a 200 -S 1 R  -U 1 u -# 1
../bin/xzqrtst_pt  -m 1 600   -n 1 501 -a 200 -S 1 R  -U 1 u -# 1
../bin/xzqrtst_pt  -m 1 502   -n 1 600 -a 200 -S 1 R  -U 1 u -# 1
../bin/xzqrtst_pt  -m 1 60   -n 1 128 -a 200 -S 1 R  -U 1 u -# 1
../bin/xzqrtst_pt  -m 1 550   -n 1 550 -a 200 -S 1 R  -U 1 u -# 1
../bin/xzqrtst_pt  -m 1 800   -n 1 800 -a 200 -S 1 R  -U 1 u -# 1

#QL
../bin/xsqrtst_pt  -m 1 800   -n 1 128 -a 200 -S 1 R  -U 1 l -# 1
../bin/xsqrtst_pt  -m 1 500   -n 1 500 -a 200 -S 1 R  -U 1 l -# 1
../bin/xsqrtst_pt  -m 1 600   -n 1 501 -a 200 -S 1 R  -U 1 l -# 1
../bin/xsqrtst_pt  -m 1 502   -n 1 600 -a 200 -S 1 R  -U 1 l -# 1
../bin/xsqrtst_pt  -m 1 60   -n 1 128 -a 200 -S 1 R  -U 1 l -# 1
../bin/xsqrtst_pt  -m 1 550   -n 1 550 -a 200 -S 1 R  -U 1 l -# 1
../bin/xsqrtst_pt  -m 1 800   -n 1 800 -a 200 -S 1 R  -U 1 l -# 1


../bin/xdqrtst_pt  -m 1 800   -n 1 128 -a 200 -S 1 R  -U 1 l -# 1
../bin/xdqrtst_pt  -m 1 500   -n 1 500 -a 200 -S 1 R  -U 1 l -# 1
../bin/xdqrtst_pt  -m 1 600   -n 1 501 -a 200 -S 1 R  -U 1 l -# 1
../bin/xdqrtst_pt  -m 1 502   -n 1 600 -a 200 -S 1 R  -U 1 l -# 1
../bin/xdqrtst_pt  -m 1 60   -n 1 128 -a 200 -S 1 R  -U 1 l -# 1
../bin/xdqrtst_pt  -m 1 550   -n 1 550 -a 200 -S 1 R  -U 1 l -# 1
../bin/xdqrtst_pt  -m 1 800   -n 1 800 -a 200 -S 1 R  -U 1 l -# 1


../bin/xcqrtst_pt  -m 1 800   -n 1 128 -a 200 -S 1 R  -U 1 l -# 1
../bin/xcqrtst_pt  -m 1 500   -n 1 500 -a 200 -S 1 R  -U 1 l -# 1
../bin/xcqrtst_pt  -m 1 600   -n 1 501 -a 200 -S 1 R  -U 1 l -# 1
../bin/xcqrtst_pt  -m 1 502   -n 1 600 -a 200 -S 1 R  -U 1 l -# 1
../bin/xcqrtst_pt  -m 1 60   -n 1 128 -a 200 -S 1 R  -U 1 l -# 1
../bin/xcqrtst_pt  -m 1 550   -n 1 550 -a 200 -S 1 R  -U 1 l -# 1
../bin/xcqrtst_pt  -m 1 800   -n 1 800 -a 200 -S 1 R  -U 1 l -# 1

../bin/xzqrtst_pt  -m 1 800   -n 1 128 -a 200 -S 1 R  -U 1 l -# 1
../bin/xzqrtst_pt  -m 1 500   -n 1 500 -a 200 -S 1 R  -U 1 l -# 1
../bin/xzqrtst_pt  -m 1 600   -n 1 501 -a 200 -S 1 R  -U 1 l -# 1
../bin/xzqrtst_pt  -m 1 502   -n 1 600 -a 200 -S 1 R  -U 1 l -# 1
../bin/xzqrtst_pt  -m 1 60   -n 1 128 -a 200 -S 1 R  -U 1 l -# 1
../bin/xzqrtst_pt  -m 1 550   -n 1 550 -a 200 -S 1 R  -U 1 l -# 1
../bin/xzqrtst_pt  -m 1 800   -n 1 800 -a 200 -S 1 R  -U 1 l -# 1
#LQ
../bin/xsqrtst_pt  -m 1 800   -n 1 128 -a 200 -S 1 L  -U 1 l -# 1
../bin/xsqrtst_pt  -m 1 500   -n 1 500 -a 200 -S 1 L  -U 1 l -# 1
../bin/xsqrtst_pt  -m 1 600   -n 1 501 -a 200 -S 1 L  -U 1 l -# 1
../bin/xsqrtst_pt  -m 1 502   -n 1 600 -a 200 -S 1 L  -U 1 l -# 1
../bin/xsqrtst_pt  -m 1 60   -n 1 128 -a 200 -S 1 L  -U 1 l -# 1
../bin/xsqrtst_pt  -m 1 550   -n 1 550 -a 200 -S 1 L  -U 1 l -# 1
../bin/xsqrtst_pt  -m 1 800   -n 1 800 -a 200 -S 1 L  -U 1 l -# 1


../bin/xdqrtst_pt  -m 1 800   -n 1 128 -a 200 -S 1 L  -U 1 l -# 1
../bin/xdqrtst_pt  -m 1 500   -n 1 500 -a 200 -S 1 L  -U 1 l -#  1
../bin/xdqrtst_pt  -m 1 600   -n 1 501 -a 200 -S 1 L  -U 1 l -# 1
../bin/xdqrtst_pt  -m 1 502   -n 1 600 -a 200 -S 1 L  -U 1 l -# 1
../bin/xdqrtst_pt  -m 1 60   -n 1 128 -a 200 -S 1 L  -U 1 l -# 1
../bin/xdqrtst_pt  -m 1 550   -n 1 550 -a 200 -S 1 L  -U 1 l -# 1
../bin/xdqrtst_pt  -m 1 800   -n 1 800 -a 200 -S 1 L  -U 1 l -# 1


../bin/xcqrtst_pt  -m 1 800   -n 1 128 -a 200 -S 1 L  -U 1 l -# 1
../bin/xcqrtst_pt  -m 1 500   -n 1 500 -a 200 -S 1 L  -U 1 l -# 1
../bin/xcqrtst_pt  -m 1 600   -n 1 501 -a 200 -S 1 L  -U 1 l -# 1
../bin/xcqrtst_pt  -m 1 502   -n 1 600 -a 200 -S 1 L  -U 1 l -# 1
../bin/xcqrtst_pt  -m 1 60   -n 1 128 -a 200 -S 1 L  -U 1 l -# 1
../bin/xcqrtst_pt  -m 1 550   -n 1 550 -a 200 -S 1 L  -U 1 l -# 1
../bin/xcqrtst_pt  -m 1 800   -n 1 800 -a 200 -S 1 L  -U 1 l -# 1

../bin/xzqrtst_pt  -m 1 800   -n 1 128 -a 200 -S 1 L  -U 1 l -# 1
../bin/xzqrtst_pt  -m 1 500   -n 1 500 -a 200 -S 1 L  -U 1 l -# 1
../bin/xzqrtst_pt  -m 1 600   -n 1 501 -a 200 -S 1 L  -U 1 l -# 1
../bin/xzqrtst_pt  -m 1 502   -n 1 600 -a 200 -S 1 L  -U 1 l -# 1
../bin/xzqrtst_pt  -m 1 60   -n 1 128 -a 200 -S 1 L  -U 1 l -# 1
../bin/xzqrtst_pt  -m 1 550   -n 1 550 -a 200 -S 1 L  -U 1 l -# 1
../bin/xzqrtst_pt  -m 1 800   -n 1 800 -a 200 -S 1 L  -U 1 l -# 1


#RQ
../bin/xsqrtst_pt  -m 1 800   -n 1 128 -a 200 -S 1 L  -U 1 u -# 1
../bin/xsqrtst_pt  -m 1 500   -n 1 500 -a 200 -S 1 L  -U 1 u -# 1
../bin/xsqrtst_pt  -m 1 600   -n 1 501 -a 200 -S 1 L  -U 1 u -# 1
../bin/xsqrtst_pt  -m 1 502   -n 1 600 -a 200 -S 1 L  -U 1 u -# 1
../bin/xsqrtst_pt  -m 1 60   -n 1 128 -a 200 -S 1 L  -U 1 u -# 1
../bin/xsqrtst_pt  -m 1 550   -n 1 550 -a 200 -S 1 L  -U 1 u -# 1
../bin/xsqrtst_pt  -m 1 800   -n 1 800 -a 200 -S 1 L  -U 1 u -# 1


../bin/xdqrtst_pt  -m 1 800   -n 1 128 -a 200 -S 1 L  -U 1 u -# 1
../bin/xdqrtst_pt  -m 1 500   -n 1 500 -a 200 -S 1 L  -U 1 u -# 1
../bin/xdqrtst_pt  -m 1 600   -n 1 501 -a 200 -S 1 L  -U 1 u -# 1
../bin/xdqrtst_pt  -m 1 502   -n 1 600 -a 200 -S 1 L  -U 1 u -# 1
../bin/xdqrtst_pt  -m 1 60   -n 1 128 -a 200 -S 1 L  -U 1 u -# 1
../bin/xdqrtst_pt  -m 1 550   -n 1 550 -a 200 -S 1 L  -U 1 u -# 1
../bin/xdqrtst_pt  -m 1 800   -n 1 800 -a 200 -S 1 L  -U 1 u -# 1


../bin/xcqrtst_pt  -m 1 800   -n 1 128 -a 200 -S 1 L  -U 1 u -# 1
../bin/xcqrtst_pt  -m 1 500   -n 1 500 -a 200 -S 1 L  -U 1 u -# 1
../bin/xcqrtst_pt  -m 1 600   -n 1 501 -a 200 -S 1 L  -U 1 u -# 1
../bin/xcqrtst_pt  -m 1 502   -n 1 600 -a 200 -S 1 L  -U 1 u -# 1
../bin/xcqrtst_pt  -m 1 60   -n 1 128 -a 200 -S 1 L  -U 1 u -# 1
../bin/xcqrtst_pt  -m 1 550   -n 1 550 -a 200 -S 1 L  -U 1 u -# 1
../bin/xcqrtst_pt  -m 1 800   -n 1 800 -a 200 -S 1 L  -U 1 u -# 1

../bin/xzqrtst_pt  -m 1 800   -n 1 128 -a 200 -S 1 L  -U 1 u -# 1
../bin/xzqrtst_pt  -m 1 500   -n 1 500 -a 200 -S 1 L  -U 1 u -# 1
../bin/xzqrtst_pt  -m 1 600   -n 1 501 -a 200 -S 1 L  -U 1 u -# 1
../bin/xzqrtst_pt  -m 1 502   -n 1 600 -a 200 -S 1 L  -U 1 u -# 1
../bin/xzqrtst_pt  -m 1 60   -n 1 128 -a 200 -S 1 L  -U 1 u -# 1
../bin/xzqrtst_pt  -m 1 550   -n 1 550 -a 200 -S 1 L  -U 1 u -# 1
../bin/xzqrtst_pt  -m 1 800   -n 1 800 -a 200 -S 1 L  -U 1 u -# 1


@ROUT RUN_ormtst.sh
cd ../bin ; make xsormtst_pt xdormtst_pt xcormtst_pt xzormtst_pt; cd ../EXtest
#--------------------------x L -y N----------------------------------------------
#QR -x L -y N
../bin/xsormtst_pt  -m 1 800   -n 1 128 -a 200 -S 1 R  -U 1 u -# 1   -x L -y N  -z 100
../bin/xsormtst_pt  -m 1 2800   -n 1 1282 -a 200 -S 1 R  -U 1 u -# 1 -x L -y N  -z 100
../bin/xsormtst_pt  -m 1 500   -n 1 500 -a 200 -S 1 R  -U 1 u -# 1   -x L -y N  -z 200
../bin/xsormtst_pt  -m 1 600   -n 1 501 -a 200 -S 1 R  -U 1 u -# 1   -x L -y N  -z 300
../bin/xsormtst_pt  -m 1 502   -n 1 600 -a 200 -S 1 R  -U 1 u -# 1   -x L -y N  -z 400
../bin/xsormtst_pt  -m 1 60   -n 1 128 -a 200 -S 1 R  -U 1 u -# 1    -x L -y N  -z 300
../bin/xsormtst_pt  -m 1 550   -n 1 550 -a 200 -S 1 R  -U 1 u -# 1   -x L -y N  -z 200
../bin/xsormtst_pt  -m 1 800   -n 1 800 -a 200 -S 1 R  -U 1 u -# 1   -x L -y N  -z 400


../bin/xdormtst_pt  -m 1 800   -n 1 128 -a 200 -S 1 R  -U 1 u -# 1   -x L -y N  -z 100
../bin/xdormtst_pt  -m 1 2800   -n 1 1128 -a 200 -S 1 R  -U 1 u -# 1 -x L -y N  -z 200
../bin/xdormtst_pt  -m 1 500   -n 1 500 -a 200 -S 1 R  -U 1 u -# 1   -x L -y N  -z 100
../bin/xdormtst_pt  -m 1 600   -n 1 501 -a 200 -S 1 R  -U 1 u -# 1   -x L -y N  -z 500
../bin/xdormtst_pt  -m 1 502   -n 1 600 -a 200 -S 1 R  -U 1 u -# 1   -x L -y N  -z 100
../bin/xdormtst_pt  -m 1 60   -n 1 128 -a 200 -S 1 R  -U 1 u -# 1    -x L -y N  -z 100
../bin/xdormtst_pt  -m 1 550   -n 1 550 -a 200 -S 1 R  -U 1 u -# 1   -x L -y N  -z 300
../bin/xdormtst_pt  -m 1 800   -n 1 800 -a 200 -S 1 R  -U 1 u -# 1   -x L -y N  -z 100


../bin/xcormtst_pt  -m 1 800   -n 1 128 -a 200 -S 1 R  -U 1 u -# 1  -x L -y N  -z 100
../bin/xcormtst_pt  -m 1 800   -n 1 1280 -a 200 -S 1 R -U 1 u -# 1  -x L -y N  -z 100
../bin/xcormtst_pt  -m 1 500   -n 1 500 -a 200 -S 1 R  -U 1 u -# 1  -x L -y N  -z 100
../bin/xcormtst_pt  -m 1 600   -n 1 501 -a 200 -S 1 R  -U 1 u -# 1  -x L -y N  -z 100
../bin/xcormtst_pt  -m 1 502   -n 1 600 -a 200 -S 1 R  -U 1 u -# 1  -x L -y N  -z 100
../bin/xcormtst_pt  -m 1 60    -n 1 128 -a 200 -S 1 R  -U 1 u -# 1  -x L -y N  -z 100
../bin/xcormtst_pt  -m 1 550   -n 1 550 -a 200 -S 1 R  -U 1 u -# 1  -x L -y N  -z 100
../bin/xcormtst_pt  -m 1 800   -n 1 800 -a 200 -S 1 R  -U 1 u -# 1  -x L -y N  -z 100


../bin/xzormtst_pt  -m 1 800   -n 1 128 -a 200 -S 1 R  -U 1 u -# 1 -x L -y N  -z 100
../bin/xzormtst_pt  -m 1 500   -n 1 500 -a 200 -S 1 R  -U 1 u -# 1 -x L -y N  -z 300
../bin/xzormtst_pt  -m 1 600   -n 1 501 -a 200 -S 1 R  -U 1 u -# 1 -x L -y N  -z 500
../bin/xzormtst_pt  -m 1 502   -n 1 600 -a 200 -S 1 R  -U 1 u -# 1 -x L -y N  -z 100
../bin/xzormtst_pt  -m 1 60    -n 1 128 -a 200 -S 1 R  -U 1 u -# 1 -x L -y N  -z 200
../bin/xzormtst_pt  -m 1 550   -n 1 550 -a 200 -S 1 R  -U 1 u -# 1 -x L -y N  -z 220
../bin/xzormtst_pt  -m 1 800   -n 1 800 -a 200 -S 1 R  -U 1 u -# 1 -x L -y N  -z 100

#QL
../bin/xsormtst_pt  -m 1 800   -n 1 128 -a 200 -S 1 R  -U 1 l -# 1   -x L -y N  -z 100
../bin/xsormtst_pt  -m 1 2800   -n 1 1282 -a 200 -S 1 R  -U 1 l -# 1 -x L -y N  -z 100
../bin/xsormtst_pt  -m 1 500   -n 1 500 -a 200 -S 1 R  -U 1 l -# 1   -x L -y N  -z 200
../bin/xsormtst_pt  -m 1 600   -n 1 501 -a 200 -S 1 R  -U 1 l -# 1   -x L -y N  -z 300
../bin/xsormtst_pt  -m 1 502   -n 1 600 -a 200 -S 1 R  -U 1 l -# 1   -x L -y N  -z 400
../bin/xsormtst_pt  -m 1 60   -n 1 128 -a 200 -S 1 R  -U 1 l -# 1    -x L -y N  -z 300
../bin/xsormtst_pt  -m 1 550   -n 1 550 -a 200 -S 1 R  -U 1 l -# 1   -x L -y N  -z 200
../bin/xsormtst_pt  -m 1 800   -n 1 800 -a 200 -S 1 R  -U 1 l -# 1   -x L -y N  -z 400


../bin/xdormtst_pt  -m 1 800   -n 1 128 -a 200 -S 1 R  -U 1 l -# 1   -x L -y N  -z 100
../bin/xdormtst_pt  -m 1 2800   -n 1 1128 -a 200 -S 1 R  -U 1 l -# 1 -x L -y N  -z 200
../bin/xdormtst_pt  -m 1 500   -n 1 500 -a 200 -S 1 R  -U 1 l -# 1   -x L -y N  -z 100
../bin/xdormtst_pt  -m 1 600   -n 1 501 -a 200 -S 1 R  -U 1 l -# 1   -x L -y N  -z 500
../bin/xdormtst_pt  -m 1 502   -n 1 600 -a 200 -S 1 R  -U 1 l -# 1   -x L -y N  -z 100
../bin/xdormtst_pt  -m 1 60   -n 1 128 -a 200 -S 1 R  -U 1 l -# 1    -x L -y N  -z 100
../bin/xdormtst_pt  -m 1 550   -n 1 550 -a 200 -S 1 R  -U 1 l -# 1   -x L -y N  -z 300
../bin/xdormtst_pt  -m 1 800   -n 1 800 -a 200 -S 1 R  -U 1 l -# 1   -x L -y N  -z 100


../bin/xcormtst_pt  -m 1 800   -n 1 128 -a 200 -S 1 R  -U 1 l -# 1  -x L -y N  -z 100
../bin/xcormtst_pt  -m 1 800   -n 1 1280 -a 200 -S 1 R -U 1 l -# 1  -x L -y N  -z 100
../bin/xcormtst_pt  -m 1 500   -n 1 500 -a 200 -S 1 R  -U 1 l -# 1  -x L -y N  -z 100
../bin/xcormtst_pt  -m 1 600   -n 1 501 -a 200 -S 1 R  -U 1 l -# 1  -x L -y N  -z 100
../bin/xcormtst_pt  -m 1 502   -n 1 600 -a 200 -S 1 R  -U 1 l -# 1  -x L -y N  -z 100
../bin/xcormtst_pt  -m 1 60    -n 1 128 -a 200 -S 1 R  -U 1 l -# 1  -x L -y N  -z 100
../bin/xcormtst_pt  -m 1 550   -n 1 550 -a 200 -S 1 R  -U 1 l -# 1  -x L -y N  -z 100
../bin/xcormtst_pt  -m 1 800   -n 1 800 -a 200 -S 1 R  -U 1 l -# 1  -x L -y N  -z 100


../bin/xzormtst_pt  -m 1 800   -n 1 128 -a 200 -S 1 R  -U 1 l -# 1 -x L -y N  -z 100
../bin/xzormtst_pt  -m 1 500   -n 1 500 -a 200 -S 1 R  -U 1 l -# 1 -x L -y N  -z 300
../bin/xzormtst_pt  -m 1 600   -n 1 501 -a 200 -S 1 R  -U 1 l -# 1 -x L -y N  -z 500
../bin/xzormtst_pt  -m 1 502   -n 1 600 -a 200 -S 1 R  -U 1 l -# 1 -x L -y N  -z 100
../bin/xzormtst_pt  -m 1 60    -n 1 128 -a 200 -S 1 R  -U 1 l -# 1 -x L -y N  -z 200
../bin/xzormtst_pt  -m 1 550   -n 1 550 -a 200 -S 1 R  -U 1 l -# 1 -x L -y N  -z 220
../bin/xzormtst_pt  -m 1 800   -n 1 800 -a 200 -S 1 R  -U 1 l -# 1 -x L -y N  -z 100

#LQ
../bin/xsormtst_pt  -m 1 800   -n 1 128 -a 200 -S 1 L  -U 1 l -# 1   -x L -y N  -z 100
../bin/xsormtst_pt  -m 1 2800   -n 1 1282 -a 200 -S 1 L  -U 1 l -# 1 -x L -y N  -z 100
../bin/xsormtst_pt  -m 1 500   -n 1 500 -a 200 -S 1 L  -U 1 l -# 1   -x L -y N  -z 200
../bin/xsormtst_pt  -m 1 600   -n 1 501 -a 200 -S 1 L  -U 1 l -# 1   -x L -y N  -z 300
../bin/xsormtst_pt  -m 1 502   -n 1 600 -a 200 -S 1 L  -U 1 l -# 1   -x L -y N  -z 400
../bin/xsormtst_pt  -m 1 60   -n 1 128 -a 200 -S 1 L  -U 1 l -# 1    -x L -y N  -z 300
../bin/xsormtst_pt  -m 1 550   -n 1 550 -a 200 -S 1 L  -U 1 l -# 1   -x L -y N  -z 200
../bin/xsormtst_pt  -m 1 800   -n 1 800 -a 200 -S 1 L  -U 1 l -# 1   -x L -y N  -z 400

../bin/xdormtst_pt  -m 1 800   -n 1 128 -a 200 -S 1 L  -U 1 l -# 1   -x L -y N  -z 100
../bin/xdormtst_pt  -m 1 2800   -n 1 1128 -a 200 -S 1 L  -U 1 l -# 1 -x L -y N  -z 200
../bin/xdormtst_pt  -m 1 500   -n 1 500 -a 200 -S 1 L  -U 1 l -# 1   -x L -y N  -z 100
../bin/xdormtst_pt  -m 1 600   -n 1 501 -a 200 -S 1 L  -U 1 l -# 1   -x L -y N  -z 500
../bin/xdormtst_pt  -m 1 502   -n 1 600 -a 200 -S 1 L  -U 1 l -# 1   -x L -y N  -z 100
../bin/xdormtst_pt  -m 1 60   -n 1 128 -a 200 -S 1 L  -U 1 l -# 1    -x L -y N  -z 100
../bin/xdormtst_pt  -m 1 550   -n 1 550 -a 200 -S 1 L  -U 1 l -# 1   -x L -y N  -z 300
../bin/xdormtst_pt  -m 1 800   -n 1 800 -a 200 -S 1 L  -U 1 l -# 1   -x L -y N  -z 100

../bin/xcormtst_pt  -m 1 800   -n 1 128 -a 200 -S 1 L  -U 1 l -# 1  -x L -y N  -z 100
../bin/xcormtst_pt  -m 1 800   -n 1 1280 -a 200 -S 1 L -U 1 l -# 1  -x L -y N  -z 100
../bin/xcormtst_pt  -m 1 500   -n 1 500 -a 200 -S 1 L  -U 1 l -# 1  -x L -y N  -z 100
../bin/xcormtst_pt  -m 1 600   -n 1 501 -a 200 -S 1 L  -U 1 l -# 1  -x L -y N  -z 100
../bin/xcormtst_pt  -m 1 502   -n 1 600 -a 200 -S 1 L  -U 1 l -# 1  -x L -y N  -z 100
../bin/xcormtst_pt  -m 1 60    -n 1 128 -a 200 -S 1 L  -U 1 l -# 1  -x L -y N  -z 100
../bin/xcormtst_pt  -m 1 550   -n 1 550 -a 200 -S 1 L  -U 1 l -# 1  -x L -y N  -z 100
../bin/xcormtst_pt  -m 1 800   -n 1 800 -a 200 -S 1 L  -U 1 l -# 1  -x L -y N  -z 100

../bin/xzormtst_pt  -m 1 800   -n 1 128 -a 200 -S 1 L  -U 1 l -# 1 -x L -y N  -z 100
../bin/xzormtst_pt  -m 1 500   -n 1 500 -a 200 -S 1 L  -U 1 l -# 1 -x L -y N  -z 300
../bin/xzormtst_pt  -m 1 600   -n 1 501 -a 200 -S 1 L  -U 1 l -# 1 -x L -y N  -z 500
../bin/xzormtst_pt  -m 1 502   -n 1 600 -a 200 -S 1 L  -U 1 l -# 1 -x L -y N  -z 100
../bin/xzormtst_pt  -m 1 60    -n 1 128 -a 200 -S 1 L  -U 1 l -# 1 -x L -y N  -z 200
../bin/xzormtst_pt  -m 1 550   -n 1 550 -a 200 -S 1 L  -U 1 l -# 1 -x L -y N  -z 220
../bin/xzormtst_pt  -m 1 800   -n 1 800 -a 200 -S 1 L  -U 1 l -# 1 -x L -y N  -z 100

#RQ

../bin/xsormtst_pt  -m 1 800   -n 1 128 -a 200 -S 1 L  -U 1 u -# 1   -x L -y N  -z 100
../bin/xsormtst_pt  -m 1 2800   -n 1 1282 -a 200 -S 1 L  -U 1 u -# 1 -x L -y N  -z 100
../bin/xsormtst_pt  -m 1 500   -n 1 500 -a 200 -S 1 L  -U 1 u -# 1   -x L -y N  -z 200
../bin/xsormtst_pt  -m 1 600   -n 1 501 -a 200 -S 1 L  -U 1 u -# 1   -x L -y N  -z 300
../bin/xsormtst_pt  -m 1 502   -n 1 600 -a 200 -S 1 L  -U 1 u -# 1   -x L -y N  -z 400
../bin/xsormtst_pt  -m 1 60   -n 1 128 -a 200 -S 1 L  -U 1 u -# 1    -x L -y N  -z 300
../bin/xsormtst_pt  -m 1 550   -n 1 550 -a 200 -S 1 L  -U 1 u -# 1   -x L -y N  -z 200
../bin/xsormtst_pt  -m 1 800   -n 1 800 -a 200 -S 1 L  -U 1 u -# 1   -x L -y N  -z 400

../bin/xdormtst_pt  -m 1 800   -n 1 128 -a 200 -S 1 L  -U 1 u -# 1   -x L -y N  -z 100
../bin/xdormtst_pt  -m 1 2800   -n 1 1128 -a 200 -S 1 L  -U 1 u -# 1 -x L -y N  -z 200
../bin/xdormtst_pt  -m 1 500   -n 1 500 -a 200 -S 1 L  -U 1 u -# 1   -x L -y N  -z 100
../bin/xdormtst_pt  -m 1 600   -n 1 501 -a 200 -S 1 L  -U 1 u -# 1   -x L -y N  -z 500
../bin/xdormtst_pt  -m 1 502   -n 1 600 -a 200 -S 1 L  -U 1 u -# 1   -x L -y N  -z 100
../bin/xdormtst_pt  -m 1 60   -n 1 128 -a 200 -S 1 L  -U 1 u -# 1    -x L -y N  -z 100
../bin/xdormtst_pt  -m 1 550   -n 1 550 -a 200 -S 1 L  -U 1 u -# 1   -x L -y N  -z 300
../bin/xdormtst_pt  -m 1 800   -n 1 800 -a 200 -S 1 L  -U 1 u -# 1   -x L -y N  -z 100

../bin/xcormtst_pt  -m 1 800   -n 1 128 -a 200 -S 1 L  -U 1 u -# 1  -x L -y N  -z 100
../bin/xcormtst_pt  -m 1 800   -n 1 1280 -a 200 -S 1 L -U 1 u -# 1  -x L -y N  -z 100
../bin/xcormtst_pt  -m 1 500   -n 1 500 -a 200 -S 1 L  -U 1 u -# 1  -x L -y N  -z 100
../bin/xcormtst_pt  -m 1 600   -n 1 501 -a 200 -S 1 L  -U 1 u -# 1  -x L -y N  -z 100
../bin/xcormtst_pt  -m 1 502   -n 1 600 -a 200 -S 1 L  -U 1 u -# 1  -x L -y N  -z 100
../bin/xcormtst_pt  -m 1 60    -n 1 128 -a 200 -S 1 L  -U 1 u -# 1  -x L -y N  -z 100
../bin/xcormtst_pt  -m 1 550   -n 1 550 -a 200 -S 1 L  -U 1 u -# 1  -x L -y N  -z 100
../bin/xcormtst_pt  -m 1 800   -n 1 800 -a 200 -S 1 L  -U 1 u -# 1  -x L -y N  -z 100

../bin/xzormtst_pt  -m 1 800   -n 1 128 -a 200 -S 1 L  -U 1 u -# 1 -x L -y N  -z 100
../bin/xzormtst_pt  -m 1 500   -n 1 500 -a 200 -S 1 L  -U 1 u -# 1 -x L -y N  -z 300
../bin/xzormtst_pt  -m 1 600   -n 1 501 -a 200 -S 1 L  -U 1 u -# 1 -x L -y N  -z 500
../bin/xzormtst_pt  -m 1 502   -n 1 600 -a 200 -S 1 L  -U 1 u -# 1 -x L -y N  -z 100
../bin/xzormtst_pt  -m 1 60    -n 1 128 -a 200 -S 1 L  -U 1 u -# 1 -x L -y N  -z 200
../bin/xzormtst_pt  -m 1 550   -n 1 550 -a 200 -S 1 L  -U 1 u -# 1 -x L -y N  -z 220
../bin/xzormtst_pt  -m 1 800   -n 1 800 -a 200 -S 1 L  -U 1 u -# 1 -x L -y N  -z 100

#--------------------------x L -y T----------------------------------------------
#QR -x L -y T
../bin/xsormtst_pt  -m 1 800   -n 1 128 -a 200 -S 1 R  -U 1 u -# 1   -x L -y T  -z 100
../bin/xsormtst_pt  -m 1 2800   -n 1 1282 -a 200 -S 1 R  -U 1 u -# 1 -x L -y T  -z 100
../bin/xsormtst_pt  -m 1 500   -n 1 500 -a 200 -S 1 R  -U 1 u -# 1   -x L -y T  -z 200
../bin/xsormtst_pt  -m 1 600   -n 1 501 -a 200 -S 1 R  -U 1 u -# 1   -x L -y T  -z 300
../bin/xsormtst_pt  -m 1 502   -n 1 600 -a 200 -S 1 R  -U 1 u -# 1   -x L -y T  -z 400
../bin/xsormtst_pt  -m 1 60   -n 1 128 -a 200 -S 1 R  -U 1 u -# 1    -x L -y T  -z 300
../bin/xsormtst_pt  -m 1 550   -n 1 550 -a 200 -S 1 R  -U 1 u -# 1   -x L -y T  -z 200
../bin/xsormtst_pt  -m 1 800   -n 1 800 -a 200 -S 1 R  -U 1 u -# 1   -x L -y T  -z 400


../bin/xdormtst_pt  -m 1 800   -n 1 128 -a 200 -S 1 R  -U 1 u -# 1   -x L -y T  -z 100
../bin/xdormtst_pt  -m 1 2800   -n 1 1128 -a 200 -S 1 R  -U 1 u -# 1 -x L -y T  -z 200
../bin/xdormtst_pt  -m 1 500   -n 1 500 -a 200 -S 1 R  -U 1 u -# 1   -x L -y T  -z 100
../bin/xdormtst_pt  -m 1 600   -n 1 501 -a 200 -S 1 R  -U 1 u -# 1   -x L -y T  -z 500
../bin/xdormtst_pt  -m 1 502   -n 1 600 -a 200 -S 1 R  -U 1 u -# 1   -x L -y T  -z 100
../bin/xdormtst_pt  -m 1 60   -n 1 128 -a 200 -S 1 R  -U 1 u -# 1    -x L -y T  -z 100
../bin/xdormtst_pt  -m 1 550   -n 1 550 -a 200 -S 1 R  -U 1 u -# 1   -x L -y T  -z 300
../bin/xdormtst_pt  -m 1 800   -n 1 800 -a 200 -S 1 R  -U 1 u -# 1   -x L -y T  -z 100


../bin/xcormtst_pt  -m 1 800   -n 1 128 -a 200 -S 1 R  -U 1 u -# 1  -x L -y T  -z 100
../bin/xcormtst_pt  -m 1 800   -n 1 1280 -a 200 -S 1 R -U 1 u -# 1  -x L -y T  -z 100
../bin/xcormtst_pt  -m 1 500   -n 1 500 -a 200 -S 1 R  -U 1 u -# 1  -x L -y T  -z 100
../bin/xcormtst_pt  -m 1 600   -n 1 501 -a 200 -S 1 R  -U 1 u -# 1  -x L -y T  -z 100
../bin/xcormtst_pt  -m 1 502   -n 1 600 -a 200 -S 1 R  -U 1 u -# 1  -x L -y T  -z 100
../bin/xcormtst_pt  -m 1 60    -n 1 128 -a 200 -S 1 R  -U 1 u -# 1  -x L -y T  -z 100
../bin/xcormtst_pt  -m 1 550   -n 1 550 -a 200 -S 1 R  -U 1 u -# 1  -x L -y T  -z 100
../bin/xcormtst_pt  -m 1 800   -n 1 800 -a 200 -S 1 R  -U 1 u -# 1  -x L -y T  -z 100


../bin/xzormtst_pt  -m 1 800   -n 1 128 -a 200 -S 1 R  -U 1 u -# 1 -x L -y T  -z 100
../bin/xzormtst_pt  -m 1 500   -n 1 500 -a 200 -S 1 R  -U 1 u -# 1 -x L -y T  -z 300
../bin/xzormtst_pt  -m 1 600   -n 1 501 -a 200 -S 1 R  -U 1 u -# 1 -x L -y T  -z 500
../bin/xzormtst_pt  -m 1 502   -n 1 600 -a 200 -S 1 R  -U 1 u -# 1 -x L -y T  -z 100
../bin/xzormtst_pt  -m 1 60    -n 1 128 -a 200 -S 1 R  -U 1 u -# 1 -x L -y T  -z 200
../bin/xzormtst_pt  -m 1 550   -n 1 550 -a 200 -S 1 R  -U 1 u -# 1 -x L -y T  -z 220
../bin/xzormtst_pt  -m 1 800   -n 1 800 -a 200 -S 1 R  -U 1 u -# 1 -x L -y T  -z 100

#QL
../bin/xsormtst_pt  -m 1 800   -n 1 128 -a 200 -S 1 R  -U 1 l -# 1   -x L -y T  -z 100
../bin/xsormtst_pt  -m 1 2800   -n 1 1282 -a 200 -S 1 R  -U 1 l -# 1 -x L -y T  -z 100
../bin/xsormtst_pt  -m 1 500   -n 1 500 -a 200 -S 1 R  -U 1 l -# 1   -x L -y T  -z 200
../bin/xsormtst_pt  -m 1 600   -n 1 501 -a 200 -S 1 R  -U 1 l -# 1   -x L -y T  -z 300
../bin/xsormtst_pt  -m 1 502   -n 1 600 -a 200 -S 1 R  -U 1 l -# 1   -x L -y T  -z 400
../bin/xsormtst_pt  -m 1 60   -n 1 128 -a 200 -S 1 R  -U 1 l -# 1    -x L -y T  -z 300
../bin/xsormtst_pt  -m 1 550   -n 1 550 -a 200 -S 1 R  -U 1 l -# 1   -x L -y T  -z 200
../bin/xsormtst_pt  -m 1 800   -n 1 800 -a 200 -S 1 R  -U 1 l -# 1   -x L -y T  -z 400


../bin/xdormtst_pt  -m 1 800   -n 1 128 -a 200 -S 1 R  -U 1 l -# 1   -x L -y T  -z 100
../bin/xdormtst_pt  -m 1 2800   -n 1 1128 -a 200 -S 1 R  -U 1 l -# 1 -x L -y T  -z 200
../bin/xdormtst_pt  -m 1 500   -n 1 500 -a 200 -S 1 R  -U 1 l -# 1   -x L -y T  -z 100
../bin/xdormtst_pt  -m 1 600   -n 1 501 -a 200 -S 1 R  -U 1 l -# 1   -x L -y T  -z 500
../bin/xdormtst_pt  -m 1 502   -n 1 600 -a 200 -S 1 R  -U 1 l -# 1   -x L -y T  -z 100
../bin/xdormtst_pt  -m 1 60   -n 1 128 -a 200 -S 1 R  -U 1 l -# 1    -x L -y T  -z 100
../bin/xdormtst_pt  -m 1 550   -n 1 550 -a 200 -S 1 R  -U 1 l -# 1   -x L -y T  -z 300
../bin/xdormtst_pt  -m 1 800   -n 1 800 -a 200 -S 1 R  -U 1 l -# 1   -x L -y T  -z 100


../bin/xcormtst_pt  -m 1 800   -n 1 128 -a 200 -S 1 R  -U 1 l -# 1  -x L -y T  -z 100
../bin/xcormtst_pt  -m 1 800   -n 1 1280 -a 200 -S 1 R -U 1 l -# 1  -x L -y T  -z 100
../bin/xcormtst_pt  -m 1 500   -n 1 500 -a 200 -S 1 R  -U 1 l -# 1  -x L -y T  -z 100
../bin/xcormtst_pt  -m 1 600   -n 1 501 -a 200 -S 1 R  -U 1 l -# 1  -x L -y T  -z 100
../bin/xcormtst_pt  -m 1 502   -n 1 600 -a 200 -S 1 R  -U 1 l -# 1  -x L -y T  -z 100
../bin/xcormtst_pt  -m 1 60    -n 1 128 -a 200 -S 1 R  -U 1 l -# 1  -x L -y T  -z 100
../bin/xcormtst_pt  -m 1 550   -n 1 550 -a 200 -S 1 R  -U 1 l -# 1  -x L -y T  -z 100
../bin/xcormtst_pt  -m 1 800   -n 1 800 -a 200 -S 1 R  -U 1 l -# 1  -x L -y T  -z 100


../bin/xzormtst_pt  -m 1 800   -n 1 128 -a 200 -S 1 R  -U 1 l -# 1 -x L -y T  -z 100
../bin/xzormtst_pt  -m 1 500   -n 1 500 -a 200 -S 1 R  -U 1 l -# 1 -x L -y T  -z 300
../bin/xzormtst_pt  -m 1 600   -n 1 501 -a 200 -S 1 R  -U 1 l -# 1 -x L -y T  -z 500
../bin/xzormtst_pt  -m 1 502   -n 1 600 -a 200 -S 1 R  -U 1 l -# 1 -x L -y T  -z 100
../bin/xzormtst_pt  -m 1 60    -n 1 128 -a 200 -S 1 R  -U 1 l -# 1 -x L -y T  -z 200
../bin/xzormtst_pt  -m 1 550   -n 1 550 -a 200 -S 1 R  -U 1 l -# 1 -x L -y T  -z 220
../bin/xzormtst_pt  -m 1 800   -n 1 800 -a 200 -S 1 R  -U 1 l -# 1 -x L -y T  -z 100

#LQ
../bin/xsormtst_pt  -m 1 800   -n 1 128 -a 200 -S 1 L  -U 1 l -# 1   -x L -y T  -z 100
../bin/xsormtst_pt  -m 1 2800   -n 1 1282 -a 200 -S 1 L  -U 1 l -# 1 -x L -y T  -z 100
../bin/xsormtst_pt  -m 1 500   -n 1 500 -a 200 -S 1 L  -U 1 l -# 1   -x L -y T  -z 200
../bin/xsormtst_pt  -m 1 600   -n 1 501 -a 200 -S 1 L  -U 1 l -# 1   -x L -y T  -z 300
../bin/xsormtst_pt  -m 1 502   -n 1 600 -a 200 -S 1 L  -U 1 l -# 1   -x L -y T  -z 400
../bin/xsormtst_pt  -m 1 60   -n 1 128 -a 200 -S 1 L  -U 1 l -# 1    -x L -y T  -z 300
../bin/xsormtst_pt  -m 1 550   -n 1 550 -a 200 -S 1 L  -U 1 l -# 1   -x L -y T  -z 200
../bin/xsormtst_pt  -m 1 800   -n 1 800 -a 200 -S 1 L  -U 1 l -# 1   -x L -y T  -z 400

../bin/xdormtst_pt  -m 1 800   -n 1 128 -a 200 -S 1 L  -U 1 l -# 1   -x L -y T  -z 100
../bin/xdormtst_pt  -m 1 2800   -n 1 1128 -a 200 -S 1 L  -U 1 l -# 1 -x L -y T  -z 200
../bin/xdormtst_pt  -m 1 500   -n 1 500 -a 200 -S 1 L  -U 1 l -# 1   -x L -y T  -z 100
../bin/xdormtst_pt  -m 1 600   -n 1 501 -a 200 -S 1 L  -U 1 l -# 1   -x L -y T  -z 500
../bin/xdormtst_pt  -m 1 502   -n 1 600 -a 200 -S 1 L  -U 1 l -# 1   -x L -y T  -z 100
../bin/xdormtst_pt  -m 1 60   -n 1 128 -a 200 -S 1 L  -U 1 l -# 1    -x L -y T  -z 100
../bin/xdormtst_pt  -m 1 550   -n 1 550 -a 200 -S 1 L  -U 1 l -# 1   -x L -y T  -z 300
../bin/xdormtst_pt  -m 1 800   -n 1 800 -a 200 -S 1 L  -U 1 l -# 1   -x L -y T  -z 100

../bin/xcormtst_pt  -m 1 800   -n 1 128 -a 200 -S 1 L  -U 1 l -# 1  -x L -y T  -z 100
../bin/xcormtst_pt  -m 1 800   -n 1 1280 -a 200 -S 1 L -U 1 l -# 1  -x L -y T  -z 100
../bin/xcormtst_pt  -m 1 500   -n 1 500 -a 200 -S 1 L  -U 1 l -# 1  -x L -y T  -z 100
../bin/xcormtst_pt  -m 1 600   -n 1 501 -a 200 -S 1 L  -U 1 l -# 1  -x L -y T  -z 100
../bin/xcormtst_pt  -m 1 502   -n 1 600 -a 200 -S 1 L  -U 1 l -# 1  -x L -y T  -z 100
../bin/xcormtst_pt  -m 1 60    -n 1 128 -a 200 -S 1 L  -U 1 l -# 1  -x L -y T  -z 100
../bin/xcormtst_pt  -m 1 550   -n 1 550 -a 200 -S 1 L  -U 1 l -# 1  -x L -y T  -z 100
../bin/xcormtst_pt  -m 1 800   -n 1 800 -a 200 -S 1 L  -U 1 l -# 1  -x L -y T  -z 100

../bin/xzormtst_pt  -m 1 800   -n 1 128 -a 200 -S 1 L  -U 1 l -# 1 -x L -y T  -z 100
../bin/xzormtst_pt  -m 1 500   -n 1 500 -a 200 -S 1 L  -U 1 l -# 1 -x L -y T  -z 300
../bin/xzormtst_pt  -m 1 600   -n 1 501 -a 200 -S 1 L  -U 1 l -# 1 -x L -y T  -z 500
../bin/xzormtst_pt  -m 1 502   -n 1 600 -a 200 -S 1 L  -U 1 l -# 1 -x L -y T  -z 100
../bin/xzormtst_pt  -m 1 60    -n 1 128 -a 200 -S 1 L  -U 1 l -# 1 -x L -y T  -z 200
../bin/xzormtst_pt  -m 1 550   -n 1 550 -a 200 -S 1 L  -U 1 l -# 1 -x L -y T  -z 220
../bin/xzormtst_pt  -m 1 800   -n 1 800 -a 200 -S 1 L  -U 1 l -# 1 -x L -y T  -z 100

#RQ

../bin/xsormtst_pt  -m 1 800   -n 1 128 -a 200 -S 1 L  -U 1 u -# 1   -x L -y T  -z 100
../bin/xsormtst_pt  -m 1 2800   -n 1 1282 -a 200 -S 1 L  -U 1 u -# 1 -x L -y T  -z 100
../bin/xsormtst_pt  -m 1 500   -n 1 500 -a 200 -S 1 L  -U 1 u -# 1   -x L -y T  -z 200
../bin/xsormtst_pt  -m 1 600   -n 1 501 -a 200 -S 1 L  -U 1 u -# 1   -x L -y T  -z 300
../bin/xsormtst_pt  -m 1 502   -n 1 600 -a 200 -S 1 L  -U 1 u -# 1   -x L -y T  -z 400
../bin/xsormtst_pt  -m 1 60   -n 1 128 -a 200 -S 1 L  -U 1 u -# 1    -x L -y T  -z 300
../bin/xsormtst_pt  -m 1 550   -n 1 550 -a 200 -S 1 L  -U 1 u -# 1   -x L -y T  -z 200
../bin/xsormtst_pt  -m 1 800   -n 1 800 -a 200 -S 1 L  -U 1 u -# 1   -x L -y T  -z 400

../bin/xdormtst_pt  -m 1 800   -n 1 128 -a 200 -S 1 L  -U 1 u -# 1   -x L -y T  -z 100
../bin/xdormtst_pt  -m 1 2800   -n 1 1128 -a 200 -S 1 L  -U 1 u -# 1 -x L -y T  -z 200
../bin/xdormtst_pt  -m 1 500   -n 1 500 -a 200 -S 1 L  -U 1 u -# 1   -x L -y T  -z 100
../bin/xdormtst_pt  -m 1 600   -n 1 501 -a 200 -S 1 L  -U 1 u -# 1   -x L -y T  -z 500
../bin/xdormtst_pt  -m 1 502   -n 1 600 -a 200 -S 1 L  -U 1 u -# 1   -x L -y T  -z 100
../bin/xdormtst_pt  -m 1 60   -n 1 128 -a 200 -S 1 L  -U 1 u -# 1    -x L -y T  -z 100
../bin/xdormtst_pt  -m 1 550   -n 1 550 -a 200 -S 1 L  -U 1 u -# 1   -x L -y T  -z 300
../bin/xdormtst_pt  -m 1 800   -n 1 800 -a 200 -S 1 L  -U 1 u -# 1   -x L -y T  -z 100

../bin/xcormtst_pt  -m 1 800   -n 1 128 -a 200 -S 1 L  -U 1 u -# 1  -x L -y T  -z 100
../bin/xcormtst_pt  -m 1 800   -n 1 1280 -a 200 -S 1 L -U 1 u -# 1  -x L -y T  -z 100
../bin/xcormtst_pt  -m 1 500   -n 1 500 -a 200 -S 1 L  -U 1 u -# 1  -x L -y T  -z 100
../bin/xcormtst_pt  -m 1 600   -n 1 501 -a 200 -S 1 L  -U 1 u -# 1  -x L -y T  -z 100
../bin/xcormtst_pt  -m 1 502   -n 1 600 -a 200 -S 1 L  -U 1 u -# 1  -x L -y T  -z 100
../bin/xcormtst_pt  -m 1 60    -n 1 128 -a 200 -S 1 L  -U 1 u -# 1  -x L -y T  -z 100
../bin/xcormtst_pt  -m 1 550   -n 1 550 -a 200 -S 1 L  -U 1 u -# 1  -x L -y T  -z 100
../bin/xcormtst_pt  -m 1 800   -n 1 800 -a 200 -S 1 L  -U 1 u -# 1  -x L -y T  -z 100

../bin/xzormtst_pt  -m 1 800   -n 1 128 -a 200 -S 1 L  -U 1 u -# 1 -x L -y T  -z 100
../bin/xzormtst_pt  -m 1 500   -n 1 500 -a 200 -S 1 L  -U 1 u -# 1 -x L -y T  -z 300
../bin/xzormtst_pt  -m 1 600   -n 1 501 -a 200 -S 1 L  -U 1 u -# 1 -x L -y T  -z 500
../bin/xzormtst_pt  -m 1 502   -n 1 600 -a 200 -S 1 L  -U 1 u -# 1 -x L -y T  -z 100
../bin/xzormtst_pt  -m 1 60    -n 1 128 -a 200 -S 1 L  -U 1 u -# 1 -x L -y T  -z 200
../bin/xzormtst_pt  -m 1 550   -n 1 550 -a 200 -S 1 L  -U 1 u -# 1 -x L -y T  -z 220
../bin/xzormtst_pt  -m 1 800   -n 1 800 -a 200 -S 1 L  -U 1 u -# 1 -x L -y T  -z 100

#QR -x R -y N
#--------------------------x L -y T----------------------------------------------
../bin/xsormtst_pt  -m 1 800   -n 1 128 -a 200 -S 1 R  -U 1 u -# 1   -x R -y N  -z 100
../bin/xsormtst_pt  -m 1 2800   -n 1 1282 -a 200 -S 1 R  -U 1 u -# 1 -x R -y N  -z 100
../bin/xsormtst_pt  -m 1 500   -n 1 500 -a 200 -S 1 R  -U 1 u -# 1   -x R -y N  -z 200
../bin/xsormtst_pt  -m 1 600   -n 1 501 -a 200 -S 1 R  -U 1 u -# 1   -x R -y N  -z 300
../bin/xsormtst_pt  -m 1 502   -n 1 600 -a 200 -S 1 R  -U 1 u -# 1   -x R -y N  -z 400
../bin/xsormtst_pt  -m 1 60   -n 1 128 -a 200 -S 1 R  -U 1 u -# 1    -x R -y N  -z 300
../bin/xsormtst_pt  -m 1 550   -n 1 550 -a 200 -S 1 R  -U 1 u -# 1   -x R -y N  -z 200
../bin/xsormtst_pt  -m 1 800   -n 1 800 -a 200 -S 1 R  -U 1 u -# 1   -x R -y N  -z 400


../bin/xdormtst_pt  -m 1 800   -n 1 128 -a 200 -S 1 R  -U 1 u -# 1   -x R -y N  -z 100
../bin/xdormtst_pt  -m 1 2800   -n 1 1128 -a 200 -S 1 R  -U 1 u -# 1 -x R -y N  -z 200
../bin/xdormtst_pt  -m 1 500   -n 1 500 -a 200 -S 1 R  -U 1 u -# 1   -x R -y N  -z 100
../bin/xdormtst_pt  -m 1 600   -n 1 501 -a 200 -S 1 R  -U 1 u -# 1   -x R -y N  -z 500
../bin/xdormtst_pt  -m 1 502   -n 1 600 -a 200 -S 1 R  -U 1 u -# 1   -x R -y N  -z 100
../bin/xdormtst_pt  -m 1 60   -n 1 128 -a 200 -S 1 R  -U 1 u -# 1    -x R -y N  -z 100
../bin/xdormtst_pt  -m 1 550   -n 1 550 -a 200 -S 1 R  -U 1 u -# 1   -x R -y N  -z 300
../bin/xdormtst_pt  -m 1 800   -n 1 800 -a 200 -S 1 R  -U 1 u -# 1   -x R -y N  -z 100


../bin/xcormtst_pt  -m 1 800   -n 1 128 -a 200 -S 1 R  -U 1 u -# 1  -x R -y N  -z 100
../bin/xcormtst_pt  -m 1 800   -n 1 1280 -a 200 -S 1 R -U 1 u -# 1  -x R -y N  -z 100
../bin/xcormtst_pt  -m 1 500   -n 1 500 -a 200 -S 1 R  -U 1 u -# 1  -x R -y N  -z 100
../bin/xcormtst_pt  -m 1 600   -n 1 501 -a 200 -S 1 R  -U 1 u -# 1  -x R -y N  -z 100
../bin/xcormtst_pt  -m 1 502   -n 1 600 -a 200 -S 1 R  -U 1 u -# 1  -x R -y N  -z 100
../bin/xcormtst_pt  -m 1 60    -n 1 128 -a 200 -S 1 R  -U 1 u -# 1  -x R -y N  -z 100
../bin/xcormtst_pt  -m 1 550   -n 1 550 -a 200 -S 1 R  -U 1 u -# 1  -x R -y N  -z 100
../bin/xcormtst_pt  -m 1 800   -n 1 800 -a 200 -S 1 R  -U 1 u -# 1  -x R -y N  -z 100


../bin/xzormtst_pt  -m 1 800   -n 1 128 -a 200 -S 1 R  -U 1 u -# 1 -x R -y N  -z 100
../bin/xzormtst_pt  -m 1 500   -n 1 500 -a 200 -S 1 R  -U 1 u -# 1 -x R -y N  -z 300
../bin/xzormtst_pt  -m 1 600   -n 1 501 -a 200 -S 1 R  -U 1 u -# 1 -x R -y N  -z 500
../bin/xzormtst_pt  -m 1 502   -n 1 600 -a 200 -S 1 R  -U 1 u -# 1 -x R -y N  -z 100
../bin/xzormtst_pt  -m 1 60    -n 1 128 -a 200 -S 1 R  -U 1 u -# 1 -x R -y N  -z 200
../bin/xzormtst_pt  -m 1 550   -n 1 550 -a 200 -S 1 R  -U 1 u -# 1 -x R -y N  -z 220
../bin/xzormtst_pt  -m 1 800   -n 1 800 -a 200 -S 1 R  -U 1 u -# 1 -x R -y N  -z 100

#QL
../bin/xsormtst_pt  -m 1 800   -n 1 128 -a 200 -S 1 R  -U 1 l -# 1   -x R -y N  -z 100
../bin/xsormtst_pt  -m 1 2800   -n 1 1282 -a 200 -S 1 R  -U 1 l -# 1 -x R -y N  -z 100
../bin/xsormtst_pt  -m 1 500   -n 1 500 -a 200 -S 1 R  -U 1 l -# 1   -x R -y N  -z 200
../bin/xsormtst_pt  -m 1 600   -n 1 501 -a 200 -S 1 R  -U 1 l -# 1   -x R -y N  -z 300
../bin/xsormtst_pt  -m 1 502   -n 1 600 -a 200 -S 1 R  -U 1 l -# 1   -x R -y N  -z 400
../bin/xsormtst_pt  -m 1 60   -n 1 128 -a 200 -S 1 R  -U 1 l -# 1    -x R -y N  -z 300
../bin/xsormtst_pt  -m 1 550   -n 1 550 -a 200 -S 1 R  -U 1 l -# 1   -x R -y N  -z 200
../bin/xsormtst_pt  -m 1 800   -n 1 800 -a 200 -S 1 R  -U 1 l -# 1   -x R -y N  -z 400


../bin/xdormtst_pt  -m 1 800   -n 1 128 -a 200 -S 1 R  -U 1 l -# 1   -x R -y N  -z 100
../bin/xdormtst_pt  -m 1 2800   -n 1 1128 -a 200 -S 1 R  -U 1 l -# 1 -x R -y N  -z 200
../bin/xdormtst_pt  -m 1 500   -n 1 500 -a 200 -S 1 R  -U 1 l -# 1   -x R -y N  -z 100
../bin/xdormtst_pt  -m 1 600   -n 1 501 -a 200 -S 1 R  -U 1 l -# 1   -x R -y N  -z 500
../bin/xdormtst_pt  -m 1 502   -n 1 600 -a 200 -S 1 R  -U 1 l -# 1   -x R -y N  -z 100
../bin/xdormtst_pt  -m 1 60   -n 1 128 -a 200 -S 1 R  -U 1 l -# 1    -x R -y N  -z 100
../bin/xdormtst_pt  -m 1 550   -n 1 550 -a 200 -S 1 R  -U 1 l -# 1   -x R -y N  -z 300
../bin/xdormtst_pt  -m 1 800   -n 1 800 -a 200 -S 1 R  -U 1 l -# 1   -x R -y N  -z 100


../bin/xcormtst_pt  -m 1 800   -n 1 128 -a 200 -S 1 R  -U 1 l -# 1  -x R -y N  -z 100
../bin/xcormtst_pt  -m 1 800   -n 1 1280 -a 200 -S 1 R -U 1 l -# 1  -x R -y N  -z 100
../bin/xcormtst_pt  -m 1 500   -n 1 500 -a 200 -S 1 R  -U 1 l -# 1  -x R -y N  -z 100
../bin/xcormtst_pt  -m 1 600   -n 1 501 -a 200 -S 1 R  -U 1 l -# 1  -x R -y N  -z 100
../bin/xcormtst_pt  -m 1 502   -n 1 600 -a 200 -S 1 R  -U 1 l -# 1  -x R -y N  -z 100
../bin/xcormtst_pt  -m 1 60    -n 1 128 -a 200 -S 1 R  -U 1 l -# 1  -x R -y N  -z 100
../bin/xcormtst_pt  -m 1 550   -n 1 550 -a 200 -S 1 R  -U 1 l -# 1  -x R -y N  -z 100
../bin/xcormtst_pt  -m 1 800   -n 1 800 -a 200 -S 1 R  -U 1 l -# 1  -x R -y N  -z 100


../bin/xzormtst_pt  -m 1 800   -n 1 128 -a 200 -S 1 R  -U 1 l -# 1 -x R -y N  -z 100
../bin/xzormtst_pt  -m 1 500   -n 1 500 -a 200 -S 1 R  -U 1 l -# 1 -x R -y N  -z 300
../bin/xzormtst_pt  -m 1 600   -n 1 501 -a 200 -S 1 R  -U 1 l -# 1 -x R -y N  -z 500
../bin/xzormtst_pt  -m 1 502   -n 1 600 -a 200 -S 1 R  -U 1 l -# 1 -x R -y N  -z 100
../bin/xzormtst_pt  -m 1 60    -n 1 128 -a 200 -S 1 R  -U 1 l -# 1 -x R -y N  -z 200
../bin/xzormtst_pt  -m 1 550   -n 1 550 -a 200 -S 1 R  -U 1 l -# 1 -x R -y N  -z 220
../bin/xzormtst_pt  -m 1 800   -n 1 800 -a 200 -S 1 R  -U 1 l -# 1 -x R -y N  -z 100

#LQ
../bin/xsormtst_pt  -m 1 800   -n 1 128 -a 200 -S 1 L  -U 1 l -# 1   -x R -y N  -z 100
../bin/xsormtst_pt  -m 1 2800   -n 1 1282 -a 200 -S 1 L  -U 1 l -# 1 -x R -y N  -z 100
../bin/xsormtst_pt  -m 1 500   -n 1 500 -a 200 -S 1 L  -U 1 l -# 1   -x R -y N  -z 200
../bin/xsormtst_pt  -m 1 600   -n 1 501 -a 200 -S 1 L  -U 1 l -# 1   -x R -y N  -z 300
../bin/xsormtst_pt  -m 1 502   -n 1 600 -a 200 -S 1 L  -U 1 l -# 1   -x R -y N  -z 400
../bin/xsormtst_pt  -m 1 60   -n 1 128 -a 200 -S 1 L  -U 1 l -# 1    -x R -y N  -z 300
../bin/xsormtst_pt  -m 1 550   -n 1 550 -a 200 -S 1 L  -U 1 l -# 1   -x R -y N  -z 200
../bin/xsormtst_pt  -m 1 800   -n 1 800 -a 200 -S 1 L  -U 1 l -# 1   -x R -y N  -z 400

../bin/xdormtst_pt  -m 1 800   -n 1 128 -a 200 -S 1 L  -U 1 l -# 1   -x R -y N  -z 100
../bin/xdormtst_pt  -m 1 2800   -n 1 1128 -a 200 -S 1 L  -U 1 l -# 1 -x R -y N  -z 200
../bin/xdormtst_pt  -m 1 500   -n 1 500 -a 200 -S 1 L  -U 1 l -# 1   -x R -y N  -z 100
../bin/xdormtst_pt  -m 1 600   -n 1 501 -a 200 -S 1 L  -U 1 l -# 1   -x R -y N  -z 500
../bin/xdormtst_pt  -m 1 502   -n 1 600 -a 200 -S 1 L  -U 1 l -# 1   -x R -y N  -z 100
../bin/xdormtst_pt  -m 1 60   -n 1 128 -a 200 -S 1 L  -U 1 l -# 1    -x R -y N  -z 100
../bin/xdormtst_pt  -m 1 550   -n 1 550 -a 200 -S 1 L  -U 1 l -# 1   -x R -y N  -z 300
../bin/xdormtst_pt  -m 1 800   -n 1 800 -a 200 -S 1 L  -U 1 l -# 1   -x R -y N  -z 100

../bin/xcormtst_pt  -m 1 800   -n 1 128 -a 200 -S 1 L  -U 1 l -# 1  -x R -y N  -z 100
../bin/xcormtst_pt  -m 1 800   -n 1 1280 -a 200 -S 1 L -U 1 l -# 1  -x R -y N  -z 100
../bin/xcormtst_pt  -m 1 500   -n 1 500 -a 200 -S 1 L  -U 1 l -# 1  -x R -y N  -z 100
../bin/xcormtst_pt  -m 1 600   -n 1 501 -a 200 -S 1 L  -U 1 l -# 1  -x R -y N  -z 100
../bin/xcormtst_pt  -m 1 502   -n 1 600 -a 200 -S 1 L  -U 1 l -# 1  -x R -y N  -z 100
../bin/xcormtst_pt  -m 1 60    -n 1 128 -a 200 -S 1 L  -U 1 l -# 1  -x R -y N  -z 100
../bin/xcormtst_pt  -m 1 550   -n 1 550 -a 200 -S 1 L  -U 1 l -# 1  -x R -y N  -z 100
../bin/xcormtst_pt  -m 1 800   -n 1 800 -a 200 -S 1 L  -U 1 l -# 1  -x R -y N  -z 100

../bin/xzormtst_pt  -m 1 800   -n 1 128 -a 200 -S 1 L  -U 1 l -# 1 -x R -y N  -z 100
../bin/xzormtst_pt  -m 1 500   -n 1 500 -a 200 -S 1 L  -U 1 l -# 1 -x R -y N  -z 300
../bin/xzormtst_pt  -m 1 600   -n 1 501 -a 200 -S 1 L  -U 1 l -# 1 -x R -y N  -z 500
../bin/xzormtst_pt  -m 1 502   -n 1 600 -a 200 -S 1 L  -U 1 l -# 1 -x R -y N  -z 100
../bin/xzormtst_pt  -m 1 60    -n 1 128 -a 200 -S 1 L  -U 1 l -# 1 -x R -y N  -z 200
../bin/xzormtst_pt  -m 1 550   -n 1 550 -a 200 -S 1 L  -U 1 l -# 1 -x R -y N  -z 220
../bin/xzormtst_pt  -m 1 800   -n 1 800 -a 200 -S 1 L  -U 1 l -# 1 -x R -y N  -z 100

#RQ

../bin/xsormtst_pt  -m 1 800   -n 1 128 -a 200 -S 1 L  -U 1 u -# 1   -x R -y N  -z 100
../bin/xsormtst_pt  -m 1 2800   -n 1 1282 -a 200 -S 1 L  -U 1 u -# 1 -x R -y N  -z 100
../bin/xsormtst_pt  -m 1 500   -n 1 500 -a 200 -S 1 L  -U 1 u -# 1   -x R -y N  -z 200
../bin/xsormtst_pt  -m 1 600   -n 1 501 -a 200 -S 1 L  -U 1 u -# 1   -x R -y N  -z 300
../bin/xsormtst_pt  -m 1 502   -n 1 600 -a 200 -S 1 L  -U 1 u -# 1   -x R -y N  -z 400
../bin/xsormtst_pt  -m 1 60   -n 1 128 -a 200 -S 1 L  -U 1 u -# 1    -x R -y N  -z 300
../bin/xsormtst_pt  -m 1 550   -n 1 550 -a 200 -S 1 L  -U 1 u -# 1   -x R -y N  -z 200
../bin/xsormtst_pt  -m 1 800   -n 1 800 -a 200 -S 1 L  -U 1 u -# 1   -x R -y N  -z 400

../bin/xdormtst_pt  -m 1 800   -n 1 128 -a 200 -S 1 L  -U 1 u -# 1   -x R -y N  -z 100
../bin/xdormtst_pt  -m 1 2800   -n 1 1128 -a 200 -S 1 L  -U 1 u -# 1 -x R -y N  -z 200
../bin/xdormtst_pt  -m 1 500   -n 1 500 -a 200 -S 1 L  -U 1 u -# 1   -x R -y N  -z 100
../bin/xdormtst_pt  -m 1 600   -n 1 501 -a 200 -S 1 L  -U 1 u -# 1   -x R -y N  -z 500
../bin/xdormtst_pt  -m 1 502   -n 1 600 -a 200 -S 1 L  -U 1 u -# 1   -x R -y N  -z 100
../bin/xdormtst_pt  -m 1 60   -n 1 128 -a 200 -S 1 L  -U 1 u -# 1    -x R -y N  -z 100
../bin/xdormtst_pt  -m 1 550   -n 1 550 -a 200 -S 1 L  -U 1 u -# 1   -x R -y N  -z 300
../bin/xdormtst_pt  -m 1 800   -n 1 800 -a 200 -S 1 L  -U 1 u -# 1   -x R -y N  -z 100

../bin/xcormtst_pt  -m 1 800   -n 1 128 -a 200 -S 1 L  -U 1 u -# 1  -x R -y N  -z 100
../bin/xcormtst_pt  -m 1 800   -n 1 1280 -a 200 -S 1 L -U 1 u -# 1  -x R -y N  -z 100
../bin/xcormtst_pt  -m 1 500   -n 1 500 -a 200 -S 1 L  -U 1 u -# 1  -x R -y N  -z 100
../bin/xcormtst_pt  -m 1 600   -n 1 501 -a 200 -S 1 L  -U 1 u -# 1  -x R -y N  -z 100
../bin/xcormtst_pt  -m 1 502   -n 1 600 -a 200 -S 1 L  -U 1 u -# 1  -x R -y N  -z 100
../bin/xcormtst_pt  -m 1 60    -n 1 128 -a 200 -S 1 L  -U 1 u -# 1  -x R -y N  -z 100
../bin/xcormtst_pt  -m 1 550   -n 1 550 -a 200 -S 1 L  -U 1 u -# 1  -x R -y N  -z 100
../bin/xcormtst_pt  -m 1 800   -n 1 800 -a 200 -S 1 L  -U 1 u -# 1  -x R -y N  -z 100

../bin/xzormtst_pt  -m 1 800   -n 1 128 -a 200 -S 1 L  -U 1 u -# 1 -x R -y N  -z 100
../bin/xzormtst_pt  -m 1 500   -n 1 500 -a 200 -S 1 L  -U 1 u -# 1 -x R -y N  -z 300
../bin/xzormtst_pt  -m 1 600   -n 1 501 -a 200 -S 1 L  -U 1 u -# 1 -x R -y N  -z 500
../bin/xzormtst_pt  -m 1 502   -n 1 600 -a 200 -S 1 L  -U 1 u -# 1 -x R -y N  -z 100
../bin/xzormtst_pt  -m 1 60    -n 1 128 -a 200 -S 1 L  -U 1 u -# 1 -x R -y N  -z 200
../bin/xzormtst_pt  -m 1 550   -n 1 550 -a 200 -S 1 L  -U 1 u -# 1 -x R -y N  -z 220
../bin/xzormtst_pt  -m 1 800   -n 1 800 -a 200 -S 1 L  -U 1 u -# 1 -x R -y N  -z 100

#QR -x R -y T
#--------------------------x R -y T----------------------------------------------
../bin/xsormtst_pt  -m 1 800   -n 1 128 -a 200 -S 1 R  -U 1 u -# 1   -x R -y T  -z 100
../bin/xsormtst_pt  -m 1 2800   -n 1 1282 -a 200 -S 1 R  -U 1 u -# 1 -x R -y T  -z 100
../bin/xsormtst_pt  -m 1 500   -n 1 500 -a 200 -S 1 R  -U 1 u -# 1   -x R -y T  -z 200
../bin/xsormtst_pt  -m 1 600   -n 1 501 -a 200 -S 1 R  -U 1 u -# 1   -x R -y T  -z 300
../bin/xsormtst_pt  -m 1 502   -n 1 600 -a 200 -S 1 R  -U 1 u -# 1   -x R -y T  -z 400
../bin/xsormtst_pt  -m 1 60   -n 1 128 -a 200 -S 1 R  -U 1 u -# 1    -x R -y T  -z 300
../bin/xsormtst_pt  -m 1 550   -n 1 550 -a 200 -S 1 R  -U 1 u -# 1   -x R -y T  -z 200
../bin/xsormtst_pt  -m 1 800   -n 1 800 -a 200 -S 1 R  -U 1 u -# 1   -x R -y T  -z 400


../bin/xdormtst_pt  -m 1 800   -n 1 128 -a 200 -S 1 R  -U 1 u -# 1   -x R -y T  -z 100
../bin/xdormtst_pt  -m 1 2800   -n 1 1128 -a 200 -S 1 R  -U 1 u -# 1 -x R -y T  -z 200
../bin/xdormtst_pt  -m 1 500   -n 1 500 -a 200 -S 1 R  -U 1 u -# 1   -x R -y T  -z 100
../bin/xdormtst_pt  -m 1 600   -n 1 501 -a 200 -S 1 R  -U 1 u -# 1   -x R -y T  -z 500
../bin/xdormtst_pt  -m 1 502   -n 1 600 -a 200 -S 1 R  -U 1 u -# 1   -x R -y T  -z 100
../bin/xdormtst_pt  -m 1 60   -n 1 128 -a 200 -S 1 R  -U 1 u -# 1    -x R -y T  -z 100
../bin/xdormtst_pt  -m 1 550   -n 1 550 -a 200 -S 1 R  -U 1 u -# 1   -x R -y T  -z 300
../bin/xdormtst_pt  -m 1 800   -n 1 800 -a 200 -S 1 R  -U 1 u -# 1   -x R -y T  -z 100


../bin/xcormtst_pt  -m 1 800   -n 1 128 -a 200 -S 1 R  -U 1 u -# 1  -x R -y T  -z 100
../bin/xcormtst_pt  -m 1 800   -n 1 1280 -a 200 -S 1 R -U 1 u -# 1  -x R -y T  -z 100
../bin/xcormtst_pt  -m 1 500   -n 1 500 -a 200 -S 1 R  -U 1 u -# 1  -x R -y T  -z 100
../bin/xcormtst_pt  -m 1 600   -n 1 501 -a 200 -S 1 R  -U 1 u -# 1  -x R -y T  -z 100
../bin/xcormtst_pt  -m 1 502   -n 1 600 -a 200 -S 1 R  -U 1 u -# 1  -x R -y T  -z 100
../bin/xcormtst_pt  -m 1 60    -n 1 128 -a 200 -S 1 R  -U 1 u -# 1  -x R -y T  -z 100
../bin/xcormtst_pt  -m 1 550   -n 1 550 -a 200 -S 1 R  -U 1 u -# 1  -x R -y T  -z 100
../bin/xcormtst_pt  -m 1 800   -n 1 800 -a 200 -S 1 R  -U 1 u -# 1  -x R -y T  -z 100


../bin/xzormtst_pt  -m 1 800   -n 1 128 -a 200 -S 1 R  -U 1 u -# 1 -x R -y T  -z 100
../bin/xzormtst_pt  -m 1 500   -n 1 500 -a 200 -S 1 R  -U 1 u -# 1 -x R -y T  -z 300
../bin/xzormtst_pt  -m 1 600   -n 1 501 -a 200 -S 1 R  -U 1 u -# 1 -x R -y T  -z 500
../bin/xzormtst_pt  -m 1 502   -n 1 600 -a 200 -S 1 R  -U 1 u -# 1 -x R -y T  -z 100
../bin/xzormtst_pt  -m 1 60    -n 1 128 -a 200 -S 1 R  -U 1 u -# 1 -x R -y T  -z 200
../bin/xzormtst_pt  -m 1 550   -n 1 550 -a 200 -S 1 R  -U 1 u -# 1 -x R -y T  -z 220
../bin/xzormtst_pt  -m 1 800   -n 1 800 -a 200 -S 1 R  -U 1 u -# 1 -x R -y T  -z 100

#QL
../bin/xsormtst_pt  -m 1 800   -n 1 128 -a 200 -S 1 R  -U 1 l -# 1   -x R -y T  -z 100
../bin/xsormtst_pt  -m 1 2800   -n 1 1282 -a 200 -S 1 R  -U 1 l -# 1 -x R -y T  -z 100
../bin/xsormtst_pt  -m 1 500   -n 1 500 -a 200 -S 1 R  -U 1 l -# 1   -x R -y T  -z 200
../bin/xsormtst_pt  -m 1 600   -n 1 501 -a 200 -S 1 R  -U 1 l -# 1   -x R -y T  -z 300
../bin/xsormtst_pt  -m 1 502   -n 1 600 -a 200 -S 1 R  -U 1 l -# 1   -x R -y T  -z 400
../bin/xsormtst_pt  -m 1 60   -n 1 128 -a 200 -S 1 R  -U 1 l -# 1    -x R -y T  -z 300
../bin/xsormtst_pt  -m 1 550   -n 1 550 -a 200 -S 1 R  -U 1 l -# 1   -x R -y T  -z 200
../bin/xsormtst_pt  -m 1 800   -n 1 800 -a 200 -S 1 R  -U 1 l -# 1   -x R -y T  -z 400


../bin/xdormtst_pt  -m 1 800   -n 1 128 -a 200 -S 1 R  -U 1 l -# 1   -x R -y T  -z 100
../bin/xdormtst_pt  -m 1 2800   -n 1 1128 -a 200 -S 1 R  -U 1 l -# 1 -x R -y T  -z 200
../bin/xdormtst_pt  -m 1 500   -n 1 500 -a 200 -S 1 R  -U 1 l -# 1   -x R -y T  -z 100
../bin/xdormtst_pt  -m 1 600   -n 1 501 -a 200 -S 1 R  -U 1 l -# 1   -x R -y T  -z 500
../bin/xdormtst_pt  -m 1 502   -n 1 600 -a 200 -S 1 R  -U 1 l -# 1   -x R -y T  -z 100
../bin/xdormtst_pt  -m 1 60   -n 1 128 -a 200 -S 1 R  -U 1 l -# 1    -x R -y T  -z 100
../bin/xdormtst_pt  -m 1 550   -n 1 550 -a 200 -S 1 R  -U 1 l -# 1   -x R -y T  -z 300
../bin/xdormtst_pt  -m 1 800   -n 1 800 -a 200 -S 1 R  -U 1 l -# 1   -x R -y T  -z 100


../bin/xcormtst_pt  -m 1 800   -n 1 128 -a 200 -S 1 R  -U 1 l -# 1  -x R -y T  -z 100
../bin/xcormtst_pt  -m 1 800   -n 1 1280 -a 200 -S 1 R -U 1 l -# 1  -x R -y T  -z 100
../bin/xcormtst_pt  -m 1 500   -n 1 500 -a 200 -S 1 R  -U 1 l -# 1  -x R -y T  -z 100
../bin/xcormtst_pt  -m 1 600   -n 1 501 -a 200 -S 1 R  -U 1 l -# 1  -x R -y T  -z 100
../bin/xcormtst_pt  -m 1 502   -n 1 600 -a 200 -S 1 R  -U 1 l -# 1  -x R -y T  -z 100
../bin/xcormtst_pt  -m 1 60    -n 1 128 -a 200 -S 1 R  -U 1 l -# 1  -x R -y T  -z 100
../bin/xcormtst_pt  -m 1 550   -n 1 550 -a 200 -S 1 R  -U 1 l -# 1  -x R -y T  -z 100
../bin/xcormtst_pt  -m 1 800   -n 1 800 -a 200 -S 1 R  -U 1 l -# 1  -x R -y T  -z 100


../bin/xzormtst_pt  -m 1 800   -n 1 128 -a 200 -S 1 R  -U 1 l -# 1 -x R -y T  -z 100
../bin/xzormtst_pt  -m 1 500   -n 1 500 -a 200 -S 1 R  -U 1 l -# 1 -x R -y T  -z 300
../bin/xzormtst_pt  -m 1 600   -n 1 501 -a 200 -S 1 R  -U 1 l -# 1 -x R -y T  -z 500
../bin/xzormtst_pt  -m 1 502   -n 1 600 -a 200 -S 1 R  -U 1 l -# 1 -x R -y T  -z 100
../bin/xzormtst_pt  -m 1 60    -n 1 128 -a 200 -S 1 R  -U 1 l -# 1 -x R -y T  -z 200
../bin/xzormtst_pt  -m 1 550   -n 1 550 -a 200 -S 1 R  -U 1 l -# 1 -x R -y T  -z 220
../bin/xzormtst_pt  -m 1 800   -n 1 800 -a 200 -S 1 R  -U 1 l -# 1 -x R -y T  -z 100

#LQ
../bin/xsormtst_pt  -m 1 800   -n 1 128 -a 200 -S 1 L  -U 1 l -# 1   -x R -y T  -z 100
../bin/xsormtst_pt  -m 1 2800   -n 1 1282 -a 200 -S 1 L  -U 1 l -# 1 -x R -y T  -z 100
../bin/xsormtst_pt  -m 1 500   -n 1 500 -a 200 -S 1 L  -U 1 l -# 1   -x R -y T  -z 200
../bin/xsormtst_pt  -m 1 600   -n 1 501 -a 200 -S 1 L  -U 1 l -# 1   -x R -y T  -z 300
../bin/xsormtst_pt  -m 1 502   -n 1 600 -a 200 -S 1 L  -U 1 l -# 1   -x R -y T  -z 400
../bin/xsormtst_pt  -m 1 60   -n 1 128 -a 200 -S 1 L  -U 1 l -# 1    -x R -y T  -z 300
../bin/xsormtst_pt  -m 1 550   -n 1 550 -a 200 -S 1 L  -U 1 l -# 1   -x R -y T  -z 200
../bin/xsormtst_pt  -m 1 800   -n 1 800 -a 200 -S 1 L  -U 1 l -# 1   -x R -y T  -z 400

../bin/xdormtst_pt  -m 1 800   -n 1 128 -a 200 -S 1 L  -U 1 l -# 1   -x R -y T  -z 100
../bin/xdormtst_pt  -m 1 2800   -n 1 1128 -a 200 -S 1 L  -U 1 l -# 1 -x R -y T  -z 200
../bin/xdormtst_pt  -m 1 500   -n 1 500 -a 200 -S 1 L  -U 1 l -# 1   -x R -y T  -z 100
../bin/xdormtst_pt  -m 1 600   -n 1 501 -a 200 -S 1 L  -U 1 l -# 1   -x R -y T  -z 500
../bin/xdormtst_pt  -m 1 502   -n 1 600 -a 200 -S 1 L  -U 1 l -# 1   -x R -y T  -z 100
../bin/xdormtst_pt  -m 1 60   -n 1 128 -a 200 -S 1 L  -U 1 l -# 1    -x R -y T  -z 100
../bin/xdormtst_pt  -m 1 550   -n 1 550 -a 200 -S 1 L  -U 1 l -# 1   -x R -y T  -z 300
../bin/xdormtst_pt  -m 1 800   -n 1 800 -a 200 -S 1 L  -U 1 l -# 1   -x R -y T  -z 100

../bin/xcormtst_pt  -m 1 800   -n 1 128 -a 200 -S 1 L  -U 1 l -# 1  -x R -y T  -z 100
../bin/xcormtst_pt  -m 1 800   -n 1 1280 -a 200 -S 1 L -U 1 l -# 1  -x R -y T  -z 100
../bin/xcormtst_pt  -m 1 500   -n 1 500 -a 200 -S 1 L  -U 1 l -# 1  -x R -y T  -z 100
../bin/xcormtst_pt  -m 1 600   -n 1 501 -a 200 -S 1 L  -U 1 l -# 1  -x R -y T  -z 100
../bin/xcormtst_pt  -m 1 502   -n 1 600 -a 200 -S 1 L  -U 1 l -# 1  -x R -y T  -z 100
../bin/xcormtst_pt  -m 1 60    -n 1 128 -a 200 -S 1 L  -U 1 l -# 1  -x R -y T  -z 100
../bin/xcormtst_pt  -m 1 550   -n 1 550 -a 200 -S 1 L  -U 1 l -# 1  -x R -y T  -z 100
../bin/xcormtst_pt  -m 1 800   -n 1 800 -a 200 -S 1 L  -U 1 l -# 1  -x R -y T  -z 100

../bin/xzormtst_pt  -m 1 800   -n 1 128 -a 200 -S 1 L  -U 1 l -# 1 -x R -y T  -z 100
../bin/xzormtst_pt  -m 1 500   -n 1 500 -a 200 -S 1 L  -U 1 l -# 1 -x R -y T  -z 300
../bin/xzormtst_pt  -m 1 600   -n 1 501 -a 200 -S 1 L  -U 1 l -# 1 -x R -y T  -z 500
../bin/xzormtst_pt  -m 1 502   -n 1 600 -a 200 -S 1 L  -U 1 l -# 1 -x R -y T  -z 100
../bin/xzormtst_pt  -m 1 60    -n 1 128 -a 200 -S 1 L  -U 1 l -# 1 -x R -y T  -z 200
../bin/xzormtst_pt  -m 1 550   -n 1 550 -a 200 -S 1 L  -U 1 l -# 1 -x R -y T  -z 220
../bin/xzormtst_pt  -m 1 800   -n 1 800 -a 200 -S 1 L  -U 1 l -# 1 -x R -y T  -z 100

#RQ

../bin/xsormtst_pt  -m 1 800   -n 1 128 -a 200 -S 1 L  -U 1 u -# 1   -x R -y T  -z 100
../bin/xsormtst_pt  -m 1 2800   -n 1 1282 -a 200 -S 1 L  -U 1 u -# 1 -x R -y T  -z 100
../bin/xsormtst_pt  -m 1 500   -n 1 500 -a 200 -S 1 L  -U 1 u -# 1   -x R -y T  -z 200
../bin/xsormtst_pt  -m 1 600   -n 1 501 -a 200 -S 1 L  -U 1 u -# 1   -x R -y T  -z 300
../bin/xsormtst_pt  -m 1 502   -n 1 600 -a 200 -S 1 L  -U 1 u -# 1   -x R -y T  -z 400
../bin/xsormtst_pt  -m 1 60   -n 1 128 -a 200 -S 1 L  -U 1 u -# 1    -x R -y T  -z 300
../bin/xsormtst_pt  -m 1 550   -n 1 550 -a 200 -S 1 L  -U 1 u -# 1   -x R -y T  -z 200
../bin/xsormtst_pt  -m 1 800   -n 1 800 -a 200 -S 1 L  -U 1 u -# 1   -x R -y T  -z 400

../bin/xdormtst_pt  -m 1 800   -n 1 128 -a 200 -S 1 L  -U 1 u -# 1   -x R -y T  -z 100
../bin/xdormtst_pt  -m 1 2800   -n 1 1128 -a 200 -S 1 L  -U 1 u -# 1 -x R -y T  -z 200
../bin/xdormtst_pt  -m 1 500   -n 1 500 -a 200 -S 1 L  -U 1 u -# 1   -x R -y T  -z 100
../bin/xdormtst_pt  -m 1 600   -n 1 501 -a 200 -S 1 L  -U 1 u -# 1   -x R -y T  -z 500
../bin/xdormtst_pt  -m 1 502   -n 1 600 -a 200 -S 1 L  -U 1 u -# 1   -x R -y T  -z 100
../bin/xdormtst_pt  -m 1 60   -n 1 128 -a 200 -S 1 L  -U 1 u -# 1    -x R -y T  -z 100
../bin/xdormtst_pt  -m 1 550   -n 1 550 -a 200 -S 1 L  -U 1 u -# 1   -x R -y T  -z 300
../bin/xdormtst_pt  -m 1 800   -n 1 800 -a 200 -S 1 L  -U 1 u -# 1   -x R -y T  -z 100

../bin/xcormtst_pt  -m 1 800   -n 1 128 -a 200 -S 1 L  -U 1 u -# 1  -x R -y T  -z 100
../bin/xcormtst_pt  -m 1 800   -n 1 1280 -a 200 -S 1 L -U 1 u -# 1  -x R -y T  -z 100
../bin/xcormtst_pt  -m 1 500   -n 1 500 -a 200 -S 1 L  -U 1 u -# 1  -x R -y T  -z 100
../bin/xcormtst_pt  -m 1 600   -n 1 501 -a 200 -S 1 L  -U 1 u -# 1  -x R -y T  -z 100
../bin/xcormtst_pt  -m 1 502   -n 1 600 -a 200 -S 1 L  -U 1 u -# 1  -x R -y T  -z 100
../bin/xcormtst_pt  -m 1 60    -n 1 128 -a 200 -S 1 L  -U 1 u -# 1  -x R -y T  -z 100
../bin/xcormtst_pt  -m 1 550   -n 1 550 -a 200 -S 1 L  -U 1 u -# 1  -x R -y T  -z 100
../bin/xcormtst_pt  -m 1 800   -n 1 800 -a 200 -S 1 L  -U 1 u -# 1  -x R -y T  -z 100

../bin/xzormtst_pt  -m 1 800   -n 1 128 -a 200 -S 1 L  -U 1 u -# 1 -x R -y T  -z 100
../bin/xzormtst_pt  -m 1 500   -n 1 500 -a 200 -S 1 L  -U 1 u -# 1 -x R -y T  -z 300
../bin/xzormtst_pt  -m 1 600   -n 1 501 -a 200 -S 1 L  -U 1 u -# 1 -x R -y T  -z 500
../bin/xzormtst_pt  -m 1 502   -n 1 600 -a 200 -S 1 L  -U 1 u -# 1 -x R -y T  -z 100
../bin/xzormtst_pt  -m 1 60    -n 1 128 -a 200 -S 1 L  -U 1 u -# 1 -x R -y T  -z 200
../bin/xzormtst_pt  -m 1 550   -n 1 550 -a 200 -S 1 L  -U 1 u -# 1 -x R -y T  -z 220
../bin/xzormtst_pt  -m 1 800   -n 1 800 -a 200 -S 1 L  -U 1 u -# 1 -x R -y T  -z 100
@ROUT atlas_qrrmeth.h
#ifndef ATLAS_QRRMETH_H
   #define ATLAS_QRRMETH_H
#include "atlas_pca.h"
#include "atlas_cache.h"
/*
 * PCA does not work reliably on ARMv7
 */
#ifndef ATL_USEPCA
   #define FORCE_NO_PCA 1
#endif
#if !defined(ATL_USEPTHREADS) || defined(FORCE_NO_PCA)
/*
 * If PCA is not an option, we use unblocked if either diminsion is too small
 * to allow us to reliably register block the L3BLAS, or if we can fit the
 * entire problem into the L1 cache.  All other problems recur.
 */
   #define METHOD(METH_, M_, N_, LDA_) /* 0,1,2,3=Recur,Unblkd,Cp,NoC      */ \
      (METH_)=( (N_ < 8) || (M_ < 8) || (((size_t)M_)*N <= L1C_ELTS) ) ? 1:0;
#else
   #if !defined(CacheEdge) || CacheEdge <=0 || CacheEdge >= 8*1024*1024
      #define MyCacheEdge (ATL_NTHREADS*(size_t)256*1024) /* collective edge */
   #else
      #define MyCacheEdge (ATL_NTHREADS*(size_t)CacheEdge) /* collective edge */
   #endif
/*
 * BIGM is the # of elts we need to force no-copy-PCA even in when we don't
 * fit into the collective cache and N is very small.  In this rule of thumb,
 * we set it to roughly the page size
 */
   #define ATL_PCA_BIGM (ATL_DivBySize(4096))
/*
 * MINM is an estimate of the min local M we can have that will amortize
 * the parallel sync costs.  These numbers will need to be refined.
 */
   #ifdef SREAL
      #define ATL_PCA_MINM 256
   #elif defined(DREAL)
      #define ATL_PCA_MINM 128
   #elif defined(SCPLX)
      #define ATL_PCA_MINM 96
   #else
      #define ATL_PCA_MINM 64
   #endif
/* 
 * Note: Expect M_ to be static dimension, N_ to be recursing dimension.
 */
   #define METHOD(METH_, M_, N_, LDA_) /* 0,1,2,3=Recur,unblck,Cp,NoC      */ \
   {                                                                          \
      METH_ = 0;                       /* default to recursion */ \
/* \
 *    If N_ is too small to get advantage from register blocking, stop recurs \
 *    and use NoCopy-PCA for huge M otherwise use unblocked \
 */ \
      if (N_ < 4) \
      { \
         METH_ = ((M_) > (ATL_PCA_BIGM<<Mmin(3,ATL_NTHRPOW2))) ? 3 : 1; \
      } \
/* \
 *    Don't consider PCA or unblocked unless problem fits in collective cache
 */ \
      if (MyCacheEdge >= ATL_MulBySize(M_)*N_) \
      { \
         const int zrows = Mmax(((M_)>>ATL_NTHRPOW2),Mmin(M_, N_));  \
                                            /* # of rows zero must take */ \
         const int rrows = (M_) - zrows;    /* # of rows for non-0 to take */ \
         METH_ = 2;   /* default to Cp-PCA if it fits in cache */ \
/* \
 *       If it fits in the L1, or if the number of local rows is too small
 *       to bear the cost of synchronization, use normal unblocked algorithm
 */ \
         if ( (((size_t)M_)*N_ <= L1C_ELTS) ||  /* Fits in L1, */ \
              (M_) < ATL_PCA_MINM ||           /* Total rows very small, */ \
              ((M_)>>ATL_NTHRPOW2) < 3 ||      /* Too few per core, */ \
              (rrows<<3) < zrows )             /* Rmndr too small % to help */ \
            METH_ = 1;                         /* Use unblocked. */ \
      } \
   } /* END METHOD MACRO */
#endif                          /* end if on threading or not */

#endif /* end multiple inclusion guard */

